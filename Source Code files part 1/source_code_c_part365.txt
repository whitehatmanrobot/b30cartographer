           TRUE );     //  already locked
    IF_NOMEM( !premote )
    {
        goto Done;
    }

    //
    //  reset response time or timeout
    //
    //  Best scoring:
    //      - keep fastest to give "idea" of best we can expect for working
    //      back in
    //
    //      then as time goes by "score" of timeouts drops, until brought
    //      back down below score of non-timeout but higher servers,
    //      however drop must depend not just on time but on low score
    //      so that quickly retry if very big spread (ms vs. secs) but
    //      don't retry on small spread
    //
    //  Never record a BestResponse of zero - if zero set it to one instead
    //  so we can easily distinguish a fast server from an untried server.
    //

    premote->LastAccess = DNS_TIME();

    if ( Timeout )
    {
        ASSERT( ResponseTime == 0 );

        premote->TimeoutCount++;
        premote->BestResponse = NO_RESPONSE_PRIORITY;
    }
    else
    {
        if ( !ResponseTime )
        {
            ResponseTime = 1;
        }
        premote->ResponseCount++;
        if ( !premote->BestResponse || ResponseTime < premote->BestResponse )
        {
            premote->BestResponse = ResponseTime;
        }
    }

    premote->AverageResponse =
        ( ResponseTime + premote->AverageResponse ) / 2;

Done:

    UNLOCK_REMOTE();
}



UCHAR 
Remote_QuerySupportedEDnsVersion(
    IN      PDNS_ADDR       pDnsAddr
    )
/*++

Routine Description:

    Queries the remote server list for EDNS version supported by
    a particular server.

Arguments:

    IpAddress -- IP to find

Return Value:

    UNKNOWN_EDNS_VERSION if we do not know what version of EDNS is
        supported by the remote, or
    NO_EDNS_SUPPORT if the remote does not support any version of EDNS, or
    the EDNS version supported (0, 1, 2, etc.)

--*/
{
    PREMOTE_SRV     premote;
    UCHAR           ednsVersion = UNKNOWN_EDNS_VERSION;

    //
    //  find remote entry
    //

    LOCK_REMOTE();

    premote = Remote_FindOrCreate(
        pDnsAddr,
        TRUE,       // create
        TRUE );     // already locked
    IF_NOMEM( !premote )
    {
        goto Done;
    }

    //
    //  Figure out what we know about this remote's EDNS support. If the info
    //  has not been set or has expired, return UNKNOWN_EDNS_VERSION.
    //

    if ( premote->LastTimeEDnsVersionSet == 0 ||
         DNS_TIME() - premote->LastTimeEDnsVersionSet > SrvCfg_dwEDnsCacheTimeout )
    {
        ednsVersion = UNKNOWN_EDNS_VERSION;
    } // if
    else
    {
        ednsVersion = premote->EDnsVersion;
    } // else

Done:

    UNLOCK_REMOTE();

    DNS_DEBUG( EDNS, (
        "Remote_QuerySupportedEDnsVersion( %s ) = %d\n",
        DNSADDR_STRING( pDnsAddr ),
        ( int ) ednsVersion ));

    return ednsVersion;
} // Remote_QuerySupportedEDnsVersion



VOID
Remote_SetSupportedEDnsVersion(
    IN      PDNS_ADDR       pDnsAddr,
    IN      UCHAR           EDnsVersion
    )
/*++

Routine Description:

    Sets the EDNS version supported by a particular remote server.

Arguments:

    pDnsAddr -- IP of remote server
    
    EDnsVersion -- EDNS version supported by this remote

Return Value:

    None.

--*/
{
    PREMOTE_SRV     premote;

    DNS_DEBUG( EDNS, (
        "Remote_SetSupportedEDnsVersion( %s, %d )\n",
        DNSADDR_STRING( pDnsAddr ),
        ( int ) EDnsVersion ));

    //  sanity check the version value
    ASSERT( IS_VALID_EDNS_VERSION( EDnsVersion ) ||
            EDnsVersion == NO_EDNS_SUPPORT );

    //
    //  find remote entry
    //

    LOCK_REMOTE();

    premote = Remote_FindOrCreate(
                    pDnsAddr,
                    TRUE,       // create
                    TRUE );     // already locked
    IF_NOMEM( !premote )
    {
        goto Done;
    }

    //
    //  Set the remote's supported EDNS version and update the timestamp.
    //

    premote->EDnsVersion = EDnsVersion;
    premote->LastTimeEDnsVersionSet = DNS_TIME();

Done:

    UNLOCK_REMOTE();

    return;
} // Remote_SetSupportedEDnsVersion



BOOL
Remote_ListInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize remote list.

Arguments:

    None.

Return Value:

    TRUE/FALSE on success/error.

--*/
{
    //
    //  Zero hash
    //

    RtlZeroMemory(
        RemoteHash,
        sizeof(RemoteHash) );
    //
    //  Initialize lock
    //
    //  DEVNOTE: Minor leak: should skip CS reinit on restart
    //

    if ( DnsInitializeCriticalSection( &csRemoteLock ) != ERROR_SUCCESS )
    {
        return FALSE;
    }

    return TRUE;
}



VOID
Remote_ListCleanup(
    VOID
    )
/*++

Routine Description:

    Initialize remote list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DeleteCriticalSection( &csRemoteLock );
}



//
//  Applied remote list routines
//
//  Building recursion visit lists
//

DWORD
rankIpRelativeToIpAddressArray(
    IN      PDNS_ADDR_ARRAY     pDnsAddrArray,
    IN      PDNS_ADDR           pRemoteIp
    )
/*++

Routine Description:

    Ranks remote IP relative to best match IP in IP array.

Arguments:

    pDnsAddrArray -- IP array to match against

    pRemoteIp -- IP to rank

Return Value:

    Rank of IP relative to array on 0-4 scale:
        Zero -- IP has nothing to do with array.
        ...
        Four -- IP matches through last octet an is likely quite "cheap" to access.

--*/
{
    IP_ADDRESS  ip;
    DWORD       remoteNetMask;
    DWORD       mismatch;
    DWORD       i;
    DWORD       rank;
    DWORD       bestRank = 0;

    DNS_DEBUG( RECURSE, (
        "Rank IP %p relative to %d count IP array at %p\n",
        DNSADDR_STRING( pRemoteIp ),
        pDnsAddrArray->AddrCount,
        pDnsAddrArray ));

    //  FIXIPV6: this is implemented only for IP4 addresses!

    ip = DnsAddr_GetIp4( pRemoteIp );
    if ( ip == INADDR_NONE )
    {
        DNS_DEBUG( RECURSE, (
            "Remote IP %s is not IPv4!\n",
            DNSADDR_STRING( pRemoteIp ) ));
        ASSERT( ip != INADDR_NONE );
        goto Done;
    }
    
    //
    //  determine remote IP mask
    //

    remoteNetMask = Dns_GetNetworkMask( ip );

    for ( i = 0; i < pDnsAddrArray->AddrCount; ++i )
    {
        ip = DnsAddr_GetIp4( &pDnsAddrArray->AddrArray[ i ] );

        ASSERT( ip != INADDR_NONE );        //  FIXIPv6 - what to do?
        
        mismatch = ( ip ^ ip );

        //
        //  determine octect of mismatch
        //      - if match through last octect, just return (we're done)
        //      - if match no octects, useless IP, continue
        //

        if ( (mismatch & 0xff000000) == mismatch )
        {
            bestRank = 4;
            break;
        }
        else if ( (mismatch & 0xffff0000) == mismatch )
        {
            rank = 2;
        }
        else if ( (mismatch & 0xffffff00) == mismatch )
        {
            rank = 1;
        }
        else    // nothing matching at all, this IP worthless
        {
            continue;
        }

        //
        //  give additional bonus for being within IP network
        //
        //  when match through 2 octets or 3 octets whether you
        //  are class A, B or C makes a difference;  although
        //  may have multiple nets in a organization (ex. MS and 157.5x)
        //  generally being inside a network tells you something --
        //  outside may tell you nothing
        //

        if ( (mismatch & remoteNetMask) == 0 )
        {
            rank += 1;
        }

        if ( rank > bestRank )
        {
            bestRank = rank;
        }
    }

    Done:
    
    DNS_DEBUG( RECURSE, (
        "Remote IP %s -- best rank = %d\n",
        DNSADDR_STRING( pRemoteIp ),
        bestRank ));

    return bestRank;
}



VOID
Remote_NsListCreate(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Setup NS list buffer.
    Note:  does not initialize.

    DEVNOTE-DCR: 455669 - could improve NS list implementation

Arguments:

    pQuery -- ptr to original query

Return Value:

    None.

--*/
{
    ASSERT( pQuery->pNsList == NULL );

    if ( !pQuery->pNsList )
    {
        pQuery->pNsList = Packet_AllocateTcpMessage( MIN_TCP_PACKET_SIZE );
        STAT_INC( PacketStats.PacketsForNsListUsed );
    }
}



VOID
Remote_NsListCleanup(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Cleanup NS list buffer.

Arguments:

    pQuery -- ptr to original query

Return Value:

    None.

--*/
{
    register PDNS_MSGINFO   pmsg = (PDNS_MSGINFO) pQuery->pNsList;

    //  see note above
    //  if switch to using memory in pRecurseMsg, then this routine
    //      can become no-op

    if ( pmsg )
    {
        //  for debug need to mark these, so none of the checks on
        //  returning messages or in free list messages are performed

        pmsg->fNsList = TRUE;
#if DBG
        pmsg->pRecurseMsg = NULL;
        pmsg->pConnection = NULL;
        pmsg->dwQueuingTime = 0;
#endif

        //  while used as remote, message is clear

        SET_PACKET_ACTIVE_TCP( pmsg );
        Packet_FreeTcpMessage( pmsg );
        pQuery->pNsList = NULL;
        STAT_INC( PacketStats.PacketsForNsListReturned );
    }
}



VOID
Remote_InitNsList(
    IN OUT  PNS_VISIT_LIST  pNsList
    )
/*++

Routine Description:

    Initialize NS list.

Arguments:

    pNsList -- NS list to prioritize

Return Value:

    None.

--*/
{
    ASSERT( pNsList );

    //  clear header portion of NS list

    RtlZeroMemory(
        pNsList,
        (PBYTE)pNsList->NsList - (PBYTE)pNsList );
}



VOID
Remote_SetNsListPriorities(
    IN OUT  PNS_VISIT_LIST  pNsList
    )
/*++

Routine Description:

    Set priorities for IP in NS list.

    DEVNOTE-DCR: 455669 - improve remote NS list implementation

Arguments:

    pNsList -- NS list to prioritize

Return Value:

    Ptr to remote struct.

--*/
{
    PREMOTE_SRV     premote;
    DWORD           i;

    DNS_DEBUG( REMOTE, (
        "Remote_SetNsListPriorities( %p )\n",
        pNsList ));

    LOCK_REMOTE();

    //
    //  for each IP in NS list, get remote priority
    //
    //  currently base priority solely on fastest response
    //  -- closest best box
    //

    for ( i=0; i<pNsList->Count; i++ )
    {
        PDNS_ADDR   pdnsaddr = &pNsList->NsList[ i ].IpAddress;
        DWORD       priority = NEW_IP_PRIORITY;
        BOOL        fneverVisited = TRUE;

        if ( DnsAddr_IsMissingGlue( pdnsaddr ) )
        {
            continue;
        }

        premote = Remote_FindOrCreate(
                    pdnsaddr,
                    FALSE,      //  do not create
                    TRUE );     //  remote list locked
        if ( premote )
        {
            //
            //  If this remote's BestResponse is currently zero, then
            //  we have never tried it. Set it's BestResponse to 
            //  NEW_IP_PRIORITY - this initially qualifies the server
            //  as "fast".
            //

            if ( premote->BestResponse == 0 )
            {
                premote->BestResponse = NEW_IP_PRIORITY;
            }
            else
            {
                fneverVisited = FALSE;
            }

            priority = premote->BestResponse;
        }

        //  if unvisited IP, adjust priority based on match with
        //  DNS server IPs, so that we try the closest NS first

        if ( fneverVisited && g_BoundAddrs )
        {
            DWORD delta;

            delta = rankIpRelativeToIpAddressArray( g_BoundAddrs, pdnsaddr );
            priority = ( delta >= priority ) ? 1 : priority - delta;
        }

        DNS_DEBUG( REMOTE, (
            "Remote_SetNsListPriorities() ip=%s best=%d newpri=%d\n",
            DNSADDR_STRING( pdnsaddr ),
            premote ? premote->BestResponse : 999999,       //  silly...
            priority ));

        pNsList->NsList[ i ].Data.Priority = priority;
    }

    UNLOCK_REMOTE();
}



PDB_NODE
Remote_NsChaseCname(
    IN PDB_NODE         pnodeNS
    )

/*++

Routine Description:

   Given the node for a NS, checks to see if there is a CNAME in the RR
   list for this node and returns the CNAME target node.

Arguments:

    pnodeNS -- NS node to chase for

Return Value:

    Pointer to CNAME target node or NULL if no CNAME was found.

Notes:

    This function should be called to attempt CNAME resolution only if an
    A record for the NS host name cannot be found in zones or cache.

--*/
    
{
    PDB_NODE        pnodeCNAMETarget = NULL;
    PDB_RECORD      prr = NULL;

    //
    //  Attempt to find a CNAME record in the NS node.
    //
    
    prr = RR_FindNextRecord(
                pnodeNS,
                DNS_TYPE_CNAME,
                NULL,
                0 );
    if ( !prr )
    {
        return NULL;
    }
    
    DNS_DEBUG( RECURSE, (
       "Founnd CNAME record for NS %p with label %s\n",
       pnodeNS,
       pnodeNS->szLabel ));

    //
    //  Attempt to find the CNAME target node in the zone.
    //
    
    if ( pnodeNS->pZone )
    {
        pnodeCNAMETarget = Lookup_ZoneNode(
                                pnodeNS->pZone,
                                prr->Data.CNAME.nameTarget.RawName,
                                NULL,                   //  message
                                NULL,                   //  lookup name
                                LOOKUP_NAME_FQDN | LOOKUP_FIND,
                                NULL,                   //  closest node ptr
                                NULL );                 //  previous node ptr
    }
    
    //
    //  Find the CNAME target node in the cache.
    //

    if ( !pnodeCNAMETarget )
    {
        pnodeCNAMETarget = Lookup_NsHostNode(
                                &prr->Data.CNAME.nameTarget,
                                LOOKUP_CACHE_CREATE,
                                NULL,
                                NULL );
    }
    
    return pnodeCNAMETarget;
}   //  Remote_NsChaseCname



DNS_STATUS
Remote_BuildNsListForNode(
    IN      PDB_NODE        pNode,
    OUT     PNS_VISIT_LIST  pNsList,
    IN      DWORD           dwQueryTime
    )
/*++

Routine Description:

    Get NS list for a node, building one if necessary.

    If pNode is in a NOTAUTH zone then we must be careful that the
    local server's own IP addresses are ommited from the output NS list.

Arguments:

    pNode   -- node containing NS records

    pNsList -- ptr to NS list struct to fill in

    dwQueryTime -- query time to use when deciding if resource records
        found in the cache should be deleted, or use zero to if timeout
        checking on resource records is not required

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_NO_DATA if no NS found for node.

--*/
{
    DBG_FN( "Remote_BuildNsListForNode" )

    PDB_RECORD      prrNS = NULL;
    PDB_RECORD      prrA;
    PDB_NODE        pnodeNS;
    PDB_NODE        pnodeCNAME;
    PDB_NODE        pnodeDelegation;
    IP_ADDRESS      ipNs;
    BOOL            foundIp;
    DNS_STATUS      status = ERROR_SUCCESS;
    PNS_VISIT       pvisit;
    PNS_VISIT       pvisitEnd;
    DWORD           size;
    BOOL            omitLocalIps;

    //
    //  list should be locked by caller
    //

    ASSERT_LOCK_NODE( pNode );

    SET_NODE_ACCESSED( pNode );

    DNS_DEBUG( RECURSE2, (
        "buildNsListForNode( %p ) (l=%s)\n"
        "    at %p\n",
        pNode,
        pNode->szLabel,
        pNsList ));

    #if DBG
    //  if debug, clear header so we can do use list debug prints
    //  without blowing up
    Remote_InitNsList( pNsList );
    #endif

    //
    //  If notauth zone, local IPs must not be included in NS list.
    //

    omitLocalIps = NODE_ZONE( pNode ) && IS_ZONE_NOTAUTH( NODE_ZONE( pNode ) );

    //
    //  build NS list
    //      - read all NS records
    //      - at each NS read all A records, each becoming entry in NS list
    //      - missing glue NS hosts get special missing glue IP
    //      - use pvisit ptr to step through NS list
    //      - save end ptr to check stop
    //

    pvisit = pNsList->NsList;
    pvisitEnd = pvisit + MAX_NS_LIST_COUNT;

    while( 1 )
    {
        prrNS = RR_FindNextRecord(
                    pNode,
                    DNS_TYPE_NS,
                    prrNS,
                    dwQueryTime );

        if ( !prrNS )
        {
            IF_DEBUG( RECURSE )
            {
                Dbg_NodeName(
                    "No more name servers for domain ",
                    pNode,
                    "\n" );
            }
            break;
        }

        //
        //  only root-hints available?
        //      - if already read cache data -- done
        //      if using root-hints flag
        //
        //  DEVNOTE: add root-hints to list?  exclude?
        //      - if add root hints need to check that not duplicate nodes
        //      - need to rank test on IPs below also
        //

        if ( !pNode->pParent  &&
            pvisit == pNsList->NsList &&
            IS_ROOT_HINT_RR( prrNS ) )
        {
            DNSLOG( RECURSE, (
                "Recursed to root and found only root hints\n" ));
            status = DNSSRV_ERROR_ONLY_ROOT_HINTS;
        }

        //
        //  get NS node
        //
        //  currently force creation of node to handle the missing
        //  glue case;  note, that this will NOT force creation of
        //  NS record in authoritative zone;  but this is ok, because
        //  we don't WANT to chase glue there -- except it possibly
        //  could have been useful in WINS zone ...
        //
        //  note:  don't have good way to index, and don't save names in
        //      IP list, so forced to create node
        //
        //  DEVNOTE: do not force create of NS-host
        //      - ideally do NOT force NS-host create (just set flag)
        //      - then if NO contact go back for missing GLUE pass and force create
        //
        //  if lookup at delegation, will also accept OUTSIDE zone records in the
        //  zone containing the delegation
        //

        pnodeNS = Lookup_NsHostNode(
                    &prrNS->Data.NS.nameTarget,
                    LOOKUP_CACHE_CREATE,
                    pNode->pZone,           //  zone of delegation (if delegation)
                    &pnodeDelegation );
        if ( !pnodeNS )
        {
            continue;
        }
        IF_DEBUG( RECURSE )
        {
            Dbg_NodeName(
                "Found a NS for domain ",
                pNode,
                " => " );
            Dbg_NodeName(
                NULL,
                pnodeNS,
                "\n" );
        }

        //
        //  find IP addresses for current NS host
        //
        //  need to hold lock on node while get IP from A record
        //  otherwise we'd have to protect A record with timeout free
        //
        //  Note: global-lock, so no need to node lock
        //
        //  DEVNOTE: Rank test IPs \ otherwise get duplicate IP
        //      - if add root hints need to check that not duplicate nodes
        //      - need to rank test on IPs below also
        //   need to either remove root hints from list OR
        //   stop on new rank OR
        //   check previous IPs for same node on new rank
        //      to avoid duplicate IP
        //

        prrA = NULL;
        ipNs = 0;
        foundIp = FALSE;
        pnodeCNAME = NULL;

        while ( 1 )
        {
            PDB_NODE    psearchNode;
            
            if ( SrvCfg_dwAllowCNAMEAtNS )
            {
                psearchNode = pnodeCNAME ? pnodeCNAME : pnodeNS;
            }
            else
            {
                psearchNode = pnodeNS;
            }
            
            //
            //  Search for an A record at the CNAME node (if one has been
            //  found in a previous pass) or the NS node.
            //
            
            prrA = RR_FindNextRecord(
                        psearchNode,
                        DNS_TYPE_A,
                        prrA,
                        0 );

            if ( !prrA && !foundIp && !pnodeCNAME && SrvCfg_dwAllowCNAMEAtNS )
            {
                //
                //  If there are no A records, see if there is a CNAME.
                //

                pnodeCNAME = Remote_NsChaseCname( pnodeNS );
                if ( pnodeCNAME )
                {
                    continue;
                }
            }
            
            if ( prrA )
            {
                ipNs = prrA->Data.A.ipAddress;

                if ( ipNs != 0 && ipNs != INADDR_BROADCAST )
                {
                    //
                    //  IP is local server's own IP?
                    //

                    if ( omitLocalIps &&
                         DnsAddrArray_ContainsIp4( g_ServerIp4Addrs, ipNs ) )
                    {
                        DNS_DEBUG( RECURSE, (
                            "%s: omitting local DNS IP at node %s\n", fn,
                            psearchNode->szLabel ));
                        continue;
                    }

                    DnsAddr_BuildFromIp4(
                        &pvisit->IpAddress,
                        ipNs,
                        DNS_PORT_NET_ORDER );

                    pvisit->pNsNode         = pnodeNS;
                    pvisit->Data.Priority   = 0;
                    pvisit->Data.SendTime   = 0;
                    pvisit++;
                    foundIp = TRUE;

                    if ( pvisit >= pvisitEnd )
                    {
                        goto EntryEnd;
                    }
                    continue;
                }

                DNS_PRINT((
                    "Bad cached IP address (%p) at node %s\n",
                    ipNs,
                    psearchNode->szLabel ));
                foundIp = FALSE;
                continue;
            }

            //
            //  no more addresses for host
            //      - if found at least one, then done
            //      - if none, then write "missing-glue" entry for NS host,
            //      but only if outside zone;  NS pointing inside a zone
            //      with empty A-list is useless
            //

            if ( foundIp )
            {
                DNS_DEBUG( RECURSE, ( "    Out of A records for NS\n" ));
                break;
            }

            if ( IS_AUTH_NODE( pnodeNS ) )
            {
                DNS_DEBUG( ANY, (
                    "WARNING:  NO A records for NS %p with label %s inside ZONE!\n"
                    "    Since inside ZONE missing glue lookup is useless!\n",
                    psearchNode,
                    psearchNode->szLabel ));

                //  DEVNOTE-LOG: log event here if first time through
                //      could have bit on node, that essentially says
                //      "logged something about this node, don't do it again"

                break;
            }

            DNS_DEBUG( RECURSE, (
                "WARNING:  NO A records for NS %p with label %s!\n",
                psearchNode,
                psearchNode->szLabel ));

            pvisit->pNsNode = pnodeNS;
            DnsAddr_SetMissingGlue( &pvisit->IpAddress );
            pvisit->Data.pnodeMissingGlueDelegation = pnodeDelegation;
            pvisit++;
            if ( pvisit >= pvisitEnd )
            {
                goto EntryEnd;
            }
            break;

        }   //  Loop through addresses for name server

    }   //  Loop through name servers for this node


EntryEnd:

    //  determine count

    pNsList->Count = ( DWORD )( pvisit - pNsList->NsList );

    if ( pNsList->Count == 0 )
    {
        DNS_DEBUG( RECURSE, ( "No NS records at %s\n", pNode->szLabel ));
        ASSERT( prrNS == NULL );

        return ERROR_NO_DATA;
    }

    //
    //  set priorities IP in NS list
    //

    Remote_SetNsListPriorities( pNsList );

    IF_DEBUG( REMOTE )
    {
        Dbg_NsList(
            "NsList leaving BuildNsListForNode()",
            pNsList );
    }
    ASSERT( status == ERROR_SUCCESS ||
            status == DNSSRV_ERROR_ONLY_ROOT_HINTS );

    return status;
}



DNS_STATUS
Remote_BuildVisitListForNewZone(
    IN      PDB_NODE        pZoneRoot,
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Build visit list for zone root.

    IA64: ivisit must either be signed or the length of the machine word because
    it can be zero when we execute "&pvisitList->NsList[ivisit-1]". If ivisit is
    unsigned or smaller than the machine word (it was originally a DWORD), there
    will be sign extension problems.

Arguments:

    pZoneRoot -- zone root node containing NS records

    pQuery  -- query being recursed

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    int             ivisit;     // IA64 quirk, see above
    DWORD           lastVisitCount;
    PNS_VISIT       pvisit;
    PNS_VISIT_LIST  pvisitList;
    NS_VISIT_LIST   nslist;
    ULONG           random;

    enum
    {
        DNS_WANT_BEST_PRIORITY,
        DNS_WANT_ANY_FAST_SERVER,
        DNS_WANT_SLOW_SERVER
    }               wantServer;


#if 0
    //  note:  Eyal changed to directly lock node;  not yet sure why
    //
    //  list should be locked by caller
    //

    ASSERT_LOCK_NODE( pZoneRoot );
#endif

    DUMMY_LOCK_RR_LIST(pZoneRoot);

    SET_NODE_ACCESSED(pZoneRoot);

    pvisitList = pQuery->pNsList;

    //
    //  check if already got response from this zone?
    //
    //  this can happen when get referral to child zone, which either
    //      - does not respond (or bad response)
    //      - is bad delegation and does not agree it's authoritative
    //  this can send us back up to higher zone which we've already contacted
    //
    //  the idea here is to allow recurse up the tree (from zone) to allow
    //  for case of stale timed out data, but not to start looping because
    //  of misconfigured delegations
    //

    if ( pZoneRoot == pvisitList->pZoneRootResponded )
    {
        IF_DNSLOG( REMOTE )
        {
            PCHAR       psznode = NULL;
        
            DNSLOG( REMOTE, (
                "Refusing to build NS list for previously responding zone "
                "%s (query %p)\n",
                psznode = Log_FormatNodeName( pZoneRoot ),
                pQuery ));
            FREE_HEAP( psznode );
        }

        return DNSSRV_ERROR_ZONE_ALREADY_RESPONDED;
    }

    IF_DNSLOG( REMOTE )
    {
        PCHAR       psznode = NULL;
    
        DNSLOG( REMOTE, (
            "Building NS list for node %s (query %p)\n",
            psznode = Log_FormatNodeName( pZoneRoot ),
            pQuery ));
        FREE_HEAP( psznode );
    }

    //
    //  if already built NS list at this zone -- no action
    //

    if ( pZoneRoot == pvisitList->pZoneRootCurrent )
    {
        DNS_DEBUG( REMOTE, (
            "Zone root %p same as current, no NS list rebuild for query %p\n"
            "    pQuery = %p\n",
            pQuery,
            pZoneRoot ));

        return ERROR_SUCCESS;
    }

    //
    //   Lock the node we're working on.
    //      - all exit paths through jump to Done to unlock
    //

    LOCK_NODE( pZoneRoot );

    //
    //  build list of NS for node
    //

    status = Remote_BuildNsListForNode(
                pZoneRoot,
                & nslist,
                pQuery->dwQueryTime );

    if ( status != ERROR_SUCCESS &&
         status != DNSSRV_ERROR_ONLY_ROOT_HINTS )
    {
        goto Done;
    }
    ASSERT( nslist.Count != 0 );

    //
    //  walk backwards from last visit
    //  whack off any missing glue IPs or completely empty zone root nodes
    //      -- unnecessary to keep them around

    ivisit = pvisitList->VisitCount;
    pvisit = &pvisitList->NsList[ivisit-1];

    while ( ivisit )
    {
        if ( DnsAddr_IsMissingGlue( &pvisit->IpAddress ) ||
             DnsAddr_IsZoneRootNode( &pvisit->IpAddress ) )
        {
            ivisit--;
            pvisit--;
            continue;
        }
        ASSERT( pvisit->SendCount > 0 );
        break;
    }

    DNS_DEBUG( REMOTE2, (
        "starting visit list build at visit count = %d\n",
        ivisit ));

    //  write zone root node entry

    lastVisitCount = ivisit;
    pvisitList->ZoneIndex = ivisit;
    pvisitList->VisitCount = ++ivisit;
    pvisitList->pZoneRootCurrent = pZoneRoot;

    pvisit++;
    pvisit->pNsNode         = pZoneRoot;
    pvisit->Data.Priority   = NS_LIST_ZONE_ROOT_PRIORITY;
    pvisit->Data.SendTime   = 0;
    pvisit->SendCount       = NS_LIST_ZONE_ROOT_SEND_COUNT;
    DnsAddr_SetZoneRootNode( &pvisit->IpAddress );
    pvisit++;

    //
    //  Fill visit list with best priority IPs available at this zone
    //  root. It's important to do some load balancing here so we don't
    //  always hit the same NS when multiple remote authoritative NS are
    //  available. Before starting iterate-and-copy, randomly decide
    //  what kind of server we want to stick in the first slot. Very
    //  infrequently stick a randomly selected timed out server in the
    //  first slot, in case it is now reachable.
    //
    //  DEVNOTE: Currently sending to slow server 1 time in 10000. It
    //  might be better to do an actual time-based measurement and send
    //  to a timed-out server once per hour instead. It could even be
    //  a global (across zones). The problem with 1:10000 is that on a
    //  busy server it might be too often and on a quiet server it might
    //  not be often enough.
    //

    ++g_RandomSeed;
    random = RtlRandom( &g_RandomSeed );
    wantServer =
        ( random > ULONG_MAX / 10000 ) ?
            DNS_WANT_ANY_FAST_SERVER :
            DNS_WANT_SLOW_SERVER;

    while ( ivisit < MAX_PACKET_NS_LIST_COUNT )
    {
        PNS_VISIT   pavailNs = nslist.NsList;
        PNS_VISIT   pnextDesiredNs = NULL;
        DWORD       bestPriority = MAXDWORD;
        DWORD       availCount = nslist.Count;
        DWORD       sendCount;
        DWORD       i;
        DNS_ADDR    ip;

        //
        //  Note: server arrays are CHARs to save stack space. Since
        //  the values will be indexes, as long as MAX_NS_LIST_COUNT
        //  is less than 255 this is okay. 
        //

        INT         slowServers = 0;
        INT         fastServers = 0;
        UCHAR       slowServerArray[ MAX_NS_LIST_COUNT ];
        UCHAR       fastServerArray[ MAX_NS_LIST_COUNT ];

        if ( availCount == 0 )
        {
            break;
        }

        //
        //  Scan through the list, dropping indexes of remaining NS into 
        //  slow/fast arrays.
        //  find best IP -- special case missing glue, it's priority field
        //      is no longer accurate

        i = 0;
        while ( availCount-- )
        {
            register    DWORD   priority;

            //
            //  Keep track of the best priority server.
            //

            if ( DnsAddr_IsMissingGlue( &pavailNs->IpAddress ) )
            {
                priority = MISSING_GLUE_PRIORITY;
            }
            else
            {
                priority = pavailNs->Data.Priority;
            }

            if ( priority < bestPriority )
            {
                bestPriority = priority;
                pnextDesiredNs = pavailNs;
            }

            //
            //  Optionally categorize this server as slow/fast. Servers
            //  that are missing glue or are otherwise not easily sendable
            //  are ignored.
            //

            if ( wantServer != DNS_WANT_BEST_PRIORITY &&
                 !DnsAddr_IsMissingGlue( &pavailNs->IpAddress ) &&
                 !DnsAddr_IsZoneRootNode( &pavailNs->IpAddress ) )
            {
                if ( pavailNs->Data.Priority > MAX_FAST_SERVER_PRIORITY )
                {
                    slowServerArray[ slowServers++ ] = ( UCHAR ) i;
                }
                else
                {
                    fastServerArray[ fastServers++ ] = ( UCHAR ) i;
                }
            }
            ++i;
            pavailNs++;
        }

        //
        //  pnextDesiredNs is now pointing to the NS with best priority
        //  but will override this selection if indicated by wantServer
        //  However, if we did not find any valid slow or fast 
        //  servers then we will have to stick with the current
        //  value of pnextDesiredNs. The scenario where this may happen
        //  is when all NS are MISSING_GLUE.
        //

        if ( wantServer != DNS_WANT_BEST_PRIORITY &&
            ( slowServers || fastServers ) )
        {
            //
            //  There is no guarantee that we have servers of the desired
            //  type. Example: we want a slow server but all servers are
            //  fast. In this case, switch wantServer to match the available
            //  servers.
            //

            if ( !slowServers && wantServer == DNS_WANT_SLOW_SERVER )
            {
                wantServer = DNS_WANT_ANY_FAST_SERVER;
            }
            else if ( !fastServers && wantServer != DNS_WANT_SLOW_SERVER )
            {
                wantServer = DNS_WANT_SLOW_SERVER;
            }

            //
            //  Randomly select next lucky winner.
            //

            ASSERT(
                wantServer == DNS_WANT_SLOW_SERVER && slowServers ||
                wantServer != DNS_WANT_SLOW_SERVER && fastServers );

            pnextDesiredNs =
                &nslist.NsList[
                    wantServer == DNS_WANT_SLOW_SERVER && slowServers ?
                        slowServerArray[ random % slowServers ] :
                        fastServerArray[ random % fastServers ] ];

            //
            //  For all server positions except the first position,
            //  we will take the best priority. This gives us a certain
            //  amount of load balancing while keeping server selection
            //  for the remaining servers in the list fast and simple.
            //

            wantServer = DNS_WANT_BEST_PRIORITY;
        }

        ASSERT( pnextDesiredNs );

        //
        //  check if this IP already visited
        //      (this will frequently happen when server auth for child and
        //      parent zones -- ex. microsoft.com and dns.microsoft.com)
        //
        //  note:  we also use this in the way we handle missing glue
        //      which is currently to rebuild whole NS list which
        //      inherently means we must pick up previous send IPs
        //

        DnsAddr_Copy( &ip, &pnextDesiredNs->IpAddress );
        sendCount = 0;

        for( i = 1; i < lastVisitCount; ++i )
        {
            if ( DnsAddr_IsEqual(
                    &ip,
                    &pvisitList->NsList[ i ].IpAddress,
                    DNSADDR_MATCH_IP ) )
            {
                sendCount = pvisitList->NsList[ i ].SendCount;
                ASSERT( !DnsAddr_IsMissingGlue( &ip ) );
                ASSERT( !DnsAddr_IsZoneRootNode( &ip ) );
                break;
            }
        }

        //
        //  skip useless IPs
        //      - responded or reached retry limit

        if ( sendCount &&
             ( sendCount >= RECURSE_IP_SEND_MAX ||
                    pvisitList->NsList[ i ].Response ) )
        {
            DNS_DEBUG( REMOTE, (
                "IP %s responded or maxed out on previous pass for query %p\n"
                "    do not include in this zone's pass\n",
                DNSADDR_STRING( &ip ),
                pQuery ));
        }

        //
        //  copy best avail NS to query's NS list
        //
        //  note:  could mem-clear entire NS list, then no need to
        //      zero count fields as will never be set even on
        //      unvisited NS that we may be overwriting
        //
        //  DEVNOTE: It is imperative to keep Priority and SendTime
        //      in sync since in IA64 these two fields combine to hold
        //      the delegation node pointer - see the macro
        //      MISSING_GLUE_DELEGATION in recurse.h

        else
        {
            pvisit->pNsNode     = pnextDesiredNs->pNsNode;
            pvisit->Data        = pnextDesiredNs->Data;
            pvisit->SendCount   = ( UCHAR ) sendCount;
            pvisit->Response    = 0;
            DnsAddr_Copy( &pvisit->IpAddress, &ip );
            pvisit++;
            ivisit++;
        }

        //  whack best NS in avail list, so not tested again on later pass
        //      simply overwrite with last entry and shrink avail list count

        nslist.Count--;
        pavailNs = &nslist.NsList[ nslist.Count ];

        pnextDesiredNs->pNsNode       = pavailNs->pNsNode;
        pnextDesiredNs->Data          = pavailNs->Data;
        DnsAddr_Copy( &pnextDesiredNs->IpAddress, &pavailNs->IpAddress );
    }

    //
    //  reset query's NS list count
    //

    pvisitList->Count = ivisit;

    DNS_DEBUG( REMOTE, (
        "Leaving Remote_BuildVisitListForNewZone()\n"
        "    query = %p, NS count = %d\n",
        pQuery,
        ivisit ));
    IF_DEBUG( REMOTE )
    {
        Dbg_NsList(
            "Visit list after rebuild",
            pvisitList );
    }

Done:

    UNLOCK_NODE ( pZoneRoot );
    return status;
}



VOID
recordVisitIp(
    IN OUT  PNS_VISIT           pVisit,
    IN OUT  PDNS_ADDR_ARRAY     IpArray
    )
/*++

Routine Description:

    Record IP as visited:
        - set fields in it's NS_VISIT struct
        - save IP to array

Arguments:

    pVisit -- ptr to visit NS IP struct

    IpArray -- IP array to hold IPs to send to;  must contain space for
        at least RECURSE_PASS_MAX_SEND_COUNT elements

Return Value:

    None.

--*/
{
    ASSERT( !DnsAddr_IsZoneRootNode( &pVisit->IpAddress ) );
    ASSERT( !DnsAddr_IsMissingGlue( &pVisit->IpAddress ) );

    pVisit->SendCount++;
    DnsAddr_Copy(
        &IpArray->AddrArray[ IpArray->AddrCount++ ],
        &pVisit->IpAddress );
}



DNS_STATUS
Remote_ChooseSendIp(
    IN OUT  PDNS_MSGINFO        pQuery,
    OUT     PDNS_ADDR_ARRAY     IpArray
    )
/*++

Routine Description:

    Determine IPs in visit list to make next send to.

Arguments:

    pQuery - ptr to query message

    IpArray - IP array to hold IPs to send to;  must contain space for
        at least RECURSE_PASS_MAX_SEND_COUNT elements

Return Value:

    ERROR_SUCCESS if successful.
    DNSSRV_ERROR_OUT_OF_IP if no IP to go to on this zone.
    DNSSRV_ERROR_MISSING_GLUE if
        - query suspended to chase glue OR if query was cache update query
        and we've now reverted to original;  in either case caller does not
        send and does not touch pQuery any more

--*/
{
    PNS_VISIT_LIST  pvisitList = ( PNS_VISIT_LIST ) pQuery->pNsList;
    PNS_VISIT       pvisitNext;
    PNS_VISIT       pvisitResend;
    PNS_VISIT       pvisitRetryLast;
    PNS_VISIT       pvisitEnd;
    PNS_VISIT       pvisitZone;
    PDB_NODE        pnodeMissingGlue;
    DWORD           sendCount;
    DWORD           sendTime;
    int             visitCount;     // IA64: must be signed!
    DWORD           priorityNext;


    DNS_DEBUG( REMOTE, (
        "Remote_ChooseSendIp( q=%p, iparray=%p )\n",
        pQuery,
        IpArray ));

    IF_DEBUG( REMOTE2 )
    {
        Dbg_NsList(
            "NS list entering choose IP",
            pvisitList );
    }
    ASSERT( pvisitList->Count > 0 );
    ASSERT( pvisitList->VisitCount > 0 );
    ASSERT( pvisitList->pZoneRootCurrent );

    //
    //  setup
    //      - clear IP array
    //      - find zone entry in list
    //      - find last visited entry in list
    //

    IpArray->AddrCount = 0;

    pvisitZone = &pvisitList->NsList[ pvisitList->ZoneIndex ];
    pvisitEnd  = &pvisitList->NsList[ pvisitList->Count ];

    visitCount = pvisitList->VisitCount;

    pvisitRetryLast = pvisitNext = &pvisitList->NsList[ visitCount - 1 ];

    //
    //  determine send count
    //      - based on number of passes through this zone's NS
    //      currently
    //          - 1,2 passes => 1 send
    //          - 3,4 passes => 2 sends
    //          - otherwise 3 sends
    //      - can not be greater than total IPs available in zone
    //

    sendCount = pvisitZone->SendCount;

    if ( sendCount < 2 )
    {
        sendCount = 1;
    }
    else if ( sendCount < 4 )
    {
        sendCount = 2;
    }
    else
    {
        sendCount = 3;
    }

#if 0
    //  code below effectively limits send count, as break
    //      out when push through end limit of list
    if ( sendCount > ZONE_VISIT_NS_COUNT(pvisitZone) )
    {
        sendCount = ZONE_VISIT_NS_COUNT(pvisitZone);
    }
#endif

    //
    //  save query time -- in milliseconds
    //
    //  DEVNOTE: query time
    //
    //  currently reading query time (in ms) in recursion function so
    //  we can associate time directly with IPs we send to;
    //  however, that has problem in that we are reading time outside
    //  of recursion queue lock -- which may force us to wait
    //  potentially lots of ms for service (depends on recursion
    //  thread cleanup activity)

    sendTime = GetCurrentTimeInMilliSeconds();

    //
    //  loop until found desired number of send IPs
    //
    //      - always send to new IP (if available)
    //      - for multiple sends
    //          -- another NEW IP
    //              OR
    //             previous IP if
    //                  - only sent once and
    //                  - "good" IP and
    //                  - better than next new IP
    //
    //

    while ( sendCount )
    {
        pvisitNext++;
        priorityNext = NO_RESPONSE_PRIORITY;

        if ( pvisitNext < pvisitEnd )
        {
            ASSERT( !DnsAddr_IsZoneRootNode( &pvisitNext->IpAddress ) );

            //
            //  skip previously visited (in another zone's pass)
            //  these IPs should not have been touched on this zone's pass
            //  but may have been sent to on previous zone's pass and
            //  not responded, in which case send count was picked up
            //
            //  if we skip an IP sent to from a previous zone's pass,
            //  then must include it in the retry processing;
            //  othwerwise, a zone that contains entirely IPs that were
            //  previously sent to, would never retry any of them

            if ( pvisitNext->SendCount )
            {
                ASSERT( pvisitList->ZoneIndex != ( DWORD ) -1 );
                visitCount++;
                ASSERT( visitCount == (int)(pvisitNext - &pvisitList->NsList[0] + 1));
                pvisitRetryLast = pvisitNext;
                continue;
            }

            //
            //  The NS list is pre-ordered, so send to the next IP unless it
            //  appears to be tremendously slow, in which case we may do 
            //  re-sends before coming back to the slow server. BUT - always
            //  use the first NS in the list, since this will have been set
            //  up for us by Remote_BuildVisitListForNewZone. Occasionally the
            //  first server will be a timed out server, which we should test
            //  to see if it has come back up.
            //  

            if ( IpArray->AddrCount == 0 ||
                pvisitNext->Data.Priority <= MAX_FAST_SERVER_PRIORITY )
            {
                if ( DnsAddr_IsMissingGlue( &pvisitNext->IpAddress ) )
                {
                    pnodeMissingGlue = pvisitNext->pNsNode;
                    if ( IS_NOEXIST_NODE( pnodeMissingGlue ) )
                    {
                        DNS_DEBUG( RECURSE, (
                            "Missing glue node %p already has cached name error\n",
                            pnodeMissingGlue ));
                        visitCount++;
                        continue;
                    }
                    goto MissingGlue;
                }
                recordVisitIp( pvisitNext, IpArray );
                pvisitNext->Data.SendTime = sendTime;
                visitCount++;
                ASSERT( visitCount ==
                        ( int ) ( pvisitNext - &pvisitList->NsList[ 0 ] + 1 ) );
                sendCount--;
                continue;
            }

            //  if not "great" IP, and have already made one send to new IP
            //      then drop down to check for better resends
            //      require resend IP to be four times as good as this one
            //      otherwise, we'll do the send to this one after retry check

            else
            {
                priorityNext = pvisitNext->Data.Priority / 4;
                if ( priorityNext > NO_RESPONSE_PRIORITY )
                {
                    priorityNext = NO_RESPONSE_PRIORITY;
                }
            }
        }

        //
        //  resend to previous NS IPs ?
        //      - should have made at least one previous send to fall here
        //      unless
        //          - no IP entries for the zone (all the IPs were retried
        //          through MAX_RETRY in previous zones) OR
        //          - first zone IP was previously sent to OR
        //          - first (and hence all) entries are missing glue
        //
        //

        ASSERT( ( pvisitList->ZoneIndex+1 < pvisitList->VisitCount &&
                    pvisitZone->SendCount > 0 )
                || ( pvisitZone + 1 ) >= pvisitEnd
                || ( pvisitZone + 1 )->SendCount != 0
                || DnsAddr_IsMissingGlue( &( pvisitZone + 1 )->IpAddress ) );

        pvisitResend = pvisitZone;

        //
        //  resend to IP if
        //      - hasn't responded (could SERVER_FAILURE or do sideways delegation)
        //      - hasn't maxed out sends
        //      - not missing glue
        //        (note: missing glue priority no longer accurate)
        //      - lower priority then possible next send
        //

        while ( ++pvisitResend <= pvisitRetryLast )
        {
            if ( pvisitResend->Response != 0 ||
                pvisitResend->SendCount > RECURSE_IP_SEND_MAX ||
                DnsAddr_IsMissingGlue( &pvisitResend->IpAddress ) )
            {
                continue;
            }
            if ( pvisitResend->Data.Priority < priorityNext )
            {
                recordVisitIp( pvisitResend, IpArray );
                sendCount--;
                if ( sendCount )
                {
                    continue;
                }
                break;
            }
        }

        //  found "better" resend IPs, for remaining sends => done
        //  drop visit count as we didn't actually use visit to last IP

        if ( pvisitResend <= pvisitRetryLast )
        {
            break;
        }

        //  if did NOT find a "better" resend candidate, then use next IP

        if ( priorityNext < NO_RESPONSE_PRIORITY &&
             !DnsAddr_IsMissingGlue( &pvisitNext->IpAddress ) )
        {
            ASSERT( pvisitNext < pvisitEnd );
            recordVisitIp( pvisitNext, IpArray );
            visitCount++;
            ASSERT( visitCount == (int)(pvisitNext - &pvisitList->NsList[0] + 1));
            sendCount--;
            continue;
        }

        //  not enough valid resends to fill send count

        DNS_DEBUG( REMOTE, ( "No more RESENDs and no next visit IP!\n" ));
        break;
    }

    pvisitList->VisitCount = visitCount;

    pvisitZone->SendCount++;

    //
    //  done
    //

    DNS_DEBUG( REMOTE, (
        "Leaving Remote_ChooseSendIp()\n"
        "    doing %d sends\n",
        IpArray->AddrCount ));
    IF_DEBUG( REMOTE2 )
    {
        Dbg_NsList(
            "NS list leaving Remote_ChooseSendIp()",
            pvisitList );
    }
    if ( IpArray->AddrCount > 0 )
    {
        //pQuery->dwMsQueryTime = sendTime;
        return ERROR_SUCCESS;
    }
    else
    {
        return DNSSRV_ERROR_OUT_OF_IP;
    }


MissingGlue:

    //
    //  Found that there is missing glue -> chase it!
    //
    //  New and improved missing glue chasing for multiple levels of
    //  missing glue, implemented November 2001 by jwesth.
    //
    //  Suspend the current query and start a new cache update query
    //  for the missing name. Count the levels of cache update queries
    //  in the chain and abort query if it becomes too deep.
    //
    
    if ( IS_CACHE_UPDATE_QUERY( pQuery ) )
    {
        PDNS_MSGINFO        pmsg;
        int                 depth;

        #define DNS_MAX_MISSING_GLUE_DEPTH  5
                
        for ( pmsg = pQuery, depth = 0;
              pmsg != NULL;
              pmsg = SUSPENDED_QUERY( pmsg ), ++depth );

        DNS_DEBUG( REMOTE, (
            "Missing glue depth is now %d\n", depth ));
        
        if ( depth > DNS_MAX_MISSING_GLUE_DEPTH )
        {
            DNS_DEBUG( REMOTE, (
                "Too much missing glue - terminating query %p\n", pQuery ));
            Recurse_ResumeSuspendedQuery( pQuery );
            return DNSSRV_ERROR_MISSING_GLUE;
        }
    }

    pvisitNext->SendCount = 1;
    pnodeMissingGlue = pvisitNext->pNsNode;
    SET_NODE_ACCESSED( pnodeMissingGlue );

    pvisitList->pNodeMissingGlue = pnodeMissingGlue;
    pvisitList->VisitCount = visitCount;

    IF_DNSLOG( REMOTE )
    {
        PCHAR       psznode = NULL;
        
        DNSLOG( LOOKUP, (
            "Querying for missing glue for %s\n",
            psznode = Log_FormatNodeName(
                        pvisitNext->Data.pnodeMissingGlueDelegation ) ));
        FREE_HEAP( psznode );
    }

    if ( Recurse_SendCacheUpdateQuery(
            pnodeMissingGlue,
            pvisitNext->Data.pnodeMissingGlueDelegation,
            DNS_TYPE_A,
            pQuery ) )
    {
        return DNSSRV_ERROR_MISSING_GLUE;
    }
    else
    {
        return DNSSRV_ERROR_OUT_OF_IP;
    }
}



VOID
Remote_ForceNsListRebuild(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Force rebuild of NS IP list for query.

Arguments:

    pQuery - ptr to query message

Return Value:

    None

--*/
{
    DNS_DEBUG( REMOTE, (
        "Remote_ForceNsListRebuild( q=%p )\n",
        pQuery ));

    //
    //  DEVNOTE: single fix up of missing glue node
    //
    //      ideally we'd just rebuild A record for missing glue node here
    //      a couple issues
    //          1) need to separate out A record query routines
    //          2) can get multiple A records, yet only have ONE entry
    //          with bogus missing glue;  if more missing glue records follow
    //          must either just overwrite (not-unreasonable) or push down
    //
    //      alternatively, the better approach might be to do full rebuild
    //      but just do a better job with the already VISITED list, so don't
    //      waste as much space
    //

    ASSERT( (PNS_VISIT_LIST)pQuery->pNsList );

    ((PNS_VISIT_LIST)pQuery->pNsList)->pZoneRootCurrent = NULL;
}




PDB_NODE
Remote_FindZoneRootOfRespondingNs(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDNS_MSGINFO    pResponse
    )
/*++

Routine Description:

    Find zone root node of responding name server.

    Updates remote IP info, and query's visited list.

Arguments:

    pQuery - ptr to query message

    pResponse - response message

Return Value:

    Ptr to node, if found.
    NULL if IP NOT in responding list.

--*/
{
    PNS_VISIT_LIST  pvisitList;
    PNS_VISIT       pvisit;
    PDB_NODE        pnodeZoneRoot = NULL;
    PDB_NODE        pnodeNs = NULL;
    PDNS_ADDR       presponseIp;
    DWORD           j;
    DWORD           timeDelta = MAX_FAST_SERVER_PRIORITY * 3;   // default


    ASSERT( pQuery && pQuery->pNsList );
    ASSERT( !IS_FORWARDING(pQuery) );

    //  responding DNS server

    presponseIp = &pResponse->RemoteAddr;

    DNS_DEBUG( REMOTE, (
        "Remote_FindZoneRootOfRespondingNs()\n"
        "    pQuery       %p\n"
        "    pResponse    %p\n"
        "    IP Resp      %s\n",
        pQuery,
        pResponse,
        DNSADDR_STRING( presponseIp ) ));

    //
    //  loop through visited NS IPs until find match
    //
    //      - save zone root node of responding NS
    //      - mark all IP from responding NS as responded
    //      (barring bad IP data) querying them will give us
    //      same response
    //      - get first query time to this IP, use to reset
    //      priority
    //

    pvisitList = ( PNS_VISIT_LIST ) pQuery->pNsList;
    pvisit = &pvisitList->NsList[ 0 ];
    --pvisit;

    j = pvisitList->VisitCount;
    while( j-- )
    {
        pvisit++;

        if ( DnsAddr_IsZoneRootNode( &pvisit->IpAddress ) )
        {
            pnodeZoneRoot = pvisit->pNsNode;
            continue;
        }

        //  match IP
        //      - note response received
        //      - calculate response time for updating remote

        if ( !pnodeNs )
        {
            if ( DnsAddr_IsEqual(
                    &pvisit->IpAddress,
                    presponseIp,
                    DNSADDR_MATCH_IP ) )
            {
                pnodeNs = pvisit->pNsNode;
                pvisit->Response = TRUE;

                //  do we want to take space for send time?
                //  alternative is simply record last send time AND flag
                //  what iteration first send was on for each IP

                timeDelta = pResponse->dwMsQueryTime - pvisit->Data.SendTime;
                DNS_DEBUG( REMOTE, (
                    "Remote_FindZoneRootOfRespondingNs()\n"
                    "    query time %08X - send time %08X = delta %08X\n",
                    pResponse->dwMsQueryTime,
                    pvisit->Data.SendTime,
                    timeDelta ));
                ASSERT( ( LONG ) timeDelta >= 0 );
            }
            continue;
        }

        //  already found IP match -- then mark all other IP
        //      for this node as responded

        else if ( pvisit->pNsNode == pnodeNs )
        {
            pvisit->Response = TRUE;
            continue;
        }
        else
        {
            break;
        }
    }

    //  not found ?

    if ( !pnodeNs )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Response from NS at %s, NOT in visited NS list\n"
            "    of query (%p)\n",
            DNSADDR_STRING( presponseIp ),
            pQuery ));
        //  TEST_ASSERT( FALSE );
        return NULL;
    }
    ASSERT( pnodeZoneRoot );

    //
    //  reset priority of remote server
    //

    Remote_UpdateResponseTime(
        presponseIp,
        timeDelta,          //  response time in milliseconds
        0 );                //  timeout

    DNS_DEBUG( REMOTE, (
        "Response (%p) for query (%p) from %s\n"
        "    resp. zoneroot   = %s (%p)\n"
        "    resp. time       = %d (ms)\n"
        "    resp. time delta = %d (ms)\n",
        pQuery,
        pResponse,
        DNSADDR_STRING( presponseIp ),
        pnodeZoneRoot->szLabel,
        pnodeZoneRoot,
        pResponse->dwMsQueryTime,
        timeDelta ));

    IF_DEBUG( REMOTE2 )
    {
        Dbg_NsList(
            "NS list after markup for responding NS",
            pvisitList );
    }
    return pnodeZoneRoot;
}



VOID
Remote_SetValidResponse(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pZoneRoot
    )
/*++

Routine Description:

    Save zone root of successfully responding NS.

    This is essentially corrolary of above function.  It merely
    digs out zone root that responded.  This function saves this
    zone root as officially "responded".

Arguments:

    pQuery - ptr to query message

    pZoneRoot - zone root of responding NS

Return Value:

    None

--*/
{
    //
    //  have a valid response from NS for given zone root
    //
    //  this is called when parsing\caching function determines that
    //  we have valid response:
    //      - answer (inc. name error, empty-auth)
    //      - referral to other NS
    //  in this case there's not point in ever requerying NS at this zone
    //  (or above)
    //

    IF_DNSLOG( REMOTE )
    {
        PCHAR       psznode = NULL;
    
        DNSLOG( REMOTE, (
            "Set valid response at node %s for query %p\n",
            psznode = Log_FormatNodeName( pZoneRoot ),
            pQuery ));
        FREE_HEAP( psznode );
    }

    ASSERT( (PNS_VISIT_LIST)pQuery->pNsList );

    ((PNS_VISIT_LIST)pQuery->pNsList)->pZoneRootResponded = pZoneRoot;
}



#if DBG
VOID
Dbg_NsList(
    IN      LPSTR           pszHeader,
    IN      PNS_VISIT_LIST  pNsList
    )
/*++

Routine Description:

    Debug print NS list.

Arguments:

    pszHeader -- header to print

    pNsList -- NS list

Return Value:

    None

--*/
{
    PNS_VISIT   pvisit;
    DWORD       count;

    DnsDebugLock();

    if ( !pszHeader )
    {
        pszHeader = "NS List";
    }

    DnsPrintf(
        "%s:\n"
        "    Count                = %d\n"
        "    VisitCount           = %d\n"
        "    ZoneIndex            = %d\n"
        "    Zone root current    = %s (%p)\n"
        "    Zone root responded  = %s (%p)\n",
        pszHeader,
        pNsList->Count,
        pNsList->VisitCount,
        pNsList->ZoneIndex,
        pNsList->pZoneRootCurrent
            ?   pNsList->pZoneRootCurrent->szLabel
            :   "none",
        pNsList->pZoneRootCurrent,
        pNsList->pZoneRootResponded
            ?   pNsList->pZoneRootResponded->szLabel
            :   "none",
        pNsList->pZoneRootResponded );

    DnsPrintf(
        "List:\n"
        "    IP               Priority  Sends  SendTime    Response  Node\n"
        "    --               --------  -----  --------    --------  ----\n" );

    pvisit = &pNsList->NsList[0];
    count = pNsList->Count;

    while( count-- )
    {
        DnsPrintf(
            "    %-15s %10d   %3d   %10d    %3d     %s\n",
            DNSADDR_STRING( &pvisit->IpAddress ),
            pvisit->Data.Priority,
            pvisit->SendCount,
            pvisit->Data.SendTime,
            pvisit->Response,
            pvisit->pNsNode
                ?   pvisit->pNsNode->szLabel
                :   "NULL" );

        pvisit++;
    }

    DnsDebugUnlock();
}
#endif

//
//  End of remote.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rpcw2k.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    w2krpc.h

Abstract:

    Domain Name System (DNS) Server

    Protypes for functions w2krpc.c

Author:

    Jeff Westhead (jwesth)      October, 2000

Revision History:

--*/


#ifndef _W2KRPC_H_INCLUDED_
#define _W2KRPC_H_INCLUDED_


DNS_STATUS
W2KRpc_GetServerInfo(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    );

DNS_STATUS
W2KRpc_GetZoneInfo(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    );

DNS_STATUS
W2KRpc_EnumZones(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );


#endif  //  _W2KRPC_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rrds.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    rrds.c

Abstract:

    Domain Name System (DNS) Server

    Routines to read and write records from DS.

Author:

    Jim Gilroy (jamesg)     March 1997

Revision History:

--*/


#include "dnssrv.h"



//
//  Record validation routines.
//

DNS_STATUS
AValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate SRV record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check

    if ( wDataLength != SIZEOF_IP_ADDRESS )
    {
        return DNS_ERROR_INVALID_DATA;
    }
    return ERROR_SUCCESS;
}



DNS_STATUS
AaaaValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate SRV record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check

    if ( wDataLength != sizeof(IP6_ADDRESS) )
    {
        return DNS_ERROR_INVALID_DATA;
    }
    return ERROR_SUCCESS;
}



DNS_STATUS
PtrValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate SRV record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check
    //      - must be at least one

    if ( wDataLength < MIN_PTR_SIZE )
    {
        return DNS_ERROR_INVALID_DATA;
    }

    //  PTR target host

    if ( !Name_ValidateDbaseName( &pRR->Data.PTR.nameTarget ) )
    {
        return DNS_ERROR_INVALID_NAME;
    }
    return ERROR_SUCCESS;
}



DNS_STATUS
SoaValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate SOA record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_NAME    pname;

    //  data length check
    //      - must be at least one

    if ( wDataLength < MIN_SOA_SIZE )
    {
        DNS_DEBUG( ANY, ( "Validation of SOA failed -- invalid size!\n" ));
        return DNS_ERROR_INVALID_DATA;
    }

    //  primary server
    //  zone admin

    pname = &pRR->Data.SOA.namePrimaryServer;
    if ( !Name_ValidateDbaseName( pname ) )
    {
        DNS_DEBUG( ANY, ( "Validation of SOA failed -- invalid primary!\n" ));
        return DNS_ERROR_INVALID_NAME;
    }

    pname = (PDB_NAME) Name_SkipDbaseName( pname );
    if ( !Name_ValidateDbaseName( pname ) )
    {
        DNS_DEBUG( ANY, ( "Validation of SOA failed -- invalid admin name!\n" ));
        return DNS_ERROR_INVALID_NAME;
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
MinfoValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate MINFO or RP record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_NAME    pname;

    //  data length check
    //      - must be at least one

    if ( wDataLength < MIN_MINFO_SIZE )
    {
        return DNS_ERROR_INVALID_DATA;
    }

    //  mailbox
    //  errors mailbox

    pname = &pRR->Data.MINFO.nameMailbox;
    if ( !Name_ValidateDbaseName( pname ) )
    {
        return DNS_ERROR_INVALID_NAME;
    }

    pname = (PDB_NAME) Name_SkipDbaseName( pname );
    if ( !Name_ValidateDbaseName( pname ) )
    {
        return DNS_ERROR_INVALID_NAME;
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
MxValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate SRV record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check
    //      - must be at least one

    if ( wDataLength < MIN_MX_SIZE )
    {
        return DNS_ERROR_INVALID_DATA;
    }

    //  MX exhange

    if ( !Name_ValidateDbaseName( &pRR->Data.MX.nameExchange ) )
    {
        return DNS_ERROR_INVALID_NAME;
    }
    return ERROR_SUCCESS;
}



DNS_STATUS
SrvValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate SRV record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check
    //      - must be at least one

    if ( wDataLength < MIN_SRV_SIZE )
    {
        return DNS_ERROR_INVALID_DATA;
    }

    //  SRV target host

    if ( !Name_ValidateDbaseName( & pRR->Data.SRV.nameTarget ) )
    {
        return DNS_ERROR_INVALID_NAME;
    }
    return ERROR_SUCCESS;
}



DNS_STATUS
WinsValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate WINS record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check

    if ( wDataLength < MIN_WINS_SIZE  ||
        wDataLength != SIZEOF_WINS_FIXED_DATA
                + (pRR->Data.WINS.cWinsServerCount * sizeof(IP_ADDRESS)) )
    {
        return DNS_ERROR_INVALID_DATA;
    }

    //  validity check flag?

    return ERROR_SUCCESS;
}



DNS_STATUS
NbstatValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate WINSR record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check
    //      - must be at least one

    if ( wDataLength < MIN_NBSTAT_SIZE )
    {
        return DNS_ERROR_INVALID_DATA;
    }

    //  DEVNOTE: validity check flag

    //
    //  NBSTAT domain
    //

    if ( !Name_ValidateDbaseName( & pRR->Data.WINSR.nameResultDomain ) )
    {
        return DNS_ERROR_INVALID_NAME;
    }
    return ERROR_SUCCESS;
}



DNS_STATUS
UnknownValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate unknown record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  no knowledge about record so -- success

    DNS_DEBUG( DS, (
        "WARNING:  Validating record of unknown type %d\n",
        pRR->wType ));

    return ERROR_SUCCESS;
}



DNS_STATUS
TxtValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate TXT type record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //
    //  DEVNOTE: TEXT types validation.
    //

    return ERROR_SUCCESS;
}



//
//  Record validation routines
//  Use these after read from DS.
//

RR_VALIDATE_FUNCTION  RecordValidateTable[] =
{
    UnknownValidate,    //  ZERO

    AValidate,          //  A
    PtrValidate,        //  NS
    PtrValidate,        //  MD
    PtrValidate,        //  MF
    PtrValidate,        //  CNAME
    SoaValidate,        //  SOA
    PtrValidate,        //  MB
    PtrValidate,        //  MG
    PtrValidate,        //  MR
    NULL,               //  NULL
    NULL,               //  WKS
    PtrValidate,        //  PTR
    TxtValidate,        //  HINFO
    MinfoValidate,      //  MINFO
    MxValidate,         //  MX
    TxtValidate,        //  TXT
    MinfoValidate,      //  RP
    MxValidate,         //  AFSDB
    TxtValidate,        //  X25
    TxtValidate,        //  ISDN
    MxValidate,         //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    NULL,               //  SIG
    NULL,               //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    AaaaValidate,       //  AAAA
    NULL,               //  LOC
    NULL,               //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvValidate,        //  SRV
    NULL,               //  ATMA
    //AtmaValidate,       //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    NULL,               //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    WinsValidate,       //  WINS
    NbstatValidate      //  WINSR
};



PDB_RECORD
Ds_CreateRecordFromDsRecord(
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNodeOwner,
    IN      PDS_RECORD      pDsRecord
    )
/*++

Routine Description:

    Create resource record from DS data.

Arguments:

    pZone       -- zone context, used to lookup non-FQDN names

    pNodeOwner  -- RR owner node

    pDsRecord   -- DS record

Return Value:

    Ptr to new record -- if successful
    NULL on error, error status from GetLastError().

--*/
{
    RR_VALIDATE_FUNCTION    pvalidateFunction;
    PDB_RECORD      prr;
    DNS_STATUS      status = ERROR_SUCCESS;
    WORD            type;
    WORD            dataLength;
    UCHAR           version;


    ASSERT( pNodeOwner && pZone && pDsRecord );

    version = pDsRecord->Version;
    if ( version != DS_NT5_RECORD_VERSION )
    {
        return( NULL );
    }

    type = pDsRecord->wType;
    dataLength = pDsRecord->wDataLength;

    IF_DEBUG( DS2 )
    {
        DNS_PRINT((
            "Creating RR type %s (%d) from DS record.\n",
            DnsRecordStringForType( type ),
            type ));
        Dbg_DsRecord(
            "Record from DS being loaded",
            pDsRecord );
    }

    //
    //  allocate record
    //

    prr = RR_AllocateEx( dataLength, MEMTAG_RECORD_DS );
    IF_NOMEM( !prr )
    {
        ASSERT( FALSE );
        return( NULL );
    }

    //
    //  fix up header
    //

    prr->wType          = type;
    prr->wDataLength    = dataLength;
    prr->dwTtlSeconds   = pDsRecord->dwTtlSeconds;
    prr->dwTimeStamp    = pDsRecord->dwTimeStamp;

    //
    //  copy record data
    //

    RtlCopyMemory(
        & prr->Data,
        & pDsRecord->Data,
        dataLength );

    //
    //  dispatch to validate record
    //

    pvalidateFunction = (RR_VALIDATE_FUNCTION)
                        RR_DispatchFunctionForType(
                            RecordValidateTable,
                            type );
    if ( !pvalidateFunction )
    {
        ASSERT( FALSE );
        status = DNS_ERROR_RCODE_SERVER_FAILURE;
        goto Failed;
    }

    status = pvalidateFunction( prr, dataLength );

    if ( status != ERROR_SUCCESS )
    {
        if ( status == DNS_INFO_ADDED_LOCAL_WINS )
        {
            goto FailedOk;
        }
        DNS_PRINT((
            "ERROR:  RecordValidateRoutine failure for record type %d.\n\n\n",
            type ));
        goto Failed;
    }

    //
    //  outside zone check
    //
    //  note:  RANK reset in RR_AddToNode() or RR_AddUpdateToNode() functions
    //
    //  note rank setting here isn't good enough anyway because do not
    //  know final status of node;  example adding delegation NS takes
    //  place INSIDE the zone when we first do it;  only on ADD does
    //  the node become desired delegation node
    //
    //  only sure way of catching all outside zone data is to do a check
    //  post-load;  then we can catch ALL records outside the zone and verify
    //  that they correspond to NS hosts in the zone and are of the proper type;
    //  this is tedious and unnecessary as random outside the zone data has
    //  no effect and will not be written on file write back
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        SET_RANK_ROOT_HINT(prr);
    }
    else
    {
        UCHAR rank = RANK_ZONE;

        if ( !IS_AUTH_NODE(pNodeOwner) )
        {
            DNS_DEBUG( DS2, (
                "Read DS node outside zone %s (%p).\n"
                "\tzone root        = %p\n"
                "\tRR type          = %d\n"
                "\tnode ptr         = %p\n"
                "\tnode zone ptr    = %p\n",
                pZone->pszZoneName,
                pZone,
                pZone->pZoneRoot,
                type,
                pNodeOwner,
                pNodeOwner->pZone ));

            if ( type == DNS_TYPE_NS )
            {
                if ( !IS_DELEGATION_NODE(pNodeOwner) )
                {
                    DNS_PRINT(( "NS node outside zone -- ignoring.\n" ));
                    status = DNS_ERROR_INVALID_NAME;
                    goto IgnoreableError;
                }
                rank = RANK_NS_GLUE;
            }
            else if ( IS_SUBZONE_TYPE(type) )
            {
                //  see note in dfread about outside zone data

                rank = RANK_GLUE;
            }
            else
            {
                DNS_PRINT(( "Record node outside zone -- ignoring.\n" ));
                status = DNS_ERROR_INVALID_NAME;
                goto IgnoreableError;
            }
        }
        SET_RR_RANK( prr, rank );
    }

    #if 0

    Success:

    //
    //  save as example of how we'd handle DS versioning
    //  currently only one DS version -- no need to save
    //
    //  return new record
    //  set zone version to highest record version
    //

    if ( pZone->ucDsRecordVersion < version )
    {
        DNS_DEBUG( DS, (
            "DS Zone %s, reset from DS version %d to %d\n",
            pZone->pszZoneName,
            pZone->ucDsRecordVersion,
            version ));
        pZone->ucDsRecordVersion = version;
    }

    #endif

    return( prr );


IgnoreableError:

    //  DEVNOTE-LOG: log when record outside zone and not proper glue
    //      note this can happen if zone boundaries change
    //
    //  DEVNOTE: eliminate outside zone data from DS?
    //
    //  DEVNOTE: include type in logging

Failed:

    {
        PCHAR   pszargs[2];
        CHAR    sznodeName[ DNS_MAX_NAME_BUFFER_LENGTH ];

        Name_PlaceFullNodeNameInBuffer(
            sznodeName,
            sznodeName + DNS_MAX_NAME_BUFFER_LENGTH,
            pNodeOwner );

        pszargs[0] = sznodeName;
        pszargs[1] = pZone->pszZoneName;

        DNS_LOG_EVENT(
            DNS_EVENT_DS_RECORD_LOAD_FAILED,
            2,
            pszargs,
            EVENTARG_ALL_UTF8,
            status );
    }
    if ( prr )
    {
        RR_Free( prr );
    }

FailedOk:

    SetLastError( status );
    return( NULL );
}


//
//  End rrds.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rrcache.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    rrcache.c

Abstract:

    Domain Name System (DNS) Server

    Write packet resource records to database.

Author:

    Jim Gilroy (jamesg)     March, 1995

Revision History:

    jamesg  Jun 1995    --  extended routine to write to separate
                            database for zone transfer
    jamesg  Jul 1995    --  moved to this file for easier access
    jamesg  Jul 1997    --  data ranking, cache pollution

--*/


#include "dnssrv.h"


//
//  Rank for cached RRs
//      - row is section index
//      - column is authoritative (1) or non-authoritative (0)
//

UCHAR   CachingRankArray[4][2] =
{
    0,                          0,
    RANK_CACHE_NA_ANSWER,       RANK_CACHE_A_ANSWER,
    RANK_CACHE_NA_AUTHORITY,    RANK_CACHE_A_AUTHORITY,
    RANK_CACHE_NA_ADDITIONAL,   RANK_CACHE_A_ADDITIONAL
};

#define CacheRankForSection( iSection, fAuthoritative ) \
        ( CachingRankArray[ iSection ][ fAuthoritative ] )


//
//  Flag to indicate name error caching has already been done
//

#define NAME_ERROR_ALREADY_CACHED (2)


//  Internet Root NS domain - used to determine if caching Internet NS

#define g_cchInternetRootNsDomain   18

UCHAR g_InternetRootNsDomain[] =
{
    0x0C, 'r', 'o', 'o', 't', '-', 's', 'e', 'r', 'v', 'e', 'r', 's',
    0x03, 'n', 'e', 't', 0x00
};

extern DWORD g_fUsingInternetRootServers;



VOID
testCacheSize(
    VOID
    )
/*++

Routine Description:

    Tests current cache size. If cache exceeds desired limit,
    set cache enforcement event.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "testCacheSize" )

    DWORD       cacheLimitInBytes = SrvCfg_dwMaxCacheSize;

    //
    //  Is cache over the limit?
    //

    if ( cacheLimitInBytes == DNS_SERVER_UNLIMITED_CACHE_SIZE ||
        DNS_SERVER_CURRENT_CACHE_BYTES < cacheLimitInBytes )
    {
        return;
    }

    //
    //  Cache is over limit!
    //

    STAT_INC( CacheStats.CacheExceededLimitChecks );

    DNS_DEBUG( ANY, (
        "%s: cache is over limit: current %ld max %ld (bytes)\n"
        "    this has happened %ld times\n", fn,
        DNS_SERVER_CURRENT_CACHE_BYTES,
        cacheLimitInBytes,
        CacheStats.CacheExceededLimitChecks ));

    SetEvent( hDnsCacheLimitEvent );
}   //  testCacheSize



BOOL
isNodeCacheable(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Tests if node represents uncacheable name such as "localhost".
    
    NOTE: This function could be replaced by -populated cache nodes
    at some point in the future. Until this, it is imperative that
    this function execute quickly in all common cases.

Arguments:

    pNode -- node where data is about to be cached

Return Value:

    TRUE if node will accept cache resource records, else FALSE.

--*/
{
    BOOL    isNodeCacheable = TRUE;

    ASSERT( pNode );

    if ( pNode->cLabelCount == 1 )
    {
        //
        //  Test for non-cacheable single label names.
        //
        
        if ( pNode->cchLabelLength == 9 &&
             RtlEqualMemory( NTree_GetDowncasedLabel( pNode ),
                             "localhost",
                             9 ) )
        {
            isNodeCacheable = FALSE;
        }
    }
    
    return isNodeCacheable;
}   //  isNodeCacheable



//
//  Message processing error routines
//

VOID
Wire_ServerFailureProcessingPacket(
    IN      PDNS_MSGINFO    pMsg,
    IN      DWORD           dwEvent
    )
/*++

Routine Description:

    Server failure encountered processing a packet.

Arguments:

    pMsg - message being processed

    dwEvent - additional event message detail

Return Value:

    None.

--*/
{
    CHAR    szaddr[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

    DnsAddr_WriteIpString_A( szaddr, &pMsg->RemoteAddr );

    DNS_LOG_EVENT_BAD_PACKET(
        DNS_EVENT_SERVER_FAILURE_PROCESSING_PACKET,
        pMsg );

    DNS_PRINT((
        "Server failure processing packet from DNS server %s\n"
        "    Unable to allocate RR\n",
        szaddr ));

    ASSERT( FALSE );
}



VOID
Wire_PacketError(
    IN      PDNS_MSGINFO    pMsg,
    IN      DWORD           dwEvent
    )
/*++

Routine Description:

    Bad packet encountered from remote DNS server.

Arguments:

    pMsg - message being processed

    dwEvent - additional event message detail

Return Value:

    None.

--*/
{
    DNS_LOG_EVENT_BAD_PACKET(
        DNS_EVENT_BAD_PACKET_LENGTH,
        pMsg );

    IF_DEBUG( ANY )
    {
        LPSTR   pszserverIp = MSG_IP_STRING( pMsg );

        DnsDebugLock();
        DNS_PRINT((
            "Packet error in packet from DNS server %s\n"
            "Packet parsing leads beyond length of packet - discarding packet\n",
            pszserverIp ));
        Dbg_DnsMessage(
            "Server packet with name error:",
             pMsg );
        DnsDebugUnlock();
    }
}



VOID
Wire_PacketNameError(
    IN      PDNS_MSGINFO    pMsg,
    IN      DWORD           dwEvent,
    IN      WORD            wOffset
    )
/*++

Routine Description:

    Bad packet encountered from remote DNS server.

Arguments:

    pMsg - message being processed

    dwEvent - additional event message detail

Return Value:

    None.

--*/
{
    DNS_LOG_EVENT_BAD_PACKET(
        DNS_EVENT_INVALID_PACKET_DOMAIN_NAME,
        pMsg );

    IF_DEBUG( ANY )
    {
        LPSTR   pszserverIp = MSG_IP_STRING( pMsg );

        DnsDebugLock();
        DNS_PRINT((
            "Name error in packet from DNS server %s, discarding packet\n",
            pszserverIp ));
        DNS_PRINT((
            "Name error in packet at offset = %d (%0x04hx)\n",
            wOffset, wOffset ));
        Dbg_DnsMessage(
            "Server packet with name error:",
            pMsg );
        DnsDebugUnlock();
    }
}



DNS_STATUS
Xfr_ReadXfrMesssageToDatabase(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process response from another DNS server.

    This writes RR in message to database.  For zone transfer messages
    written to temporary database for new zone.   For referrals, or
    caching of server generated responses (WINS, CAIRO, etc.) records
    are cached in directly in database, with caching TTLs.

Arguments:

    pMsg - ptr to response info

    pdbZoneXfr - temporary zone transfer database;  NULL for referral

    ppZoneRoot - addr of ptr to root of new zone;  ptr set to NULL on
                    first call and is set to first node written;  then
                    this value should be returned in subsequent calls

Return Value:

    Zero if successful
    Otherwise error code.

--*/
{
    register PCHAR      pchdata = 0;
    PCHAR               pchname;
    PCHAR               pchnextName;
    PDNS_WIRE_RECORD    pwireRR;
    PDB_RECORD          prr = NULL;
    PDB_NODE            pnode;
    INT                 crecordsTotal;
    INT                 countRecords;
    WORD                type;
    WORD                wlength;
    WORD                index;
    PCHAR               pchpacketEnd;
    PCHAR               pszserverIp;
    DNS_STATUS          status;
    PARSE_RECORD        parseRR;

    //
    //  never have any AXFR RCODE except success
    //

    if ( pMsg->Head.ResponseCode != DNS_RCODE_NO_ERROR )
    {
        return DNS_ERROR_RCODE;
    }

    //
    //  total resource records in response
    //
    //  no records
    //      -> if name error continue, to get name and cache NAME_ERROR
    //      -> otherwise return no
    //
    //  for stub zones, additional and/or NS RRs are processed
    //

    crecordsTotal = pMsg->Head.AnswerCount;

    if ( IS_ZONE_STUB( pZone ) )
    {
        crecordsTotal += pMsg->Head.AdditionalCount + pMsg->Head.NameServerCount;
    }
    else if ( pMsg->Head.AdditionalCount || pMsg->Head.NameServerCount )
    {
        DNS_PRINT((
            "ERROR:  AXFR packet with additional or authority records!\n" ));
        goto PacketError;
    }
    DNS_DEBUG( ZONEXFR2, (
        "AXFR Message at %p contains %d resource records\n",
        pMsg,
        crecordsTotal ));

    //
    //  write responses into database
    //
    //  loop through all resource records
    //      - skip question
    //      - write other RRs to database
    //

    pchpacketEnd = DNSMSG_END( pMsg );
    pchnextName = pMsg->MessageBody;

    for ( countRecords = 0;
            countRecords < (crecordsTotal + pMsg->Head.QuestionCount);
              countRecords ++ )
    {
        //  clear prr -- makes it easy to determine when needs free

        prr = NULL;

        //  get ptr to next RR name
        //      - insure we stay within message

        pchname = pchnextName;
        if ( pchname >= pchpacketEnd )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  bad packet, at end of packet length with"
                "more records to process\n"
                "    packet length = %ld\n"
                "    current offset = %ld\n",
                pMsg->MessageLength,
                DNSMSG_OFFSET( pMsg, pchdata ) ));
            goto PacketError;
        }

        //  skip RR name, get struct

        IF_DEBUG( READ2 )
        {
            Dbg_MessageName(
                "Record name ",
                pchname,
                pMsg );
        }
        pchdata = Wire_SkipPacketName( pMsg, pchname );
        if ( !pchdata )
        {
            goto PacketNameError;
        }

        //
        //  skip question
        //
        //  DEVNOTE: could match AXFR question name with zone root
        //

        if ( countRecords < pMsg->Head.QuestionCount )
        {
            if ( pchdata > pchpacketEnd - sizeof(DNS_QUESTION) )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  bad packet, not enough space remaining for question" ));
                goto PacketError;
            }
            pchnextName = pchdata + sizeof( DNS_QUESTION );
            continue;
        }

        //
        //  create new node in load database
        //

        pnode = Lookup_ZoneNode(
                    pZone,
                    pchname,
                    pMsg,
                    NULL,       // no lookup name
                    LOOKUP_LOAD | LOOKUP_NAME_FQDN,
                    NULL,       // create mode
                    NULL );     // following node ptr
        if ( !pnode )
        {
            DNS_DEBUG( ANY, (
               "ERROR:  PacketNameError in Xfr_ReadXfrMesssageToDatabase()\n"
               "    packet = %p\n"
               "    offending name at %p\n",
               pMsg,
               pchname ));
            ASSERT( FALSE );
            goto PacketNameError;
        }

        //
        //  extract RR info, type, datalength
        //      - verify RR within message
        //

        pchnextName = Wire_ParseWireRecord(
                        pchdata,
                        pchpacketEnd,
                        TRUE,           // class IN required
                        &parseRR );
        if ( !pchnextName )
        {
            DNS_PRINT(( "ERROR:  bad RR in AXFR packet\n" ));
            //status = DNS_RCODE_FORMAT_ERROR;
            goto PacketError;
        }

        //
        //  zone transfer first/last zone SOA record matching
        //      - first RR is SOA, save root node
        //      - if have root node, check for matching last node of zone
        //          transfer
        //

        if ( !IS_ZONE_STUB( pZone ) )
        {
            if ( !RECEIVED_XFR_STARTUP_SOA( pMsg ) )
            {
                if ( parseRR.wType != DNS_TYPE_SOA )
                {
                    DNS_PRINT(( "ERROR:  first AXFR record is NOT SOA!!!\n" ));
                    goto PacketError;
                }
                RECEIVED_XFR_STARTUP_SOA( pMsg ) = TRUE;
            }
            else if ( pnode == pZone->pLoadZoneRoot )
            {
                //  when again receive SOA for zone root -- we're done

                if ( parseRR.wType == DNS_TYPE_SOA )
                {
                    return DNSSRV_STATUS_AXFR_COMPLETE;
                }
            }
        }

        //
        //  dispatch RR create function for desired type
        //      - special types (SOA, NS) need node info, write it to packet
        //      - all unknown types get flat data copy
        //

        pMsg->pnodeCurrent = pnode;

        prr = Wire_CreateRecordFromWire(
                    pMsg,
                    & parseRR,
                    parseRR.pchData,
                    MEMTAG_RECORD_AXFR );
        if ( !prr )
        {
            //
            //  DEVNOTE: Should have some way to distiguish bad record, from
            //      unknown type, etc.

            //
            //  DEVNOTE-LOG: log record creation failure
            //

            DNS_PRINT((
                "ERROR:  failed record create in AXFR !!!\n" ));
            continue;
        }

        //
        //  zone transfer -- add RR to temp database
        //
        //      - RR rank set in RR_AddToNode()
        //
        //  note:  not setting RR flags to indicate fixed or default TTL;
        //  since we are secondary, SOA won't change, until new transfer
        //  and can write back TTL based on whether matches SOA default;
        //  this is only broken when secondary promoted to primary,
        //  then SOA changed -- not worth worrying about
        //

        status = RR_AddToNode(
                    pZone,
                    pnode,
                    prr );
        if ( status != ERROR_SUCCESS )
        {
            PCHAR   pszargs[3];
            CHAR    sznodeName[ DNS_MAX_NAME_BUFFER_LENGTH ];

            RR_Free( prr );
            prr = NULL;

            Name_PlaceFullNodeNameInBuffer(
                sznodeName,
                sznodeName + DNS_MAX_NAME_BUFFER_LENGTH,
                pnode );

            pszargs[0] = pZone->pszZoneName;
            pszargs[1] = MSG_IP_STRING( pMsg );
            pszargs[2] = sznodeName;

            DNS_PRINT((
                "ERROR:  Adding record during AXFR recv\n"
                "    zone= %s\n"
                "    at node %s\n"
                "    master = %s\n"
                "    RR_AddToNode status = %p\n",
                pZone->pszZoneName,
                pszargs[2],
                pszargs[1],
                status ));

            switch ( status )
            {
                case DNS_ERROR_RECORD_ALREADY_EXISTS:
                    continue;

                case DNS_ERROR_NODE_IS_CNAME:
                    DNS_LOG_EVENT(
                        DNS_EVENT_XFR_ADD_RR_AT_CNAME,
                        3,
                        pszargs,
                        EVENTARG_ALL_UTF8,
                        0 );
                    continue;

                case DNS_ERROR_CNAME_COLLISION:
                    DNS_LOG_EVENT(
                        DNS_EVENT_XFR_CNAME_NOT_ALONE,
                        3,
                        pszargs,
                        EVENTARG_ALL_UTF8,
                        0 );
                    continue;

                case DNS_ERROR_CNAME_LOOP:
                    DNS_LOG_EVENT(
                        DNS_EVENT_XFR_CNAME_LOOP,
                        3,
                        pszargs,
                        EVENTARG_ALL_UTF8,
                        0 );
                    continue;

                default:
                    DNS_PRINT((
                        "ERROR:  UNKNOWN status %p from RR_Add\n",
                        status ));
                    ASSERT( FALSE );
                    goto ServerFailure;
            }
            continue;
        }

    }   // loop through RRs

    return ERROR_SUCCESS;


PacketNameError:

    Wire_PacketNameError( pMsg, 0, (WORD)(pchdata - (PCHAR)&pMsg->Head) );
    status = DNS_ERROR_INVALID_NAME;
    goto ErrorCleanup;

PacketError:

    Wire_PacketError( pMsg, 0 );
    status = DNS_ERROR_BAD_PACKET;
    goto ErrorCleanup;

ServerFailure:

    Wire_ServerFailureProcessingPacket( pMsg, 0 );
    status = DNS_ERROR_RCODE_SERVER_FAILURE;
    goto ErrorCleanup;

ErrorCleanup:

    if ( prr )
    {
        RR_Free( prr );
    }
    return status;
}



//
//  End rrcache.c
//



DNS_STATUS
Xfr_ParseIxfrResponse(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PUPDATE_LIST    pPassUpdateList
    )
/*++

Routine Description:

    Process response from another DNS server.

    This writes RR in message to database.  For zone transfer messages
    written to temporary database for new zone.   For referrals, or
    caching of server generated responses (WINS, CAIRO, etc.) records
    are cached in directly in database, with caching TTLs.

Arguments:

    pMsg - ptr to response info

    pUpdateList - update list to receive IXFR changes

    pPassUpdateList - update list for this pass only


    fFirst - TRUE for first message of transfer;  FALSE otherwise

Return Value:

    ERROR_SUCCESS if message successfully parsed but IXFR not complete.
    DNSSRV_STATUS_AXFR_COMPLETE if IXFR complete.
    DNSSRV_STATUS_NEED_AXFR if response is need AXFR response.
    DNSSRV_STATUS_AXFR_IN_IXFR if response is full AXFR.

    DNSSRV_STATUS_IXFR_UNSUPPORTED if master does not seem to support IXFR.
    DNS_ERROR_RCODE for other RCODE error.
    DNS_ERROR_INVALID_NAME bad name in packet
    DNS_ERROR_BAD_PACKET bad packet

--*/
{
    register PCHAR      pchdata = 0;
    PCHAR               pchname;
    PCHAR               pchnextName;
    PCHAR               pchpacketEnd;
    PDB_RECORD          prr = NULL;
    PDB_NODE            pnode;
    INT                 crecordsTotal;
    INT                 countRecords;
    PCHAR               pszserverIp;
    DNS_STATUS          status;
    DWORD               soaVersion;
    DWORD               version = 0;
    BOOL                fadd;
    BOOL                fdone = FALSE;
    PARSE_RECORD        parseRR;


    DNS_DEBUG( XFR, (
        "ParseIxfrResponse at at %p\n",
        pMsg ));

    //
    //  RCODE should always be success
    //
    //  if FORMAT_ERROR or NOT_IMPLEMENTED, on first packet, then
    //      master doesn't understand IXFR
    //

    if ( pMsg->Head.ResponseCode != DNS_RCODE_NO_ERROR )
    {
        if ( XFR_MESSAGE_NUMBER( pMsg ) == 1 &&
            ( pMsg->Head.ResponseCode == DNS_RCODE_FORMAT_ERROR ||
              pMsg->Head.ResponseCode == DNS_RCODE_NOT_IMPLEMENTED ) )
        {
            return DNSSRV_STATUS_IXFR_UNSUPPORTED;
        }
        return DNS_ERROR_RCODE;
    }

    //  total resource records in response
    //      - no records => error
    //      - authority records or additional records => error
    //
    //  DEVNOTE: will security add additional records to IXFR\AXFR?

    crecordsTotal = pMsg->Head.AnswerCount;

    if ( crecordsTotal == 0  ||
        pMsg->Head.AdditionalCount || pMsg->Head.NameServerCount )
    {
        DNS_PRINT((
            "ERROR:  IXFR packet with additional or authority records!\n" ));
        goto PacketError;
    }

    DNS_DEBUG( ZONEXFR2, (
        "IXFR Message at %p contains %d resource records\n",
        pMsg,
        crecordsTotal ));

    //
    //  recover IXFR add\delete section info of previous message
    //

    if ( XFR_MESSAGE_NUMBER( pMsg ) > 1 )
    {
        if ( RECEIVED_XFR_STARTUP_SOA( pMsg ) )
        {
            version = IXFR_LAST_SOA_VERSION( pMsg );
            fadd = IXFR_LAST_PASS_ADD( pMsg );

            ASSERT( pMsg->fTcp );
            ASSERT( RECEIVED_XFR_STARTUP_SOA( pMsg ) );
            ASSERT( version != 0 );
        }
    }

    //
    //  single SOA in first packet?
    //
    //  note, for TCP we need to get out here, because BIND will still
    //  send one RR per packet if doing AXFR in IXFR;  if we
    //  fall through and hence don't detect that we don't have IXFR until
    //  the second message, then we won't have the first message around
    //  to send to AXFR processing
    //

    else if ( pMsg->Head.AnswerCount == 1 )
    {
        if ( pMsg->fTcp )
        {
            //
            //  If answer count is one we won't be able to tell if this an 
            //  IXFR or an AXFR until we get the next packet! So drop down
            //  and parse this RR.
            //
        }
        else
        {
            DNS_DEBUG( ZONEXFR, (
                "UDP IXFR packet %p contains single SOA -- need TCP\n",
                pMsg ));
            return DNSSRV_STATUS_NEED_AXFR;
        }
    }

    //
    //  write responses into database
    //
    //  loop through all resource records
    //      - skip question
    //      - write other RRs to database
    //

    pchpacketEnd = DNSMSG_END( pMsg );
    pchnextName = pMsg->MessageBody;

    for ( countRecords = 0;
          countRecords < (crecordsTotal + pMsg->Head.QuestionCount);
          countRecords ++ )
    {
        //  clear prr -- makes it easy to determine when needs free

        prr = NULL;

        //  get ptr to next RR name
        //      - insure we stay within message

        pchname = pchnextName;
        if ( pchname >= pchpacketEnd )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  bad packet, at end of packet length with"
                "more records to process\n"
                "    packet length = %ld\n"
                "    current offset = %ld\n",
                pMsg->MessageLength,
                DNSMSG_OFFSET( pMsg, pchdata ) ));
            goto PacketError;
        }

        //  skip RR name, get struct

        IF_DEBUG( READ2 )
        {
            Dbg_MessageName(
                "Record name ",
                pchname,
                pMsg );
        }
        pchdata = Wire_SkipPacketName( pMsg, pchname );
        if ( !pchdata )
        {
            goto PacketNameError;
        }

        //
        //  read question name -- must be zone root
        //  note this also has the affect of "seeding" packet
        //  compression information with zone root, which speeds later
        //  lookups
        //

        if ( countRecords < pMsg->Head.QuestionCount )
        {
            PDB_NODE    pclosestNode;

            pnode = Lookup_ZoneNode(
                        pMsg->pzoneCurrent,
                        pchname,
                        pMsg,
                        NULL,               //  no lookup name
                        0,                  //  no flag
                        & pclosestNode,     //  find node
                        NULL );             //  following node ptr
            if ( !pnode  ||  pnode != pMsg->pzoneCurrent->pZoneRoot )
            {
                CLIENT_ASSERT( FALSE );
                goto PacketNameError;
            }
            if ( pchdata > pchpacketEnd - sizeof(DNS_QUESTION) )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  bad packet, not enough space remaining for question\n" ));
                goto PacketError;
            }
            pchnextName = pchdata + sizeof( DNS_QUESTION );
            continue;
        }

        //
        //  extract and validate RR info
        //      - type
        //      - datalength
        //      - get RR data ptr
        //  save ptr to next RR name
        //

        pchnextName = Wire_ParseWireRecord(
                            pchdata,
                            pchpacketEnd,
                            TRUE,           // class IN only
                            &parseRR );
        if ( !pchnextName )
        {
            CLIENT_ASSERT( FALSE );
            goto PacketError;
        }
        pchdata += sizeof(DNS_WIRE_RECORD);

        //
        //  check SOA records
        //      - pull out version of SOA
        //
        //  1) first SOA record gives new (master) version
        //  2) second is client request version
        //  3) remaining indicate boundaries between add and delete sections
        //      - at end of add pass, version matches previous
        //          => switch to delete
        //          => when matches master version => exit
        //      - at end of delete pass, get version of delete pass
        //          => switch to add pass
        //  note on final SOA we skip end of version processing so we can
        //  build database record for final SOA and include it in last update
        //

        if ( parseRR.wType == DNS_TYPE_SOA )
        {
            soaVersion = SOA_VERSION_OF_PREVIOUS_RECORD( pchnextName );

            if ( version )
            {
                if ( fadd )
                {
                    if ( soaVersion != version )
                    {
                        CLIENT_ASSERT( FALSE );
                        goto PacketError;
                    }
                    if ( soaVersion == IXFR_MASTER_VERSION( pMsg ) )
                    {
                        fdone = TRUE;
                        goto RecordCreate;      // skip end of pass processing
                    }
                    fadd = FALSE;
                    continue;
                }
                else    // end of delete pass
                {
                    if ( soaVersion <= version )
                    {
                        CLIENT_ASSERT( FALSE );
                        goto PacketError;
                    }
                    fadd = TRUE;
                    version = soaVersion;
                }

                //  append update list for this pass, to IXFR master

                Up_AppendUpdateList(
                        pUpdateList,
                        pPassUpdateList,
                        version             // set to new version
                        );
                Up_InitUpdateList( pPassUpdateList );
            }

            //  first SOA?  --  master version

            else if ( !IXFR_MASTER_VERSION( pMsg ) )
            {
                IXFR_MASTER_VERSION( pMsg ) = soaVersion;
                continue;
            }

            //  second SOA  -- client request version

            else if ( soaVersion <= IXFR_CLIENT_VERSION( pMsg ) )
            {
                version = soaVersion;
                fadd = FALSE;
                RECEIVED_XFR_STARTUP_SOA( pMsg ) = TRUE;
                continue;
            }
            else
            {
                CLIENT_ASSERT( FALSE );
                goto PacketError;
            }
        }

        //
        //  if not SOA, make sure we have received first two SOA records
        //  (master version and client version);
        //
        //  if receive record after single SOA, then this is really an AXFR
        //      => return and fall through to AXFR processing
        //

        else if ( !RECEIVED_XFR_STARTUP_SOA( pMsg ) )
        {
            if ( IXFR_MASTER_VERSION( pMsg ) )
            {
                DNS_DEBUG( ZONEXFR, (
                    "IXFR packet %p contains no second SOA -- AXFR in IXFR\n",
                    pMsg ));
                return DNSSRV_STATUS_AXFR_IN_IXFR;
            }
            //  if haven't received any SOA, then bum packet
            CLIENT_ASSERT( FALSE );
            goto PacketError;
        }

RecordCreate:

        //
        //  find\create node
        //
        //  DEVNOTE: Optimization don't create node for delete records case
        //      but note that this would prevent follow through transfer.
        //

        pnode = Lookup_ZoneNode(
                    pMsg->pzoneCurrent,
                    pchname,
                    pMsg,
                    NULL,           // no lookup name
                    0,              // no flag
                    NULL,           // create mode
                    NULL );         // following node ptr
        if ( !pnode )
        {
            goto PacketNameError;
        }

        //
        //  build database record
        //

        prr = Wire_CreateRecordFromWire(
                pMsg,
                & parseRR,
                pchdata,
                MEMTAG_RECORD_IXFR );
        if ( !prr )
        {
            goto PacketError;
        }

        //
        //  put new record in update list add\delete pass
        //

        Up_CreateAppendUpdate(
                pPassUpdateList,
                pnode,
                ( fadd ) ? prr : NULL,
                0,
                ( fadd ) ? NULL : prr );

    }   // loop through RRs

    //
    //  done?
    //      if done append last add list, we hold off doing this
    //      when detect final SOA, because we go on to build a dbase RR
    //      for the final SOA and include it as part of the final update
    //

    if ( fdone )
    {
        ASSERT( prr->wType == DNS_TYPE_SOA );
        ASSERT( ntohl(prr->Data.SOA.dwSerialNo) == IXFR_MASTER_VERSION( pMsg ) );

        Up_AppendUpdateList(
                pUpdateList,
                pPassUpdateList,
                0 );                    //  no need to set version
        Up_InitUpdateList( pPassUpdateList );
        return DNSSRV_STATUS_AXFR_COMPLETE;
    }

    //
    //  TCP IXFR with multiple messages
    //      - save current version section info
    //      - ERROR_SUCCESS to indicate successful UN-completed IXFR
    //

    if ( pMsg->fTcp )
    {
        IXFR_LAST_SOA_VERSION( pMsg ) = version;
        IXFR_LAST_PASS_ADD( pMsg ) = (BOOLEAN) fadd;

        DNS_DEBUG( XFR, (
            "Parsed IXFR TCP message #%d at %p\n"
            "    saved fAdd = %d\n"
            "    saved version = %d\n",
            XFR_MESSAGE_NUMBER( pMsg ),
            pMsg,
            fadd,
            version ));
        return ERROR_SUCCESS;
    }

    //
    //  successfully parsed all records if completed loop
    //      so any remaining pRR is in pPassUpdateList
    //      make sure we don't clean it up if encounter error

    prr = NULL;

    //
    //  UDP IXFR where master could NOT fit all the records in response
    //      will have single SOA corresponding to new version
    //

    if ( pMsg->Head.AnswerCount == 1 )
    {
        ASSERT( !RECEIVED_XFR_STARTUP_SOA( pMsg ) );
        ASSERT( IXFR_MASTER_VERSION( pMsg ) );

        return DNSSRV_STATUS_NEED_AXFR;
    }
    else
    {
        PCHAR   pszargs[ 2 ];

        pszargs[ 0 ] = pMsg->pzoneCurrent->pszZoneName;
        pszargs[ 1 ] = MSG_IP_STRING( pMsg );

        DNS_PRINT((
            "ERROR:  incomplete UDP IXFR packet at %p\n"
            "    from server %s\n"
            "    for zone %s\n",
            pMsg,
            pszargs[ 1 ],
            pszargs[ 0 ] ));

        DNS_LOG_EVENT(
            DNS_EVENT_IXFR_BAD_RESPONSE,
            2,
            pszargs,
            EVENTARG_ALL_UTF8,
            0 );
        goto PacketError;
    }

PacketNameError:

    Wire_PacketNameError( pMsg, 0, (WORD)(pchdata - (PCHAR)&pMsg->Head) );
    status = DNS_ERROR_INVALID_NAME;
    goto ErrorCleanup;

PacketError:

    Wire_PacketError( pMsg, 0 );
    status = DNS_ERROR_BAD_PACKET;
    goto ErrorCleanup;

ErrorCleanup:

    if ( prr )
    {
        RR_Free( prr );
    }
    return status;
}




DNS_STATUS
Recurse_CacheMessageResourceRecords(
    IN      PDNS_MSGINFO    pMsg,
    IN OUT  PDNS_MSGINFO    pQuery,
    OUT     PBOOL           pfCnameAnswer   OPTIONAL
    )
/*++

Routine Description:

    Process and cache response from another DNS server.
    This writes RR in message to database.

Arguments:


    pMsg - ptr to response message info

    pQuery - ptr to original query message info
    
    pfCnameAnswer - out value is TRUE if the answer contains
        a CNAME, else it is false

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_RCODE_NAME_ERROR if name error.
    DNS_ERROR_NAME_NOT_IN_ZONE if unable to cache record outside NS zone.
    DNS_INFO_NO_RECORDS if this is an empty auth response.
    Error code on bad packet failure or other RCODE responses.

--*/
{
    #define             DNS_SECONDS_BETWEEN_CACHE_TESTS     30

    register PCHAR      pch;
    BOOL                fcnameAnswer = FALSE;
    PCHAR               pchnextName;
    PCHAR               pchcurrentName;
    PDB_RECORD          prr = NULL;
    PDB_NODE            pnode = NULL;
    PDB_NODE            pnodePrevious = NULL;
    PDB_NODE            pnodeQueried;
    WORD                type;
    WORD                typePrevious = 0;
    WORD                offset;
    WORD                offsetPrevious = 0;
    DWORD               minTtl = 0xFFFFFFFF;
    DWORD               ttlForSet = SrvCfg_dwMaxCacheTtl;
    DWORD               ttlTemp;
    PDB_NODE            pnodeQuestion = NULL;
    PCHAR               pchpacketEnd;
    PCHAR               pszserverIp;
    BOOL                fnameError = FALSE;
    BOOL                fignoreRecord = FALSE;
    BOOL                fnoforwardResponse = FALSE;
    BOOL                fanswered = FALSE;
    BOOL                forwardTruncatedResponse = FALSE;
    DNS_STATUS          status;
    INT                 sectionIndex;
    WORD                countSectionRR;
    UCHAR               rank;
    DNS_LIST            listRR;
    DWORD               i;
    PARSE_RECORD        parseRR;
    DWORD               femptyAuthResponse = 0;     //  count of SOAs
    static DWORD        lastCacheCheckTime = 0;

    DNS_DEBUG( READ2, (
        "Recurse_CacheMessageResourceRecords()\n"
        "    response = %p\n"
        "    query    = %p, query time = %p\n",
        pMsg,
        pQuery,
        pQuery->dwQueryTime ));

    //
    //  Test current cache size - only perform test every X seconds.
    //

    if ( DNS_TIME() - lastCacheCheckTime > DNS_SECONDS_BETWEEN_CACHE_TESTS )
    {
        testCacheSize();
        lastCacheCheckTime = DNS_TIME();
    }

    //
    //  authoritative response
    //      - ends queries for THIS question
    //      (may continue following CNAME, but this question is settled)
    //

    if ( pMsg->Head.Authoritative )
    {
        pQuery->fQuestionCompleted = TRUE;
        STAT_INC( RecurseStats.ResponseAuthoritative );
    }
    else
    {
        STAT_INC( RecurseStats.ResponseNotAuth );
    }

    //
    //  forwarding response
    //      - any valid forwarders response ends queries on this question
    //      - no checking RRs against server queried when forwarding
    //      as forwarder has that info and must do checks
    //
    //  catch non-recursive forwarder
    //      however, forward can forward response from remote DNS
    //      without RA or RD flags set, so before must screen out other
    //      valid responses (answer, AUTH, NXDOMAIN) and only catch
    //      when getting a delegation instead of ANSWER
    //
    //  DEVNOTE: should have packet categorization below, so don't repeat
    //      test here
    //

    if ( IS_FORWARDING(pQuery) )
    {
        pnodeQueried = NULL;
        STAT_INC( RecurseStats.ResponseFromForwarder );

        if ( pQuery->Head.RecursionDesired )
        {
            if ( pMsg->Head.RecursionAvailable )
            {
                pQuery->fQuestionCompleted = TRUE;
            }
            else if ( pMsg->Head.AnswerCount == 0   &&
                      ! pMsg->Head.Authoritative    &&
                      pMsg->Head.ResponseCode != DNS_RCODE_NXDOMAIN )
            {
                PVOID parg = ( PVOID ) &pMsg->RemoteAddr;

                DNS_LOG_EVENT(
                    DNS_EVENT_NON_RECURSIVE_FORWARDER,
                    1,
                    & parg,
                    EVENTARG_ALL_IP_ADDRESS,
                    0 );
            }
        }
    }
    //
    //  non-forwarding -- secure responses
    //
    //      - determine zone root of responding server
    //          can then verify validity of RRs returned
    //      - any valid authorititative response ends queries on THIS question
    //
    else
    {
        pnodeQueried = Remote_FindZoneRootOfRespondingNs(
                            pQuery,
                            pMsg );
        if ( !pnodeQueried )
        {
            if ( SrvCfg_fSecureResponses )
            {
                STAT_INC( RecurseStats.ResponseUnsecure );
                status = DNS_ERROR_UNSECURE_PACKET;
                goto Done;
            }
        }
    }

    //
    //  check for errors before we even bother
    //
    //  NAME_ERROR is special case
    //      - if SOA returned, set flag to allow negative caching
    //

    if ( pMsg->Head.ResponseCode != DNS_RCODE_NO_ERROR )
    {
        if ( pMsg->Head.ResponseCode != DNS_RCODE_NAME_ERROR )
        {
            STAT_INC( RecurseStats.ResponseRcode );
            status = DNS_ERROR_RCODE;
            goto Done;
        }

        STAT_INC( RecurseStats.ResponseNameError );
        fnameError = TRUE;
    }

    //
    //  answer? empty? delegation?
    //
    //  DEVNOTE: is BIND going to start sending non-auth empties with SOA?
    //
    //  DEVNOTE: nice to detect empties:  two issues
    //  DEVNOTE: NT4 non-auth empty forwards will cause problems
    //  DEVNOTE: out of zone SOA additional data could cause security rejection
    //      of additional, so we didn't do direct forward, then we wouldn't
    //      be able to write empty from cache, and if we did we wouldn't
    //      be setting authority flag or rewriting SOA
    //
    //  Note, if we can detect empty, just turning on fQuestionCompleted flag
    //  will cause correct behavior (no write, no recurse).  If sent on for
    //  current lookup.
    //

    else if ( pMsg->Head.AnswerCount )
    {
        pQuery->fQuestionCompleted = TRUE;
        STAT_INC( RecurseStats.ResponseAnswer );
    }
    else if ( !pMsg->Head.NameServerCount )
    {
        //
        //  completely empty non-auth response (probably from NT4 DNS)
        //      - if forwarding just forward to client
        //      - otherwise treat as bad packet (without logging) and
        //          let recursion eventually track down AUTH server and
        //          get proper AUTH response
        //
        //  021220: BIND4 can also return a completely empty response.
        //  We need to handle this as a valid packet unfortunately.
        //

        DNS_DEBUG( RECURSE, (
            "WARNING: non-authoritative empty response at %p\n",
            pMsg ));

        pQuery->fQuestionCompleted = TRUE;

        STAT_INC( RecurseStats.ResponseEmpty );

        status = DNS_INFO_NO_RECORDS;
        goto Done;
    }

    //
    //  write responses into database
    //
    //  loop through all resource records
    //      - skip question
    //      - write other RRs to database
    //

    INITIALIZE_COMPRESSION( pMsg );

    pchpacketEnd = DNSMSG_END( pMsg );
    pchnextName = pMsg->MessageBody;

    sectionIndex = QUESTION_SECTION_INDEX;
    countSectionRR = pMsg->Head.QuestionCount;
    DNS_LIST_STRUCT_INIT( listRR );

    //
    //  Resource record loop.
    //

    while( 1 )
    {
        BOOL        fcachingRootNs = FALSE;

        //
        //  new section?
        //      - commit any outstanding RR sets

        if ( countSectionRR == 0 )
        {
            if ( !IS_DNS_LIST_STRUCT_EMPTY(listRR) )
            {
                ASSERT( pnodePrevious );
                RR_CacheSetAtNode(
                    pnodePrevious,
                    listRR.pFirst,
                    listRR.pLast,
                    ttlForSet,
                    pQuery->dwQueryTime );
                DNS_LIST_STRUCT_INIT( listRR );
                ttlForSet = SrvCfg_dwMaxCacheTtl;
            }

            if ( sectionIndex == ADDITIONAL_SECTION_INDEX )
            {
                break;
            }

            //  new section info

            sectionIndex++;
            countSectionRR = RR_SECTION_COUNT( pMsg, sectionIndex );
            if ( countSectionRR == 0 )
            {
                continue;
            }
            rank = CacheRankForSection( sectionIndex, pMsg->Head.Authoritative );
        }

        //  clear prr -- makes it easy to determine when needs free

        countSectionRR--;
        prr = NULL;

        //
        //  get RR owner name
        //      - insure we stay within message
        //

        pchcurrentName = pchnextName;

        pnode = Lookup_CreateCacheNodeFromPacketName(
                    pMsg,
                    pchpacketEnd,
                    & pchnextName );
        if ( !pnode )
        {
            //  if question name is invalid name generating name error
            //  make sure name error gets returned to client

            if ( sectionIndex == QUESTION_SECTION_INDEX )
            {
                if ( fnameError )
                {
                    DNS_DEBUG( READ, (
                        "Name error on invalid name\n",
                        pMsg ));
                    status =  DNS_ERROR_RCODE_NAME_ERROR;
                    goto Done;
                }
            }
            goto PacketNameError;
        }
        pch = pchnextName;

        //
        //  Process OPT RR. 
        //
        
        type = FlipUnalignedWord( pch );
        if ( type == DNS_TYPE_OPT )
        {
            DNS_DEBUG( READ, (
                "Ignoring OPT record parsing packet at %p\n",
                pMsg ));
            pMsg->pCurrent = pchcurrentName;    // back up to start of RR
            Answer_ParseAndStripOpt( pMsg );
            continue;
        }

        //
        //  new node?
        //      - save offset to avoid unnecessary lookup of same name for next RR
        //      - ignore RR if
        //      1) in authoritative zone
        //          OR
        //      2) not in subtree of zone root of NS responding to query
        //          (the "cache-pollution" fix)
        //      then set zero timeout on ignore node
        //

        if ( pnode != pnodePrevious )
        {
            fignoreRecord = FALSE;

            //
            //  Are we allowed to accept cache records at this node?
            //

            if ( !isNodeCacheable( pnode ) )
            {
                DNS_DEBUG( LOOKUP, (
                    "RR maps to uncacheable cache node!\n" ));
                fignoreRecord = TRUE;
            }

            //
            //  secure responses
            //      - currently only secure responses
            //
            //  DEVNOTE: secure responses when queried delegation
            //      - need to either
            //      - save cache node corresponding to query (rather
            //          than just delegation
            //      - do absolute name hierarchial compare here
            //          (this is not really very hard)
            //

            else if ( SrvCfg_fSecureResponses && pnodeQueried )
            {
                if ( IS_CACHE_TREE_NODE( pnodeQueried ) )
                {
                    //
                    //  The NS node is in the cache so use fast subtree compare.
                    //

                    if ( !Dbase_IsNodeInSubtree( pnode, pnodeQueried ) )
                    {
                        DNS_DEBUG( ANY, (
                            "Secure response: ignoring RR at offset %x section %d in packet %p\n"
                            "    node queried =     %s (from cache)\n"
                            "    RR node =          %s\n"
                            "    remote NS =        %s\n",
                            offsetPrevious,
                            sectionIndex,
                            pMsg,
                            pnodeQueried->szLabel,
                            pnode->szLabel,
                            MSG_IP_STRING( pMsg ) ));
                        fignoreRecord = TRUE;
                    }
                }
                else
                {
                    //
                    //  The NS node is in an authoritative zone so use
                    //  subtree name compare.
                    //

                    if ( !Dbase_IsNodeInSubtreeByLabelCompare( pnode, pnodeQueried ) )
                    {
                        DNS_DEBUG( ANY, (
                            "Secure response: ignoring RR at offset %x section %d in packet %p\n"
                            "    node queried =     %s (from zone %s)\n"
                            "    RR node =          %s\n"
                            "    remote NS =        %s\n",
                            offsetPrevious,
                            sectionIndex,
                            pMsg,
                            pnodeQueried->szLabel,
                            NODE_ZONE( pnodeQueried )->pszZoneName,
                            pnode->szLabel,
                            MSG_IP_STRING( pMsg ) ));
                        fignoreRecord = TRUE;
                    }
                }
            }

            if ( fignoreRecord )
            {
                Timeout_SetTimeoutOnNode( pnode );
            }
        }

        //  may not be necessary as RR create now independent of node

        pMsg->pnodeCurrent = pnode;

        //
        //  question section
        //  if name error (NXDOMAIN) then create question node for
        //  name error caching
        //

        if ( sectionIndex == QUESTION_SECTION_INDEX )
        {
            pchnextName += sizeof( DNS_QUESTION );
            if ( pchnextName > pchpacketEnd )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  bad packet, not enough space remaining for"
                    "Question structure\n"
                    "    Terminating caching from packet\n" ));
                goto PacketError;
            }

            //  grab question type, (we special case SOA queries in name error caching)

            pMsg->wQuestionType = FlipUnalignedWord( pch );

            pnodeQuestion = pnode;
            pnodePrevious = pnode;

            //  DEVNOTE:  could do query question matching here
            //      i'm going to concentrate the fix on requiring data to be under
            //      the zone of the NS we queried

            //  reject packet if question node triggered "ignore" condition
            //      1) in authoriative zone => never should have queried so
            //      this is probably a bogus question or mismatched response
            //      2) outside zone we queried => never should have queried

            if ( fignoreRecord )
            {
                IF_DEBUG( ANY )
                {
                    DnsDebugLock();
                    DNS_PRINT((
                        "ERROR:  Ignoring question node (label %s) of response!\n",
                        pnode->szLabel ));
                    Dbg_DnsMessage(
                        "Ignored question node response:",
                        pMsg );
                    Dbg_DnsMessage(
                        "Ignored question node original query:",
                        pQuery );
                    DnsDebugUnlock();
                }
                goto InvalidDataError;
            }
            continue;
        }

        //
        //  extract RR info
        //      - type
        //      - datalength
        //      - get RR data ptr
        //  save ptr to next RR name
        //

        pchnextName = Wire_ParseWireRecord(
                        pch,
                        pchpacketEnd,
                        TRUE,           // class IN required
                        & parseRR
                        );
        if ( !pchnextName )
        {
            DNS_PRINT(( "ERROR:  bad RR in response packet\n" ));
            MSG_ASSERT( pMsg, FALSE );
            //status = DNS_RCODE_FORMAT_ERROR;
            goto PacketError;
        }
        type = parseRR.wType;

        //
        //  Are we caching an NS record for the root?
        //

        if ( type == DNS_TYPE_NS &&
            pnode->pParent == NULL )
        {
            fcachingRootNs = TRUE;
        }

        //
        //  answer section
        //

        if ( sectionIndex == ANSWER_SECTION_INDEX )
        {
            //  type checking -- must match
            //  DEVNOTE: could have strict CNAME checking, but doesn't buy much
            //      data integrity
            //
            //  DEVNOTE: type table should handle these checks
            //

            if ( type == pQuery->wTypeCurrent )
            {
                fanswered = TRUE;
            }
            else if (   type == DNS_TYPE_CNAME ||
                        type == DNS_TYPE_SIG )
            {
                fcnameAnswer = TRUE;
            }
            else if (   pQuery->wTypeCurrent == DNS_TYPE_ALL ||
                        pQuery->wTypeCurrent == DNS_TYPE_MAILB ||
                        pQuery->wTypeCurrent == DNS_TYPE_MAILA )
            {
                fanswered = TRUE;
            }
            else
            {
                DNS_DEBUG( ANY, (
                    "PACKERR:  Answer type %d does not match question type %d,\n"
                    "    nor is possible answer for this question\n"
                    "    Tossing response packet %p for orginal query at %p\n",
                    type,
                    pQuery->wTypeCurrent,
                    pMsg,
                    pQuery ));
                goto InvalidDataError;
            }
        }

        //
        //  authority section
        //      - NS or SOA only
        //      - screen out records for info outside subtree for NS queried
        //      (note server can legitimately pass on higher level server info
        //      it could even be authoritative for the root, but not the zone
        //      queried)
        //
        //  DEVNOTE-LOG: log warning bad type in authority
        //

        else if ( sectionIndex == AUTHORITY_SECTION_INDEX )
        {
            if ( !IS_AUTHORITY_SECTION_TYPE(type) )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  record type %d in authority section of response msg %p\n",
                    type,
                    pMsg ));
                fignoreRecord = TRUE;
            }

            //  if have valid authority record, should never be recursing up to
            //  (asking query of NS at) this NS's zone root node again
            //  valid response is either
            //      - SOA to cache name error at authoritative response
            //      - NS accompanying answers
            //      - NS referral to lower level zone (and node)
            //
            //  unfortunately, people out in Internet land apparently have
            //  sideways delegations where NS refers to another
            //  example:
            //      in com zone
            //      uclick.com. NS  ns.uclick.com.
            //      uclick.com. NS  ns1.isp.com.
            //      but on isp's box, some sort of stub to real NS
            //      uclick.com. NS  ns.uclick.com.
            //
            //  so the referral is sideways, and you MUST keep checking unless also an
            //  authoritative response
            //  so we limit setting valid response to when we actually know we have
            //  an answer (authoritative or answer) OR when we cleared have delegated
            //  to subzone
            //
            //  DEVNOTE: intelligent limit on tree walk
            //      we still aren't catching the case where we are delegating BACK UP
            //      the tree to a node we previously touched
            //      ideally we'd have a delegation wizard to check when question not
            //      answered
            //

            else
            {
                if ( pnodeQueried && !fignoreRecord )
                {
                    if ( pQuery->fQuestionCompleted ||
                        ( Dbase_IsNodeInSubtree( pnode, pnodeQueried ) &&
                            pnode != pnodeQueried ) )
                    {
                        DNS_DEBUG( RECURSE, (
                            "Valid authority record read from reponse %p\n"
                            "    setting response node to %p (label %s)\n",
                            pMsg,
                            pnodeQueried,
                            pnodeQueried->szLabel ));

                        Remote_SetValidResponse(
                            pQuery,
                            pnodeQueried );
                    }
                }

                //
                //  Empty auth response: this in an empty auth response if:
                //      - rcode is NO_ERROR, and
                //      - there are zero answer RRs, and
                //      - there is at least one SOA in the auth section
                //

                if ( type == DNS_TYPE_SOA &&
                     pMsg->Head.ResponseCode == DNS_RCODE_NO_ERROR &&
                     !pMsg->Head.AnswerCount )
                {
                    ++femptyAuthResponse;
                }
            }
        }

        //
        //  additional section
        //      - A, AAAA, SIG, KEY only
        //      - screen out records for info outside subtree for NS queried
        //
        //  DEVNOTE-LOG: log warning bad type in additional
        //
        //  DEVNOTE: additional screening problematic
        //      unlike authority it is reasonable to have random stuff
        //

        else
        {
            ASSERT( sectionIndex == ADDITIONAL_SECTION_INDEX );
            if ( ! IS_ADDITIONAL_SECTION_TYPE(type) )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  record type %d in additional section of response msg %p\n",
                    type,
                    pMsg ));
                fignoreRecord = TRUE;
            }

            //  authoritative empty response?
            //  if killing A record for primary server, then
            //      and send packet, just stripped of offending record
            //
            //  for delegations and answered queries there is no problem with
            //  just caching the "legal" info in the packet and continuing, only
            //  the auth-empty response causes problems, because we don't have
            //  a way to properly cache the "NXRRSET"

            if ( fignoreRecord &&
                    pMsg->Head.AnswerCount == 0 &&
                    pMsg->Head.Authoritative &&
                    ! fnoforwardResponse )
            {
                DNS_DEBUG( READ, (
                    "Killing Additional section ignore record in authoritative empty response\n"
                    "    Generally this is primary server A record\n"
                    ));

                pMsg->MessageLength = DNSMSG_OFFSET( pMsg, pchcurrentName );

                pMsg->Head.AdditionalCount -= (countSectionRR + 1);

                countSectionRR = 0;     // stop further processing
                forwardTruncatedResponse = TRUE;
            }
        }

        //
        //  new RR set?
        //

        if ( ! IS_DNS_LIST_STRUCT_EMPTY(listRR)
                &&
            (type != typePrevious || pnode != pnodePrevious) )
        {
            RR_CacheSetAtNode(
                pnodePrevious,
                listRR.pFirst,
                listRR.pLast,
                ttlForSet,
                pQuery->dwQueryTime );
            DNS_LIST_STRUCT_INIT( listRR );
            ttlForSet = SrvCfg_dwMaxCacheTtl;
        }

        //  reset previous to this record

        typePrevious = type;
        pnodePrevious = pnode;

        //
        //  ignoring this record?
        //

        if ( fignoreRecord )
        {
            fnoforwardResponse = TRUE;
            IF_DEBUG( READ )
            {
                DnsDbg_Lock();
                DnsDbg_PacketRecord(
                    "WARNING:  Ignored packet record RR ",
                    (PDNS_WIRE_RECORD) parseRR.pchWireRR,
                    DNS_HEADER_PTR( pMsg ),
                    DNSMSG_END( pMsg ) );

                if ( pnodeQueried )
                {
                    Dbg_NodeName(
                        "Queried NS at node ",
                        pnodeQueried,
                        "\n" );
                }
                else
                {
                    DnsPrintf( "    No NS queried node\n" );
                }
                Dbg_NodeName(
                    "Node for record being ignored ",
                    pnode,
                    "\n" );
                DnsDbg_Unlock();
            }
            continue;
        }
        if ( type == DNS_TYPE_WINS || type == DNS_TYPE_WINSR )
        {
            DNS_DEBUG( READ, (
                "Ignoring WINS\\WINSR record parsing packet at %p\n",
                pMsg ));
            continue;
        }

        //
        //  create database record
        //

        prr = Wire_CreateRecordFromWire(
                    pMsg,
                    & parseRR,
                    parseRR.pchData,
                    MEMTAG_RECORD_CACHE );
        if ( !prr )
        {
            //
            //  DEVNOTE: should have some way to distiguish bad record, from
            //              unknown type, etc.
            //
            //  DEVNOTE: should fail on legitimate FORMERR (ex. bad name)
            //
            //  DEVNOTE-LOG: log record creation failure
            //

            DNS_PRINT((
                "ERROR:  failed record create in response!!!\n" ));

            MSG_ASSERT( pMsg, FALSE );
            goto PacketError;
        }

        //
        //  cache record
        //      TTL -- saved as absolute timeout (host byte order)
        //
        //  node and type matching determine if this is FIRST RR in set
        //  or part of continuing RR set
        //

        SET_RR_RANK( prr, rank );

        INLINE_DWORD_FLIP( parseRR.dwTtl, parseRR.dwTtl );

        if ( parseRR.dwTtl < ttlForSet )
        {
            ttlForSet = parseRR.dwTtl;
        }
        if ( parseRR.dwTtl < minTtl )
        {
            minTtl = parseRR.dwTtl;
        }
        DNS_LIST_STRUCT_ADD( listRR, prr );

        //
        //  cache name error
        //  only records in packet should be
        //      - question (already skipped)
        //      - and SOA in authority section
        //      - and possibly A record for SOA primary in additional section
        //
        //  save node to pnodeCurrent, to allow inclusion of SOA response
        //

        if ( fnameError )
        {
            if ( type == DNS_TYPE_SOA &&
                fnameError != NAME_ERROR_ALREADY_CACHED )
            {
                DNS_DEBUG( READ, (
                    "Caching SOA name error for response at %p\n",
                    pMsg ));
                RR_CacheNameError(
                    pnodeQuestion,
                    pMsg->wQuestionType,
                    pMsg->dwQueryTime,
                    pMsg->Head.Authoritative,
                    pnode,
                    ntohl( prr->Data.SOA.dwMinimumTtl ) );

                fnameError = NAME_ERROR_ALREADY_CACHED;
                continue;
            }
            else
            {
                /*
                ASSERT( sectionIndex == ADDITIONAL_SECTION_INDEX
                    || (sectionIndex == AUTHORITY_SECTION_INDEX && type == DNS_TYPE_NS) );
                */

                //
                //  DEVNOTE: catch bogus NAME_ERROR packet?  enforce above ASSERT
                //      and if fails drop to bad packet
                //

                RR_Free( prr );
                
                //
                //  Make sure that any nodes created are entered into the
                //  timeout system. If the node is has no RRs, make sure the
                //  node's NOEXIST flag is clear.
                //
                
                if ( pnode )
                {
                    if ( EMPTY_RR_LIST( pnode ) )
                    {
                        CLEAR_NOEXIST_NODE( pnode );
                    }
                    if ( !IS_TIMEOUT_NODE( pnode ) )
                    {
                        Timeout_SetTimeoutOnNode( pnode );
                    }
                    RR_ListVerify( pnode );
                }
                if ( pnodePrevious )
                {
                    if ( EMPTY_RR_LIST( pnodePrevious ) )
                    {
                        CLEAR_NOEXIST_NODE( pnodePrevious );
                    }
                    if ( !IS_TIMEOUT_NODE( pnodePrevious ) )
                    {
                        Timeout_SetTimeoutOnNode( pnodePrevious );
                    }
                    RR_ListVerify( pnodePrevious );
                }
                if ( pnodeQuestion )
                {
                    if ( EMPTY_RR_LIST( pnodeQuestion ) )
                    {
                        CLEAR_NOEXIST_NODE( pnodeQuestion );
                    }
                    if ( !IS_TIMEOUT_NODE( pnodeQuestion ) )
                    {
                        Timeout_SetTimeoutOnNode( pnodeQuestion );
                    }
                    RR_ListVerify( pnodeQuestion );
                }
                status = DNS_ERROR_RCODE_NAME_ERROR;
                goto Done;
            }
        }

        //
        //  If this is the first empty auth SOA, cache the empty response.
        //  Continue processing RRs to cache rest of response.
        //

        if ( femptyAuthResponse == 1 && type == DNS_TYPE_SOA )
        {
            RR_CacheEmptyAuth(
                    pnodeQuestion,
                    pMsg->wQuestionType,
                    pMsg->dwQueryTime,
                    pMsg->Head.Authoritative,
                    pnode,
                    ntohl( prr->Data.SOA.dwMinimumTtl ) );
        }

        //
        //  Check if we are caching an Internet root nameserver. Assume an
        //  NS is an Internet root server if has three name components and 
        //  ends with root-servers.net.
        //

        if ( fcachingRootNs &&
            !g_fUsingInternetRootServers &&
            prr->Data.NS.nameTarget.LabelCount == 3 &&
            prr->Data.NS.nameTarget.Length > g_cchInternetRootNsDomain + 1 &&
            RtlEqualMemory(
                prr->Data.NS.nameTarget.RawName +
                    * ( PUCHAR ) prr->Data.NS.nameTarget.RawName + 1,
                g_InternetRootNsDomain,
                g_cchInternetRootNsDomain ) )
        {
            g_fUsingInternetRootServers = TRUE;
            IF_DEBUG( READ )
            {
                Dbg_DnsMessage(
                    "Found INET root NS while caching this msg",
                    pMsg );
            }
        }
    }   //  loop through RRs

    //
    //  All response RRs should now be in database and we've set various
    //  flags to tell us what kind of response we are dealing with.
    //  Decide what to return to caller and perform final processing.
    //
    
    //
    //  Type all query caching: set the node type ALL TTL to be the minimum
    //  of all TTLs found in the packet. Note: if there are additional 
    //  records present in the packet with low TTLs this may reduce the
    //  type ALL TTL but that is acceptable.
    //
    
    if ( pQuery->wQuestionType == DNS_TYPE_ALL &&
         minTtl != 0xFFFFFFFF &&
         pMsg->Head.AnswerCount &&
         pMsg->Head.Authoritative &&
         pQuery->pNodeQuestion )
    {
        pQuery->pNodeQuestion->dwTypeAllTtl = pQuery->dwQueryTime + minTtl;
    }

    //
    //  name error
    //  if no-SOA, then didn't cache above
    //  cache name error here with brief timeout to kill off retries
    //
    //  set queries current node to point at name error node;  this allows
    //  SendNameError() function to locate and write cached SOA, with
    //  correct TTL for this node
    //

    if ( fnameError )
    {
        if ( fnameError != NAME_ERROR_ALREADY_CACHED )
        {
            DNS_DEBUG( READ, (
                "Caching non-SOA name error for response at %p\n",
                pMsg ));
            RR_CacheNameError(
                pnodeQuestion,
                pMsg->wQuestionType,
                pMsg->dwQueryTime,
                pMsg->Head.Authoritative,
                NULL,
                0 );
        }
        pQuery->pnodeCurrent = pnodeQuestion;
        status = DNS_ERROR_RCODE_NAME_ERROR;
        goto Done;
    }

    //
    //  Empty auth response.
    //

    if ( femptyAuthResponse  )
    {
        pQuery->fQuestionCompleted = TRUE;

        STAT_INC( RecurseStats.ResponseEmpty );

        status = DNS_INFO_NO_RECORDS;
        goto Done;
    }
    else if ( !pMsg->Head.AnswerCount && pMsg->Head.NameServerCount )
    {
        STAT_INC( RecurseStats.ResponseDelegation );
    }

    //
    //  data outside domain of responding NS makes response unforwardable
    //      - we'll have to write our response from cache and possibly
    //      follow up with another query to replace lost data
    //
    //      - for case of authoritative-empty response, need to go ahead
    //      and send packet, just stripped of offending record
    //

    if ( fnoforwardResponse )
    {
        if ( !forwardTruncatedResponse )
        {
            STAT_INC( RecurseStats.ResponseNonZoneData );
            status = DNS_ERROR_NAME_NOT_IN_ZONE;
            goto Done;
        }

        DNS_DEBUG( READ, (
            "Returning truncated auth-empty response %p\n", pMsg ));
        status = ERROR_SUCCESS;
        goto Done;
    }

    //
    //  check if need to chase CNAME
    //      - if no "answers" to question type
    //      - then only CNAMEs (bogus answers cause invalid packet error)
    //  then must write records from cache and continue query at CNAME
    //

    if ( pMsg->Head.AnswerCount && !fanswered )
    {
        status = DNS_ERROR_NODE_IS_CNAME;
        goto Done;
    }

    status = ERROR_SUCCESS;
    goto Done;

    //
    //  Failure conditions.
    //

    InvalidDataError:
    PacketNameError:

    Wire_PacketNameError( pMsg, 0, (WORD)(pch - (PCHAR)&pMsg->Head) );
    status = DNS_ERROR_INVALID_NAME;
    goto ErrorCleanup;

    //  InvalidTypeError:
    PacketError:

    Wire_PacketError( pMsg, 0 );
    status = DNS_ERROR_BAD_PACKET;
    goto ErrorCleanup;

    ErrorCleanup:

    //  free record
    //  put timeouts on any nodes created

    //
    //  DEVNOTE: leak here of stuff in listRR, if bad record
    //      shouldn't happen on InvalidZone failure, as it takes a new
    //      node to trigger InvalidZone and this would also commit list
    //

    RR_Free( prr );
    if ( pnode && !IS_TIMEOUT_NODE( pnode ) )
    {
        Timeout_SetTimeoutOnNode( pnode );
    }
    if ( pnodePrevious && !IS_TIMEOUT_NODE( pnodePrevious ) )
    {
        Timeout_SetTimeoutOnNode( pnodePrevious );
    }

    STAT_INC( RecurseStats.ResponseBadPacket );

    Done:
    
    if ( pfCnameAnswer )
    {
        *pfCnameAnswer = fcnameAnswer;
    }
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rrfile.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    rrfile.c

Abstract:

    Domain Name System (DNS) Server

    Routines to write resource records to database file.

Author:

    Jim Gilroy (jamesg)     August 25, 1995

Revision History:

--*/


#include "dnssrv.h"


#define DNSSEC_ERROR_NOSTRING       (-1)
#define DNSSEC_BAD_TIME             (-1)



//
//  Read records from file routines
//

DNS_STATUS
AFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process A record.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD  prr;
    DNS_ADDR    dnsAddr;

    //
    //  A <IP address string>
    //

    if ( Argc != 1 )
    {
        return ( Argc > 1 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }
    prr = RR_Allocate( (WORD)SIZEOF_IP_ADDRESS );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    if ( !File_ParseIpAddress(
                &dnsAddr,
                Argv,
                pParseInfo ) )
    {
        return DNSSRV_PARSING_ERROR;
    }
    
    prr->Data.A.ipAddress = DnsAddr_GetIp4( &dnsAddr );

    return ERROR_SUCCESS;
}



DNS_STATUS
PtrFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process PTR compatible record.
    Includes: PTR, NS, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr = NULL;
    COUNT_NAME      countName;
    DNS_STATUS      status;

    PZONE_INFO  pzone;
    PDB_NODE    pnodeOwner;

    //
    //  PTR <DNS name>
    //

    if ( Argc != 1 )
    {
        return ( Argc > 1 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    status = File_ReadCountNameFromToken(
                & countName,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return DNSSRV_PARSING_ERROR;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) Name_LengthDbaseNameFromCountName(&countName) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //
    //  write target name
    //

    Name_CopyCountNameToDbaseName(
        & prr->Data.PTR.nameTarget,
        & countName );

    return ERROR_SUCCESS;
}



DNS_STATUS
SoaFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process SOA RR.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PZONE_INFO      pzone = pParseInfo->pZone;
    INT             i;
    PDWORD          pdword;     // ptr to next numeric SOA field
    DNS_STATUS      status;
    COUNT_NAME      countNamePrimary;
    COUNT_NAME      countNameAdmin;
    PDB_RECORD      prr;
    PDB_NAME        pname;

    //
    //  check SOA validity
    //      - first record in zone file
    //      - attached to zone root

    if ( pParseInfo->fParsedSoa  ||
            ( pzone->pZoneRoot != pParseInfo->pnodeOwner &&
            pzone->pLoadZoneRoot != pParseInfo->pnodeOwner ) )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_SOA_RECORD,
            pParseInfo,
            NULL );
        return DNSSRV_PARSING_ERROR;
    }
    if ( Argc != 7 )
    {
        return ( Argc > 7 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  create primary name server
    //

    status = File_ReadCountNameFromToken(
                & countNamePrimary,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return DNSSRV_PARSING_ERROR;
    }
    NEXT_TOKEN( Argc, Argv );

    //  create zone admin name

    status = File_ReadCountNameFromToken(
                & countNameAdmin,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return DNSSRV_PARSING_ERROR;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) ( SIZEOF_SOA_FIXED_DATA +
                                Name_LengthDbaseNameFromCountName(&countNamePrimary) +
                                Name_LengthDbaseNameFromCountName(&countNameAdmin) ) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //
    //  convert numeric fields
    //      - store in netorder for fast access to wire
    //

    pdword = & prr->Data.SOA.dwSerialNo;

    while( Argc )
    {
        if ( !File_ParseDwordToken(
                    pdword,
                    Argv,
                    pParseInfo ) )
        {
            return DNSSRV_PARSING_ERROR;
        }
        *pdword = htonl( *pdword );
        pdword++;
        NEXT_TOKEN( Argc, Argv );
    }

    //
    //  write names
    //      - primary server name
    //      - zone admin name
    //

    pname = &prr->Data.SOA.namePrimaryServer;

    Name_CopyCountNameToDbaseName(
        pname,
        & countNamePrimary );

    pname = (PDB_NAME) Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        & countNameAdmin );

    //
    //  update parse info to indicate successful SOA load
    //

    pParseInfo->fParsedSoa = TRUE;
    pParseInfo->dwTtlDirective =
        pParseInfo->dwDefaultTtl =
        prr->Data.SOA.dwMinimumTtl;

    return ERROR_SUCCESS;
}



DNS_STATUS
MxFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process MX compatible RR.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    DWORD           dwtemp;
    COUNT_NAME      countName;
    DNS_STATUS      status;

    //
    //  MX  <preference> <exchange DNS name>
    //

    if ( Argc != 2 )
    {
        return ( Argc > 2 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  MX preference
    //  RT preference
    //  AFSDB subtype
    //

    if ( !File_ParseDwordToken(
                & dwtemp,
                Argv,
                pParseInfo ) )
    {
        return DNSSRV_PARSING_ERROR;
    }
    if ( dwtemp > 0xffff )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_PREFERENCE,
            pParseInfo,
            Argv );
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
        pParseInfo->fErrorEventLogged = TRUE;
        return DNSSRV_PARSING_ERROR;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  MX mail exchange
    //  RT intermediate exchange
    //  AFSDB hostname
    //      - do this first to determine record length
    //

    status = File_ReadCountNameFromToken(
                & countName,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return DNSSRV_PARSING_ERROR;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_MX_FIXED_DATA +
                            Name_LengthDbaseNameFromCountName(&countName)) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //  set preference

    prr->Data.MX.wPreference = htons( (WORD)dwtemp );

    //
    //  MX mail exchange
    //  RT intermediate exchange
    //  AFSDB hostname
    //

    Name_CopyCountNameToDbaseName(
        & prr->Data.MX.nameExchange,
        & countName );

    return ERROR_SUCCESS;
}



DNS_STATUS
TxtFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process Text (TXT) RR.

Arguments:

    pRR - NULL ptr to database record, since this record type has variable
        length, this routine allocates its own record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    DWORD       cch;
    DWORD       index;
    DWORD       dataLength = 0;
    DWORD       minTokenCount = 1;
    DWORD       maxTokenCount;

    DNS_DEBUG( PARSE2, (
        "TxtFileRead() type=%d, argc=%d\n",
        pParseInfo->wType,
        Argc ));

    //
    //  verify correct number of strings for type
    //

    if ( !Dns_IsStringCountValidForTextType(
                pParseInfo->wType,
                (WORD)Argc ) )
    {
        return DNSSRV_ERROR_INVALID_TOKEN;
    }

    //  sum text string length
    //
    //  note:  we won't bother to catch space errors here, as quote expansion
    //      may reduce length;
    //      just don't worry about wasting space in allocation

    for ( index=0; index<Argc; index++ )
    {
        cch = Argv[index].cchLength;
        dataLength += cch;
        dataLength++;
    }

    //
    //  allocate
    //

    prr = RR_Allocate( (WORD)dataLength );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //  fill in text data
    //      need to special case zero length strings as
    //      cch=zero will cause pchToken to be taken as SZ string

    pch = prr->Data.TXT.chData;

    while( Argc )
    {
        cch = Argv->cchLength;
        if ( cch == 0 )
        {
            *pch++ = 0;
        }
        else
        {
            pch = File_CopyFileTextData(
                    pch,
                    dataLength,
                    Argv->pchToken,
                    cch,
                    TRUE );
            if ( !pch )
            {
                File_LogFileParsingError(
                    DNS_EVENT_TEXT_STRING_TOO_LONG,
                    pParseInfo,
                    Argv );
                return DNSSRV_PARSING_ERROR;
            }
        }
        NEXT_TOKEN( Argc, Argv );
    }

    //  set text length

    dataLength = (DWORD) (pch - prr->Data.TXT.chData);
    if ( dataLength > MAXWORD )
    {
        File_LogFileParsingError(
            DNS_EVENT_TEXT_STRING_TOO_LONG,
            pParseInfo,
            Argv );
        return DNSSRV_PARSING_ERROR;
    }
    prr->wDataLength = (WORD) dataLength;

    return ERROR_SUCCESS;
}



DNS_STATUS
MinfoFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process MINFO or RP record.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status;
    COUNT_NAME      countNameMailbox;
    COUNT_NAME      countNameErrors;
    PDB_RECORD      prr;
    PDB_NAME        pname;

    //
    //  MINFO <responsible mailbox> <errors to mailbox>
    //

    if ( Argc != 2 )
    {
        return ( Argc > 2 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    //  create mailbox

    status = File_ReadCountNameFromToken(
                & countNameMailbox,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return DNSSRV_PARSING_ERROR;
    }
    NEXT_TOKEN( Argc, Argv );

    //  create errors to mailbox

    status = File_ReadCountNameFromToken(
                & countNameErrors,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return DNSSRV_PARSING_ERROR;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) ( Name_LengthDbaseNameFromCountName(&countNameMailbox) +
                                Name_LengthDbaseNameFromCountName(&countNameErrors) ) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //
    //  write names
    //

    pname = &prr->Data.MINFO.nameMailbox;

    Name_CopyCountNameToDbaseName(
        pname,
        & countNameMailbox );

    pname = (PDB_NAME) Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        & countNameErrors );

    return ERROR_SUCCESS;
}



DNS_STATUS
WksBuildRecord(
    OUT     PDB_RECORD *    ppRR,
    IN      PDNS_ADDR       ipAddress,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Build WKS record.
    This does WKS building common to file and RPC loading.

Arguments:

    ppRR -- existing RR being built

    ipAddress -- IP of machine WKS is for

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDB_RECORD          prr;
    DWORD               i;
    DWORD               portDword;
    WORD                port;
    UCHAR               bit;
    WORD                maxPort = 0;
    WORD                wbitmaskLength;
    PBYTE               bitmaskBytes;
    WORD                portArray[ MAX_TOKENS ];
    CHAR                szNameBuffer[ DNS_MAX_NAME_LENGTH ];
    PCHAR               pszNameBuffer = szNameBuffer;
    struct servent *    pServent;
    struct protoent *   pProtoent;

    ASSERT( Argc <= MAX_TOKENS );

    //
    //  find protocol
    //

    if ( !File_MakeTokenString(
                pszNameBuffer,
                Argv,
                pParseInfo ) )
    {
        return DNSSRV_ERROR_INVALID_TOKEN;
    }
    pProtoent = getprotobyname( pszNameBuffer );

    if ( !pProtoent || pProtoent->p_proto >= MAXUCHAR )
    {
        File_LogFileParsingError(
            DNS_EVENT_UNKNOWN_PROTOCOL,
            pParseInfo,
            Argv );
        return DNSSRV_ERROR_INVALID_TOKEN;
    }

    //
    //  get port for each service
    //      - if digit, then use port number
    //      - if not digit, then service name
    //      - save max port for determining RR length
    //

    for ( i=1; i<Argc; i++ )
    {
        if ( File_ParseDwordToken(
                    & portDword,
                    & Argv[i],
                    NULL ) )
        {
            if ( portDword > MAXWORD )
            {
                return DNSSRV_ERROR_INVALID_TOKEN;
            }
            port = (WORD) portDword;
        }
        else
        {
            if ( !File_MakeTokenString(
                        pszNameBuffer,
                        & Argv[i],
                        pParseInfo ) )
            {
                return DNSSRV_ERROR_INVALID_TOKEN;
            }
            pServent = getservbyname(
                            pszNameBuffer,
                            pProtoent->p_name );
            if ( !pServent )
            {
                File_LogFileParsingError(
                    DNS_EVENT_UNKNOWN_SERVICE,
                    pParseInfo,
                    & Argv[i] );
                return DNSSRV_ERROR_INVALID_TOKEN;
            }
            port = ntohs( pServent->s_port );
        }

        portArray[ i ] = port;
        if ( port > maxPort )
        {
            maxPort = port;
        }
    }

    //
    //  allocate required length
    //      - fixed length, plus bitmask covering max port
    //

    wbitmaskLength = maxPort/8 + 1;

    prr = RR_Allocate(
                (WORD)(SIZEOF_WKS_FIXED_DATA + wbitmaskLength) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //
    //  copy fixed fields -- IP and protocol
    //

    prr->Data.WKS.ipAddress = DnsAddr_GetIp4( ipAddress );
    prr->Data.WKS.chProtocol = (UCHAR) pProtoent->p_proto;

    //
    //  build bitmask from port array
    //      - clear port array first
    //
    //  note that bitmask is just flat run of bits
    //  hence lowest port in byte, corresponds to highest bit
    //  highest port in byte, corresponds to lowest bit and
    //  requires no shift
    //

    bitmaskBytes = prr->Data.WKS.bBitMask;

    RtlZeroMemory(
        bitmaskBytes,
        wbitmaskLength );

    for ( i=1; i<Argc; i++ )
    {
        port = portArray[ i ];
        bit  = port & 0x7;      // mod 8
        port = port >> 3;       // divide by 8
        bitmaskBytes[ port ] |= 1 << (7-bit);
    }

    //  return ptr to new WKS record

    *ppRR = prr;

    return ERROR_SUCCESS;
}



DNS_STATUS
WksFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process WKS record.

Arguments:

    pRR - NULL ptr to database record, since this record type has variable
        length, this routine allocates its own record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;
    DNS_ADDR    dnsAddr;

    //
    //  WKS <IP address> <protocol> [<services> ...]
    //
    //  - allow no services, some customer has this
    //

    if ( Argc < 2 )
    {
        return  DNSSRV_ERROR_MISSING_TOKEN;
    }

    //  parse IP address string

    if ( !File_ParseIpAddress(
                &dnsAddr,
                Argv,
                pParseInfo ) ||
         !DnsAddr_IsIp4( &dnsAddr ) )
    {
        return DNSSRV_PARSING_ERROR;
    }
    
    //  parse protocol and services and build WKS record

    status = WksBuildRecord(
                &pRR,
                &dnsAddr,
                --Argc,
                ++Argv,
                pParseInfo );

    //  return record ptr through parse info

    pParseInfo->pRR = pRR;
    return( status );
}



DNS_STATUS
AaaaFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process AAAA record.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD  prr;

    //
    //  AAAA <IPv6 address string>
    //

    if ( Argc != 1 )
    {
        return ( Argc > 1 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    prr = RR_Allocate( (WORD)sizeof(IP6_ADDRESS) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    if ( !Dns_Ip6StringToAddressEx_A(
                &prr->Data.AAAA.Ip6Addr,
                Argv->pchToken,
                Argv->cchLength ) )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_IPV6_ADDRESS,
            pParseInfo,
            Argv );
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
        pParseInfo->fErrorEventLogged = TRUE;
        return DNSSRV_PARSING_ERROR;
    }
    return ERROR_SUCCESS;
}



DNS_STATUS
SrvFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process SRV compatible RR.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD           dwtemp;
    PWORD           pword;
    PDB_RECORD      prr = NULL;
    COUNT_NAME      countName;
    DNS_STATUS      status;

    //
    //  SRV  <priority> <weight> <port> <target hostname>
    //

    if ( Argc != 4 )
    {
        return ( Argc > 4 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  SRV target host
    //      - do this first to determine record length
    //

    status = File_ReadCountNameFromToken(
                & countName,
                pParseInfo,
                &Argv[3] );
    if ( status != ERROR_SUCCESS )
    {
        return DNSSRV_PARSING_ERROR;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_SRV_FIXED_DATA +
                            Name_LengthDbaseNameFromCountName(&countName)) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //
    //  read SRV integers -- priority, weight, port
    //

    pword = &prr->Data.SRV.wPriority;

    while( Argc > 1 )
    {
        if ( !File_ParseDwordToken(
                    & dwtemp,
                    Argv,
                    pParseInfo ) )
        {
            goto ParsingError;
        }
        if ( dwtemp > MAXWORD )
        {
            goto ParsingError;
        }
        *pword = htons( (WORD)dwtemp );
        pword++;
        NEXT_TOKEN( Argc, Argv );
    }

    //
    //  copy SRV target host
    //

    Name_CopyCountNameToDbaseName(
        & prr->Data.SRV.nameTarget,
        & countName );

    return ERROR_SUCCESS;

ParsingError:

    pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
    return DNSSRV_PARSING_ERROR;
}



DNS_STATUS
AtmaFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process ATMA record.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD  prr;
    DWORD       length;
    BYTE        addrBuffer[ DNS_ATMA_MAX_RECORD_LENGTH ];
    DNS_STATUS  status;

    //
    //  ATMA <ATM address in either AESA or E164 format>
    //

    if ( Argc != 1 )
    {
        return ( Argc > 1 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    length = DNS_ATMA_MAX_RECORD_LENGTH;

    status = Dns_AtmaStringToAddress(
                addrBuffer,
                & length,
                Argv->pchToken,
                Argv->cchLength
                );
    if ( status != ERROR_SUCCESS )
    {
        return DNSSRV_PARSING_ERROR;
    }

    prr = RR_Allocate( (WORD)length );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //
    //  copy ATMA data to record
    //

    RtlCopyMemory(
        & prr->Data.ATMA,
        addrBuffer,
        length );

    return ERROR_SUCCESS;
}



DWORD
ParseWinsFixedFields(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Parse fixed fields for WINS or WINS-R records.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    Argc remaining.
    (-1) on parsing error.

--*/
{
    DWORD   flag;
    TOKEN   token;

    //
    //  fixed fields [LOCAL] [SCOPE] [L<lookup>] [C<cache>]
    //      - default for lookup timeout is initialized by caller
    //

    pRR->Data.WINS.dwMappingFlag = 0;
    pRR->Data.WINS.dwCacheTimeout = WINS_DEFAULT_TTL;

    //  check for WINS flag

    while ( Argc )
    {
        flag = Dns_WinsRecordFlagForString(
                    Argv->pchToken,
                    Argv->cchLength );

        if ( flag == DNS_WINS_FLAG_ERROR )
        {
            break;
        }
        NEXT_TOKEN( Argc, Argv );
        pRR->Data.WINS.dwMappingFlag |= flag;
    }

    //  lookup timeout

    if ( Argc && Argv->pchToken[0] == 'L' )
    {
        MAKE_TOKEN( &token, Argv->pchToken+1, Argv->cchLength-1 );

        if ( !File_ParseDwordToken(
                    & pRR->Data.WINS.dwLookupTimeout,
                    & token,
                    pParseInfo ) )
        {
            return( (DWORD)-1 );
        }
        NEXT_TOKEN( Argc, Argv );
    }

    //  cache timeout

    if ( Argc && Argv->pchToken[0] == 'C' )
    {
        MAKE_TOKEN( &token, Argv->pchToken+1, Argv->cchLength-1 );

        if ( !File_ParseDwordToken(
                    & pRR->Data.WINS.dwCacheTimeout,
                    & token,
                    pParseInfo ) )
        {
            return( (DWORD)-1 );
        }
        NEXT_TOKEN( Argc, Argv );
    }

    return Argc;
}



DNS_STATUS
WinsFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process WINS record.

Arguments:

    pRR - NULL ptr to database record, since this record type has variable
        length, this routine allocates its own record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    COUNT_NAME      countName;
    DB_RECORD       record;
    DWORD           argcFixed;
    DWORD           i = 0;

    //
    //  WINS [LOCAL] [L<lookup>] [C<cache>] <WINS IP> [<WINS IP>...]
    //

    //
    //  parse fixed fields into temp stack record
    //      - set default lookup timeout which is different for WINS \ WINSR
    //      - then reset Argv ptrs to account fixed fields parsed

    argcFixed = Argc;
    record.Data.WINS.dwLookupTimeout =  WINS_DEFAULT_LOOKUP_TIMEOUT;

    Argc = ParseWinsFixedFields(
                & record,
                Argc,
                Argv,
                pParseInfo );
    if ( Argc == 0 || Argc == (DWORD)(-1) )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_WINS_RECORD,
            pParseInfo,
            NULL );
        return DNSSRV_ERROR_MISSING_TOKEN;
    }
    if ( argcFixed -= Argc )
    {
        Argv += argcFixed;
    }

    //  allocate

    prr = RR_Allocate( (WORD)(SIZEOF_WINS_FIXED_DATA + (Argc * sizeof(DWORD))) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;
    prr->wType = DNS_TYPE_WINS;

    //  copy fixed fields

    RtlCopyMemory(
        & prr->Data,
        & record.Data,
        SIZEOF_WINS_FIXED_DATA );

    //  read in WINS IP addresses

    prr->Data.WINS.cWinsServerCount = Argc;

    for( i=0; i<Argc; i++ )
    {
        DNS_ADDR    dnsAddr;
        
        if ( !File_ParseIpAddress(
                    &dnsAddr,
                    Argv,
                    pParseInfo ) ||
             !DnsAddr_IsIp4( &dnsAddr ) )
        {
            return DNSSRV_PARSING_ERROR;
        }
        prr->Data.WINS.aipWinsServers[ i ] = DnsAddr_GetIp4( &dnsAddr );
        Argv++;
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
NbstatFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process WINS-R (nbstat) record.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    DB_RECORD       record;
    DWORD           argcFixed;
    COUNT_NAME      countName;
    DNS_STATUS      status;

    //
    //  WINSR [LOCAL] [SCOPE] [L<lookup>] [C<cache>] <landing domain>
    //

    //
    //  parse fixed fields into temp stack record
    //      - set default lookup timeout which is different for WINS \ WINSR
    //      - then reset Argv ptrs to account fixed fields parsed

    argcFixed = Argc;
    record.Data.WINS.dwLookupTimeout = NBSTAT_DEFAULT_LOOKUP_TIMEOUT;

    Argc = ParseWinsFixedFields(
                & record,
                Argc,
                Argv,
                pParseInfo );
    if ( Argc == 0 || Argc == (DWORD)(-1) )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_NBSTAT_RECORD,
            pParseInfo,
            NULL );
        return DNSSRV_ERROR_MISSING_TOKEN;
    }
    if ( argcFixed -= Argc )
    {
        Argv += argcFixed;
    }

    //
    //  WINSR result domain
    //      - do this first to determine record length
    //

    status = File_ReadCountNameFromToken(
                & countName,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return DNSSRV_PARSING_ERROR;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_WINS_FIXED_DATA +
                            Name_LengthDbaseNameFromCountName(&countName)) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;
    prr->wType = DNS_TYPE_WINSR;

    //  copy fixed fields

    RtlCopyMemory(
        &prr->Data,
        &record.Data,
        SIZEOF_WINS_FIXED_DATA );

    //
    //  write WINSR result domain
    //

    Name_CopyCountNameToDbaseName(
        & prr->Data.WINSR.nameResultDomain,
        & countName );

    return( status );
}



DNS_STATUS
buildKeyOrSignatureFromTokens(
    OUT     PBYTE           pKey,
    IN OUT  PDWORD          pKeyLength,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv
    )
/*++

Routine Description:

    Build a key or signature from a set of tokens representing the
    actual key or signature in base64 notation.

Arguments:

    pKey        - ptr to buffer for key

    pKeyLength  - ptr to DWORD with max key length

    Argc        - token count

    Argv        - tokens

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD   len;
    DWORD   stringLength = 0;
    UCHAR   stringKey[ DNS_MAX_KEY_STRING_LENGTH + 1 ];
    PUCHAR  pstringKey = stringKey;

    //
    //  There must be key tokens.
    //

    if ( Argc < 1 )
    {
        return DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  Collect argcs into a single key string.
    //

    while( Argc-- )
    {
        len = Argv->cchLength;
        stringLength += len;
        if ( stringLength > DNS_MAX_KEY_STRING_LENGTH )
        {
            return DNSSRV_ERROR_EXCESS_TOKEN;
        }
        RtlCopyMemory(
            pstringKey,
            Argv->pchToken,
            len );
        pstringKey += len;
        ++Argv;
    }

    stringKey[ stringLength ] = '\0';   // NULL terminate the string

    //
    //  Convert the key string from base64 character representation (RFC2045,
    //  also reproduced in part in Appendix A of RFC2535) to actual binary key.
    //

    return Dns_SecurityBase64StringToKey(
                pKey,
                pKeyLength,
                stringKey,
                stringLength );
}



DNS_STATUS
KeyFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process KEY record - DNSSEC RFC2535 section 3

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    WORD        flag = 0;
    UCHAR       protocol;
    UCHAR       algorithm;
    BOOL        foundFlag = FALSE;
    DWORD       dwTemp;
    DWORD       keyLength;
    UCHAR       key[ DNS_MAX_KEY_LENGTH ];

    //
    //  KEY  <flags> <protocol> <algorithm> <key bytes>
    //

    if ( Argc < 3 )
    {
        status = DNSSRV_ERROR_MISSING_TOKEN;
        goto Cleanup;
    }

    //
    //  Flags may be either set of mnemonics or unsigned integer.
    //  Loop converting tokens as mnemonics until failure, if none
    //  none converted then flag must be unsigned integer.
    //

    while ( Argc > 2 )
    {
        WORD    thisFlag;

        thisFlag = Dns_KeyRecordFlagForString(
                        Argv->pchToken,
                        Argv->cchLength );
        if ( thisFlag == ( WORD ) DNSSEC_ERROR_NOSTRING )
        {
            break;
        }
        flag |= thisFlag;
        foundFlag = TRUE;
        NEXT_TOKEN( Argc, Argv );
    }

    //
    //  If no matching mnemonics, try reading flag as integer value.
    //

    if ( !foundFlag )
    {
        if ( !File_ParseDwordToken(
                &dwTemp,
                Argv,
                pParseInfo ) ||
            dwTemp > MAXWORD )
        {
            status = DNSSRV_PARSING_ERROR;
            goto Cleanup;
        }
        flag = ( WORD ) dwTemp;
        NEXT_TOKEN( Argc, Argv );
    }

    //
    //  Protocol may also be mnemonic or integer. Try parsing mnemonic but
    //  if that fails read as integer.
    //

    protocol = Dns_KeyRecordProtocolForString(
                    Argv->pchToken,
                    Argv->cchLength );
    if ( protocol == ( UCHAR ) DNSSEC_ERROR_NOSTRING )
    {
        if ( !File_ParseDwordToken(
                &dwTemp,
                Argv,
                pParseInfo ) ||
            dwTemp > MAXUCHAR )
        {
            status = DNSSRV_PARSING_ERROR;
            goto Cleanup;
        }
        protocol = ( UCHAR ) dwTemp;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  Algorithm may also be mnemonic or integer. Try parsing mnemonic but
    //  if that fails read as integer.
    //

    algorithm = Dns_SecurityAlgorithmForString(
                    Argv->pchToken,
                    Argv->cchLength );
    if ( algorithm == ( UCHAR ) DNSSEC_ERROR_NOSTRING )
    {
        if ( !File_ParseDwordToken(
                &dwTemp,
                Argv,
                pParseInfo ) ||
            dwTemp > MAXUCHAR )
        {
            status = DNSSRV_PARSING_ERROR;
            goto Cleanup;
        }
        algorithm = ( UCHAR ) dwTemp;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  Parse the key tokens into a binary key.
    //

    status = buildKeyOrSignatureFromTokens(
                key,
                &keyLength,
                Argc,
                Argv );
    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  Allocate the RR with enough space to hold the binary key.
    //

    pRR = RR_Allocate( ( WORD )( SIZEOF_KEY_FIXED_DATA + keyLength ) );
    IF_NOMEM( !pRR )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }
    pParseInfo->pRR = pRR;

    //
    //  Copy parsed values into RR data fields.
    //

    pRR->Data.KEY.wFlags        = htons( flag );
    pRR->Data.KEY.chProtocol    = protocol;
    pRR->Data.KEY.chAlgorithm   = algorithm;

    RtlCopyMemory(
        pRR->Data.KEY.Key,
        key,
        keyLength );

    //
    //  Final processing, cleanup, and return.
    //

    Cleanup:

    if ( status == DNSSRV_PARSING_ERROR )
    {
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
    }

    return status;
}   //  KeyFileRead



DNS_STATUS
SigFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process SIG record - DNSSEC RFC2535 section 4

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    WORD        typeCovered;
    WORD        keyTag;
    DWORD       originalTtl;
    DWORD       sigExpiration;
    DWORD       sigInception;
    DWORD       dwTemp;
    COUNT_NAME  signersCountName;
    DWORD       sigLength;
    UCHAR       sig[ DNS_MAX_KEY_LENGTH ];
    UCHAR       algorithm;
    UCHAR       labelCount;

    //
    //  SIG format: <type covered> <algorithm> <original TTL> 
    //      <signature expiration> <signature inception>
    //      <key tag> <signer's name> <signature in base64 form>
    //

    if ( Argc < 8 )
    {
        status = DNSSRV_ERROR_MISSING_TOKEN;
        goto Cleanup;
    }

    //
    //  Type covered is single type in either mnemonic or integer form.
    //  Try parsing mnemonic but if that fails read as integer.
    //

    typeCovered = Dns_RecordTypeForName(
                    Argv->pchToken,
                    Argv->cchLength );
    if ( typeCovered == ( WORD ) DNSSEC_ERROR_NOSTRING )
    {
        if ( !File_ParseDwordToken(
               &dwTemp,
               Argv,
               pParseInfo ) ||
            dwTemp > MAXWORD )
        {
            status = DNSSRV_PARSING_ERROR;
            goto Cleanup;
        }
        typeCovered = ( WORD ) dwTemp;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  Algorithm may also be mnemonic or integer. Try parsing mnemonic but
    //  if that fails read as integer.
    //

    algorithm = Dns_SecurityAlgorithmForString(
                    Argv->pchToken,
                    Argv->cchLength );
    if ( algorithm == ( UCHAR ) DNSSEC_ERROR_NOSTRING )
    {
        if ( !File_ParseDwordToken(
               &dwTemp,
               Argv,
               pParseInfo ) ||
            dwTemp > MAXUCHAR )
        {
            status = DNSSRV_PARSING_ERROR;
            goto Cleanup;
        }
        algorithm = ( UCHAR ) dwTemp;
    }
    NEXT_TOKEN( Argc, Argv );

    // 
    //  Label count is an unsigned integer value.
    //
    
    if ( !File_ParseDwordToken(
            &dwTemp,
            Argv,
            pParseInfo ) )
    {
        status = DNSSRV_PARSING_ERROR;
        goto Cleanup;
    }
    labelCount = ( UCHAR ) dwTemp > 127 ? 127 : ( UCHAR ) dwTemp;
    NEXT_TOKEN( Argc, Argv );

    // 
    //  Original TTL is an unsigned integer value.
    //
    
    if ( !File_ParseDwordToken(
            &dwTemp,
            Argv,
            pParseInfo ) )
    {
        status = DNSSRV_PARSING_ERROR;
        goto Cleanup;
    }
    originalTtl = ( DWORD ) dwTemp;
    NEXT_TOKEN( Argc, Argv );

    //
    //  Signature expiration and inceptions times are string values
    //  in YYYYMMDDHHMMSS format.
    //

    sigExpiration = ( DWORD ) Dns_ParseSigTime(
                                Argv->pchToken,
                                Argv->cchLength );
    NEXT_TOKEN( Argc, Argv );

    sigInception = ( DWORD ) Dns_ParseSigTime(
                                Argv->pchToken,
                                Argv->cchLength );
    NEXT_TOKEN( Argc, Argv );

    // 
    //  Key tag is an unsigned integer value.
    //
    
    if ( !File_ParseDwordToken(
            &dwTemp,
            Argv,
            pParseInfo ) ||
        dwTemp > MAXWORD )
    {
        status = DNSSRV_PARSING_ERROR;
        goto Cleanup;
    }
    keyTag = ( WORD ) dwTemp;
    NEXT_TOKEN( Argc, Argv );

    //
    //  Signer's name is a regular DNS domain name which may be
    //  compressed in the usual fashion.
    //

    status = File_ReadCountNameFromToken(
                &signersCountName,
                pParseInfo,
                Argv );
    if ( status != ERROR_SUCCESS )
    {
        status = DNSSRV_PARSING_ERROR;
        goto Cleanup;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  Signature is a base64 representation. Parse it into a binary
    //  string.
    //

    status = buildKeyOrSignatureFromTokens(
                sig,
                &sigLength,
                Argc,
                Argv );
    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  Allocate the RR with enough space to hold the binary signature.
    //  Note that since we have two variable length elements (sig and
    //  signer's name), we must include one of them in it's entirety.
    //  So the signer's name element is always allocated to it's maximum
    //  size and the sig is allowed to "float" at the end of the struct.
    //

    pRR = RR_Allocate( ( WORD )(
                SIZEOF_SIG_FIXED_DATA +
                Name_LengthDbaseNameFromCountName( &signersCountName ) +
                sigLength ) );
    IF_NOMEM( !pRR )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }
    pParseInfo->pRR = pRR;

    //
    //  Copy parsed values into RR data fields.
    //

    Name_CopyCountNameToDbaseName(
        &pRR->Data.SIG.nameSigner,
        &signersCountName );

    pRR->Data.SIG.wTypeCovered      = htons( typeCovered );
    pRR->Data.SIG.chAlgorithm       = algorithm;
    pRR->Data.SIG.chLabelCount      = labelCount;
    pRR->Data.SIG.dwOriginalTtl     = htonl( originalTtl );
    pRR->Data.SIG.dwSigExpiration   = htonl( sigExpiration );
    pRR->Data.SIG.dwSigInception    = htonl( sigInception );
    pRR->Data.SIG.wKeyTag           = htons( keyTag );

    RtlCopyMemory(
        ( PBYTE ) &pRR->Data.SIG.nameSigner +
            DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner ),
        sig,
        sigLength );

    //
    //  Final processing, cleanup, and return.
    //

    Cleanup:

    if ( status == DNSSRV_PARSING_ERROR )
    {
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
    }
    return status;
} // SigFileRead



DNS_STATUS
NxtFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process NXT record - DNSSEC RFC2535

    Note: we always copy the maximum bitmap to the RR. It's not that
    big, and if we have to add types later it saves us from having to
    reallocate the RR.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       dwTemp;
    BOOL        foundType = FALSE;
    COUNT_NAME  nextCountName;
    UCHAR       typeBitmap[ DNS_MAX_TYPE_BITMAP_LENGTH ] = { 0 };

    //
    //  NXT  <next domain name> <type bit map>
    //

    if ( Argc < 2 )
    {
        status = DNSSRV_ERROR_MISSING_TOKEN;
        goto Cleanup;
    }

    //
    //  Next domain name is a regular DNS domain name which may be
    //  compressed in the usual fashion.
    //

    status = File_ReadCountNameFromToken(
                &nextCountName,
                pParseInfo,
                Argv );
    if ( status != ERROR_SUCCESS )
    {
        status = DNSSRV_PARSING_ERROR;
        goto Cleanup;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  Type bit map is an unsigned int or series of type mnemonics.
    //

    while ( Argc )
    {
        WORD    wType;

        wType = Dns_RecordTypeForName(
                Argv->pchToken,
                Argv->cchLength );
        if ( wType == ( WORD ) DNSSEC_ERROR_NOSTRING )
        {
            break;
        }
        typeBitmap[ wType / 8 ] |= 1 << wType % 8;
        foundType = TRUE;
        NEXT_TOKEN( Argc, Argv );
    }

    if ( !foundType )
    {
        if ( !File_ParseDwordToken(
                &dwTemp,
                Argv,
                pParseInfo ) ||
            dwTemp > MAXDWORD )
        {
            status = DNSSRV_PARSING_ERROR;
            goto Cleanup;
        }
        * ( DWORD * ) typeBitmap = dwTemp;
        NEXT_TOKEN( Argc, Argv );
    }

    //
    //  Allocate the RR with enough space to hold the type bitmap and
    //  the signer's name.
    //


    pRR = RR_Allocate( ( WORD )(
                SIZEOF_NXT_FIXED_DATA +
                DNS_MAX_TYPE_BITMAP_LENGTH +
                Name_LengthDbaseNameFromCountName( &nextCountName ) ) );
    IF_NOMEM( !pRR )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }
    pParseInfo->pRR = pRR;

    //
    //  Copy parsed values into RR data fields.
    //

    RtlCopyMemory(
        pRR->Data.NXT.bTypeBitMap,
        typeBitmap,
        DNS_MAX_TYPE_BITMAP_LENGTH );

    Name_CopyCountNameToDbaseName(
        &pRR->Data.NXT.nameNext,
        &nextCountName );

    //
    //  Final processing, cleanup, and return.
    //

    Cleanup:

    if ( status == DNSSRV_PARSING_ERROR )
    {
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
    }

    return status;
}   //  NxtFileRead



//
//  Read RR from file functions
//

RR_FILE_READ_FUNCTION   RRFileReadTable[] =
{
    NULL,               //  ZERO -- no default for unknown types

    AFileRead,          //  A
    PtrFileRead,        //  NS
    PtrFileRead,        //  MD
    PtrFileRead,        //  MF
    PtrFileRead,        //  CNAME
    SoaFileRead,        //  SOA
    PtrFileRead,        //  MB
    PtrFileRead,        //  MG
    PtrFileRead,        //  MR
    NULL,               //  NULL
    WksFileRead,        //  WKS
    PtrFileRead,        //  PTR
    TxtFileRead,        //  HINFO
    MinfoFileRead,      //  MINFO
    MxFileRead,         //  MX
    TxtFileRead,        //  TXT
    MinfoFileRead,      //  RP
    MxFileRead,         //  AFSDB
    TxtFileRead,        //  X25
    TxtFileRead,        //  ISDN
    MxFileRead,         //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigFileRead,        //  SIG
    KeyFileRead,        //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    AaaaFileRead,       //  AAAA
    NULL,               //  LOC
    NxtFileRead,        //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvFileRead,        //  SRV
    AtmaFileRead,       //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    NULL,               //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    WinsFileRead,       //  WINS
    NbstatFileRead      //  WINS-R
};


//
//  End of rrfile.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rpccall.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    rpccall.c

Abstract:

    Domain Name System (DNS) Server

    General RPC routines.
    These remote routines provide general query \ operation
    to server.  Dispatch tables below dispatch to routines to
    handle specific operation \ query.

Author:

    Jim Gilroy (jamesg)     April, 1997

Revision History:

--*/


#include "dnssrv.h"
#include "sdutl.h"


/*--------------------------------------------------------------------------

A note on credentials and impersonation:

All RPC operations will be done in the client context. This is
new for .Net. However, there are operations which must be done
in the server context for them to succeed, such as writing
parameters back to the registry.

For these operations, the server must temporarily switch to 
it's own context and revert to the client context when the
operation is completed.

These exceptions aside, it is considered the default state in
an RPC operation for the thread to be operating in the context
of the RPC client, with brief switches into the server context
for operations that cannot be performed in the client context.

--------------------------------------------------------------------------*/


//
//  Server operations
//

DNS_STATUS
Rpc_Restart(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

#if DBG
DNS_STATUS
Rpc_DebugBreak(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_RootBreak(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );
#endif

DNS_STATUS
Rpc_ClearDebugLog(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ClearCache(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_WriteRootHints(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_WriteDirtyZones(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ClearStatistics(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetServerDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetServerStringProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetServerIPArrayProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetLogFilterListProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetForwarders(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetListenAddresses(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_CreateZone(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_EnlistDirectoryPartition(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_DeleteCacheNode(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeid,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_DeleteCacheRecordSet(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_StartScavenging(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_AbortScavenging(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_AutoConfigure(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );


//
//  Zone operations
//

DNS_STATUS
Rpc_WriteAndNotifyZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ReloadZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_RefreshSecondaryZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ExpireSecondaryZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_DeleteZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_RenameZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ExportZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_DeleteZoneFromDs(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_UpdateZoneFromDs(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_PauseZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResumeZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_LockZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneTypeEx(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ChangeZoneDirectoryPartition(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneDatabase(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneMasters(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneSecondaries(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneScavengeServers(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneAllowAutoNS(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneStringProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_DeleteZoneNode(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeid,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_DeleteRecordSet(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ForceAgingOnNode(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeid,
    IN      PVOID       pData
    );


//
//  Server queries
//

DNS_STATUS
Rpc_GetServerInfo(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_QueryServerDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_QueryServerStringProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_QueryServerIPArrayProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

//
//  Zone queries
//

DNS_STATUS
Rpc_GetZoneInfo(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_GetZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_QueryZoneDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_QueryZoneIPArrayProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_QueryZoneStringProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );


//
//  Complex in\out operations
//

DNS_STATUS
Rpc_EnumZones(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_EnumZones2(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_EnumDirectoryPartitions(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_DirectoryPartitionInfo(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_GetStatistics(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_QueryDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_QueryStringProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_QueryIPListProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );



//
//  RPC Dispatch Tables
//
//  NT5+ RPC interface uses fewer more extensible calls.
//  The calls contain string determining the operation or
//  query to perform.  These tables dispatch appropriately.
//
//  This is general dispatch definition so I can write one routine to
//  lookup dispatch functions without typing problems and still
//  get type checking between the actual functions (and prototypes)
//  and the dispatch function definition for the table.
//

typedef DNS_STATUS (* DNS_RPC_DISPATCH_FUNCTION)();

typedef struct _DnsRpcDispatchEntry
{
    LPCSTR                      pszOperation;
    DNS_RPC_DISPATCH_FUNCTION   pfnFunction;
    DWORD                       dwTypeIn;
    DWORD                       dwAccess;
}
DNS_RPC_DISPATCH_ENTRY, *PDNS_RPC_DISPATCH_ENTRY;



//
//  Server operations
//

typedef DNS_STATUS (* RPC_SERVER_OPERATION_FUNCTION)(
                        IN      DWORD       dwClientVersion,
                        IN      LPSTR       pszOperation,
                        IN      DWORD       dwTypeIn,
                        IN      PVOID       pData
                        );
typedef struct _DnsRpcServerOperation
{
    LPCSTR                              pszServerOperationName;
    RPC_SERVER_OPERATION_FUNCTION       pfnServerOperationFunc;
    DWORD                               dwTypeIn;
    DWORD                               dwAccess;
};

struct _DnsRpcServerOperation RpcServerOperationTable[] =
{
    //
    //  Property reset functions
    //

    DNSSRV_OP_RESET_DWORD_PROPERTY                  ,
        Rpc_ResetServerDwordProperty                ,
            DNSSRV_TYPEID_NAME_AND_PARAM            ,
                PRIVILEGE_WRITE                     ,

    //  Operations

    DNSSRV_OP_RESTART                       ,
        Rpc_Restart                         ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

#if DBG
    DNSSRV_OP_DEBUG_BREAK                   ,
        Rpc_DebugBreak                      ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,
    DNSSRV_OP_ROOT_BREAK                    ,
        Rpc_RootBreak                       ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,
#endif
    DNSSRV_OP_CLEAR_DEBUG_LOG               ,
        Rpc_ClearDebugLog                   ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,
    DNSSRV_OP_CLEAR_CACHE                   ,
        Rpc_ClearCache                      ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_WRITE_BACK_FILE          ,
        Rpc_WriteRootHints                  ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_WRITE_DIRTY_ZONES             ,
        Rpc_WriteDirtyZones                 ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_CLEAR_STATISTICS              ,
        Rpc_ClearStatistics                 ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_CREATE                   ,
        Rpc_CreateZone                      ,
            DNSSRV_TYPEID_ZONE_CREATE       ,
                PRIVILEGE_WRITE_IF_FILE_READ_IF_DS,     //  enforced by AD for DS-integrated zone

    DNSSRV_OP_ENLIST_DP                     ,
        Rpc_EnlistDirectoryPartition        ,
            DNSSRV_TYPEID_ENLIST_DP         ,
                PRIVILEGE_READ              ,           //  enforced by AD

    DNSSRV_OP_START_SCAVENGING              ,
        Rpc_StartScavenging                 ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ABORT_SCAVENGING              ,
        Rpc_AbortScavenging                 ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_AUTO_CONFIGURE                ,
        Rpc_AutoConfigure                   ,
            DNSSRV_TYPEID_DWORD             ,
                PRIVILEGE_WRITE             ,

    //  Server operation as well as zone operation
    //  to accomodate cache zone

    DNSSRV_OP_DELETE_NODE                   ,
        Rpc_DeleteCacheNode                 ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_DELETE_RECORD_SET             ,
        Rpc_DeleteCacheRecordSet            ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,

    //  Complex property reset

    DNS_REGKEY_LISTEN_ADDRESSES             ,
        Rpc_ResetListenAddresses            ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_FORWARDERS                   ,
        Rpc_ResetForwarders                 ,
            DNSSRV_TYPEID_FORWARDERS        ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_LOG_FILE_PATH                ,
        Rpc_ResetServerStringProperty       ,
            DNSSRV_TYPEID_LPWSTR            ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_LOG_IP_FILTER_LIST           ,
        Rpc_ResetServerIPArrayProperty      ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_FOREST_DP_BASE_NAME          ,
        Rpc_ResetServerStringProperty       ,
            DNSSRV_TYPEID_LPWSTR            ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_DOMAIN_DP_BASE_NAME          ,
        Rpc_ResetServerStringProperty       ,
            DNSSRV_TYPEID_LPWSTR            ,
                PRIVILEGE_WRITE             ,

    //  Debugging aids

    DNS_REGKEY_BREAK_ON_RECV_FROM           ,
        Rpc_ResetServerIPArrayProperty      ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_BREAK_ON_UPDATE_FROM         ,
        Rpc_ResetServerIPArrayProperty      ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    //  Plugin
    
    DNS_REGKEY_SERVER_PLUGIN                ,
        Rpc_ResetServerStringProperty       ,
            DNSSRV_TYPEID_LPWSTR            ,
                PRIVILEGE_WRITE             ,

    NULL, NULL, 0, 0
};



//
//  Zone operations
//

typedef DNS_STATUS (* RPC_ZONE_OPERATION_FUNCTION)(
                        IN      DWORD       dwClientVersion,
                        IN      PZONE_INFO  pZone,
                        IN      LPSTR       pszOperation,
                        IN      DWORD       dwTypeIn,
                        IN      PVOID       pData
                        );

typedef struct _DnsRpcZoneOperation
{
    LPCSTR                          pszZoneOperationName;
    RPC_ZONE_OPERATION_FUNCTION     pfnZoneOperationFunc;
    DWORD                           dwTypeIn;
    DWORD                           dwAccess;
};

struct _DnsRpcZoneOperation RpcZoneOperationTable[] =
{
    //  Operations

    DNSSRV_OP_ZONE_RELOAD                   ,
        Rpc_ReloadZone                      ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_EXPIRE                   ,
        Rpc_ExpireSecondaryZone             ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_REFRESH                  ,
        Rpc_RefreshSecondaryZone            ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_WRITE_BACK_FILE          ,
        Rpc_WriteAndNotifyZone              ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_INCREMENT_VERSION        ,
        Rpc_WriteAndNotifyZone              ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_DELETE                   ,
        Rpc_DeleteZone                      ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE_IF_FILE_READ_IF_DS,     //  enforced by AD for DS-integrated zone

#if 1
//
//  This feature has been postponed until post-Whistler
//
    DNSSRV_OP_ZONE_RENAME                   ,
        Rpc_RenameZone                      ,
            DNSSRV_TYPEID_ZONE_RENAME       ,
                PRIVILEGE_WRITE             ,
#endif

    DNSSRV_OP_ZONE_EXPORT                   ,
        Rpc_ExportZone                      ,
            DNSSRV_TYPEID_ZONE_EXPORT       ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_PAUSE                    ,
        Rpc_PauseZone                       ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_RESUME                   ,
        Rpc_ResumeZone                      ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

#if DBG
    DNSSRV_OP_ZONE_LOCK                     ,
        Rpc_LockZone                        ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,
#endif

    DNSSRV_OP_ZONE_DELETE_NODE              ,
        Rpc_DeleteZoneNode                  ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_DELETE_RECORD_SET             ,
        Rpc_DeleteRecordSet                 ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_FORCE_AGING_ON_NODE           ,
        Rpc_ForceAgingOnNode                ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_DELETE_FROM_DS           ,
        Rpc_DeleteZoneFromDs                ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_UPDATE_FROM_DS           ,
        Rpc_UpdateZoneFromDs                ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    //  Complex property reset

    DNSSRV_OP_ZONE_TYPE_RESET               ,
        Rpc_ResetZoneTypeEx                 ,
            DNSSRV_TYPEID_ZONE_CREATE       ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_CHANGE_DP                ,
        Rpc_ChangeZoneDirectoryPartition    ,
            DNSSRV_TYPEID_ZONE_CHANGE_DP    ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_FILE                    ,
        Rpc_ResetZoneDatabase               ,
            DNSSRV_TYPEID_ZONE_DATABASE     ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_MASTERS                 ,
        Rpc_ResetZoneMasters                ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_LOCAL_MASTERS           ,
        Rpc_ResetZoneMasters                ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_SECONDARIES             ,
        Rpc_ResetZoneSecondaries            ,
            DNSSRV_TYPEID_ZONE_SECONDARIES  ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_SCAVENGE_SERVERS        ,
        Rpc_ResetZoneScavengeServers        ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_ALLOW_AUTONS            ,
        Rpc_ResetZoneAllowAutoNS            ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE    ,
        Rpc_ResetZoneStringProperty         ,
            DNSSRV_TYPEID_LPWSTR            ,
                PRIVILEGE_WRITE             ,

    //  DWORD property reset

    DNSSRV_OP_RESET_DWORD_PROPERTY          ,
        Rpc_ResetZoneDwordProperty          ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,

    NULL, NULL, 0, 0
};



//
//  Server queries
//

typedef DNS_STATUS (* RPC_SERVER_QUERY_FUNCTION)(
                        IN      DWORD       dwClientVersion,
                        IN      LPSTR       pszQuery,
                        IN      PDWORD      pdwTypeOut,
                        IN      PVOID *     ppData
                        );

typedef struct _DnsRpcServerQuery
{
    LPCSTR                      pszServerQueryName;
    RPC_SERVER_QUERY_FUNCTION   pfnServerQueryFunc;
    DWORD                       dwTypeIn;
    DWORD                       dwAccess;
};

struct _DnsRpcServerQuery RpcServerQueryTable[] =
{
    //  General queries

    DNSSRV_QUERY_SERVER_INFO            ,
        Rpc_GetServerInfo               ,
            0                           ,
                PRIVILEGE_READ          ,

    DNS_REGKEY_LOG_FILE_PATH            ,
        Rpc_QueryServerStringProperty   ,
            0                           ,
                PRIVILEGE_READ          ,

    DNS_REGKEY_LOG_IP_FILTER_LIST       ,
        Rpc_QueryServerIPArrayProperty  ,
            0                           ,
                PRIVILEGE_READ          ,

    //  Interface setup

    DNS_REGKEY_LISTEN_ADDRESSES         ,
        NULL                            ,   //Rpc_QueryListenAddresses,
            0                           ,
                PRIVILEGE_READ          ,

    DNS_REGKEY_FORWARDERS               ,
        NULL                            ,   //Rpc_QueryForwarders
            0                           ,
                PRIVILEGE_READ          ,

    //  Directory partitions

    DNS_REGKEY_FOREST_DP_BASE_NAME      ,
        Rpc_QueryServerStringProperty   ,
            0                           ,
                PRIVILEGE_READ          ,

    DNS_REGKEY_DOMAIN_DP_BASE_NAME      ,
        Rpc_QueryServerStringProperty   ,
            0                           ,
                PRIVILEGE_READ          ,

    //  Debugging

    DNS_REGKEY_BREAK_ON_RECV_FROM       ,
        Rpc_QueryServerIPArrayProperty  ,
            0                           ,
                PRIVILEGE_READ          ,

    DNS_REGKEY_BREAK_ON_UPDATE_FROM     ,
        Rpc_QueryServerIPArrayProperty  ,
            0                           ,
                PRIVILEGE_READ          ,

    //  Plugin
    
    DNS_REGKEY_SERVER_PLUGIN            ,
        Rpc_QueryServerStringProperty   ,
            0                           ,
                PRIVILEGE_READ          ,

    NULL, NULL, 0, 0
};



//
//  Zone queries
//

typedef DNS_STATUS (* RPC_ZONE_QUERY_FUNCTION)(
                        IN      DWORD       dwClientVersion,
                        IN      PZONE_INFO  pZone,
                        IN      LPSTR       pszQuery,
                        IN      PDWORD      pdwTypeOut,
                        IN      PVOID *     ppData
                        );

typedef struct _DnsRpcZoneQuery
{
    LPCSTR                      pszZoneQueryName;
    RPC_ZONE_QUERY_FUNCTION     pfnZoneQueryFunc;
    DWORD                       dwTypeIn;
    DWORD                       dwAccess;
};

struct _DnsRpcZoneQuery RpcZoneQueryTable[] =
{
    //  Property Queries
    //
    //  Note:  elminatated all DWORD property queries here
    //  as dispatch function by default assumes that unmatched
    //  query name => Rpc_QueryZoneDwordProperty
    //

#if 0
    //  If want DWORD queries broken out, they would be like this
    DNS_REGKEY_ZONE_Xxx                     ,
        Rpc_QueryZoneDwordProperty          ,
            0                               ,
                PRIVILEGE_READ              ,
#endif

#if 0
    //  Need special function
    //  DEVNOTE:  not yet implemented

    DNS_REGKEY_ZONE_FILE                    ,
        NULL                                , //Rpc_QueryZoneDatabase,
            0                               ,
                PRIVILEGE_READ              ,

    DNS_REGKEY_ZONE_MASTERS                 ,
        NULL                                , //Rpc_QueryZoneMasters,
            0                               ,
                PRIVILEGE_READ              ,

    DNS_REGKEY_ZONE_LOCAL_MASTERS           ,
        NULL                                , //Rpc_QueryZoneMasters,
            0                               ,
                PRIVILEGE_READ              ,

    DNS_REGKEY_ZONE_SECONDARIES             ,
        NULL                                , //Rpc_QueryZoneSecondaries,
            0                               ,
                PRIVILEGE_READ              ,
#endif

    //  Special queries

    DNSSRV_QUERY_ZONE_HANDLE                ,
        Rpc_QueryZoneDwordProperty          ,
            0                               ,
                PRIVILEGE_READ              ,
    DNSSRV_QUERY_ZONE                       ,
        Rpc_GetZone                         ,
            0                               ,
                PRIVILEGE_READ              ,
    DNSSRV_QUERY_ZONE_INFO                  ,
        Rpc_GetZoneInfo                     ,
            0                               ,
                PRIVILEGE_READ              ,
    DNS_REGKEY_ZONE_ALLOW_AUTONS            ,
        Rpc_QueryZoneIPArrayProperty        ,
            0                               ,
                PRIVILEGE_READ              ,
    DNS_REGKEY_ZONE_MASTERS                 ,
        Rpc_QueryZoneIPArrayProperty        ,
            0                               ,
                PRIVILEGE_READ              ,
    DNS_REGKEY_ZONE_LOCAL_MASTERS           ,
        Rpc_QueryZoneIPArrayProperty        ,
            0                               ,
                PRIVILEGE_READ              ,
    DNS_REGKEY_ZONE_SECONDARIES           ,
        Rpc_QueryZoneIPArrayProperty        ,
            0                               ,
                PRIVILEGE_READ              ,
    DNS_REGKEY_ZONE_NOTIFY_LIST           ,
        Rpc_QueryZoneIPArrayProperty        ,
            0                               ,
                PRIVILEGE_READ              ,
    DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE    ,
        Rpc_QueryZoneStringProperty         ,
            0                               ,
                PRIVILEGE_READ              ,

    NULL, NULL, 0, 0
};



//
//  RPC Complex In\Out Operations
//

typedef DNS_STATUS (* RPC_COMPLEX_OPERATION_FUNCTION)(
                        IN      DWORD       dwClientVersion,
                        IN      PZONE_INFO  pZone,
                        IN      LPSTR       pszQuery,
                        IN      DWORD       dwTypeIn,
                        IN      PVOID       pDataIn,
                        IN      PDWORD      pdwTypeOut,
                        IN      PVOID *     ppData
                        );

typedef struct _DnsRpcComplexOperation
{
    LPCSTR                          pszComplexOperationName;
    RPC_COMPLEX_OPERATION_FUNCTION  pfnComplexOperationFunc;
    DWORD                           dwTypeIn;
    DWORD                           dwAccess;
};

struct _DnsRpcComplexOperation  RpcComplexOperationTable[] =
{
    DNSSRV_OP_ENUM_ZONES                    ,
        Rpc_EnumZones                       ,
            DNSSRV_TYPEID_DWORD             ,   // input is filter DWORD
                PRIVILEGE_READ              ,

    DNSSRV_OP_ENUM_ZONES2                   ,
        Rpc_EnumZones2                      ,
            DNSSRV_TYPEID_ENUM_ZONES_FILTER ,   // input is filter structure
                PRIVILEGE_READ              ,

    DNSSRV_OP_ENUM_DPS                      ,
        Rpc_EnumDirectoryPartitions         ,
            DNSSRV_TYPEID_DWORD             ,   // input is unused
                PRIVILEGE_READ              ,

    DNSSRV_OP_DP_INFO                       ,
        Rpc_DirectoryPartitionInfo          ,
            DNSSRV_TYPEID_LPSTR             ,   // input is unused
                PRIVILEGE_READ              ,

    DNSSRV_QUERY_STATISTICS                 ,
        Rpc_GetStatistics                   ,
            DNSSRV_TYPEID_DWORD             ,   // input is filter
                PRIVILEGE_READ              ,

    DNSSRV_QUERY_DWORD_PROPERTY             ,
        Rpc_QueryDwordProperty              ,
            DNSSRV_TYPEID_LPSTR             ,   // input is property name
                PRIVILEGE_READ              ,

#if 0
    DNSSRV_OP_ENUM_RECORDS                  ,
        Rpc_EnumRecords                     ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_READ              ,

#endif

    NULL, NULL, 0, 0
};




//
//  General DNS server API
//

DNS_RPC_DISPATCH_FUNCTION
findMatchingFunction(
    IN      PDNS_RPC_DISPATCH_ENTRY DispatchTable,
    IN      LPCSTR                  pszOperation,
    IN      DWORD                   dwTypeIn,
    OUT     PDWORD                  pdwAccessRequired       OPTIONAL
    )
/*++

Routine Description:

    Find RPC dispatch function.

Arguments:

    DispatchTable   -- table to search for named operation

    pszOperation    -- name of operation to find function for

    dwTypeIn        -- type id of incoming data;
        for query functions where no incoming data, use DNSSRV_TYPEID_ANY
        for operation functions which do there own type checking, their
        type id in dispatch table may be set to DNSSRV_TYPEID_ANY
    
    pdwAccessRequired -- access required to execute this function

Return Value:

    Pointer to dispatch function, if successful
    NULL if operation not found.

--*/
{
    DWORD   index = 0;
    DWORD   dispatchType;
    LPCSTR  pszopName;

    //
    //  Check parameters.
    //

    if ( !DispatchTable || !pszOperation )
    {
        return NULL;
    }
    
    if ( pdwAccessRequired )
    {
        *pdwAccessRequired = 0;
    }

    //
    //  loop through dispatch table, until find operation or reach end
    //

    while ( ( pszopName = DispatchTable[ index ].pszOperation ) != NULL )
    {
        if ( _stricmp( pszopName, pszOperation ) == 0 )
        {
            //  found matching operation
            //      - check type id, if desired
            //      - return pointer to dispatch function

            if ( dwTypeIn != DNSSRV_TYPEID_ANY )
            {
                dispatchType = DispatchTable[ index ].dwTypeIn;
                if ( dispatchType != dwTypeIn &&
                     dispatchType != DNSSRV_TYPEID_ANY )
                {
                    DNS_DEBUG( RPC, (
                        "ERROR:  RPC type %d != dispatch type %d for routine\n",
                        dwTypeIn,
                        dispatchType ));
                    return NULL;
                }
            }

            if ( pdwAccessRequired )
            {
                *pdwAccessRequired = DispatchTable[ index ].dwAccess;
            }

            return DispatchTable[ index ].pfnFunction;
        }
        index++;
    }

    //  named operation not found

    DNS_DEBUG( RPC, (
        "ERROR:  RPC command %s not found in dispatch table.\n",
        pszOperation ));
    return NULL;
}



DNS_STATUS
R_DnssrvQuery(
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZone,
    IN      LPCSTR              pszQuery,
    OUT     PDWORD              pdwTypeOut,
    OUT     DNSSRV_RPC_UNION *  ppData
    )
/*++

    
Routine Description:

    Legacy version of R_DnssrvQuery - no client version argument.

Arguments:

    See R_DnssrvQuery2

Return Value:

    See R_DnssrvQuery2

--*/
{
    DNS_STATUS      status;
    
    DNS_DEBUG( RPC, (
        "R_DnssrvQuery() - non-versioned legacy call\n" ));

    status = R_DnssrvQuery2(
                    DNS_RPC_W2K_CLIENT_VERSION,
                    0,
                    hServer,
                    pszZone,
                    pszQuery,
                    pdwTypeOut,
                    ppData );
    return status;
}   //  R_DnssrvQuery



DNS_STATUS
R_DnssrvQuery2(
    IN      DWORD               dwClientVersion,
    IN      DWORD               dwSettingFlags,
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZone,
    IN      LPCSTR              pszQuery,
    OUT     PDWORD              pdwTypeOut,
    OUT     DNSSRV_RPC_UNION *  ppData
    )
/*++

Routine Description:

    Get a blob of data.

Arguments:

    Server      -- server string handle
    pszZone     -- zone name;  NULL if server property
    pszQuery    -- name of data item to retrieve
    dwTypeIn    -- addr to set with switch indicating data type
    ppData      -- addr to set with data answering query

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PZONE_INFO  pzone;
    DNS_STATUS  status = ERROR_SUCCESS;
    BOOL        bstatus;

    DNS_DEBUG( RPC, (
        "R_DnssrvQuery2():\n"
        "    dwClientVersion  = 0x%X\n"
        "    pszZone          = %s\n"
        "    pszQuery         = %s\n"
        "    pdwTypeOut       = %p\n"
        "    ppData           = %p\n",
        dwClientVersion,
        pszZone,
        pszQuery,
        pdwTypeOut,
        ppData ));

    if ( !ppData || !pdwTypeOut )
    {
        status = ERROR_INVALID_PARAMETER;
        goto DoneNotImpersonating;
    }

    //  set return PTRs for error case
    //  this may be unnecessary if RPC always inits to zero

    *( PVOID * ) ppData = NULL;
    *pdwTypeOut = DNSSRV_TYPEID_NULL;

    //
    //  access check
    //

    status = RpcUtil_FindZone( pszZone, RPC_INIT_FIND_ALL_ZONES, &pzone );
    if ( status != ERROR_SUCCESS )
    {
        goto DoneNotImpersonating;
    }

    status = RpcUtil_SessionSecurityInit(
                NULL,
                pzone,
                PRIVILEGE_READ,
                RPC_INIT_FIND_ALL_ZONES,
                NULL );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    //
    //  Switch back to server context. There is no need to do RPC
    //  read operations in the user context.
    //

    status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    //
    //  server info, dispatch
    //
    //  DEVNOTE: fail into DWORD or other property from SrvCfg table
    //      alternatively expose another query param so folks can do
    //          - QueryServerDword
    //          - RefreshInterval
    //

    if ( !pzone )
    {
        RPC_SERVER_QUERY_FUNCTION  function;

        function = ( RPC_SERVER_QUERY_FUNCTION )
                        findMatchingFunction(
                            ( PDNS_RPC_DISPATCH_ENTRY ) RpcServerQueryTable,
                            pszQuery,
                            ( DWORD ) DNSSRV_TYPEID_ANY,
                            NULL );
        if ( !function )
        {
            function = Rpc_QueryServerDwordProperty;
        }

        status = ( *function )(
                    dwClientVersion,
                    ( LPSTR ) pszQuery,
                    pdwTypeOut,
                    ( PVOID * ) ppData );
    }

    //
    //  zone info query -- find zone, then dispatch query
    //
    //  note, if query function NOT found, then assume query for DWORD
    //  zone property;  this keeps us from having to maintain lookup
    //  in two places (zone query table above, as well as DWORD query
    //  function)
    //

    else
    {
        RPC_ZONE_QUERY_FUNCTION  function;

        function = ( RPC_ZONE_QUERY_FUNCTION )
                        findMatchingFunction(
                            ( PDNS_RPC_DISPATCH_ENTRY ) RpcZoneQueryTable,
                            pszQuery,
                            ( DWORD ) DNSSRV_TYPEID_ANY,
                            NULL );
        if ( !function )
        {
            function = Rpc_QueryZoneDwordProperty;

            //status = ERROR_INVALID_PARAMETER;
            //goto Cleanup;
        }

        status = ( *function )(
                    dwClientVersion,
                    pzone,
                    ( LPSTR ) pszQuery,
                    pdwTypeOut,
                    ( PVOID * ) ppData );
    }

    RpcUtil_SessionComplete();

    DoneNotImpersonating:
    
    return status;
}



DNS_STATUS
R_DnssrvOperation(
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZone,
    IN      DWORD               dwContext,
    IN      LPCSTR              pszOperation,
    IN      DWORD               dwTypeIn,
    IN      DNSSRV_RPC_UNION    pData
    )
/*++

    
Routine Description:

    Legacy version of R_DnssrvOperation - no client version argument.

Arguments:

    See R_DnssrvOperation2

Return Value:

    See R_DnssrvOperation2

--*/
{
    DNS_STATUS      status;
    
    DNS_DEBUG( RPC, (
        "R_DnssrvOperation() - non-versioned legacy call\n" ));

    status = R_DnssrvOperation2(
                    DNS_RPC_W2K_CLIENT_VERSION,
                    0,
                    hServer,
                    pszZone,
                    dwContext,
                    pszOperation,
                    dwTypeIn,
                    pData );
    return status;
}   //  R_DnssrvOperation



DNS_STATUS
R_DnssrvOperation2(
    IN      DWORD               dwClientVersion,
    IN      DWORD               dwSettingFlags,
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZone,
    IN      DWORD               dwContext,
    IN      LPCSTR              pszOperation,
    IN      DWORD               dwTypeIn,
    IN      DNSSRV_RPC_UNION    pData
    )
/*++

Routine Description:

    Perform operation.

Arguments:

    Server          -- server string handle
    pszZone         -- zone name;  NULL if server operation
    dwContext       -- additional context;
                        currently only supported context is multizone selection
    pszOperation    -- operation to perfrom
    dwTypeIn        -- switch indicating data type
    pData           -- ptr to block of data for operation

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DBG_FN( "R_DnssrvOperation2" )

    PZONE_INFO                      pzone = NULL;
    DNS_STATUS                      status;
    BOOL                            bstatus;
    DNSSRV_RPC_UNION                pdataCopy = pData;
    DWORD                           dwflag = 0;
    PDNS_DP_INFO                    pdp = NULL;
    BOOL                            bimpersonating = FALSE;
    RPC_ZONE_OPERATION_FUNCTION     zoneFunction = NULL;
    RPC_ZONE_OPERATION_FUNCTION     multiZoneFunction = NULL;
    RPC_SERVER_OPERATION_FUNCTION   serverFunction = NULL;
    DWORD                           dwaccessRequired = 0;

    DNS_DEBUG( RPC, (
        "%s:\n"
        "    dwClientVersion  = 0x%X\n"
        "    pszZone          = %s\n"
        "    dwContext        = %p\n"
        "    pszOperation     = %s\n"
        "    dwTypeIn         = %d\n"
        "    pData            = %p\n",
        fn,
        dwClientVersion,
        pszZone,
        dwContext,
        pszOperation,
        dwTypeIn,
        pData ));

    //
    //  This request may be from a downlevel client. If so, the RPC data 
    //  structure will need to be converted to the current version.
    //

    status = DnsRpc_ConvertToCurrent( &dwTypeIn, &pdataCopy.Null );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "unable to convert structure to current version error %d\n",
            status ));
        ASSERT( status == ERROR_SUCCESS );
        goto Cleanup;
    }

    //
    //  Do some preprocessing on the operation to pull out 
    //  information required to perform the access check.
    //

    if ( pszOperation )
    {
        if ( _stricmp( pszOperation, DNSSRV_OP_ZONE_EXPORT ) == 0 ||
             _stricmp( pszOperation, DNSSRV_OP_DELETE_NODE ) == 0 )
        {
            //  Allow cache zone to be a target of this operation.

            dwflag |= RPC_INIT_FIND_ALL_ZONES;
        }
        else if ( _stricmp( pszOperation, DNSSRV_OP_ZONE_CREATE ) == 0 )
        {
            //
            //  Pull out the target directory partition FQDN so we
            //  can perform the access check using the proper security
            //  descriptor.
            //

            PDNS_RPC_ZONE_CREATE_INFO   pci;

            if ( dwTypeIn == DNSSRV_TYPEID_ZONE_CREATE &&
                ( pci = pdataCopy.ZoneCreate ) != NULL &&
                pci->fDsIntegrated )
            {
                Dp_FindPartitionForZone(
                    pci->dwDpFlags,
                    pci->pszDpFqdn,
                    FALSE,
                    &pdp );
            }
        }
    }

    //
    //  Find zone pointer.
    //
        
    status = RpcUtil_FindZone( pszZone, dwflag, &pzone );
    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }
    
    //
    //  Check dispatch table for function. The dispatch table also tells
    //  us what kind of access this operation requires.
    //
    
    if ( pzone ||
         ( pszZone && _stricmp( pszZone, DNS_ZONE_ROOT_HINTS_A ) == 0 ) )
    {
        zoneFunction = ( RPC_ZONE_OPERATION_FUNCTION )
            findMatchingFunction(
                ( PDNS_RPC_DISPATCH_ENTRY ) RpcZoneOperationTable,
                pszOperation,
                dwTypeIn,
                &dwaccessRequired );
    }
    else if ( pszZone &&
                ( dwContext ||
                ( dwContext = Zone_GetFilterForMultiZoneName(
                                ( LPSTR ) pszZone ) ) ) )
    {
        multiZoneFunction = ( RPC_ZONE_OPERATION_FUNCTION )
            findMatchingFunction(
                ( PDNS_RPC_DISPATCH_ENTRY ) RpcZoneOperationTable,
                pszOperation,
                dwTypeIn,
                &dwaccessRequired );
    }
    else
    {
        serverFunction = ( RPC_SERVER_OPERATION_FUNCTION )
            findMatchingFunction(
                ( PDNS_RPC_DISPATCH_ENTRY ) RpcServerOperationTable,
                pszOperation,
                dwTypeIn,
                &dwaccessRequired );
    }
    
    if ( !zoneFunction && !multiZoneFunction && !serverFunction )
    {
        DNS_DEBUG( RPC, (
            "%s: invalid RPC operation %s\n", fn, pszOperation ));
        status =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    
    if ( !pzone && zoneFunction )
    {
        pzone = g_pRootHintsZone;
    }

	//
	//	Access check.
	//

    status = RpcUtil_SessionSecurityInit(
                pdp,
                pzone,
                dwaccessRequired,
                dwflag,
                &bimpersonating );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "%s: security failure - returning 0x%08X\n", fn, status ));
        return status;
    }
    ASSERT( bimpersonating );
    
    //
    //  Note: this thread is now operating using the RPC client's context.
    //

    //
    //  zone operation
    //      - find operation function
    //      - no zone operations on AutoCreated zones
    //

    if ( zoneFunction )
    {
        //  if auto-created, no valid operations

        if ( pzone->fAutoCreated )
        {
            status =  DNS_ERROR_INVALID_ZONE_TYPE;
            goto Cleanup;
        }

        status = ( *zoneFunction )(
                    dwClientVersion,
                    pzone,
                    ( LPSTR ) pszOperation,
                    dwTypeIn,
                    ( PVOID ) pdataCopy.Null );
    }

    //
    //  multizone operation
    //      - apply operation to all zones
    //      - save status of any failure
    //
    //  note, test must include check for multizones, because there
    //  are a couple other psuedo zone operations that fall through
    //  to server dispatch table
    //

    else if ( multiZoneFunction )
    {
        RPC_ZONE_OPERATION_FUNCTION     function;
        DNS_STATUS                      tempStatus = ERROR_SUCCESS;
        DNS_RPC_ENUM_ZONES_FILTER       filter = { 0 };

        pzone = NULL;
        filter.dwFilter = dwContext;

        while ( pzone = Zone_ListGetNextZoneMatchingFilter(
                                pzone,
                                &filter ) )
        {
            tempStatus = ( *multiZoneFunction )(
                            dwClientVersion,
                            pzone,
                            ( LPSTR ) pszOperation,
                            dwTypeIn,
                            ( PVOID ) pdataCopy.Null );

            if ( tempStatus > status )
            {
                status = tempStatus;
            }
        }
    }

    //
    //  server operation, dispatch
    //

    else if ( serverFunction )
    {
        status = ( *serverFunction )(
                    dwClientVersion,
                    ( LPSTR ) pszOperation,
                    dwTypeIn,
                    ( PVOID ) pdataCopy.Null );
    }


Cleanup:

    RpcUtil_SessionComplete();

    DNS_DEBUG( RPC, (
        "%s: returning 0x%08X\n", fn, status ));
    return status;
}



//
//  General RPC function shared between server\zone
//


DNS_STATUS
R_DnssrvComplexOperation(
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZone,
    IN      LPCSTR              pszOperation,
    IN      DWORD               dwTypeIn,
    IN      DNSSRV_RPC_UNION    pDataIn,
    OUT     PDWORD              pdwTypeOut,
    OUT     DNSSRV_RPC_UNION *  ppDataOut
    )
/*++

    
Routine Description:

    Legacy version of R_DnssrvComplexOperation - no client version argument.

Arguments:

    See R_DnssrvComplexOperation

Return Value:

    See R_DnssrvComplexOperation

--*/
{
    DNS_STATUS      status;
    
    DNS_DEBUG( RPC, (
        "R_DnssrvComplexOperation() - non-versioned legacy call\n" ));

    status = R_DnssrvComplexOperation2(
                    DNS_RPC_W2K_CLIENT_VERSION,
                    0,
                    hServer,
                    pszZone,
                    pszOperation,
                    dwTypeIn,
                    pDataIn,
                    pdwTypeOut,
                    ppDataOut );
    return status;
}   //  R_DnssrvComplexOperation



DNS_STATUS
R_DnssrvComplexOperation2(
    IN      DWORD               dwClientVersion,
    IN      DWORD               dwSettingFlags,
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZone,
    IN      LPCSTR              pszOperation,
    IN      DWORD               dwTypeIn,
    IN      DNSSRV_RPC_UNION    pDataIn,
    OUT     PDWORD              pdwTypeOut,
    OUT     DNSSRV_RPC_UNION *  ppDataOut
    )
/*++

Routine Description:

    Perform complex in\out operation.

Arguments:

    Server          -- server string handle
    pszZone         -- zone name;  NULL if server operation
    pszOperation    -- operation to perfrom
    dwTypeIn        -- switch indicating data type
    pDataIn         -- ptr to block of data for operation
    pdwTypeOut      -- addr to set with switch indicating data type
    ppDataOut       -- addr to set with data answering query

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    RPC_COMPLEX_OPERATION_FUNCTION      function;
    PZONE_INFO                          pzone = NULL;
    DNS_STATUS                          status;
    BOOL                                bstatus;
    DWORD                               dwaccessRequired = 0;

    DNS_DEBUG( RPC, (
        "R_DnssrvComplexOperation2():\n"
        "    dwClientVersion  = 0x%08X\n"
        "    pszZone          = %s\n"
        "    pszOperation     = %s\n"
        "    dwTypeIn         = %d\n"
        "    pDataIn          = %p\n"
        "    pdwTypeOut       = %p\n"
        "    ppData           = %p\n",
        dwClientVersion,
        pszZone,
        pszOperation,
        dwTypeIn,
        pDataIn,
        pdwTypeOut,
        ppDataOut ));

    if ( !ppDataOut || !pdwTypeOut )
    {
        status = ERROR_INVALID_PARAMETER;
        goto DoneNotImpersonating;
    }

    //  set return PTRs for error case
    //  this may be unnecessary if RPC always inits to zero

    *(PVOID *)ppDataOut = NULL;
    *pdwTypeOut = DNSSRV_TYPEID_NULL;

    function = ( RPC_COMPLEX_OPERATION_FUNCTION )
        findMatchingFunction(
            ( PDNS_RPC_DISPATCH_ENTRY ) RpcComplexOperationTable,
            pszOperation,
            dwTypeIn,
            &dwaccessRequired );
    if ( !function )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    status = RpcUtil_FindZone( pszZone, 0, &pzone );
    if ( status != ERROR_SUCCESS )
    {
        goto DoneNotImpersonating;
    }

    //
    //  access check
    //

    status = RpcUtil_SessionSecurityInit(
                NULL,
                pzone,
                dwaccessRequired,
                0,                  // no flag
                NULL );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    status = (*function)(
                dwClientVersion,
                pzone,
                (LPSTR) pszOperation,
                dwTypeIn,
                (PVOID) pDataIn.Null,
                pdwTypeOut,
                (PVOID) ppDataOut );

    Cleanup:

    RpcUtil_SessionComplete();

    DoneNotImpersonating:
    
    return status;
}



DNS_STATUS
Rpc_QueryDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Query server\zone DWORD property.

    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    if ( dwTypeIn != DNSSRV_TYPEID_LPSTR ||
         !pDataIn ||
         !ppDataOut ||
         !pdwTypeOut )
    {
        return ERROR_INVALID_PARAMETER;
    }


    //  if zone dispatch to zone property routine

    if ( pZone )
    {
        return  Rpc_QueryZoneDwordProperty(
                    dwClientVersion,
                    pZone,
                    (LPSTR) pDataIn,    // property name
                    pdwTypeOut,
                    ppDataOut );
    }

    //  otherwise, treat as server property

    return  Rpc_QueryServerDwordProperty(
                dwClientVersion,
                (LPSTR) pDataIn,    // property name
                pdwTypeOut,
                ppDataOut );
}


//
//  End of rpccall.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rpcw2k.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    w2krpc.c

Abstract:

    Domain Name System (DNS) Server

    Frozen RPC routines for answering queries from W2K clients.

Author:

    Jeff Westhead (jwesth)      October, 2000

Revision History:

--*/


#include "dnssrv.h"


#define MAX_RPC_ZONE_COUNT_DEFAULT  (0x10000)   //  copied from zonerpc.c


//
//  Internal functions
//



VOID
freeRpcServerInfoW2K(
    IN OUT  PDNS_RPC_SERVER_INFO_W2K    pServerInfo
    )
/*++

Routine Description:

    Deep free of DNS_RPC_SERVER_INFO structure.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( !pServerInfo )
    {
        return;
    }

    //
    //  free substructures
    //      - server name
    //      - server IP address array
    //      - listen address array
    //      - forwarders array
    //  then server info itself
    //

    if ( pServerInfo->pszServerName )
    {
        MIDL_user_free( pServerInfo->pszServerName );
    }
    if ( pServerInfo->aipServerAddrs )
    {
        MIDL_user_free( pServerInfo->aipServerAddrs );
    }
    if ( pServerInfo->aipListenAddrs )
    {
        MIDL_user_free( pServerInfo->aipListenAddrs );
    }
    if ( pServerInfo->aipForwarders )
    {
        MIDL_user_free( pServerInfo->aipForwarders );
    }
    if ( pServerInfo->pszDsContainer )
    {
        MIDL_user_free( pServerInfo->pszDsContainer );
    }
    MIDL_user_free( pServerInfo );
}



VOID
freeRpcZoneInfoW2K(
    IN OUT  PDNS_RPC_ZONE_INFO_W2K      pZoneInfo
    )
/*++

Routine Description:

    Deep free of DNS_RPC_ZONE_INFO structure.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( !pZoneInfo )
    {
        return;
    }

    //
    //  free substructures
    //      - name string
    //      - data file string
    //      - secondary IP array
    //      - WINS server array
    //  then zone info itself
    //

    MIDL_user_free( pZoneInfo->pszZoneName );
    MIDL_user_free( pZoneInfo->pszDataFile );
    MIDL_user_free( pZoneInfo->aipMasters );
    MIDL_user_free( pZoneInfo->aipSecondaries );
    MIDL_user_free( pZoneInfo->aipNotify );
    MIDL_user_free( pZoneInfo->aipScavengeServers );
    MIDL_user_free( pZoneInfo );
}



PDNS_RPC_ZONE_INFO_W2K
allocateRpcZoneInfoW2K(
    IN      PZONE_INFO  pZone
    )
/*++

Routine Description:

    Create RPC zone info to return to admin client.

Arguments:

    pZone -- zone

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_ZONE_INFO_W2K      pzoneInfo;

    pzoneInfo = MIDL_user_allocate_zero( sizeof(DNS_RPC_ZONE_INFO_W2K) );
    if ( !pzoneInfo )
    {
        goto done_failed;
    }

    //
    //  fill in fixed fields
    //

    pzoneInfo->dwZoneType           = pZone->fZoneType;
    pzoneInfo->fReverse             = pZone->fReverse;
    pzoneInfo->fAutoCreated         = pZone->fAutoCreated;
    pzoneInfo->fAllowUpdate         = pZone->fAllowUpdate;
    pzoneInfo->fUseDatabase         = pZone->fDsIntegrated;
    pzoneInfo->fSecureSecondaries   = pZone->fSecureSecondaries;
    pzoneInfo->fNotifyLevel         = pZone->fNotifyLevel;

    pzoneInfo->fPaused              = IS_ZONE_PAUSED(pZone);
    pzoneInfo->fShutdown            = IS_ZONE_SHUTDOWN(pZone);
    pzoneInfo->fUseWins             = IS_ZONE_WINS(pZone);
    pzoneInfo->fUseNbstat           = IS_ZONE_NBSTAT(pZone);

    pzoneInfo->fAging               = pZone->bAging;
    pzoneInfo->dwNoRefreshInterval  = pZone->dwNoRefreshInterval;
    pzoneInfo->dwRefreshInterval    = pZone->dwRefreshInterval;
    pzoneInfo->dwAvailForScavengeTime =
                    pZone->dwAgingEnabledTime + pZone->dwRefreshInterval;

    //
    //  fill in zone name
    //

    if ( ! RpcUtil_CopyStringToRpcBuffer(
                &pzoneInfo->pszZoneName,
                pZone->pszZoneName ) )
    {
        goto done_failed;
    }

    //
    //  database filename
    //

#ifdef FILE_KEPT_WIDE
    if ( ! RpcUtil_CopyStringToRpcBufferEx(
                &pzoneInfo->pszDataFile,
                pZone->pszDataFile,
                TRUE,       // unicode in
                FALSE       // UTF8 out
                ) )
    {
        goto done_failed;
    }
#else
    if ( ! RpcUtil_CopyStringToRpcBuffer(
                &pzoneInfo->pszDataFile,
                pZone->pszDataFile ) )
    {
        goto done_failed;
    }
#endif

    //
    //  master list
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipMasters,
                pZone->aipMasters ) )
    {
        goto done_failed;
    }

    //
    //  secondary and notify lists
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipSecondaries,
                pZone->aipSecondaries ) )
    {
        goto done_failed;
    }
    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipNotify,
                pZone->aipNotify ) )
    {
        goto done_failed;
    }

    //
    //  scavenging servers
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipScavengeServers,
                pZone->aipScavengeServers ) )
    {
        goto done_failed;
    }

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneInfo_W2K(
            "RPC zone info leaving allocateRpcZoneInfo():\n",
            pzoneInfo );
    }
    return( pzoneInfo );

done_failed:

    //  free newly allocated info block

    freeRpcZoneInfoW2K( pzoneInfo );
    return( NULL );
}



PDNS_RPC_ZONE_W2K
allocateRpcZoneW2K(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Allocate \ create RPC zone struct for zone.

Arguments:

    pZone -- zone to create RPC zone struct for

Return Value:

    RPC zone struct.
    NULL on allocation failure.

--*/
{
    PDNS_RPC_ZONE_W2K       prpcZone;

    DNS_DEBUG( RPC2, ("allocateRpcZoneW2K( %s )\n", pZone->pszZoneName ));

    //  allocate and attach zone

    prpcZone = (PDNS_RPC_ZONE_W2K) MIDL_user_allocate( sizeof(DNS_RPC_ZONE_W2K) );
    if ( !prpcZone )
    {
        return( NULL );
    }

    //  copy zone name

    prpcZone->pszZoneName = Dns_StringCopyAllocate_W(
                                    pZone->pwsZoneName,
                                    0 );
    if ( !prpcZone->pszZoneName )
    {
        MIDL_user_free( prpcZone );
        return( NULL );
    }

    //  set type and flags

    prpcZone->ZoneType = (UCHAR) pZone->fZoneType;
    prpcZone->Version  = DNS_RPC_VERSION;

    *(PDWORD) &prpcZone->Flags = 0;

    if ( pZone->fPaused )
    {
        prpcZone->Flags.Paused = TRUE;
    }
    if ( pZone->fShutdown )
    {
        prpcZone->Flags.Shutdown = TRUE;
    }
    if ( pZone->fReverse )
    {
        prpcZone->Flags.Reverse = TRUE;
    }
    if ( pZone->fAutoCreated )
    {
        prpcZone->Flags.AutoCreated = TRUE;
    }
    if ( pZone->fDsIntegrated )
    {
        prpcZone->Flags.DsIntegrated = TRUE;
    }
    if ( pZone->bAging )
    {
        prpcZone->Flags.Aging = TRUE;
    }

    //  two bits reserved for update

    prpcZone->Flags.Update = pZone->fAllowUpdate;


    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcZone_W2K(
            "New zone for RPC: ",
            prpcZone );
    }
    return( prpcZone );
}   //  allocateRpcZoneW2K



VOID
freeZoneListW2K(
    IN OUT  PDNS_RPC_ZONE_LIST_W2K      pZoneList
    )
/*++

Routine Description:

    Deep free of list of DNS_RPC_ZONE structures.

Arguments:

    pZoneList -- ptr RPC_ZONE_LIST structure to free

Return Value:

    None

--*/
{
    DWORD               i;
    PDNS_RPC_ZONE_W2K   pzone;

    for( i=0; i< pZoneList->dwZoneCount; i++ )
    {
        //  zone name is only sub-structure

        pzone = pZoneList->ZoneArray[i];
        MIDL_user_free( pzone->pszZoneName );
        MIDL_user_free( pzone );
    }

    MIDL_user_free( pZoneList );
}   //  freeZoneListW2K


//
//  External functions
//



DNS_STATUS
W2KRpc_GetServerInfo(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get server info.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_SERVER_INFO_W2K    pinfo;

    DNS_DEBUG( RPC, (
        "W2KRpc_GetServerInfo( dwClientVersion=0x%lX)\n",
        dwClientVersion ));

    //
    //  allocate server info buffer
    //

    pinfo = MIDL_user_allocate_zero( sizeof(DNS_RPC_SERVER_INFO_W2K) );
    if ( !pinfo )
    {
        DNS_PRINT(( "ERROR:  unable to allocate SERVER_INFO block.\n" ));
        goto DoneFailed;
    }

    //
    //  fill in fixed fields
    //

    pinfo->dwVersion                = SrvCfg_dwVersion;
    pinfo->dwRpcProtocol            = SrvCfg_dwRpcProtocol;
    pinfo->dwLogLevel               = SrvCfg_dwLogLevel;
    pinfo->dwDebugLevel             = SrvCfg_dwDebugLevel;
    pinfo->dwNameCheckFlag          = SrvCfg_dwNameCheckFlag;
    pinfo->cAddressAnswerLimit      = SrvCfg_cAddressAnswerLimit;
    pinfo->dwRecursionRetry         = SrvCfg_dwRecursionRetry;
    pinfo->dwRecursionTimeout       = SrvCfg_dwRecursionTimeout;
    pinfo->dwForwardTimeout         = SrvCfg_dwForwardTimeout;
    pinfo->dwMaxCacheTtl            = SrvCfg_dwMaxCacheTtl;
    pinfo->dwDsPollingInterval      = SrvCfg_dwDsPollingInterval;
    pinfo->dwScavengingInterval     = SrvCfg_dwScavengingInterval;
    pinfo->dwDefaultRefreshInterval     = SrvCfg_dwDefaultRefreshInterval;
    pinfo->dwDefaultNoRefreshInterval   = SrvCfg_dwDefaultNoRefreshInterval;

    //  boolean flags

    pinfo->fBootMethod              = (BOOLEAN) SrvCfg_fBootMethod;
    pinfo->fAdminConfigured         = (BOOLEAN) SrvCfg_fAdminConfigured;
    pinfo->fAllowUpdate             = (BOOLEAN) SrvCfg_fAllowUpdate;
    pinfo->fAutoReverseZones        = (BOOLEAN) ! SrvCfg_fNoAutoReverseZones;
    pinfo->fAutoCacheUpdate         = (BOOLEAN) SrvCfg_fAutoCacheUpdate;

    pinfo->fSlave                   = (BOOLEAN) SrvCfg_fSlave;
    pinfo->fForwardDelegations      = (BOOLEAN) SrvCfg_fForwardDelegations;
    pinfo->fNoRecursion             = (BOOLEAN) SrvCfg_fNoRecursion;
    pinfo->fSecureResponses         = (BOOLEAN) SrvCfg_fSecureResponses;
    pinfo->fRoundRobin              = (BOOLEAN) SrvCfg_fRoundRobin;
    pinfo->fLocalNetPriority        = (BOOLEAN) SrvCfg_fLocalNetPriority;
    pinfo->fBindSecondaries         = (BOOLEAN) SrvCfg_fBindSecondaries;
    pinfo->fWriteAuthorityNs        = (BOOLEAN) SrvCfg_fWriteAuthorityNs;

    pinfo->fStrictFileParsing       = (BOOLEAN) SrvCfg_fStrictFileParsing;
    pinfo->fLooseWildcarding        = (BOOLEAN) SrvCfg_fLooseWildcarding;
    pinfo->fDefaultAgingState       = (BOOLEAN) SrvCfg_fDefaultAgingState;


    //  DS available

    //pinfo->fDsAvailable = SrvCfg_fDsAvailable;
    pinfo->fDsAvailable     = (BOOLEAN) Ds_IsDsServer();

    //
    //  server name
    //

    if ( ! RpcUtil_CopyStringToRpcBuffer(
                &pinfo->pszServerName,
                SrvCfg_pszServerName ) )
    {
        DNS_PRINT(( "ERROR:  unable to copy SrvCfg_pszServerName.\n" ));
        goto DoneFailed;
    }

    //
    //  path to DNS container in DS
    //  unicode since Marco will build unicode LDAP paths
    //

    if ( g_pwszDnsContainerDN )
    {
        pinfo->pszDsContainer = (LPWSTR) Dns_StringCopyAllocate(
                                            (LPSTR) g_pwszDnsContainerDN,
                                            0,
                                            DnsCharSetUnicode,   // unicode in
                                            DnsCharSetUnicode    // unicode out
                                            );
        if ( ! pinfo->pszDsContainer )
        {
            DNS_PRINT(( "ERROR:  unable to copy g_pszDsDnsContainer.\n" ));
            goto DoneFailed;
        }
    }

    //
    //  server IP address list
    //  listening IP address list
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipServerAddrs,
                g_ServerIp4Addrs ) )
    {
        goto DoneFailed;
    }

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipListenAddrs,
                SrvCfg_aipListenAddrs ) )
    {
        goto DoneFailed;
    }

    //
    //  Forwarders list
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipForwarders,
                SrvCfg_aipForwarders ) )
    {
        goto DoneFailed;
    }

    //
    //  set ptr
    //

    *(PDNS_RPC_SERVER_INFO_W2K *)ppData = pinfo;
    *pdwTypeId = DNSSRV_TYPEID_SERVER_INFO_W2K;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcServerInfo_W2K(
            "GetServerInfo return block",
            pinfo );
    }
    return( ERROR_SUCCESS );

DoneFailed:

    //  free newly allocated info block

    if ( pinfo )
    {
        freeRpcServerInfoW2K( pinfo );
    }
    return( DNS_ERROR_NO_MEMORY );
}


DNS_STATUS
W2KRpc_GetZoneInfo(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get zone info.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_ZONE_INFO_W2K      pinfo;

    DNS_DEBUG( RPC, (
        "W2KRpc_GetZoneInfo()\n"
        "  client ver       = 0x%08lX"
        "  zone name        = %s\n",
        dwClientVersion,
        pZone->pszZoneName ));

    //
    //  allocate\create zone info
    //

    pinfo = allocateRpcZoneInfoW2K( pZone );
    if ( !pinfo )
    {
        DNS_PRINT(( "ERROR: unable to allocate DNS_RPC_ZONE_INFO block.\n" ));
        goto DoneFailed;
    }

    //  set return ptrs

    *(PDNS_RPC_ZONE_INFO_W2K *)ppData = pinfo;
    *pdwTypeId = DNSSRV_TYPEID_ZONE_INFO_W2K;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneInfo_W2K(
            "GetZoneInfo return block (W2K)",
            pinfo );
    }
    return( ERROR_SUCCESS );

DoneFailed:

    //  free newly allocated info block

    return( DNS_ERROR_NO_MEMORY );
}



DNS_STATUS
W2KRpc_EnumZones(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Enumerate zones.

    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

    None

Return Value:

    None

--*/
{
    PZONE_INFO                  pzone = NULL;
    DWORD                       count = 0;
    PDNS_RPC_ZONE_W2K           prpcZone;
    DNS_STATUS                  status;
    PDNS_RPC_ZONE_LIST_W2K      pzoneList;
    DNS_RPC_ENUM_ZONES_FILTER   filter = { 0 };

    DNS_DEBUG( RPC, (
        "W2KRpc_EnumZones():\n"
        "\tFilter = %08lx\n",
        (ULONG_PTR) pDataIn ));

    filter.dwFilter = ( DWORD ) ( ULONG_PTR ) pDataIn;

    //
    //  allocate zone enumeration block
    //  by default allocate space for 64k zones, if go over this we do
    //  a huge reallocation
    //

    pzoneList = (PDNS_RPC_ZONE_LIST_W2K)
                    MIDL_user_allocate(
                        sizeof(DNS_RPC_ZONE_LIST_W2K) +
                        sizeof(PDNS_RPC_ZONE_W2K) * MAX_RPC_ZONE_COUNT_DEFAULT );
    IF_NOMEM( !pzoneList )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    //
    //  add all zones that pass filter
    //

    while ( pzone = Zone_ListGetNextZoneMatchingFilter( pzone, &filter ) )
    {
        //  create RPC zone struct for zone
        //  add to list, keep count

        prpcZone = allocateRpcZoneW2K( pzone );
        IF_NOMEM( !prpcZone )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }
        pzoneList->ZoneArray[count] = prpcZone;
        count++;

        //  check against max count
        //
        //  DEVNOTE: reallocate if more than 64K zones

        if ( count >= MAX_RPC_ZONE_COUNT_DEFAULT )
        {
            break;
        }
    }

    //  set return count
    //  set returned type
    //  return enumeration

    pzoneList->dwZoneCount = count;

    *( PDNS_RPC_ZONE_LIST_W2K * ) ppDataOut = pzoneList;
    *pdwTypeOut = DNSSRV_TYPEID_ZONE_LIST_W2K;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneList_W2K(
            "Leaving W2KRpc_EnumZones() zone list sent:",
            pzoneList );
    }
    return( ERROR_SUCCESS );

Failed:

    DNS_PRINT((
        "W2KRpc_EnumZones(): failed\n"
        "\tstatus       = %p\n",
        status ));

    pzoneList->dwZoneCount = count;
    freeZoneListW2K( pzoneList );
    return( status );
}   //  W2KRpc_EnumZones


//
//  End of w2krpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rrfunc.h ===
/*++

Copyright(c) 1996-1999 Microsoft Corporation

Module Name:

    rrfunc.h

Abstract:

    Domain Name System (DNS) Server

    Resource record function headers.

    Used separate file as record.h contains record type definition
    required by other headers and loaded early.  These prototypes
    may contain other types and hence should be defined later.

Author:

    Jim Gilroy      Decemeber 1996

Revision History:

--*/


#ifndef _RRFUNC_INCLUDED_
#define _RRFUNC_INCLUDED_


//
//  Record type specific helper utilities
//

DNS_STATUS
WksBuildRecord(
    OUT     PDB_RECORD *    ppRR,
    IN      PDNS_ADDR       ipAddress,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );



//
//  Read records from file (rrload.c)
//

DNS_STATUS
AFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
NsFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
PtrFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
SoaFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
MxFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
MinfoFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
TxtFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
WksFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
AaaaFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
SrvFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
WinsFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
NbstatFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );



//
//  Read records from wire (rrwire.c)
//

PDB_RECORD
AWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
CopyWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
PtrWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
MxWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
SoaWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
MinfoWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
SrvWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
WinsWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
NbstatWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );




//
//  Read records from RPC buffer (rradmin.c)
//

DNS_STATUS
ARpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
NsRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
PtrRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
SoaRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
MxRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
MinfoRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
TxtRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
WksRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
AaaaRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
SrvRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
WinsRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
NbstatRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );



#endif // _RRFUNC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rrflat.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    rrflat.c

Abstract:

    Domain Name System (DNS) Server

    Routines to read flat DNS records, used by admin RPC and DS,
    into database.

Author:

    Jim Gilroy (jamesg)     Decemeber 1996

Revision History:

--*/


#include "dnssrv.h"




//
//  Utils for building records from RPC buffer.
//

DNS_STATUS
tokenizeCountedStringsInBuffer(
    IN      PDNS_RPC_STRING pString,
    IN      WORD            wLength,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Parse buffer with data in counted string format into tokens.

    Primary purpose is to tokenize any RPC buffers with all the data in
    this format, to allow processing by standard file load functions.

Arguments:

    pString - ptr to first counted string in buffer

    wLength - length of buffer to tokenize

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PCHAR   pch;
    DWORD   tokenLength;
    PCHAR   pchend = (PCHAR)pString + wLength;
    DWORD   argc = 0;
    PTOKEN  argv = pParseInfo->Argv;

    DNS_DEBUG( RPC2, (
        "Tokenizing counted string buffer:\n"
        "    length   = %d\n"
        "    start    = %p\n"
        "    stop     = %p\n"
        "    first strlen = %d\n"
        "    first string = %.*s\n",
        wLength,
        pString,
        pchend,
        pString->cchNameLength,
        pString->cchNameLength,
        pString->achName ));

    //
    //  tokenize all counted strings within specified length
    //

    while ( ( PBYTE ) pString < pchend )
    {
        if ( argc >= MAX_TOKENS )
        {
            return DNS_ERROR_INVALID_DATA;
        }
        
        //  catches string extending beyond boundary or record,
        //  hence catches any possibility of overwrite

        tokenLength = pString->cchNameLength;
        pch = (PCHAR)pString + tokenLength;
        if ( pch >= pchend )
        {
            return DNS_ERROR_INVALID_DATA;
        }

        //  correct token length if last char NULL termination
        //      special case NULL string

        if ( *pch == 0 && tokenLength != 0 )
        {
            tokenLength--;
        }

        //  save this token

        argv[argc].pchToken = (PCHAR) pString->achName;
        argv[argc].cchLength = tokenLength;
        argc++;

        DNS_DEBUG( RPC2, (
            "Tokenized RPC string len=%d <%.*s>\n",
            tokenLength,
            tokenLength,
            (PCHAR) pString->achName ));

        //  next string
        //      -- pch sitting on last char in previous string

        pString = (PDNS_RPC_STRING) ++pch;
    }

    pParseInfo->Argc = argc;

#if DBG
    IF_DEBUG( RPC2 )
    {
        DWORD i;

        DnsPrintf(
            "Tokenized %d strings in RPC buffer\n",
            argc );

        for( i=0; i<argc; i++ )
        {
            DnsPrintf(
                "    token[%d] = %.*s (len=%d)\n",
                i,
                argv[i].cchLength,
                argv[i].pchToken,
                argv[i].cchLength );
        }
    }
#endif

    return ERROR_SUCCESS;
}




//
//  Type specific functions for building RR from RPC buffer
//

DNS_STATUS
AFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process A record.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD  prr;

    //  validate record length

    if ( pRecord->wDataLength != sizeof( IP_ADDRESS ) )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    //  allocate record

    prr = RR_Allocate( SIZEOF_IP_ADDRESS );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //  copy IP address

    prr->Data.A.ipAddress = pRecord->Data.A.ipAddress;

    return ERROR_SUCCESS;
}



DNS_STATUS
PtrFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process PTR compatible record.
    Includes: PTR, NS, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           status;
    DWORD           length;
    COUNT_NAME      nameTarget;

    //
    //  all these types are indirection to another database node
    //      named in plookName1
    //

    prpcName = & pRecord->Data.PTR.nameNode;
    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    length = Name_ConvertRpcNameToCountName(
                    & nameTarget,
                    prpcName );
    if ( ! length )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( ( WORD ) length );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //
    //  copy in name
    //

    status = Name_CopyCountNameToDbaseName(
                    &prr->Data.PTR.nameTarget,
                    &nameTarget );

    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
MxFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process MX compatible RR.

Arguments:

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           status;
    DWORD           length;
    COUNT_NAME      nameExchange;

    //
    //  MX mail exchange
    //  RT intermediate exchange
    //  AFSDB hostname
    //

    prpcName = & pRecord->Data.MX.nameExchange;
    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    length = Name_ConvertRpcNameToCountName(
                    &nameExchange,
                    prpcName );
    if ( ! length )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_MX_FIXED_DATA + length) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //
    //  copy fixed field
    //  MX preference
    //  RT preference
    //  AFSDB subtype
    //

    prr->Data.MX.wPreference = htons( pRecord->Data.MX.wPreference );

    //
    //  copy in name
    //

    status = Name_CopyCountNameToDbaseName(
                    & prr->Data.MX.nameExchange,
                    & nameExchange );

    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
SoaFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process SOA RR.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           status;
    COUNT_NAME      namePrimary;
    COUNT_NAME      nameAdmin;
    DWORD           length1;
    DWORD           length2;
    PDB_NAME        pname;

    //
    //  Primary name server
    //

    prpcName = &pRecord->Data.SOA.namePrimaryServer;

    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }
    length1 = Name_ConvertRpcNameToCountName(
                    & namePrimary,
                    prpcName );
    if ( ! length1 )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    //
    //  Zone admin
    //

    prpcName = DNS_GET_NEXT_NAME( prpcName );
    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        status = DNS_ERROR_RECORD_FORMAT;
    }
    length2 = Name_ConvertRpcNameToCountName(
                    & nameAdmin,
                    prpcName );
    if ( ! length2 )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_SOA_FIXED_DATA + length1 + length2) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //
    //  copy / byte swap fixed SOA fields back into net order
    //

    prr->Data.SOA.dwSerialNo    = htonl( pRecord->Data.SOA.dwSerialNo );
    prr->Data.SOA.dwRefresh     = htonl( pRecord->Data.SOA.dwRefresh );
    prr->Data.SOA.dwRetry       = htonl( pRecord->Data.SOA.dwRetry );
    prr->Data.SOA.dwExpire      = htonl( pRecord->Data.SOA.dwExpire );
    prr->Data.SOA.dwMinimumTtl  = htonl( pRecord->Data.SOA.dwMinimumTtl );

    //
    //  copy in names
    //

    pname = &prr->Data.SOA.namePrimaryServer;

    Name_CopyCountNameToDbaseName(
        pname,
        & namePrimary );

    pname = (PDB_NAME) Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        & nameAdmin );

    return ERROR_SUCCESS;
}



DNS_STATUS
KeyFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process KEY RR.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;

    prr = RR_Allocate( pRecord->wDataLength );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    prr->Data.KEY.wFlags        = htons( pRecord->Data.KEY.wFlags );
    prr->Data.KEY.chProtocol    = pRecord->Data.KEY.chProtocol;
    prr->Data.KEY.chAlgorithm   = pRecord->Data.KEY.chAlgorithm;

    RtlCopyMemory(
        prr->Data.KEY.Key,
        pRecord->Data.Key.bKey,
        pRecord->wDataLength -
            ( pRecord->Data.Key.bKey - ( PBYTE ) &pRecord->Data ) );

    return ERROR_SUCCESS;
}   //  KeyFlatRead



DNS_STATUS
SigFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process SIG RR.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           nameLength;
    DWORD           sigLength;
    COUNT_NAME      nameSigner;
    PBYTE           psigSrc;
    PBYTE           psigDest;

    prpcName = &pRecord->Data.SIG.nameSigner;
    if ( !DNS_IS_NAME_IN_RECORD( pRecord, prpcName ) ||
        ( nameLength = Name_ConvertRpcNameToCountName(
                            &nameSigner,
                            prpcName ) ) == 0 )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    psigSrc = ( PBYTE ) DNS_GET_NEXT_NAME( prpcName );
    sigLength = ( DWORD )
        ( pRecord->wDataLength - ( psigSrc - ( PBYTE ) &pRecord->Data ) );

    prr = RR_Allocate( ( WORD ) (
                SIZEOF_SIG_FIXED_DATA +
                nameLength +
                sigLength ) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    prr->Data.SIG.wTypeCovered      = htons( pRecord->Data.SIG.wTypeCovered );
    prr->Data.SIG.chAlgorithm       = pRecord->Data.SIG.chAlgorithm;
    prr->Data.SIG.chLabelCount      = pRecord->Data.SIG.chLabelCount;
    prr->Data.SIG.dwOriginalTtl     = htonl( pRecord->Data.SIG.dwOriginalTtl );
    prr->Data.SIG.dwSigExpiration   = htonl( pRecord->Data.SIG.dwSigExpiration );
    prr->Data.SIG.dwSigInception    = htonl( pRecord->Data.SIG.dwSigInception );
    prr->Data.SIG.wKeyTag           = htons( pRecord->Data.SIG.wKeyTag );

    Name_CopyCountNameToDbaseName(
        &prr->Data.SIG.nameSigner,
        &nameSigner );
    psigDest = ( PBYTE ) &prr->Data.SIG.nameSigner +
                DBASE_NAME_SIZE( &prr->Data.SIG.nameSigner );

    RtlCopyMemory( psigDest, psigSrc, sigLength );

    return ERROR_SUCCESS;
}   //  SigFlatRead



DNS_STATUS
NxtFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process NXT RR.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      rc = ERROR_SUCCESS;
    PDB_RECORD      prr = NULL;
    PDNS_RPC_NAME   prpcName;
    DWORD           nameLength;
    COUNT_NAME      nameNext;
    INT             typeIdx;
    WORD            numTypeWords = pRecord->Data.Nxt.wNumTypeWords;

    ASSERT( numTypeWords > 0 && numTypeWords < 33 );

    //
    //  Copy out the next name.
    //
    
    prpcName = ( PDNS_RPC_NAME ) (
        ( PBYTE ) &pRecord->Data +
        ( numTypeWords + 1 ) * sizeof( WORD ) );
    if ( !DNS_IS_NAME_IN_RECORD( pRecord, prpcName ) ||
        ( nameLength = Name_ConvertRpcNameToCountName(
                            &nameNext,
                            prpcName ) ) == 0 )
    {
        rc = DNS_ERROR_RECORD_FORMAT;
        goto Failure;
    }

    //
    //  Allocate the RR.
    //

    prr = RR_Allocate( ( WORD ) ( DNS_MAX_TYPE_BITMAP_LENGTH + nameLength ) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    Name_CopyCountNameToDbaseName(
        &prr->Data.NXT.nameNext,
        &nameNext );

    //
    //  Handle the array of types covered.
    //  

    RtlZeroMemory(
        prr->Data.NXT.bTypeBitMap,
        sizeof( prr->Data.NXT.bTypeBitMap ) );

    //
    //  Loop through the type WORDs, turning on the appropriate bit
    //  in the type bitmap array. Some types are not allowed, such as
    //  the compound types (eg. MAILA), the transfer types (eg. AXFR), 
    //  and the WINS types.
    //

    for ( typeIdx = 0; typeIdx < numTypeWords; ++typeIdx )
    {
        WORD    wType = pRecord->Data.Nxt.wTypeWords[ typeIdx ];

        if ( wType > DNS_MAX_TYPE_BITMAP_LENGTH * 8 )
        {
            DNS_DEBUG( RPC, (
                "NxtFlatRead: rejecting NXT RR with type out of range (%d)\n",
                ( int ) wType ));
            rc = DNS_ERROR_RECORD_FORMAT;
            goto Failure;
        }
        prr->Data.NXT.bTypeBitMap[ wType / 8 ] |= 1 << wType % 8;
    }

    return ERROR_SUCCESS;

    Failure:

    if ( prr )
    {
        RR_Free( prr );
    }
    return rc;
}   //  NxtFlatRead



DNS_STATUS
TxtFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process Text (TXT) RR.

Arguments:

    pRR - NULL ptr to database record, since this record type has variable
        length, this routine allocates its own record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD           status;

    IF_DEBUG( RPC2 )
    {
        DNS_PRINT((
            "Building string record:\n"
            "    type         = 0x%x\n"
            "    pRecord dlen = %d\n"
            "    pRecord data = %p\n",
            pRecord->wType,
            pRecord->wDataLength,
            &pRecord->Data ));
    }

    //
    //  tokenize record data in buffer
    //

    status = tokenizeCountedStringsInBuffer(
                & pRecord->Data.Txt.stringData,
                pRecord->wDataLength,
                pParseInfo );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    #if 0
    //
    //  This code triggered bug 53180 to be filed - removing it since 
    //  hopefully Marco's bug has long since vanished into pre-history.
    //

    //  protect against last TXT string empty
    //  this is an admin tool bug, which Marco probably doesn't
    //      have time to fix;  can still intentionally send
    //      last string empty by sending another bogus string

    if ( pRecord->wType == DNS_TYPE_TEXT &&
        pParseInfo->Argc > 1 &&
        pParseInfo->Argv[ (pParseInfo->Argc)-1 ].cchLength == 0 )
    {
        DNS_DEBUG( RPC, (
            "WARNING:  Last string in TXT RPC record is empty string\n"
            "    assuming this admin tool error and removing from list\n" ));
        pParseInfo->Argc--;
    }
    #endif

    //
    //  give tokens to file load routine to
    //      - it allocates record and returns it in pParseInfo
    //

    status = TxtFileRead(
                NULL,
                pParseInfo->Argc,
                pParseInfo->Argv,
                pParseInfo );

    ASSERT( pParseInfo->pRR || status != ERROR_SUCCESS );

    return status;
}



DNS_STATUS
MinfoFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process MINFO or RP record.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           status;
    COUNT_NAME      name1;
    COUNT_NAME      name2;
    DWORD           length1;
    DWORD           length2;
    PDB_NAME        pname;

    //
    //  MINFO   <responsible mailbox> <errors to mailbox>
    //  RP      <responsible mailbox> <text location>
    //

    prpcName = &pRecord->Data.MINFO.nameMailBox;

    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }
    length1 = Name_ConvertRpcNameToCountName(
                    & name1,
                    prpcName );
    if ( ! length1 )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    //  second name

    prpcName = DNS_GET_NEXT_NAME( prpcName );
    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        status = DNS_ERROR_RECORD_FORMAT;
    }
    length2 = Name_ConvertRpcNameToCountName(
                    & name2,
                    prpcName );
    if ( ! length2 )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(length1 + length2) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //
    //  copy in names
    //

    pname = &prr->Data.MINFO.nameMailbox;

    Name_CopyCountNameToDbaseName(
        pname,
        & name1 );

    pname = (PDB_NAME) Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        & name2 );

    return ERROR_SUCCESS;
}



DNS_STATUS
WksFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process WKS record.

Arguments:

    pRR - NULL ptr to database record, since this record type has variable
        length, this routine allocates its own record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PCHAR           pch;
    PCHAR           pchstop;
    PCHAR           pszservice;
    UCHAR           ch;
    WORD            port;
    WORD            maxPort = 0;
    USHORT          byte;
    UCHAR           bit;
    PDNS_RPC_STRING pstring;
    BYTE            bitmaskBytes[ WKS_MAX_BITMASK_LENGTH ];
    WORD            wbitmaskLength;
    CHAR            szservice[ MAX_PATH ];

    struct servent * pServent;
    struct protoent * pProtoent;


    //
    //  get protocol name -- need for services lookup
    //

    pProtoent = getprotobynumber( (INT)pRecord->Data.WKS.chProtocol );
    if ( ! pProtoent )
    {
        return DNS_ERROR_INVALID_DATA;
    }

    //
    //  generate bitmask from string of space separated services
    //

    pstring = (PDNS_RPC_STRING) pRecord->Data.WKS.bBitMask;
    // pstring = pRecord->Data.WKS.stringServices;

    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, pstring) )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }
    pch = pstring->achName;
    pchstop = pch + pstring->cchNameLength;

    DNS_DEBUG( RPC2, (
        "WKS services string %.*s (len=%d)\n",
        pstring->cchNameLength,
        pch,
        pstring->cchNameLength ));

    //  clear bit mask

    RtlZeroMemory(
        bitmaskBytes,
        WKS_MAX_BITMASK_LENGTH );

    //
    //  run through service name list, find port for each service
    //

    while ( pch < pchstop )
    {
        //  strip any leading white space

        if ( *pch == ' ' )
        {
            pch++;
            continue;
        }
        if ( *pch == 0 )
        {
            ASSERT( pch+1 == pchstop );
            break;
        }

        //  found service name start
        //      - if space terminated make NULL terminated

        pszservice = szservice;

        while ( pch < pchstop )
        {
            ch = *pch++;
            if ( ch == 0 )
            {
                break;
            }
            if ( ch == ' ' )
            {
                break;
            }
            *pszservice++ = ch;
        }
        *pszservice = 0;

        //
        //  get port
        //      - verify port supported
        //      - save max port for determining RR length
        //

        pServent = getservbyname(
                        szservice,
                        pProtoent->p_name );
        if ( ! pServent )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  bogus WKS service %s\n",
                szservice ));
            return DNS_ERROR_INVALID_DATA;
        }
        port = ntohs( pServent->s_port );

        if ( port > WKS_MAX_PORT )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Encountered well known service (%s) with port (%d) > %d\n"
                "Need new WKS parsing code to support this port\n",
                pszservice,
                port,
                WKS_MAX_PORT
                ));
            return DNS_ERROR_INVALID_DATA;
        }
        else if ( port > maxPort )
        {
            maxPort = port;
        }

        //
        //  set port bit in mask
        //
        //  note that bitmask is just flat run of bits
        //  hence lowest port in byte, corresponds to highest bit
        //  highest port in byte, corresponds to lowest bit and
        //  requires no shift

        byte = port / 8;
        bit  = port % 8;

        bitmaskBytes[ byte ] |=  1 << (7-bit);
    }

    //  if no services, return error

    if ( maxPort == 0 )
    {
        return DNS_ERROR_INVALID_DATA;
    }

    //
    //  build the RR
    //      - calculate required data length
    //      - allocate and clear data area
    //

    wbitmaskLength = maxPort/8 + 1;

    //  allocate database record

    prr = RR_Allocate( (WORD)(SIZEOF_WKS_FIXED_DATA + wbitmaskLength) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;
    prr->wType = DNS_TYPE_WKS;

    //  server IP address

    prr->Data.WKS.ipAddress = pRecord->Data.WKS.ipAddress;

    //  set protocol

    prr->Data.WKS.chProtocol = (UCHAR) pProtoent->p_proto;

    //  copy bitmask, only through max port's byte

    RtlCopyMemory(
        prr->Data.WKS.bBitMask,
        bitmaskBytes,
        wbitmaskLength );

    return ERROR_SUCCESS;
}



DNS_STATUS
AaaaFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process AAAA record.

Arguments:

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;

    //
    //  AAAA in standard wire format
    //

    if ( pRecord->wDataLength != sizeof(IP6_ADDRESS) )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    //  allocate record

    prr = RR_Allocate( sizeof(IP6_ADDRESS) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    RtlCopyMemory(
        & prr->Data.AAAA.Ip6Addr,
        ( UNALIGNED BYTE * ) & pRecord->Data.AAAA.ipv6Address,
        sizeof(IP6_ADDRESS) );

    return ERROR_SUCCESS;
}



DNS_STATUS
SrvFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process SRV compatible RR.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           status;
    DWORD           length;
    COUNT_NAME      nameTarget;

    //
    //  SRV target host
    //

    prpcName = & pRecord->Data.SRV.nameTarget;
    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    length = Name_ConvertRpcNameToCountName(
                    & nameTarget,
                    prpcName );
    if ( ! length )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_SRV_FIXED_DATA + length) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //
    //  copy fixed fields
    //

    prr->Data.SRV.wPriority = htons( pRecord->Data.SRV.wPriority );
    prr->Data.SRV.wWeight   = htons( pRecord->Data.SRV.wWeight );
    prr->Data.SRV.wPort     = htons( pRecord->Data.SRV.wPort );

    //
    //  copy in name
    //

    Name_CopyCountNameToDbaseName(
            & prr->Data.SRV.nameTarget,
            & nameTarget );

    return ERROR_SUCCESS;
}



DNS_STATUS
AtmaFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process ATMA record.

Arguments:

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;

    //
    //  ATMA comes in standard wire format
    //
    //  DEVNOTE: should validate allowable IDs and
    //      length (40 hex, 20 bytes) for AESA type
    //

    //  allocate record

    prr = RR_Allocate( pRecord->wDataLength );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    RtlCopyMemory(
        & prr->Data,
        & pRecord->Data,
        pRecord->wDataLength );

    return ERROR_SUCCESS;
}



DNS_STATUS
WinsFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Read WINS record from RPC buffer.

Arguments:

    pRR -- NULL ptr to database record, since this record type has variable
        length, this routine allocates its own record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDB_RECORD  prr;
    WORD        wdataLength;
    DWORD       status;

    //
    //  determine data length
    //  note:  should be able to just use RPC record datalength, BUT
    //  it is sometimes incorrect;  calculate from WINS server count,
    //  then verify within buffer
    //

    wdataLength = (WORD)(SIZEOF_WINS_FIXED_DATA +
                    pRecord->Data.WINS.cWinsServerCount * sizeof(IP_ADDRESS));

    if ( wdataLength > pRecord->wDataLength )
    {
        return DNS_ERROR_INVALID_DATA;
    }

    //  allocate database record

    prr = RR_Allocate( wdataLength );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;
    ASSERT( prr->wDataLength == wdataLength );
    prr->wType = DNS_TYPE_WINS;

    //
    //  copy data -- RPC record is direct copy of database record
    //

    RtlCopyMemory(
        & prr->Data.WINS,
        & pRecord->Data.WINS,
        wdataLength );

    return ERROR_SUCCESS;
}



DNS_STATUS
NbstatFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Read WINS-R record from RPC buffer.

Arguments:

    prr -- ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           status;
    DWORD           length;
    COUNT_NAME      nameResultDomain;

    //
    //  WINS-R landing domain
    //

    prpcName = &pRecord->Data.WINSR.nameResultDomain;

    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }
    if ( prpcName->cchNameLength == 0 )
    {
        return DNS_ERROR_INVALID_DATA;
    }
    IF_DEBUG( RPC )
    {
        DNS_PRINT((
            "WINS-R creation\n"
            "    result domain name = %.*s\n"
            "    name len = %d\n",
            prpcName->cchNameLength,
            prpcName->achName,
            prpcName->cchNameLength ));
    }

    length = Name_ConvertRpcNameToCountName(
                    & nameResultDomain,
                    prpcName );
    if ( ! length )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_NBSTAT_FIXED_DATA + length) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    //
    //  copy WINS-R record fixed fields -- RPC record format is identical
    //

    if ( pRecord->wDataLength < SIZEOF_NBSTAT_FIXED_DATA + sizeof(DNS_RPC_NAME) )
    {
        return DNS_ERROR_INVALID_DATA;
    }
    RtlCopyMemory(
        & prr->Data.WINSR,
        & pRecord->Data.WINSR,
        SIZEOF_WINS_FIXED_DATA );

    //
    //  copy in name
    //

    Name_CopyCountNameToDbaseName(
           & prr->Data.WINSR.nameResultDomain,
           & nameResultDomain );

    return ERROR_SUCCESS;
}



//
//  Read RR from RPC buffer functions
//

RR_FLAT_READ_FUNCTION   RRFlatReadTable[] =
{
    NULL,               //  ZERO

    AFlatRead,          //  A
    PtrFlatRead,        //  NS
    PtrFlatRead,        //  MD
    PtrFlatRead,        //  MF
    PtrFlatRead,        //  CNAME
    SoaFlatRead,        //  SOA
    PtrFlatRead,        //  MB
    PtrFlatRead,        //  MG
    PtrFlatRead,        //  MR
    NULL,               //  NULL
    WksFlatRead,        //  WKS
    PtrFlatRead,        //  PTR
    TxtFlatRead,        //  HINFO
    MinfoFlatRead,      //  MINFO
    MxFlatRead,         //  MX
    TxtFlatRead,        //  TXT
    MinfoFlatRead,      //  RP
    MxFlatRead,         //  AFSDB
    TxtFlatRead,        //  X25
    TxtFlatRead,        //  ISDN
    MxFlatRead,         //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigFlatRead,        //  SIG
    KeyFlatRead,        //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    AaaaFlatRead,       //  AAAA
    NULL,               //  LOC
    NxtFlatRead,        //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvFlatRead,        //  SRV
    AtmaFlatRead,       //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    NULL,               //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    WinsFlatRead,       //  WINS
    NbstatFlatRead      //  WINSR
};



DNS_STATUS
Dnssrv_Flat_RecordRead(
    IN      PZONE_INFO          pZone,      OPTIONAL
    IN      PDB_NODE            pNode,
    IN      PDNS_RPC_RECORD     pFlatRR,
    OUT     PDB_RECORD *        ppResultRR
    )
/*++

Routine Description:

    Create resource record from data.

Arguments:

    pZone       -- zone context, used to lookup non-FQDN names
    pNode       -- owner node
    pFlatRR     -- RR information
    ppResultRR  -- addr to receive ptr to created RR

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDB_RECORD      prr = NULL;
    DNS_STATUS      status = ERROR_SUCCESS;
    WORD            type;
    PARSE_INFO      parseInfo;
    PPARSE_INFO     pparseInfo = &parseInfo;
    RR_FLAT_READ_FUNCTION   preadFunction;

    //
    //  verification
    //

    if ( !pFlatRR )
    {
        ASSERT( FALSE );
        return DNS_ERROR_INVALID_DATA;
    }

    //
    //  create resource record (RR) to link to node
    //
    //      - pFlatRR->wDataLength contains length for non-standard types
    //      - must flip TTL to store in net byte order
    //

    type = pFlatRR->wType;

    DNS_DEBUG( RPC, (
        "Building RR type %s (%d) from RPC buffer\n"
        "    with flags = %p\n",
        DnsRecordStringForType( type ),
        type,
        pFlatRR->dwFlags
        ));

    //
    //  dispatching load function for desired type
    //
    //  - save type for potential use by type's routine
    //  - save ptr to RR, so can restore from this location
    //  regardless of whether created here or in type's routine
    //

    pparseInfo->pRR = NULL;
    pparseInfo->wType = type;
    pparseInfo->pnodeOwner = pNode;
    pparseInfo->pZone = NULL;
    pparseInfo->dwAppendFlag = 0;

    preadFunction = (RR_FLAT_READ_FUNCTION)
                        RR_DispatchFunctionForType(
                            (RR_GENERIC_DISPATCH_FUNCTION *) RRFlatReadTable,
                            type );
    if ( !preadFunction )
    {
        DNS_PRINT((
            "ERROR:  Attempt to build unsupported RR type %d in RPC buffer\n",
            type ));
        status = DNS_ERROR_UNKNOWN_RECORD_TYPE;
        ASSERT( FALSE );
        goto Failed;
    }

    status = preadFunction(
                pFlatRR,
                pparseInfo );

    //
    //  make status check -- saves status checks in case blocks
    //      - special case adding local WINS record
    //      - handle to local WINS record not necessary

    if ( status != ERROR_SUCCESS )
    {
        if ( status == DNS_INFO_ADDED_LOCAL_WINS )
        {
            prr = pparseInfo->pRR;
            status = ERROR_SUCCESS;
            goto Done;
        }
        DNS_PRINT((
            "ERROR:  DnsRpcRead routine failure %p (%d) for record type %d.\n\n\n",
            status, status,
            type ));
        goto Failed;
    }

    //
    //  recover ptr to type -- may have been created inside type routine
    //      for non-fixed-length types
    //

    prr = pparseInfo->pRR;
    prr->wType = pparseInfo->wType;

    Mem_ResetTag( prr, MEMTAG_RECORD_ADMIN );

    //
    //  set TTL
    //      - to explicit value, if given
    //      - otherwise to default value for zone
    //
    //  do this here, so SOA record gets default TTL that it contains
    //

    prr->dwTtlSeconds = htonl( pFlatRR->dwTtlSeconds );

    prr->dwTimeStamp = pFlatRR->dwTimeStamp;

    if ( pZone && !IS_ZONE_CACHE(pZone) )
    {
        if ( (pFlatRR->dwFlags & DNS_RPC_RECORD_FLAG_DEFAULT_TTL)
                ||
            pZone->dwDefaultTtlHostOrder == pFlatRR->dwTtlSeconds )
        {
            prr->dwTtlSeconds = pZone->dwDefaultTtl;
            SET_ZONE_TTL_RR(prr);
        }
    }

    goto Done;

Failed:

    if ( prr )
    {
        RR_Free( prr );
    }
    prr = NULL;

Done:

    if ( ppResultRR )
    {
        *ppResultRR = prr;
    }
    return status;
}



DNS_STATUS
Flat_BuildRecordFromFlatBufferAndEnlist(
    IN      PZONE_INFO          pZone,      OPTIONAL
    IN      PDB_NODE            pNode,
    IN      PDNS_RPC_RECORD     pFlatRR,
    OUT     PDB_RECORD *        ppResultRR  OPTIONAL
    )
/*++

Routine Description:

    Create resource record from data.

Arguments:

    pZone       -- zone context, used to lookup non-FQDN names
    pNode  -- RR owner node
    pnameOwner  -- RR owner, in DNS_RPC_NAME format
    pFlatRR     -- RR information
    ppResultRR  -- addr to receive ptr to created RR

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDB_RECORD      prr = NULL;
    PDNS_RPC_NAME   pname;
    DNS_STATUS      status = ERROR_SUCCESS;

    DNS_DEBUG( RPC2, (
        "Flat_BuildRecordFromFlatBufferAndEnlist for pFlatRR at %p\n",
        pFlatRR ));

    //
    //  verification
    //

    if ( !pNode )
    {
        ASSERT( FALSE );
        return DNS_ERROR_INVALID_NAME;
    }

    //
    //  build RPC record into real record
    //

    IF_DEBUG( RPC )
    {
        Dbg_NodeName(
            "    Build record from RPC at node ",
            pNode,
            "\n" );
    }
    status = Dnssrv_Flat_RecordRead(
                pZone,
                pNode,
                pFlatRR,
                & prr );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }
    ASSERT( prr );

    //
    //  add resource record to node's RR list
    //

    status = RR_AddToNode(
                pZone,
                pNode,
                prr
                );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }
    IF_DEBUG( RPC2 )
    {
        Dbg_DbaseNode(
           "Node after Admin create of new record\n",
           pNode );
    }

    //
    //  set ptr to resulting
    //

    if ( ppResultRR )
    {
        *ppResultRR = prr;
    }
    return status;

Failed:

    if ( prr )
    {
        RR_Free( prr );
    }
    if ( ppResultRR )
    {
        *ppResultRR = NULL;
    }
    return status;
}



DNS_STATUS
Flat_CreatePtrRecordFromDottedName(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PDB_NODE        pNode,
    IN      LPSTR           pszDottedName,
    IN      WORD            wType,
    OUT     PDB_RECORD *    ppResultRR      OPTIONAL
    )
/*++

Routine Description:

    Create PTR (or other single indirection record) at node
    dotted name.

Arguments:

    pZone -- zone to create NS record for

    pNode -- node to host record

    pszDottedName -- name record points to

    ppResultRR -- resulting record

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDNS_RPC_RECORD precord;
    PDNS_RPC_NAME   pname;
    INT             nameLength;
    PBYTE           precordEnd;
    CHAR            chBuffer[ 700 ];    // big enough for record with max name

    DNS_DEBUG( INIT, (
        "Flat_CreatePtrRecordFromDottedName()\n"
        "    pszDottedName = %s\n",
        pszDottedName ));

    //
    //  create PTR record
    //

    precord = (PDNS_RPC_RECORD) chBuffer;

    RtlZeroMemory(
        precord,
        SIZEOF_FLAT_RECORD_HEADER );

    precord->wType = wType;
    precord->dwFlags = DNS_RPC_FLAG_RECORD_DEFAULT_TTL;

    //  write name as record data

    pname = &precord->Data.PTR.nameNode;

    nameLength = strlen( pszDottedName );

    RtlCopyMemory(
        pname->achName,
        pszDottedName,
        nameLength );

    pname->cchNameLength = (UCHAR) nameLength;

    //  fill in record datalength

    precordEnd = pname->achName + nameLength;
    precord->wDataLength = (WORD) (precordEnd - (PBYTE)&precord->Data);

    //
    //  add record to database
    //

    status = Flat_BuildRecordFromFlatBufferAndEnlist(
                pZone,
                pNode,
                precord,
                ppResultRR
                );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR: creating new PTR from dotted name %s\n"
            "    status = %p (%d)\n",
            pszDottedName,
            status, status ));
    }
    return status;
}



//
//  Flat write section
//
//  Type specific functions for writing flat records.
//

PCHAR
AFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Process A record.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    if ( pch + SIZEOF_IP_ADDRESS > pchBufEnd )
    {
        return NULL;
    }
    *(PDWORD)pch = pRR->Data.A.ipAddress;

    return pch + sizeof(IP_ADDRESS);
}



PCHAR
PtrFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Process PTR compatible record.
    Includes: PTR, NS, CNAME, MB, MR, MG, MD, MF

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    //
    //  all these RR are single indirection RR
    //

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            & pRR->Data.PTR.nameTarget,
            FALSE );
    return pch;
}



PCHAR
SoaFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write SOA compatible record to flat buffer.
    Includes:  SOA, MINFO, RP.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    PDB_NAME    pname;

    //
    //  copy / byte swap SOA fixed fields
    //      - dwSerialNo
    //      - dwRefresh
    //      - dwRetry
    //      - dwExpire
    //      - dwMinimumTtl

    if ( pRR->wType == DNS_TYPE_SOA )
    {
        if ( pchBufEnd - pch < SIZEOF_SOA_FIXED_DATA )
        {
            return NULL;
        }
        pFlatRR->Data.SOA.dwSerialNo    = htonl( pRR->Data.SOA.dwSerialNo );
        pFlatRR->Data.SOA.dwRefresh     = htonl( pRR->Data.SOA.dwRefresh );
        pFlatRR->Data.SOA.dwRetry       = htonl( pRR->Data.SOA.dwRetry );
        pFlatRR->Data.SOA.dwExpire      = htonl( pRR->Data.SOA.dwExpire );
        pFlatRR->Data.SOA.dwMinimumTtl  = htonl( pRR->Data.SOA.dwMinimumTtl );
        pch += SIZEOF_SOA_FIXED_DATA;
    }

    //  SOA name server

    pname = &pRR->Data.SOA.namePrimaryServer;

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            pname,
            FALSE );
    if ( !pch )
    {
        return NULL;
    }

    //  Zone admin

    pname = Name_SkipDbaseName( pname );

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            pname,
            TRUE );

    return pch;
}



PCHAR
KeyFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write key record to flat buffer.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    if ( pchBufEnd - pch < pRR->wDataLength )
    {
        return NULL;
    }

    pFlatRR->Data.KEY.wFlags        = htons( pRR->Data.KEY.wFlags );
    pFlatRR->Data.KEY.chProtocol    = pRR->Data.KEY.chProtocol;
    pFlatRR->Data.KEY.chAlgorithm   = pRR->Data.KEY.chAlgorithm;

    RtlCopyMemory(
        pFlatRR->Data.KEY.bKey,
        &pRR->Data.KEY.Key,
        pRR->wDataLength - SIZEOF_KEY_FIXED_DATA );

    pch += pRR->wDataLength;

    return pch;
}   //  KeyFlatWrite



PCHAR
SigFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write sig record to flat buffer.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    int         sigLength;

    if ( pchBufEnd - pch < SIZEOF_SIG_FIXED_DATA )
    {
        return NULL;
    }
    pFlatRR->Data.SIG.wTypeCovered      = htons( pRR->Data.SIG.wTypeCovered );
    pFlatRR->Data.SIG.chAlgorithm       = pRR->Data.SIG.chAlgorithm;
    pFlatRR->Data.SIG.chLabelCount      = pRR->Data.SIG.chLabelCount;
    pFlatRR->Data.SIG.dwOriginalTtl     = htonl( pRR->Data.SIG.dwOriginalTtl );
    pFlatRR->Data.SIG.dwSigExpiration   = htonl( pRR->Data.SIG.dwSigExpiration );
    pFlatRR->Data.SIG.dwSigInception    = htonl( pRR->Data.SIG.dwSigInception );
    pFlatRR->Data.SIG.wKeyTag           = htons( pRR->Data.SIG.wKeyTag );
    pch += SIZEOF_SIG_FIXED_DATA;

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            &pRR->Data.SIG.nameSigner,
            FALSE );
    if ( !pch )
    {
        return NULL;
    }

    sigLength = pRR->wDataLength -
                SIZEOF_SIG_FIXED_DATA - 
                DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner );
    ASSERT( sigLength > 0 );

    if ( pchBufEnd - pch < sigLength )
    {
        return NULL;
    }
    RtlCopyMemory(
        pch,
        ( PBYTE ) &pRR->Data.SIG.nameSigner +
            DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner ),
        sigLength );
    pch += sigLength;

    return pch;
}   //  SigFlatWrite



PCHAR
NxtFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write NXT record to flat buffer.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    INT         byteIdx;
    INT         bitIdx;
    PWORD       pWordCount = ( PWORD ) pch;

    //
    //  Write word count followed by word array.
    //

    *pWordCount = 0;
    pch += sizeof( WORD );
    for ( byteIdx = 0; byteIdx < DNS_MAX_TYPE_BITMAP_LENGTH; ++byteIdx )
    {
        for ( bitIdx = ( byteIdx ? 0 : 1 ); bitIdx < 8; ++bitIdx )
        {
            PCHAR   pszType;

            if ( !( pRR->Data.NXT.bTypeBitMap[ byteIdx ] &
                    ( 1 << bitIdx ) ) )
            {
                continue;   // Bit value is zero - do not write string.
            }
            if ( pchBufEnd - pch < sizeof( WORD ) )
            {
                return NULL;
            }
            * ( WORD * ) pch = byteIdx * 8 + bitIdx;
            pch += sizeof( WORD );
            ++( *pWordCount );
        } 
    }

    //
    //  Write next name.
    //

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            &pRR->Data.NXT.nameNext,
            FALSE );
    if ( !pch )
    {
        return NULL;
    }

    return pch;
}   //  NxtFlatWrite



PCHAR
MinfoFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write MINFO compatible record to flat buffer.
    Includes:  MINFO, RP.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    PDB_NAME    pname;

    //  mailbox

    pname = &pRR->Data.MINFO.nameMailbox;

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            pname,
            FALSE );
    if ( !pch )
    {
        return NULL;
    }

    //  errors mailbox

    pname = Name_SkipDbaseName( pname );

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            pname,
            FALSE );

    return pch;
}



PCHAR
MxFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write MX compatible record to flat buffer.
    Includes: MX, RT, AFSDB

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //

    if ( pchBufEnd - pch < sizeof(WORD) )
    {
        return NULL;
    }
    *(WORD *) pch = ntohs( pRR->Data.MX.wPreference );
    pch += sizeof( WORD );

    //
    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            & pRR->Data.MX.nameExchange,
            FALSE );

    return pch;
}



PCHAR
FlatFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write flat compatible record to flat buffer.
    These records have exactly the same database and flat record
    format so need only mem copy.

    Includes: TXT, HINFO, ISDN, X25, AAAA, WINS

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    if ( pchBufEnd - pch < pRR->wDataLength )
    {
        return NULL;
    }

    RtlCopyMemory(
        pch,
        & pRR->Data,
        pRR->wDataLength );

    pch += pRR->wDataLength;
    return pch;
}



PCHAR
WksFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write WKS record to flat buffer.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    PDNS_RPC_NAME   pstringServices;
    INT             i;
    USHORT          port;
    UCHAR           bBitmask;
    struct servent * pServent;
    struct protoent * pProtoent;


    //  server address

    if ( pch + SIZEOF_WKS_FIXED_DATA > pchBufEnd )
    {
        return NULL;
    }
    *(DWORD *)pch = pRR->Data.WKS.ipAddress;
    pch += SIZEOF_IP_ADDRESS;

    //  protocol

    *pch = pRR->Data.WKS.chProtocol;
    pch++;

    pProtoent = getprotobynumber( (INT) pRR->Data.WKS.chProtocol );
    if ( ! pProtoent )
    {
        DNS_PRINT((
            "ERROR:  Unable to find protocol %d, writing WKS record\n",
            (INT) pRR->Data.WKS.chProtocol
            ));
        pServent = NULL;
    }

    //
    //  services
    //
    //  find each bit set in bitmask, lookup and write service
    //  corresponding to that port
    //
    //  note, that since that port zero is the front of port bitmask,
    //  lowest ports are the highest bits in each byte
    //

    pstringServices = (PDNS_RPC_STRING) pch;

    for ( i = 0;
            i < (INT)(pRR->wDataLength - SIZEOF_WKS_FIXED_DATA);
                i++ )
    {
        bBitmask = (UCHAR) pRR->Data.WKS.bBitMask[i];

        port = i * 8;

        //  write service name for each bit set in byte
        //      - get out as soon byte is empty of ports
        //      - terminate each name with blank (until last)

        while ( bBitmask )
        {
            if ( bBitmask & 0x80 )
            {
                if ( pProtoent )
                {
                    pServent = getservbyport(
                                    (INT) htons(port),
                                    pProtoent->p_name );
                }
                if ( pServent )
                {
                    INT copyCount = strlen(pServent->s_name);

                    pch++;
                    if ( pchBufEnd - pch <= copyCount+1 )
                    {
                        return NULL;
                    }
                    RtlCopyMemory(
                        pch,
                        pServent->s_name,
                        copyCount );
                    pch += copyCount;
                    *pch = ' ';
                }

                //  failed to find service name -- write port as integer
                //  note max 5 chars in WORD base 10, so that's our
                //      out of buffer test

                else
                {
                    DNS_PRINT((
                        "ERROR:  in WKS write\n"
                        "    Unable to find service for port %d, protocol %s\n",
                        port,
                        pProtoent ? pProtoent->p_name : NULL ));

                    if ( pchBufEnd - pch <= 6 )
                    {
                        return NULL;
                    }
                    pch += sprintf( pch, "%u ", port );
                }
            }
            port++;             // next service port
            bBitmask <<= 1;     // shift mask up to read next port
        }
    }

    //  NULL terminate services string and write byte count

    *pch++ = 0;
    pstringServices->cchNameLength = (UCHAR) (pch - pstringServices->achName);

    //  return next position in buffer

    return pch;
}



PCHAR
SrvFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write SRV record to flat buffer.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    //
    //  SRV fixed fields -- priority, weight, port
    //

    if ( pchBufEnd - pch < 3*sizeof(WORD) )
    {
        return NULL;
    }
    *(WORD *) pch = ntohs( pRR->Data.SRV.wPriority );
    pch += sizeof( WORD );
    *(WORD *) pch = ntohs( pRR->Data.SRV.wWeight );
    pch += sizeof( WORD );
    *(WORD *) pch = ntohs( pRR->Data.SRV.wPort );
    pch += sizeof( WORD );

    //
    //  SRV target host
    //

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            & pRR->Data.SRV.nameTarget,
            FALSE );

    return pch;
}



PCHAR
NbstatFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write WINSR record to flat buffer.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    //
    //  NBSTAT flags
    //      - note these are stored in HOST order for easy use
    //

    if ( pchBufEnd - pch < SIZEOF_NBSTAT_FIXED_DATA )
    {
        return NULL;
    }
    *(DWORD *) pch = pRR->Data.WINSR.dwMappingFlag;
    pch += sizeof( DWORD );
    *(DWORD *) pch = pRR->Data.WINSR.dwLookupTimeout;
    pch += sizeof( DWORD );
    *(DWORD *) pch = pRR->Data.WINSR.dwCacheTimeout;
    pch += sizeof( DWORD );

    //
    //  NBSTAT domain
    //

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            & pRR->Data.WINSR.nameResultDomain,
            FALSE );

    return pch;
}



//
//  Write RR to flat buffer functions
//

RR_FLAT_WRITE_FUNCTION  RRFlatWriteTable[] =
{
    FlatFlatWrite,      //  ZERO -- default for unknown types is flat write

    AFlatWrite,         //  A
    PtrFlatWrite,       //  NS
    PtrFlatWrite,       //  MD
    PtrFlatWrite,       //  MF
    PtrFlatWrite,       //  CNAME
    SoaFlatWrite,       //  SOA
    PtrFlatWrite,       //  MB
    PtrFlatWrite,       //  MG
    PtrFlatWrite,       //  MR
    NULL,               //  NULL
    WksFlatWrite,       //  WKS
    PtrFlatWrite,       //  PTR
    FlatFlatWrite,      //  HINFO
    MinfoFlatWrite,     //  MINFO
    MxFlatWrite,        //  MX
    FlatFlatWrite,      //  TXT
    MinfoFlatWrite,     //  RP
    MxFlatWrite,        //  AFSDB
    FlatFlatWrite,      //  X25
    FlatFlatWrite,      //  ISDN
    MxFlatWrite,        //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigFlatWrite,       //  SIG
    KeyFlatWrite,       //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    FlatFlatWrite,      //  AAAA
    FlatFlatWrite,      //  LOC
    NxtFlatWrite,       //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvFlatWrite,       //  SRV
    FlatFlatWrite,      //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    NULL,               //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    FlatFlatWrite,      //  WINS
    NbstatFlatWrite     //  WINSR
};




DNS_STATUS
Flat_WriteRecordToBuffer(
    IN OUT  PBUFFER         pBuffer,
    IN      PDNS_RPC_NODE   pRpcNode,
    IN      PDB_RECORD      pRR,
    IN      PDB_NODE        pNode,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Add resource record to flat (RPC or DS) buffer.

Arguments:

    ppCurrent - addr of current ptr in buffer

    pchBufEnd - ptr to byte after buffer

    pRpcNode - ptr to record name for this buffer

    pRR - database RR information to include in answer

    pNode - database node this record belongs to

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of space in buffer.
    Error code on failure.

--*/
{
    PDNS_RPC_RECORD pflatRR;
    PCHAR           pch = pBuffer->pchCurrent;
    PCHAR           pbufEnd = pBuffer->pchEnd;
    DWORD           ttl;
    DWORD           currentTime;
    DNS_STATUS      status;
    RR_FLAT_WRITE_FUNCTION  pwriteFunction;

    ASSERT( IS_DWORD_ALIGNED(pch) );
    ASSERT( pRR != NULL );
    pflatRR = (PDNS_RPC_RECORD) pch;

    DNS_DEBUG( RPC, (
        "Flat_WriteRecordToBuffer()\n"
        "    Writing RR at %p to buffer at %p, with buffer end at %p\n"
        "    Buffer node at %p\n"
        "    Flags = %p\n",
        pRR,
        pflatRR,
        pbufEnd,
        pRpcNode,
        dwFlag ));

    //
    //  last error will be set on failure for out-of-buffer condition
    //  clear last error now, so any error is valid
    //

    SetLastError( ERROR_SUCCESS );

    //  verify record size not messed up

    ASSERT( SIZEOF_DNS_RPC_RECORD_HEADER ==
                        ((PBYTE)&pflatRR->Data - (PBYTE)pflatRR) );

    //
    //  fill RR structure
    //      - set ptr
    //      - set type and class
    //      - set datalength once we're finished
    //

    if ( pbufEnd - (PCHAR)pflatRR < SIZEOF_DNS_RPC_RECORD_HEADER )
    {
        goto MoreData;
    }
    pflatRR->wType          = pRR->wType;
    pflatRR->dwFlags        = RR_RANK(pRR);
    pflatRR->dwSerial       = 0;
    pflatRR->dwTimeStamp    = pRR->dwTimeStamp;
    pflatRR->dwReserved     = 0;

    //
    //  Zone root record ?
    //

    if ( IS_ZONE_ROOT(pNode) )
    {
        pflatRR->dwFlags |= DNS_RPC_FLAG_ZONE_ROOT;
        if ( IS_AUTH_ZONE_ROOT(pNode) )
        {
            pflatRR->dwFlags |= DNS_RPC_FLAG_AUTH_ZONE_ROOT;
        }
    }

    //
    //  TTL
    //      - cache data TTL is in form of timeout time
    //      - regular authoritative data TTL is STATIC TTL in net byte order
    //

    ttl = pRR->dwTtlSeconds;

    if ( IS_CACHE_RR(pRR) )
    {
        currentTime = DNS_TIME();
        if ( ttl < currentTime )
        {
            DNS_DEBUG( RPC, (
                "Dropping timed out record at %p from flat write\n"
                "    record ttl = %d, current time = %d\n",
                pRR,
                ttl,
                currentTime ));
            return ERROR_SUCCESS;
        }
        pflatRR->dwTtlSeconds = ttl - currentTime;
        pflatRR->dwFlags |= DNS_RPC_RECORD_FLAG_CACHE_DATA;
    }
    else
    {
        pflatRR->dwTtlSeconds = ntohl( ttl );
    }

    //
    //  write RR data
    //

    pch = (PCHAR) &pflatRR->Data;

    DNS_DEBUG( RPC2, (
        "Wrote record header at %p\n"
        "    Starting data write at %p\n"
        "    %d bytes available\n",
        pflatRR,
        pch,
        pbufEnd - pch ));


    pwriteFunction = (RR_FLAT_WRITE_FUNCTION)
                        RR_DispatchFunctionForType(
                            (RR_GENERIC_DISPATCH_FUNCTION *) RRFlatWriteTable,
                            pRR->wType );
    if ( !pwriteFunction )
    {
        ASSERT( FALSE );
        return ERROR_INVALID_PARAMETER;
    }
    pch = pwriteFunction(
                pflatRR,
                pRR,
                pch,
                pbufEnd );
    if ( !pch )
    {
        DNS_DEBUG( RPC, (
            "WARNING:  RRFlatWrite routine failure for record type %d,\n"
            "    assuming out of buffer space\n",
            pRR->wType ));
        goto MoreData;
    }

    //
    //  write record length
    //

    ASSERT( pch > (PCHAR)&pflatRR->Data );

    pflatRR->wDataLength = (WORD) (pch - (PCHAR)&pflatRR->Data);

    //  successful => increment count of RR attached to name

    if ( pRpcNode )
    {
        pRpcNode->wRecordCount++;
    }

    //
    //  reset current ptr for next record
    //      - DWORD align
    //

    pch = (PCHAR) DNS_NEXT_DWORD_PTR(pch);
    ASSERT( pch && IS_DWORD_ALIGNED(pch) );
    pBuffer->pchCurrent = pch;

    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcRecord(
            "RPC record written to buffer",
            pflatRR );
        DNS_PRINT((
            "Wrote RR at %p to buffer at position %p\n"
            "    New pCurrent = %p\n",
            pRR,
            pflatRR,
            pch ));
    }
    return ERROR_SUCCESS;


MoreData:

    //
    //  error writing record to buffer
    //      - default assumption is out of space
    //      - in any case leave ppCurrent unchanged so can resume write
    //

    status = GetLastError();

    if ( status == ERROR_SUCCESS )
    {
        status = ERROR_MORE_DATA;
    }

    if ( status == ERROR_MORE_DATA )
    {
        DNS_DEBUG( RPC, (
            "INFO:  Unable to write RR at %p to buffer -- out of space\n"
            "    pchCurrent   %p\n"
            "    pbufEnd    %p\n",
            pRR,
            pch,
            pbufEnd ));
    }
    else
    {
        DNS_DEBUG( ANY, (
            "ERROR:  %d (%p) writing RR at %p to buffer\n"
            "    pchCurrent   %p\n"
            "    pbufEnd    %p\n",
            pRR,
            pch,
            pbufEnd ));
    }

    return status;
}

//
//  End rrflat.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\sdutl.cxx ===
/*******************************************************************
*
*    File        : sdutl.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996-1999
*    Date        : 8/17/1998
*    Description : DNS 'C' Interface to CSecurityDescriptor class
*
*    Revisions   : <date> <name> <description>
*                   2001  jwesth  Cleanup/unicode/additions
*******************************************************************/



#ifndef SDUTL_CXX
#define SDUTL_CXX


#ifdef __cplusplus
extern "C"
{
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include <windows.h>
#include <stdio.h>


extern "C"
{
#pragma warning (disable : 4200)
#include "dnssrv.h"
}
#include <ntseapi.h>
#include <sddl.h>
#include <dns.h>
#include "csd.h"
#include "lmaccess.h"
#include "lmerr.h"
#include "secobj.h"


// defines //
#define SZ_DNS_ADMIN_GROUP              "DnsAdmins"
#define SZ_DNS_ADMIN_GROUP_W            L"DnsAdmins"


#define MEMTAG_SECURITY     MEMTAG_DS_OTHER


#define NT_FROM_HRESULT(x)      ((NTSTATUS)(x))

//
// From CN=Dns-Node,CN=Schema,CN=Configuration,DC=ntdev,DC=microsoft,DC=com
//      defaultSecurityDescriptor attribute
// DEVNOTE: in the future we may wanna read this dynamically
//
// Problems w/ parsing out the SACL. Let's use w/out the SACL for now
// #define DEFAULT_DNS_NODE_SD_STRING "O:COG:CGD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;ED)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;CO)(A;;RPLCLORC;;;WD)S:(AU;SAFA;WDWOSDDTWPCRCCDCSW;;;WD)"
#define DEFAULT_DNS_NODE_SD_STRING_W L"D:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;BA)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;ED)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;CO)(A;;RPLCLORC;;;WD)"

// types //


// global variables //



extern "C"
{

// extern: dns variables that are not available as long as we can't include dnssrv.h
//
// security globals from startup at dns.c (from dnssrv.h)
//

extern  PSECURITY_DESCRIPTOR g_pDefaultServerSD;
extern  PSID g_pServerSid;
extern  PSID g_pServerGroupSid;
extern  PSID g_pAuthenticatedUserSid;
extern  PSID g_pDomainAdminsSid;
extern  PSID g_pEnterpriseAdminsSid;
extern  PSID g_pEnterpriseControllersSid;
extern  PSID g_pLocalSystemSid;
extern  PSID g_pEveryoneSid;
extern  PSID g_pDynuproxSid;
extern  PSID g_pDnsAdminSid;

// defined in ds.c
extern WCHAR  g_wszDomainFlatName[LM20_DNLEN+1];

}


//
//  Security Descriptor utilities
//

extern "C" {



PSECURITY_DESCRIPTOR
makeSecurityDescriptorCopy(
    IN      CSecurityDescriptor &   csd
    )
{
    DWORD                   lengthSD;
    PSECURITY_DESCRIPTOR    pnewsd;
    DNS_STATUS              status;

    DNS_DEBUG( SD, ( "makeSecurityDescriptorCopy( %p )\n", &csd ));

    lengthSD = GetSecurityDescriptorLength( PSECURITY_DESCRIPTOR( csd ) );

    ASSERT( lengthSD );

    pnewsd = ( PSECURITY_DESCRIPTOR ) ALLOC_TAGHEAP( lengthSD, MEMTAG_SECURITY );
    IF_NOMEM( !pnewsd )
    {
        DNS_DEBUG( SD, ( "no memory for Client SD!\n" ));
        SetLastError( DNS_ERROR_NO_MEMORY );
        return NULL;
    }

    //
    //  convert to self relative
    //

    status = RtlAbsoluteToSelfRelativeSD(
                    PSECURITY_DESCRIPTOR( csd ),
                    pnewsd,
                    &lengthSD );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, ( "cannot create self-relative SD\n" ));
        if ( pnewsd )
        {
            FREE_HEAP( pnewsd );
        }
        SetLastError( status );
        return NULL;
    }

    return pnewsd;
}   //  makeSecurityDescriptorCopy



NTSTATUS
__stdcall
SD_CreateClientSD(
    OUT     PSECURITY_DESCRIPTOR *  ppClientSD,
    IN      PSECURITY_DESCRIPTOR *  pBaseSD,       OPTIONAL
    IN      PSID                    pOwnerSid,
    IN      PSID                    pGroupSid,
    IN      BOOL                    bAllowWorld
    )
/*+++
Function   : SD_CreateClientSD
Description: Create's a client SD to apply to an update
Parameters : ppClientSD: SD generated to return
Return     : success status (ERROR_SUCCESS on success)
Remarks    : Assumes that we're in client context!!
             Caller must free non-NULL *ppClientSD with LocalFree
---*/
{
    DWORD   status=0;
    PSID    pUsr=NULL;
    PSID    pGroup=NULL;
    DWORD   lengthSD=0;
    LPTSTR   pwsSD = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;
    CSecurityDescriptor csd;

    DNS_DEBUG( SD, ( "SD_CreateClientSD()\n" ));

    //
    // create SD from given SD
    // if not given use server default SD.
    //

    psd = pBaseSD ? pBaseSD : g_pDefaultServerSD;

    status = csd.Attach(psd);
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to initialize from base SD\n" ));
        return NT_FROM_HRESULT( status );
    }

    //
    // modify so that:
    // 1) R/W access allowed to:
    //      - client thread Sid
    //      - process Sid
    //
    
    status = csd.GetThreadSids( &pUsr, &pGroup, TRUE );
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to get thread sids\n" ));
        return NT_FROM_HRESULT( status );
    }

    //
    //  apply group & user SID to new SD
    //

    status = csd.Allow( pUsr, DNS_DS_GENERIC_WRITE );
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to allow user\n" ));
        goto Cleanup;
    }

    if ( bAllowWorld )
    {
        //
        //  Allow authenticated users (that's what world access means for us)
        //
        
        DNS_DEBUG( SD, ( "allowing authenticated users access!!\n" ));
        status = csd.Allow( g_pAuthenticatedUserSid, DNS_DS_GENERIC_WRITE );
        if ( FAILED( status ) )
        {
            DNS_DEBUG( SD, ( "Failed to allow authenticated users access\n" ));
            goto Cleanup;
        }
    }

    delete pUsr;
    pUsr = NULL;

    delete pGroup;
    pGroup = NULL;


    //
    //  set owner & group
    //

    status = csd.SetOwner(pOwnerSid, FALSE);
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed set process user \n" ));
        goto Cleanup;
    }

    status = csd.SetGroup(pGroupSid, FALSE);
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to set process group \n" ));
        goto Cleanup;
    }

    //
    //  allocate copy
    //

    lengthSD = GetSecurityDescriptorLength( PSECURITY_DESCRIPTOR(csd) );
    ASSERT(lengthSD);

    psd = (PSECURITY_DESCRIPTOR) ALLOC_TAGHEAP( lengthSD, MEMTAG_SECURITY );
    IF_NOMEM( !psd )
    {
        DNS_DEBUG( SD, ( "no memory for Server SD!\n" ));
        status = DNS_ERROR_NO_MEMORY;
        return NULL;
    }

    //
    //  convert to self relative
    //

    status = RtlAbsoluteToSelfRelativeSD(
                    PSECURITY_DESCRIPTOR( csd ),
                    psd,
                    &lengthSD );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, ( "cannot create self-relative SD\n" ));
        if ( psd )
        {
            FREE_HEAP( psd );
            psd = NULL;
        }
    }

    *ppClientSD = psd;

#if DBG
    if ( psd )
    {
        pwsSD = csd.GenerateSDString();  // must free w/ pwsSD
        DNS_DEBUG( SD, ( "SD = %S\n", pwsSD ));
        if ( pwsSD )
        {
            LocalFree(pwsSD);
        }
        else
        {
            DNS_DEBUG( SD, ( "Error<%lu>: cannot generate sd string\n", GetLastError() ));
        }
    }
#endif

Cleanup:

    //
    //  clean up memory
    //
    delete pUsr;
    delete pGroup;

    // return
    return (NTSTATUS)status;
}


NTSTATUS
__stdcall
SD_CreateServerSD(
    OUT PSECURITY_DESCRIPTOR *ppServerSD
    )

/*+++
Function   : SD_CreateServerSD
Description: Creates DNS server default SD to apply to an update
             Basically, for reverting to default dnsNode access description
Parameters : ppClientSD: SD generated to return
Return     : success status (ERROR_SUCCESS on success)
Remarks    : see Dns-Node schema definition to see where we took this from
             //Caller must free non-NULL *ppClientSD with LocalFree

             free with FREE_HEAP

---*/
{

    DWORD status=0;
    DWORD lengthSD=0;
    LPTSTR pwsSD = NULL;
    PSECURITY_DESCRIPTOR psd=NULL;
    CSecurityDescriptor csd;

    DNS_DEBUG( SD, ( "Calling SD_CreateServerSD\n" ));

    if (!ppServerSD)
    {
       return ERROR_INVALID_PARAMETER;
    }

    DNS_DEBUG( SD, ( "Building SD...\n" ));
    //
    // create SD from process (DNS context, not client!)
    //
    status = csd.InitializeFromProcessToken();
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to initialize from process token\n" ));
        return NT_FROM_HRESULT( status );
    }

    status = csd.Attach(DEFAULT_DNS_NODE_SD_STRING_W);
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to attach from default SD string\n" ));
        return NT_FROM_HRESULT( status );
    }

    //
    // set owner & group
    //

    status = csd.SetOwner(g_pServerSid, FALSE);
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed set process user \n" ));
        goto Cleanup;
    }

    status = csd.SetGroup(g_pServerGroupSid, FALSE);
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to set process group \n" ));
        goto Cleanup;
    }

    //
    //  Add DnsAdmins to SD. Note: if DnsAdmins could not be loaded, omit
    //  this step.
    //

    if ( g_pDnsAdminSid )
    {
        status = csd.Allow(
                     SZ_DNS_ADMIN_GROUP_W,
                     STANDARD_RIGHTS_REQUIRED |             // standard rights
                         DNS_DS_GENERIC_ALL,                // all DS object rights
                     CONTAINER_INHERIT_ACE );

        if ( FAILED( status ) )
        {
            DNS_DEBUG( SD, ( "Failed to add dnsadmin group to server SD \n" ));
            goto Cleanup;
        }
    }

    //
    //  allocate copy
    //

    lengthSD = GetSecurityDescriptorLength( PSECURITY_DESCRIPTOR(csd) );
    ASSERT(lengthSD);

    psd = (PSECURITY_DESCRIPTOR) ALLOC_TAGHEAP( lengthSD, MEMTAG_SECURITY );
    IF_NOMEM( !psd )
    {
        DNS_DEBUG( SD, ( "no memory for Server SD!\n" ));
        status = DNS_ERROR_NO_MEMORY;
        return NULL;
    }

    //
    //  convert to self relative
    //

    status = RtlAbsoluteToSelfRelativeSD(
                    PSECURITY_DESCRIPTOR( csd ),
                    psd,
                    &lengthSD );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, ( "cannot create self-relative SD\n" ));
        if ( psd )
        {
            FREE_HEAP( psd );
            psd = NULL;
        }
    }

    *ppServerSD = psd;


#if DBG
    if ( psd )
    {
        pwsSD = csd.GenerateSDString();  // must free w/ pwsSD
        DNS_DEBUG( SD, ( "SD = %S\n", pwsSD ));
        if ( pwsSD )
        {
            LocalFree(pwsSD);
        }
        else
        {
            DNS_DEBUG( SD, ( "Error<%lu>: cannot generate sd string\n", GetLastError() ));
        }
    }
#endif


Cleanup:

    return (NTSTATUS)status;
}






NTSTATUS __stdcall
SD_GetProcessSids(
    OUT PSID *pServerSid,
    OUT PSID *pServerGroupSid
    )
/*+++
Function   : SD_GetProcessSids
Description: allocates & gets server SIDs (owner & group
Parameters : pServerSID: place holder for allocated user SID,
             pServerGroupSID: place holder for allocated group SID
Return     : success code, ERROR_SUCCESS is good
Remarks    : none.
---*/
{


   if (!pServerSid || !pServerGroupSid)
   {
      DNS_DEBUG( SD, ( "Error: invalid parameters\n" ));
      return ERROR_INVALID_PARAMETER;
   }


   return CSecurityDescriptor::GetProcessSids(pServerSid, pServerGroupSid);
}




NTSTATUS __stdcall
SD_GetThreadSids(
    OUT PSID *pClientSid,
    OUT PSID *pClientGroupSid
    )
/*+++
Function   : SD_GetThreadSids
Description: allocates & gets server SIDs (owner & group
Parameters : pServerSID: place holder for allocated user SID,
             pServerGroupSID: place holder for allocated group SID
Return     : success code, ERROR_SUCCESS is good
Remarks    : none.
---*/
{


   if (!pClientSid || !pClientGroupSid)
   {
      DNS_DEBUG( SD, ( "Error: invalid parameters\n" ));
      return ERROR_INVALID_PARAMETER;
   }


   return CSecurityDescriptor::GetThreadSids(pClientSid,
                                             pClientGroupSid,
                                             TRUE);
}



VOID __stdcall
SD_Delete(
    PVOID pVoid
    )
/*+++
Function   : SD_FreeThreadSids
Description: free up given poiner
Parameters : pVoid: memory to free
Return     : success code, ERROR_SUCCESS is good
Remarks    : Basically, we're supplying this to free up memory allocated
             by C++ new allocator.
---*/
{

    ASSERT( pVoid );

    delete pVoid;

}



NTSTATUS __stdcall
SD_AccessCheck(
    PSECURITY_DESCRIPTOR    IN          pSd,
    PSID                    IN          pSid,
    DWORD                   IN          dwMask,
    PBOOL                   IN OUT      pbAccess)
/*+++
Function   : SD_AccessCheck
Description: Our own little access check to see if given Sid contains specified access (given by mask
             for user (specified by sid)
Parameters : pSd: Security Descriptor, self-relative!
             pSid: user id
             dwMask: access desired
             pbAccess: whether access is given
Return     : status: any failure report, ERROR_SUCCESS on success
             pbAccess: result
Remarks    : DEVNOTE: should probably move to CSecurityDescriptr class later?
---*/
{

   NTSTATUS status = ERROR_SUCCESS;
   BOOL     bDACLPresent;
   BOOL     bDefaulted;
   BOOL     bAccess = FALSE;
   PACL     pDACL = NULL;
   ACCESS_ALLOWED_ACE * pACE = NULL;
   INT      i;
   INT      iFound = 0;
   PSID     pTmpSid = NULL;

   //
   // sanity
   //
   if ( !pSd || !pSid || !pbAccess )
   {
      return ERROR_INVALID_PARAMETER;
   }


   // get the existing DACL.
   if ( !GetSecurityDescriptorDacl(pSd, &bDACLPresent, &pDACL, &bDefaulted) ||
        !bDACLPresent ||
        !pDACL )
   {
        status = GetLastError();
        if ( status == ERROR_SUCCESS )
        {
            status = ERROR_ACCESS_DENIED;
        }
        DNS_DEBUG( SD, (
            "sdutl error <%lu>: GetSecurityDescriptorDacl failed\n",
            status ));
        goto Cleanup;
   }

   // cycle ACEs & find access-allowed ones.
   for ( i=0; i < pDACL->AceCount; i++ )
   {
      if ( !GetAce(pDACL, i, (void **)&pACE) )
      {
          status = GetLastError();
          DNS_DEBUG( SD, ( "sdutl error <%lu>: GetAce failed\n", status ));
          goto Cleanup;
      }

      if ( pACE->Header.AceType != ACCESS_ALLOWED_ACE_TYPE )
      {
          DNS_DEBUG( SD, ( "sdutl: unknown ACE type = 0x%x\n", pACE->Header.AceType ));
          continue;
      }

      //
      // Ok, found a known type
      //
      iFound++;

      pTmpSid = (PSID)(&pACE->SidStart);


      //
      // Compare to see if there's access match
      //
      //    DEVNOTE:  this seems broken
      //        do we care ONLY that we have "a" bit, or that we've got
      //        all the bits we need -- it should be the later
      //
      //    DEVNOTE:  you never compare to TRUE
      //

      if ( (pACE->Mask & dwMask) == dwMask
                &&
            RtlEqualSid(pTmpSid, pSid) )
      {
            bAccess = TRUE;
            break;
      }
#if 0
      if ((pACE->Mask & dwMask) &&
          TRUE == RtlEqualSid(pTmpSid, pSid))
      {
            bAccess = TRUE;
            break;
      }
#endif


   }

   if (0 == iFound)
   {
      DNS_DEBUG( SD, ( "sdutl: Could not find known ACEs\n" ));
      status = ERROR_INVALID_PARAMETER;
   }
   else
   {
      //
      // return access check
      //
      *pbAccess = bAccess;
   }

Cleanup:

   return status;
}


BOOL
__stdcall
SD_IsProxyClient(
    IN      HANDLE          hToken
    )
/*++

Routine Description:

    Check if client token is in DNS proxies (DHCP servers) group.

Arguments:

    hToken -- handle to token of client (impersonated thread token)

Return Value:

    TRUE -- client is member of DNS proxies.
    FALSE -- not member or error

--*/
{
    BOOL    bresult;

    if ( !g_pDynuproxSid )
    {
        ASSERT( FALSE );
        return( FALSE );
    }

    if ( !CheckTokenMembership(
                hToken,
                g_pDynuproxSid,
                & bresult ) )
    {
        IF_DEBUG( ANY )
        {
            DNS_STATUS status = GetLastError();

            DNS_PRINT((
                "ERROR:  CheckTokenMembership failed:  %d (%p)\n",
                status, status ));
        }
        bresult = FALSE;
    }

    return bresult;
}


NTSTATUS __stdcall
SD_LoadDnsAdminGroup(
     VOID
     )
/*++

Routine Description (Dns_LoadDnsAdminGroup):

    Read Dns Admin group info & place in global info
    If group does not exist, will create it.


Arguments:

    None.



Return Value:

    Error code. ERROR_SUCCESS on success.

Remarks:
    None.


--*/
{

    PSID pSid = NULL;
    DWORD status;
    BOOL fMissing = FALSE;
    // we're using an arbitrary big constant, could be smaller.
    WCHAR wszBuffer[DNS_MAX_NAME_LENGTH];
    WCHAR wszFullName[DNS_MAX_NAME_LENGTH];
    LOCALGROUP_INFO_1 grpInfo =
    {
        SZ_DNS_ADMIN_GROUP_W,
        wszBuffer
    };

    //
    // Read DnsAdminGroup
    //

    if ( g_pDnsAdminSid )
    {
        DNS_DEBUG( SD, ( "When do we re-load DnsAdmin group? Here.\n" ));
        ASSERT( FALSE );
        delete g_pDnsAdminSid;
        g_pDnsAdminSid = NULL;
    }

    //
    // Used ALL WIDE chars here to avoid completely breaking on non US domains.
    //

    wsprintf(
        wszFullName,
        L"%s\\%s",
        g_wszDomainFlatName,
        SZ_DNS_ADMIN_GROUP_W );

    DNS_DEBUG( SD, (
        "DnsAdmins groups is \"%S\"\n",
        wszFullName ));

    status = CSecurityDescriptor::GetPrincipalSID(
                 wszFullName,
                 &pSid );

    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, ( "Retrieved DnsAdmin group sid\n" ));
        goto Cleanup;
    }

    //
    //  Load Description string
    //

    if ( !Dns_GetResourceString (
              ID_ADMIN_GROUP_DESCRIPTION,
              wszBuffer,
              DNS_MAX_NAME_LENGTH ) )
    {
        DNS_DEBUG( SD, ( "Failed to get Resource string" ));
        ASSERT( FALSE );
        // use something
        wcscpy( wszBuffer, L"Dns Administrators Group" );
    }

    //
    // Didn't find it. Let's try to create it.
    //
    DNS_DEBUG( SD, (
        "Error %lu: cannot get principal sid for DnsAdmins.\n"
        "Trying to add it.\n",
        status ));

    status = NetLocalGroupAdd(
                              NULL,             // local computer
                              1,                // info level
                              (LPBYTE)&grpInfo, // group name & comment
                              NULL);            // index to param err

    if ( NERR_Success != status )
    {
        DNS_DEBUG( SD, (
            "Error %lu: Failed to create DnsAdmin group\n",
            status ));

        //  if going to ASSERT() on status!=SUCCESS below, then do it here
        //      so we can tell at a glance what failed
        ASSERT( FALSE );
        goto Cleanup;
    }
    fMissing = TRUE;

    //
    // Created. Get group sid
    //
    status = CSecurityDescriptor::GetPrincipalSID(
                                        SZ_DNS_ADMIN_GROUP_W,
                                        &pSid );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, (
            "Error %lu: Failed to get DnsAdmin group sid\n",
            status ));
        //  if going to ASSERT() on status!=SUCCESS below, then do it here
        //      so we can tell at a glance what failed
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    // created & got sid
    //
    DNS_DEBUG( SD, ( "Retrieved DnsAdmin group sid\n" ));


Cleanup:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, (
            "Error %lu: cannot create group or get sid of Admin group\n",
            status ));
        ASSERT(FALSE);
    }

    else if ( fMissing )
    {
        // success + created a new dns admin group
        status = DNS_ERROR_NAME_DOES_NOT_EXIST;
    }

    g_pDnsAdminSid = pSid;

    return status;
}





#if 0
//
//  This function is unused?
//

BOOL
__stdcall
SD_IsDnsAdminClient(
    IN      HANDLE          hToken
    )
/*+++
Function   : SD_IsDnsAdminClientAccess
Description:
    test if client token has
        dns admin group  OR
        Administrators group
    in its membership list.

Parameters : client token
Return     : failure code, & results in bAccess
Remarks    : none.
---*/
{
    BOOL        bfoundDnsAdmin = FALSE;
    BOOL        bfoundAdmin = FALSE;
    NTSTATUS    status = ERROR_SUCCESS;
    PSID        padminSid = NULL;

    DNS_DEBUG( SD, ( "SD_IsDnsAdminClient()\n" ));

    if ( !g_pDnsAdminSid )
    {
        return FALSE;
    }

    //
    //  check for DnsAdmin SID
    //

    status = CSecurityDescriptor::IsSidInTokenGroups(
                                        hToken,
                                        g_pDnsAdminSid,
                                        &bfoundDnsAdmin);
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, ( "Error <%lu>: failed to verify sid in token groups\n", status ));
        bfoundDnsAdmin = FALSE;
        ASSERT(FALSE);
    }

    //
    //  read DomainAdmins SID and check it's access
    //

    SID_IDENTIFIER_AUTHORITY    ntAuthority = SECURITY_NT_AUTHORITY;

    status = RtlAllocateAndInitializeSid(
                    &ntAuthority,
                    1,
                    DOMAIN_GROUP_RID_ADMINS,
                    0, 0, 0, 0, 0, 0, 0,
                    &padminSid );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, (
            "Error <%lu>: failed to get Domain Admins' sid\n",
            status ));
        bfoundAdmin = FALSE;
        goto Cleanup;
    }

    status = CSecurityDescriptor::IsSidInTokenGroups(
                    hToken,
                    padminSid,
                    &bfoundAdmin );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, (
            "Error <%lu>: failed to verify sid in token groups\n",
            status ));
        bfoundAdmin = FALSE;
        ASSERT(FALSE);
    }

Cleanup:

    if ( padminSid )
    {
        delete padminSid;
    }
    return( bfoundAdmin || bfoundDnsAdmin );
}
#endif


NTSTATUS
__stdcall
SD_AddPrincipalToSD(
    IN       PSID                   pSid,           OPTIONAL
    IN       LPTSTR                 pwszName,       OPTIONAL
    IN       PSECURITY_DESCRIPTOR   pBaseSD,
    OUT      PSECURITY_DESCRIPTOR * ppNewSD,
    IN       DWORD                  AccessMask,
    IN       DWORD                  AceFlags,       OPTIONAL
    IN       PSID                   pOwner,         OPTIONAL
    IN       PSID                   pGroup,         OPTIONAL
    IN       BOOL                   bWhackExistingAce,
    IN       BOOL                   fTakeOwnership
    )
/*++

Routine Description (SD_AddPrinicipalToSD):

    Add an ace to security descriptor  based on in params

Arguments:

    pSid:       user's SID to add access (leave NULL to specify by name)
    pwszName:   user's name to add access
    pBaseSD:    SD to apply access
    ppResultSD: new SD
    AccessMask: what access to give user
    AceFlags:   additional flags such as inheritance
    bWhackExistingAce: if TRUE, remove existing ACE before adding new one
    fTakeOwnership: if TRUE, take ownership

Return Value:

    success status

Remarks:
    ppNewSD must be freed with FREE_HEAP

--*/
{
    DWORD                   status;
    CSecurityDescriptor     csd;
    DWORD                   lengthSD;
    PSID                    pUsrSid = pOwner ? pOwner : g_pServerSid;
    PSID                    pGrpSid = pGroup ? pGroup : g_pServerGroupSid;

    #if DBG
    Dbg_DumpSD( "Before add principle", pBaseSD );
    #endif
    
    status = csd.Attach( pBaseSD );
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to initialize from base SD\n" ));
        return NT_FROM_HRESULT( status );
    }

    //
    //  Conditionally whack any existing ACE from the ACL. If the principal
    //  already has an ACE we want to over-write it.
    //

    if ( pSid )
    {
        if ( bWhackExistingAce )
        {
            csd.Revoke( pSid );
        }

        status = csd.Allow(
                    pSid,
                    AccessMask,
                    AceFlags );
    }
    else
    {
        if ( bWhackExistingAce )
        {
            csd.Revoke( pwszName );
        }

        status = csd.Allow(
                    pwszName,
                    AccessMask,
                    AceFlags );
    }
    
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to add %S to SD\n", pwszName ));
        goto Cleanup;
    }

    //
    //  set owner & group
    //

    if ( fTakeOwnership )
    {
        status = csd.SetOwner( pUsrSid, FALSE );
        if ( FAILED( status ) )
        {
            DNS_DEBUG( SD, ( "Failed to set SD owner\n" ));
            goto Cleanup;
        }

        status = csd.SetGroup( pGrpSid, FALSE );
        if ( FAILED( status ) )
        {
            DNS_DEBUG( SD, ( "Failed to set SD group\n" ));
            goto Cleanup;
        }
    }

    //
    //  allocate copy
    //

    *ppNewSD = makeSecurityDescriptorCopy( csd );
    if ( !*ppNewSD )
    {
        status = GetLastError();
    }

    #if DBG
    Dbg_DumpSD( "After add principle", *ppNewSD );
    #endif
    
Cleanup:

    return ( NTSTATUS ) status;
}


NTSTATUS
__stdcall
SD_RemovePrincipalFromSD(
    IN      PSID                    pSid,           OPTIONAL
    IN      LPTSTR                  pwszName,       OPTIONAL
    IN      PSECURITY_DESCRIPTOR    pSD,
    IN      PSID                    pOwner,        OPTIONAL
    IN      PSID                    pGroup,        OPTIONAL
    OUT     PSECURITY_DESCRIPTOR *  ppNewSD
    )
/*++

Routine Description

    Remove the ACE for a named principle from an ACL.

Arguments:

    pSid -- SID of principle to remove (pass NULL to specify by name )
    
    pwszName -- name of principle to remove

    pSD -- security descriptor to operate upon

    pOwner -- new owner

    pGroup -- new group

    pNewSD -- copy of pSD with principle removed

Return Value:

    success status

Remarks:

    Caller must FREE_HEAP( pNewSD )

--*/
{
    DWORD                   status;
    CSecurityDescriptor     csd;
    PSID                    pUsrSid = pOwner ? pOwner : g_pServerSid;
    PSID                    pGrpSid = pGroup ? pGroup : g_pServerGroupSid;

    *ppNewSD = NULL;

    status = csd.Attach( pSD );
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to initialize from base SD\n" ));
        return NT_FROM_HRESULT( status );
    }

    #if DBG
    {
        PWSTR   pwsz = csd.GenerateSDString();

        DNS_DEBUG( SD, ( "SD_RemovePrincipalFromSD: SD before:\n  %S\n", pwsz ));
        LocalFree( pwsz );
    }
    #endif

    //
    //  Remove the ACE, then reset the group and owner.
    //

    if ( pSid )
    {
        csd.Revoke( pSid );
    }
    else
    {
        csd.Revoke( pwszName );
    }

    status = csd.SetGroup( pGrpSid, FALSE );
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to set group \n" ));
    }

    status = csd.SetOwner( pUsrSid, FALSE );
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to set SD owner\n" ));
    }

    //
    //  Copy to make self-relative and return.
    //

    *ppNewSD = makeSecurityDescriptorCopy( csd );
    if ( !*ppNewSD )
    {
        status = GetLastError();
    }

    #if DBG
    {
        PWSTR   pwsz = csd.GenerateSDString();

        DNS_DEBUG( SD, ( "SD_RemovePrincipalFromSD: SD after:\n  %S\n", pwsz ));
        LocalFree( pwsz );
    }
    #endif

    return ( NTSTATUS ) status;
}   //  SD_RemovePrincipalFromSD


BOOL
__stdcall
SD_DoesPrincipalHasAce(
    IN      LPTSTR                  pwszName,       OPTIONAL
    IN      PSID                    pSid,           OPTIONAL
    IN      PSECURITY_DESCRIPTOR    pSD
    )
/*++

Routine Description

    Returns true if the security descriptor contains an ACE for
    the specific principal.

Arguments:

    pwszName -- name of principle to remove
    
    pSid -- sid of principle to remove - used only if pwszName is NULL

    pSD -- security descriptor to operate upon

Return Value:

    success status

--*/
{
    CSecurityDescriptor     csd;

    if ( csd.Attach( pSD ) != ERROR_SUCCESS )
    {
        return FALSE;
    }

    if ( pwszName )
    {
        return csd.DoesPrincipleHaveAce( pwszName );
    }

    return csd.DoesPrincipleHaveAce( pSid );
}   //  SD_DoesPrincipalHasAce


NTSTATUS
__stdcall
SD_IsImpersonating(
    VOID
    )
/*++

Routine Description:

    Test if current thread is in impersonation context

Arguments:

    None.

Return Value:

    TRUE: Indeed impersonating right now
    FALSE: Not impersonating (process context).

Remarks:

--*/
{
    HANDLE      htoken;
    BOOL        bstatus;
    TOKEN_TYPE  toktype = TokenImpersonation;    // init on the safe side.
    DWORD       length;

    //
    //  get thread token, if not found use process token
    //

    bstatus = OpenThreadToken(
                  GetCurrentThread(),
                  TOKEN_QUERY,
                  TRUE,             // open as self
                  &htoken );
    if ( !bstatus )
    {
        bstatus = OpenProcessToken(
                      GetCurrentProcess(),
                      TOKEN_QUERY,
                      &htoken );
    }
    ASSERT( bstatus );

    //
    //  check if token type is impersonation
    //

    bstatus = GetTokenInformation(
                  htoken,
                  TokenType,
                  (LPVOID)&toktype,
                  sizeof(toktype),
                  &length );

    ASSERT( length == sizeof(toktype) && bstatus );

    CloseHandle( htoken );

    return toktype == TokenImpersonation;
}


}   //  extern "C"


#endif

//
//  End of sdutl.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rrrpc.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    rrrpc.c

Abstract:

    Domain Name System (DNS) Server

    Resource record RPC routines.

Author:

    Jim Gilroy (jamesg)     November 1995

Revision History:

--*/


#include "dnssrv.h"
#include "limits.h"

//
//  Minimum emumeration buffer length
//

#define MIN_ENUM_BUFFER_LENGTH 1024

//
//  Protect the end of the buffer
//

#define ENUMERATION_ALLOC_SIZE      (0x00040000)    // 256K

#define ENUM_BUFFER_PROTECT_LENGTH  16


//
//  Data selection macros
//

#define IS_NOENUM_NODE(p)       ( IS_SELECT_NODE(p) )

#define VIEW_AUTHORITY(flag)    (flag & DNS_RPC_VIEW_AUTHORITY_DATA)
#define VIEW_CACHE(flag)        (flag & DNS_RPC_VIEW_CACHE_DATA)
#define VIEW_GLUE(flag)         (flag & DNS_RPC_VIEW_GLUE_DATA)
#define VIEW_ROOT_HINT(flag)    (flag & DNS_RPC_VIEW_ROOT_HINT_DATA)
#define VIEW_ADDITIONAL(flag)   (flag & DNS_RPC_VIEW_ADDITIONAL_DATA)

//
//  Additional data viewing
//      - currently NS only (for root hints or glue)
//      - currently fixed limit at 100 nodes
//

#define IS_VIEW_ADDITIONAL_RECORD(prr)  ((prr)->wType == DNS_TYPE_NS)

#define VIEW_ADDITIONAL_LIMIT           (100)


//
//  Private protos
//

BOOL
ignoreNodeInEnumeration(
    IN      PDB_NODE        pNode
    );

DNS_STATUS
addNodeToRpcBuffer(
    IN OUT  PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode,
    IN      WORD            wRecordType,
    IN      DWORD           dwSelectFlag,
    IN      DWORD           dwEnumFlag
    );

PCHAR
writeStringToRpcBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCHAR           pchString,
    IN      DWORD           cchStringLength OPTIONAL
    );

DNS_STATUS
Dead_UpdateResourceRecordTtl(
    IN      PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRRUpdate,
    IN      DWORD           dwNewTtl
    );

DNS_STATUS
locateAndAccessCheckZoneNode(
    IN      LPSTR           pszZoneName,
    IN      LPSTR           pszNodeName,
    IN      BOOL            fCreate,
    OUT     PZONE_INFO *    ppZone,
    OUT     PDB_NODE *      ppNode
    );

DNS_STATUS
createAssociatedPtrRecord(
    IN      PDNS_ADDR       pDnsAddr,
    IN OUT  PDB_NODE        pHostNode,
    IN      DWORD           dwFlag
    );

DNS_STATUS
deleteAssociatedPtrRecord(
    IN      PDNS_ADDR       pDnsAddr,
    IN      PDB_NODE        pnodeAddress,
    IN      DWORD           dwFlag
    );

DNS_STATUS
updateWinsRecord(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pDeleteRR,
    IN      PDNS_RPC_RECORD pRecord         OPTIONAL
    );

BOOL
deleteNodeOrSubtreeForAdminPrivate(
    IN OUT  PDB_NODE        pNode,
    IN      BOOL            fDeleteSubtree,
    IN      PUPDATE_LIST    pUpdateList
    );



//
//  Record viewing API
//

DNS_STATUS
R_DnssrvEnumRecords(
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZoneName,
    IN      LPCSTR              pszNodeName,
    IN      LPCSTR              pszStartChild,
    IN      WORD                wRecordType,
    IN      DWORD               dwSelectFlag,
    IN      LPCSTR              pszFilterStart,
    IN      LPCSTR              pszFilterStop,
    OUT     PDWORD              pdwBufferLength,
    OUT     PBYTE *             ppBuffer
    )
/*++

    
Routine Description:

    Legacy version of R_DnssrvEnumRecords - no client version argument.

Arguments:

    See R_DnssrvEnumRecords2

Return Value:

    See R_DnssrvEnumRecords2

--*/
{
    DNS_STATUS      status;
    
    DNS_DEBUG( RPC, (
        "R_DnssrvEnumRecords() - non-versioned legacy call\n" ));

    status = R_DnssrvEnumRecords2(
                    DNS_RPC_W2K_CLIENT_VERSION,
                    0,
                    hServer,
                    pszZoneName,
                    pszNodeName,
                    pszStartChild,
                    wRecordType,
                    dwSelectFlag,
                    pszFilterStart,
                    pszFilterStop,
                    pdwBufferLength,
                    ppBuffer );
    return status;
}   //  R_DnssrvEnumRecords



DNS_STATUS
DNS_API_FUNCTION
R_DnssrvEnumRecords2(
    IN      DWORD               dwClientVersion,
    IN      DWORD               dwSettingFlags,
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZoneName,
    IN      LPCSTR              pszNodeName,
    IN      LPCSTR              pszStartChild,
    IN      WORD                wRecordType,
    IN      DWORD               dwSelectFlag,
    IN      LPCSTR              pszFilterStart,
    IN      LPCSTR              pszFilterStop,
    OUT     PDWORD              pdwBufferLength,
    OUT     PBYTE *             ppBuffer
    )
/*++

Routine Description:

    RPC record enumeration call.

    Enumerate records at node or its children.

Arguments:

    hServer -- server RPC handle

    pszZoneName -- zone name;  includes special zone names
                    (eg. ..RootHints or ..Cache)

    pszNodeName -- node name;  FQDN or relative to root (@ for root)

    pszStartChild -- child to restart enum after ERROR_MORE_DATA condition

    wRecordType -- optional record type filter (default is ALL)

    dwSelectFlag -- flag indicating records to select;
        - node and children
        - only children
        - only node
        - auth data only
        - additional data
        - cache data

    pszFilterStart -- not yet implemented

    pszFilterStop -- not yet implemented

    pdwBufferLength -- addr to receive buffer length

    ppBuffer -- addr to receive buffer

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of space in buffer.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PZONE_INFO      pzone = NULL;
    PDB_NODE        pnode;
    PDB_NODE        pnodeStartChild = NULL;
    PCHAR           pbuf = NULL;
    BUFFER          buffer;
    BOOL            bimpersonating = FALSE;

    DNS_DEBUG( RPC, (
        "R_DnssrvEnumRecords2():\n"
        "    dwClientVersion  = 0x%08X\n"
        "    pszZoneName      = %s\n"
        "    pszNodeName      = %s\n"
        "    pszStartChild    = %s\n"
        "    wRecordType      = %d\n"
        "    dwSelectFlag     = %p\n"
        "    pdwBufferLen     = %p\n",
        dwClientVersion,
        pszZoneName,
        pszNodeName,
        pszStartChild,
        wRecordType,
        dwSelectFlag,
        pdwBufferLength ));

    *pdwBufferLength = 0;
    *ppBuffer = NULL;
    
    //
    //  access check
    //

    status = RpcUtil_FindZone(
                pszZoneName,
                RPC_INIT_FIND_ALL_ZONES,
                &pzone );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    status = RpcUtil_SessionSecurityInit(
                NULL,
                pzone,
                PRIVILEGE_READ,
                RPC_INIT_FIND_ALL_ZONES,    //  return cache or root-hints zones
                &bimpersonating );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    //
    //  find domain node in desired zone
    //

    pnode = Lookup_FindZoneNodeFromDotted(
                pzone,
                ( LPSTR ) pszNodeName,
                LOOKUP_FIND_PTR,
                &status );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    //
    //  No node? What to do?
    //

    if ( pnode == NULL )
    {
        status = ERROR_SUCCESS;
        goto Done;
    }

    //
    //  allocate a big buffer, adequate for largest possible record
    //

    pbuf = (PBYTE) MIDL_user_allocate( ENUMERATION_ALLOC_SIZE );
    if ( !pbuf )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //  init buffer
    //      - for retail pad with a few bytes on end for safety

    InitializeFileBuffer(
        & buffer,
        pbuf,
#if DBG
        ENUMERATION_ALLOC_SIZE,
#else
        ENUMERATION_ALLOC_SIZE - ENUM_BUFFER_PROTECT_LENGTH,
#endif
        NULL );         //  no file

#if DBG
    memset(
        buffer.pchEnd - ENUM_BUFFER_PROTECT_LENGTH,
        0xd,                            // write hex d to buffer
        ENUM_BUFFER_PROTECT_LENGTH );
#endif

    //
    //  if starting child node, find it
    //      - if FQDN, lookup in tree
    //      - if single label, find child node
    //

    if ( pszStartChild  &&  *pszStartChild != 0 )
    {
        pnodeStartChild = NTree_FindOrCreateChildNode(
                            pnode,
                            (PCHAR) pszStartChild,
                            (DWORD) strlen( pszStartChild ),
                            0,          //  create flag
                            0,          //  memtag
                            NULL );     //  ptr for following node
        if ( !pnodeStartChild  ||  pnodeStartChild->pParent != pnode )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Done;
        }
    }

    //
    //  use last error to propagate out-of-space condition
    //      so clear error here

    SetLastError( ERROR_SUCCESS );

    //
    //  write node's records
    //  then write all node's children's records
    //

    if ( !pnodeStartChild )
    {
        if ( ! (dwSelectFlag & DNS_RPC_VIEW_ONLY_CHILDREN) )
        {
            status = addNodeToRpcBuffer(
                        &buffer,
                        pzone,
                        pnode,
                        wRecordType,
                        dwSelectFlag,
                        ENUM_DOMAIN_ROOT );
            if ( status != ERROR_SUCCESS )
            {
                goto Done;
            }
        }
        pnodeStartChild = NTree_FirstChild( pnode );
    }

    if ( ! (dwSelectFlag & DNS_RPC_VIEW_NO_CHILDREN) )
    {
        while ( pnodeStartChild )
        {
            status = addNodeToRpcBuffer(
                        &buffer,
                        pzone,
                        pnodeStartChild,
                        wRecordType,
                        dwSelectFlag,
                        0 );
            if ( status != ERROR_SUCCESS )
            {
                if ( status == ERROR_MORE_DATA || fDnsServiceExit )
                {
                    break;
                }
            }

            //  get next child

            pnodeStartChild = NTree_NextSiblingWithLocking( pnodeStartChild );
        }
    }

Done:

    //
    //  set buffer length written
    //      - using pdwBufferLength as available length ptr
    //

    if ( status == ERROR_SUCCESS || status == ERROR_MORE_DATA )
    {
        *pdwBufferLength = BUFFER_LENGTH_TO_CURRENT( &buffer );
        *ppBuffer = buffer.pchStart;
    }
    else
    {
        MIDL_user_free( pbuf );
    }

    DNS_DEBUG( RPC, (
        "Leave R_DnssrvEnumRecords()\n"
        "    Wrote %d byte record buffer at %p:\n"
        "    status = %p\n",
        *pdwBufferLength,
        *ppBuffer,
        status ));

    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcRecordsInBuffer(
            "EnumRecords Buffer:\n",
            *pdwBufferLength,
            *ppBuffer );
    }

    if ( bimpersonating )
    {
        RpcUtil_SessionComplete();
    }
    
    DnsRpcFixStatus( status );

    return status;
}



//
//  Record viewing utilities
//

BOOL
ignoreNodeInEnumeration(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Checks if node needs enumeration.

    May call itself recursively to determine need for enumeration.

Arguments:

    pNode -- ptr to node to check for enumeration

Return Value:

    TRUE if node should be enumerated.
    FALSE if node does NOT need enumeration.

--*/
{
    //
    //  records at node -- always enumerate
    //  sticky node -- admin wants enumerated
    //

    if ( IS_NOENUM_NODE(pNode) )
    {
        DNS_DEBUG( RPC, ( "Ignoring node (l=%s) -- NOENUM node\n", pNode->szLabel ));
        return TRUE;
    }
    if ( pNode->pRRList && !IS_NOEXIST_NODE(pNode) || IS_ENUM_NODE(pNode) )
    {
        return FALSE;
    }

    //
    //  no records, not sticky AND no children -- ignore
    //

    if ( ! pNode->pChildren )
    {
        DNS_DEBUG( RPC, (
            "Ignoring node (l=%s) -- no records, no children\n",
            pNode->szLabel ));
        return TRUE;
    }

    //
    //  check if children can be ignored
    //  returns FALSE immediately if encounters non-ignoreable node
    //

    else
    {
        PDB_NODE    pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            if ( ! ignoreNodeInEnumeration( pchild ) )
            {
                return FALSE;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
        return TRUE;
    }
}



DNS_STATUS
addNodeToRpcBuffer(
    IN OUT  PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode,
    IN      WORD            wRecordType,
    IN      DWORD           dwSelectFlag,
    IN      DWORD           dwEnumFlag
    )
/*++

Routine Description:

    Add node's resource records to RPC buffer.

Arguments:

    pBuffer - buffer to write to

    pNode - ptr to node

    wRecordType - record type

    dwSelectFlag - flag indicating records to select

    dwEnumFlag - flag indicating how to enum this node, based on where we
        are in enumeration

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of space in buffer.
    Error code on failure.

--*/
{
    PDNS_RPC_NODE   prpcNode;
    PCHAR           pch = pBuffer->pchCurrent;
    PCHAR           pbufEnd = pBuffer->pchEnd;
    PDB_RECORD      prr;
    DNS_STATUS      status = ERROR_SUCCESS;
    INT             i;
    INT             countAdditional = 0;
    PDB_NODE        arrayAdditional[ VIEW_ADDITIONAL_LIMIT ];

    prpcNode = ( PDNS_RPC_NODE ) pch;
    ASSERT( IS_DWORD_ALIGNED( pch ) );
    ASSERT( pNode != NULL );

    //  insure node header size is not messed up

    ASSERT( SIZEOF_DNS_RPC_NODE_HEADER
                == ((PBYTE)&prpcNode->dnsNodeName - (PBYTE)prpcNode) );

    //
    //  ignore node?
    //      - no RR data at node
    //      - not "sticky" domain user created
    //      - no children with RR data
    //

    if ( ignoreNodeInEnumeration(pNode) )
    {
        IF_DEBUG( RPC )
        {
            Dbg_DbaseNode(
                "Ignoring RPC enumeration of node",
                pNode );
        }
        return ERROR_SUCCESS;
    }

    DNS_DEBUG( RPC, (
        "addNodeToRpcBuffer()\n"
        "    Writing node (label %s) to buffer\n"
        "    Writing at %p, with buf end at %p\n"
        "    Select flags = %p\n"
        "    Enum flags   = %p\n"
        "    Type         = %d\n",
        pNode->szLabel,
        prpcNode,
        pbufEnd,
        dwSelectFlag,
        dwEnumFlag,
        wRecordType ));

    //
    //  fill in node structure
    //      - clear fields that are not definitely set
    //      - set child count
    //      - set length once finished writing name itself
    //      - "sticky" node set flag to alert admin to enumerate
    //      - always enum zone roots (show folder for delegation)
    //      whether there are children or not
    //

    if ( pbufEnd - (PCHAR)prpcNode < SIZEOF_NBSTAT_FIXED_DATA )
    {
        goto NameSpaceError;
    }
    prpcNode->dwFlags = 0;
    prpcNode->wRecordCount = 0;
    prpcNode->dwChildCount = pNode->cChildren;

    if ( prpcNode->dwChildCount == 0 && pNode->pChildren )
    {
        prpcNode->dwChildCount = 1;
        DNS_DEBUG( ANY, (
            "Node %p %s, has child ptr but no child count!\n",
            pNode,
            pNode->szLabel ));
        ASSERT( FALSE );
    }

    if ( IS_ENUM_NODE(pNode) || IS_ZONE_ROOT(pNode) || pNode->pChildren )
    {
        DNS_DEBUG( RPC, (
            "Enum at domain root, setting sticky flag\n" ));
        prpcNode->dwFlags |= DNS_RPC_FLAG_NODE_STICKY;

        if ( IS_ZONE_ROOT(pNode) )
        {
            prpcNode->dwFlags |= DNS_RPC_FLAG_ZONE_ROOT;

            if ( IS_AUTH_ZONE_ROOT(pNode) )
            {
                prpcNode->dwFlags |= DNS_RPC_FLAG_AUTH_ZONE_ROOT;
            }
            else if ( IS_DELEGATION_NODE(pNode) )
            {
                prpcNode->dwFlags |= DNS_RPC_FLAG_ZONE_DELEGATION;
            }
            ELSE_ASSERT( !pNode->pParent || !IS_ZONE_TREE_NODE(pNode) );
        }
    }

    //
    //  write node name
    //      - note name includes terminating NULL so admin need not
    //      copy from RPC buffer
    //
    //  for domain root write empty name
    //      - clear DOMAIN_ROOT flag for record enumeration
    //      - clear child count (already know it and having it
    //          causes NT4.0 admin to put up another domain
    //      - clear sticky flag
    //

    if ( dwEnumFlag & ENUM_DOMAIN_ROOT )
    {
        pch = Name_PlaceNodeLabelInRpcBuffer(
                    (PCHAR) &prpcNode->dnsNodeName,
                    pbufEnd,
                    DATABASE_ROOT_NODE
                    );
        prpcNode->dwChildCount = 0;
        prpcNode->dwFlags &= ~DNS_RPC_NODE_FLAG_STICKY;
    }
    else if ( dwEnumFlag & ENUM_NAME_FULL )
    {
        pch = Name_PlaceFullNodeNameInRpcBuffer(
                    (PCHAR) &prpcNode->dnsNodeName,
                    pbufEnd,
                    pNode
                    );
    }
    else
    {
        pch = Name_PlaceNodeLabelInRpcBuffer(
                    (PCHAR) &prpcNode->dnsNodeName,
                    pbufEnd,
                    pNode
                    );
    }

    //
    //  if name didn't write to packet, bail
    //      - if no error given, assume out-of-space error
    //

    if ( pch == NULL )
    {
        status = GetLastError();
        if ( status == ERROR_SUCCESS ||
            status == ERROR_MORE_DATA )
        {
            goto NameSpaceError;
        }
        ASSERT( FALSE );
        goto Done;
    }

    //
    //  set node length
    //  round name up to DWORD for record write
    //

    pch = (PCHAR) DNS_NEXT_DWORD_PTR(pch);
    pBuffer->pchCurrent = pch;

    prpcNode->wLength = (WORD)(pch - (PCHAR)prpcNode);

    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcNode(
            "RPC node (header) written to buffer",
            prpcNode );
    }

    //
    //  do NOT enumerate records at domain when enumerating domain's parent
    //
    //  generally all records at a domain, are enumerated only when domain folder
    //  itself is opened;  note that sticky flag is reset when actually
    //  enumerate the node under its own domain (ENUM_DOMAIN_ROOT flag)
    //
    //  however exeception is when precisely asking about particular node
    //  examples:
    //      - root hints NS host A records
    //      - more generally any additional data
    //

    if ( prpcNode->dwFlags & DNS_RPC_NODE_FLAG_STICKY )
    {
        if ( dwEnumFlag & (ENUM_NAME_FULL | ENUM_DOMAIN_ROOT) )
        {
            DNS_DEBUG( RPC, (
                "Continuing enum of node %s with sticky flag\n"
                "    Enum flag = %p\n",
                pNode->szLabel,
                dwEnumFlag ));
        }
        else
        {
            DNS_DEBUG( RPC, ( "Leave addNodeToRpcBuffer() => sticky node\n" ));
            goto Done;
        }
    }
    ASSERT( prpcNode->dwChildCount == 0 || (prpcNode->dwFlags & DNS_RPC_NODE_FLAG_STICKY) );

    //  if no records desired -- only writing name
    //  then we're done

    if ( wRecordType == 0 )
    {
        DNS_DEBUG( RPC, ( "Leave addNodeToRpcBuffer() => zero record type\n" ));
        goto Done;
    }

    //
    //  write resource records at node
    //

    LOCK_READ_RR_LIST(pNode);
    status = ERROR_SUCCESS;

    //  if cached name error, presumably should have no children that aren't
    //  also cached name errors, so should have ignored node

    if ( IS_NOEXIST_NODE(pNode) )
    {
        Dbg_DbaseNode(
            "WARNING:  cached name error at node with NON-ignored children\n",
            pNode );
        // ASSERT( pNode->cChildren );
        // ASSERT( prpcNode->dwChildCount );

        UNLOCK_READ_RR_LIST(pNode);
        goto Done;
    }

    prr = START_RR_TRAVERSE(pNode);

    while ( prr = NEXT_RR(prr) )
    {
        //  if at delegation (zone root and NOT root of enumeration)
        //  then only show NS records

        if ( IS_DELEGATION_NODE(pNode)  &&
                ! (dwEnumFlag & ENUM_DOMAIN_ROOT) &&
                prr->wType != DNS_TYPE_NS )
        {
            DNS_DEBUG( RPC, (
                "Skipping non-NS record at delegation node %s\n",
                pNode->szLabel ));
            continue;
        }

        //  Skip cached empty auth RRs.

        if ( IS_EMPTY_AUTH_RR( prr ) )
        {
            continue;
        }

        //  screen for data type and RR type

        if ( wRecordType != DNS_TYPE_ALL && wRecordType != prr->wType )
        {
            continue;
        }

        if ( IS_ZONE_RR(prr) )
        {
            if ( ! VIEW_AUTHORITY(dwSelectFlag) )
            {
                continue;
            }
        }
        else if ( IS_CACHE_RR(prr) )
        {
            if ( ! VIEW_CACHE(dwSelectFlag) )
            {
                continue;
            }
        }
        else if ( IS_NS_GLUE_RR(prr) )
        {
            if ( ! VIEW_GLUE(dwSelectFlag) )
            {
                //  allow NS glue enum
                //      - viewing auth data
                //      - glue is for subzone, NOT at zone root

                if ( !pZone ||
                        pNode == pZone->pZoneRoot ||
                        !VIEW_AUTHORITY(dwSelectFlag) )
                {
                    continue;
                }
            }
        }
        else if ( IS_GLUE_RR(prr) )
        {
            if ( ! VIEW_GLUE(dwSelectFlag) )
            {
                continue;
            }
        }
        else if ( IS_ROOT_HINT_RR(prr) )
        {
            if ( ! VIEW_ROOT_HINT(dwSelectFlag) )
            {
                continue;
            }
        }
        else    // what type is this?
        {
            ASSERT( FALSE );
            continue;
        }

        //
        //  do NOT enumerate database WINS RR if it is not the zone's WINS RR
        //      - need this or else end up enumerating two WINS records
        //

        if ( IS_WINS_TYPE(prr->wType) )
        {
            if ( pZone->pWinsRR != prr )
            {
                continue;
            }
        }

        ASSERT( pch && IS_DWORD_ALIGNED(pch) );

        status = Flat_WriteRecordToBuffer(
                    pBuffer,
                    prpcNode,
                    prr,
                    pNode,
                    dwSelectFlag );

        if ( status != ERROR_SUCCESS )
        {
            //  if out of space -- quit
            //  otherwise skip record and continue

            if ( status == ERROR_MORE_DATA )
            {
                UNLOCK_RR_LIST(pNode);
                goto NameSpaceError;
            }
            continue;
        }

        //
        //  additional data?
        //
        //  this is capable of finding addtional data for any PTR type
        //  but only immediate interest if NS glue data
        //
        //  can encapsulate in function if broader use is anticipated
        //  function could do memory alloc\realloc for buffer, so no
        //  limit, and then writing function could cleanup
        //
        //  NS glue lookup
        //  for root NS records:
        //      - zone auth data
        //      - another zone's auth data
        //      - other zone (glue, outside) data
        //
        //  for delegation NS records:
        //      - zone auth data
        //      - zone glue data
        //      - another zone's auth data
        //      - outside zone data
        //
        //  DEVNOTE: root-zone view any different
        //      still want to use\display other zone AUTH data
        //      as we'd certainly use for lookup;   however, don't want to
        //      hide the fact that we don't have it in our root-hints file
        //
        //  DEVNOTE: may need some sort of force writing whenever view
        //      data from another zone, that is NOT in root-hints or
        //      zone view?
        //

        if ( VIEW_ADDITIONAL(dwSelectFlag) &&
            IS_VIEW_ADDITIONAL_RECORD(prr) &&
            countAdditional < VIEW_ADDITIONAL_LIMIT )
        {
            PDB_NODE pnodeGlue;
            PDB_NODE pnodeGlueFromZone = NULL;

            //
            //  first check in zone
            //      - auth node
            //                  => final word, done
            //      - glue node
            //                  => done if delegation
            //                  => check other zones, if zone NS
            //      - outside
            //                  => check other zones
            //
            //  but for root zone, we always take what's here
            //

            pnodeGlue = Lookup_ZoneNode(
                            pZone,
                            prr->Data.NS.nameTarget.RawName,
                            NULL,       // no message
                            NULL,       // no lookup name
                            LOOKUP_FIND | LOOKUP_FQDN,
                            NULL,       // no closest name
                            NULL );     // following node ptr
            if ( pnodeGlue )
            {
                if ( IS_ZONE_ROOTHINTS(pZone) ||
                     IS_AUTH_NODE(pnodeGlue) ||
                     (IS_SUBZONE_NODE(pnodeGlue) && !IS_AUTH_ZONE_ROOT(pNode)) )
                {
                    //  done (see above)
                }
                else
                {
                    pnodeGlueFromZone = pnodeGlue;
                    pnodeGlue = NULL;
                }
            }

            //
            //  check all other zones for authoritative data
            //      - accept NO cache data
            //      - if not authoritative data, use any non-auth data
            //          found by zone lookup above
            //

            if ( !pnodeGlue && !IS_ZONE_ROOTHINTS(pZone) )
            {
                pnodeGlue = Lookup_NsHostNode(
                                & prr->Data.NS.nameTarget,
                                LOOKUP_NO_CACHE_DATA,
                                NULL,   // no favored zone (already did zone lookup)
                                NULL    // no delegated info needed
                                );

                if ( !pnodeGlue ||
                     ! IS_AUTH_NODE(pnodeGlue) )
                {
                     pnodeGlue = pnodeGlueFromZone;
                }
            }

            //  if found anything worthwhile, use it

            if ( pnodeGlue )
            {
                arrayAdditional[ countAdditional ] = pnodeGlue;
                countAdditional++;
            }
        }
    }

    //
    //  DEVNOTE: Admin tool should make direct call to do this
    //
    //  write LOCAL WINS\WINSR record which does not get written from
    //      database;  now only occurs on secondary zone
    //
    //  special case writing WINS records
    //      - in authoritative zone
    //      - at zone root
    //
    //  note:  we do AFTER writing RR, as admin picks LAST WINS
    //          RR received for use in property page
    //

    ASSERT( pch && IS_DWORD_ALIGNED(pch) );

    if ( pZone
            &&  pZone->pZoneRoot == pNode
            &&  IS_ZONE_SECONDARY(pZone)
            &&  pZone->fLocalWins
            &&  (wRecordType == DNS_TYPE_ALL || IS_WINS_TYPE(wRecordType)) )
    {
        //  note eliminating possibility of passing down record that
        //      just disappeared, ie. NULL zone pWinsRR ptr

        prr = pZone->pWinsRR;
        if ( prr )
        {
            status = Flat_WriteRecordToBuffer(
                        pBuffer,
                        prpcNode,
                        prr,
                        pNode,
                        dwSelectFlag );

            ASSERT( status != DNS_ERROR_RECORD_TIMED_OUT );
            ASSERT( IS_DWORD_ALIGNED(pch) );
            if ( status == ERROR_MORE_DATA || pch==NULL )
            {
                UNLOCK_RR_LIST(pNode);
                goto NameSpaceError;
            }
        }
    }

    UNLOCK_READ_RR_LIST(pNode);


    //
    //  write any additional data to buffer
    //

    for ( i=0; i<countAdditional; i++ )
    {
        status = addNodeToRpcBuffer(
                    pBuffer,
                    pZone,
                    arrayAdditional[ i ],
                    DNS_TYPE_A,
                    dwSelectFlag,
                    ENUM_NAME_FULL );
        if ( status != ERROR_SUCCESS )
        {
            //DnsDebugLock();
            DNS_PRINT((
                "ERROR:  enumerating additional data at node"
                "    status = %p\n",
                status ));
            Dbg_NodeName(
                "Failing additional node",
                arrayAdditional[ i ],
                "\n" );
            //DnsDebugUnlock();

            if ( status == ERROR_MORE_DATA )
            {
                goto NameSpaceError;
            }
            continue;
        }
    }

Done:

    //
    //  Done
    //
    //  skip node if
    //      - no records
    //      - no children
    //      - not sticky
    //      - not the node being enumerated
    //
    //  with filter it is possible that terminal node written with
    //  no records;  in that case, and if not sticky, don't reset
    //  position effectively dumping name data
    //

    if ( prpcNode->wRecordCount == 0  &&
         prpcNode->dwChildCount == 0  &&
         ! (prpcNode->dwFlags & DNS_RPC_NODE_FLAG_STICKY) &&
         ! (dwEnumFlag & ENUM_DOMAIN_ROOT) )
    {
        DNS_DEBUG( RPC, (
            "Skipping node %s in RPC enum -- no records, no kids\n",
            pNode->szLabel ));

        pBuffer->pchCurrent = (PCHAR) prpcNode;
    }

    //  on successful write, indicate node is complete in buffer

    if ( status == ERROR_SUCCESS )
    {
        prpcNode->dwFlags |= DNS_RPC_NODE_FLAG_COMPLETE;

        IF_DEBUG( RPC )
        {
            DnsDbg_RpcNode(
                "Complete RPC node written to buffer",
                prpcNode );
        }
        DNS_DEBUG( RPC2, (
            "Wrote %d RR for %*s into buffer from %p to %p\n",
            prpcNode->wRecordCount,
            prpcNode->dnsNodeName.cchNameLength,
            prpcNode->dnsNodeName.achName,
            prpcNode,
            pch ));
    }
#if DBG
    else
    {
        IF_DEBUG( RPC )
        {
            DnsDbg_RpcNode(
                "Partial RPC node written to buffer",
                prpcNode );
        }
        DNS_DEBUG( RPC2, (
            "Encountered error %d writing RR for %*s\n"
            "    %d records successfully written in buffer"
            " from %p to %p\n",
            status,
            prpcNode->dnsNodeName.cchNameLength,
            prpcNode->dnsNodeName.achName,
            prpcNode->wRecordCount,
            prpcNode,
            pch ));
    }
#endif
    return status;


NameSpaceError:

    DNS_DEBUG( RPC, (
        "Out of space attempting to write node name to buffer at %p\n"
        "    Node label = %s\n",
        (PCHAR) prpcNode,
        pNode->szLabel ));

    return ERROR_MORE_DATA;
}



PCHAR
writeStringToRpcBuffer(
    IN OUT  PCHAR   pchBuf,
    IN      PCHAR   pchBufEnd,
    IN      PCHAR   pchString,
    IN      DWORD   cchStringLength OPTIONAL
    )
/*++

Routine Description:

    Write string in RPC buffer format.  This means counted string length
    AND NULL termination.

    Raises DNS_EXCEPTION_NO_PACKET_SPACE, if buffer has insufficient space
    for string.

Arguments:

    cchStringLength -- optional length of string, if NOT given assumes
        NULL terminated string

Return Value:

    Ptr to next byte in buffer.

--*/
{
    if ( ! cchStringLength )
    {
        cchStringLength = strlen( pchString );
    }

    //  check that length may be represented in counted length string

    if ( cchStringLength > 255 )
    {
        DNS_PRINT((
            "ERROR:  string %.*s length = %d exceeds 255 limit!!!\n",
            cchStringLength,
            pchString,
            cchStringLength ));
        ASSERT( cchStringLength <= 255 );
        return NULL;
    }

    //  check for space in buffer

    if ( pchBuf + cchStringLength + 2 > pchBufEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return NULL;
    }

    // length in buf with NULL terminator

    *pchBuf++ = (UCHAR) cchStringLength + 1;

    RtlCopyMemory(
        pchBuf,
        pchString,
        cchStringLength );

    pchBuf += cchStringLength;
    *pchBuf = 0;    //  NULL terminate

    return ++pchBuf;
}




//
//  Record management API
//


DNS_STATUS
R_DnssrvUpdateRecord(
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZoneName,
    IN      LPCSTR              pszNodeName,
    IN      PDNS_RPC_RECORD     pAddRecord,
    IN      PDNS_RPC_RECORD     pDeleteRecord
    )
/*++

    
Routine Description:

    Legacy version of R_DnssrvUpdateRecord - no client version argument.

Arguments:

    See R_DnssrvUpdateRecord2

Return Value:

    See R_DnssrvUpdateRecord2

--*/
{
    DNS_STATUS      status;
    
    status = R_DnssrvUpdateRecord2(
                    DNS_RPC_W2K_CLIENT_VERSION,
                    0,
                    hServer,
                    pszZoneName,
                    pszNodeName,
                    pAddRecord,
                    pDeleteRecord );
    return status;
}   //  R_DnssrvUpdateRecord


DNS_STATUS
DNS_API_FUNCTION
R_DnssrvUpdateRecord2(
    IN      DWORD               dwClientVersion,
    IN      DWORD               dwSettingFlags,
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZoneName,
    IN      LPCSTR              pszNodeName,
    IN      PDNS_RPC_RECORD     pAddRecord,
    IN      PDNS_RPC_RECORD     pDeleteRecord
    )
/*++

Routine Description:

    RPC record update call.

    Update record at zone node.

Arguments:

    hServer -- server RPC handle

    pszZoneName -- zone name;  includes special zone names
                    (eg. ..RootHints or ..Cache)

    pszNodeName -- node name;  FQDN or relative to root (@ for root)

    pAddRecord -- record to add

    pDeleteRecord -- record to delete

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PZONE_INFO      pzone = NULL;
    PDB_NODE        pnode;
    PDB_RECORD      prrAdd = NULL;
    PDB_RECORD      prrDelete = NULL;
    BOOL            bimpersonating = FALSE;

    UPDATE_LIST     updateList;
    DWORD           updateFlag;
    PUPDATE         pupdate;
    PDB_RECORD      pdbaseRR;
    BOOL            fupdatePtr;
    DNS_ADDR        addIp;
    DNS_ADDR        deleteIp;

    DnsAddr_Reset( &addIp );
    DnsAddr_Reset( &deleteIp );

    IF_DEBUG( RPC )
    {
        DNS_PRINT((
            "R_DnssrvUpdateRecord():\n"
            "    dwClientVersion  = 0x%08X\n"
            "    pszZoneName      = %s\n"
            "    pszNodeName      = %s\n"
            "    pAddRecord       = %p\n"
            "    pDeleteRecord    = %p\n",
            dwClientVersion,
            pszZoneName,
            pszNodeName,
            pAddRecord,
            pDeleteRecord ));

        IF_DEBUG( RPC2 )
        {
            DnsDbg_RpcRecord(
                "    Update add record data:\n",
                pAddRecord );
            DnsDbg_RpcRecord(
                "    Update delete record data:\n",
                pDeleteRecord );
        }
    }

    //
    //  Access check. For file-backed zones, write access is required. For
    //  DS-integrated zones, only read access on the zone object is required.
    //  Active Directory will perform the "real" access check when we try to
    //  commit the write in the user's context.
    //

    status = RpcUtil_FindZone(
                pszZoneName,
                RPC_INIT_FIND_ALL_ZONES,
                &pzone );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    status = RpcUtil_SessionSecurityInit(
                NULL,
                pzone,
                PRIVILEGE_WRITE_IF_FILE_READ_IF_DS,
                0,                              //  flags
                &bimpersonating );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }
    
    //
    //  find domain node in desired zone
    //      - if only delete, then just do find (if no node => success)
    //

    pnode = Lookup_FindZoneNodeFromDotted(
                pzone,
                (LPSTR) pszNodeName,
                (pAddRecord || !pDeleteRecord) ? NULL : LOOKUP_FIND_PTR,
                & status );

    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }
    if ( !pnode )
    {
        ASSERT( !pAddRecord );
        goto Cleanup;
    }

    //
    //  if NO record specified, then just adding name
    //      - set bit to make sure we show name on later enumerations,
    //        even with no records or children
    //      - however if already an enum node, we return ALREADY_EXIST to help admin
    //          avoid duplicate display
    //

    if ( !pAddRecord && !pDeleteRecord )
    {
        if ( IS_ENUM_NODE(pnode) || IS_ZONE_ROOT(pnode) || pnode->cChildren )
        {
            DNS_DEBUG( RPC, (
                //"Returning ALREADY_EXISTS on domain (%s) create because \n"
                "WARNING:  RPC Creation of existing domain (%s):\n"
                "    enum flag = %d\n"
                "    zone root = %d\n"
                "    children  = %d\n",
                pnode->szLabel,
                IS_ENUM_NODE(pnode),
                IS_ZONE_ROOT(pnode),
                pnode->cChildren ));
            //status = DNS_ERROR_RECORD_ALREADY_EXISTS;
        }
        SET_ENUM_NODE( pnode );
        status = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    //  build desired records
    //

    if ( pAddRecord )
    {
        status = Dnssrv_Flat_RecordRead(
                    pzone,
                    pnode,
                    pAddRecord,
                    & prrAdd );
        if ( status != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
    }
    if ( pDeleteRecord )
    {
        status = Dnssrv_Flat_RecordRead(
                    pzone,
                    pnode,
                    pDeleteRecord,
                    & prrDelete );
        if ( status != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
    }

    //
    //  root hints
    //
    //  note: if successful prrAdd IS the database record, NULL
    //      ptr to avoid free
    //
    //  Note: In W2k and .NET, DNSMGR uses the cache zone name
    //  (erroneously) to add/delete root hints so for now we
    //  must allow this.
    //

    if ( !pzone ||
         !pszZoneName ||
         strcmp( pszZoneName, DNS_ZONE_CACHE_A ) == 0 ||    //  DNSMGR needs this!!
         strcmp( pszZoneName, DNS_ZONE_ROOT_HINTS_A ) == 0 )
    {
        if ( prrDelete )
        {
            pdbaseRR = RR_UpdateDeleteMatchingRecord(
                            pnode,
                            prrDelete );
            if ( pdbaseRR )
            {
                DNS_DEBUG( RPC, (
                    "Non-zone update delete record found = %p\n",
                    pdbaseRR ));

                if ( !IS_CACHE_RR(pdbaseRR) )
                {
                    MARK_ROOT_HINTS_DIRTY();
                }
                RR_Free( pdbaseRR );
            }
        }

        if ( pAddRecord )
        {
            status = RR_AddToNode(
                        NULL,
                        pnode,
                        prrAdd );
            if ( status != ERROR_SUCCESS )
            {
                goto Cleanup;
            }
            ASSERT( !IS_CACHE_RR(prrAdd) );
            prrAdd = NULL;
            MARK_ROOT_HINTS_DIRTY();
        }
    }

    //
    //  cache -- delete's only, no adding to cache
    //
    //  DEVNOTE: cache deletes -- either bogus, or delete's ALL records of type
    //
    //  DEVNOTE: make sure aren't deleting root hint data
    //      need delete function with Rank parameter\flag
    //

    else if ( pszZoneName &&
              strcmp( pszZoneName, DNS_ZONE_ROOT_HINTS_A ) == 0 )
    {
        if ( prrAdd )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ( prrDelete )
        {
            pdbaseRR = RR_UpdateDeleteMatchingRecord(
                            pnode,
                            prrDelete );
            if ( pdbaseRR )
            {
                DNS_DEBUG( RPC, (
                    "Non-zone update delete record found = %p\n",
                    pdbaseRR ));

                if ( !IS_CACHE_RR( pdbaseRR ) )
                {
                    MARK_ROOT_HINTS_DIRTY();
                }
                RR_Free( pdbaseRR );
            }
        }
    }

    //
    //  regular zones
    //

    else if ( pzone )
    {
        //
        //  special case adding LOCAL WINS to secondary zone
        //
        //  special case WINS records
        //  complicated behavior switching to create / delete /
        //      switch to local differ for primary and secondary
        //
        //  DEVNOTE: need to separate the building from the flag setting
        //              to get this to work;  this should really happen
        //              automatically when WINS added to authoritative zone
        //

        if ( IS_ZONE_SECONDARY( pzone ) && !IS_ZONE_STUB( pzone ) )
        {
            if ( ( pAddRecord  &&  IS_WINS_TYPE(pAddRecord->wType)) ||
                 ( pDeleteRecord  &&  IS_WINS_TYPE(pDeleteRecord->wType)) )
            {
                status = updateWinsRecord(
                            pzone,
                            pnode,
                            NULL,           // no delete record
                            pAddRecord );
                goto Cleanup;
            }
        }

        //  check for primary

        if ( ! IS_ZONE_PRIMARY(pzone) )
        {
            status = DNS_ERROR_INVALID_ZONE_TYPE;
            goto Cleanup;
        }

        //  init update list

        Up_InitUpdateList( &updateList );

        //  indicate admin update

        updateFlag = DNSUPDATE_ADMIN;

        //  if suppressing notify, set flag

        if ( (pAddRecord && (pAddRecord->dwFlags & DNS_RPC_FLAG_SUPPRESS_NOTIFY)) ||
             (pDeleteRecord && (pDeleteRecord->dwFlags & DNS_RPC_FLAG_SUPPRESS_NOTIFY)) )
        {
            updateFlag |= DNSUPDATE_NO_NOTIFY;
        }

        //
        //  build the update -- still need to do it under lock, because
        //      currently routines set flags, etc.
        //
        //  WARNING:  delete MUST go first, otherwise when duplicate data
        //      (TTL change), add will change TTL, but delete will delete record
        //
        //  DEVNOTE: not correct place to build, see above
        //

        if ( prrDelete )
        {
            pupdate = Up_CreateAppendUpdate(
                            & updateList,
                            pnode,
                            NULL,
                            0,
                            prrDelete );
            IF_NOMEM( !pupdate )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Cleanup;
            }
        }
        if ( prrAdd )
        {
            //  set aging
            //      - admin update by default turns aging OFF
            //      - set flag to turn on

            if ( pAddRecord->dwFlags & DNS_RPC_FLAG_AGING_ON )
            {
                updateFlag |= DNSUPDATE_AGING_ON;
            }
            else
            {
                updateFlag |= DNSUPDATE_AGING_OFF;
            }

            if ( pAddRecord->dwFlags & DNS_RPC_FLAG_OPEN_ACL )
            {
                updateFlag |= DNSUPDATE_OPEN_ACL;
            }

            pupdate = Up_CreateAppendUpdate(
                            & updateList,
                            pnode,
                            prrAdd,
                            0,
                            NULL );
            IF_NOMEM( !pupdate )
            {
                status = DNS_ERROR_NO_MEMORY;
                prrDelete = NULL;
                goto Cleanup;
            }
        }

        //
        //  PTR update?  --  save new IP address
        //  grab it here so, we know record still exists -- it could be
        //      deleted by someone else immediately after unlock
        //

        //
        //  always do PTR check on A record delete
        //
        //  currently admin UI has no checkbox for update-PTR on record delete
        //  so we'll just assume it is set;
        //
        //  DEVNOTE: temp hack, PTR flag on delete
        //

        if ( !pAddRecord && pDeleteRecord )
        {
            pDeleteRecord->dwFlags |= DNS_RPC_RECORD_FLAG_CREATE_PTR;
        }

        fupdatePtr = (pAddRecord &&
                        (pAddRecord->dwFlags & DNS_RPC_RECORD_FLAG_CREATE_PTR)) ||
                    (pDeleteRecord &&
                        (pDeleteRecord->dwFlags & DNS_RPC_RECORD_FLAG_CREATE_PTR));
        if ( fupdatePtr )
        {
            if ( prrAdd && prrAdd->wType == DNS_TYPE_A )
            {
                DnsAddr_BuildFromIp4( &addIp, prrAdd->Data.A.ipAddress, 0 );
            }
            if ( prrDelete && prrDelete->wType == DNS_TYPE_A )
            {
                DnsAddr_BuildFromIp4( &deleteIp, prrDelete->Data.A.ipAddress, 0 );
            }
        }
        ELSE
        {
            DNS_DEBUG( RPC, (
                "No PTR update for update\n" ));
        }

        //
        //  execute the update
        //
        //  ExecuteUpdates() cleans up failure case add RRs and
        //  deletes temporary delete RRs.
        //
        //  if ALREADY_EXISTS error, continue with additional records
        //  processing to handle successful delete (which could be separate record)
        //
        //  DEVNOTE: this new Up_ExecuteUpdate() also takes zone lock
        //      ideally this would be fine with a waiting-for-lock on the zone
        //
        //  note:  ExecuteUpdate() unlocks zone in all cases
        //

        prrAdd = NULL;
        prrDelete = NULL;

        status = Up_ExecuteUpdate(
                        pzone,
                        &updateList,
                        updateFlag );

        if ( status != ERROR_SUCCESS  &&
             status != DNS_ERROR_RECORD_ALREADY_EXISTS )
        {
            goto Cleanup;
        }


        IF_DEBUG( RPC )
        {
            Dbg_DbaseNode(
                "    Updated node:",
                pnode );
        }

        //
        //  update associate PTR records, if any
        //

        if ( fupdatePtr )
        {
            DNS_STATUS  tempStatus;

            if ( !DnsAddr_IsClear( &addIp ) )
            {
                tempStatus = createAssociatedPtrRecord( &addIp, pnode, updateFlag );
                if ( tempStatus != ERROR_SUCCESS )
                {
                    status = DNS_WARNING_PTR_CREATE_FAILED;
                }
            }
            if ( !DnsAddr_IsClear( &deleteIp ) )
            {
                tempStatus = deleteAssociatedPtrRecord( &deleteIp, pnode, updateFlag );
                if ( tempStatus != ERROR_SUCCESS )
                {
                    status = DNS_WARNING_PTR_CREATE_FAILED;
                }
            }
        }
        goto Cleanup;
    }


Cleanup:

    //
    //  If we have created a node in memory but failed to add a record to it,
    //  we must delete the node from memory. Otherwise an unauthorized admin
    //  could cause the DNS server to consume memory by submitting add requests.
    //
    
    if ( pnode && !pnode->pChildren && EMPTY_RR_LIST( pnode ) )
    {
        //
        //  Node seems to be empty. Lock it and test again to make absolutely
        //  certain it is empty, then remove it from memory. Note: failure is
        //  ignored. This should not fail but if it does there is nothing
        //  we can do about it.
        //
        
        LOCK_NODE( pnode );

        if ( !pnode->pChildren && EMPTY_RR_LIST( pnode ) )
        {
            //  WHAT TO DO???    NTree_RemoveNode( pnode );
        }
        
        UNLOCK_NODE( pnode );
    }
    
    DNS_DEBUG( RPC, (
        "Leaving R_DnssrvUpdateRecord():\n"
        "    status = %p (%d)\n",
        status, status ));

    RR_Free( prrDelete );
    RR_Free( prrAdd );

    //
    //  If a record was successfully modified, mark the server as configured.
    //  In principle we are looking for root hint modifications but if any
    //  record is modified it is reasonable to assume that the admin has taken
    //  sufficient action that the server can be considered to have been
    //  configured.
    //
    
    if ( status == ERROR_SUCCESS && !SrvCfg_fAdminConfigured )
    {
        DnsSrv_SetAdminConfigured( TRUE );
    }
    
    RpcUtil_SessionComplete();
    
    DnsRpcFixStatus( status );

    return status;
}



DNS_STATUS
Rpc_DeleteZoneNode(
    IN      DWORD           dwClientVersion,
    IN      PZONE_INFO      pZone,
    IN      LPSTR           pszProperty,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    )
/*++

Routine Description:

    Delete a name from database.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_NODE        pnode;
    PDB_NODE        pnodeClosest;
    UPDATE_LIST     updateList;
    BOOL            fdeleteSubtree;
    LPSTR           psznodeName;

    ASSERT( dwTypeId == DNSSRV_TYPEID_NAME_AND_PARAM );

    fdeleteSubtree = (BOOL) ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam;
    psznodeName = ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName;

    //
    //  If we've been passed the cache zone replace zone pointer
    //  with NULL. Node delete routines expect NULL when operating 
    //  on the cache zone.
    //

    if ( pZone && IS_ZONE_CACHE( pZone ) )
    {
        pZone = NULL;
    }

    DNS_DEBUG( RPC, (
        "Rpc_DeleteZoneNode():\n"
        "    pszZoneName      = %s\n"
        "    pszNodeName      = %s\n"
        "    fDeleteSubtree   = %d\n",
        pZone ? pZone->pszZoneName : "NULL (cache)",
        psznodeName,
        fdeleteSubtree ));

    //
    //  find node, if doesn't exist -- we're done
    //

    pnode = Lookup_ZoneNodeFromDotted(
                pZone,
                psznodeName,
                0,
                LOOKUP_NAME_FQDN,
                DNS_FIND_LOOKUP_PTR,
                &status );
    if ( !pnode )
    {
        if ( status == DNS_ERROR_NAME_DOES_NOT_EXIST )
        {
            status = ERROR_SUCCESS;
        }
        return status;
    }

    //
    //  if zone
    //      - can NOT delete zone root
    //      - init\lock zone for update
    //

    if ( pZone )
    {
        if ( pnode == pZone->pZoneRoot )
        {
            status = DNS_ERROR_INVALID_ZONE_OPERATION;
            goto Done;
        }

        //  check for primary or cache

        if ( !IS_ZONE_PRIMARY( pZone ) &&
             !IS_ZONE_CACHE( pZone ) )
        {
            status = DNS_ERROR_INVALID_ZONE_TYPE;
            goto Done;
        }

        //  init update list

        Up_InitUpdateList( &updateList );

        //  lock out update

        if ( !Zone_LockForAdminUpdate( pZone ) )
        {
            status = DNS_ERROR_ZONE_LOCKED;
            goto Done;
        }

        //
        //  if subtree delete in DS zone -- poll
        //
        //  the reason is unless we have an in-memory node we won't
        //  touch the node to do a delete, so we'll miss recently
        //  replicated in data;  (there's still a replication window
        //  here, for new nodes replicating in after our delete, but
        //  the poll lessens the problem)
        //
        //  of course, ultimately this points out that my flat zone
        //  DS model is non-ideal for this sort of operation, but it's
        //  not a frequent operation, so we can live with it
        //
        //  DEVNOTE: DS update gets post-delete in memory delete?
        //  DEVNOTE:  update should be able to suppress all reads, since
        //      just did poll
        //

        status = Ds_ZonePollAndUpdate(
                    pZone,
                    TRUE );         //  force polling
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  polling zone %s, before subtree delete!\n",
                pZone->pszZoneName ));
        }

    }

    //
    //  in cache
    //      - node MUST NOT be a zone node or delegation
    //

    ELSE_ASSERT( !IS_ZONE_TREE_NODE(pnode) );

    //
    //  delete the node and optionally subtree
    //  need update list if deleting zone nodes, otherwise not
    //

    if ( RpcUtil_DeleteNodeOrSubtreeForAdmin(
            pnode,
            pZone,
            pZone ? &updateList : NULL,
            fdeleteSubtree ) )
    {
        status = ERROR_SUCCESS;
    }
    else
    {
        status = DNS_WARNING_DOMAIN_UNDELETED;
    }

    //
    //  execute the update
    //      - DS write
    //      - memory write
    //      - DS unlock
    //      - don't overwrite UNDELETED warning status
    //
    //  DEVNOTE: flag to suppress DS read?  don't need read if just polled
    //      as all node's get delete;
    //      note:  generally admin node delete's need not read -- just delete node
    //

    if ( pZone )
    {
        DNS_STATUS upStatus;

        upStatus = Up_ExecuteUpdate(
                        pZone,
                        &updateList,
                        DNSUPDATE_ADMIN | DNSUPDATE_ALREADY_LOCKED );
        if ( upStatus != ERROR_SUCCESS )
        {
            status = upStatus;
        }
    }

Done:

    DNS_DEBUG( RPC, (
        "Leaving RpcDeleteNode() delete:\n"
        "    psznodeName  = %s\n"
        "    status       = %p\n",
        psznodeName,
        status ));

    return status;
}



DNS_STATUS
Rpc_DeleteCacheNode(
    IN      DWORD           dwClientVersion,
    IN      LPSTR           pszProperty,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    )
/*++

Routine Description:

    Delete a name from the cache.

    This is a stub to Rpc_DeleteZoneNode(), required as RPC server
    operations functions do not have a zone name.
    Unable to dispatch directly from zone operations table without a
    zone name specified, hence having essentially the same function
    in both tables was required.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    return Rpc_DeleteZoneNode(
                dwClientVersion,
                NULL,       // cache zone
                pszProperty,
                dwTypeId,
                pData );
}



DNS_STATUS
Rpc_DeleteRecordSet(
    IN      DWORD           dwClientVersion,
    IN      PZONE_INFO      pZone,
    IN      LPSTR           pszProperty,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    )
/*++

Routine Description:

    Delete a record set from database.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_NODE        pnode;
    PDB_NODE        pnodeClosest;
    UPDATE_LIST     updateList;
    WORD            type;
    LPSTR           psznodeName;

    ASSERT( dwTypeId == DNSSRV_TYPEID_NAME_AND_PARAM );

    type = (WORD) ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam;
    psznodeName = ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName;

    DNS_DEBUG( RPC, (
        "Rpc_DeleteRecordSet():\n"
        "    pszZoneName  = %s\n"
        "    pszNodeName  = %s\n"
        "    type         = %d\n",
        pZone->pszZoneName,
        psznodeName,
        type ));

    //
    //  find node, if doesn't exist -- we're done
    //

    pnode = Lookup_ZoneNodeFromDotted(
                pZone,
                psznodeName,
                0,
                LOOKUP_NAME_FQDN,
                DNS_FIND_LOOKUP_PTR,
                &status );
    if ( !pnode )
    {
        if ( status == DNS_ERROR_NAME_DOES_NOT_EXIST )
        {
            status = ERROR_SUCCESS;
        }
        return status;
    }

    //
    //  zone
    //      - init\lock zone for update
    //      - setup type delete update
    //      - send update for processing
    //

    if ( pZone )
    {
        //  check for primary

        if ( ! IS_ZONE_PRIMARY(pZone) )
        {
            status = DNS_ERROR_INVALID_ZONE_TYPE;
            goto Done;
        }

        //  init update list

        Up_InitUpdateList( &updateList );

        Up_CreateAppendUpdate(
            &updateList,
            pnode,
            NULL,               //  no add records
            type,               //  delete all records of given type
            NULL );             //  no delete records

        status = Up_ExecuteUpdate(
                        pZone,
                        &updateList,
                        DNSUPDATE_ADMIN );
    }

    //
    //  in cache
    //      - node MUST NOT be a zone node or delegation
    //

    else
    {
        PDB_RECORD  prrDeleted;
        DWORD       count;

        ASSERT( !IS_ZONE_TREE_NODE(pnode) );

        prrDeleted = RR_UpdateDeleteType(
                        NULL,
                        pnode,
                        type,
                        0 );

        count = RR_ListFree( prrDeleted );
        status = ERROR_SUCCESS;

        DNS_DEBUG( RPC, (
            "Deleted %d records from cache node %s\n",
            count,
            psznodeName ));
    }

Done:

    DNS_DEBUG( RPC, (
        "Leaving RpcDeleteRecordSet()\n"
        "    psznodeName  = %s\n"
        "    status       = %d (%p)\n",
        psznodeName,
        status, status ));

    return status;
}



DNS_STATUS
Rpc_DeleteCacheRecordSet(
    IN      DWORD           dwClientVersion,
    IN      LPSTR           pszProperty,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    )
/*++

Routine Description:

    Delete a record set from the cache.

    This is a stub to Rpc_DeleteRecordSet(), required as RPC server
    operations functions do not have a zone name.
    Unable to dispatch directly from zone operations table without a
    zone name specified, hence having essentially the same function
    in both tables was required.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    return Rpc_DeleteRecordSet(
                dwClientVersion,
                NULL,       // cache zone
                pszProperty,
                dwTypeId,
                pData );
}



DNS_STATUS
Rpc_ForceAgingOnNode(
    IN      DWORD           dwClientVersion,
    IN      PZONE_INFO      pZone,
    IN      LPSTR           pszProperty,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    )
/*++

Routine Description:

    Force aging on zone node or subtree.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_NODE        pnode;
    BOOL            bageSubtree;
    LPSTR           psznodeName;

    ASSERT( dwTypeId == DNSSRV_TYPEID_NAME_AND_PARAM );

    bageSubtree = (BOOL) ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam;
    psznodeName = ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName;

    DNS_DEBUG( RPC, (
        "Rpc_ForceAgingOnZoneNode():\n"
        "    pszZoneName  = %s\n"
        "    pszNodeName  = %s\n"
        "    bSubtree     = %d\n",
        pZone->pszZoneName,
        psznodeName,
        bageSubtree ));

    //
    //  zone op only
    //  only relevant on aging zones
    //

    ASSERT( pZone );
    if ( !pZone->bAging )
    {
        return DNS_ERROR_INVALID_ZONE_OPERATION;
    }

    //
    //  if node not given -- use zone root
    //  otherwise, find node, if doesn't exist -- we're done
    //

    if ( psznodeName )
    {
        pnode = Lookup_ZoneNodeFromDotted(
                    pZone,
                    psznodeName,
                    0,
                    LOOKUP_NAME_FQDN,
                    DNS_FIND_LOOKUP_PTR,
                    &status );
        if ( !pnode )
        {
            return status;
        }
    }
    else
    {
        pnode = pZone->pZoneRoot;
    }

    //
    //  make call to age zone
    //

    return Aging_ForceAgingOnNodeOrSubtree(
                pZone,
                pnode,
                bageSubtree );
}



//
//  Update utilites
//

BOOL
deleteNodeOrSubtreeForAdminPrivate(
    IN OUT  PDB_NODE        pNode,
    IN      BOOL            fDeleteSubtree,
    IN      PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Recursive database walk deleting records from tree.

    MUST lock out timeout thread while using this function.

Arguments:

    pNode -- ptr to root of subtree to delete

    fDeleteSubtree -- deleting entire subtree

    pUpdateList -- update list, if deleting zone nodes

Return Value:

    TRUE if subtree actually deleted.
    FALSE if subtree delete halted by undeletable records.

--*/
{
    BOOL    fSuccess = TRUE;
    BOOL    bAccessed;


    DNS_DEBUG( RPC2, (
        "deleteNodeOrSubtreeForAdminPrivate( %s )",
        pNode->szLabel ));

    //
    //  don't delete authoritative zone roots !
    //      - except current zone root, if doing zone delete
    //
    //  DEVNOTE: delegations on zone delete
    //      -- if going to absorb this territory then should keep delegation
    //          zone root / NS records / GLUE
    //

    if ( IS_AUTH_ZONE_ROOT(pNode) )
    {
        DNS_DEBUG( RPC, (
            "Stopping admin subtree delete, at authoritative zone root",
            "    %s\n",
            ((PZONE_INFO)pNode->pZone)->pszZoneName ));
        return FALSE;
    }

    //
    //  delete children
    //      - if undeletable nodes, set flag but continue delete
    //

    if ( pNode->pChildren  &&  fDeleteSubtree )
    {
        PDB_NODE pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            if ( ! deleteNodeOrSubtreeForAdminPrivate(
                            pchild,
                            fDeleteSubtree,
                            pUpdateList ) )
            {
                fSuccess = FALSE;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }

    //
    //  delete this node
    //

    if ( pNode->pRRList )
    {
        //
        //  for update just cut list and add it to update
        //  note, assuming roughly one record per node as typical value
        //

        if ( pUpdateList )
        {
            PUPDATE pupdate;

            pupdate = Up_CreateAppendUpdate(
                            pUpdateList,
                            pNode,
                            NULL,               // no add RR
                            DNS_TYPE_ALL,       // delete type
                            NULL );             // no delete RR
            IF_NOMEM( !pupdate )
            {
                return DNS_ERROR_NO_MEMORY;
            }

            //  if you could set an "already memory applied" flag
            //  you can execute this RIGHT HERE!
            //  but our paradigm is "build update, then execute intact"
            //
            //  pUpdateList->iNetRecords--;
            //  pNode->pRRList = NULL;
        }

        //
        //  cache delete
        //      - delete RR list at node
        //      - clear node flags
        //
        //  protect against deleting node being accessed, but otherwise clear out
        //  flags:
        //      -> enumeration flag, so empty node no longer shows up on admin
        //      -> wildcard flag (record gone)
        //      -> cname flag (record gone)
        //      -> zone root info (zone gone or would exit above)
        //
        //  do NOT clear flags if no delete node
        //
        //  this insures that NO_DELETE node flag is NOT cleared -- AND
        //  that ZONE_ROOT is never removed from DNS root node
        //
        //  if zone delete -- clear zone flag
        //

        else
        {
            RR_ListDelete( pNode );
            if ( !IS_NODE_NO_DELETE(pNode) )
            {
                CLEAR_EXCEPT_FLAG( pNode, (NODE_NOEXIST | NODE_SELECT | NODE_IN_TIMEOUT) );
            }
        }
    }

    //
    //  clear enum node on all nodes
    //  that way Anand will stop bugging me
    //

    CLEAR_ENUM_NODE( pNode );


    //
    //  return result from child delete
    //
    //  return will be TRUE, except when undeletable records in child nodes
    //

    return fSuccess;
}



BOOL
RpcUtil_DeleteNodeOrSubtreeForAdmin(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList,    OPTIONAL
    IN      BOOL            fDeleteSubtree
    )
/*++

Routine Description:

    Delete subtree for admin.

    If in zone, zone should be locked during delete.

Arguments:

    pNode -- ptr to root of subtree to delete

    pZone -- zone of deleted records

    pUpdateList -- update list if doing in zone delete

    fDeleteSubtree -- deleting subtree under node

    fDeleteZone -- deleting entire zone

Return Value:

    TRUE (BOOL return required for traversal function).

--*/
{
    ASSERT( !pZone || pZone->fLocked );

    DNS_DEBUG( RPC, (
        "Admin delete of subtree at node %s\n"
        "    In zone          = %s\n"
        "    Subtree delete   = %d\n",
        pNode->szLabel,
        pZone ? pZone->pszZoneName : NULL,
        fDeleteSubtree ));

    //
    //  call private function which does recursive delete
    //

    return deleteNodeOrSubtreeForAdminPrivate(
                    pNode,
                    fDeleteSubtree,
                    pUpdateList );
}



DNS_STATUS
createAssociatedPtrRecord(
    IN      PDNS_ADDR       pDnsAddr,
    IN OUT  PDB_NODE        pHostNode,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Create PTR record for A record being created.

    Assumes database lock is held.

Arguments:

    pDnsAddr -- to create reverse lookup node for

    pnodePtr -- node PTR will point to

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDB_RECORD      prr = NULL;
    PDB_NODE        pnodeReverse;
    PUPDATE         pupdate;
    PZONE_INFO      pzone;
    UPDATE_LIST     updateList;
    DB_NAME         targetName;
    DWORD           flag;

    DNS_DEBUG( RPC, (
        "createAssociatePtrRecord():\n"
        "    A node label = %s\n"
        "    IP = %s\n",
        pHostNode->szLabel,
        DNSADDR_STRING( pDnsAddr ) ));

    //
    //  find zone for reverse (PTR) node
    //  if not authoritative primary -- we're done
    //

    pnodeReverse = Lookup_FindNodeForIpAddress(
                        pDnsAddr,
                        LOOKUP_WITHIN_ZONE | LOOKUP_CREATE,
                        NULL );                             //  create
    if ( !pnodeReverse )
    {
        DNS_DEBUG( RPC, (
            "Associated IP %s, is not within zone so no creation\n",
            DNSADDR_STRING( pDnsAddr ) ));
        return DNS_ERROR_ZONE_DOES_NOT_EXIST;
    }
    pzone = pnodeReverse->pZone;
    if ( !pzone || !IS_AUTH_NODE(pnodeReverse) || IS_ZONE_SECONDARY(pzone) )
    {
        DNS_DEBUG( RPC, (
            "Associated PTR node not valid for create\n"
            "    Either NOT authoritative zone node OR in secondary\n"
            "    pnodeReverse = %s (auth=%d)\n"
            "    pzone        = %s\n",
            pnodeReverse->szLabel,
            pnodeReverse->uchAuthority,
            pzone ? pzone->pszZoneName : NULL ));
        return DNS_ERROR_ZONE_DOES_NOT_EXIST;
    }

    //  check for primary zone

    if ( ! IS_ZONE_PRIMARY(pzone) )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //  init update list

    Up_InitUpdateList( &updateList );

    //
    //  create PTR record and update
    //      - create full dbase name for node
    //      - create PTR
    //

    Name_NodeToDbaseName(
        & targetName,
        pHostNode );

    prr = RR_CreatePtr(
            & targetName,
            NULL,           // no string name
            DNS_TYPE_PTR,
            pzone->dwDefaultTtl,
            MEMTAG_RECORD_ADMIN );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    //
    //  create add update
    //

    pupdate = Up_CreateAppendUpdate(
                    &updateList,
                    pnodeReverse,
                    prr,
                    0,          //  no delete type
                    NULL );     //  no delete record
    IF_NOMEM( !pupdate )
    {
        RR_Free( prr );
        return DNS_ERROR_NO_MEMORY;
    }

    //
    //  execute and complete the update
    //

    ASSERT( dwFlag & DNSUPDATE_ADMIN );
    ASSERT( !(dwFlag & DNSUPDATE_ALREADY_LOCKED) );

    return Up_ExecuteUpdate(
                pzone,
                &updateList,
                dwFlag );       //  update flag
}



DNS_STATUS
deleteAssociatedPtrRecord(
    IN      PDNS_ADDR       pDnsAddr,
    IN      PDB_NODE        pHostNode,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Update PTR record.

Arguments:

    pDnsAddr -- address PTR points to

    pHostNode -- node containing A record

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDB_RECORD      prr = NULL;
    PDB_NODE        pnodeReverse;
    PZONE_INFO      pzone;
    UPDATE_LIST     updateList;
    DB_NAME         targetName;
    PUPDATE         pupdate;

    // dwFlags is specified in add, in del it isn't needed at the moment
    // but may in the future (aging issues).

    UNREFERENCED_PARAMETER(dwFlags);
    DNS_DEBUG( RPC, (
        "deleteAssociatedPtrRecord():\n"
        "    node label = %s\n"
        "    IP       = %s\n",
        pHostNode->szLabel,
        DNSADDR_STRING( pDnsAddr ) ));

    //
    //  find reverse lookup node
    //      - if doesn't exist, done
    //      - if not in authoritative primary zone, done
    //

    pnodeReverse = Lookup_FindNodeForIpAddress(
                        pDnsAddr,
                        0,                          //  flags
                        DNS_FIND_LOOKUP_PTR );
    if ( !pnodeReverse )
    {
        DNS_DEBUG( RPC, ( "Previous associated PTR node not found\n" ));
        return ERROR_SUCCESS;
    }
    pzone = (PZONE_INFO) pnodeReverse->pZone;
    if ( !pzone || !IS_AUTH_NODE(pnodeReverse) || IS_ZONE_SECONDARY(pzone) )
    {
        DNS_DEBUG( RPC, (
            "Associated PTR node not valid for delete\n"
            "    Either NOT authoritative zone node OR in secondary\n"
            "    pnodeReverse = %s (auth=%d)\n"
            "    pzone        = %s\n",
            pnodeReverse->szLabel,
            pnodeReverse->uchAuthority,
            pzone ? pzone->pszZoneName : NULL ));
        return ERROR_SUCCESS;
    }

    //  check for primary zone

    if ( !IS_ZONE_PRIMARY( pzone ) )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //  create update list

    Up_InitUpdateList( &updateList );

    //
    //  create PTR record
    //      - create full dbase name for node
    //      - create PTR
    //      - dummy record so TTL immaterial
    //

    Name_NodeToDbaseName(
        & targetName,
        pHostNode );

    prr = RR_CreatePtr(
            &targetName,
            NULL,           // no string name
            DNS_TYPE_PTR,
            pzone->dwDefaultTtl,
            MEMTAG_RECORD_ADMIN );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    //
    //  create delete update
    //

    pupdate = Up_CreateAppendUpdate(
                    &updateList,
                    pnodeReverse,
                    NULL,           // no add
                    0,
                    prr );
    IF_NOMEM( !pupdate )
    {
        RR_Free( prr );
        return DNS_ERROR_NO_MEMORY;
    }

    //
    //  execute and complete update
    //      - execute function free's dummy delete RR
    //

    return Up_ExecuteUpdate(
                pzone,
                & updateList,
                DNSUPDATE_ADMIN );
}



//
//  WINS / NBSTAT specific record management
//

DNS_STATUS
updateWinsRecord(
    IN OUT  PZONE_INFO          pZone,
    IN OUT  PDB_NODE            pNode,
    IN OUT  PDB_RECORD          pDeleteRR,
    IN      PDNS_RPC_RECORD     pRecord
    )
{
    DNS_STATUS  status = MAXDWORD;      // init to catch any possible missed assignment
    PDB_RECORD  prr = NULL;
    UPDATE_LIST updateList;
    PUPDATE     pupdate;
    BOOL        fsecondaryLock = FALSE;

    DNS_DEBUG( RPC, (
        "\nupdateWinsRecord():\n"
        "    pZone            = %p\n"
        "    pNode            = %p\n"
        "    pExistingWins    = %p\n"
        "    pNewRecord       = %p\n",
        pZone,
        pNode,
        pDeleteRR,
        pRecord ));

    //
    //  validate at an authoritative zone root
    //

    if ( !pZone || !pNode || pNode != pZone->pZoneRoot )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  primary zone needs to go through update process
    //

    if ( IS_ZONE_PRIMARY(pZone) )
    {
        //  init update list

        Up_InitUpdateList( &updateList );

        //  lock zone

        if ( !Zone_LockForAdminUpdate(pZone) )
        {
            return DNS_ERROR_ZONE_LOCKED;
        }

        //  add first then delete
        //      - lock database to do updates atomically

        Dbase_LockDatabase();

        //
        //  DEVNOTE: may need type delete for WINS!
        //      otherwise, missed WINS may be in database
        //      after install LOCAL WINS
        //

        if ( pRecord )
        {
            status = Dnssrv_Flat_RecordRead(
                        pZone,
                        pNode,
                        pRecord,
                        & prr );
            if ( status != ERROR_SUCCESS )
            {
                goto ZoneUpdateFailed;
            }
            ASSERT( prr );
            if ( !prr )
            {
                goto ZoneUpdateFailed;
            }

            pupdate = Up_CreateAppendUpdate(
                            & updateList,
                            pNode,
                            prr,
                            0,
                            NULL );

            //  update WINS record
            //  never age it
            //
            //  DEVNOTE: not clear why we're doing this

            status = RR_UpdateAdd(
                        pZone,
                        pNode,
                        prr,
                        pupdate,
                        DNSUPDATE_ADMIN | DNSUPDATE_AGING_OFF
                        );
            if ( status != ERROR_SUCCESS )
            {
                goto ZoneUpdateFailed;
            }
        }

        //
        //  delete existing record (NT4)
        //  do not care if doesn't find record as long as able to
        //      handle operation
        //

        if ( pDeleteRR && !prr )
        {
            status = RR_ListDeleteMatchingRecordHandle(
                        pNode,
                        pDeleteRR,
                        &updateList );
            if ( status != ERROR_SUCCESS )
            {
                IF_NOMEM( status == DNS_ERROR_NO_MEMORY )
                {
                    goto ZoneUpdateFailed;
                }
                status = ERROR_SUCCESS;
            }
        }

        //
        //  no record always means remove WINS lookup
        //
        //  this removes LOCAL WINS in all cases, it only removes DATABASE
        //  WINS for primary
        //

        if ( !pRecord )
        {
            Wins_StopZoneWinsLookup( pZone );
            status = ERROR_SUCCESS;
        }

        pZone->fRootDirty = TRUE;
        Dbase_UnlockDatabase();
        status = Up_ExecuteUpdate(
                    pZone,
                    &updateList,
                    DNSUPDATE_ADMIN );

        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( RPC, (
                "Error <%lu>: updateWinsRecord failed update\n",
                status ));
        }
    }

    //
    //  secondary zone
    //
    //  note, can not delete anything from database, let WINS create
    //  routine reset any pointers properly
    //

    else if ( IS_ZONE_SECONDARY(pZone) )
    {
        if ( !Zone_LockForAdminUpdate(pZone) )
        {
            return DNS_ERROR_ZONE_LOCKED;
        }
        fsecondaryLock = TRUE;

        if ( pRecord )
        {
            //  set as LOCAL as NT4 admin isn't setting flag properly
            //
            //  DEVNOTE: ultimately should reject non-local updates from secondary

            pRecord->Data.WINS.dwMappingFlag |= DNS_WINS_FLAG_LOCAL;

            status = Dnssrv_Flat_RecordRead(
                        pZone,
                        pNode,
                        pRecord,
                        & prr );
            if ( status != ERROR_SUCCESS )
            {
                goto Done;
            }
            ASSERT( prr );
            if ( !prr )
            {
                goto Done;
            }

            status = Wins_RecordCheck(
                        pZone,
                        pNode,
                        prr );
            if ( status != DNS_INFO_ADDED_LOCAL_WINS )
            {
                ASSERT( status != ERROR_SUCCESS );
                goto Done;
            }
            Zone_GetZoneInfoFromResourceRecords( pZone );
        }

        //  if no record delete LOCAL WINS

        else
        {
            Wins_StopZoneWinsLookup( pZone );
        }
        status = ERROR_SUCCESS;
    }
    else
    {
        return( ERROR_INVALID_PARAMETER );
    }

Done:

    //  zone is always dirty after this operation, even if secondary

    pZone->fDirty = TRUE;

    if ( fsecondaryLock )
    {
        Zone_UnlockAfterAdminUpdate( pZone );
    }

    DNS_DEBUG( RPC, (
        "Leave updateWinsRecord():\n"
        "    status = %p\n",
        status ));

    return status;

ZoneUpdateFailed:

    DNS_DEBUG( RPC, (
        "Leave updateWinsRecord():\n"
        "    status = %d (%p)\n",
        status, status ));

    RR_Free( prr );
    Dbase_UnlockDatabase();
    Zone_UnlockAfterAdminUpdate( pZone );
    return status;
}

//
//  End of rrrpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rrpacket.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    rrpacket.c

Abstract:

    Domain Name System (DNS) Server

    Routines to _write resource records to packet.

Author:

    Jim Gilroy (jamesg)     March, 1995

Revision History:

    jamesg  Jul 1995    --  Move these routines to this file
                        --  Round robining RRs
    jamesg  May 1997    --  Covert to dispatch table

--*/


#include "dnssrv.h"

//
//  MAX IPs that we'll handle, by default, when writing.
//
//  If need more than this need to realloc.
//

#define DEFAULT_MAX_IP_WRITE_COUNT  (1000)



VOID
prioritizeIpAddressArray(
    IN OUT  IP_ADDRESS      IpArray[],
    IN      DWORD           dwCount,
    IN      IP_ADDRESS      RemoteIp
    );



//
//  Write-to-wire routines for specific types
//

PCHAR
AWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write A record wire format into database record.

Arguments:

    pMsg - message being read

    pchData - ptr to RR data field

    pRR - ptr to database record

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    * ( UNALIGNED DWORD * ) pchData = pRR->Data.A.ipAddress;
    pchData += SIZEOF_IP_ADDRESS;

    //  clear WINS lookup flag when A record written

    pMsg->fWins = FALSE;
    return pchData;
}



PCHAR
CopyWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write to wire all types for which the database format is
    identical to the wire format (no indirection).

    Types included:
        HINFO
        ISDN
        X25
        WKS
        TXT
        NULL
        AAAA
        KEY

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    //  all these RR types, have no indirection
    //  bytes stored exactly as bits on the wire

    if ( pMsg->pBufferEnd - pchData < pRR->wDataLength )
    {
        DNS_DEBUG( WRITE, (
            "Truncation on wire write of flat record %p\n"
            "    packet buf end = %p\n"
            "    packet RR data = %p\n"
            "    RR datalength  = %d\n",
            pRR,
            pMsg->pBufferEnd,
            pchData,
            pRR->wDataLength ));
        return NULL;
    }
    RtlCopyMemory(
        pchData,
        &pRR->Data.TXT,
        pRR->wDataLength );
    pchData += pRR->wDataLength;
    return pchData;
}



PCHAR
NsWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write NS record to wire.

    Handles all single indirection types that require additional
    data processing:
        NS, CNAME, MB, MD, MF

    CNAME does NOT write have additional section processing during
    CNAME query, but uses additional info to store next node in CNAME
    trail.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    PCHAR   pchname = pchData;

    //  write target name to packet

    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                & pRR->Data.PTR.nameTarget );

    //
    //  save additional data
    //      - except for explicit CNAME query
    //

    if ( pMsg->fDoAdditional  &&
        ( pRR->wType != DNS_TYPE_CNAME || pMsg->wQuestionType != DNS_TYPE_CNAME ) )
    {
        Wire_SaveAdditionalInfo(
            pMsg,
            pchname,
            &pRR->Data.PTR.nameTarget,
            DNS_TYPE_A );
    }
    return pchData;
}



PCHAR
PtrWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write PTR compatible record to wire.

    Handles all single indirection records which DO NOT
    cause additional section processing.

    Includes: PTR, MR, MG

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                & pRR->Data.PTR.nameTarget );

    return pchData;
}



PCHAR
MxWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write MX compatible record to wire.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    PCHAR   pchname;

    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //
    //  - extra space in buffer so need not test adding preference
    //      value

    * ( UNALIGNED WORD * ) pchData = pRR->Data.MX.wPreference;
    pchData += sizeof( WORD );

    //
    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //

    pchname = pchData;
    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                & pRR->Data.MX.nameExchange );

    //
    //  DEVNOTE: RT supposed to additional ISDN and X25 also
    //

    if ( pMsg->fDoAdditional )
    {
        Wire_SaveAdditionalInfo(
            pMsg,
            pchname,
            & pRR->Data.MX.nameExchange,
            DNS_TYPE_A );
    }
    return pchData;
}



PCHAR
SoaWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write SOA record to wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    PDB_NAME    pname;
    PCHAR       pchname;

    //  SOA primary name server

    pname = &pRR->Data.SOA.namePrimaryServer;
    pchname = pchData;

    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                pname );
    if ( !pchData )
    {
        return NULL;
    }

    //  SOA zone admin

    pname = Name_SkipDbaseName( pname );

    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                pname );
    if ( !pchData )
    {
        return NULL;
    }

    //
    //  copy SOA fixed fields
    //      - dwSerialNo
    //      - dwRefresh
    //      - dwRetry
    //      - dwExpire
    //      - dwMinimumTtl

    RtlCopyMemory(
        pchData,
        &pRR->Data.SOA.dwSerialNo,
        SIZEOF_SOA_FIXED_DATA );

    pchData += SIZEOF_SOA_FIXED_DATA;

    //
    //  additional processing, ONLY when writing direct response for SOA
    //      - not when written to authoritity section
    //
    //  DEVNOTE: should we figure this out here?
    //

    if ( pMsg->fDoAdditional &&
        pMsg->wQuestionType == DNS_TYPE_SOA )
    {
        Wire_SaveAdditionalInfo(
            pMsg,
            pchname,
            & pRR->Data.SOA.namePrimaryServer,
            DNS_TYPE_A );
    }
    return pchData;
}



PCHAR
MinfoWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write MINFO and RP records to wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    PDB_NAME    pname;

    //  MINFO responsible mailbox
    //  RP responsible person mailbox

    pname = &pRR->Data.MINFO.nameMailbox;

    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                pname );
    if ( !pchData )
    {
        return NULL;
    }

    //  MINFO errors to mailbox
    //  RP text RR location

    pname = Name_SkipDbaseName( pname );

    return  Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                pname );
}



PCHAR
SrvWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write SRV record to wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    PDB_NAME    pname;
    PCHAR       pchname;

    //
    //  SRV <priority> <weight> <port> <target host>
    //

    * (UNALIGNED WORD *) pchData = pRR->Data.SRV.wPriority;
    pchData += sizeof( WORD );
    * (UNALIGNED WORD *) pchData = pRR->Data.SRV.wWeight;
    pchData += sizeof( WORD );
    * (UNALIGNED WORD *) pchData = pRR->Data.SRV.wPort;
    pchData += sizeof( WORD );

    //
    //  write target host
    //  - save for additional section
    //  - except when target is root node to give no-service-exists response
    //

    pname = & pRR->Data.SRV.nameTarget;

    if ( IS_ROOT_NAME(pname) )
    {
        *pchData++ = 0;
    }
    else
    {
        pchname = pchData;
        pchData = Name_WriteDbaseNameToPacketEx(
                    pMsg,
                    pchData,
                    pname,
                    FALSE       // no compression
                    );
        if ( pMsg->fDoAdditional )
        {
            Wire_SaveAdditionalInfo(
                pMsg,
                pchname,
                pname,
                DNS_TYPE_A );
        }
    }
    return pchData;
}



PCHAR
NbstatWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write WINS-R record to wire.

Arguments:

    pMsg - message being read

    pchData - ptr to RR data field

    pRR - ptr to database record

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    ASSERT( pRR->wDataLength >= MIN_NBSTAT_SIZE );

    //
    //  NBSTAT fixed fields
    //      - flags
    //      - lookup timeout
    //      - cache timeout
    //  note these are stored in HOST order for easy use
    //

    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINSR.dwMappingFlag );
    pchData += sizeof( DWORD );
    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINSR.dwLookupTimeout );
    pchData += sizeof( DWORD );
    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINSR.dwCacheTimeout );
    pchData += sizeof( DWORD );

    //  NBSTAT domain

    pchData = Name_WriteDbaseNameToPacketEx(
                pMsg,
                pchData,
                & pRR->Data.WINSR.nameResultDomain,
                FALSE       // no compression
                );
    return pchData;
}



PCHAR
WinsWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write WINS-R record to wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    DWORD   lengthServerArray;

    ASSERT( pRR->wDataLength >= MIN_WINS_SIZE );

    //
    //  WINS fixed fields
    //      - flags
    //      - lookup timeout
    //      - cache timeout
    //      - server count
    //  note these are stored in HOST order for easy use
    //

    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINS.dwMappingFlag );
    pchData += sizeof( DWORD );
    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINS.dwLookupTimeout );
    pchData += sizeof( DWORD );
    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINS.dwCacheTimeout );
    pchData += sizeof( DWORD );
    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINS.cWinsServerCount );
    pchData += sizeof( DWORD );

    //
    //  WINS server addresses are already in network order, just copy
    //

    lengthServerArray = pRR->wDataLength - SIZEOF_WINS_FIXED_DATA;

    ASSERT( lengthServerArray ==
            pRR->Data.WINS.cWinsServerCount * sizeof(IP_ADDRESS) );

    RtlCopyMemory(
        pchData,
        pRR->Data.WINS.aipWinsServers,
        lengthServerArray
        );
    pchData += lengthServerArray;
    return pchData;
}



PCHAR
OptWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write OPT resource record to wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    return pchData;
} // OptWireWrite



PCHAR
SigWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write SIG resource record to wire - DNSSEC RFC 2535

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    int     sigLength;

    //
    //  Copy fixed fields.
    //

    if ( pMsg->pBufferEnd - pchData < SIZEOF_SIG_FIXED_DATA )
    {
        return NULL;
    }

    RtlCopyMemory(
        pchData,
        &pRR->Data.SIG,
        SIZEOF_SIG_FIXED_DATA
        );
    pchData += SIZEOF_SIG_FIXED_DATA;

    //
    //  Write signer's name.
    //

    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                &pRR->Data.SIG.nameSigner );
    if ( !pchData )
    {
        goto Cleanup;
    }

    //
    //  Write binary signature blob.
    //

    sigLength = pRR->wDataLength -
                SIZEOF_SIG_FIXED_DATA -
                DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner );
    if ( pMsg->pBufferEnd - pchData < sigLength )
    {
        return NULL;
    }

    RtlCopyMemory(
        pchData,
        ( PBYTE ) &pRR->Data.SIG.nameSigner +
            DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner ),
        sigLength );
    pchData += sigLength;

    Cleanup:

    return pchData;
} // SigWireWrite



PCHAR
NxtWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write NXT resource record to wire - DNSSEC RFC 2535

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    //
    //  Write next name.
    //

    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                &pRR->Data.NXT.nameNext );
    if ( !pchData )
    {
        goto Cleanup;
    }

    //
    //  Write type bit map. For simplicity we will write the
    //  entire 16 bytes, but we could write less if there are
    //  zeros in the high bits.
    //

    if ( pMsg->pBufferEnd - pchData < DNS_MAX_TYPE_BITMAP_LENGTH )
    {
        return NULL;
    }

    RtlCopyMemory(
        pchData,
        pRR->Data.NXT.bTypeBitMap,
        DNS_MAX_TYPE_BITMAP_LENGTH );
    pchData += DNS_MAX_TYPE_BITMAP_LENGTH;

    Cleanup:

    return pchData;
} // NxtWireWrite



//
//  Write RR to wire functions
//

RR_WIRE_WRITE_FUNCTION   RRWireWriteTable[] =
{
    CopyWireWrite,      //  ZERO -- default for unspecified types

    AWireWrite,         //  A
    NsWireWrite,        //  NS
    NsWireWrite,        //  MD
    NsWireWrite,        //  MF
    NsWireWrite,        //  CNAME
    SoaWireWrite,       //  SOA
    NsWireWrite,        //  MB
    PtrWireWrite,       //  MG
    PtrWireWrite,       //  MR
    CopyWireWrite,      //  NULL
    CopyWireWrite,      //  WKS
    PtrWireWrite,       //  PTR
    CopyWireWrite,      //  HINFO
    MinfoWireWrite,     //  MINFO
    MxWireWrite,        //  MX
    CopyWireWrite,      //  TXT
    MinfoWireWrite,     //  RP
    MxWireWrite,        //  AFSDB
    CopyWireWrite,      //  X25
    CopyWireWrite,      //  ISDN
    MxWireWrite,        //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigWireWrite,       //  SIG
    CopyWireWrite,      //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    CopyWireWrite,      //  AAAA
    NULL,               //  LOC
    NxtWireWrite,       //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvWireWrite,       //  SRV
    CopyWireWrite,      //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    OptWireWrite,       //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    WinsWireWrite,       //  WINS
    NbstatWireWrite      //  WINS-R
};



WORD
processCachedEmptyAuthRR(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,          OPTIONAL
    IN      WORD            wNameOffset,    OPTIONAL
    IN      PDB_RECORD      pEmptyAuthRR )
/*++

Routine Description:

    Use the found empty auth RR to build the answer to the query.

Arguments:

    pMsg -- the query

    pNode -- owner node of answer name

    wNameOffset -- if node not specified, offset of owner name

    pEmptyAuthRR -- cached empty auth RR that matches the query

Return Value:

    Number of RRs written to packet. This will generally be one
    if the cached empty auth response is good or zero if there
    was a problem with the cached data.

--*/
{
    WORD        wRRsWritten = 0;
    PDB_NODE    psoaNode;
    PDB_RECORD  psoaRR;
    BOOL        fdiscardRR = FALSE;
    UCHAR       oldSection = pMsg->Section;

    ASSERT( pMsg );
    ASSERT( pEmptyAuthRR );
    ASSERT( IS_EMPTY_AUTH_RR( pEmptyAuthRR ) );

    //
    //  Make sure we have a valid SOA node pointer. If not, discard the
    //  cached RR.
    //

    if ( ( psoaNode = pEmptyAuthRR->Data.EMPTYAUTH.psoaNode ) == NULL )
    {
        ASSERT( pEmptyAuthRR->Data.EMPTYAUTH.psoaNode );
        fdiscardRR = TRUE;
        goto Done;
    }

    //
    //  Find the SOA RR in the SOA node. If the SOA RR can't be found
    //  discard the cached RR.
    //

    if ( ( psoaRR = RR_FindNextRecord(
                        psoaNode,
                        DNS_TYPE_SOA,
                        NULL,
                        pMsg->dwQueryTime ) ) == NULL )
    {
        fdiscardRR = TRUE;
        goto Done;
    }

    //
    //  Add the SOA to the authority section of the response. Note: this
    //  function does not currently add the SOA primary server as an
    //  additional section work item unless the query is for type SOA.
    //  So we will not get the primary server's address in the additional
    //  section. See SoaWireWrite.
    //

    SET_TO_WRITE_AUTHORITY_RECORDS( pMsg );

    if ( !Wire_AddResourceRecordToMessage(
                        pMsg,
                        psoaNode,
                        0,              //  name offset
                        psoaRR,
                        0 ) )           //  flags
    {
        ASSERT( !"Wire_AddResourceRecordToMessage failed" );
        goto Done;
    }

    //
    //  Empty auth response has been successfully used!
    //

    ++wRRsWritten;
    ++CURRENT_RR_SECTION_COUNT( pMsg );
    pMsg->fRecurseIfNecessary = FALSE;

    //
    //  Cleanup and return.
    //

    Done:

    if ( fdiscardRR && pNode )
    {
        RR_ListDeleteType( pNode, pEmptyAuthRR->wType );
    }

    if ( !wRRsWritten )
    {
        pMsg->Section = oldSection;
    }

    return wRRsWritten;
}   //  processCachedEmptyAuthRR



//
//  General write to wire routines
//

BOOL
Wire_AddResourceRecordToMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,              OPTIONAL
    IN      WORD            wNameOffset,        OPTIONAL
    IN      PDB_RECORD      pRR,
    IN      DWORD           flags
    )
/*++

Routine Description:

    Add resource record to DNS packet in the transport format.

    Note:  MUST be holding RR list lock during this function call to
            insure that record remains valid during write.

Arguments:

    pchMsgInfo - Info for message to write to.

    pNode - The "owner" node of this resource record.

    wNameOffset - Offset to name to write instead of node name

    pRR - The RR information to include in answer.

    flags - Flags to modify write operation.

Return Value:

    TRUE if successful.
    FALSE if unable to write:
        timed out, cache file record, out of space in packet, etc

--*/
{
    register PCHAR          pch = pMsg->pCurrent;
    PCHAR                   pchstop = pMsg->pBufferEnd;
    PCHAR                   pchdata;
    PDNS_WIRE_RECORD        pwireRR;
    DWORD                   ttl;
    DWORD                   queryTime;
    WORD                    netType;
    RR_WIRE_WRITE_FUNCTION  pwriteFunction;
    INT                     bufferAdjustmentForOPT = 0;
    BOOL                    rc = TRUE;

    ASSERT( pRR != NULL );

#if DBG
    pchdata = NULL;
#endif

    DNS_DEBUG( WRITE2, (
        "Writing RR (t=%d) (r=%d) at %p to location %p\n"
        "    Node ptr = %p\n"
        "    wNameOffset = 0x%04hx\n"
        "    AvailLength = %d\n",
        pRR->wType,
        RR_RANK(pRR),
        pRR,
        pch,
        pNode,
        wNameOffset,
        pchstop - pch ));

    //
    //  cache hint?
    //  cache hints from cache file are NEVER sent in response
    //

    if ( IS_ROOT_HINT_RR(pRR) )
    {
        rc = FALSE;
        goto Done;
    }

    //
    //  Is the RR a cached empty auth response? If so, this is a bug.
    //  Cached empty auth RRs should never be passed to this function.
    //

    if ( IS_EMPTY_AUTH_RR( pRR ) )
    {
        ASSERT( !IS_EMPTY_AUTH_RR( pRR ) );
        rc = FALSE;
        goto Done;
    }

    //
    //  Need to reserve space in buffer for OPT?
    //

    if ( pMsg->Opt.fInsertOptInOutgoingMsg && pRR->wType != DNS_TYPE_OPT )
    {
        pMsg->pBufferEnd -= DNS_MINIMIMUM_OPT_RR_SIZE;
        bufferAdjustmentForOPT = DNS_MINIMIMUM_OPT_RR_SIZE;
        DNS_DEBUG( WRITE2, (
            "adjusted buffer end by %d bytes to reserve space for OPT\n",
            bufferAdjustmentForOPT ));
    }

    //
    //  writing from node name -- for zone transfer
    //

    if ( pNode )
    {
        pch = Name_PlaceNodeNameInPacket(
                pMsg,
                pch,
                pNode
                );
        if ( !pch )
        {
            goto Truncate;
        }
    }

    //
    //  write ONLY compressed name -- normal response case
    //
    //  DEVNOTE: cleanup when fixed (?)

    else
    {
#if DBG
        HARD_ASSERT( wNameOffset );
#else
        if ( !wNameOffset )
        {
            goto Truncate;
        }
#endif
        //  compression should always be BACK ptr

        ASSERT( OFFSET_FOR_COMPRESSED_NAME(wNameOffset) < DNSMSG_OFFSET(pMsg, pch) );

        INLINE_WRITE_FLIPPED_WORD( pch, COMPRESSED_NAME_FOR_OFFSET(wNameOffset) );
        pch += sizeof( WORD );
    }

    //
    //  fill RR structure
    //      - extra space for RR header in packet buffer so no need to test
    //      - set datalength once we're finished
    //

    pwireRR = (PDNS_WIRE_RECORD) pch;

    INLINE_WRITE_FLIPPED_WORD( &pwireRR->RecordType, pRR->wType );
    WRITE_UNALIGNED_WORD( &pwireRR->RecordClass, DNS_RCLASS_INTERNET );

    //
    //  TTL
    //      - cache data TTL is in form of timeout time
    //      - regular authoritative data TTL is STATIC TTL in net byte order
    //

    if ( IS_CACHE_RR(pRR) )
    {
        ttl = RR_PacketTtlForCachedRecord( pRR, pMsg->dwQueryTime );
        if ( ttl == (-1) )
        {
            rc = FALSE;
            goto Done;
        }
    }
    else
    {
        ttl = pRR->dwTtlSeconds;
    }
    WRITE_UNALIGNED_DWORD( &pwireRR->TimeToLive, ttl );

    //
    //  save ptr to RR data, so can calculate data length
    //

    pch = pchdata = (PCHAR)( pwireRR + 1 );

    //
    //  write RR data
    //

    pwriteFunction = (RR_WIRE_WRITE_FUNCTION)
                        RR_DispatchFunctionForType(
                            (RR_GENERIC_DISPATCH_FUNCTION *) RRWireWriteTable,
                            pRR->wType );
    if ( !pwriteFunction )
    {
        ASSERT( FALSE );
        goto Truncate;
    }
    pch = pwriteFunction(
                pMsg,
                pchdata,
                pRR );

    //
    //  verify within packet
    //
    //  pch is NULL, if name writing exceeds packet length
    //

    if ( pch==NULL  ||  pch > pchstop )
    {
        DNS_PRINT((
            "ERROR:  DnsWireWrite routine failure for record type %d.\n\n\n",
            pRR->wType ));
        goto Truncate;
    }

    //
    //  If necessary, add a KEY entry to the additional data.
    //
    //  We do not have the node name in DB form at this point so pass NULL.
    //

    if ( flags & DNSSEC_INCLUDE_KEY )
    {
        Wire_SaveAdditionalInfo(
            pMsg,
            DNSMSG_PTR_FOR_OFFSET( pMsg, wNameOffset ),
            NULL,   // no DB name available
            DNS_TYPE_KEY );
    }

    //
    //  write RR data length
    //

    ASSERT( pch >= pchdata );

    INLINE_WRITE_FLIPPED_WORD(
        &pwireRR->DataLength,
        ( WORD ) ( pch - pchdata ) );

    //
    //  reset message info
    //

    pMsg->pCurrent = pch;

    DNS_DEBUG( WRITE2, (
        "Wrote RR at %p to msg info at %p\n"
        "    New avail length = %d\n"
        "    New pCurrent = %p\n",
        pRR,
        pMsg,
        pMsg->pBufferEnd - pch,
        pch ));

Done:

    pMsg->pBufferEnd += bufferAdjustmentForOPT;
    return rc;

Truncate:

    pMsg->pBufferEnd += bufferAdjustmentForOPT;

    //
    //  Set truncation bit
    //
    //  Assume all failures sent here are length problems
    //
    //     only Name_PlaceNodeNameInPacket() has other
    //     source of error and this would be a corrupt database
    //

    pMsg->Head.Truncation = 1;

    DNS_DEBUG( WRITE, (
        "Failed to write RR at %p to msg at %p\n"
        "    pCurrent         = %p\n"
        "    Buffer Length    = %d\n"
        "    Buffer End       = %p\n"
        "    pch Final        = %p\n"
        "    pchdata          = %p\n",
        pRR,
        pMsg,
        pMsg->pCurrent,
        pMsg->BufferLength,
        pMsg->pBufferEnd,
        pch,
        pchdata ));

    return FALSE;
}



WORD
Wire_WriteRecordsAtNodeToMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      WORD            wNameOffset     OPTIONAL,
    IN      DWORD           flags
    )
/*++

Routine Description:

    Write all matching RRs at node to packet.

    Also resets fWins flag in packet, if WINS lookup is indicated.

Arguments:

    pMsg - message to write to.

    pNode - node being looked up

    wType - type being looked up

    wNameOffset - offset to previous name in packet, to write as compressed
                    RR name, instead of writing node name

    flags - control specifics of records written

Return Value:

    Count of resource records written.

--*/
{
    PDB_RECORD  prr;
    PDB_RECORD  pprevRRWritten;
    WORD        countRR = 0;        // count of records written
    PDB_NODE    pnodeUseName;
    WORD        startOffset = 0;    // init for ppc compiler
    BOOL        fdelete = FALSE;    // timed out record found
    UCHAR       rank;
    UCHAR       foundRank = 0;
    DWORD       rrWriteFlags = flags & 0xF; // first nibble flags by default
    BOOL        fIncludeSig;
    BOOL        fIsCompoundQuery;
    BOOL        fIsMailbQuery;
    BOOL        fIncludeDnsSecInResponse;
    WORD        wDesiredSigType;
    WORD        wMaxSigScanType;

    PDB_RECORD  prrLastMatch = NULL;
    PDB_RECORD  prrBeforeMatch;

    //
    //  If an invalid compression offset was specified, clear the offset.
    //  This will force the name to be generated in full from the node.
    //
    
    if ( wNameOffset >= DNSSRV_MAX_COMPRESSION_OFFSET )
    {
        ASSERT( wNameOffset < DNSSRV_MAX_COMPRESSION_OFFSET );
        wNameOffset = 0;
    }

    //
    //  cached name error node
    //

    LOCK_RR_LIST( pNode );
    if ( IS_NOEXIST_NODE( pNode ) )
    {
        UNLOCK_RR_LIST( pNode );
        return 0;
    }

#if DBG
    //  Verify handling CNAME issue properly

    TEST_ASSERT( !IS_CNAME_NODE(pNode) ||
                 wType == DNS_TYPE_CNAME ||
                 wType == DNS_TYPE_ALL ||
                 IS_ALLOWED_WITH_CNAME_TYPE(wType) );
#endif


    //
    //  type ALL
    //      - do NOT write records if non-authoritative and have NOT
    //          gotten recursive answer, unless the type ALL TTL at
    //          the node is still valid
    //      - allowing additional record processing
    //      - do allow WINS lookup,
    //          but disallow the case where looking up at CNAME
    //

    pMsg->fWins = FALSE;
    if ( wType == DNS_TYPE_ALL )
    {
        if ( !IS_AUTH_NODE( pNode ) &&
             !pMsg->fQuestionCompleted &&
             ( pNode->dwTypeAllTtl == 0 || 
               pMsg->dwQueryTime >= pNode->dwTypeAllTtl  ) )
        {
            UNLOCK_RR_LIST(pNode);
            return 0;
        }

        //  Note:  can't find explicit RFC reference for avoiding Additional
        //      on type ALL queries;  and Malaysian registrar apparently uses
        //      type ALL instead of NS in verifying delegations
        //
        //pMsg->fDoAdditional = FALSE;

        pMsg->fWins = (BOOLEAN) (SrvCfg_fWinsInitialized && !IS_CNAME_NODE(pNode));
    }

    //
    //  determine RR owner name format
    //      => if compression, do not use node name
    //      => no compression,
    //          - use node name
    //          - save pCurrent to determine later compression

    if ( wNameOffset )
    {
        pnodeUseName = NULL;
    }
    else
    {
        pnodeUseName = pNode;
        startOffset = DNSMSG_OFFSET( pMsg, pMsg->pCurrent );
    }

    //
    //  According to RFC 2535 secions 4.1.8, SIGs are not to be included
    //  in ANY queries. Note: BIND apparently does not respect this.
    //

    if ( wType == DNS_TYPE_ALL )
    {
        rrWriteFlags &= ~DNSSEC_ALLOW_INCLUDE_SIG;
    }

    //
    //  RR prescan to determine if KEY RR is present at this name.
    //
    //  Set the KEY flag bit if and only if:
    //      1) there is a KEY at this name
    //      2) the type of query requires inclusions of KEYs as add data
    //      3) this query is doing additional data
    //
    //  DEVNOTE: there are priority rules for inclusion of KEYs which we are
    //  not yet implementing: see RFC 2535 section 3.5
    //
    //  DEVNOTE: we really should just have a flag on the node that says
    //  whether or not there is a key!
    //

    fIncludeDnsSecInResponse = DNSMSG_INCLUDE_DNSSEC_IN_RESPONSE( pMsg );

    if ( flags & DNSSEC_ALLOW_INCLUDE_KEY &&
        fIncludeDnsSecInResponse &&
        pMsg->fDoAdditional &&
        ( wType == DNS_TYPE_SOA || wType == DNS_TYPE_NS ||
          wType == DNS_TYPE_A || wType == DNS_TYPE_AAAA ) )
    {
        prr = START_RR_TRAVERSE(pNode);

        while ( prr = NEXT_RR(prr) )
        {
            if ( prr->wType == DNS_TYPE_KEY )
            {
                rrWriteFlags |= DNSSEC_INCLUDE_KEY;
                break;
            }
        }
    }

    //
    //  Set some locals to simplify/optimize decisions in the loop below.
    //

    #define DNS_BOGUS_SIG_TYPE  0xEFBE
    
    fIncludeSig = fIncludeDnsSecInResponse;
    wDesiredSigType = fIncludeSig ? htons( wType ) : DNS_BOGUS_SIG_TYPE;
    fIsMailbQuery = wType == DNS_TYPE_MAILB;
    fIsCompoundQuery = wType == DNS_TYPE_ALL || fIsMailbQuery || fIncludeSig;
    wMaxSigScanType =
        ( fIncludeSig && DNS_TYPE_SIG > wType ) ?
            DNS_TYPE_SIG : wType;

    //
    //  Loop through records at node, writing appropriate ones
    //

    pprevRRWritten = NULL;

    prr = START_RR_TRAVERSE( pNode );
    prrBeforeMatch = prr;

    while ( prr = NEXT_RR( prr ) )
    {
        BOOL        bAddedRRs;

        //  
        //  There are two tricky compound queries.
        //  1) MAILB - include all mailbox types (possibly obsolete).
        //  2) SIG - include appropriate SIG RR for non-compound queries.
        //
        //  First test: if the RR type equals the query type, include the RR.
        //

        if ( prr->wType != wType )
        {
            //
            //  For round robin we need ptr to the RR before the first match.
            //

            if ( prr->wType < wType )
            {
                prrBeforeMatch = prr;
            }

            //
            //  Loop termination test: terminate if we're past the query type 
            //  and we don't need to pick up any other RRs for a compound query.
            //  If we're not past the query type but this is not a compound
            //  query, we can skip this RR.
            //
        
            if ( !fIsCompoundQuery )
            {
                if ( prr->wType > wType )
                {
                    break;
                }
                continue;
            }
            
            if ( wType == DNS_TYPE_ALL )
            {
                //
                //  Conditionally exclude specific RR types from TYPE_ALL queries.
                //

                if ( prr->wType == DNS_TYPE_SIG && !fIncludeSig )
                {
                    continue;
                }

                //
                //  Do not include empty auths in ALL query responses.
                //

                if ( IS_EMPTY_AUTH_RR( prr ) )
                {
                    continue;
                }

                //  Drop through and include this RR.
            }

            //
            //  If this is a MAILB query, skip non-mail RR types. If we're 
            //  past the final mailbox type we can terminate. NOTE: I'm not
            //  handling SIGs properly for MAILB queries. Unless someone
            //  complains it's not worth the extra work - MAILB is an
            //  experimental, obsolete type anyways. The problem is that
            //  currently we only need to include ONE supplementary SIG
            //  RR in the answer. To include more than one requires us to
            //  track a list of types
            //

            else if ( fIsMailbQuery )
            {
                if ( prr->wType > DNS_TYPE_MR )
                {
                    break;
                }
                if ( !DnsIsAMailboxType( prr->wType ) ||
                     IS_EMPTY_AUTH_RR( prr ) )
                {
                    continue;
                }
                //  Drop through and include this RR.
            }

            //
            //  If we're past both the SIG type and the query type we can quit.
            //  If this RR is a SIG of the wrong type, skip this RR. 
            //

            else 
            {
                if ( prr->wType > wMaxSigScanType )
                {
                    break;
                }
                if ( prr->wType != DNS_TYPE_SIG ||
                    prr->Data.SIG.wTypeCovered != wDesiredSigType ||
                    IS_EMPTY_AUTH_RR( prr ) )
                {
                    continue;
                }
                //  Drop through and include this RR.
            }
        }

        //
        //  This RR is a match and so may be included in the response.
        //
        //  if already have data, then do NOT use data of lower rank (eg. glue)
        //  CACHE_HINT data NEVER goes on to the wire
        //

        rank = RR_RANK( prr );
        if ( foundRank != rank )
        {
            if ( foundRank )
            {
                ASSERT( rank < foundRank );
                if ( countRR == 0 )
                {
                    prrBeforeMatch = prr;
                }
                continue;
            }
            if ( rank == RANK_ROOT_HINT )
            {
                if ( countRR == 0 )
                {
                    prrBeforeMatch = prr;
                }
                prrBeforeMatch = prr;
                continue;
            }
            foundRank = rank;
        }
        ASSERT( !IS_ROOT_HINT_RR(prr) );

        //
        //  skip all CACHED records when any are timed out
        //
        //  DEVNOTE: could combine with rank test
        //      foundRank == rank && IS_CACHE_RANK(rank) and fdelete
        //

        if ( fdelete && IS_CACHE_RR(prr) )
        {
            foundRank = 0;
            if ( countRR == 0 )
            {
                prrBeforeMatch = prr;
            }
            continue;
        }

        //
        //  Is this RR a cached empty auth response?
        //

        if ( IS_EMPTY_AUTH_RR( prr ) )
        {
            countRR = processCachedEmptyAuthRR(
                                pMsg,
                                pNode,
                                wNameOffset,
                                prr );
            goto Done;
        }

        //
        //  Add the RR to the answer.
        //

        bAddedRRs = Wire_AddResourceRecordToMessage(
                        pMsg,
                        pnodeUseName,
                        wNameOffset,
                        prr,
                        rrWriteFlags );
        rrWriteFlags &= ~DNSSEC_INCLUDE_KEY; // Only call once with this flag

        if ( !bAddedRRs )
        {
            //
            //  When packet is full break out.
            //  DNSSEC special case: if there is not enough space to write
            //  out the SIG for an RRset in the additional section, we
            //  should quit but we should not set the truncation bit.
            //

            if ( pMsg->Head.Truncation == TRUE )
            {
                if ( IS_SET_TO_WRITE_ADDITIONAL_RECORDS( pMsg ) &&
                    prr->wType == DNS_TYPE_SIG )
                {
                    pMsg->Head.Truncation = FALSE;
                }
                break;
            }

            //  otherwise, we've hit timed out record
            //      - continue processing, but set flag to delete node

            fdelete = TRUE;
            foundRank = 0;
            continue;
        }

        //  wrote record
        //      - inc count
        //      - if first RR, setup to compress name of any following RR

        if ( prr->wType == wType )
        {
            prrLastMatch = prr;
        }
        countRR++;
        if ( ! wNameOffset )
        {
            pnodeUseName = NULL;
            wNameOffset = startOffset;
        }
    }

    //
    //  Round robin: juggle list
    //      - cut the first match from the list
    //      - first match's new next ptr is last match's current next ptr
    //      - last match's next ptr is first match
    //

    if ( !IS_COMPOUND_TYPE( wType ) &&
         countRR > 1 &&         //  can be >1 if additional RRs written!
         prrLastMatch &&
         prrBeforeMatch &&
         SrvCfg_fRoundRobin &&
         IS_ROUND_ROBIN_TYPE( wType ) &&
         NEXT_RR( prrBeforeMatch ) != prrLastMatch )
    {
        PDB_RECORD      prrFirstMatch = prrBeforeMatch->pRRNext;
        
        ASSERT( prrFirstMatch != NULL );

        prrBeforeMatch->pRRNext = prrFirstMatch->pRRNext;
        prrFirstMatch->pRRNext = prrLastMatch->pRRNext;
        prrLastMatch->pRRNext = prrFirstMatch;
    }

    //
    //  set count of RR processed
    //  return count to caller
    //

    CURRENT_RR_SECTION_COUNT( pMsg ) += countRR;

    Done:

    //
    //  If found timed out record, cleanse list of timed out records
    //

    if ( fdelete )
    {
        RR_ListTimeout( pNode );
    }

    UNLOCK_RR_LIST( pNode );

    return countRR;
}



VOID
Wire_SaveAdditionalInfo(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      PDB_NAME        pName,
    IN      WORD            wType
    )
/*++

Routine Description:

    Save additional info when writing record.

Arguments:

    pMsg - message

    pchName - ptr to byte in packet where additional name written

    pName - database name written, useful as follow this reference

    wType - type of additional processing;

Return Value:

    None.

--*/
{
    PADDITIONAL_INFO    padditional;
    DWORD               countAdditional;

    ASSERT( pMsg->fDoAdditional );

    DNS_DEBUG( WRITE2, (
        "Enter Wire_SaveAdditionalInfo()\n" ));

    //
    //  test should be done by caller, but for safety protect
    //

    if ( !pMsg->fDoAdditional )
    {
        return;
    }

    //
    //  verify space in additional array
    //

    padditional = &pMsg->Additional;
    countAdditional = padditional->cCount;

    if ( countAdditional >= padditional->cMaxCount )
    {
        ASSERT( countAdditional == padditional->cMaxCount );
        DNS_DEBUG( WRITE, (
            "WARNING:  out of additional record space processing\n"
            "    packet at %p\n",
            pMsg ));
        return;
    }

    //
    //  save additional data
    //      - node
    //      - offset in packet
    //
    //  DEVNOTE: need type field in additional data?
    //      - when do additional processing that requires security
    //
    //  DEVNOTE: should either change type on additional ptr
    //      OR
    //      combine with compression and understand cast
    //

    padditional->pNameArray[ countAdditional ]   = pName;
    padditional->wOffsetArray[ countAdditional ] = DNSMSG_OFFSET( pMsg, pchName );
    padditional->wTypeArray[ countAdditional ]   = wType;

    padditional->cCount = ++countAdditional;
    return;
}



PDB_NODE
Wire_GetNextAdditionalSectionNode(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Get next additional section node.

Arguments:

    pMsg -- ptr to query

Return Value:

    Ptr to next additional node -- if found.
    NULL otherwise.

--*/
{
    PADDITIONAL_INFO    padditional;
    DWORD               i;
    WORD                offset;
    PDB_NODE            pnode;

    DNS_DEBUG( LOOKUP, (
        "Wire_GetNextAdditionalSectionNode( %p )\n",
        pMsg ));

    //
    //  additional records to write?
    //
    //  note:  currently ALL additional records are A records
    //          if this changes would need to keep array of
    //          additional record type also
    //

    padditional = &pMsg->Additional;

    while( HAVE_MORE_ADDITIONAL_RECORDS(padditional) )
    {
        pMsg->wTypeCurrent = DNS_TYPE_A;

        i = padditional->iIndex++;
        offset = padditional->wOffsetArray[i];

        ASSERT( 0 < offset && offset < MAXWORD );
        ASSERT( DNSMSG_PTR_FOR_OFFSET(pMsg, offset) < pMsg->pCurrent );

        pnode = Lookup_NodeForPacket(
                    pMsg,
                    DNSMSG_PTR_FOR_OFFSET( pMsg, offset ),
                    0       // no flags
                    );
        if ( !pnode )
        {
            DNS_DEBUG( LOOKUP, (
                "Unable to find node for additional data in pMsg %p\n"
                "    additional index = %d\n",
                pMsg,
                i ));
            continue;
        }
        pMsg->wOffsetCurrent = offset;

        pMsg->fQuestionRecursed = FALSE;
        pMsg->fQuestionCompleted = FALSE;
        SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg);

        return pnode;
    }

    return NULL;
}




//
//  Query for type A is the common special case
//

WORD
Wire_WriteAddressRecords(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wNameOffset
    )
/*++

Routine Description:

    Write A records at node to packet.

    This is only for answering question where node already has packet
    offset.   This is fine, because we're only interested in this
    for question answer and additional data, which both have existing
    offsets.

Arguments:

    pMsg - msg to write to

    pNode - ptr to node to write A records of

    wNameOffset - offset to node name in packet;  NOT optional

Return Value:

    Count of records written.
    Zero if no valid records available.

--*/
{
    register PDB_RECORD                     prr;
    register PDNS_COMPRESSED_A_RECORD       pCAR;

    PDB_RECORD          prrLastA = NULL;    // init for PPC comp
    PDB_RECORD          prrBeforeA;
    PCHAR               pchstop;
    DWORD               minTtl = MAXDWORD;
    DWORD               ttl;
    DWORD               tempTtl;
    WORD                countWritten = 0;
    WORD                foundCount = 0;
    INT                 fdelete = FALSE;
    BOOL                fcontinueAfterLimit = FALSE;
    UCHAR               foundRank = 0;
    UCHAR               rank;
    IP_ADDRESS          ip;
    IP_ADDRESS          writeIpArray[ DEFAULT_MAX_IP_WRITE_COUNT ];
    INT                 bufferAdjustmentForOPT = 0;
    BOOL                foundCachedEmptyAuth = FALSE;
    WORD                wcompressedNameOffset;

    ASSERT( pNode != NULL );
    ASSERT( wNameOffset );
    ASSERT( wNameOffset < DNSSRV_MAX_COMPRESSION_OFFSET );

    IF_DEBUG( WRITE2 )
    {
        Dbg_NodeName(
            "Writing A records at node ",
            ( PDB_NODE ) pNode,
            "\n" );
    }

    //
    //  get message info
    //      - flip question name, and insure proper compression flag
    //

    pCAR = ( PDNS_COMPRESSED_A_RECORD ) pMsg->pCurrent;

    wcompressedNameOffset = htons( COMPRESSED_NAME_FOR_OFFSET( wNameOffset ) );

    //
    //  set WINS flag -- cleared if A records written
    //

    pMsg->fWins = (BOOLEAN) SrvCfg_fWinsInitialized;

    //
    //  walk RR list -- write A records
    //

    LOCK_RR_LIST( pNode );
    if ( IS_NOEXIST_NODE( pNode ) )
    {
        UNLOCK_RR_LIST( pNode );
        return 0;
    }
    
    //
    //  Need to reserve space in buffer for OPT?
    //

    if ( pMsg->Opt.fInsertOptInOutgoingMsg )
    {
        bufferAdjustmentForOPT = DNS_MINIMIMUM_OPT_RR_SIZE;
        pMsg->pBufferEnd -= bufferAdjustmentForOPT;
        DNS_DEBUG( WRITE2, (
            "adjusted buffer end by %d bytes to reserve space for OPT\n",
            bufferAdjustmentForOPT ));
    }
    pchstop = pMsg->pBufferEnd;

    prr = START_RR_TRAVERSE( pNode );
    prrBeforeA = prr;

    while ( prr = prr->pRRNext )
    {
        DNS_DEBUG( OFF, (
            "Checking record of type %d for address record\n",
            prr->wType ));

        //
        //  skip RR before A, break after A
        //      - save ptr to RR just before first A for round robining
        //

        if ( prr->wType != DNS_TYPE_A )
        {
            if ( prr->wType > DNS_TYPE_A )
            {
                break;
            }
            prrBeforeA = prr;
            continue;
        }

        //
        //  Is this RR a cached empty auth response?
        //

        if ( IS_EMPTY_AUTH_RR( prr ) )
        {
            countWritten = processCachedEmptyAuthRR(
                                pMsg,
                                NULL,
                                wNameOffset,
                                prr );
            goto Cleanup;
        }

        //
        //  fast path for single A RR
        //      - get rid of all the tests and special cases
        //

        if ( !prrLastA &&
             ( !prr->pRRNext || prr->pRRNext->wType != DNS_TYPE_A ) )
        {
            //  cache hint never hits wire

            if ( IS_ROOT_HINT_RR(prr) )
            {
                break;
            }

            //  out of space in packet? --
            //      - set truncation flag

            if ( ( PCHAR ) pCAR + sizeof( DNS_COMPRESSED_A_RECORD ) > pchstop )
            {
                pMsg->Head.Truncation = TRUE;
                break;
            }

            //
            //  TTL
            //      - cache data TTL is in form of timeout time
            //      - regular authoritative data TTL is STATIC TTL in net byte order
            //

            if ( IS_CACHE_RR(prr) )
            {
                ttl = RR_PacketTtlForCachedRecord( prr, pMsg->dwQueryTime );
                if ( ttl == (-1) )
                {
                    fdelete = TRUE;
                    break;
                }
            }
            else
            {
                ttl = prr->dwTtlSeconds;
            }

            //
            //  write record
            //      - compressed name
            //      - type
            //      - class
            //      - TTL
            //      - data length
            //      - data (IP address)

            *(UNALIGNED  WORD *) &pCAR->wCompressedName = wcompressedNameOffset;
            *(UNALIGNED  WORD *) &pCAR->wType = (WORD) DNS_RTYPE_A;
            *(UNALIGNED  WORD *) &pCAR->wClass = (WORD) DNS_RCLASS_INTERNET;
            *(UNALIGNED DWORD *) &pCAR->dwTtl = ttl;
            *(UNALIGNED  WORD *) &pCAR->wDataLength
                                        = NET_BYTE_ORDER_A_RECORD_DATA_LENGTH;
            *(UNALIGNED DWORD *) &pCAR->ipAddress = prr->Data.A.ipAddress;

            countWritten = 1;
            pCAR++;
            goto Done;
        }

        //
        //  if already have data, then do NOT use data of lower rank
        //      - cache hints
        //      - glue
        //
        //  ROOT_HINT data NEVER goes on to the wire
        //

        rank = RR_RANK(prr);
        if ( foundRank != rank )
        {
            if ( foundRank )
            {
                ASSERT( rank < foundRank );
                break;
            }
            if ( rank == RANK_ROOT_HINT )
            {
                break;
            }
            foundRank = rank;
        }
        ASSERT( !IS_ROOT_HINT_RR(prr) );

        //
        //  skip all CACHED records when any are timed out
        //
        //  DEVNOTE: could combine with rank test
        //      foundRank == rank && IS_CACHE_RANK(rank) and fdelete
        //

        if ( fdelete && IS_CACHE_RR(prr) )
        {
            foundRank = 0;
            continue;
        }

        //
        //  stop reading records?
        //      - reach hard limit in array OR
        //      - NOT doing local net priority, and at AddressAnswerLimit
        //
        //  continue through A records after reaching limit?
        //  so that the round robining continues correctly;
        //  note this is done in main loop AFTER check for mixed cached
        //  and static data, so we specifically do NOT mix the data
        //  when round robining
        //

        prrLastA = prr;

        if ( fcontinueAfterLimit )
        {
            continue;
        }
        if ( foundCount >= DEFAULT_MAX_IP_WRITE_COUNT ||
             !SrvCfg_fLocalNetPriority &&
                SrvCfg_cAddressAnswerLimit &&
                foundCount >= SrvCfg_cAddressAnswerLimit )
        {
            if ( SrvCfg_fRoundRobin )
            {
                fcontinueAfterLimit = TRUE;
                continue;
            }
            break;
        }

        //
        //  determine TTL
        //      - cache data TTL is in form of timeout time;  every record
        //      is guaranteed to have minimum TTL, so only need check first one
        //
        //      - regular authoritative data TTL is STATIC TTL, records may
        //      have differing TTL for admin convenience, but always send
        //      minimum TTL of RR set
        //
        //  note do this test before writting anything, as need to catch
        //  timed out case and quit
        //

        if ( IS_CACHE_RR( prr ) )
        {
            if ( foundCount == 0 )
            {
                ttl = RR_PacketTtlForCachedRecord( prr, pMsg->dwQueryTime );
                if ( ttl == (-1) )
                {
                    fdelete = TRUE;
                    break;
                }
            }
        }
        else
        {
            INLINE_DWORD_FLIP( tempTtl, (prr->dwTtlSeconds) );
            if ( tempTtl < minTtl )
            {
                minTtl = tempTtl;
                ttl = prr->dwTtlSeconds;
            }
        }

        //  save address

        writeIpArray[ foundCount++ ] = prr->Data.A.ipAddress;
    }

    //
    //  prioritize address for local net
    //

    if ( SrvCfg_fLocalNetPriority )
    {
        prioritizeIpAddressArray(
            writeIpArray,
            foundCount,
            DnsAddr_GetIp4( &pMsg->RemoteAddr ) );
    }

    //
    //  write records
    //
    //  limit write if AddressAnswerLimit
    //  may have actually read more records than AddressAnswerLimit
    //  if LocalNetPriority, to make sure best record included, but
    //  we now limit the write to only the best records
    //
    //  DEVNOTE: should also skip downgrade on smart "length-aware" clients
    //

    if ( SrvCfg_cAddressAnswerLimit &&
         SrvCfg_cAddressAnswerLimit < foundCount &&
         !pMsg->fTcp )
    {
        ASSERT( SrvCfg_fLocalNetPriority );
        foundCount = ( WORD ) SrvCfg_cAddressAnswerLimit;
    }

    for ( countWritten = 0; countWritten < foundCount; countWritten++ )
    {
        //
        //  out of space in packet?
        //
        //      - set truncation flag (unless specially configured not to)
        //      - only "repeal" truncation for answers
        //      for additional data, the truncation flag will terminate the
        //      record writing loop and the flag will be reset in the
        //      calling routine (answer.c)
        //

        if ( ( PCHAR ) pCAR + sizeof( DNS_COMPRESSED_A_RECORD ) > pchstop )
        {
            if ( !SrvCfg_cAddressAnswerLimit ||
                 !IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) ||
                 !countWritten )
            {
                pMsg->Head.Truncation = TRUE;
            }
            break;
        }

        //
        //  write record
        //      - compressed name
        //      - type
        //      - class
        //      - TTL
        //      - data length
        //      - data (IP address)

        ip = writeIpArray[ countWritten ];

        if ( countWritten == 0 )
        {
            *(UNALIGNED  WORD *) &pCAR->wCompressedName = wcompressedNameOffset;
            *(UNALIGNED  WORD *) &pCAR->wType = (WORD) DNS_RTYPE_A;
            *(UNALIGNED  WORD *) &pCAR->wClass = (WORD) DNS_RCLASS_INTERNET;
            *(UNALIGNED DWORD *) &pCAR->dwTtl = ttl;
            *(UNALIGNED  WORD *) &pCAR->wDataLength
                                        = NET_BYTE_ORDER_A_RECORD_DATA_LENGTH;
            *(UNALIGNED DWORD *) &pCAR->ipAddress = ip;
        }
        else
        {
            //  if written record before, just copy previous
            //  then write in TTL + IP

            RtlCopyMemory(
                pCAR,
                pMsg->pCurrent,
                sizeof(DNS_COMPRESSED_A_RECORD) - sizeof(IP_ADDRESS) );

            *(UNALIGNED DWORD *) &pCAR->ipAddress = ip;
        }
        pCAR++;
    }

Done:

    //
    //  wrote A records?
    //      - clear WINS flag (if found record, no need)
    //      - update packet position
    //

    if ( countWritten )
    {
        pMsg->fWins = FALSE;
        pMsg->pCurrent = (PCHAR) pCAR;

        //
        //  more than one A -- round robin
        //

        if ( countWritten > 1 &&
             SrvCfg_fRoundRobin &&
             IS_ROUND_ROBIN_TYPE( DNS_TYPE_A ) &&
             prrLastA )
        {
            //  save ptr to first A record

            PDB_RECORD      pfirstRR = prrBeforeA->pRRNext;
            ASSERT( pfirstRR != NULL );

            //  cut first A from list

            prrBeforeA->pRRNext = pfirstRR->pRRNext;

            //  point first A's next ptr at remainder of list

            pfirstRR->pRRNext = prrLastA->pRRNext;

            //  splice first A in at end of A records

            prrLastA->pRRNext = pfirstRR;
        }
    }
    
    //
    //  set count of RR processed
    //
    //  return count to caller
    //

    CURRENT_RR_SECTION_COUNT( pMsg ) += countWritten;

Cleanup:

    UNLOCK_RR_LIST( pNode );

    //
    //  delete timed out resource records
    //

    if ( fdelete )
    {
        ASSERT( countWritten == 0 );
        RR_ListTimeout( pNode );
    }
    
    IF_DEBUG( WRITE2 )
    {
        DNS_PRINT((
            "Wrote %d A records %sat node ",
            countWritten,
            ( pMsg->Head.Truncation )
                ?   "and set truncation bit "
                :   "" ));
        Dbg_NodeName(
            NULL,
            (PDB_NODE) pNode,
            "\n" );
    }

    pMsg->pBufferEnd += bufferAdjustmentForOPT;

    return countWritten;
}



VOID
prioritizeIpAddressArray(
    IN OUT  IP_ADDRESS      IpArray[],
    IN      DWORD           dwCount,
    IN      IP_ADDRESS      RemoteIp
    )
/*++

Routine Description:

    Prioritizes IP array for addresses closest to remote address.

    The LocalNetPriority value is either 1 to specify that
    addresses should be ordered in the best possible match
    or it is a netmask to indicate within what mask the best
    matches should be round-robined.

Arguments:

Return Value:

    None

--*/
{
    DBG_FN( "prioritizeIpAddressArray" )

    IP_ADDRESS  ip;
    DWORD       remoteNetMask;
    DWORD       mismatch;
    DWORD       i;
    DWORD       j;
    DWORD       jprev;
    DWORD       matchCount = 0;
#ifdef JJW_KILL
    DWORD       matchCountWithinPriorityNetmask = 0;
#endif
    DWORD       mismatchArray[ DEFAULT_MAX_IP_WRITE_COUNT ];
    DWORD       dwpriorityMask = SrvCfg_dwLocalNetPriorityNetMask;
    
    //
    //  Retrieve corresponding to the client's IP address.
    //  Class A, B, or C, depending on the upper address bits.
    //

    remoteNetMask = Dns_GetNetworkMask( RemoteIp );

    if ( dwpriorityMask == DNS_LOCNETPRI_MASK_CLASS_DEFAULT )
    {
        dwpriorityMask = remoteNetMask;
    }

    IF_DEBUG( WRITE )
    {
        DNS_PRINT((
            "PrioritizeAddressArray\n"
            "    remote IP        = %s\n"
            "    remote net mask  = 0x%08X\n"
            "    priority mask    = 0x%08X\n",
            IP_STRING( RemoteIp ),
            remoteNetMask,
            dwpriorityMask ));
        IF_DEBUG( WRITE2 )
        {
            DnsDbg_Ip4AddressArray(
                "Host IPs before local net prioritization: ",
                NULL,
                dwCount,
                IpArray );
        }
    }

    //
    //  Loop through each answer IP.
    //

    for ( i = 0; i < dwCount; ++i )
    {
        ip = IpArray[ i ];
        mismatch = ip ^ RemoteIp;

        //
        //  If the nets don't match just continue.
        //

        if ( mismatch & remoteNetMask )
        {
            continue;
        }

        INLINE_DWORD_FLIP( mismatch, mismatch );

        DNS_DEBUG( WRITE2, (
            "found IP %s matching nets with remote IP 0x%08X\n"
            "    mismatch = 0x%08X\n",
            IP_STRING( ip ),
            RemoteIp,
            mismatch ));

        //  matches remote net, put last non-matching entry in its place
        //
        //  then work down matching array, bubbling existing entries up,
        //  until find matching entry with smaller mismatch

        j = matchCount;
        IpArray[ i ] = IpArray[ j ];

        //
        //  Sort by mismatch but only down to the priority mask.
        //

        while ( j )
        {
            jprev = j--;
            if ( mismatch > dwpriorityMask )
            {
                ++j;
                break;
            }
            mismatchArray[ jprev ] = mismatchArray[ j ];
            IpArray[ jprev ] = IpArray[ j ];
        }

        IpArray[ j ] = ip;
        mismatchArray[ j ] = mismatch;
        ++matchCount;

#ifdef JJW_KILL
        if ( mismatch <= dwpriorityMask )
        {
            ++matchCountWithinPriorityNetmask;
        }
#endif

        IF_DEBUG( WRITE2 )
        {
            DnsDbg_DwordArray(
                "Matching IP mis-match list after insert:",
                NULL,
                matchCount,
                mismatchArray );
        }
    }

#ifdef JJW_KILL

    //
    //  If there were no matches within the priority netmask use
    //  the match count by client address class so that we will
    //  round-robin the best addresses.
    //

    if ( matchCountWithinPriorityNetmask == 0 )
    {
        matchCountWithinPriorityNetmask = matchCount;
    }

    //
    //  Round-robin is tricky with LNP enabled. The problem is
    //  that the swapping of matching addresses into the start
    //  of the array leaves us with the original address ordering
    //  whenever the original IP answer list started with all
    //  non-matching addresses. To combat this, round-robin
    //  the matching addresses by a pseudo-random factor.
    //
    //  However, we do this swapping for matching addresses that
    //  matched within the priority netmask. This keeps those
    //  addresses at the top of the list.
    //

    if ( dwpriorityMask != DNS_LOCNETPRI_MASK_BEST_MATCH &&
         matchCountWithinPriorityNetmask &&
         ( i = DNS_TIME() % matchCountWithinPriorityNetmask ) > 0 )
    {
        #define     DNS_MAX_LNP_RR_CHUNK    32

        DNS_ADDR    tempArray[ DNS_MAX_LNP_RR_CHUNK ];

        DNS_DEBUG( WRITE, (
            "%s: round robin top %d addresses within priority netmask\n",
            fn, matchCountWithinPriorityNetmask ));

        IF_DEBUG( WRITE2 )
        {
            DnsDbg_DnsAddrArray(
                "Host IPs before priority netmask round robin: ",
                NULL,
                pDnsAddrArray );
        }

        //
        //  Limit the shift factor i so that it is smaller than
        //  the temp buffer size.
        //

        while ( i > DNS_MAX_LNP_RR_CHUNK )
        {
            i /= 2;
        }

        DNS_DEBUG( WRITE, ( "%s: shift factor is %d\n", fn, i ));

        //
        //  Round-robin by copying a chunk of addresses to the
        //  temp buffer, then copy the remaining addresses to the
        //  top of the IP array, then copy of the temp buffer to
        //  the bottom of the IP array.
        //

        RtlCopyMemory(
            tempArray,
            pDnsAddrArray->AddrArray,
            sizeof( DNS_ADDR ) * i );
        RtlCopyMemory(
            pDnsAddrArray->AddrArray,
            &pDnsAddrArray->AddrArray[ i ],
            sizeof( DNS_ADDR ) * ( matchCountWithinPriorityNetmask - i ) );
        RtlCopyMemory(
            &pDnsAddrArray->AddrArray[ matchCountWithinPriorityNetmask - i ],
            tempArray, 
            sizeof( DNS_ADDR ) * i );
    }
#endif

    IF_DEBUG( WRITE2 )
    {
        DnsDbg_Ip4AddressArray(
            "Host IPs after local net prioritization: ",
            NULL,
            dwCount,
            IpArray );
    }
}



DWORD
FASTCALL
RR_PacketTtlForCachedRecord(
    IN      PDB_RECORD      pRR,
    IN      DWORD           dwQueryTime
    )
/*++

Routine Description:

    Determine TTL to write for cached record.

Arguments:

    pRR - record being written to packet

    dwQueryTime - time of original query

Return Value:

    TTL if successful.
    (-1) if record timed out.

--*/
{
    DWORD   ttl;

    ttl = pRR->dwTtlSeconds;

    if ( IS_FIXED_TTL_RR( pRR ) )
    {
        return ttl;
    }
    
    if ( ttl < dwQueryTime )
    {
        DNS_DEBUG( WRITE, (
            "Encountered timed out RR (t=%d) (r=%d) (ttl=%d) at %p\n"
            "    Writing packet with query time %d\n"
            "    Stopping packet write\n",
            pRR->wType,
            RR_RANK(pRR),
            pRR->dwTtlSeconds,
            pRR,
            dwQueryTime ));
        return ( DWORD ) -1;        //  RR has timed out
    }

    if ( !IS_ZERO_TTL_RR(pRR) )
    {
        ttl = ttl - DNS_TIME();
        if ( (INT)ttl > 0 )
        {
            INLINE_DWORD_FLIP( ttl, ttl );
        }
        else
        {
            DNS_DEBUG( WRITE, (
                "Encountered RR (t=%d) (r=%d) (ttl=%d) at %p\n"
                "    which timed out since query time %d\n"
                "    Writing RR to packet with zero TTL\n",
                pRR->wType,
                RR_RANK(pRR),
                pRR->dwTtlSeconds,
                pRR,
                dwQueryTime ));
            ttl = 0;
        }
    }
    else
    {
        ttl = 0;
    }
    return ttl;
}

//
//  End of rrpacket.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rrlist.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    rrlist.c

Abstract:

    Domain Name System (DNS) Server

    Routines to handle resource records (RR) lists.

Author:

    Jim Gilroy (jamesg)     March, 1995

Revision History:

    jamesg      1997    --  update RR list routines
                            name error caching
                            CNAME BIND compatibility

--*/


#include "dnssrv.h"


//
//  Name error caching time
//      - max value controlled by SrvCfg_dwMaxNegativeCacheTtl
//      - min value of a minute
//

#define MIN_NAME_ERROR_TTL      (60)

//
//  Dummy refresh time that means force refresh
//

#define FORCE_REFRESH_DUMMY_TIME    (MAXDWORD)



//
//  Private protos
//

VOID
deleteCachedRecordsForUpdate(
    IN OUT  PDB_NODE        pNode
    );

DNS_STATUS
FASTCALL
checkCnameConditions(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR,
    IN      WORD            wType
    );

VOID
RR_ListResetNodeFlags(
    IN OUT  PDB_NODE        pNode
    );



PDB_RECORD
RR_FindNextRecord(
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      PDB_RECORD      pRecord,
    IN      DWORD           dwQueryTime
    )
/*++

Routine Description:

    Gets next resource record in a domain node that matches a given type.

    This function can be used to retrieve records from the
    cache that are expired. So when a cache record is found, if it is timed
    out we must delete it and NOT return it as a match.

Arguments:

    pNode - ptr to node to find record at

    wType - type of record to find;  type ALL to just get next record in list

    pRecord - ptr to previous record;  NULL to start at beginning of list.

    dwQueryTime - query time: used to determine if the found record is
        timed out OR use 0 to indicate that no RR timeout checking should be
        performed

Return Value:

    Ptr to RR if found.
    NULL if no more RR of desired type.

--*/
{
    DBG_FN( "RR_FindNextRecord" )

    BOOL    fdeleteRequired = FALSE;

    ASSERT( pNode != NULL );

    IF_DEBUG( LOOKUP2 )
    {
        DNS_PRINT((
            "Looking for RR type %d, at node, query time %d",
            wType,
            dwQueryTime ));
        Dbg_NodeName(
            NULL,
            (PDB_NODE) pNode,
            "\n" );
        DNS_PRINT((
            "    Previous RR ptr = %p.\n",
            pRecord ));
    }

    LOCK_READ_RR_LIST( pNode );

    //
    //  cached name error node
    //

    if ( IS_NOEXIST_NODE( pNode ) )
    {
        goto NotFound;
    }

    //
    //  Set query time argument to zero if the node is not in the cache
    //  or should not be checked for timeout to simply timeout test later.
    //

    if ( dwQueryTime && !IS_CACHE_TREE_NODE( pNode ) )
    {
        dwQueryTime = 0;
    }

    //
    //  if previous RR, start after it
    //  otherwise start at head of node's RR list
    //

    if ( !pRecord )
    {
        pRecord = START_RR_TRAVERSE( pNode );
    }

    //
    //  traverse list, until find next record of desired type
    //

    while ( pRecord = NEXT_RR(pRecord) )
    {
        //  found matching record?

        if ( wType == pRecord->wType
                ||
             wType == DNS_TYPE_ALL
                ||
             ( wType == DNS_TYPE_MAILB && DnsIsAMailboxType( pRecord->wType ) ) )
        {
            //
            //  Is the found record timed out?
            //

            if ( dwQueryTime &&
                 pRecord->dwTtlSeconds &&
                 RR_PacketTtlForCachedRecord(
                            pRecord,
                            dwQueryTime ) == -1 )
            {
                fdeleteRequired = TRUE;
                DNS_DEBUG( LOOKUP2, (
                    "%s: encountered timed out record %p in node %p",
                    fn, pRecord, pNode ));
                continue;
            }

            goto Found;
        }

        //  past matching records?

        if ( wType < pRecord->wType )
        {
            goto NotFound;
        }
    }

NotFound:

    pRecord = NULL;

Found:

    if ( fdeleteRequired )
    {
        DNS_DEBUG( LOOKUP2, (
            "%s: deleting timed out RRs node %p", fn, pNode ));
        RR_ListTimeout( pNode );
    }

    UNLOCK_READ_RR_LIST( pNode );

    return pRecord;
}



DWORD
RR_ListCountRecords(
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      BOOL            fLocked
    )
/*++

Routine Description:

    Counts records of desired type

Arguments:

    pNode - ptr to node to find record at

    wType - type of record to find;  type ALL to just get next record in list

    fLocked - already locked

Return Value:

    Count of records of desired type.

--*/
{
    PDB_RECORD  prr;
    DWORD       count = 0;
    WORD        type;

    ASSERT( pNode != NULL );

    DNS_DEBUG( LOOKUP, (
        "RR_ListCountRecords( %s, type=%d, lock=%d )\n",
        pNode->szLabel,
        wType,
        fLocked ));

    if ( !fLocked )
    {
        LOCK_READ_RR_LIST( pNode );
    }

    //
    //  cached name error node
    //

    if ( IS_NOEXIST_NODE( pNode ) )
    {
        goto Done;
    }

    //
    //  traverse list, counting records
    //

    for ( prr = FIRST_RR( pNode );
          prr != NULL;
          prr = NEXT_RR(prr) )
    {
        //  ignore cached records

        if ( IS_CACHE_RR(prr) )
        {
            continue;
        }
        type = prr->wType;

        //  found matching record?

        if ( wType == DNS_TYPE_ALL  ||  wType == type )
        {
            count++;
            continue;
        }

        //  not yet to matching type?

        else if ( wType < type )
        {
            continue;
        }

        //  past matching type

        break;
    }

Done:

    if ( !fLocked )
    {
        UNLOCK_READ_RR_LIST( pNode );
    }
    return count;
}



DWORD
RR_FindRank(
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    )
/*++

Routine Description:

    Gets rank (highest rank) for record type at node.

    Useful for comparing cache node to zone delegation\glue nodes.

Arguments:

    pNode - ptr to node

    wType - type of record to check

Return Value:

    Rank of record data of desired type at node.
    Zero if no records of desired type.

--*/
{
    PDB_RECORD  prr;
    DWORD       rank = 0;

    ASSERT( pNode != NULL );

    DNS_DEBUG( LOOKUP2, (
        "RR_FindRank() %p (l=%s), type = %d\n",
        pNode,
        pNode->szLabel,
        wType ));

    LOCK_READ_RR_LIST( pNode );

    //
    //  cached name error node
    //

    if ( IS_NOEXIST_NODE( pNode ) )
    {
        goto Done;
    }

    //
    //  traverse list, until find next record of desired type
    //

    prr = START_RR_TRAVERSE( pNode );

    while ( prr = NEXT_RR(prr) )
    {
        if ( wType == prr->wType )
        {
            rank = RR_RANK(prr);
            break;
        }
    }

Done:

    UNLOCK_READ_RR_LIST( pNode );

    return rank;
}



#if DBG
BOOL
RR_ListVerify(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Verify that node's RR list is valid.

    Asserts if RR list is invalid.

Arguments:

    pNode -- ptr to node

Return Value:

    TRUE -- if RR list valid
    FALSE -- otherwise

--*/
{
    PDB_RECORD  prr;
    WORD        type;
    WORD        previousType;
    UCHAR       rank = 0;
    UCHAR       previousRank;
    BOOL        foundCname = FALSE;
    BOOL        foundNs = FALSE;
    BOOL        foundSoa = FALSE;
    BOOL        foundEmptyAuthForThisType = FALSE;
    UINT        rrsForThisType = 0;

    ASSERT( pNode != NULL );

    //
    //  cached name error
    //      - only issue is valid timeout
    //

    LOCK_READ_RR_LIST( pNode );

    if ( IS_NOEXIST_NODE( pNode ) )
    {
        UNLOCK_READ_RR_LIST( pNode );
        return TRUE;
    }

#if 0
    //  for some reason this is broken on deleted nodes
    //  not necessary doing to track another bug
    //
    //  AUTH zone root check
    //

    if ( IS_AUTH_ZONE_ROOT( pNode ) )
    {
        ASSERT( IS_AUTH_NODE( pNode ) );
        ASSERT( IS_ZONE_ROOT( pNode ) );
        ASSERT( pNode->pZone );
        ASSERT( ((PZONE_INFO)pNode->pZone)->pZoneRoot == pNode ||
                ((PZONE_INFO)pNode->pZone)->pLoadZoneRoot == pNode ||
                IS_TNODE( pNode ) );
    }
#endif

    //
    //  walk to end of list, check
    //      - list termination
    //      - types in correct (increasing) order
    //

    prr = FIRST_RR( pNode );
    previousType = 0;

    while ( prr != NULL )
    {
        //  validity check

        if ( !RR_Validate(
                prr,
                TRUE,       //  active
                0,          //  no required type
                0 ) )       //  no required source
        {
            ASSERT( FALSE );
            UNLOCK_READ_RR_LIST( pNode );
            return FALSE;
        }

        //  type ordering check

        type = prr->wType;
        ASSERT( type && type >= previousType );

        //
        //  Empty-auth checking: if there is an empty auth RR there
        //  should be no other RRs with the same type.
        //

        if ( type != previousType )
        {
            foundEmptyAuthForThisType = FALSE;
            rrsForThisType = 0;
        }
        ++rrsForThisType;

        if ( IS_EMPTY_AUTH_RR( prr ) )
        {
            foundEmptyAuthForThisType = TRUE;
            ASSERT( rrsForThisType == 1 );
        }
        else
        {
            ASSERT( !foundEmptyAuthForThisType );

            //  rank ordering check

            rank = RR_RANK(prr);
            if ( type == previousType )
            {
                ASSERT( rank <= previousRank );
            }

            ASSERT( prr->wDataLength );

            //
            //  CNAME check
            //      - CNAME records ONLY found AT CNAME node
            //      - if CNAME node ONLY certain types may be present

            if ( type == DNS_TYPE_CNAME )
            {
                ASSERT( IS_CNAME_NODE( pNode ) );
                foundCname = TRUE;
            }
            else if ( IS_CNAME_NODE( pNode ) )
            {
                ASSERT( IS_ALLOWED_WITH_CNAME_TYPE(type) );
            }

            //
            //  NS-SOA root check
            //

            if ( type == DNS_TYPE_NS )
            {
                ASSERT( IS_ZONE_ROOT( pNode ) );
                foundNs = TRUE;
            }
            else if ( type == DNS_TYPE_SOA )
            {
                foundSoa = TRUE;
                ASSERT( IS_ZONE_ROOT( pNode ) );
                ASSERT( IS_AUTH_ZONE_ROOT( pNode ) || !IS_ZONE_TREE_NODE( pNode ) );
            }
        }

        //  next record

        prr = prr->pRRNext;
        previousType = type;
        previousRank = rank;
    }

    //
    //  flag checks
    //      - CNAME record at CNAME node
    //      - NS or SOA at zone root
    //      - SOA at authoritative zone root (which also must be zone root)
    //

    if ( IS_CNAME_NODE( pNode ) )
    {
        ASSERT( foundCname );
    }

#if 0
    //  can't do these checks on zone while loading, since
    //  zone root has no SOA when we start load
    if ( IS_AUTH_ZONE_ROOT( pNode ) )
    {
        ASSERT( foundSoa );
        ASSERT( IS_ZONE_ROOT( pNode ) );
    }
    if ( IS_ZONE_ROOT( pNode ) )
    {
        ASSERT( foundNs || foundSoa );
    }
#endif

    UNLOCK_READ_RR_LIST( pNode );

    return TRUE;
}



BOOL
RR_ListVerifyDetached(
    IN      PDB_RECORD      pRR,
    IN      WORD            wType,
    IN      DWORD           dwSource
    )
/*++

Routine Description:

    Verify that RR list is valid.

    This is for detached list -- as in updates.

Arguments:

    pRR -- ptr to head of RR list

    wType -- records in list must be this type

    dwSource -- records must be from this source

Return Value:

    TRUE -- if RR list valid
    FALSE -- otherwise

--*/
{
    WORD        type;
    WORD        previousType = 0;
    UCHAR       rank;
    UCHAR       previousRank = 0;


    while ( pRR != NULL )
    {
        //  validity check

        if ( !RR_Validate(
                pRR,
                TRUE,               //  active
                wType,              //  required type (if any)
                dwSource ) )        //  required source (if any)
        {
            ASSERT( FALSE );
            return FALSE;
        }

        //  type ordering check

        type = pRR->wType;
        ASSERT( type && type >= previousType );

        //  rank ordering check

        rank = RR_RANK(pRR);
        if ( type == previousType )
        {
            ASSERT( rank <= previousRank );
        }

        //  next record

        pRR = pRR->pRRNext;
        previousType = type;
        previousRank = rank;
    }

    return TRUE;
}
#endif



//
//  Name error caching \ NOEXIST nodes
//

VOID
RR_CacheNameError(
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wQuestionType,
    IN      DWORD           dwQueryTime,
    IN      BOOL            fAuthoritative,
    IN      PDB_NODE        pZoneRoot,      OPTIONAL
    IN      DWORD           dwCacheTtl      OPTIONAL
    )
/*++

Routine Description:

    Cache name error at node.

Arguments:

    pNode -- ptr to node with name error

    dwQueryTime -- time of query

    fAuthoritative -- authoritative response?

    pZoneRoot -- zone root node where SOA will be cached

    dwCacheTtl -- caching TTL, from SOA returned with name error;  if not given
        will cache for short time only to eliminate repeat queries

Return Value:

    None

--*/
{
    PDB_RECORD  prr;

    //
    //  NAME_ERROR response packets without a question never get a node
    //  created in caller, protect against them
    //

    if ( pNode == NULL )
    {
        DNS_PRINT((
            "ERROR: received NAME_ERROR response without question section\n" ));
        return;
    }

    DNS_DEBUG( READ2, (
        "RR_CacheNameError at %p (l=%s)\n"
        "    type     = %d\n"
        "    time     = %d\n"
        "    auth     = %d\n"
        "    zoneRoot = %p\n"
        "    TTL      = %d\n",
        pNode, pNode->szLabel,
        wQuestionType,
        dwQueryTime,
        fAuthoritative,
        pZoneRoot,
        dwCacheTtl ));

    //
    //  set NAME_ERROR TTL
    //  - even if no TTL available still cache for a minute to avoid looking up
    //  client retries
    //  - when query was for SOA, also limit to minimum since this is often the
    //  result of a FAZ query and name may quickly be updated
    //
    //  - limit to maximum of 15 minutes
    //

    if ( !dwCacheTtl || wQuestionType == DNS_TYPE_SOA )
    {
        dwCacheTtl = MIN_NAME_ERROR_TTL;
    }
    else if ( dwCacheTtl > SrvCfg_dwMaxNegativeCacheTtl )
    {
        dwCacheTtl = SrvCfg_dwMaxNegativeCacheTtl;
    }
    if ( dwCacheTtl > SrvCfg_dwMaxCacheTtl )
    {
        dwCacheTtl = SrvCfg_dwMaxCacheTtl;
    }

    //
    //  existing records?
    //
    //  if authoritative node, timeout records (WINS or NBSTAT)
    //  but can't cache NAME_ERROR if existing records
    //
    //  non-authoritative, delete existing records
    //
    //  DEVNOTE: should NAME_ERROR delete GLUE A records?
    //

    LOCK_WRITE_RR_LIST( pNode );

    if ( pNode->pRRList )
    {
        if ( IS_NOEXIST_NODE( pNode ) )
        {
            RR_ListFree( pNode->pRRList );
            pNode->pRRList = NULL;
            RR_ListTimeout( pNode );
        }
        else if ( IS_ZONE_TREE_NODE( pNode ) )
        {
            RR_ListTimeout( pNode );
            if ( pNode->pRRList )
            {
                goto Unlock;
            }
        }
        else
        {
            RR_ListDelete( pNode );
        }
    }

    ASSERT( pNode->pRRList == NULL );

    //
    //  set NAME_ERROR with timeout
    //  cached name error will use standard RR with fields
    //      - wType => 0
    //      - wDataLength => 4
    //      - dwTtl => standard caching TTL
    //      - Data => zoneroot node (to find cached SOA)
    //
    //  reference zone root node so not deleted out from under this
    //      record

    SET_NOEXIST_NODE( pNode );

    Timeout_SetTimeoutOnNodeEx(
        pNode,
        dwCacheTtl,
        TIMEOUT_NODE_LOCKED );

    prr = RR_AllocateEx( sizeof(PDB_NODE), MEMTAG_RECORD_NOEXIST );
    IF_NOMEM( !prr )
    {
        goto Unlock;
    }
    prr->wType = DNS_TYPE_NOEXIST;
    prr->Data.NOEXIST.pnodeZoneRoot = pZoneRoot;
    prr->dwTtlSeconds = dwCacheTtl + dwQueryTime;

    SET_RR_RANK(
        prr,
        (fAuthoritative ? RANK_CACHE_A_ANSWER : RANK_CACHE_NA_ANSWER) );

    pNode->pRRList = prr;

    if ( pZoneRoot )
    {
        NTree_ReferenceNode( pZoneRoot );
    }

    IF_DEBUG( READ2 )
    {
        Dbg_DbaseNode(
            "Domain node after NXDOMAIN caching:\n",
            pNode );
    }

Unlock:

    //  note:  currently don't need to set timeout on any failure
    //      cases, as only case is zone node with existing data
    //      which obviously doesn't require timeout

    UNLOCK_WRITE_RR_LIST( pNode );
}   //  RR_CacheNameError


VOID
RR_CacheEmptyAuth(
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wType,
    IN      DWORD           dwQueryTime,
    IN      BOOL            fAuthoritative,
    IN      PDB_NODE        pZoneRoot,      OPTIONAL
    IN      DWORD           dwCacheTtl      OPTIONAL
    )
/*++

Routine Description:

    Cache empty auth response at node. Empty auth means that no records for
    the specified type exist at this node.

Arguments:

    pNode -- ptr to node with name error

    wType -- type that for which no records exists

    dwQueryTime -- time of query

    fAuthoritative -- authoritative response?

    pZoneRoot -- zone root node where SOA will be cached

    dwCacheTtl -- caching TTL, from SOA returned with name error;  if not given
        will cache for short time only to eliminate repeat queries

Return Value:

    None

--*/
{
    DBG_FN( "RR_CacheEmptyAuth" )

    PDB_RECORD  prr;
    PDB_RECORD  pemptyAuthRR = NULL;

    if ( !SrvCfg_dwCacheEmptyAuthResponses )
    {
        return;
    }

    if ( pNode == NULL )
    {
        DNS_PRINT((
            "ERROR: received empty auth response without question section\n" ));
        return;
    }

    DNS_DEBUG( READ2, (
        "%s at %p (l=%s)\n"
        "    type     = %d\n"
        "    time     = %d\n"
        "    auth     = %d\n"
        "    zoneRoot = %p\n"
        "    TTL      = %d\n", fn,
        pNode, pNode->szLabel,
        wType,
        dwQueryTime,
        fAuthoritative,
        pZoneRoot,
        dwCacheTtl ));

    //
    //  Set TTL using same logic as in RR_CacheNameError.
    //

    if ( !dwCacheTtl || wType == DNS_TYPE_SOA )
    {
        dwCacheTtl = MIN_NAME_ERROR_TTL;
    }
    else if ( dwCacheTtl > SrvCfg_dwMaxNegativeCacheTtl )
    {
        dwCacheTtl = SrvCfg_dwMaxNegativeCacheTtl;
    }
    if ( dwCacheTtl > SrvCfg_dwMaxCacheTtl )
    {
        dwCacheTtl = SrvCfg_dwMaxCacheTtl;
    }

    //
    //  If there are any records in the node for the empty
    //  auth response type, those records must be freed.
    //

    LOCK_WRITE_RR_LIST( pNode );

    if ( pNode->pRRList )
    {
        if ( IS_NOEXIST_NODE( pNode ) )
        {
            RR_ListFree( pNode->pRRList );
            pNode->pRRList = NULL;
        }
        else if ( IS_ZONE_TREE_NODE( pNode ) )
        {
            RR_ListTimeout( pNode );
            if ( pNode->pRRList )
            {
                goto Unlock;
            }
        }
        else
        {
            RR_ListDeleteType( pNode, wType );
        }
    }

    Timeout_SetTimeoutOnNodeEx(
        pNode,
        dwCacheTtl,
        TIMEOUT_NODE_LOCKED );

    //
    //  Allocate an empty auth RR. For allocation tagging, empty
    //  auths are included in the NOEXIST bucket.
    //

    pemptyAuthRR = RR_AllocateEx( sizeof( pemptyAuthRR->Data.EMPTYAUTH ), MEMTAG_RECORD_NOEXIST );
    IF_NOMEM( !pemptyAuthRR )
    {
        goto Unlock;
    }
    pemptyAuthRR->wType = wType;
    pemptyAuthRR->Data.EMPTYAUTH.psoaNode = pZoneRoot;
    pemptyAuthRR->dwTtlSeconds = dwCacheTtl + dwQueryTime;
    SET_EMPTY_AUTH_RR( pemptyAuthRR );

    SET_RR_RANK(
        pemptyAuthRR,
        ( fAuthoritative ? RANK_CACHE_A_ANSWER : RANK_CACHE_NA_ANSWER ) );

    //
    //  Insert the new RR into the node's RR list.
    //

    pNode->pRRList = RR_ListInsertInOrder( pNode->pRRList, pemptyAuthRR );

    if ( pZoneRoot )
    {
        NTree_ReferenceNode( pZoneRoot );
    }

    IF_DEBUG( READ2 )
    {
        Dbg_DbaseNode(
            "Domain node after empty auth caching:\n",
            pNode );
    }

    RR_ListVerify( pNode );

    Unlock:

    UNLOCK_WRITE_RR_LIST( pNode );
}   //  RR_CacheEmptyAuth



BOOL
RR_CheckNameErrorTimeout(
    IN OUT  PDB_NODE        pNode,
    IN      BOOL            fForceRemove,
    OUT     PDWORD          pdwTtl,         OPTIONAL
    OUT     PDB_NODE *      ppSoaNode       OPTIONAL
    )
/*++

Routine Description:

    Check cached name error timeout on node. Cleanup if timed out.

    Optionally return caching TTL and SOA node.

Arguments:

    pNode -- ptr to node containing RR list

    fForceRemove - TRUE if remove any existing timeout

    pdwTtl -- caching TTL

    ppSoaNode -- zone node containing SOA

    Note:  pdwTtl and ppSoaNode are OPTIONAL;  but must request but if requested
        MUST request both

Return Value:

    TRUE if cached name error exists.
    FALSE if does not or has timed out.

--*/
{
    PDB_RECORD      prr;
    DWORD           ttl;
    DWORD           dwCurrentTime;
    DWORD           dwTimeAdjust = g_dwCacheLimitCurrentTimeAdjustment;

    DNS_DEBUG( DATABASE, (
        "RR_CheckNameErrorTimeout( label=%s, force=%d )\n",
        pNode->szLabel,
        fForceRemove ));

    LOCK_WRITE_RR_LIST( pNode );

    RR_ListVerify( pNode );

    //
    //  Cache limit enforcement: if we're calling this function in
    //  the context of trying to shrink the cache, then depending
    //  on the current aggression level we may cut RRs that are not
    //  yet fully expired.
    //

    dwCurrentTime = DNS_TIME() + dwTimeAdjust;

    //
    //  If no longer cached name error, we're done. If this is a no-exist
    //  node but there is not a no-exist RR, clear the noexist flag and 
    //  return.
    //

    prr = pNode->pRRList;

    if ( IS_NOEXIST_NODE( pNode ) )
    {
        if ( !prr || prr->wType != DNS_TYPE_NOEXIST )
        {
            CLEAR_NOEXIST_NODE( pNode );
            prr = NULL;
            goto Unlock;
        }
    }
    else
    {
        prr = NULL;
        goto Unlock;
    }

    //
    //  if forcing removal, or if name error timed out, delete from node
    //

    ttl = prr->dwTtlSeconds - dwCurrentTime;

    if ( fForceRemove ||
         dwTimeAdjust == DNS_CACHE_LIMIT_DISCARD_ALL ||
         ( LONG ) ttl < 0 )
    {
        pNode->pRRList = NULL;
        CLEAR_NOEXIST_NODE( pNode );
        ++g_dwCacheFreeCount;
        RR_Free( prr );
        prr = NULL;
        goto Unlock;
    }

    //
    //  if requested return cached name error info
    //

    if ( pdwTtl )
    {
        *pdwTtl = ttl;
        if ( ppSoaNode )
        {
            *ppSoaNode = prr->Data.NOEXIST.pnodeZoneRoot;
        }
        DNS_DEBUG( LOOKUP2, (
            "NameError cached TTL = %d\n", ttl ));
    }


Unlock:

    //
    //  If the node now has no records and is a cache node, we must
    //  enter the node in the timeout system so it will get deleted.
    //

    if ( EMPTY_RR_LIST( pNode ) &&
         IS_CACHE_TREE_NODE( pNode ) &&
         !IS_TIMEOUT_NODE( pNode ) )
    {
        Timeout_SetTimeoutOnNodeEx(
            pNode,
            0,
            TIMEOUT_NODE_LOCKED );
    }

    UNLOCK_WRITE_RR_LIST( pNode );
    return prr != NULL;
}



//
//  Caching \ timeout
//

BOOL
RR_CacheSetAtNode(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pFirstRR,
    IN OUT  PDB_RECORD      pLastRR,
    IN      DWORD           dwTtl,
    IN      DWORD           dwQueryTime
    )
/*++

Routine Description:

    Cache a RR set at node in database.

Arguments:

    pNode -- ptr to node to add resource record to

    pFirstRR -- first resource record to add

    pLastRR -- last resource record to add

    dwTtl -- TTL for record set

    dwQueryTime -- time we queried remote, allows us to determine TTL timeout
    
Return Value:

    TRUE -- if successful
    FALSE -- otherwise;  records are deleted

--*/
{
    PDB_RECORD      pcurRR;
    PDB_RECORD      pprevRR;
    PDB_RECORD      prr;
    PDB_RECORD      prrTestPrevious;
    PDB_RECORD      prrTest;
    WORD            type;
    UCHAR           rank;

    ASSERT( pNode != NULL && pFirstRR != NULL && pLastRR != NULL );
    ASSERT( RR_RANK( pFirstRR ) != 0  && IS_CACHE_RR( pFirstRR ) );

    type = pFirstRR->wType;
    rank = RR_RANK( pFirstRR );

    DNS_DEBUG( READ2, (
        "Caching RR at node (label=%s)\n"
        "    type %d, rank %x, TTL = %d, query time = %d\n",
        pNode->szLabel,
        type,
        rank,
        dwTtl,
        dwQueryTime ));

    LOCK_WRITE_RR_LIST( pNode );

    IF_DEBUG( READ )
    {
        RR_ListVerify( pNode );
    }

    //
    //  clear cached NAME_ERROR
    //

    if ( IS_NOEXIST_NODE( pNode ) )
    {
        RR_RemoveCachedNameError( pNode );
    }

    //
    //  check CNAME node special case
    //

    if ( IS_CNAME_NODE( pNode ) || type == DNS_TYPE_CNAME )
    {
        DNS_STATUS status;
        status = checkCnameConditions(
                    pNode,
                    pFirstRR,
                    type );
        if ( status != ERROR_SUCCESS )
        {
            goto Failed;
        }
    }

    //
    //  traverse RR list
    //

    pcurRR = START_RR_TRAVERSE( pNode );

    while ( pprevRR = pcurRR, pcurRR = pcurRR->pRRNext )
    {
        //  continue until reach new type
        //  break when past new type

        if ( type != pcurRR->wType )
        {
            if ( type > pcurRR->wType )
            {
                continue;
            }
            break;
        }

        //  found record of desired type
        //
        //  => do NOT cache if records of higher rank
        //  => eliminate any CACHED records of lower rank
        //
        //  This can happen if an update JUST added the RR.

        if ( rank < RR_RANK( pcurRR ) )
        {
            DNS_DEBUG( READ, (
                "Failed to cache RR at node %p.\n"
                "    Existing record %p of same type with superior rank %d\n",
                pNode,
                pcurRR,
                RR_RANK(pcurRR) ));
            goto Failed;
        }

        //  delete any previously cached records of this type
        //      - delete previously cached records of this type
        //      - deletes cached records of same OR inferior rank
        //
        //  note that we use main loop here, we essentially cut current
        //  and delete it, resetting current to previous so we pick up
        //  next record after pcurRR next time through the loop

        if ( IS_CACHE_RR(pcurRR) )
        {
            pprevRR->pRRNext = pcurRR->pRRNext;
            RR_Free( pcurRR );
            pcurRR = pprevRR;
            continue;
        }

        //  break when reach record of lower rank (glue, root hint)
        //  all cached records were deleted by previous passes

#if DBG
        if ( rank > RR_RANK(pcurRR) )
        {
            IF_DEBUG( READ2 )
            {
                Dbg_DbaseRecord(
                    "Inferior RR in list after cached records cleared.\n",
                    pcurRR );
            }
            ASSERT( !IS_CACHE_RR(pcurRR) && IS_ROOT_HINT_TYPE(type) );
        }
#endif
        break;
    }

    //
    //  kill off duplicates and set TTL
    //
    //  TTL for cached record is time when record will timeout =>
    //      (query time + TTL)
    //  needed to have both times passed so we can determine zero TTLs
    //
    //  need to kill duplicates as NS queries, can generate responses that
    //  have identical Answer and Authority sections and if single RR, then
    //  can have duplicate RRs in Additional section for same node and type
    //

    dwQueryTime += dwTtl;

    prr = pFirstRR;
    do
    {
        prrTestPrevious = prr;
        while ( prrTest = NEXT_RR(prrTestPrevious) )
        {
            //  check for duplicate record
            //      - ignore TTL in check

            if ( !RR_Compare( prr, prrTest, 0 ) )
            {
                prrTestPrevious = prrTest;
                continue;
            }

            //  duplicate record
            //      - hack it out and toss it
            //      - if duplicate is last RR, reset pLastRR

            DNS_DEBUG( READ, (
                "Duplicate record %p in caching RR set.\n"
                "    removing record from cached set.\n",
                prrTest ));

            prrTestPrevious->pRRNext = prrTest->pRRNext;
            RR_Free( prrTest );

            if ( prrTestPrevious->pRRNext == NULL )
            {
                pLastRR = prrTestPrevious;
                break;
            }
        }

        ASSERT( prr->wType == type && RR_RANK(prr) == rank );

        prr->dwTtlSeconds = dwQueryTime;
        if ( dwTtl == 0 )
        {
            SET_ZERO_TTL_RR( prr );
        }

        STAT_INC( RecordStats.CacheCurrent );
        STAT_INC( RecordStats.CacheTotal );

    }
    while( prr = NEXT_RR( prr ) );

    //
    //  put RR set between pprevRR and pcurRR
    //

    pprevRR->pRRNext = pFirstRR;
    pLastRR->pRRNext = pcurRR;

    //
    //  put node in timeout list
    //

    Timeout_SetTimeoutOnNodeEx(
        pNode,
        dwTtl,
        TIMEOUT_NODE_LOCKED );

    DNS_DEBUG( READ, (
        "Cached (type %d) (rank %x) (ttl=%d) (timeout=%d) records at node (label=%s)\n",
        type,
        rank,
        dwTtl,
        dwQueryTime,
        pNode->szLabel ));
    IF_DEBUG( READ2 )
    {
        Dbg_DbaseNode(
            "Domain node after caching RRs\n",
            pNode );
    }

    //
    //  reset node properties
    //      - flags, authority, NS-list

    RR_ListResetNodeFlags( pNode );

    RR_ListVerify( pNode );

    UNLOCK_WRITE_RR_LIST( pNode );

    return TRUE;

Failed:

    //  put node in timeout list anyway

    Timeout_SetTimeoutOnNodeEx(
        pNode,
        0,          // put in next timeout bin for immediate cleanup
        TIMEOUT_NODE_LOCKED );

    //  delete new RR set

    UNLOCK_WRITE_RR_LIST( pNode );

    DNS_DEBUG( READ, (
        "Unable to cache RR set (t=%d, r=%x) at node (%s).\n"
        "    deleting new RR set.\n",
        type,
        rank,
        pNode->szLabel ));

    RR_ListFree( pFirstRR );

    return FALSE;
}



VOID
RR_ListTimeout(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Delete timed out RR in node's RR list.

    This function also may use globals set by the enforceCacheLimit
    function to throw out nodes that are not fully timed out.

Arguments:

    pNode -- ptr to node containing RR list

Return Value:

    None

--*/
{
    PDB_RECORD      prr;
    PDB_RECORD      pprevRR;
    WORD            wtypeDelete = 0;
    DWORD           dwTimeAdjust = g_dwCacheLimitCurrentTimeAdjustment;

    RR_ListVerify( pNode );

    DNS_DEBUG( DATABASE, (
        "Timeout delete of RR list for node at %p.\n"
        "    ref count = %d\n",
        pNode,
        pNode->cReferenceCount ));

    LOCK_WRITE_RR_LIST( pNode );

    //
    //  Check cached NAME_ERROR node.
    //

    if ( IS_NOEXIST_NODE( pNode ) )
    {
        if ( RR_CheckNameErrorTimeout( pNode, FALSE, NULL, NULL ) )
        {
            goto Unlock;
        }
    }

    //
    //  Traverse node's RR list check each RR for timeout.
    //

    pprevRR = START_RR_TRAVERSE( pNode );

    while ( prr = pprevRR->pRRNext )
    {
        ASSERT( IS_DNS_HEAP_DWORD( prr ) );

        //
        //  delete only if
        //      - cached node
        //      - cached TTL has expired
        //

        if ( IS_CACHE_RR( prr ) && 
            ( dwTimeAdjust == DNS_CACHE_LIMIT_DISCARD_ALL ||
                prr->dwTtlSeconds < DNS_TIME() + dwTimeAdjust ) )
        {
            //  first cut RR from list (set previous next ptr to next)

            pprevRR->pRRNext = prr->pRRNext;
            wtypeDelete = prr->wType;

            ++g_dwCacheFreeCount;

            RR_Free( prr );
            continue;
        }

        //
        //  not deleting -- setup to check next record
        //
        //  RR sets (same type) MUST be deleted in their entirety
        //  so no delete MUST be new type from any previous delete
        //  unless this is NOT cache data (case of delegation where
        //  both cache and load data is at node)
        //

        ASSERT( prr->wType != wtypeDelete || !IS_CACHE_RR(prr) );
        pprevRR = prr;
    }

    //  reset node properties
    //      - flags, authority, NS-list

    if ( wtypeDelete != 0 )
    {
        RR_ListResetNodeFlags( pNode );

        DB_CLEAR_TYPE_ALL_TTL( pNode );
    }

    //
    //  If the node now has no records and is a cache node, we must
    //  enter the node in the timeout system so it will get deleted.
    //

    if ( EMPTY_RR_LIST( pNode ) &&
         IS_CACHE_TREE_NODE( pNode ) &&
         !IS_TIMEOUT_NODE( pNode ) )
    {
        Timeout_SetTimeoutOnNodeEx(
            pNode,
            0,
            TIMEOUT_NODE_LOCKED );
    }

Unlock:

    RR_ListVerify( pNode );

    UNLOCK_WRITE_RR_LIST( pNode );

    return;
}




//
//  Delete functions
//

DNS_STATUS
RR_DeleteMatchingRecordFromNode(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR
    )
/*++

Routine Description:

    Delete a known record from node.

    Note this is used by RPC functions so there is no guarantee that
    the record actually exists.

    Unlike matching handle function below, this function doesn't require
    that this be an authoritative zone or provide for update functionality,
    and it actually DELETEs the record.

Arguments:

    pNode - node owning RR

    pRR - ptr to resource record

Return Value:

    ERROR_SUCCESS if record found and deleted.
    DNS_ERROR_RECORD_DOES_NOT_EXIST otherwise.

--*/
{
    PDB_RECORD  pcurrent;
    PDB_RECORD  pback;

    DNS_DEBUG( UPDATE, (
        "RR_DeleteMatchingRecordFromNode()\n"
        "    pnode = %p\n"
        "    handle to delete = %p\n",
        pNode,
        pRR ));

    LOCK_WRITE_RR_LIST( pNode );
    RR_ListVerify( pNode );

    if ( IS_NOEXIST_NODE( pNode ) )
    {
        UNLOCK_WRITE_RR_LIST( pNode );
        return DNS_ERROR_RECORD_DOES_NOT_EXIST;
    }

    //
    //  traverse list
    //      - find\remove RR matching data
    //

    pcurrent = START_RR_TRAVERSE( pNode );

    while ( pback = pcurrent, pcurrent = pcurrent->pRRNext )
    {
        ASSERT( IS_DNS_HEAP_DWORD(pcurrent) );

        if ( pcurrent == pRR )
        {
            pback->pRRNext = pcurrent->pRRNext;
            goto Free;
        }
    }

    //  if RR not found in list, bogus call

    ASSERT( pcurrent == NULL );
    UNLOCK_WRITE_RR_LIST( pNode );
    return DNS_ERROR_RECORD_DOES_NOT_EXIST;

Free:

    //
    //  reset node properties
    //      - flags, authority, NS-list

    RR_ListResetNodeFlags( pNode );

    //  if root hint, mark cache zone dirty

    if ( IS_ROOT_HINT_RR(pRR) )
    {
        if ( g_pCacheZone )
        {
            g_pCacheZone->fDirty = TRUE;
        }
        ELSE_IF_DEBUG( ANY )
        {
            DNS_PRINT(( "ERROR:  deleting root hint RR with NO cache zone!\n" ));
            Dbg_DbaseRecord(
                "Root hint record being deleted without cache zone\n",
                pRR );
        }
    }

    //  prr is now cut out of the RR list and node flags updated

    RR_ListVerify( pNode );
    UNLOCK_WRITE_RR_LIST( pNode );

    RR_Free( pRR );

    return ERROR_SUCCESS;
}



VOID
RR_ListDelete(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Delete node's RR list.

Arguments:

    pNode -- ptr to node containing RR list

Return Value:

    None

--*/
{
    PDB_RECORD  prr;

    DNS_DEBUG( DATABASE, (
        "RR list delete of node at %p.\n"
        "    ref count = %d\n",
        pNode,
        pNode->cReferenceCount ));

    LOCK_WRITE_RR_LIST( pNode );

    RR_ListVerify( pNode );

    DB_CLEAR_TYPE_ALL_TTL( pNode );
    
    //
    //  check cached NAME_ERROR node
    //      - reset if timed out
    //

    if ( IS_SELECT_NODE( pNode ) )
    {
        UNLOCK_WRITE_RR_LIST( pNode );
        return;
    }
    if ( IS_NOEXIST_NODE( pNode ) )
    {
        RR_RemoveCachedNameError( pNode );
        UNLOCK_WRITE_RR_LIST( pNode );
        return;
    }

    //
    //  Delete RRs from cache: cannot delete this RR list if any of
    //  the RRs are root hint RRs.
    //
    //  DEVNOTE: there are 2 ways this could be improved:
    //  1) Delete all RRs in the the list except for root hints RRs
    //  2) Move roothint RRs to separate tree -> this is probably a
    //      good long-term work item
    //

    if ( IS_CACHE_TREE_NODE( pNode ) )
    {
        prr = START_RR_TRAVERSE( pNode );

        WHILE_MORE_RR( prr )
        {
            if ( IS_ROOT_HINT_RR( prr ) )
            {
                //  Cannot delete this RR list!

                UNLOCK_WRITE_RR_LIST( pNode );
                return;
            }
        }
    }

    //
    //  cut node's RR list
    //      - will delete after releasing lock for perf
    //

    prr = pNode->pRRList;
    pNode->pRRList = NULL;

    RR_ListResetNodeFlags( pNode );

    RR_ListVerify( pNode );

    RR_ListFree( prr );
    
    //
    //  If the node now has no records and is a cache node, we must
    //  enter the node in the timeout system so it will get deleted.
    //

    if ( EMPTY_RR_LIST( pNode ) &&
         IS_CACHE_TREE_NODE( pNode ) &&
         !IS_TIMEOUT_NODE( pNode ) )
    {
        Timeout_SetTimeoutOnNodeEx(
            pNode,
            0,
            TIMEOUT_NODE_LOCKED );
    }

    UNLOCK_WRITE_RR_LIST( pNode );
}



VOID
RR_ListDeleteType(
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wType
    )
/*++

Routine Description:

    Delete all RRs of the specified type from the node's RR list.

Arguments:

    pNode -- ptr to node containing RR list

    wType -- type of RRs to delete

Return Value:

    None

--*/
{
    PDB_RECORD  prr;
    PDB_RECORD  pprevRR;
    PDB_RECORD  pnextRR;

    DNS_DEBUG( DATABASE, (
        "RR list delete type %d of node at %p.\n"
        "    ref count = %d\n",
        wType,
        pNode,
        pNode->cReferenceCount ));

    LOCK_WRITE_RR_LIST( pNode );

    RR_ListVerify( pNode );

    DB_CLEAR_TYPE_ALL_TTL( pNode );
    
    //
    //  If this is a NOEXIST node, remove cached NOEXIST.
    //

    if ( IS_SELECT_NODE( pNode ) )
    {
        UNLOCK_WRITE_RR_LIST( pNode );
        return;
    }
    if ( IS_NOEXIST_NODE( pNode ) )
    {
        RR_RemoveCachedNameError( pNode );
        UNLOCK_WRITE_RR_LIST( pNode );
        return;
    }

    //
    //  Delete matching RRs from cache but do not delete root hint RRs.
    //

    prr = START_RR_TRAVERSE( pNode );
    
    for ( pprevRR = NULL, prr = NEXT_RR( prr );
          prr != NULL;
          pprevRR = prr, prr = pnextRR )
    {
        //
        //  Need to read the value of the next RR pointer up front in
        //  case this RR is freed.
        //
        
        pnextRR = NEXT_RR( prr );

        if ( IS_ROOT_HINT_RR( prr ) )
        {
            continue;
        }

        if ( prr->wType == wType )
        {
            //
            //  Cut this RR from the list and free it.
            //

            if ( pprevRR )
            {
                pprevRR->pRRNext = prr->pRRNext;
            }
            else
            {
                pNode->pRRList = prr->pRRNext;
            }
            RR_Free( prr );
        }
        else if ( prr->wType > wType )
        {
            break;      //  Records are in type order.
        }
    }

    //
    //  Reset node properties: flags, authority, NS-list.
    //

    RR_ListResetNodeFlags( pNode );

    //
    //  If the node now has no records and is a cache node, we must
    //  enter the node in the timeout system so it will get deleted.
    //

    if ( EMPTY_RR_LIST( pNode ) &&
         IS_CACHE_TREE_NODE( pNode ) &&
         !IS_TIMEOUT_NODE( pNode ) )
    {
        Timeout_SetTimeoutOnNodeEx(
            pNode,
            0,
            TIMEOUT_NODE_LOCKED );
    }

    RR_ListVerify( pNode );

    UNLOCK_WRITE_RR_LIST( pNode );
}   //  RR_ListDeleteType



//
//  Dynamic update RR list routines
//

BOOL
RR_ListIsMatchingType(
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    )
/*++

Routine Description:

    Does node's RR list contain desired type.

    For use by UPDATE preconditions.
    Note:  no locking as assuming database locked for UPDATE.

Arguments:

    pNode -- ptr to node

    wType -- desired type

Return Value:

    None

--*/
{
    PDB_RECORD  prr;
    BOOL        result;

    if ( !pNode )
    {
        return FALSE;
    }

    result = FALSE;

    LOCK_WRITE_RR_LIST( pNode );

    //  delete cached data

    deleteCachedRecordsForUpdate( pNode );

    //
    //  if no data -> FALSE
    //  if ANY type -> TRUE
    //

    if ( !pNode->pRRList )
    {
        goto Done;
    }
    else if ( wType == DNS_TYPE_ALL )
    {
        result = TRUE;
        goto Done;
    }

    //
    //  traverse list, find matching type
    //      - ignore cached records in check
    //

    prr = START_RR_TRAVERSE( pNode );

    while ( prr = prr->pRRNext )
    {
        //  past matching records? -- no match

        if ( wType < prr->wType )
        {
            break;
        }
        if ( wType == prr->wType && !IS_CACHE_RR(prr) )
        {
            result = TRUE;
            break;
        }
        continue;
    }

    //  out of RRs -- no match

Done:

    UNLOCK_WRITE_RR_LIST( pNode );
    return result;
}



BOOL
RR_ListIsMatchingSet(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pCheckRRList,
    IN      BOOL            bForceRefresh
    )
/*++

Routine Description:

    Check for matching RR set at node.

    Essentially for update preconditions checking.

Arguments:

    pNode -- ptr to node to add resource record to

    pRRList -- RR set to match with existing

    bForceRefresh -- force aging refresh

Return Value:

    TRUE if match
    FALSE on error

--*/
{
    PDB_RECORD      prr;
    PDB_RECORD      prrSetStart = NULL;
    PDB_RECORD      prrSetEnd = NULL;
    PDB_RECORD      prrSetEndNext;
    WORD            type;
    DWORD           result = RRLIST_NO_MATCH;

    ASSERT( pNode != NULL );
    ASSERT( pCheckRRList != NULL );


    LOCK_WRITE_RR_LIST( pNode );

    //  delete cached data
    //  if no data left -> no match

    deleteCachedRecordsForUpdate( pNode );
    if ( !pNode->pRRList )
    {
        goto NoMatch;
    }

    //
    //  find start and end of RR existing RR set
    //

    type = pCheckRRList->wType;
    prr = START_RR_TRAVERSE( pNode );

    while ( prr = NEXT_RR(prr) )
    {
        if ( prr->wType == type )
        {
            prrSetEnd = prr;
            if ( !prrSetStart )
            {
                prrSetStart = prr;
            }
            continue;
        }
        if ( prr->wType < type )
        {
            continue;
        }
        break;
    }

    //
    //  truncated RR list at end of set so that we can call RR_ListCompare()
    //      - first need to save pNextRR of last RR in set
    //

    if ( !prrSetStart )
    {
        goto NoMatch;
    }
    ASSERT( prrSetEnd );
    prrSetEndNext = NEXT_RR( prrSetEnd );
    NEXT_RR( prrSetEnd ) = NULL;


    //
    //  compare RR set
    //      - ignore TTL and refresh time in compare
    //      - force refresh if flag set
    //

    result = RR_ListCompare(
                prrSetStart,
                pCheckRRList,
                0,
                bForceRefresh
                    ? FORCE_REFRESH_DUMMY_TIME
                    : 0 );

    //  restore rest of list to node's RR list

    NEXT_RR( prrSetEnd ) = prrSetEndNext;

NoMatch:

    UNLOCK_WRITE_RR_LIST( pNode );
    return result == RRLIST_MATCH;
}



BOOL
RR_ListIsMatchingList(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRRList,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Check for record list exact match to nodes.

Arguments:

    pNode -- ptr to node to add resource record to

    pRRList -- RR set to match with existing

    dwFlags -- comparison flags

Return Value:

    TRUE if match
    FALSE on error

--*/
{
    DWORD   result;

    ASSERT( pNode != NULL );

    LOCK_WRITE_RR_LIST( pNode );

    //  delete cached data
    //  if no data left -> no match

    deleteCachedRecordsForUpdate( pNode );

    //
    //  compare RR set
    //      - ignore TTL in compare
    //

    result = RR_ListCompare(
                pNode->pRRList,
                pRRList,
                dwFlags,
                0 );                // no refresh time checking

    UNLOCK_WRITE_RR_LIST( pNode );

    return result == RRLIST_MATCH;
}



DWORD
RR_ListCheckIfNodeNeedsRefresh(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRRList,
    IN      DWORD           dwRefreshTime
    )
/*++

Routine Description:

    Check for record list exact match to nodes.

Arguments:

    pNode -- ptr to node to add resource record to

    pRRList -- RR set to match with existing

    dwRefreshTime -- refresh time for zone
        see RR_ListCompare() for detailed description of return codes

Return Value:

    RRLIST_MATCH            -- matches completely
    RRLIST_AGING_REFRESH    -- matches, but aging requires refresh
    RRLIST_AGING_OFF        -- matches, but aging turning off on a record
    RRLIST_AGING_ON         -- matches, but aging turning on on a record
    RRLIST_NO_MATCH         -- no match, record is different

--*/
{
    DWORD   result;

    ASSERT( pNode != NULL );

    LOCK_WRITE_RR_LIST( pNode );

    //  delete cached data
    //  if no data left -> no match

    deleteCachedRecordsForUpdate( pNode );

    //
    //  compare RR set
    //

    result = RR_ListCompare(
                pNode->pRRList,
                pRRList,
                DNS_RRCOMP_CHECK_TTL,
                dwRefreshTime );

    UNLOCK_WRITE_RR_LIST( pNode );

    return result;
}



VOID
RR_ListResetNodeFlags(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Reset node flags after UPDATE add or delete.

Arguments:

    pNode -- ptr to node

Return Value:

    None

--*/
{
    PDB_RECORD  prr;
    WORD        type;
    DWORD       mask;
    BOOL        foundNs = FALSE;

    DNS_DEBUG( UPDATE, (
        "RR_ListResetNodeFlags( %p, %s )\n"
        "    current flags = 0x%08x\n",
        pNode, pNode->szLabel,
        pNode->dwNodeFlags ));

    ASSERT( IS_LOCKED_NODE( pNode ) );


    //
    //  DEVNOTE: issue clearly ZONE_ROOT flag at top of cache
    //      currently we mark top of cache tree as ZONE_ROOT;
    //      if never cache NS records, and get a response at zone
    //      root (for any type), we'd end up running through this
    //      function with no NS records in the list and hence clear
    //      the ZONE_ROOT flag;   not sure if this merits any
    //      special casing as i haven't seen any effect of this
    //      accepting hitting ASSERT() in recurse.c
    //      Rec_CheckForDelegation() (currently line 2732);  i'm
    //      simply removing the ASSERT() there as the safer solution
    //

    //
    //  clear current mask of ZONE_ROOT and CNAME flags
    //

    mask = pNode->dwNodeFlags & ~( NODE_ZONE_ROOT | NODE_CNAME );

    //
    //  check all records, set mask if find NS, SOA or CNAME
    //      - re-rank new delegation NS records
    //      they can be miss marked on full list replace from DS poll
    //

    prr = START_RR_TRAVERSE( pNode );

    while ( prr = prr->pRRNext )
    {
        type = prr->wType;

        if ( type == DNS_TYPE_NS )
        {
            foundNs = TRUE;
            mask |= NODE_ZONE_ROOT;

            //  if node is NOT auth zone root, then NS are delegation RRs

            if ( IS_ZONE_TREE_NODE( pNode ) && !(mask & NODE_AUTH_ZONE_ROOT) )
            {
                SET_RANK_NS_GLUE(prr);
            }
        }
        else if ( type == DNS_TYPE_SOA )
        {
            ASSERT( !IS_ZONE_TREE_NODE( pNode ) || IS_AUTH_ZONE_ROOT( pNode ) );
            mask |= NODE_ZONE_ROOT;
        }
        else if ( type == DNS_TYPE_CNAME )
        {
            mask |= NODE_CNAME;
        }
    }

    //  reset node's mask

    pNode->dwNodeFlags = mask;

    //
    //  set authority if delegation
    //  clear authority if lost delegation
    //

    if ( !IS_AUTH_ZONE_ROOT( pNode ) )
    {
        if ( foundNs )
        {
            if ( IS_AUTH_NODE( pNode ) )
            {
                SET_DELEGATION_NODE( pNode );
            }
            //Rec_MarkNodeNsListDirty( pNode );
        }
        else
        {
            if ( IS_DELEGATION_NODE( pNode ) )
            {
                SET_AUTH_NODE( pNode );
            }
            //Rec_DeleteNodeNsList( pNode );
        }
    }
    
    //
    //  If the node now has no records and is a cache node, we must
    //  enter the node in the timeout system so it will get deleted.
    //

    if ( EMPTY_RR_LIST( pNode ) &&
         IS_CACHE_TREE_NODE( pNode ) &&
         !IS_TIMEOUT_NODE( pNode ) )
    {
        Timeout_SetTimeoutOnNodeEx(
            pNode,
            0,
            TIMEOUT_NODE_LOCKED );
    }
}



DNS_STATUS
RR_ListDeleteMatchingRecordHandle(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR,
    IN OUT  PUPDATE_LIST    pUpdateList     OPTIONAL
    )
/*++

Routine Description:

    Delete record matching given record from RR list.

    For use by NT4 admin update, where passed a handle to the actual
    record.

Arguments:

    pNode -- ptr to node

    pRR -- ptr to record to delete

    pUpdateList -- update list if deleting in zone

Return Value:

    None

--*/
{
    PDB_RECORD  pcurrent;
    PDB_RECORD  pback;
    WORD        type;
    BOOL        ffoundNs = FALSE;
    DNS_STATUS  status;

    DNS_DEBUG( UPDATE, (
        "RR_ListDeleteMatchingRecordHandle()\n"
        "    pnode = %p\n"
        "    handle to delete = %p\n",
        pNode,
        pRR ));

    LOCK_WRITE_RR_LIST( pNode );

    RR_ListVerify( pNode );

    DB_CLEAR_TYPE_ALL_TTL( pNode );

    //  delete cached data
    //  if no data left -> no record deleted

    deleteCachedRecordsForUpdate( pNode );
    if ( !pNode->pRRList )
    {
        goto NoMatch;
    }

    //
    //  traverse list
    //      - find\remove RR matching data
    //      - or reach end
    //

    pcurrent = START_RR_TRAVERSE( pNode );

    while ( pback = pcurrent, pcurrent = pcurrent->pRRNext )
    {
        ASSERT( IS_DNS_HEAP_DWORD(pcurrent) );

        //  no match, continue
        //  if pass NS record, then can delete NS record no matter
        //  what value it has

        if ( pcurrent != pRR )
        {
            if ( pcurrent->wType == DNS_TYPE_NS )
            {
                ffoundNs = TRUE;
            }
            continue;
        }

        //  found matching record -- cut
        //  however, don't delete SOA or last NS record from zone root

        type = pcurrent->wType;

        if ( type == DNS_TYPE_SOA )
        {
            DNS_DEBUG( UPDATE, ( "    Refusing SOA record delete.\n" ));
            ASSERT( IS_AUTH_ZONE_ROOT( pNode ) );
            status = DNS_ERROR_SOA_DELETE_INVALID;
            goto Failed;
        }

        //  don't delete last NS from zone root
        //  however do allow delete of last NS from delegation and reset zone
        //      root flag -- delegation is history

        if ( type == DNS_TYPE_NS &&
            ! ffoundNs &&
            ( !pcurrent->pRRNext || pcurrent->pRRNext->wType != DNS_TYPE_NS ) )
        {
            if ( IS_AUTH_ZONE_ROOT( pNode ) )
            {
                DNS_DEBUG( UPDATE, ( "    Refusing delete of last NS record.\n" ));
                status = DNS_ERROR_SOA_DELETE_INVALID;
                goto Failed;
            }
            CLEAR_ZONE_ROOT( pNode );
        }

        pback->pRRNext = pcurrent->pRRNext;
        pcurrent->pRRNext = NULL;

        //  reset node properties
        //      - flags, authority, NS-list

        RR_ListResetNodeFlags( pNode );

        RR_ListVerify( pNode );
        UNLOCK_WRITE_RR_LIST( pNode );

        //
        //  if update, save delete record and its type
        //  otherwise, delete it
        //
        //  DEVNOTE: fix to use direct delete type

        if ( pUpdateList )
        {
            PUPDATE pupdate;
            pupdate = Up_CreateAppendUpdate(
                            pUpdateList,
                            pNode,
                            NULL,       // no add
                            type,       // delete type
                            pcurrent    // delete record
                            );
            IF_NOMEM( !pupdate )
            {
                return( DNS_ERROR_NO_MEMORY );
            }
            pUpdateList->iNetRecords--;
        }
        else
        {
            RR_Free( pcurrent );
        }
        return ERROR_SUCCESS;
    }

NoMatch:

    DNS_DEBUG( UPDATE, (
        "No matching RR to UPDATE delete record\n" ));
    status = DNS_ERROR_RECORD_DOES_NOT_EXIST;

Failed:

    UNLOCK_WRITE_RR_LIST( pNode );

    return status;
}



PDB_RECORD
RR_UpdateDeleteMatchingRecord(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Delete record matching given record from RR list.

    For use by UPDATE.

Arguments:

    pNode -- ptr to node

    pRR   -- temp RR to delete matching records for

Return Value:

    Record matching desired record, if exists.
    NULL if not found.

--*/
{
    PDB_RECORD  pcurrent;
    PDB_RECORD  pback;
    WORD        type = pRR->wType;
    WORD        dataLength = pRR->wDataLength;

    IF_DEBUG( UPDATE )
    {
        DnsDebugLock();
        DNS_PRINT((
            "RR_UpdateDeleteMatchingRecord()\n"
            "    pnode = %p\n",
            pNode ));
        Dbg_DbaseRecord(
            "RR_UpdateDeleteMatchingRecord()",
            pRR );
        DnsDebugUnlock();
    }

    LOCK_WRITE_RR_LIST( pNode );

    RR_ListVerify( pNode );

    DB_CLEAR_TYPE_ALL_TTL( pNode );
    
    //  delete cached data
    //  if no data left -> no record deleted

    deleteCachedRecordsForUpdate( pNode );
    if ( !pNode->pRRList )
    {
        pcurrent = NULL;
        goto Unlock;
    }

    //
    //  traverse list
    //      - find\remove RR matching data
    //      - or reach end
    //

    pcurrent = START_RR_TRAVERSE( pNode );

    while ( pback = pcurrent, pcurrent = pcurrent->pRRNext )
    {
        ASSERT( IS_DNS_HEAP_DWORD( pcurrent ) );

        //  past matching records? -- stop
        //  before -- continue

        if ( type < pcurrent->wType )
        {
            break;
        }
        if ( type > pcurrent->wType )
        {
            continue;
        }

        //  match datalength, then data
        //  if no match set flag to indicate already checked record of
        //  desired type;  need this for NS

        if ( dataLength != pcurrent->wDataLength ||
             ! RtlEqualMemory(
                    & pRR->Data,
                    & pcurrent->Data,
                    dataLength ) )
        {
            DNS_DEBUG( UPDATE, (
                "    Matched delete record type, failed data match\n" ));
            IF_DEBUG( UPDATE )
            {
                Dbg_DbaseRecord(
                    "no-match record",
                    pcurrent );
            }
            continue;
        }

        //
        //  exact match -- cut
        //
        //  special processing for
        //      - SOA (no delete)
        //      - NS (allow removal of last NS?)
        //      - FIXED_TTL cache records
        //

        if ( type != DNS_TYPE_A )
        {
            if ( type == DNS_TYPE_SOA )
            {
                if ( IS_AUTH_ZONE_ROOT( pNode ) )
                {
                    DNS_DEBUG( UPDATE, ( "Failed SOA record delete.\n" ));
                    break;
                }
                //  if have SOA, better have been in zone at root
                ASSERT( FALSE );
            }
        }

        if ( IS_FIXED_TTL_RR( pcurrent ) && IS_CACHE_TREE_NODE( pNode ) )
        {
            pcurrent = NULL;
            goto Unlock;
        }

        //  cut the record

        pback->pRRNext = pcurrent->pRRNext;
        pcurrent->pRRNext = NULL;

        DNS_DEBUG( UPDATE, (
            "Update matched and deleted record (%p type=%d) from node (%s)\n",
            pcurrent,
            type,
            pNode->szLabel ));
        goto Done;
    }

    DNS_DEBUG( UPDATE, (
        "Failed to match update delete record (type=%d) at node (%s)\n",
        type,
        pNode->szLabel ));

    UNLOCK_WRITE_RR_LIST( pNode );
    return NULL;

    Done:

    RR_ListResetNodeFlags( pNode );
    RR_ListVerify( pNode );
    
    Unlock: 

    UNLOCK_WRITE_RR_LIST( pNode );
    return pcurrent;
}



PDB_RECORD
RR_UpdateDeleteType(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wDeleteType,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Delete and return records matching a given type.

    For use by UPDATE.

Arguments:

    pNode -- ptr to node

    wDeleteType -- type to delete or type ANY

    dwFlag -- flag on update

Return Value:

    List of records deleted.
    NULL if no records deleted.

--*/
{
    PDB_RECORD  pcurrent;
    WORD        typeCurrent;
    PDB_RECORD  pdelete = NULL;
    PDB_RECORD  pdeleteLast;
    PDB_RECORD  pbeforeDelete;

    ASSERT( !IS_COMPOUND_TYPE_EXCEPT_ANY(wDeleteType) );

    LOCK_WRITE_RR_LIST( pNode );

    RR_ListVerify( pNode );

    DB_CLEAR_TYPE_ALL_TTL( pNode );

    //
    //  for zone update, clear cached data
    //
    //  this routine also called from Rpc_DeleteRecordSet() and
    //  obviously must skip cache record delete for cache data
    //

    if ( pZone )
    {
        deleteCachedRecordsForUpdate( pNode );
    }

    //
    //  regular type -- traverse list
    //      - find\remove RR matching data
    //      - or reach end
    //      - can NOT delete SOA or all NS at zone root
    //      the SOA restriction we always enforce,
    //      the NS restriction we limit to actual dynamic update packet
    //

    if ( wDeleteType != DNS_TYPE_ALL )
    {
        if ( IS_AUTH_ZONE_ROOT( pNode ) )
        {
            if ( wDeleteType == DNS_TYPE_SOA
                ||
               ( wDeleteType == DNS_TYPE_NS && (dwFlag & DNSUPDATE_PACKET) ) )
            {
                goto NotFound;
            }
#if 0
            if ( IS_WINS_TYPE( wDeleteType )
            {
                Wins_StopZoneWinsLookup( pZone );
            }
#endif
        }

        pcurrent = START_RR_TRAVERSE( pNode );
        pbeforeDelete = pcurrent;

        while ( pcurrent = pcurrent->pRRNext )
        {
            ASSERT( IS_DNS_HEAP_DWORD(pcurrent) );

            typeCurrent = pcurrent->wType;

            //  found delete type
            //      - save ptr to first record

            if ( typeCurrent == wDeleteType )
            {
                if ( !pdelete )
                {
                    pdelete = pcurrent;
                }
                pdeleteLast = pcurrent;
                continue;
            }

            //  before matching records -- continue

            if ( typeCurrent < wDeleteType )
            {
                pbeforeDelete = pcurrent;
                continue;
            }
            break;      //  past matching records -- stop
        }

        if ( pdelete )
        {
            DNS_DEBUG( UPDATE, (
                "Deleted record(s) type=%d at node %p.\n",
                wDeleteType,
                pNode ));

            pdeleteLast->pRRNext = NULL;        // NULL terminate delete list
            ASSERT( pbeforeDelete );
            pbeforeDelete->pRRNext = pcurrent;  // patch up RR list
        }
    }

    //
    //  type all
    //

    else
    {
        //
        //  if NOT at zone root, just cut out entire list
        //
        //  clear forced ENUM of node:  deleting all records is the
        //  way admin can do subtree delete, so should not force enumeration
        //  after delete;  (enum may still occur because of children that
        //  need enumeration)
        //

        if ( !IS_AUTH_ZONE_ROOT( pNode ) )
        {
            pdelete = pNode->pRRList;
            pNode->pRRList = NULL;
            CLEAR_ENUM_NODE( pNode );
        }

        //
        //  if at zone root, must traverse to avoid deleting SOA or NS
        //

        //  DEVNOTE: this should be common code with replace function
        //      either just call it if type ALL
        //      or just here when need to fix up zone root
        //
        //  DEVNOTE: both should save\require SOA and NS of THIS server
        //

        else
        {
            PDB_RECORD      psaveLast;

            psaveLast = START_RR_TRAVERSE( pNode );
            pcurrent = psaveLast;

            while ( pcurrent = pcurrent->pRRNext )
            {
                ASSERT( IS_DNS_HEAP_DWORD(pcurrent) );

                typeCurrent = pcurrent->wType;

                if ( typeCurrent == DNS_TYPE_SOA
                    || typeCurrent == DNS_TYPE_NS )
                {
                    psaveLast->pRRNext = pcurrent;
                    psaveLast = pcurrent;
                    continue;
                }

                if ( !pdelete )
                {
                    pdelete = pcurrent;
                }
                else
                {
                    pdeleteLast->pRRNext = pcurrent;
                }
                pdeleteLast = pcurrent;
            }

            //  make sure delete list and saved list NULL terminated

            if ( pdelete )
            {
                pdeleteLast->pRRNext = NULL;
                psaveLast->pRRNext = NULL;
            }
        }
    }

    //
    //  successful delete
    //
    //  reset node properties
    //      - flags, authority, NS-list

    if ( pdelete )
    {
        RR_ListResetNodeFlags( pNode );
    }

NotFound:

    //
    //  If the node now has no records and is a cache node, we must
    //  enter the node in the timeout system so it will get deleted.
    //

    if ( EMPTY_RR_LIST( pNode ) &&
         IS_CACHE_TREE_NODE( pNode ) &&
         !IS_TIMEOUT_NODE( pNode ) )
    {
        Timeout_SetTimeoutOnNodeEx(
            pNode,
            0,
            TIMEOUT_NODE_LOCKED );
    }

    RR_ListVerify( pNode );

    UNLOCK_WRITE_RR_LIST( pNode );

    IF_DEBUG( UPDATE )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Node of delete of type = %d.\n"
            "    return pdelete = %p\n",
            wDeleteType,
            pdelete ));
        Dbg_DbaseNode(
            "Node after type delete:\n",
            pNode );
        DnsDebugUnlock();
    }
    return( pdelete );
}



PDB_RECORD
RR_UpdateScavenge(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Delete expired records.
    For use by UPDATE.

Arguments:

    pZone -- zone being updated

    pNode -- ptr to node

    dwFlag -- flag on update

Return Value:

    List of expired records deleted.
    NULL if no records deleted.

--*/
{
    PDB_RECORD  prr;
    PDB_RECORD  pback;
    PDB_RECORD  pdeleteFirst = NULL;
    PDB_RECORD  pdeleteLast;
    DWORD       expireTime;


    //
    //  get expire time for zone
    //

    expireTime = AGING_ZONE_EXPIRE_TIME(pZone);

    DNS_DEBUG( UPDATE, (
        "RR_UpdateScavenge( %s, expire=%d )\n",
        pNode->szLabel,
        expireTime ));

    //
    //  search list and scavenge any dead entries
    //

    LOCK_WRITE_RR_LIST( pNode );
    RR_ListVerify( pNode );

    //  for zone update, clear cached data

    if ( pZone )
    {
        deleteCachedRecordsForUpdate( pNode );
    }

    prr = START_RR_TRAVERSE( pNode );

    while ( pback = prr, prr = NEXT_RR(pback) )
    {
        //  if non-aging or not expired, continue

        if ( !AGING_IS_RR_EXPIRED( prr, expireTime ) )
        {
            continue;
        }

        //  non-scavenging type

        if ( IS_NON_SCAVENGE_TYPE( prr->wType ) )
        {
            continue;
        }

        //  cut scavenged record from list

        pback->pRRNext = prr->pRRNext;
        prr->pRRNext = NULL;

        if ( !pdeleteFirst )
        {
            pdeleteFirst = prr;
        }
        else
        {
            pdeleteLast->pRRNext = prr;
        }
        pdeleteLast = prr;

        //  set so pback will be the same the next time through

        prr = pback;
    }

    //  if deleted records, must reset flags

    if ( pdeleteFirst )
    {
        RR_ListResetNodeFlags( pNode );
    }

    UNLOCK_WRITE_RR_LIST( pNode );

    DNS_DEBUG( UPDATE, (
        "Leave RR_UpdateScavenge( %s )\n"
        "    scavenged record = %s\n",
        pNode->szLabel,
        pdeleteFirst ? "TRUE" : "FALSE" ));

    return  pdeleteFirst;
}



DWORD
RR_UpdateForceAging(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Force aging on records in list.

Arguments:

    pZone -- zone being updated

    pNode -- ptr to node

    dwFlag -- flag on update

Return Value:

    Count of records for which aging turned on.

--*/
{
    PDB_RECORD  prr;
    DWORD       count = 0;

    DNS_DEBUG( UPDATE, (
        "RR_UpdateForceAging( %s )\n",
        pNode->szLabel ));

    //
    //  search list and force aging
    //

    LOCK_WRITE_RR_LIST( pNode );

    //  for zone update, clear cached data

    if ( pZone )
    {
        deleteCachedRecordsForUpdate( pNode );
    }

    prr = START_RR_TRAVERSE( pNode );

    while ( prr = NEXT_RR(prr) )
    {
        //  if already aging or non-scavenge type continue

        if ( prr->dwTimeStamp != 0  ||
            IS_NON_SCAVENGE_TYPE( prr->wType ) )
        {
            continue;
        }

        //  otherwise turn aging on

        prr->dwTimeStamp = g_CurrentTimeHours;
        count++;
    }

    UNLOCK_WRITE_RR_LIST( pNode );

    DNS_DEBUG( UPDATE, (
        "Leave RR_UpdateForceAging( %s )\n"
        "    turned on %d records\n",
        pNode->szLabel,
        count ));

    return  count;
}



//
//  Add RR to node (load and update)
//

DNS_STATUS
RR_AddToNode(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR
    )
/*++

Routine Description:

    Add a resource record to node in database.

Arguments:

    pNode -- ptr to node to add resource record to

    pRR -- resource record to add

Return Value:

    ERROR_SUCCESS -- if successful
    DNS_ERROR_RECORD_ALREADY_EXISTS -- if new record is duplicate
    ErrorCode for CNAME error

--*/
{
    PDB_RECORD      pcurRR;
    PDB_RECORD      pprevRR;
    WORD            type;
    UCHAR           rank;
    DNS_STATUS      status;

    ASSERT( pNode != NULL );
    ASSERT( pRR != NULL );

    //  indicate cache zone with NULL ptr

    if ( pZone && IS_ZONE_CACHE(pZone) )
    {
        pZone = NULL;
    }

    type = pRR->wType;

    LOCK_WRITE_RR_LIST( pNode );

    RR_ListVerify( pNode );

    DB_CLEAR_TYPE_ALL_TTL( pNode );

    //
    //  clear cached NAME_ERROR
    //

    if ( IS_NOEXIST_NODE( pNode ) )
    {
        RR_RemoveCachedNameError( pNode );
    }

    //
    //  check CNAME node special case
    //

    if ( IS_CNAME_NODE( pNode ) || type == DNS_TYPE_CNAME )
    {
        status = checkCnameConditions(
                    pNode,
                    pRR,
                    type );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
    }

    //
    //  enforce RR node restrictions
    //      SOA, WINS, WINSR only at authoritative zone roots
    //      NS at zone root or delegation
    //
    //  DEVNOTE: could screen out non-NS and glue types for cache zone
    //
    //  note, we are setting node flags here, essentially assuming that
    //  below here the ONLY FAILURES are duplicates
    //

    if ( type != DNS_TYPE_A && pZone )
    {
        //
        //  adding NS record, outside root == adding delegation
        //
        //  if this is newly created node, clean out zone properties
        //  which otherwise are inherited during creation from
        //  node's parent
        //
        //  should ONLY be relevant for receiving delegation during XFR
        //

        if ( type == DNS_TYPE_NS )
        {
            if ( !IS_AUTH_ZONE_ROOT( pNode ) )
            {
                //  no delegation can be added UNDER a delegation

                if ( !IS_ZONE_ROOT( pNode ) && !IS_AUTH_NODE( pNode ) )
                {
                    DNS_DEBUG( UPDATE, (
                        "WARNING:  attempt to add NS at node %p inside delegation or\n"
                        "    outside zone.\n",
                        pNode ));
                    status = DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT;
                    goto Done;
                }

                //  create delegation

                SET_ZONE_ROOT( pNode );
                SET_DELEGATION_NODE( pNode );
            }
        }

        //
        //  adding CNAME, set CNAME node
        //

        else if ( type == DNS_TYPE_CNAME )
        {
            SET_CNAME_NODE( pNode );
        }

        //  SOA only at zone root
        //
        //      DEVNOTE: should we always be dirty here?
        //

        else if ( type == DNS_TYPE_SOA )
        {
            if ( ! IS_AUTH_ZONE_ROOT( pNode ) )
            {
                status = DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT;
                goto Done;
            }
        }

        //
        //  WINS record
        //      - catch bogus placement
        //      - catch when LOCAL WINS does not get added to list (for secondary)

        else if ( IS_WINS_TYPE(type) )
        {
            status = Wins_RecordCheck(
                        pZone,
                        pNode,
                        pRR
                        );
            if ( status != ERROR_SUCCESS )
            {
                if ( status == DNS_INFO_ADDED_LOCAL_WINS )
                {
                    status = ERROR_SUCCESS;
                }
                goto Done;
            }
        }
    }

    //
    //  set RANK
    //      - mark glue records as glue
    //      - mark root hints as root hints
    //
    //  note doing this after type NS check, so it can mark node as delegation
    //      before set NS as glue
    //
    //  DEVNOTE: note:  duplicate RANK setting code with file and DS read
    //      see dfread.c and rrds.c for explanation of issues
    //

    if ( pZone )
    {
        if ( pRR->dwTtlSeconds == pZone->dwDefaultTtl )
        {
            SET_ZONE_TTL_RR(pRR);
        }
        rank = RANK_ZONE;
        if ( !IS_AUTH_NODE( pNode ) )
        {
            rank = RANK_GLUE;
            if ( type == DNS_TYPE_NS )
            {
                rank = RANK_NS_GLUE;
            }
        }
    }

    //
    //  mark cache hints
    //      - no TTL (they never hit the wire, they don't time out)
    //

    else  // add to cache can only be root hints
    {
        rank = RANK_ROOT_HINT;
        pRR->dwTtlSeconds = 0;

        if ( type == DNS_TYPE_NS )
        {
            SET_ZONE_ROOT( pNode );
        }
    }

    RR_RANK(pRR) = rank;
    ASSERT( rank != 0  &&  !IS_CACHE_RR(pRR) );


    //
    //  traverse list, until find first resource record of higher type
    //

    pcurRR = START_RR_TRAVERSE( pNode );

    while ( pprevRR = pcurRR, pcurRR = pprevRR->pRRNext )
    {
        //  continue until reach new type
        //  break when past new type

        if ( type != pcurRR->wType )
        {
            if ( type > pcurRR->wType )
            {
                continue;
            }
            break;
        }

        //  found desired type
        //  continue past records higher rank
        //  break when reach inferior data
        //
        //  Note: with DNSSEC, we may have ZONE rank SIG and NXT 
        //  records with GLUE rank records.

        if ( rank != RR_RANK(pcurRR) )
        {
            ASSERT( IS_CACHE_RR(pcurRR) ||
                    type == DNS_TYPE_A ||
                    type == DNS_TYPE_NS ||
                    type == DNS_TYPE_SIG ||
                    type == DNS_TYPE_NXT );
            if ( rank < RR_RANK(pcurRR) )
            {
                continue;
            }
            break;
        }

        //
        //  check for duplicate record
        //      - ignore TTL in check
        //

        if ( RR_Compare( pRR, pcurRR, 0 ) )
        {
            status = DNS_ERROR_RECORD_ALREADY_EXISTS;
            goto Done;
        }

        //  only one SOA

        if ( type == DNS_TYPE_SOA )
        {
            DNS_PRINT((
                "ERROR:  existing SOA on SOA load at node %s\n"
                "    pZone    = %p\n"
                "    pNode    = %p\n"
                "    cur RR   = %p\n"
                "    new RR   = %p\n",
                pNode->szLabel,
                pZone,
                pNode,
                pcurRR,
                pRR ));

            ASSERT( FALSE );
            status = DNS_ERROR_RECORD_ALREADY_EXISTS;
            goto Done;
        }
    }

    //
    //  If this is a DNSSEC record, set the zone's DNSSEC flag.
    //

    if ( IS_DNSSEC_TYPE( type ) && pZone )
    {
        pZone->bContainsDnsSecRecords = TRUE;
    }
    //
    //  put in RR between pprevRR and pcurRR
    //

    pRR->pRRNext = pcurRR;
    pprevRR->pRRNext = pRR;

    RR_ListVerify( pNode );

    UNLOCK_WRITE_RR_LIST( pNode );
    return ERROR_SUCCESS;

Done:

    DNS_DEBUG( LOOKUP, (
        "RR_AddToNode() no add.\n"
        "    status   = %d (%p)\n"
        "    pZone    = %p\n"
        "    pNode    = %p\n"
        "    pRR      = %p (type %d)\n",
        status, status,
        pZone,
        pNode,
        pRR, pRR->wType ));

    UNLOCK_WRITE_RR_LIST( pNode );
    return status;
}



DNS_STATUS
RR_UpdateAdd(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR,
    IN OUT  PUPDATE         pUpdate,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Add an update resource record to node in database.

Arguments:

    pNode -- ptr to node to add resource record to

    pRR -- resource record to add

    pUpdate -- update for add;

    dwFlag -- type of update, from packet, admin, DS

Return Value:

    ERROR_SUCCESS -- if successful
    DNS_ERROR_RECORD_ALREADY_EXISTS -- if new record is duplicate
    DNS_ERROR_RCODE_REFUSED -- if dynamic update not allowed for this record
    ErrorCode for invalid update
        - CNAME error
        - SOA, NS, WINS outside zone root etc.

--*/
{
    PDB_RECORD  pcurRR;
    PDB_RECORD  pprevRR;
    WORD        type;
    UCHAR       rank;
    DNS_STATUS  status;

    ASSERT( pZone && pNode && pRR && pUpdate );

    type = pRR->wType;
    rank = RR_RANK(pRR);

    DNS_DEBUG( UPDATE, (
        "RR_UpdateAdd( z=%s, n=%s, pRR=%p )\n",
        pZone ? pZone->pszZoneName : "null",
        pNode->szLabel,
        pRR ));

    LOCK_WRITE_RR_LIST( pNode );

    RR_ListVerify( pNode );

    DB_CLEAR_TYPE_ALL_TTL( pNode );

    //
    //  clear cached data
    //

    deleteCachedRecordsForUpdate( pNode );

    //
    //  check CNAME node special case
    //

    if ( IS_CNAME_NODE( pNode ) || type == DNS_TYPE_CNAME )
    {
        status = checkCnameConditions(
                    pNode,
                    pRR,
                    type );
        if ( status != ERROR_SUCCESS )
        {
            if ( dwFlag & DNSUPDATE_PACKET )
            {
                if ( type == DNS_TYPE_CNAME &&
                    SrvCfg_fSilentlyIgnoreCNameUpdateConflict )
                {
                    DNS_DEBUG( UPDATE, (
                        "Silently ignoring CNAME update conflict for node %s\n"
                        "    in zone %s\n",
                        pNode->szLabel,
                        pZone->pszZoneName ));
                    status = ERROR_SUCCESS;;
                }
                else
                {
                    DNS_DEBUG( UPDATE, (
                        "Update CNAME conflict at node %s -- returning YXRRSET.\n"
                        "    Either update type %d is CNAME or node is CNAME\n"
                        "    and are updating with non-CNAME compatible type.\n",
                        pNode->szLabel,
                        type ));
                    ASSERT( DNS_ERROR_CNAME_COLLISION || DNS_ERROR_NODE_IS_CNAME );
                    status = DNS_ERROR_RCODE_YXRRSET;
                }
            }
            goto NoAdd;
        }
    }

    //
    //  enforce RR node restrictions
    //      SOA, WINS, WINSR only at authoritative zone roots
    //      NS at zone root or delegation
    //

    if ( type != DNS_TYPE_A )
    {
        //
        //  NS records only at zone root
        //
        //  adding NS record, outside root => adding delegation
        //      - clean out zone ptr
        //      - set ZONE_ROOT flag
        //
        //  new delegations can come from
        //      - admin
        //      - IXFR
        //      - by policy, dynamic update delegation
        //
        //  DEVNOTE: perhaps need server flag to allow
        //              perhaps check should be on non-secure update zone
        //
        //  DEVNOTE: set\or check RR_RANK to NS_GLUE if doing delegation NS
        //              this may be handled properly by the node write routines
        //
        //      may have to do general case on glue here to handle XFR
        //      (or later UPDATE) where delegation change comes in rendering
        //      previous records haven't
        //      this becomes less important with separate zones where no confusion
        //      about
        //

        if ( type == DNS_TYPE_NS )
        {
            if ( !IS_AUTH_ZONE_ROOT( pNode ) )
            {
                //  no delegation can be added UNDER a delegation

                if ( !IS_ZONE_ROOT( pNode ) && !IS_AUTH_NODE( pNode ) )
                {
                    DNS_DEBUG( UPDATE, (
                        "WARNING:  attempt to add NS at node %p inside delegation or\n"
                        "    outside zone.\n",
                        pNode ));
                    status = DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION;
                    goto NoAdd;
                }

                //  by policy may exclude dynamic update of delegation

                if ( (dwFlag & DNSUPDATE_PACKET) &&
                     ( SrvCfg_fNoUpdateDelegations ||
                       (SrvCfg_dwUpdateOptions & UPDATE_NO_DELEGATION_NS) ) )
                {
                    status = DNS_ERROR_RCODE_REFUSED;
                    goto NoAdd;
                }

                //  create delegation

                SET_ZONE_ROOT( pNode );
                SET_DELEGATION_NODE( pNode );
            }

            //  root NS
            //      - by policy may exclude root-NS updates

            else if ( dwFlag & DNSUPDATE_PACKET &&
                      (SrvCfg_dwUpdateOptions & UPDATE_NO_ROOT_NS) )
            {
                status = DNS_ERROR_RCODE_REFUSED;
                goto NoAdd;
            }
        }

        //  SOA only at zone root
        //      - by policy may exclude SOA dynamic update

        else if ( type == DNS_TYPE_SOA )
        {
            if ( !IS_AUTH_ZONE_ROOT( pNode ) )
            {
                status = DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT;
                goto NoAdd;
            }
            if ( dwFlag & DNSUPDATE_PACKET &&
                 (SrvCfg_dwUpdateOptions & UPDATE_NO_SOA) )
            {
                status = DNS_ERROR_RCODE_REFUSED;
                goto NoAdd;
            }
        }

        //
        //  WINS record
        //      - catch bogus placement
        //      - catch when LOCAL WINS does not get added to list (for secondary)
        //      pRR is saved in zone but removed from update list
        //

        else if ( IS_WINS_TYPE(type) )
        {
            status = Wins_RecordCheck(
                        pZone,
                        pNode,
                        pRR
                        );
            if ( status != ERROR_SUCCESS )
            {
                if ( status == DNS_INFO_ADDED_LOCAL_WINS )
                {
                    pRR = NULL;
                    status = ERROR_SUCCESS;
                }
                goto NoAdd;
            }
            pZone->fRootDirty = TRUE;
        }

    }   // non-A types

    //
    //  mark glue records as glue
    //  mark root hints as root hints
    //
    //  DEVNOTE: probably shouldn't even bother with rank inside zone
    //      when compare to cache data just use zone positional info
    //

    if ( pZone )
    {
        if ( pRR->dwTtlSeconds == pZone->dwDefaultTtl )
        {
            SET_ZONE_TTL_RR(pRR);
        }
        rank = RANK_ZONE;

        //  sub-zone \ delegation updates
        //      - mark RR with appropriate glue rank
        //      - allow NS only at delegation
        //      - validity check other records
        //      (A, AAAA, SIG, KEY, etc. allowed)

        if ( !IS_AUTH_NODE( pNode ) )
        {
            if ( type == DNS_TYPE_NS )
            {
                rank = RANK_NS_GLUE;
                if ( !IS_ZONE_ROOT( pNode ) )
                {
                    status = DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION;
                    goto NoAdd;
                }
            }
            else
            {
                rank = RANK_GLUE;
                if ( ! IS_UPDATE_IN_SUBZONE_TYPE(type) )
                {
                    status = DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION;
                    goto NoAdd;
                }
            }
        }
    }

    RR_RANK(pRR) = rank;
    ASSERT( rank != 0  &&  !IS_CACHE_RR(pRR) );


    //
    //  traverse list, until find first resource record of higher type
    //

    pcurRR = START_RR_TRAVERSE( pNode );

    while ( pprevRR = pcurRR, pcurRR = pprevRR->pRRNext )
    {
        //  continue until reach new type
        //  break when past new type

        if ( type != pcurRR->wType )
        {
            if ( type > pcurRR->wType )
            {
                continue;
            }
            break;
        }

        //  delete any cached records of desired type
        //      - eliminate WINS \ WINS-R cached records before add update

        if ( IS_CACHE_RR( pcurRR ) )
        {
            pprevRR->pRRNext = pcurRR->pRRNext;

            DNS_DEBUG( UPDATE, (
                "Deleting cached RR at %p in preparation for update.\n",
                pcurRR ));

            RR_Free( pcurRR );
            pcurRR = pprevRR;
            continue;
        }

        //  found desired type
        //  continue past records higher rank
        //  break when reach inferior data
        //      - only A and NS should have cached data of same type updating

        if ( rank != RR_RANK(pcurRR) )
        {
            if ( rank < RR_RANK(pcurRR) )
            {
                ASSERT( type == DNS_TYPE_A || type == DNS_TYPE_NS );
                continue;
            }
            break;
        }

        //
        //  check for duplicates
        //      - do not include TTL in comparison
        //

        if ( RR_Compare( pRR, pcurRR, 0 ) )
        {
            //
            //  record is duplicate
            //
            //  TTL change, do simple overwrite
            //

            if ( pRR->dwTtlSeconds != pcurRR->dwTtlSeconds )
            {
                goto Overwrite;
            }

            //
            //  now duplicate record for all DNS-RFC data
            //      => update will be no-op
            //      => but may still have aging change
            //
            //  pick up aging info from update RR
            //  EXCEPT when have non-aging record and
            //      are not explicitly turning aging ON
            //      via ADMIN update
            //
            //  note, contrary to the belief of some confused developers
            //  and PMs, we do NOT suppress refresh changes here because
            //  we WANT to move the record's time stamps forward if we
            //  end up doing a write for any reason;
            //  if we suppress the new timestamp then we will later have
            //  to do additional writes for the records we suppressed here;
            //  the classic example of this is precon RRs followed by
            //  update;  we WANT to refresh the precon RRs when we execute
            //  the update, otherwise EACH AND EVERY RR in the set would
            //  generate a DS write when it's individual refresh came due
            //
            //  so the general paradigm is always keep track of any touch
            //  to the record;  then we'll specifically check for the need
            //  for DS write on the node's entire RR list, and IF we write
            //  we'll always write the list with the LATEST timestamps
            //

            status = DNS_ERROR_RECORD_ALREADY_EXISTS;

            if ( pcurRR->dwTimeStamp != 0 ||
                ( (dwFlag & DNSUPDATE_ADMIN) && (dwFlag & DNSUPDATE_AGING_ON) ) )
            {
                //  if making an explicit AGING ON\OFF change, then
                //  suppress ALREADY_EXISTS error code for admin updates
                //  as this code is reported back to DNS manager
                //
                //  note, test is just whether aging OFF before or after,
                //  because OFF before AND after, is ruled out by above test

                if ( (dwFlag & DNSUPDATE_ADMIN)
                        &&
                    (pcurRR->dwTimeStamp == 0 || pRR->dwTimeStamp == 0) )
                {
                    status = ERROR_SUCCESS;
                }

                pcurRR->dwTimeStamp = pRR->dwTimeStamp;
            }

            goto NoAdd;
        }

        //
        //  overwrite type?
        //
        //  for some types:  SOA, CNAME, WINS, WINSR
        //  "add" is always a replace, there is no possibility of
        //  having multiple records even if delete operation was
        //  not specified
        //      - cut existing and replace
        //

        switch( type )
        {

        case DNS_TYPE_CNAME:
        case DNS_TYPE_WINS:
        case DNS_TYPE_WINSR:

            //  no-op always overwrite CNAME or WINS

            goto Overwrite;

        case DNS_TYPE_SOA:
        {
            //
            //  for UPDATE protocol must increase serial number over current
            //      - if not ignore SOA
            //  mark root dirty for zone SOA update on completion
            //      - do not install it here as may later have rollback on failure
            //          issues (ex:  scriptable admin with multiple updates)
            //

            if ( dwFlag & DNSUPDATE_PACKET )
            {
                DWORD       diffSerial;

                ASSERT( pZone && pZone->pSoaRR );

                diffSerial = htonl( pRR->Data.SOA.dwSerialNo ) -
                                htonl( pcurRR->Data.SOA.dwSerialNo );

                if ( diffSerial == 0 || diffSerial > (DWORD)MAXLONG )
                {
                    DNS_DEBUG( UPDATE, (
                        "WARNING:  Ignoring SOA update with bad serial.\n" ));
                    status = DNS_ERROR_SOA_DELETE_INVALID;
                    goto NoAdd;
                }
            }
            pZone->fDirty = TRUE;
            pZone->fRootDirty = TRUE;
            goto Overwrite;
        }

        default:

            //  NOT overwrite type -- continue checking with next record

            continue;

        }   // end switch on overwrite types
    }

    //
    //  found correct location
    //  put in RR between pprevRR and pcurRR
    //  increment update record count
    //  reset flags if picked up NS or CNAME record
    //

    pRR->pRRNext = pcurRR;
    pprevRR->pRRNext = pRR;

    pUpdate->pAddRR = pRR;

    //
    //  reset node properties
    //      - flags, authority (if delegation), NS list
    //

    RR_ListResetNodeFlags( pNode );

    RR_ListVerify( pNode );
    UNLOCK_WRITE_RR_LIST( pNode );

    DNS_DEBUG( UPDATE, (
        "RR_UpdateAdd() ADDED UPDATE RR.\n" ));
    return ERROR_SUCCESS;


Overwrite:

    //
    //  overwrite type or TTL change on duplicate data
    //
    //  if aging disabled, packet update should NOT override
    //
    //  DEVNOTE: non-duplicate data (TTL ok) should not preserve zero timestamp
    //

    if ( pcurRR->dwTimeStamp == 0
            &&
        (dwFlag & DNSUPDATE_PACKET) )
    {
        DNS_DEBUG( AGING, (
            "Aging: Applied disabled RR Timestamp field.\n",
            pcurRR ));
        pRR->dwTimeStamp = 0;
    }

    //  replace old with new
    //      - cut existing and replace with new RR
    //      - add delete RR to update
    //      - update has no net record count effect

    pprevRR->pRRNext = pRR;
    pRR->pRRNext = pcurRR->pRRNext;
    pcurRR->pRRNext = NULL;

    pUpdate->pDeleteRR = pcurRR;
    pUpdate->pAddRR = pRR;

    RR_ListVerify( pNode );
    UNLOCK_WRITE_RR_LIST( pNode );

    DNS_DEBUG( UPDATE, (
        "RR_UpdateAdd() REPLACED existing RR %p with UPDATE RR.\n",
        pcurRR ));
    return ERROR_SUCCESS;

NoAdd:

    UNLOCK_WRITE_RR_LIST( pNode );
    DNS_DEBUG( UPDATE, (
        "RR_UpdateAdd() -- IGNORING UPDATE add.\n",
        "    status = %p (%d)\n",
        status, status ));

    //
    //  free record
    //      - NULL out add in passed in update
    //      or
    //      - whack newly created update from list and free
    //

    RR_Free( pRR );
    pUpdate->pAddRR = NULL;

    //  mark update as rejected
    //      - this keeps "empty update" check ASSERT from firing

    pUpdate->wDeleteType = UPDATE_OP_REJECTED;

    //  clear ALREADY_EXISTS error, accept for admin
    //  for everyone else this is not an error

    if ( status == DNS_ERROR_RECORD_ALREADY_EXISTS  &&
         !(dwFlag & DNSUPDATE_ADMIN) )
    {
        status = ERROR_SUCCESS;
    }

    return status;
}



PDB_RECORD
RR_ReplaceSet(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Replace record set.
    For use by UPDATE.

Arguments:

    pZone -- ptr to zone info

    pNode -- ptr to node

    pRR -- replacement record set

    Flag --

Return Value:

    Ptr to replaced record set.

--*/
{
    PDB_RECORD  pcurrent;
    WORD        replaceType;
    WORD        typeCurrent;
    PDB_RECORD  pbeforeDelete;
    PDB_RECORD  pdelete = NULL;
    PDB_RECORD  pdeleteLast = NULL;
    PDB_RECORD  preplaceLast;
    UCHAR       rank;
    DWORD       ttl;

    DNS_DEBUG( UPDATE, (
        "RR_ReplaceSet( %s, pZone=%p, pRR=%p, Flag=%d )\n",
        pNode->szLabel,
        pZone,
        pRR,
        Flag ));

    LOCK_WRITE_RR_LIST( pNode );

    RR_ListVerify( pNode );

    DB_CLEAR_TYPE_ALL_TTL( pNode );

    //
    //  clear cached data
    //

    deleteCachedRecordsForUpdate( pNode );

    //
    //  find end of replace list
    //      - validate common type
    //      - set RR rank
    //      - set zone TTL
    //

    replaceType = pRR->wType;
    ASSERT( !IS_COMPOUND_TYPE_EXCEPT_ANY(replaceType) );

    rank = RANK_ROOT_HINT;
    ttl = 0;
    if ( pZone )
    {
        ttl = pZone->dwDefaultTtl;

        rank = RANK_ZONE;
        if ( !IS_AUTH_NODE( pNode ) )
        {
            rank = RANK_GLUE;
            if ( replaceType == DNS_TYPE_NS )
            {
                rank = RANK_NS_GLUE;
            }
        }
    }

    pcurrent = pRR;
    do
    {
        ASSERT( pcurrent->wType == replaceType );

        RR_RANK( pcurrent ) = rank;
        pcurrent->dwTtlSeconds = ttl;
        SET_ZONE_TTL_RR( pcurrent );

        preplaceLast = pcurrent;
    }
    while( pcurrent = pcurrent->pRRNext );

    //
    //  find records of replacement type
    //      - cut them from list
    //      - patch new ones in
    //

    pcurrent = START_RR_TRAVERSE( pNode );
    pbeforeDelete = pcurrent;

    while ( pcurrent = pcurrent->pRRNext )
    {
        ASSERT( IS_VALID_RECORD(pRR) );

        typeCurrent = pcurrent->wType;

        //  found delete type
        //      - save ptr to first record

        if ( typeCurrent == replaceType )
        {
            if ( !pdelete )
            {
                pdelete = pcurrent;
            }
            pdeleteLast = pcurrent;
            continue;
        }

        //  before matching records -- continue

        if ( typeCurrent < replaceType )
        {
            pbeforeDelete = pcurrent;
            continue;
        }
        break;      //  past matching records -- stop
    }

    //
    //  have isolated type records
    //      pbeforeDelete   -- ptr to record (or node ptr) before type
    //      pdelete         -- first record of replace type
    //      pdeleteLast     -- last record of replace type
    //      pcurrent        -- record after replace set
    //
    //  splice in new RR set
    //  NULL terminate old set (if any)
    //

    pbeforeDelete->pRRNext = pRR;
    preplaceLast->pRRNext = pcurrent;

    if ( pdeleteLast )
    {
        pdeleteLast->pRRNext = NULL;
    }

    //
    //  reset node properties
    //      - flags, authority (if delegation), NS list
    //

    RR_ListResetNodeFlags( pNode );

    RR_ListVerify( pNode );
    UNLOCK_WRITE_RR_LIST( pNode );

    IF_DEBUG( UPDATE )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Node after replace of type = %d.\n",
            replaceType ));
        Dbg_DbaseNode(
            "Node after type delete:\n",
            pNode );
        DnsDebugUnlock();
    }

    return pdelete;
}



#if 0
//  unused


DNS_STATUS
RR_VerifyUpdate(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR,
    IN OUT  PUPDATE         pUpdate
    )
/*++

Routine Description:

    Verify proposed update is valid for this node.

    The idea here is to catch updates that we will NOT be able to do
    to avoid roll back.  Currently doing silent ignore.

Arguments:

    pNode -- ptr to node to add resource record to

    pRR -- resource record to add

    pUpdate -- update for add

Return Value:

    ERROR_SUCCESS -- if successful
    ErrorCode for CNAME error

--*/
{
    PDB_RECORD  pcurRR;
    PDB_RECORD  pprevRR;
    WORD        type;
    DNS_STATUS  status = ERROR_SUCCESS;

    ASSERT( pNode != NULL );
    ASSERT( pRR != NULL );

    type = pRR->wType;

    LOCK_WRITE_RR_LIST( pNode );
    RR_ListVerify( pNode );

    //
    //  clear cached data
    //

    deleteCachedRecordsForUpdate( pNode );

    pprevRR = START_RR_TRAVERSE( pNode );
    pcurRR = NEXT_RR( pprevRR );

    //
    //  CNAME node special case
    //

    if ( IS_CNAME_NODE( pNode ) )
    {
        if ( !IS_ALLOWED_AT_CNAME_NODE_TYPE(type) )
        {
            status = DNS_ERROR_CNAME_COLLISION;
            goto Done;
        }
    }

    //
    //  SOA only at zone root
    //

    if ( type == DNS_TYPE_SOA )
    {
        if ( ! IS_AUTH_ZONE_ROOT( pNode ) )
        {
            status = DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT;
            goto Done;
        }
    }

Done:
    UNLOCK_WRITE_RR_LIST( pNode );
    return ERROR_SUCCESS;
}
#endif



//
//  Miscellaneous RR list related routines.
//

//
//  DEVNOTE: cname loop check needs work -- should be in the context of a zone
//

BOOL
FASTCALL
checkForCnameLoop(
    IN      PDB_NODE        pNodeNew,
    IN      PDB_NODE        pNodeCheck,
    IN      DWORD           cChainLength
    )
/*++

Routine Description:

    Test for new CNAME node being part of CNAME loop.

    This handles multiple CNAMEs at node

Arguments:

    pNodeNew -- original node adding CNAME, hence the node to look for to
        verify a loop

    pNodeCheck -- node in CNAME chain to check this call

    cChainLength -- chain length at this call;  call with 0

Return Value:

    TRUE if CNAME loop.
    FALSE otherwise.

--*/
{
#ifdef NEWDNS
    return FALSE;

#else
    PDB_NODE        pnode;
    PDB_RECORD      prr;
    DWORD           currentTime = 0;
    BOOL            foundCname = FALSE;

    //
    //  loop until find end of CNAME chain
    //      or
    //  detect a loop
    //
    //  note, we only bother to check for our node being in the loop,
    //      any pre-existing loop should have been caught when it
    //      was made;  but provide count to avoid spin
    //

    LOCK_WRITE_RR_LIST(pNodeCheck);

    //
    //  if adding self-referential CNAME RR, catch right away
    //

    if ( pNodeNew == pNodeCheck )
    {
        pnode = pNodeNew;
        goto CnameLoop;
    }

    //
    //  regular node -- no loop
    //

    if ( ! IS_CNAME_NODE(pNodeCheck) )
    {
        UNLOCK_WRITE_RR_LIST(pNodeCheck);
        return FALSE;
    }

    //
    //  check all CNAMEs to see if they point back to start node
    //

    prr = START_RR_TRAVERSE( pNodeCheck );

    while ( prr = NEXT_RR(prr) )
    {
        if ( prr->wType != DNS_TYPE_CNAME )
        {
            if ( !IS_ALLOWED_WITH_CNAME_TYPE(prr->wType) )
            {
                ASSERT( FALSE );
            }
            continue;
        }
        foundCname = TRUE;

        //  if cached node, check timeout
        //      but not for the new node itself

        if ( IS_CACHE_RR(prr) && pNodeCheck != pNodeNew )
        {
            if ( !currentTime )
            {
                currentTime = GetCurrentTimeInSeconds();
            }
            if ( prr->dwTtlSeconds < currentTime )
            {
                RR_ListTimeout(pNodeCheck);
                ASSERT( pNodeCheck->pRRList == NULL );
                break;
            }
        }

        //
        //  RR points at new node -- CNAME loop?
        //

        pnode = Lookup_FindDbaseName( pRR->Data.CNAME.nameTarget );
        if ( pnode == pNodeNew )
        {
            //  peramanent record or cycle within new node
            //      => report CNAME loop error

            if ( pNodeCheck == pNodeNew || !IS_CACHE_RR(prr) )
            {
                goto CnameLoop;
            }

            //  if cached record -- break loop here

            RR_ListDelete( pNodeCheck );
            ASSERT( pNodeCheck->pRRList == NULL );
            break;
        }

        //
        //  recurse to continue loop check with CNAME nodes
        //

        if ( cChainLength >= CNAME_CHAIN_LIMIT )
        {
            goto CnameLoop;
        }
        if ( checkForCnameLoop( pNodeNew, pnode, ++cChainLength ) )
        {
            goto CnameLoop;
        }
    }

    //  drops here if no CNAME loop
    //      - if no CNAME at node, clear flag

    if ( ! foundCname )
    {
        DNS_PRINT((
            "ERROR:  node %s at %p with bogus CNAME flag.\n",
            pNodeCheck->szLabel,
            pNodeCheck ));
        ASSERT( FALSE );
        CLEAR_CNAME_NODE( pNodeCheck );
    }
    UNLOCK_WRITE_RR_LIST(pNodeCheck);
    return FALSE;

CnameLoop:

    //
    //  detected CNAME LOOP
    //
    //  log message, given new node trying to add,
    //  and this link in loop (recursion adds all the
    //  links in the loop)
    //
    {
        PCHAR   pszArgs[3];
        CHAR    szLoadNode [ DNS_MAX_NAME_BUFFER_LENGTH ];
        CHAR    szAliasNode[ DNS_MAX_NAME_BUFFER_LENGTH ];
        CHAR    szCnameNode[ DNS_MAX_NAME_BUFFER_LENGTH ];

        Name_PlaceFullNodeNameInRpcBuffer(
            szLoadNode,
            szLoadNode + sizeof(szLoadNode),
            pNodeNew );

        Name_PlaceFullNodeNameInRpcBuffer(
            szAliasNode,
            szAliasNode + sizeof(szAliasNode),
            pNodeCheck );

        Name_PlaceFullNodeNameInRpcBuffer(
            szCnameNode,
            szCnameNode + sizeof(szCnameNode),
            pnode );

        pszArgs[0] = szLoadNode + 1;
        pszArgs[1] = szAliasNode + 1;
        pszArgs[2] = szCnameNode + 1;

        DNS_LOG_EVENT(
            DNS_EVENT_CNAME_LOOP_LINK,
            3,
            pszArgs,
            EVENTARG_ALL_UTF8,
            0 );

    }
    UNLOCK_WRITE_RR_LIST(pNodeCheck);
    return TRUE;
#endif
}



DNS_STATUS
FASTCALL
cleanRecordListForNewCname(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Delete cached records incompatible with CNAME.

    Assumes:  RR list or node already locked.

Arguments:

    pNode -- ptr to node

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_CNAME_COLLISION.

--*/
{
    PDB_RECORD  pcurRR;
    PDB_RECORD  pprevRR;
    WORD        typeCurrent;

    ASSERT( IS_LOCKED_NODE( pNode ) );

    //
    //  Do not allow CNAMEs to be added at a zone root.
    //
        
    if ( IS_ZONE_ROOT( pNode ) )
    {
        return DNS_ERROR_CNAME_COLLISION;
    }

    //
    //  Examine the record types at the node to determine if it is allowable
    //  to add a CNAME here.
    //
    
    pprevRR = START_RR_TRAVERSE( pNode );

    while ( pcurRR = pprevRR->pRRNext )
    {
        typeCurrent = pcurRR->wType;

        if ( IS_ALLOWED_WITH_CNAME_TYPE(typeCurrent) )
        {
            pprevRR = pcurRR;
            continue;
        }

        //  if incompatible, cached RR -- cut out and delete

        if ( IS_CACHE_RR( pcurRR ) )
        {
            DNS_DEBUG( READ, (
                "Deleting cached RR %p type %d at node %p\n"
                "    to add new CNAME RR\n",
                pcurRR,
                typeCurrent,
                pNode ));
            pprevRR->pRRNext = pcurRR->pRRNext;
            RR_Free( pcurRR );
            DB_CLEAR_TYPE_ALL_TTL( pNode );
            continue;
        }

        //  if incompatible, non-cached type -- error

        Dbg_DbaseNode(
            "ERROR:  Attempt to add CNAME to node with incompatible record.\n",
            pNode );
        return DNS_ERROR_CNAME_COLLISION;
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
FASTCALL
checkCnameConditions(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR,
    IN      WORD            wType
    )
/*++

Routine Description:

    Check CNAME conditions on adding node to database.

    Conditions:
        - only CNAME data at a node
        - no CNAME loops

    Assumes:  RR list or node already locked.

Arguments:

    pNode -- ptr to node to add resource record to

    pRR -- resource record to add

    wType -- record type

Return Value:

    ERROR_SUCCESS -- if successful
    DNS_ERROR_NODE_IS_CNAME -- if adding non-CNAME data a CNAME node
    DNS_ERROR_CNAME_COLLISION -- if adding CNAME at non-CNAME node
    DNS_ERROR_CNAME_LOOP -- if causing CNAME loop

--*/
{
    ASSERT( pNode && pRR );

    ASSERT( IS_LOCKED_NODE( pNode ) );

    //
    //  CNAME node -- no non-CNAME data
    //      - allow some types with CNAME
    //      - protect against condition where left stray flag set
    //          (should never happen)
    //      - dump cached data
    //

    if ( IS_CNAME_NODE( pNode ) && wType != DNS_TYPE_CNAME )
    {
        if ( IS_ALLOWED_WITH_CNAME_TYPE(wType) )
        {
            DNS_DEBUG( READ, (
                "Writing new type %d to existing CNAME node %p\n",
                wType,
                pNode ));
            return ERROR_SUCCESS;
        }
        if ( !pNode->pRRList )
        {
            Dbg_DbaseNode(
                "ERROR:  Node with CNAME flag and no data.\n",
                pNode );
            ASSERT( FALSE );
            CLEAR_CNAME_NODE( pNode );
            return ERROR_SUCCESS;
        }
        if ( IS_CACHE_TREE_NODE( pNode ) )
        {
            Dbg_DbaseNode(
                "WARNING:  clearing existing cached CNAME node to create non-CNAME ",
                pNode );
            RR_ListDelete( pNode );
            CLEAR_CNAME_NODE( pNode );
            return ERROR_SUCCESS;
        }

        IF_DEBUG( READ )
        {
            Dbg_DbaseNode(
                "ERROR:  Attempt to add record to CNAME node.\n",
                pNode );
        }
        return( DNS_ERROR_NODE_IS_CNAME );
    }

    //
    //  add CNAME type
    //  if non-CNAME node becoming CNAME must not have incompatible RRs
    //  delete any cached incompatible RRs, if incompatible static RRs
    //  (zone data or glue) then error
    //

    ASSERT( wType == DNS_TYPE_CNAME );

    if ( !IS_CNAME_NODE( pNode ) )
    {
        if ( pNode->pRRList )
        {
            DNS_STATUS  status = cleanRecordListForNewCname( pNode );
            if ( status != ERROR_SUCCESS )
            {
                return status;
            }
        }
    }

    //
    //  CNAME loop check
    //

#ifndef NEWDNS
    if ( checkForCnameLoop(
            pNode,
            Lookup_FindDbaseName( pRR->Data.CNAME.nameTarget ),
            0 ) )
    {
        Dbg_DbaseNode(
            "ERROR:  Detected CNAME loop adding record at node ",
            pNode );
        if ( !pNode->pRRList )
        {
            CLEAR_CNAME_NODE( pNode );
        }
        return DNS_ERROR_CNAME_LOOP;
    }
#endif

    return ERROR_SUCCESS;
}



VOID
deleteCachedRecordsForUpdate(
    IN OUT  PDB_NODE    pNode
    )
/*++

Routine Description:

    Delete's cached records prior to update operation.

    This is for use by UPDATE operations, hence assumes authoritative
    node and looking only for WINS \ WINSR data.
    Note:  no locking as assuming database locked for UPDATE.

Arguments:

    pNode -- ptr to node

Return Value:

    None

--*/
{
    PDB_RECORD  prr;
    PDB_RECORD  pback;
    PZONE_INFO  pzone = pNode->pZone;

    ASSERT( IS_LOCKED_NODE( pNode ) );

    DB_CLEAR_TYPE_ALL_TTL( pNode );

    //
    //  if name error on node, eliminate it
    //

    if ( IS_NOEXIST_NODE( pNode ) )
    {
        RR_RemoveCachedNameError( pNode );
        return;
    }

    //
    //  delete any cached lookups
    //      - only need to check if in WINS or WINSR zone
    //
    //  DEVNOTE: this changes if allow delegation updates
    //

    if ( ! pzone ||
        ! pzone->pWinsRR ||
        ( !pzone->fReverse && pNode->pParent != pzone->pZoneRoot ) )
    {
        return;
    }

    //  purge RR list of any cached records

    prr = START_RR_TRAVERSE( pNode );

    while ( pback = prr, prr = prr->pRRNext )
    {
        if ( IS_CACHE_RR(prr) )
        {
            pback->pRRNext = prr->pRRNext;
            RR_Free( prr );
            prr = pback;
        }
    }
}


#if 0
//
//  Non-recursive version
//
BOOL
FASTCALL
checkForCnameLoop(
    IN      PDB_NODE        pNodeNew,
    IN      PDB_NODE        pNodeCname
    )
/*++

Routine Description:

    Test for new CNAME node being part of CNAME loop.

    MUST hold database lock while check loop.
    This handles multiple CNAMEs at node

Arguments:

    pNodeNew -- original node adding CNAME, hence the node to look for to
        verify a loop

    pNodeCname -- CNAME (targer to CNAME record)

Return Value:

    TRUE if CNAME loop.
    FALSE otherwise.

--*/
{
    PDB_NODE        pnodeNextCname;
    PDB_RECORD      prr;
    DWORD           countCnames;
    BOOL            foundCname;

    //
    //  loop until find end of CNAME chain
    //      or
    //  detect a loop
    //
    //  note, we only bother to check for our node being in the loop,
    //      any pre-existing loop should have been caught when it
    //      was made;  but provide count to avoid spin
    //

    countCnames = 0;

    while( countCnames < CNAME_CHAIN_LIMIT )
    {
        LOCK_WRITE_RR_LIST(pNodeCname);

        //  regular node -- no loop

        if ( ! IS_CNAME_NODE(pNodeCname) )
        {
            UNLOCK_WRITE_RR_LIST(pNodeCname);
            return FALSE;
        }

        //  look through records for CNAME

        pnodeNextCname = NULL;
        foundCname = FALSE;

        prr = START_RR_TRAVERSE( pNodeCname );

        while ( prr = NEXT_RR(prr) )
        {
            if ( prr->wType != DNS_TYPE_CNAME )
            {
                if ( !IS_ALLOWED_WITH_CNAME_TYPE(prr->wType) )
                {
                    ASSERT( FALSE );
                }
                continue;
            }
            foundCname = TRUE;

            //  if cached node, check timeout
            //      but not for the new node itself

            if ( IS_CACHE_RR(prr) && pNodeCname != pNodeNew )
            {
                if ( prr->dwTtlSeconds < DNS_TIME() )
                {
                    RR_ListTimeout(pNodeCname);
                    ASSERT( pNodeCname->pRRList == NULL );
                    break;
                }
            }

            //
            //  RR points at new node -- CNAME loop
            //      - if cyclic within new record => report loop
            //      - permanent record => report loop
            //      - if cached record => delete record to break loop
            //

            pnodeNextCname = Lookup_FindDbaseName( prr->Data.CNAME.nameTarget );
            if ( pnodeNextCname == pNodeNew )
            {
                if ( pNodeCname == pNodeNew || !IS_CACHE_RR(prr) || IS_ZONE_TREE_NODE(pNodeCname) )
                {
                    goto CnameLoop;
                }
                RR_ListDelete( pNodeCname );
                ASSERT( pNodeCname->pRRList == NULL );
                pnodeNextCname = NULL;
                break;
            }
        }

        //  drops here if CNAME at node did NOT from loop
        //      - if no CNAME at node, clear bogus flag

        if ( ! foundCname )
        {
            DNS_PRINT((
                "ERROR:  node %s at %p with bogus CNAME flag.\n",
                pNodeCname->szLabel,
                pNodeCname ));
            ASSERT( FALSE );
            CLEAR_CNAME_NODE( pNodeCname );
        }
        UNLOCK_WRITE_RR_LIST(pNodeCname);

        if ( !pnodeNextCname )
        {
            return FALSE;
        }

        pNodeCname = pnodeNextCname;
        countCnames++;
    }

    //  drops here if exceeds CNAME chain limit

CnameLoop:

    //
    //  detected CNAME LOOP
    //
    //  log message, given new node trying to add,
    //  and this link in loop (recursion adds all the
    //  links in the loop)
    //
    {
        PCHAR   pszArgs[3];
        CHAR    szLoadNode [ DNS_MAX_NAME_BUFFER_LENGTH ];
        CHAR    szAliasNode[ DNS_MAX_NAME_BUFFER_LENGTH ];
        CHAR    szCnameNode[ DNS_MAX_NAME_BUFFER_LENGTH ];

        Name_PlaceFullNodeNameInRpcBuffer(
            szLoadNode,
            szLoadNode + sizeof(szLoadNode),
            pNodeNew );

        Name_PlaceFullNodeNameInRpcBuffer(
            szAliasNode,
            szAliasNode + sizeof(szAliasNode),
            pNodeCname );

        Name_PlaceFullNodeNameInRpcBuffer(
            szCnameNode,
            szCnameNode + sizeof(szCnameNode),
            pnode );

        pszArgs[0] = szLoadNode + 1;
        pszArgs[1] = szAliasNode + 1;
        pszArgs[2] = szCnameNode + 1;

        DNS_LOG_EVENT(
            DNS_EVENT_CNAME_LOOP_LINK,
            3,
            pszArgs,
            EVENTARG_ALL_UTF8,
            0 );

    }
    UNLOCK_WRITE_RR_LIST(pNodeCname);
    return TRUE;
}

#endif


BOOL
RR_ListExtractInfo(
    IN      PDB_RECORD      pNewList,
    IN      BOOL            fZoneRoot,
    OUT     PBOOL           pfNs,
    OUT     PBOOL           pfCname,
    OUT     PBOOL           pfSoa
    )
/*++

Routine Description:

    Investigate new RR list for various conditions.

Arguments:

    pNewList -- new RR list

    fZoneRoot -- root of zone being updated;  for this case avoid delete
        of SOA and NS records;  do not generally do this as want to allow
        delete for delegations

    pfCname -- ptr to recv

Return Value:

    TRUE if successfull.
    FALSE on error.

--*/
{
    PDB_RECORD  prr;
    WORD        typeCurrent;

    *pfSoa = FALSE;
    *pfNs = FALSE;
    *pfCname = FALSE;

    //
    //  set bit for each record in mask
    //

    prr = pNewList;

    while ( prr )
    {
        ASSERT( IS_DNS_HEAP_DWORD(prr) );

        typeCurrent = prr->wType;

#if 0
        //  bitmask setting
        //  other possiblity is UCHAR array of types

        //  screen dual SOA

        if ( typeCurrent == DNS_TYPE_SOA &&
                SOA_BIT_SET(mask) )
        {
            return( -1 );
        }

        //  DEVNOTE:  screen dual CNAME?

        if ( typeCurrent < 32 )
        {
            mask |= (1 << (typeCurrent-1) );
        }
#endif

        //  NS

        if ( typeCurrent == DNS_TYPE_NS )
        {
            *pfNs = TRUE;
        }

        //  CNAME
        //      -- we won't screen dual

        if ( typeCurrent == DNS_TYPE_CNAME )
        {
#if 0
            if ( *pfCname )
            {
                return FALSE;
            }
#endif
            *pfCname = TRUE;
        }

        //  SOA -- screen dual

        if ( typeCurrent == DNS_TYPE_SOA )
        {
            if ( *pfSoa )
            {
                return FALSE;
            }
            *pfSoa = TRUE;
        }

        prr = NEXT_RR(prr);
    }

    return TRUE;
}



DNS_STATUS
RR_ListReplace(
    IN OUT  PUPDATE         pUpdate,
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pNewList,
    OUT     PDB_RECORD *    ppDelete
    )
/*++

Routine Description:

    Replace record list.

Arguments:

    pUpdate -- update being executed

    pNode -- ptr to node

    pNewList -- new RR list

    ppDelete -- addr to recv ptr to deleted list

Return Value:

    List of records deleted.
    NULL if no records deleted.

--*/
{
    PDB_RECORD  pdelete = NULL;
    BOOL        bNs = FALSE;
    BOOL        bCname = FALSE;
    BOOL        bSoa = FALSE;
    BOOL        bzoneRoot = FALSE;
    PDB_RECORD  pcurrent;
    WORD        typeCurrent;
    PZONE_INFO  pZone;

    DNS_DEBUG( UPDATE, (
        "Enter RR_ListReplace()\n"
        "    pnode = %p (%s)\n",
        pNode,
        pNode->szLabel ));

    pZone = pNode->pZone;

    DB_CLEAR_TYPE_ALL_TTL( pNode );

    //
    //  DEVNOTE: generally RR replace needs to be smarter
    //      - replace ANYTHING
    //      - reset
    //      - if busted because of zone fix with old records
    //          (retrieve SOA if missing, retrieve first\last NS if missing)


    //  authoritative zone root?

    bzoneRoot = IS_AUTH_ZONE_ROOT( pNode );

    //
    //  if replace RR set, get its info
    //

    if ( pNewList )
    {
        if ( ! RR_ListExtractInfo(
                    pNewList,
                    bzoneRoot,
                    & bNs,
                    & bCname,
                    & bSoa ) )
        {
            goto BadData;
        }
        if ( bSoa && !bzoneRoot )
        {
            goto BadData;
        }
    }

    LOCK_WRITE_RR_LIST( pNode );
    RR_ListVerify( pNode );

    //
    //  clear cached data
    //

    deleteCachedRecordsForUpdate( pNode );

    //
    //  if not zone root, just hack out and replace
    //  or if replacement has valid SOA and NS
    //      => hack out and replace, then can still
    //
    //  Note: with DCR 37323 (conditional disable of auto creation of
    //  local NS records) it is possible to get into a situation
    //  where the zone has no NS RRs. This is currently only possible
    //  for DS integrated zones. Example: the admin sets the set of
    //  servers allowed to create local NS records to contain only
    //  IP addresses that aren't DNS servers with a DS integrated
    //  copy of this zone. In that case, the zone would have no NS
    //  records on any server.
    //

    if ( !bzoneRoot ||
         ( pNewList && bSoa &&
            ( bNs || IS_ZONE_DSINTEGRATED( pZone ) ) ) ||
         ( bzoneRoot && !pZone ) )
    {
        pdelete = pNode->pRRList;
        pNode->pRRList = pNewList;
    }

    //
    //  delete all non-SOA, non-NS records
    //

    else
    {
        ASSERT( FALSE );
        UNLOCK_WRITE_RR_LIST( pNode );
        goto BadData;

#if 0
        //  DEVNOTE: interesting robustness fix
        //      - merge in missing SOA, NS

        //  DEVNOTE: generic list operators not in context of node
        //      - remove type
        //      - remove types?  (use mask technology???)
        //      - stick record in correct place
        //      - replace records of type (for dynamic update NS)

        PDB_RECORD      psaveLast;

        psaveLast = START_RR_TRAVERSE( pNode );
        pcurrent = psaveLast;

        while ( pcurrent = pcurrent->pRRNext )
        {
            ASSERT( IS_DNS_HEAP_DWORD(pcurrent) );

            typeCurrent = pcurrent->wType;

            if ( typeCurrent == DNS_TYPE_SOA
                || typeCurrent == DNS_TYPE_NS )
            {
                psaveLast->pRRNext = pcurrent;
                psaveLast = pcurrent;
                continue;
            }

            if ( !pdelete )
            {
                pdelete = pcurrent;
            }
            else
            {
                pdeleteLast->pRRNext = pcurrent;
            }
            pdeleteLast = pcurrent;
        }

        //  make sure delete list and saved list NULL terminated

        if ( pdelete )
        {
            pdeleteLast->pRRNext = NULL;
            psaveLast->pRRNext = NULL;
        }

        //  add new records into list
#endif
    }

    //  reset node's flags

    RR_ListResetNodeFlags( pNode );

    UNLOCK_WRITE_RR_LIST( pNode );

    //  return list cut from node

    *ppDelete = pdelete;

    DNS_DEBUG( UPDATE, (
        "Leaving RR_ListReplace()\n"
        "    pnode = %p (%s)\n"
        "    status = %p\n",
        pNode,
        pNode->szLabel,
        ERROR_SUCCESS ));

    return ERROR_SUCCESS;


BadData:

    //
    //  if "hard" update (DS poll or IXFR)
    //  then we need to do our best to make this work
    //

    DNS_DEBUG( ANY, (
        "ERROR:  bogus replace update!\n"
        "    pnode        = %p (%s)\n"
        "    temp node    = %d\n",
        pNode,
        pNode->szLabel,
        IS_TNODE( pNode ) ));

    if ( IS_TNODE( pNode ) )
    {
        return ERROR_INVALID_DATA;
    }

    DNS_DEBUG( ANY, (
        "ERROR:  bogus replace update on real node!\n"
        "    pnode    = %p (%s)\n"
        "    bNs      = %d\n"
        "    bSoa     = %d\n"
        "    bCname   = %d\n"
        "    zoneRoot = %d\n",
        pNode,
        pNode->szLabel,
        bNs,
        bSoa,
        bCname,
        bzoneRoot ));
    ASSERT( FALSE );

    //
    //  DEVNOTE: should fix up
    //
    //  temp hack, just leave old list and dump new
    //
    //  make update a no-op so it will be eliminated from
    //      calling list
    //

    if ( pUpdate )
    {
        RR_ListFree( pNewList );
        pUpdate->pAddRR = NULL;
        pUpdate->pDeleteRR = NULL;
    }
    *ppDelete = NULL;

    return ERROR_INVALID_DATA;
}



PDB_RECORD
RR_ListInsertInOrder(
    IN OUT  PDB_RECORD      pFirstRR,
    IN      PDB_RECORD      pNewRR
    )
/*++

Routine Description:

    Insert record in record list -- in type order.

Arguments:

    pFirstRR -- ptr to head of list to insert into

    pNewRR -- ptr to RR to insert in list

Return Value:

    New head of list -- either pFirstRR, or pNewRR if lowest type record.

--*/
{
    PDB_RECORD  prr;
    PDB_RECORD  prev;
    WORD        type;

    type = pNewRR->wType;

    prr = pFirstRR;
    prev = NULL;

    while ( prr )
    {
        if ( prr->wType > type )
        {
            break;
        }
        prev = prr;
        prr = NEXT_RR(prr);
    }

    //  found location
    //      prr -- record to immediately follow pNewRR (maybe NULL)
    //      prev -- record before pNewRR;  if NULL then pNewRR should
    //          be new front of list

    NEXT_RR( pNewRR ) = prr;

    if ( prev )
    {
        NEXT_RR(prev) = pNewRR;
        return pFirstRR;
    }

    return pNewRR;
}



PDB_RECORD
RR_ListForNodeCopy(
    IN      PDB_NODE        pNode,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Copy record list of node.

Arguments:

    pNode - ptr to node to find record at

    Flag  - flags on copy
                RRCOPY_EXCLUDE_CACHE_DATA   - exclude cached data

Return Value:

    Ptr to RR if found.
    NULL if no more RR of desired type.

--*/
{
    PDB_RECORD  prr;

    LOCK_WRITE_RR_LIST( pNode );

    //
    //  cached name error node
    //

    if ( IS_NOEXIST_NODE( pNode ) )
    {
        prr = NULL;
    }
    else
    {
        prr = RR_ListCopy( pNode->pRRList, Flag );
    }

    UNLOCK_WRITE_RR_LIST( pNode );
    return prr;
}



PDB_RECORD
RR_ListCopy(
    IN      PDB_RECORD      pRR,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Copy record list.

Arguments:

    pRR     - start of record list to copy

    Flag    - flags on copy
        RRCOPY_EXCLUDE_CACHE_DATA   - exclude cached data

Return Value:

    Ptr to RR list copy.

--*/
{
    PDB_RECORD  pnew;
    DNS_LIST    newRecordList;

    DNS_LIST_INIT( &newRecordList );

    //
    //  traverse list, copying each record
    //      - exclude cache records (if desired)
    //

    while ( pRR )
    {
        if ( (Flag & RRCOPY_EXCLUDE_CACHED_DATA) && IS_CACHE_RR(pRR) )
        {
            pRR = NEXT_RR(pRR);
            continue;
        }

        pnew = RR_Copy( pRR, 0 );
        if ( !pnew )
        {
            ASSERT( FALSE );
            pRR = NEXT_RR(pRR);
            continue;
        }
        ASSERT( pnew->pRRNext == NULL );

        DNS_LIST_ADD( &newRecordList, pnew );
        pRR = NEXT_RR(pRR);
    }

    return ( PDB_RECORD ) newRecordList.pFirst;
}



//
//  Record \ Record Set \ Record List comparisons
//

BOOL
FASTCALL
RR_Compare(
    IN      PDB_RECORD      pRR1,
    IN      PDB_RECORD      pRR2,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Compare two RRs

Arguments:

    pRR1    -- first RR to compare

    pRR2    -- second RR to compare

    dwFlags -- comparison flags

Return Value:

    TRUE if match
    FALSE if no match

--*/
{
    WORD    type;

    IF_DEBUG( UPDATE2 )
    {
        char        sz[ 100 ];
        
        sprintf( sz, "RR_Compare1 %p flags %04X", pRR1, dwFlags );
        Dbg_DbaseRecord( sz, pRR1 );
        sprintf( sz, "RR_Compare2 %p flags %04X", pRR2, dwFlags );
        Dbg_DbaseRecord( sz, pRR2 );
    }
    
    //
    //  check for duplicate record
    //      - same record type
    //      - same data length
    //      - byte compare of data
    //  if fCheckTtl
    //      - compare ttl
    //  if fCheckTimestamp
    //      - compare Timestamp
    //
    //  for perf, we do check on first DWORD of data first, this
    //  fails quickly for almost all non-duplicates
    //
    //  note the reason for the ordering is that when we turn on case
    //  preservation in RR name data, we'll have a situation where
    //  memcmp and first DWORD compare can fail ... yet, the 95% A record
    //  case can still be dispatched without calling memcmp()
    //

    if ( !pRR1 || !pRR2 ||
         ( type = pRR1->wType ) != pRR2->wType ||
         pRR1->wDataLength != pRR2->wDataLength )
    {
        DNS_DEBUG( UPDATE2, ( "RR_Compare: basic mismatch\n" ));
        return FALSE;
    }

    //
    //  optimize type A
    //

    if ( type == DNS_TYPE_A &&
         pRR1->Data.A.ipAddress != pRR2->Data.A.ipAddress )
    {
        DNS_DEBUG( UPDATE2, ( "RR_Compare: type A mismatch\n" ));
        return FALSE;
    }

    //
    //  special checks
    //

    if ( ( dwFlags & DNS_RRCOMP_CHECK_TTL ) && 
         pRR1->dwTtlSeconds != pRR2->dwTtlSeconds )
    {
        DNS_DEBUG( UPDATE2, ( "RR_Compare: TTL mismatch\n" ));
        return FALSE;
    }
    if ( ( dwFlags & DNS_RRCOMP_CHECK_TIMESTAMP ) &&
         pRR1->dwTimeStamp != pRR2->dwTimeStamp )
    {
        DNS_DEBUG( UPDATE2, ( "RR_Compare: timestamp mismatch\n" ));
        return FALSE;
    }

    //
    //  optimize type A again -- we're done
    //      no need for memory compare
    //

    if ( type == DNS_TYPE_A )
    {
        DNS_DEBUG( UPDATE2, ( "RR_Compare: type A match\n" ));
        return TRUE;
    }

    //
    //  Special SOA compare: do not compare serial number or primary name
    //  server. We exclude these two fields because the in-memory data will
    //  usually not match the DS data. The serial number on the SOA in the DS
    //  will rarely match the current zone serial number, and unless this is
    //  the DNS server that last wrote the SOA to the DS the master server 
    //  in memory will not match the DS data either.
    //
    
    if ( type == DNS_TYPE_SOA && ( dwFlags & DNS_RRCOMP_IGNORE_SOA_SERIAL ) )
    {
        //
        //  Compare fixed SOA fields excluding serial number.
        //
        
        if ( RtlEqualMemory(
                ( PBYTE ) &pRR1->Data + sizeof( DWORD ),
                ( PBYTE ) &pRR2->Data + sizeof( DWORD ),
                SIZEOF_SOA_FIXED_DATA - sizeof( DWORD ) ) )
        {
            PDB_NAME    pnameRp1, pnameRpEnd1;
            PDB_NAME    pnameRp2, pnameRpEnd2;
            
            DNS_DEBUG( ANY, ( "RR_Compare: type SOA no-serial fixed fields match\n" ));
            
            //
            //  Compare responsible person fields.
            //
            
            pnameRp1 = Name_SkipDbaseName( &pRR1->Data.SOA.namePrimaryServer );
            pnameRp2 = Name_SkipDbaseName( &pRR2->Data.SOA.namePrimaryServer );
            if ( pnameRp1 && pnameRp2 )
            {
                pnameRpEnd1 = Name_SkipDbaseName( pnameRp1 );
                pnameRpEnd2 = Name_SkipDbaseName( pnameRp2 );
                if ( pnameRpEnd1 && pnameRpEnd2 )
                {
                    DWORD       nameLength1, nameLength2;

                    nameLength1 = ( DWORD ) ( DWORD_PTR )
                                  ( ( PBYTE ) pnameRpEnd1 - ( PBYTE ) pnameRp1 );
                    nameLength2 = ( DWORD ) ( DWORD_PTR )
                                  ( ( PBYTE ) pnameRpEnd2 - ( PBYTE ) pnameRp2 );
                    if ( nameLength1 == nameLength2 &&
                         RtlEqualMemory( pnameRp1, pnameRp2, nameLength1 ) )
                    {
                        return TRUE;
                    }
                }
            }
        }
        DNS_DEBUG( UPDATE2, ( "RR_Compare: type SOA with ignore serial did not match\n" ));
    }
    
    //
    //  full data compare
    //
    //  DEVNOTE: case sensitivity will require additional comparison routines
    //      here for types with names in RR data
    //

    else if ( RtlEqualMemory(
                    &pRR1->Data,
                    &pRR2->Data,
                    pRR1->wDataLength ) )
    {
        DNS_DEBUG( UPDATE2, ( "RR_Compare: full data match\n" ));
        return TRUE;
    }

    DNS_DEBUG( UPDATE2, ( "RR_Compare: basic mismatch\n" ));
    return FALSE;
}



DWORD
RR_ListCompare(
    IN      PDB_RECORD      pNodeRRList,
    IN      PDB_RECORD      pCheckRRList,
    IN      DWORD           dwFlags,
    IN      DWORD           dwRefreshTime           OPTIONAL
    )
/*++

Routine Description:

    Compare two RR lists.

Arguments:

    pNodeRRList -- RR list

    pCheckRRList -- another RR List

    dwFlags -- comparison flags

    dwRefreshTime -- refresh time for zone, OPTIONAL

        If given then node's records (pNodeRRList) checked if refresh required.
        Note that this option makes pNodeRRList and pCheckRRList non-symmetric.
        It's purpose is to determine when aging refresh requires a DS write.

        Refresh is required when
            A) one of pNodeRRList's records has aging on and requires a refresh
            B) aging ON on pNodeRRList record, but OFF on check
            C) aging OFF on pNodeRRList record, but ON on check

        Note, the three cases are broken out purely for statistics tracking
        when actually doing DS write.  (Breaking them out is cheap.)

Return Value:

    RRLIST_MATCH            -- matches completely
    RRLIST_AGING_REFRESH    -- matches, but aging requires refresh
    RRLIST_AGING_OFF        -- matches, but aging turning off on a record
    RRLIST_AGING_ON         -- matches, but aging turning on on a record
    RRLIST_NO_MATCH         -- no match, record is different

--*/
{
    DWORD           result = RRLIST_MATCH;
    PDB_RECORD      prr1;
    PDB_RECORD      prr2;
    DWORD           count1 = 0;
    DWORD           count2 = 0;
    BOOL            ffound;

    //
    //  verify existing RR counts are equal
    //

    prr1 = pNodeRRList;
    while ( prr1 )
    {
        count1++;
        prr1 = NEXT_RR(prr1);
    }

    prr2 = pCheckRRList;
    while ( prr2 )
    {
        count2++;
        CLEAR_MATCH_RR(prr2);
        prr2 = NEXT_RR(prr2);
    }

    if ( count1 != count2 )
    {
        DNS_DEBUG( UPDATE, (
            "RR_ListCompare() failed, list1 and list2 have different lengths (%d,%d).\n",
            count1,
            count2 ));
        return RRLIST_NO_MATCH;
    }

    //
    //  verify RRs compare
    //  as we match RR from list 1, mark RR in list2 so it can not be used twice
    //      this is faster, and prevents false positive when list1 is actually
    //      a subset of list2 with duplicates making it the same length
    //

    for ( prr1 = pNodeRRList;
          prr1 != NULL;
          prr1 = NEXT_RR( prr1 ) )
    {
        ffound = FALSE;

        prr2 = pCheckRRList;
        while ( prr2 )
        {
            if ( IS_MATCH_RR( prr2 ) || !RR_Compare( prr1, prr2, dwFlags ) )
            {
                prr2 = NEXT_RR(prr2);
                continue;
            }

            ffound = TRUE;
            SET_MATCH_RR( prr2 );
            break;
        }

        if ( !ffound )
        {
            DNS_DEBUG( UPDATE, (
                "RR_ListCompare() failed, pRR %p in list 1 unmatched.\n",
                prr1 ));
            return RRLIST_NO_MATCH;
        }

        //  no refresh action -- continue

        if ( dwRefreshTime == 0 )
        {
            continue;
        }

        //
        //  force refresh
        //      (-1) as refresh indicates FORCE refresh on records
        //

        if ( dwRefreshTime == FORCE_REFRESH_DUMMY_TIME )
        {
            if ( prr1->dwTimeStamp != 0 )
            {
                prr1->dwTimeStamp = g_CurrentTimeHours;
            }
        }

        //
        //  check refresh only if requested
        //  two cases
        //
        //  1) RR is aging
        //      => refresh if past refresh time
        //      => refresh if check RR has aging OFF
        //
        //  2) RR is not aging (RefreshTime is zero)
        //      => only need refresh if check RR has aging ON
        //
        //  note, we save the "highest ranking" refresh result
        //  rank is
        //      MATCH
        //      REFRESH
        //      AGING_ON
        //      AGING_OFF
        //      NO_MATCH
        //  the idea here if that caller may choose to react differently
        //  to different kinds of matching "failures"
        //
        //  currently, non-scavenging DS zones will not write simple
        //  refreshes, but will write aging being explicitly turned OFF
        //

        else if ( prr1->dwTimeStamp != prr2->dwTimeStamp )
        {
            DWORD   refreshResult = RRLIST_MATCH;

            if ( prr1->dwTimeStamp != 0 )
            {
                if ( prr2->dwTimeStamp == 0 )
                {
                    refreshResult = RRLIST_AGING_OFF;
                }
                else if ( prr1->dwTimeStamp < dwRefreshTime )
                {
                    refreshResult = RRLIST_AGING_REFRESH;
                }
            }
            else if ( prr2->dwTimeStamp != 0 )
            {
                refreshResult = RRLIST_AGING_ON;
            }

            if ( refreshResult > result )
            {
                result = refreshResult;
            }
        }
    }

    //  verify every record in check list was matched

    prr2 = pCheckRRList;
    while ( prr2 )
    {
        if ( IS_MATCH_RR(prr2) )
        {
            CLEAR_MATCH_RR(prr2);
            prr2 = NEXT_RR(prr2);
            continue;
        }

        DNS_DEBUG( UPDATE, (
            "RR_ListCompare() failed, pRR %p in list 2 unmatched.\n"
            "    list1 was subset of list2\n",
            prr2 ));

        return RRLIST_NO_MATCH;
    }

    return result;
}



BOOL
RR_IsRecordInRRList(
    IN      PDB_RECORD      pRRList,
    IN      PDB_RECORD      pRR,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Compare two RRs

Arguments:

    pRRList -- RR list to find record in;  if active list, must be locked

    pRR     -- record to find in list

    fCheckTtl -- TRUE to include TTL in check, FALSE otherwise

    fCheckTimestamp -- TRUE to include aging Timestamp in check, FALSE otherwise

Return Value:

    TRUE if pRR is in list
    FALSE if no match

--*/
{
    PDB_RECORD      pcheckRR;
    WORD            type;
    BOOL            bresult = FALSE;

    //
    //  check all records in list
    //      - if pRR found => TRUE
    //      - otherwise => FALSE
    //

    type = pRR->wType;

    for ( pcheckRR = pRRList;
          pcheckRR != NULL;
          pcheckRR = NEXT_RR(pcheckRR) )
    {
        if ( pcheckRR->wType == type )
        {
            bresult = RR_Compare( pRR, pcheckRR, dwFlags );
            if ( bresult )
            {
                break;
            }
            continue;
        }
        if ( pcheckRR->wType < type )
        {
            continue;
        }
        break;
    }

    DNS_DEBUG( UPDATE, (
        "RR_IsRecordInList() returns %d\n",
        bresult ));

    return bresult;
}



PDB_RECORD
FASTCALL
RR_RemoveRecordFromRRList(
    IN OUT  PDB_RECORD *    ppRRList,
    IN      PDB_RECORD      pRR,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Removes the matching RR from the list and returns a ptr to it. The caller
    is responsible for freeing or otherwise dealing with the RR.

Arguments:

    pRRList -- RR list to find record in;  if active list, must be locked

    pRR     -- record to find in list

    fCheckTtl -- TRUE to include TTL in check, FALSE otherwise

    fCheckTimestamp -- TRUE to include aging Timestamp in check, FALSE otherwise

Return Value:

    Pointer to matching record (which has been removed from list) or
    NULL if no match.

--*/
{
    PDB_RECORD      pMatchRR = NULL;
    PDB_RECORD      pCheckRR;
    PDB_RECORD      pPrevRR = NULL;
    WORD            type = pRR->wType;

    for ( pCheckRR = *ppRRList;
          pCheckRR != NULL;
          pPrevRR = pCheckRR, pCheckRR = NEXT_RR( pCheckRR ) )
    {
        if ( pCheckRR->wType == type )
        {
            if ( RR_Compare( pRR, pCheckRR, dwFlags ) )
            {
                //  Found it! Remove it from the list.

                pMatchRR = pCheckRR;
                if ( pPrevRR )
                {
                    pPrevRR->pRRNext = pMatchRR->pRRNext;   //  not head element
                }
                else
                {
                    *ppRRList = pMatchRR->pRRNext;      //  removing list head
                }
                pMatchRR->pRRNext = NULL;
                break;
            }
            continue;
        }
        if ( pCheckRR->wType < type )
        {
            continue;
        }
        break;
    }

    DNS_DEBUG( UPDATE, (
        "RR_RemoveRecordFromRRList() returns %p\n",
        pMatchRR ));

    return pMatchRR;
}   //  RR_RemoveRecordFromRRList



//
//  Record \ Record List free routines
//

DWORD
RR_ListFree(
    IN OUT  PDB_RECORD      pRRList
    )
/*++

Routine Description:

    Free records in RR list.
    Records are unassociated with any node.

Arguments:

    pRRList -- ptr to first record in list to free

Return Value:

    Count of records freed.

--*/
{
    register    PDB_RECORD  prr = pRRList;
    register    PDB_RECORD  pnextRR;
    DWORD       count = 0;

    while ( prr )
    {
        count++;

        pnextRR = prr->pRRNext;
        RR_Free( prr );
        prr = pnextRR;
    }
    
    return count;
}

//
//  End rrlist.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\sdutl.h ===
/*******************************************************************
*
*    File        : sdutl.h
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996-1999
*    Date        : 8/17/1998
*    Description :
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef SDUTL_H
#define SDUTL_H



// include //


// defines //

#define SZ_DNS_ADMIN_GROUP              "DnsAdmins"
#define SZ_DNS_ADMIN_GROUP_W            L"DnsAdmins"



// types //


// global variables //



// prototypes //
NTSTATUS __stdcall
SD_CreateClientSD(
    OUT PSECURITY_DESCRIPTOR *ppClientSD,
    IN PSECURITY_DESCRIPTOR *pBaseSD,       OPTIONAL
    IN PSID pOwnerSid,
    IN PSID pGroupSid,
    IN BOOL bAllowWorld
    );

NTSTATUS __stdcall
SD_CreateServerSD(
    OUT PSECURITY_DESCRIPTOR *ppServerSD
    );

NTSTATUS __stdcall
SD_GetProcessSids(
    OUT PSID *pServerSid,
    OUT PSID *pServerGroupSid
    );

NTSTATUS __stdcall
SD_GetThreadSids(
    OUT PSID *pServerSid,
    OUT PSID *pServerGroupSid);

VOID __stdcall
SD_Delete(
    IN  PVOID pVoid );

NTSTATUS __stdcall
SD_AccessCheck(
    IN      PSECURITY_DESCRIPTOR    pSd,
    IN      PSID                    pSid,
    IN      DWORD                   dwMask,
    IN OUT  PBOOL                   pbAccess);

BOOL __stdcall
SD_IsProxyClient(
      IN  HANDLE  token
      );

NTSTATUS __stdcall
SD_LoadDnsAdminGroup(
     VOID
     );

#if 0
//  This function is currently unused.
BOOL __stdcall
SD_IsDnsAdminClient(
    IN  HANDLE  token
    );
#endif

NTSTATUS __stdcall
SD_AddPrincipalToSD(
    IN       PSID                   pSid,           OPTIONAL
    IN       LPTSTR                 pwszName,       OPTIONAL
    IN       PSECURITY_DESCRIPTOR   pBaseSD,
    OUT      PSECURITY_DESCRIPTOR * ppNewSD,
    IN       DWORD                  AccessMask,
    IN       DWORD                  AceFlags,      OPTIONAL
    IN       PSID                   pOwner,        OPTIONAL
    IN       PSID                   pGroup,        OPTIONAL
    IN       BOOL                   bWhackExistingAce,
    IN       BOOL                   fTakeOwnership
    );

NTSTATUS
__stdcall
SD_RemovePrincipalFromSD(
    IN      PSID                    pSid,           OPTIONAL
    IN      LPTSTR                  pwszName,       OPTIONAL
    IN      PSECURITY_DESCRIPTOR    pSD,
    IN      PSID                    pOwner,        OPTIONAL
    IN      PSID                    pGroup,        OPTIONAL
    OUT     PSECURITY_DESCRIPTOR *  ppNewSD
    );

BOOL
__stdcall
SD_DoesPrincipalHasAce(
    IN      LPTSTR                  pwszName,       OPTIONAL
    IN      PSID                    pSid,           OPTIONAL
    IN      PSECURITY_DESCRIPTOR    pSD
    );

NTSTATUS
__stdcall
SD_IsImpersonating(
    VOID
    );

#endif

/******************* EOF *********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\rrwire.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    rrwire.c

Abstract:

    Domain Name System (DNS) Server

    Resource record read from wire routines for specific types.

Author:

    Jim Gilroy (jamesg)     Novemeber 1996

Revision History:

--*/


#include "dnssrv.h"
#include <stddef.h>


//
//  DEVNOTE: WireRead flat copy routines (?)
//  DEVNOTE: flat copy of known length routine? (?)
//
//      AAAA and LOC fall into this category
//      FLAT copy from wire BUT must match know length
//
//  Also
//      - plain vanilla flat copy (unknown types)
//      - flat copy and validate (TEXT types)
//          (fixed types could fall here with the validation,
//              catching length issue)
//



PDB_RECORD
AWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read A record wire format into database record.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;

    if ( wLength != SIZEOF_IP_ADDRESS )
    {
        return NULL;
    }

    //  allocate record

    prr = RR_Allocate( wLength );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    prr->Data.A.ipAddress = *(UNALIGNED DWORD *) pchData;
    return prr;
}


#if 0

PDB_RECORD
AaaaWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read AAAA record wire format into database record.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;

    if ( wLength != sizeof(IP6_ADDRESS) )
    {
        return NULL;
    }

    //  allocate record

    prr = RR_Allocate( wLength );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    RtlCopyMemory(
        & prr->Data.AAAA.ipv6Address,
        pchData,
        wLength );

    return prr;
}
#endif


#if 0

PDB_RECORD
A6WireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read A6 record wire format into database record.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    DBG_FN( "A6WireRead" )

    PDB_RECORD      prr;
    PCHAR           pch = pchData;
    PCHAR           pchend = pchData + wLength;
    UCHAR           prefixBits;
    COUNT_NAME      prefixName;

    if ( wLength < 1 )
    {
        // Must have at least 1 octet for prefix length.
        return NULL;
    }

    // Read the length of the prefix field in bits and skip over
    // the prefix length and address suffix field.

    prefixBits = * ( PUCHAR ) pch;
    pch += sizeof( UCHAR ) +            // length field
           prefixBits / 8 +             // integral bytes of prefix
           ( prefixBits % 8 ) ? 1 : 0;  // one more byte if not integral

    // Read the prefix name.

    pch = Name_PacketNameToCountName(
                & prefixName,
                pMsg,
                pch,
                pchend );
    if ( !pch || pch >= pchend )
    {
        DNS_PRINT(( "%s: "
            "pch = %p\n"
            "pchend = %p\n",
            fn,
            pch,
            pchend ));
        return NULL;
    }

    //  Allocate record.

    prr = RR_Allocate( ( WORD ) (
                SIZEOF_A6_FIXED_DATA + 
                Name_SizeofDbaseNameFromCountName( & prefixName ) ) );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    // Fill out fields in the record.

    prr->Data.A6.chPrefixBits = prefixBits;

    RtlZeroMemory( prr->Data.A6.AddressSuffix,
                   SIZEOF_A6_ADDRESS_SUFFIX_LENGTH );
    RtlCopyMemory(
        prr->Data.A6.AddressSuffix,
        pchData + sizeof( UCHAR ),
        SIZEOF_A6_ADDRESS_SUFFIX_LENGTH );

    Name_CopyCountNameToDbaseName(
        & prr->Data.A6.namePrefix,
        & prefixName );

    return prr;
} // A6WireRead
#endif



PDB_RECORD
OptWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read OPT record wire format into database record.

    See RFC2671 for OPT specification.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    DBG_FN( "OptWireRead" )

    PDB_RECORD      prr;

    //  Allocate record.

    prr = RR_Allocate( wLength );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    // Fill out fields in the record.

    // JJW: Should payload and extended flags be macros or something?
    //      Since they're only copies there no real need to have
    //      separate members.

    prr->Data.OPT.wUdpPayloadSize = pParsedRR->wClass;
    prr->Data.OPT.dwExtendedFlags = pParsedRR->dwTtl;

    // EDNS1+: parse RDATA into attribute,value pairs here.

    return prr;
} // OptWireRead



PDB_RECORD
CopyWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read from wire all types for which the database format is
    identical to the wire format (no indirection).

    Types included:
        HINFO
        ISDN
        X25
        WKS
        TXT
        NULL
        AAAA
        KEY

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;

    //
    //  allocate record
    //

    prr = RR_Allocate( wLength );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //
    //  DEVNOTE: should do post build validity check
    //

    RtlCopyMemory(
        & prr->Data.TXT,
        pchData,
        wLength );

    return prr;
}



PDB_RECORD
PtrWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Process PTR compatible record from wire.
    Includes: PTR, NS, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       length;
    COUNT_NAME  nameTarget;

    //
    //  get length of PTR name
    //

    pch = pchData;

    pch = Name_PacketNameToCountName(
                &nameTarget,
                pMsg,
                pch,
                pchend );
    if ( pch != pchend )
    {
        return NULL;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)  Name_SizeofDbaseNameFromCountName( &nameTarget ) );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //
    //  copy in name
    //

    Name_CopyCountNameToDbaseName(
           &prr->Data.PTR.nameTarget,
           &nameTarget );

    return prr;
}



PDB_RECORD
MxWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read MX compatible record from wire.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       length;
    COUNT_NAME  nameExchange;

    //
    //  skip fixed data
    //

    pch = pchData;
    pch += SIZEOF_MX_FIXED_DATA;
    if ( pch >= pchend )
    {
        return NULL;
    }

    //
    //  read name
    //      - MX exchange
    //      - RT exchange
    //      - AFSDB hostname
    //

    pch = Name_PacketNameToCountName(
                & nameExchange,
                pMsg,
                pch,
                pchend );
    if ( pch != pchend )
    {
        return NULL;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) (
                SIZEOF_MX_FIXED_DATA +
                Name_SizeofDbaseNameFromCountName( &nameExchange ) ) );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //

    prr->Data.MX.wPreference = *(UNALIGNED WORD *) pchData;

    //
    //  copy in name
    //

    Name_CopyCountNameToDbaseName(
           &prr->Data.MX.nameExchange,
           &nameExchange );

    return prr;
}



PDB_RECORD
SoaWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read SOA record from wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       length1;
    DWORD       length2;
    PDB_NAME    pname;
    COUNT_NAME  name1;
    COUNT_NAME  name2;

    DNS_PRINT((
        "pchData    = %p; offset %d\n"
        "wLength    = %d\n"
        "pchend     = %p\n"
        "pMsg       = %p\n",
        pchData, DNSMSG_OFFSET( pMsg, pchData ),
        wLength,
        pchend,
        pMsg ));

    //
    //  read SOA names
    //      - primary server
    //      - zone admin
    //

    pch = pchData;

    pch = Name_PacketNameToCountName(
                & name1,
                pMsg,
                pch,
                pchend );
    if ( !pch || pch >= pchend )
    {
        DNS_PRINT((
            "pch = %p\n"
            "pchend = %p\n",
            pch,
            pchend ));
        return NULL;
    }

    DNS_PRINT((
        "after first name:  pch = %p; offset from pchData %d\n"
        "pchend = %p\n",
        pch, pch-pchData,
        pchend ));

    pch = Name_PacketNameToCountName(
                & name2,
                pMsg,
                pch,
                pchend );
    if ( pch+SIZEOF_SOA_FIXED_DATA != pchend )
    {
        DNS_PRINT((
            "pch = %p\n"
            "pchend = %p\n",
            pch,
            pchend ));
        return NULL;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) (
                SIZEOF_SOA_FIXED_DATA +
                Name_SizeofDbaseNameFromCountName( &name1 ) +
                Name_SizeofDbaseNameFromCountName( &name2 ) ) );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //
    //  copy SOA fixed fields following names
    //      - dwSerialNo
    //      - dwRefresh
    //      - dwRetry
    //      - dwExpire
    //      - dwMinimumTtl
    //

    RtlCopyMemory(
        & prr->Data.SOA.dwSerialNo,
        pch,
        SIZEOF_SOA_FIXED_DATA );

    //
    //  copy in names
    //

    pname = &prr->Data.SOA.namePrimaryServer;

    Name_CopyCountNameToDbaseName(
        pname,
        &name1 );

    pname = (PDB_NAME) Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        &name2 );

    return prr;
}



PDB_RECORD
MinfoWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read MINFO and RP records from wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       length1;
    DWORD       length2;
    PDB_NAME    pname;
    COUNT_NAME  name1;
    COUNT_NAME  name2;

    //
    //  get length of MINFO names
    //

    pch = pchData;

    pch = Name_PacketNameToCountName(
                & name1,
                pMsg,
                pch,
                pchend );
    if ( !pch || pch >= pchend )
    {
        return NULL;
    }

    pch = Name_PacketNameToCountName(
                & name2,
                pMsg,
                pch,
                pchend );
    if ( pch != pchend )
    {
        return NULL;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) (
                Name_SizeofDbaseNameFromCountName( &name1 ) +
                Name_SizeofDbaseNameFromCountName( &name2 ) ) );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //
    //  copy in names
    //

    pname = &prr->Data.MINFO.nameMailbox;

    Name_CopyCountNameToDbaseName(
        pname,
        & name1 );

    pname = (PDB_NAME) Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        & name2 );

    return prr;
}



PDB_RECORD
SrvWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read SRV record from wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       length;
    COUNT_NAME  nameTarget;

    //
    //  skip fixed data and get length of SRV target name
    //

    pch = pchData;
    pch += SIZEOF_SRV_FIXED_DATA;
    if ( pch >= pchend )
    {
        return NULL;
    }

    //
    //  read SRV target host name
    //

    pch = Name_PacketNameToCountName(
                & nameTarget,
                pMsg,
                pch,
                pchend );
    if ( pch != pchend )
    {
        return NULL;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) (
                SIZEOF_SRV_FIXED_DATA +
                Name_SizeofDbaseNameFromCountName( &nameTarget ) ) );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //
    //  SRV fixed values
    //

    pch = pchData;
    prr->Data.SRV.wPriority = *(UNALIGNED WORD *) pch;
    pch += sizeof( WORD );
    prr->Data.SRV.wWeight = *(UNALIGNED WORD *) pch;
    pch += sizeof( WORD );
    prr->Data.SRV.wPort = *(UNALIGNED WORD *) pch;
    pch += sizeof( WORD );

    //
    //  copy in name
    //

    Name_CopyCountNameToDbaseName(
           & prr->Data.SRV.nameTarget,
           & nameTarget );

    return prr;
}



PDB_RECORD
WinsWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read WINS-R record from wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;

    //
    //  allocate record -- record is flat copy
    //

    if ( wLength < MIN_WINS_SIZE )
    {
        return NULL;
    }
    prr = RR_Allocate( wLength );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //
    //  WINS database and wire formats identical EXCEPT that
    //  WINS info is repeatedly used, so violate convention
    //  slightly and keep fixed fields in HOST order
    //

    RtlCopyMemory(
        & prr->Data.WINS,
        pchData,
        wLength );

    //  flip fixed fields

    prr->Data.WINS.dwMappingFlag    = ntohl( prr->Data.WINS.dwMappingFlag );
    prr->Data.WINS.dwLookupTimeout  = ntohl( prr->Data.WINS.dwLookupTimeout );
    prr->Data.WINS.dwCacheTimeout   = ntohl( prr->Data.WINS.dwCacheTimeout );
    prr->Data.WINS.cWinsServerCount = ntohl( prr->Data.WINS.cWinsServerCount );

    //  sanity check length
    //      - the first check is to guard against a specifically manufactured
    //      packet with a VERY large cWinsServerCount which DWORD wraps in
    //      the multipication and validates against the length

    if ( wLength < prr->Data.WINS.cWinsServerCount ||
         wLength != SIZEOF_WINS_FIXED_DATA
                    + (prr->Data.WINS.cWinsServerCount * sizeof(IP_ADDRESS)) )
    {
        RR_Free( prr );
        return NULL;
    }

    return prr;
}



PDB_RECORD
NbstatWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read WINS-R record from wire.

Arguments:

    prr - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       length;
    COUNT_NAME  nameResultDomain;

    //
    //  skip fixed data and get length of WINSR result domain
    //

    pch = pchData;
    pch += SIZEOF_NBSTAT_FIXED_DATA;

    if ( pch >= pchend )
    {
        return NULL;
    }

    //
    //  read result domain name
    //

    pch = Name_PacketNameToCountName(
                & nameResultDomain,
                pMsg,
                pch,
                pchend );
    if ( pch != pchend )
    {
        return NULL;
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) (
                SIZEOF_NBSTAT_FIXED_DATA +
                Name_SizeofDbaseNameFromCountName( &nameResultDomain ) ) );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //
    //  copy fixed fields
    //
    //  NBSTAT from wire is not used until AFTER zone transfer
    //      completes, so no attempt to detect or reset zone params
    //
    //  NBSTAT info is repeatedly used, so violate convention
    //      slightly and keep flags in HOST order
    //

    prr->Data.WINSR.dwMappingFlag = FlipUnalignedDword( pchData );
    pchData += sizeof( DWORD );
    prr->Data.WINSR.dwLookupTimeout = FlipUnalignedDword( pchData );
    pchData += sizeof( DWORD );
    prr->Data.WINSR.dwCacheTimeout = FlipUnalignedDword( pchData );
    pchData += sizeof( DWORD );

    //
    //  copy in name
    //

    Name_CopyCountNameToDbaseName(
           & prr->Data.WINSR.nameResultDomain,
           & nameResultDomain );

    return prr;
}



PDB_RECORD
SigWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read SIG record from wire - DNSSEC RFC 2535

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    intptr_t    sigLength;
    COUNT_NAME  nameSigner;

    //
    //  Skip fixed data.
    //

    pch = pchData + SIZEOF_SIG_FIXED_DATA;
    if ( pch >= pchend )
    {
        return NULL;
    }

    //
    //  Read signer's name. Compute signature length.
    //

    pch = Name_PacketNameToCountName(
                &nameSigner,
                pMsg,
                pch,
                pchend );

    sigLength = pchend - pch;

    //
    //  Allocate the RR. 
    //

    prr = RR_Allocate( ( WORD ) (
                SIZEOF_SIG_FIXED_DATA +
                COUNT_NAME_SIZE( &nameSigner ) +
                sigLength ) );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //
    //  Copy fixed values and signer's name.
    //

    RtlCopyMemory(
        &prr->Data.SIG,
        pchData,
        SIZEOF_SIG_FIXED_DATA );

    Name_CopyCountNameToDbaseName(
           &prr->Data.SIG.nameSigner,
           &nameSigner );

    //
    //  Copy signature.
    //

    RtlCopyMemory(
        ( PBYTE ) &prr->Data.SIG.nameSigner +
            DBASE_NAME_SIZE( &prr->Data.SIG.nameSigner ),
        pch,
        sigLength );

    return prr;
} // SigWireRead



PDB_RECORD
NxtWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read NXT record from wire - DNSSEC RFC 2535

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       sigLength;
    COUNT_NAME  nameNext;

    //
    //  Read nextname.
    //

    pch = Name_PacketNameToCountName(
                &nameNext,
                pMsg,
                pchData,
                pchend );
    if ( !pch )
    {
        goto Error;
    }

    //
    //  Allocate the RR.
    //

    prr = RR_Allocate( ( WORD ) (
                SIZEOF_NXT_FIXED_DATA +
                DNS_MAX_TYPE_BITMAP_LENGTH +
                Name_LengthDbaseNameFromCountName( &nameNext ) ) );
    IF_NOMEM( !prr )
    {
        goto Error;
    }

    //
    //  Copy NXT data into new RR.
    //

    Name_CopyCountNameToDbaseName(
           &prr->Data.NXT.nameNext,
           &nameNext );

    RtlCopyMemory(
        &prr->Data.NXT.bTypeBitMap,
        pch,
        pchend - pch );

    return prr;
    
    Error:
    
    return NULL;
} // NxtWireRead



//
//  Read RR from wire functions
//

RR_WIRE_READ_FUNCTION   RRWireReadTable[] =
{
    CopyWireRead,       //  ZERO -- default for unspecified types

    AWireRead,          //  A
    PtrWireRead,        //  NS
    PtrWireRead,        //  MD
    PtrWireRead,        //  MF
    PtrWireRead,        //  CNAME
    SoaWireRead,        //  SOA
    PtrWireRead,        //  MB
    PtrWireRead,        //  MG
    PtrWireRead,        //  MR
    CopyWireRead,       //  NULL
    CopyWireRead,       //  WKS
    PtrWireRead,        //  PTR
    CopyWireRead,       //  HINFO
    MinfoWireRead,      //  MINFO
    MxWireRead,         //  MX
    CopyWireRead,       //  TXT
    MinfoWireRead,      //  RP
    MxWireRead,         //  AFSDB
    CopyWireRead,       //  X25
    CopyWireRead,       //  ISDN
    MxWireRead,         //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigWireRead,        //  SIG
    CopyWireRead,       //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    CopyWireRead,       //  AAAA
    CopyWireRead,       //  LOC
    NxtWireRead,        //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvWireRead,        //  SRV
    CopyWireRead,       //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    OptWireRead,        //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    WinsWireRead,       //  WINS
    NbstatWireRead      //  WINS-R
};




PDB_RECORD
Wire_CreateRecordFromWire(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PPARSE_RECORD   pParsedRR,
    IN      PCHAR           pchData,
    IN      DWORD           MemTag
    )
/*++

Routine Description:

    Create database record from parsed wire record.

    Hides details of lookup table calls.

Arguments:

    pMsg - ptr to response info

    pParsedRR - parsed info from wire record

    pchData - record location (if no pParsedRR)

    MemTag - tag for dbase record to be created


    DEVNOTE: fix this marking so only done on actual attachment, then
                no node required

Return Value:

    Ptr to database record, if successful.
    NULL if bad record.

--*/
{
    RR_WIRE_READ_FUNCTION   preadFunction;
    PDB_RECORD      prr;
    PCHAR           pch;
    WORD            index;
    PARSE_RECORD    tempRR;


    DNS_DEBUG( READ2, (
        "Wire_CreateRecordFromWire() data at %p.\n",
        pchData ));

    //
    //  if no temp record, then pchData assumed to be record data
    //

    if ( !pParsedRR )
    {
        pch = Wire_ParseWireRecord(
                    pchData,
                    DNSMSG_END(pMsg),
                    TRUE,               // require class IN
                    & tempRR );
        if ( !pch )
        {
            DNS_PRINT((
                "ERROR:  bad packet record header on msg %p\n", pMsg ));
            CLIENT_ASSERT( FALSE );
            return NULL;
        }
        pchData += sizeof(DNS_WIRE_RECORD);
        pParsedRR = &tempRR;
    }

    //
    //  dispatch RR create function for desired type
    //      - all unknown types get flat data copy
    //

    preadFunction = (RR_WIRE_READ_FUNCTION)
                        RR_DispatchFunctionForType(
                            (RR_GENERIC_DISPATCH_FUNCTION *) RRWireReadTable,
                            pParsedRR->wType );
    if ( !preadFunction )
    {
        ASSERT( FALSE );
        return NULL;
    }

    prr = preadFunction(
            pParsedRR,
            pMsg,
            pchData,
            pParsedRR->wDataLength );

    if ( !prr )
    {
        DNS_PRINT((
            "ERROR:  DnsWireRead routine failure for recordpParsedRR->wType %d.\n\n\n",
           pParsedRR->wType ));
        return NULL;
    }

    //
    //  reset memtag
    //

    Mem_ResetTag( prr, MemTag );

    //
    //  set TTL, leave in net order -- used directly by zone nodes
    //      so this is valid for XFR and UPDATE
    //      must FLIP for caching
    //

    prr->dwTtlSeconds = pParsedRR->dwTtl;
    prr->dwTimeStamp = 0;

    //
    //  type may not be set in routines
    //

    prr->wType = pParsedRR->wType;

    return prr;

#if 0
    //
    //  DEVNOTE: error logging section???
    //

PacketError:

    DNS_LOG_EVENT_BAD_PACKET(
        DNS_EVENT_BAD_PACKET_LENGTH,
        pMsg );

    IF_DEBUG( ANY )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Packet error in packet from DNS server %s.\n"
            "    Discarding packet.\n",
            pszclientIp
            ));
        Dbg_DnsMessage(
            "Server packet with name error:",
             pMsg );
        DnsDebugUnlock();
    }
    if ( pdbaseRR )
    {
        RR_Free( pdbaseRR );
    }
#endif
}



PCHAR
Wire_ParseWireRecord(
    IN      PCHAR           pchWireRR,
    IN      PCHAR           pchStop,
    IN      BOOL            fClassIn,
    OUT     PPARSE_RECORD   pRR
    )
/*++

Routine Description:

    Parse wire record.

    Reads wire record into database format, and skips to next record.

Arguments:

    pWireRR     -- ptr to wire record

    pchStop     -- end of message, for error checking

    pRR         -- database record to receive record info

Return Value:

    Ptr to start of next record (i.e. next record name)
    NULL if record is bogus -- exceeds packet length.

--*/
{
    register PCHAR      pch;
    register WORD       tempWord;

    DNS_DEBUG( READ2, (
        "ParseWireRecord at %p.\n",
        pchWireRR ));

    IF_DEBUG( READ2 )
    {
        DnsDbg_PacketRecord(
            "Resource Record ",
            (PDNS_WIRE_RECORD) pchWireRR,
            NULL,           // no message header ptr available
            pchStop         // message end
            );
    }

    //
    //  make sure wire record safely within packet
    //

    pRR->pchWireRR = pch = (PCHAR) pchWireRR;

    if ( pch + sizeof(DNS_WIRE_RECORD) > pchStop )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  bad packet, not enough space remaining for"
            "RR structure.\n"
            "    Terminating caching from packet.\n" ));
        DNS_DEBUG( ANY, (
            "ERROR:  bad packet!!!\n"
            "    RR record (%p) extends beyond message stop at %p\n\n",
            pchWireRR,
            pchStop ));
        goto PacketError;
    }

    //
    //  read record fields
    //      - reject any non-Internet class records
    //        EXCEPT if this is an OPT RR, where CLASS is actually 
    //        the sender's UDP payload size
    //
    //  note:  class and TTL left in NET BYTE ORDER
    //          (strictly a perf issue)
    //

    pRR->wType  = READ_PACKET_HOST_WORD_MOVEON( pch );
    tempWord    = READ_PACKET_NET_WORD_MOVEON( pch );
    if ( pRR->wType != DNS_TYPE_OPT &&
        tempWord != DNS_RCLASS_INTERNET && fClassIn )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  bad packet!!!\n"
            "    RR record (%p) class %x non-Internet.\n\n",
            pchWireRR,
            tempWord ));
        goto PacketError;
    }
    pRR->wClass         = tempWord;

    pRR->dwTtl          = READ_PACKET_NET_DWORD_MOVEON( pch );
    tempWord            = READ_PACKET_HOST_WORD_MOVEON( pch );
    pRR->wDataLength    = tempWord;

    ASSERT( pch == pchWireRR + sizeof(DNS_WIRE_RECORD) );

    //
    //  verify record data withing message
    //

    pRR->pchData = pch;
    pch += tempWord;
    if ( pch > pchStop )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  bad packet!!!\n"
            "    RR record (%p) data extends beyond message stop at %p\n\n",
            pchWireRR,
            pchStop ));
        goto PacketError;
    }

    return( pch );

PacketError:

    return NULL;
}


//
//  End rrwire.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\security.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    security.c

Abstract:

    Domain Name System (DNS) Server

    Security utilities.

Author:

    Jim Gilroy (jamesg)     October, 1999

Revision History:

--*/


#include "dnssrv.h"


//
//  Security globals
//

PSECURITY_DESCRIPTOR        g_pDefaultServerSD;
PSECURITY_DESCRIPTOR        g_pServerObjectSD;
PSID                        g_pServerSid;
PSID                        g_pServerGroupSid;
PSID                        g_pDnsAdminSid;
PSID                        g_pAuthenticatedUserSid;
PSID                        g_pEnterpriseDomainControllersSid;
PSID                        g_pDomainControllersSid;
PSID                        g_pLocalSystemSid;
PSID                        g_pEveryoneSid;
PSID                        g_pDynuproxSid;
PSID                        g_pDomainAdminsSid;
PSID                        g_pEnterpriseAdminsSid;
PSID                        g_pBuiltInAdminsSid;

POLICY_DNS_DOMAIN_INFO *    g_pDnsPolicyInfo = NULL;
HANDLE                      g_LsaHandle = NULL;




VOID
dbgLookupSid(
    PSID    pSid,
    PSTR    pszContext
    )
{
#if DBG
    TCHAR           szDomain[ 200 ];
    DWORD           iDomain = 200;
    TCHAR           szUser[ 200 ];
    DWORD           iUser = 200;
    BOOL            b;
    SID_NAME_USE    sidNameUse = 0;
    
    b = LookupAccountSid(
            NULL, 
            pSid,
            szUser,
            &iDomain,
            szDomain,
            &iUser,
            &sidNameUse );
    if ( b )
    {
        DNS_PRINT((
            "%s: LookupAccountSid returned %S\\%S use=%d\n",
            pszContext, szDomain, szUser, sidNameUse));
    }
    else
    {
        DWORD       e = GetLastError();
        
        DNS_PRINT(( "%s, LookupAccountSid error=%d\n", pszContext, e ));
    }
#endif
}



DNS_STATUS
createWellKnownSid(
    WELL_KNOWN_SID_TYPE     WellKnownSidType,
    PSID *                  ppSid
    )
/*++

Routine Description:

    Wrapper around CreateWellKnownSid.

Arguments:

    WellKnownSidType -- SID to create 
    
    ppSid -- destination pointer for new SID
    
Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DBG_FN( "createWellKnownSid" )
    
    DNS_STATUS                  status = ERROR_SUCCESS;
    DWORD                       cbsid = SECURITY_MAX_SID_SIZE;
    
    //
    //  Allocate buffer for new SID.
    //
    
    *ppSid = ALLOCATE_HEAP( cbsid );
    if ( *ppSid == NULL )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    
    //
    //  Get domain SID. LSA blob and handle are closed on shutdown.
    //
    
    if ( !g_pDnsPolicyInfo )
    {
        NTSTATUS                    ntstatus;

        if ( !g_LsaHandle )
        {
            LSA_OBJECT_ATTRIBUTES       objectAttributes = { 0 };

            ntstatus = LsaOpenPolicy(
                            NULL,                   //  target system
                            &objectAttributes,      //  object attributes
                            POLICY_ALL_ACCESS,      //  desired access
                            &g_LsaHandle );
            if ( ntstatus != ERROR_SUCCESS )
            {
                status = ntstatus;
                DNS_PRINT((
                    "%s: LsaOpenPolicy returned %d\n", fn,
                    status ));
                ASSERT( !"LsaOpenPolicy failed" );
                goto Done;
            }
        }

        ntstatus = LsaQueryInformationPolicy(
                        g_LsaHandle,
                        PolicyDnsDomainInformation,
                        ( PVOID * ) &g_pDnsPolicyInfo );
        if ( ntstatus != ERROR_SUCCESS )
        {
            status = ntstatus;
            DNS_PRINT((
                "%s: LsaQueryInformationPolicy returned %d\n", fn,
                status ));
            ASSERT( !"LsaQueryInformationPolicy failed" );
            goto Done;
        }
    }
                        
    if ( !CreateWellKnownSid(
                WellKnownSidType,
                g_pDnsPolicyInfo->Sid,
                *ppSid,
                &cbsid ) )
    {
        status = GetLastError();
            DNS_PRINT((
                "%s: CreateWellKnownSid returned %d\n", fn,
                status ));
        ASSERT( !"CreateWellKnownSid failed" );
        goto Done;
    }

    //
    //  Cleanup and return.
    //
        
    Done:
    
    if ( status != ERROR_SUCCESS && *ppSid )
    {
        FREE_HEAP( *ppSid );
        *ppSid = NULL;
    }
    
    return status;
}



DNS_STATUS
Security_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize security.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( DS, ( "Security_Initialize()\n" ));

    //  clear security globals
    //  need to do this in case of server restart

    g_pDefaultServerSD                  = NULL;
    g_pServerObjectSD                   = NULL;
    g_pServerSid                        = NULL;
    g_pServerGroupSid                   = NULL;
    g_pDnsAdminSid                      = NULL;
    g_pAuthenticatedUserSid             = NULL;
    g_pEnterpriseDomainControllersSid   = NULL;
    g_pDomainControllersSid             = NULL;
    g_pLocalSystemSid                   = NULL;
    g_pEveryoneSid                      = NULL;
    g_pDomainAdminsSid                  = NULL;
    g_pDynuproxSid                      = NULL;
    g_pEnterpriseAdminsSid              = NULL;
    g_pBuiltInAdminsSid                 = NULL;

    //
    //  create standard SIDs
    //

    Security_CreateStandardSids();

    return ERROR_SUCCESS;
}



DNS_STATUS
Security_Shutdown(
    VOID
    )
/*++

Routine Description:

    Cleanup security.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( DS, ( "Security_Shutdown()\n" ));

    if ( g_pDnsPolicyInfo )
    {
        LsaFreeMemory( g_pDnsPolicyInfo );
        g_pDnsPolicyInfo = NULL;
    }
    
    if ( g_LsaHandle )
    {
        LsaClose( g_LsaHandle );
        g_LsaHandle = NULL;
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
Security_CreateStandardSids(
    VOID
    )
/*++

Routine Description:

    Create standard SIDs.

    These SIDs are used to create several different security descriptors
    so we just create them and leave them around for later use.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS                  status;
    DNS_STATUS                  finalStatus = ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY    ntAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    worldSidAuthority =  SECURITY_WORLD_SID_AUTHORITY;

    DNS_DEBUG( DS, ( "Security_CreateStandardSids()\n" ));

    //
    //  create standard SIDs
    //

    //
    //  Everyone SID
    //

    if ( !g_pEveryoneSid )
    {
        status = RtlAllocateAndInitializeSid(
                         &worldSidAuthority,
                         1,
                         SECURITY_WORLD_RID,
                         0, 0, 0, 0, 0, 0, 0,
                         &g_pEveryoneSid );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR <%lu>: Cannot create Everyone SID\n",
                status ));
            finalStatus = status;
        }
        else
        {
            dbgLookupSid( g_pEveryoneSid, "g_pEveryoneSid" );
        }
    }

    //
    //  Authenticated-user SID
    //

    if ( !g_pAuthenticatedUserSid )
    {
        status = RtlAllocateAndInitializeSid(
                        &ntAuthority,
                        1,
                        SECURITY_AUTHENTICATED_USER_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &g_pAuthenticatedUserSid );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR <%lu>: Cannot create Authenticated Users SID\n",
                status ));
            finalStatus = status;
        }
        else
        {
            dbgLookupSid( g_pAuthenticatedUserSid, "g_pAuthenticatedUserSid" );
        }
    }

    //
    //  Enterprise domain controllers SID
    //

    if ( !g_pEnterpriseDomainControllersSid )
    {
        status = RtlAllocateAndInitializeSid(
                        &ntAuthority,
                        1,
                        SECURITY_ENTERPRISE_CONTROLLERS_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &g_pEnterpriseDomainControllersSid );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR: <%lu>: Cannot create Enterprise Domain Controllers SID\n",
                status));
            finalStatus = status;
        }
        else
        {
            dbgLookupSid( g_pEnterpriseDomainControllersSid, "g_pEnterpriseDomainControllersSid" );
        }
    }

    //
    //  Local System SID
    //

    if ( !g_pLocalSystemSid )
    {
        status = RtlAllocateAndInitializeSid(
                        &ntAuthority,
                        1,
                        SECURITY_LOCAL_SYSTEM_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &g_pLocalSystemSid );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR: <%lu>: Cannot create Local System SID\n",
                status));
            finalStatus = status;
        }
        else
        {
            dbgLookupSid( g_pLocalSystemSid, "g_pLocalSystemSid" );
        }
    }

    //
    //  Admin SID
    //

    if ( !g_pDomainAdminsSid )
    {
        createWellKnownSid( WinAccountDomainAdminsSid, &g_pDomainAdminsSid );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR: <%lu>: Cannot create Domain Admins SID\n",
                status));
            finalStatus = status;
        }
        else
        {
            dbgLookupSid( g_pDomainAdminsSid, "g_pDomainAdminsSid" );
        }
    }

    //
    //  Domain controllers SID
    //

    if ( !g_pDomainControllersSid )
    {
        createWellKnownSid( WinAccountControllersSid, &g_pDomainControllersSid );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR: <%lu>: Cannot create Domain Controllers SID\n",
                status));
            finalStatus = status;
        }
        else
        {
            dbgLookupSid( g_pDomainControllersSid, "g_pDomainControllersSid" );
        }
    }
    

    //
    //  Enterprise Admins SID
    //

    if ( !g_pEnterpriseAdminsSid )
    {
        createWellKnownSid( WinAccountEnterpriseAdminsSid, &g_pEnterpriseAdminsSid );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR: <%lu>: Cannot create Enterprise Admins SID\n",
                status));
            finalStatus = status;
        }
        else
        {
            dbgLookupSid( g_pEnterpriseAdminsSid, "g_pEnterpriseAdminsSid" );
        }
    }

    //
    //  Built-in Administrators SID
    //

    if ( !g_pBuiltInAdminsSid )
    {
        createWellKnownSid( WinBuiltinAdministratorsSid, &g_pBuiltInAdminsSid );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR: <%lu>: Cannot create Built-in Administrators SID\n",
                status));
            finalStatus = status;
        }
        else
        {
            dbgLookupSid( g_pBuiltInAdminsSid, "g_pBuiltInAdminsSid" );
        }
    }

    return finalStatus;
}

//
//  End security.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\send.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    send.c

Abstract:

    Domain Name System (DNS) Server

    Send response routines.

Author:

    Jim Gilroy (jamesg)     January 1995

Revision History:

    jamesg  Jan 1995    -   rewrite generic response routine
    jamesg  Mar 1995    -   flip all counts when recieve packet
                            unflip here before send
                        -   Reject_UnflippedRequest()
    jamesg  Jul 1995    -   convert to generic send routine
                            and move to send.c
    jamesg  Sep 1997    -   improve NameError routine to send cached SOA
                            direct recursive response send

--*/


#include "dnssrv.h"


//
//  Retries on TCP  WSAEWOULDBLOCK error
//
//  This can occur on connection to remote that is backed up and not
//  being as serviced as fast as we can send.   XFR sends which involve
//  lots of data being sent fast, and require significant work by
//  receiver (new thread, new database, lots of nodes to build) can
//  presumably back up.  For standard recursive queries, this just
//  indicates a bogus, malperforming remote DNS.
//

#define WOULD_BLOCK_RETRY_DELTA     (1000)      //  1s retry intervals

#define MAX_WOULD_BLOCK_RETRY       (20)        //  20 retrys, then give up


//
//  Bad packet (bad opcode) suppression
//
//  Keeps list of IPs sending bad packets and just starts dropping
//  packets on the floor if they are in this list.
//

#define BAD_SENDER_SUPPRESS_INTERVAL    (60)        // one minute
#define BAD_SENDER_ARRAY_LENGTH         (10)

typedef struct
{
    DNS_ADDR    IpAddress;
    DWORD       ReleaseTime;
}
BAD_SENDER, *PBAD_SENDER;

BAD_SENDER  BadSenderArray[ BAD_SENDER_ARRAY_LENGTH ];


//
//  Private protos
//

BOOL
checkAndSuppressBadSender(
    IN OUT  PDNS_MSGINFO    pMsg
    );


DNS_STATUS
Send_Msg(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Send a DNS packet.

    This is the generic send routine used for ANY send of a DNS message.

    It assumes nothing about the message type, but does assume:
        - pCurrent points at byte following end of desired data
        - RR count bytes are in HOST byte order

    Depending on flags in the message and the remote destination, an OPT
    RR may be added to the end of the message. If the query has timeout out
    in the past, do not add an OPT, as the timeout may have been caused by
    MS DNS FORMERR suppression. This is a broad measure but it will work.

Arguments:

    pMsg - message info for message to send

Return Value:

    TRUE if successful.
    FALSE on send error.

--*/
{
    INT         err;
    DNS_STATUS  status = ERROR_SUCCESS;
    UCHAR       remoteEDnsVersion = NO_EDNS_SUPPORT;
    BOOL        wantToSendOpt;
    PBYTE       p;
    WORD        wPayload = ( WORD ) SrvCfg_dwMaxUdpPacketSize;

    DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

    #if DBG
    //  HeapDbgValidateAllocList();    
    Mem_HeapHeaderValidate( pMsg );    
    #endif
    
    //
    //  Pre-send processing:
    //  If required, insert an OPT RR at the end of the message. This
    //  RR will be the last RR in the additional section. If this query 
    //  already been sent, it may already have an OPT. In this case the
    //  OPT values should be overwritten to ensure they are current, or
    //  the OPT may need to be deleted.
    //

    wantToSendOpt = 
        pMsg->Opt.fInsertOptInOutgoingMsg &&
        pMsg->nTimeoutCount == 0;
    if ( wantToSendOpt )
    {
        //  Do check in two stages to avoid more expensive bits when possible.

        remoteEDnsVersion = Remote_QuerySupportedEDnsVersion(
                                &pMsg->RemoteAddr );
        if ( remoteEDnsVersion != UNKNOWN_EDNS_VERSION &&
            !IS_VALID_EDNS_VERSION( remoteEDnsVersion ) )
        {
            wantToSendOpt = FALSE;
        }
    }

    DNS_DEBUG( EDNS, (
        "Send_Msg: %p rem=%d insert=%d opt=%d add=%d wantToSend=%d\n",
        pMsg,
        ( int ) remoteEDnsVersion,
        ( int ) pMsg->Opt.fInsertOptInOutgoingMsg,
        ( int ) pMsg->Opt.wOptOffset,
        ( int ) pMsg->Head.AdditionalCount,
        ( int ) wantToSendOpt ));

    if ( pMsg->Opt.wOptOffset )
    {
        if ( wantToSendOpt )
        {
            //  Msg already has OPT. Overwrite OPT values.
            p = DNSMSG_OPT_PTR( pMsg ) + 3;
            INLINE_WRITE_FLIPPED_WORD( p, wPayload );
            p += sizeof( WORD );
            * ( p++ ) = pMsg->Opt.cExtendedRCodeBits;
            * ( p++ ) = 0;                      //  EDNS version
            * ( p++ ) = 0;                      //  ZERO
            * ( p++ ) = 0;                      //  ZERO
            * ( p++ ) = 0;                      //  RDLEN
            * ( p++ ) = 0;                      //  RDLEN
        }
        else
        {
            //  Msg has OPT but we don't want to send it. Remove it.
            pMsg->pCurrent = DNSMSG_OPT_PTR( pMsg );
            ASSERT( pMsg->Head.AdditionalCount > 0 );
            --pMsg->Head.AdditionalCount;
            pMsg->Opt.wOptOffset = 0;
        }
    }
    else
    {
        //
        //  Add OPT to message if it doesn't have one already and if there
        //  is room in the message buffer for it.
        //

        if ( wantToSendOpt && DNSMSG_BYTES_REMAINING( pMsg ) > 11 )
        {
            DB_RECORD   rr;

            pMsg->Opt.wOptOffset = DNSMSG_CURRENT_OFFSET( pMsg );
            p = pMsg->pCurrent;
            RtlZeroMemory( &rr, sizeof( rr ) );
            rr.wType = DNS_TYPE_OPT;
            if ( Wire_AddResourceRecordToMessage(
                    pMsg,
                    DATABASE_ROOT_NODE,     // this gives us the empty name
                    0,                      // name offset
                    &rr,
                    0 ) )
            {
                ++pMsg->Head.AdditionalCount;

                p += 3;
                INLINE_WRITE_FLIPPED_WORD( p, wPayload );
                p += sizeof( WORD );
                * ( p++ ) = pMsg->Opt.cExtendedRCodeBits;
                * ( p++ ) = 0;                      //  EDNS version
                * ( p++ ) = 0;                      //  ZERO
                * ( p++ ) = 0;                      //  ZERO
                * ( p++ ) = 0;                      //  RDLEN
                * ( p++ ) = 0;                      //  RDLEN

                //  Should have advanced p all the way through the RR added above.
                ASSERT( p == pMsg->pCurrent );
            }
            else
            {
                //
                //  There was an error adding the OPT. Put the message's
                //  current pointer back to where it was and continue without
                //  adding an OPT.
                //

                pMsg->pCurrent = p;
            }
        }
        //  else Msg has no OPT and we don't want to send one - do nothing.
    }

    //
    //  set for send
    //      - message length
    //      - flip header bytes to net order
    //
    //  log if desired
    //

    pMsg->Head.Reserved = 0;
    pMsg->MessageLength = (WORD)DNSMSG_OFFSET( pMsg, pMsg->pCurrent );

    DNSLOG_MESSAGE_SEND( pMsg );
    IF_DEBUG( SEND )
    {
        Dbg_DnsMessage(
            "Sending packet",
            pMsg );
    }

    DNSMSG_SWAP_COUNT_BYTES( pMsg );

    //
    //  TCP message, send until all info transmitted
    //

    DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

    if ( pMsg->fTcp )
    {
        WORD    wLength;
        PCHAR   pSend;

        //
        //  Clear Truncation bit. Even if the message is genuinely
        //  truncated (if the RRSet is >64K) we don't want to send
        //  a TCP packet with TC set. We could consider logging at
        //  error at this point.
        //

        pMsg->Head.Truncation = 0;

        //
        //  TCP message always begins with bytes being sent
        //
        //      - send length = message length plus two byte size
        //      - flip bytes in message length
        //      - send starting at message length
        //

        wLength = pMsg->MessageLength + sizeof( wLength );

        INLINE_WORD_FLIP( pMsg->MessageLength, pMsg->MessageLength );

        pSend = (PCHAR) & pMsg->MessageLength;

        while ( wLength )
        {
            //
            //  Check if the socket is valid. The TCP receiver can close the
            //  socket out from under us if the client closes the socket and
            //  the server receives a FIN. I have a opened a Longhorn bug to
            //  fix this is a more efficient and bullet-proof way.
            //
            
            if ( ( dwFlags & DNS_SENDMSG_TCP_ENLISTED ) &&
                 pMsg->fTcp &&
                 Tcp_ConnectionFindAndVerifyForMsg( pMsg ) == NULL )
            {
                err = WSAENOTSOCK;
                goto Done;
            }

            //  ASSERT_VALID_HANDLE( pMsg->Socket );

            err = send(
                    pMsg->Socket,
                    pSend,
                    (INT)wLength,
                    0 );

            if ( err == 0 || err == SOCKET_ERROR )
            {
                //
                //  first check for shutdown -- socket close may cause error
                //      - return cleanly to allow thread shutdown
                //

                if ( fDnsServiceExit )
                {
                    goto Done;
                }
                err = GetLastError();

                //
                //  WSAESHUTDOWN is ok, client got timed out connection and
                //      closed
                //
                //  WSAENOTSOCK may also occur if FIN recv'd and connection
                //      closed by TCP receive thread before the send
                //

                if ( err == WSAESHUTDOWN )
                {
                    DNS_DEBUG( ANY, (
                        "WARNING:  send() failed on shutdown TCP socket %d\n"
                        "    pMsgInfo at %p\n",
                        pMsg->Socket,
                        pMsg ));
                }
                else if ( err == WSAENOTSOCK )
                {
                    DNS_DEBUG( ANY, (
                        "ERROR:  send() on closed TCP socket %d\n"
                        "    pMsgInfo at %p\n",
                        pMsg->Socket,
                        pMsg ));
                }
                else if ( err == WSAEWOULDBLOCK )
                {
                    DNS_DEBUG( ANY, (
                        "ERROR:  send() WSAEWOULDBLOCK on TCP socket %d\n"
                        "    pMsgInfo at %p\n",
                        pMsg->Socket,
                        pMsg ));
                }
                else
                {
                    #if DBG
                    DNS_LOG_EVENT(
                        DNS_EVENT_SEND_CALL_FAILED,
                        0,
                        NULL,
                        NULL,
                        err );
                    #endif
                    DNS_DEBUG( ANY, ( "ERROR:  TCP send() failed, err = %d\n", err ));
                }
                status = err;
                goto Done;
            }
            wLength -= (WORD)err;
            pSend += err;
        }

        //
        //  count responses
        //
        //  update connection timeout
        //

        if ( pMsg->Head.IsResponse )
        {
            STAT_INC( QueryStats.TcpResponses );
            PERF_INC( pcTcpResponseSent );
            PERF_INC( pcTotalResponseSent );
            Tcp_ConnectionUpdateTimeout( pMsg->Socket );
        }
        else
        {
            STAT_INC( QueryStats.TcpQueriesSent );
        }
    }

    //
    //  UDP message
    //

    else
    {
        ASSERT( pMsg->MessageLength <= pMsg->MaxBufferLength );
        ASSERT( pMsg->RemoteAddr.SockaddrLength <= sizeof( pMsg->RemoteAddr.MaxSa ) );

        //
        //  protect against self-send
        //
        //  note, I don't believe any protection is needed on accessing
        //  g_ServerIp4Addrs;  it does change, but it changes by simple ptr
        //  replacement, and old copy gets timeout free
        //

        if ( !pMsg->Head.IsResponse &&
             DnsAddrArray_ContainsAddr(
                    g_ServerIp4Addrs,
                    &pMsg->RemoteAddr,
                    DNSADDR_MATCH_IP ) &&
             pMsg->RemoteAddr.SockaddrIn6.sin6_port == DNS_PORT_NET_ORDER )
        {
            LOOKUP_NAME     lookupName = { 0 };

            BYTE    argTypeArray[] =
                        {
                            EVENTARG_IP_ADDRESS,
                            EVENTARG_LOOKUP_NAME
                        };
            PVOID   argArray[] =
                        {
                            &pMsg->RemoteAddr,
                            &lookupName
                        };

            //
            //  If this fails, the lookup name should be zero'ed and
            //  logged as an empty string.
            //

            Name_ConvertPacketNameToLookupName(
                        pMsg,
                        pMsg->MessageBody,
                        &lookupName );

            DNS_PRINT((
                "ERROR: detected self-send to address %s\n",
                MSG_IP_STRING( pMsg ) ));

            err = DNS_ERROR_INVALID_IP_ADDRESS;

            DNSLOG( ANY, (
                "DNS server detected send to self at IP %s - message follows:\n",
                MSG_IP_STRING( pMsg ) ));

            Log_Message(
                pMsg,
                TRUE,
                TRUE );     // force print

            DNS_LOG_EVENT(
                DNS_EVENT_SELF_SEND,
                sizeof( argTypeArray ) / sizeof( argTypeArray[ 0 ] ),
                argArray,
                argTypeArray,
                err );

            status = err;
            goto Done;
        }

        //
        //  Set truncation bit. Is this the right place to do this, or
        //  will it already be set?
        //

        if ( pMsg->MessageLength >
            ( pMsg->Opt.wUdpPayloadSize > 0 ?
                pMsg->Opt.wUdpPayloadSize :
                DNS_RFC_MAX_UDP_PACKET_LENGTH ) )
        {
            pMsg->Head.Truncation = 1;
        }

        ASSERT_VALID_HANDLE( pMsg->Socket );

        err = sendto(
                pMsg->Socket,
                ( PCHAR ) DNS_HEADER_PTR( pMsg ),
                pMsg->MessageLength,
                0,
                &pMsg->RemoteAddr.Sockaddr,
                pMsg->RemoteAddr.SockaddrLength );

        if ( err == SOCKET_ERROR )
        {
            //
            //  first check for shutdown -- socket close may cause error
            //      - return cleanly to allow thread shutdown
            //

            if ( fDnsServiceExit )
            {
                goto Done;
            }

            err = GetLastError();
            if ( err == WSAENETUNREACH || err == WSAEHOSTUNREACH )
            {
                DNS_DEBUG( SEND, (
                    "WARNING:  sendto() failed with %d for packet %p\n",
                    err,
                    pMsg ));
            }
            else if ( err == WSAEWOULDBLOCK )
            {
                DNS_DEBUG( ANY, (
                    "WARNING:  sendto() failed with WOULDBLOCK for packet %p\n",
                    pMsg ));
            }
            else
            {
                IF_DEBUG( ANY )
                {
                    DNS_PRINT(( "ERROR:  UDP sendto() failed.\n" ));
                    DnsDbg_DnsAddr(
                        "sendto() failed sockaddr\n",
                        &pMsg->RemoteAddr );
                    Dbg_DnsMessage(
                        "sendto() failed message",
                        pMsg );
                }
                #if DBG
                DNS_LOG_EVENT(
                    DNS_EVENT_SENDTO_CALL_FAILED,
                    0,
                    NULL,
                    NULL,
                    err );
                #endif
            }
            status = err;
            goto Done;
        }

        if ( err != pMsg->MessageLength )
        {
            DNS_DEBUG( SEND, (
                "WARNING: sendto() on msg %p returned %d but expected %d\n"
                "\nGetLastError() = %d\n",
                pMsg,
                err,
                pMsg->MessageLength,
                GetLastError() ));
        }
        ASSERT( err == pMsg->MessageLength );

        //
        //  count sends query\response
        //

        if ( pMsg->Head.IsResponse )
        {
            STAT_INC( QueryStats.UdpResponses );
            PERF_INC( pcUdpResponseSent );
            PERF_INC( pcTotalResponseSent );
        }
        else
        {
            STAT_INC( QueryStats.UdpQueriesSent );
        }
    }

Done:

    //
    //  delete query, if desired
    //

    if ( pMsg->fDelete )
    {
        ASSERT( !pMsg->fRecursePacket );
        Packet_Free( pMsg );
    }
    else
    {
        DNSMSG_SWAP_COUNT_BYTES( pMsg );

        DNS_DEBUG( SEND, (
            "No delete after send of message at %p.\n",
            pMsg ));
    }
    return status;
}



DNS_STATUS
Send_ResponseAndReset(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           dwSendFlags
    )
/*++

Routine Description:

    Send a DNS packet and reset for reuse.

    It assumes nothing about the message type, but does assume:
        - pCurrent points at byte following end of desired data
        - RR count bytes are in HOST byte order

    After send message info reset for reuse:
        - pCurrent reset to point after original question
        - AvailLength reset appropriately
        - RR count bytes returned to HOST byte order

Arguments:

    pMsg -- message info for message to send and reuse
    
    dwSendFlags -- flags to pass to Send_Msg()

Return Value:

    TRUE if send successful.
    FALSE otherwise.

--*/
{
    DNS_STATUS          status;
    DWORD               blockRetry;
    FD_SET              exceptSocketSet;
    struct timeval      selectTimeout;

    //
    //  set as response and send
    //      - no delete after send

    pMsg->fDelete = FALSE;
    pMsg->Head.IsResponse = TRUE;
    pMsg->Head.RecursionAvailable = SrvCfg_fRecursionAvailable ? TRUE : FALSE;


    //
    //  send -- protecting against WOULDBLOCK error
    //
    //  WOULDBLOCK can occur when remote does not RESET connection
    //  but does not read receive buffer either (ie. not servicing
    //  connection);
    //  XFR sends which involve lots of data being sent fast, and
    //  require significant work by receiver (new thread, new database,
    //  lots of nodes to build) can presumably back up.  For standard
    //  recursive queries, this just indicates a bogus, malperforming
    //  remote DNS.
    //
    //  retry once a second up to 60 seconds then bail;
    //
    //  DEVNOTE: This seems like excessive retrying! Consider reducing
    //  this so that the thread can't block for so long.
    //

    blockRetry = 0;

    do
    {
        int     rc;

        status = Send_Msg( pMsg, dwSendFlags );
        if ( status != WSAEWOULDBLOCK )
        {
            break;
        }

        //
        //  If this is the first retry - initialize the socket set.
        //
        
        if ( blockRetry == 0 )
        {
            FD_ZERO( &exceptSocketSet );
            FD_SET( pMsg->Socket, &exceptSocketSet );
            selectTimeout.tv_sec = WOULD_BLOCK_RETRY_DELTA;
            selectTimeout.tv_usec = 0;
        }
        
        DNS_DEBUG( SEND, (
            "Send would block on message %p, socket %d, retry %d\n",
            pMsg, pMsg->Socket, blockRetry ));

        //
        //  Watch the socket for errors. Assume that any socket error means
        //  that the session has been closed or damaged and abort the operation.
        //

        rc = select( 0, NULL, NULL, &exceptSocketSet, &selectTimeout );
        if ( rc != 0 )
        {
            DNS_DEBUG( SEND, (
                "Wait error %d on message %p, socket %d, retry %d\n",
                WSAGetLastError(), pMsg, pMsg->Socket, blockRetry ));
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            break;
        }

        blockRetry++;
    }
    while ( blockRetry < MAX_WOULD_BLOCK_RETRY );

    //
    //  reset
    //      - point again immediately after question or after header
    //          if no question
    //      - reset available length
    //      - clear response counts
    //      - clear turncation
    //      - reset compression table
    //          - zero if no question
    //          - one (to include question) if question
    //          (this helps in XFR where zone is question)
    //
    //  note that Authority and ResponseCode are unchanged
    //

    INITIALIZE_COMPRESSION( pMsg );

    if ( pMsg->Head.QuestionCount )
    {
        pMsg->pCurrent = ( PCHAR ) ( pMsg->pQuestion + 1 );

        //  note this routine works even if pnode is NULL

        Name_SaveCompressionWithNode(
            pMsg,
            pMsg->MessageBody,
            pMsg->pNodeQuestion );
    }
    else
    {
        pMsg->pCurrent = pMsg->MessageBody;
    }

    pMsg->Head.AnswerCount = 0;
    pMsg->Head.NameServerCount = 0;
    pMsg->Head.AdditionalCount = 0;
    pMsg->Head.Truncation = 0;

    return status;
}



VOID
Send_Multiple(
    IN OUT  PDNS_MSGINFO        pMsg,
    IN      PDNS_ADDR_ARRAY     aipSendAddrs,
    IN OUT  PDWORD              pdwStatCount    OPTIONAL
    )
/*++

Routine Description:

    Send a DNS packet to multiple destinations.

    Assumes packet is in same state as normal send
        - host order count and XID
        - pCurrent pointing at byte after desired data

Arguments:

    pMsg - message info for message to send and reuse

    aipSendAddrs - IP array of addrs to send to

    pdwStatCount - addr of stat to update with number of sends

Return Value:

    None.

--*/
{
    DWORD   i;
    BOOLEAN fDelete;

    //
    //  save delete for after sends
    //

    fDelete = pMsg->fDelete;
    pMsg->fDelete = FALSE;

    //
    //  send the to each address specified in IP array
    //

    if ( aipSendAddrs )
    {
        for ( i = 0; i < aipSendAddrs->AddrCount; i++ )
        {
            DnsAddr_Copy( &pMsg->RemoteAddr, &aipSendAddrs->AddrArray[ i ] );
            Send_Msg( pMsg, 0 );
        }

        //  stats update

        if ( pdwStatCount )
        {
            *pdwStatCount += aipSendAddrs->AddrCount;
        }
    }

    if ( fDelete )
    {
        Packet_Free( pMsg );
    }
}



VOID
setResponseCode(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            ResponseCode
    )
/*++

Routine Description:

    Sets the ResponseCode in the message. If the ResponseCode is bigger
    than 4 bits, we must include an OPT in the response. With EDNS0, the
    ResponseCode can be up to 12 bits long.

Arguments:

    pMsg -- query to set ResponseCode in 

    ResponseCode -- failure response code

Return Value:

    None.

--*/
{
    if ( ResponseCode > DNS_RCODE_MAX )
    {
        pMsg->Opt.fInsertOptInOutgoingMsg = TRUE;
        pMsg->Opt.wUdpPayloadSize = ( WORD ) SrvCfg_dwMaxUdpPacketSize;
        pMsg->Opt.cVersion = 0;     // max version supported by server
        pMsg->Opt.cExtendedRCodeBits = ( ResponseCode >> 4 ) & 0xFF;
    }
    pMsg->Head.ResponseCode = ( BYTE ) ( ResponseCode & 0xF );
}



VOID
Reject_UnflippedRequest(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            ResponseCode,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Send failure response to query with unflipped bytes.

Arguments:

    pMsg -- query to respond to;  its memory is freed

    ResponseCode -- failure response code

    Flags -- flags modify way rejection is handled (DNS_REJECT_XXX)

Return Value:

    None.

--*/
{
    //
    //  flip header count bytes
    //      - they are flipped in Send_Response()
    //

    DNSMSG_SWAP_COUNT_BYTES( pMsg );
    Reject_Request( pMsg, ResponseCode, Flags );
    return;
}  // Reject_UnflippedRequest



VOID
Reject_Request(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            ResponseCode,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Send failure response to query.

Arguments:

    pMsg -- query to respond to;  its memory is freed

    ResponseCode -- failure response code

    Flags -- flags modify way rejection is handled (DNS_REJECT_XXX)

Return Value:

    None.

--*/
{
    DNS_DEBUG( RECV, ( "Rejecting packet at %p.\n", pMsg ));

    //
    //  clear any packet building we did
    //
    //  DEVNOTE: make packet building clear a macro, and use only when needed
    //      problem rejecting responses from other name servers that have
    //      these fields filled
    //

    pMsg->pCurrent = DNSMSG_END(pMsg);
    pMsg->Head.AnswerCount = 0;
    pMsg->Head.NameServerCount = 0;
    pMsg->Head.AdditionalCount = 0;

    //
    //  set up the error response code in the DNS header.
    //

    pMsg->Head.IsResponse = TRUE;
    setResponseCode( pMsg, ResponseCode );

    //
    //  check if suppressing response
    //

    if ( !( Flags & DNS_REJECT_DO_NOT_SUPPRESS ) &&
        checkAndSuppressBadSender(pMsg) )
    {
        return;
    }

    //
    //  Add rejection stats
    //
    //  DEVOTE: add PERF_INC( ... ) ? Add counters specific for rejection?
    // (see bug 292709 for this stat)
    //
    Stats_updateErrorStats ( (DWORD)ResponseCode );

    //
    //  UDP messages should all be set to delete
    //      => unless static buffer
    //      => unless nbstat
    //      => unless IXFR
    //  TCP messages are sometimes kept around for connection info
    //

    ASSERT( pMsg->fDelete ||
            pMsg->fTcp ||
            pMsg->U.Nbstat.pNbstat ||
            pMsg->wQuestionType == DNS_TYPE_IXFR ||
            ResponseCode == DNS_RCODE_SERVER_FAILURE );

    SET_OPT_BASED_ON_ORIGINAL_QUERY( pMsg );

    Send_Msg( pMsg, 0 );
} // Reject_Request



VOID
Reject_RequestIntact(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            ResponseCode,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Send failure response to request.

    Unlike Reject_Request(), this routine sends back entire
    packet, unchanged accept for header flags.
    This is necessary for messages like UPDATE, where sender
    may have RRs outside of question section.

Arguments:

    pMsg -- query to respond to;  its memory is freed

    ResponseCode -- failure response code

    Flags -- flags modify way rejection is handled (DNS_REJECT_XXX)

Return Value:

    None.

--*/
{
    DNS_DEBUG( RECV, ("Rejecting packet at %p.\n", pMsg ));

    //
    //  set pCurrent so send entire length
    //

    pMsg->pCurrent = DNSMSG_END(pMsg);

    //
    //  Set up the error response code in the DNS header. 
    //

    pMsg->Head.IsResponse = TRUE;
    setResponseCode( pMsg, ResponseCode );

    //
    //  check if suppressing response
    //

    if ( !( Flags & DNS_REJECT_DO_NOT_SUPPRESS ) &&
        checkAndSuppressBadSender(pMsg) )
    {
        return;
    }

    //
    //  Add rejection stats
    //
    //  DEVNOTE: add PERF_INC( ... ) ? Add counters specific for rejection?
    // (see bug 292709 for this stat)
    //
    Stats_updateErrorStats ( (DWORD)ResponseCode );


    //
    //  UDP messages should all be set to delete
    //      => unless static buffer
    //      => unless nbstat
    //      => unless IXFR
    //  TCP messages are sometimes kept around for connection info
    //

    ASSERT( pMsg->fDelete ||
            pMsg->fTcp ||
            pMsg->U.Nbstat.pNbstat ||
            pMsg->wQuestionType == DNS_TYPE_IXFR ||
            ResponseCode == DNS_RCODE_SERVER_FAILURE );

    Send_Msg( pMsg, 0 );
} // Reject_RequestIntact



VOID
Send_NameError(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Send NAME_ERROR response to query.
    First writes zone SOA, if authoritative response.

Arguments:

    pMsg -- query to respond to;  its memory is freed

Return Value:

    None.

--*/
{
    PZONE_INFO  pzone;
    PDB_NODE    pnode;
    PDB_NODE    pnodeSoa;
    PDB_RECORD  prr;
    DWORD       ttl = MAXDWORD;
    PDWORD      pminTtl;

    DNS_DEBUG( RECV, ( "Send_NameError( %p ).\n", pMsg ));

    //
    //  clear any packet building we did
    //
    //  DEVNOTE:  make packet building clear a macro, and use only when needed
    //      problem rejecting responses from other name servers that have
    //      these fields filled
    //

    //  note:  the Win95 NBT resolver is broken and sends packets that
    //      exceed the length of the actual DNS message;  i'm guessing
    //      that this is because it allocates a buffer based on a 16 byte
    //      netBIOS name + DNS domain and sends the whole thing regardless
    //      of how big the name actually was
    //      => bottom line, can't use this check
    //  MSG_ASSERT( pMsg, pMsg->pCurrent == DNSMSG_END(pMsg) );

    MSG_ASSERT( pMsg, pMsg->pCurrent > (PCHAR)DNS_HEADER_PTR(pMsg) );
    MSG_ASSERT( pMsg, pMsg->pCurrent < pMsg->pBufferEnd );
    MSG_ASSERT( pMsg, (PCHAR)(pMsg->pQuestion + 1) == pMsg->pCurrent );
    MSG_ASSERT( pMsg, pMsg->Head.AnswerCount == 0 );
    MSG_ASSERT( pMsg, pMsg->Head.NameServerCount == 0 );
    MSG_ASSERT( pMsg, pMsg->Head.AdditionalCount == 0 );

    //
    //  set up the error response code in the DNS header.
    //

    pMsg->Head.IsResponse = TRUE;
    pMsg->Head.ResponseCode = DNS_RCODE_NAME_ERROR;

    pzone = pMsg->pzoneCurrent;
    pnode = pMsg->pnodeCurrent;

    IF_DEBUG( LOOKUP )
    {
        DNS_PRINT((
            "Name error node = %p, zone = %p\n",
            pnode, pzone ));
        Dbg_DbaseNode( "NameError node:", pnode );
    }

    //
    //  authoritative zone
    //
    //  make determination on NAME_ERROR \ AUTH_EMPTY
    //  based on whether
    //      - pnode directly has other data
    //      - zone is set for WINS\WINSR lookup and didn't do lookup
    //      - wildcard data exists
    //
    //  also, for SOA query (possible FAZ for update), save additional data
    //  and attempt additional data lookup before final send
    //
    //  JDEVNOTE: if NAME_ERROR at end of CNAME chain, then pNodeQuestion is out
    //      - no longer reliable indicator
    //

    if ( pzone && !IS_ZONE_NOTAUTH( pzone ) )
    {
        ASSERT(
            IS_ZONE_FORWARDER( pzone ) ||
            IS_ZONE_STUB( pzone ) ||
            pMsg->Head.Authoritative );
        ASSERT( pMsg->pNodeQuestionClosest->pZone );
        ASSERT( !pnode || pnode == pMsg->pNodeQuestionClosest );
        ASSERT( pMsg->pNodeQuestionClosest->pZone == pzone );

        //
        //  WINS or WINSR zone
        //
        //  if WINS cache time less than SOA TTL, use it instead
        //
        //  do NOT send NAME_ERROR if
        //      - in WINS zone
        //      - query is for name that would have WINS lookup
        //      - never looked up the WINS type (so WINS\WINSR lookup could succeed)
        //      - no cached NAME_ERROR
        //
        //  note: that for WINS lookup to succeed, must be only one level below
        //      zone root;  must screen out both nodes that are found, and names
        //      that are NOT found, that are more than one level below zone root
        //
        //      example:
        //          zone    foo.bar
        //          query   sammy.dev.foo.bar
        //          closest foo.bar
        //

        prr = pzone->pWinsRR;
        if ( prr )
        {
            if ( pzone->dwDefaultTtlHostOrder > prr->Data.WINS.dwCacheTimeout )
            {
                ttl = prr->Data.WINS.dwCacheTimeout;
            }

            if ( !pzone->fReverse )  // WINS zone
            {
                if ( pMsg->wQuestionType != DNS_TYPE_A &&
                    pMsg->wQuestionType != DNS_TYPE_ALL &&
                    ( (!pnode &&
                        pMsg->pnodeClosest == pzone->pZoneRoot &&
                        pMsg->pLooknameQuestion->cLabelCount ==
                            pzone->cZoneNameLabelCount + 1 )
                    || (pnode &&
                        !IS_NOEXIST_NODE(pnode) &&
                        pnode->pParent == pzone->pZoneRoot) ) )
                {
                    pMsg->Head.ResponseCode = DNS_RCODE_NO_ERROR;
                }
            }
            else    // WINSR zone
            {
                if ( pMsg->wQuestionType != DNS_TYPE_PTR &&
                    pMsg->wQuestionType != DNS_TYPE_ALL &&
                    ( !pnode || !IS_NOEXIST_NODE(pnode) ) )
                {
                    pMsg->Head.ResponseCode = DNS_RCODE_NO_ERROR;
                }
            }
        }

        //
        //  Authoritative Empty Response?
        //

        if ( pnode && !EMPTY_RR_LIST( pnode ) && !IS_NOEXIST_NODE( pnode ) )
        {
            DNS_DEBUG( LOOKUP, (
                "empty auth: node %p rrlist %p noexist %d\n",
                pnode,
                pnode->pRRList,
                IS_NOEXIST_NODE( pnode ) ));
            pMsg->Head.ResponseCode = DNS_RCODE_NO_ERROR;
        }

        //
        //  Check if wildcard for another type
        //      - if exists then NO_ERROR response
        //

        else if ( pMsg->fQuestionWildcard == WILDCARD_UNKNOWN )
        {
            if ( Answer_QuestionWithWildcard(
                    pMsg,
                    pMsg->pNodeQuestionClosest,
                    DNS_TYPE_ALL,
                    WILDCARD_CHECK_OFFSET ) )
            {
                DNS_DEBUG( LOOKUP, (
                    "Wildcard flag EXISTS, switching to NO_ERROR response for %p\n",
                    pMsg ));
                pMsg->Head.ResponseCode = DNS_RCODE_NO_ERROR;
            }
            ELSE_ASSERT( pMsg->fQuestionWildcard == WILDCARD_NOT_AVAILABLE );
        }

        else if ( pMsg->fQuestionWildcard == WILDCARD_EXISTS )
        {
            DNS_DEBUG( LOOKUP, (
                "Wildcard flag EXISTS, switching to NO_ERROR response for %p\n",
                pMsg ));
            pMsg->Head.ResponseCode = DNS_RCODE_NO_ERROR;
        }
        ELSE_ASSERT( pMsg->fQuestionWildcard == WILDCARD_NOT_AVAILABLE );

        //  writing name error, using SOA at zone root

        pnodeSoa = pzone->pZoneRoot;

        //  SOA query?
        //      - save primary name additional data to speed FAZ query

        if ( pMsg->wQuestionType == DNS_TYPE_SOA )
        {
            pMsg->fDoAdditional = TRUE;
        }
    }

    //
    //  if non-authoritative and name error for original question
    //      - if know zone, attempt SOA write, otherwise send
    //      - note under lock as grabbing record
    //      - note that we assume name error determination already made,
    //      if has timed out since, we just send without SOA and TTL
    //

    else if ( pnode &&
              IS_NOEXIST_NODE( pnode ) &&
              IS_SET_TO_WRITE_ANSWER_RECORDS( pMsg ) &&
              CURRENT_RR_SECTION_COUNT( pMsg ) == 0 )
    {
        if ( !RR_CheckNameErrorTimeout(
                    pnode,
                    FALSE,      // don't remove
                    &ttl,
                    &pnodeSoa ) )
        {
            goto Send;
        }
        if ( !pnodeSoa )
        {
            goto Send;
        }
    }

    //  no zone SOA available, just send NAME_ERROR

    else
    {
        goto Send;
    }

    SET_TO_WRITE_AUTHORITY_RECORDS(pMsg);

    //
    //  Try to write an NXT record to the packet. For name error, we must
    //  have found the NXT node during the packet lookup. For empty auth
    //  responses the NXT is the one for the lookup node.
    //

    if ( DNSMSG_INCLUDE_DNSSEC_IN_RESPONSE( pMsg ) )
    {
        PDB_NODE    presponsenode;
        
        presponsenode = pMsg->Head.ResponseCode == DNS_RCODE_NO_ERROR ?
                            pMsg->pnodeCurrent :
                            pMsg->pnodeNxt;
        if ( presponsenode )
        {
            Wire_WriteRecordsAtNodeToMessage(
                    pMsg,
                    presponsenode,
                    DNS_TYPE_NXT,
                    0,
                    DNSSEC_ALLOW_INCLUDE_ALL );
        }
    }

    //
    //  write SOA to authority section
    //      - don't worry about failure or truncation -- if fails, just send
    //      - overwrite minTTL field if smaller timeout appropriate
    //

    if ( ! Wire_WriteRecordsAtNodeToMessage(
                pMsg,
                pnodeSoa,
                DNS_TYPE_SOA,
                0,
                DNSSEC_ALLOW_INCLUDE_ALL ) )
    {
        goto Send;
    }

    if ( ttl != MAXDWORD )
    {
        pminTtl = (PDWORD)(pMsg->pCurrent - sizeof(DWORD));
        INLINE_DWORD_FLIP( ttl, ttl );
        * (UNALIGNED DWORD *) pminTtl = ttl;
    }

    //
    //  SOA query?
    //      - write primary name additional data to speed FAZ query
    //

    if ( pMsg->wQuestionType == DNS_TYPE_SOA && pzone )
    {
        DNS_DEBUG( LOOKUP, (
            "Break from Send_NameError() to write SOA additional data; pmsg = %p.\n",
            pMsg ));

        Answer_ContinueNextLookupForQuery( pMsg );
        return;
    }

Send:

    Stats_updateErrorStats( DNS_RCODE_NAME_ERROR );

    //
    //  UDP messages should all be set to delete
    //      => unless nbstat
    //  TCP messages are sometimes kept around for connection info
    //

    ASSERT( pMsg->fDelete || pMsg->fTcp || pMsg->U.Nbstat.pNbstat );

    Send_Msg( pMsg, 0 );
}   //  Send_NameError



BOOL
Send_RecursiveResponseToClient(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN OUT  PDNS_MSGINFO    pResponse
    )
/*++

Routine Description:

    Send recursive response back to original client.

Arguments:

    pQuery -- original query

    pResponse -- response from remote DNS

Return Value:

    None.

--*/
{
    BOOLEAN fresponseTcp;

    DNS_DEBUG( SEND, (
        "Responding to query %p with recursive response %p.\n",
        pQuery,
        pResponse ));

    //
    //  check for TCP\UDP mismatch between query and response
    //  make sure we can do the right thing
    //  if TCP response, then make sure it fits within UDP query
    //  if UDP response, make sure don't have truncation bit set
    //
    //  DEVNOTE: fix truncation reset when do TCP recursion
    //              (then we shouldn't fall here with TCP query and truncated
    //              response, we should have recursed with TCP)
    //

    fresponseTcp = pResponse->fTcp;

    if ( fresponseTcp != pQuery->fTcp )
    {
        if ( !fresponseTcp )
        {
            pResponse->Head.Truncation = FALSE;
        }
        else    // TCP response
        {
            if ( pResponse->MessageLength > DNSSRV_UDP_PACKET_BUFFER_LENGTH )
            {
                return FALSE;
            }
            pResponse->Head.Truncation = TRUE;
        }
        pResponse->fTcp = !fresponseTcp;
    }

    //
    //  EDNS
    //
    //  If the response is larger than the maximum standard UDP packet and
    //  less than the EDNS payload size specified in the query, we must
    //  cache the response and regenerate an answer packet from the
    //  database. We also must allow for a minimum length OPT to be
    //  appended to the response.
    //
    //  Turn on the response's OPT include flag if the query included an OPT.
    //

    if ( pResponse->MessageLength > DNS_RFC_MAX_UDP_PACKET_LENGTH &&
        ( pQuery->Opt.wOriginalQueryPayloadSize == 0 ||
            pResponse->MessageLength + DNS_MINIMIMUM_OPT_RR_SIZE >
                pQuery->Opt.wOriginalQueryPayloadSize ) )
    {
        return FALSE;
    }
    pResponse->Opt.wOriginalQueryPayloadSize =
        pQuery->Opt.wOriginalQueryPayloadSize;
    SET_OPT_BASED_ON_ORIGINAL_QUERY( pResponse );

    //
    //  setup response with query info
    //      - original XID
    //      - socket and address
    //      - set response for no delete on send (all responses are
    //      cleaned up in Answer_ProcessMessage() in answer.c)
    //      - set pCurrent to end of message (Send_Msg() uses to determine
    //      message length)
    //

    pResponse->Head.Xid = pQuery->Head.Xid;
    pResponse->Socket   = pQuery->Socket;
    DnsAddr_Copy( &pResponse->RemoteAddr, &pQuery->RemoteAddr );

    pResponse->fDelete  = FALSE;
    pResponse->pCurrent = DNSMSG_END( pResponse );

    //
    //  send response
    //  restore pResponse TCP flag, strictly for packet counting purposes when
    //      packet is freed
    //  delete original query
    //

    Send_Msg( pResponse, 0 );

    pResponse->fTcp = fresponseTcp;
    STAT_INC( RecurseStats.SendResponseDirect );

    Packet_Free( pQuery );

    return TRUE;
}   //  Send_RecursiveResponseToClient



VOID
Send_QueryResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Send response to query.

    Main routine for sending response when all lookup exhausted.
    Its main purpose is to determine if need NameError, AuthEmpty or
        ServerFailure when no lookup has succeeded.

Arguments:

    pMsg -- query to respond to;  its memory is freed

Return Value:

    None.

--*/
{
    DNS_DEBUG( LOOKUP, (
        "Send_QueryResponse( %p ).\n",
        pMsg ));

    //
    //  free query after response
    //

    pMsg->fDelete = TRUE;
    pMsg->Head.IsResponse = TRUE;

    //
    //  question answered ?
    //      or referral
    //      or SOA for AUTH empty response
    //

    SET_OPT_BASED_ON_ORIGINAL_QUERY( pMsg );

    if ( pMsg->Head.AnswerCount != 0 || pMsg->Head.NameServerCount != 0 )
    {
        Send_Msg( pMsg, 0 );
        return;
    }

    //
    //  question not answered
    //      hence current name is question name
    //
    //  Send_NameError() makes NAME_ERROR \ AUTH_EMPTY determination
    //  based on whether other data may be available for other types from
    //      - WINS\WINSR
    //      - wildcard
    //
    //  note:  we need the WRITING_ANSWER check because it's possible to have
    //      a case where we are attempting to writing referral, but the NS
    //      records go away at delegation or at root node;  don't want to
    //      send NAME_ERROR, just bail out
    //

    if ( pMsg->Head.Authoritative &&
         IS_SET_TO_WRITE_ANSWER_RECORDS( pMsg ) )
    {
        //  This path is for question node found except for not-auth zones.

        ASSERT(
            pMsg->pNodeQuestionClosest->pZone == pMsg->pzoneCurrent ||
            ( pMsg->pNodeQuestionClosest->pZone == NULL &&
                pMsg->pzoneCurrent != NULL &&
                IS_ZONE_NOTAUTH( pMsg->pzoneCurrent ) ) );

        Send_NameError( pMsg );
        return;
    }

    //
    //  not authoritative and unable to come up with answer OR referral
    //
    //  DEVNOTE: should we give referrral if recurse failure?
    //      may have some merit for forwarding
    //

    Reject_Request(
        pMsg,
        DNS_RCODE_SERVER_FAILURE,
        0 );
    return;
}



VOID
Send_ForwardResponseAsReply(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN      PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Set response for reply to original query.

Arguments:

    pResponse - ptr to response from remote server

    pQuery - ptr to original query

Return Value:

    None

--*/
{
    DNS_DEBUG( SEND, (
        "Forwarding response %p to query %p\n"
        "    back to original client at %s.\n",
        pResponse,
        pQuery,
        DNSADDR_STRING( &pQuery->U.Forward.ipOriginal ) ));

    COPY_FORWARDING_FIELDS( pResponse, pQuery );

    //  responses are freed by response dispatching block (answer.c)

    pResponse->fDelete = FALSE;
    pResponse->pCurrent = DNSMSG_END( pResponse );

    Send_Msg( pResponse, 0 );
}



VOID
Send_InitBadSenderSuppression(
    VOID
    )
/*++

Routine Description:

    Init bad sender suppression.

Arguments:

    None

Return Value:

    None.

--*/
{
    RtlZeroMemory(
        BadSenderArray,
        (BAD_SENDER_ARRAY_LENGTH * sizeof(BAD_SENDER)) );
}



BOOL
checkAndSuppressBadSender(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Check for bad packet response suppression.

    If from recent "bad IP", then suppress response
    and if pMsg->fDelete flag is set free the packet memory.
    The semantics of this function in the TRUE case are
    identical to Send_Msg without the send, so on TRUE return
    the caller can treat as if it used Send_Msg().

Arguments:

    pMsg -- query being responded to

Return Value:

    TRUE if message suppressed;  caller should not send the response.
    FALSE if message not sent;  caller should send.

--*/
{
    DWORD       i;
    DWORD       entryTime;
    DWORD       useIndex = MAXDWORD;
    DWORD       oldestEntryTime = MAXDWORD;
    DWORD       nowTime = DNS_TIME();
    PDNS_ADDR   pdnsAddr = &pMsg->RemoteAddr;

    DNS_DEBUG( RECV, ( "checkAndSuppressBadSender( %p )\n", pMsg ));

    //
    //  ignore suppression for regression test runs
    //

    if ( SrvCfg_dwEnableSendErrSuppression )
    {
        return FALSE;
    }

    //
    //  check if suppressable RCODE
    //      - FORMERR
    //      - NOTIMPL
    //  are suppressable;  the others convery real info
    //
    //  however, DEVNOTE: since we're using NOTIMPL on dynamic update, for
    //      zone's without update, we won't suppress if this is
    //      clearly a dynamic update packet

    if ( pMsg->Head.ResponseCode != DNS_RCODE_FORMERR
            &&
        (   pMsg->Head.ResponseCode != DNS_RCODE_NOTIMPL ||
            pMsg->Head.Opcode == DNS_OPCODE_UPDATE ) )
    {
        return FALSE;
    }

    //
    //  find if suppressing response for IP
    //
    //  why no locking?
    //  the worse case that no locking does here is that we
    //  inadvertantly allow a send that we'd like to suppress
    //  (i.e. someone else writes their IP in on top of ours
    //  and so we go through this again and don't find
    //
    //  optimizations would be a count to track suppressions,
    //  allowing
    //

    for ( i = 0; i < BAD_SENDER_ARRAY_LENGTH; ++i )
    {
        entryTime = BadSenderArray[ i ].ReleaseTime;

        if ( DnsAddr_IsEqual(
                pdnsAddr,
                &BadSenderArray[ i ].IpAddress,
                DNSADDR_MATCH_IP ) )
        {
            if ( nowTime < entryTime )
            {
                goto Suppress;
            }
            useIndex = i;
            break;
        }

        //  otherwise find oldest suppression entry to grab
        //  in case don't match our own IP

        else if ( entryTime < oldestEntryTime )
        {
            useIndex = i;
            oldestEntryTime = entryTime;
        }
    }

    //  set entry to suppress any further bad packets from this IP
    //  ReleaseTime will be when suppression stops

    if ( useIndex != MAXDWORD )
    {
        DnsAddr_Copy( &BadSenderArray[ useIndex ].IpAddress, pdnsAddr );
        BadSenderArray[ useIndex ].ReleaseTime = nowTime + BAD_SENDER_SUPPRESS_INTERVAL;
    }
    return FALSE;

Suppress:

    //
    //  if suppressing and message set for delete -- free the memory
    //  this keeps us completely analogous to Send_Msg() except for
    //  hitting the wire
    //

    DNS_DEBUG( RECV, (
        "Suppressing error (%d) send on ( %p )\n",
        pMsg->Head.ResponseCode,
        pMsg ));

    if ( pMsg->fDelete )
    {
        Packet_Free( pMsg );
    }
    return TRUE;
}


//
//  End of send.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\socket.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    socket.h

Abstract:

    Domain Name System (DNS) Server

    Socket related definitions.

Author:

    Jim Gilroy (jamesg)     June 20, 1995

Revision History:

--*/


#ifndef _DNS_SOCKET_INCLUDED_
#define _DNS_SOCKET_INCLUDED_


//
//  Server name in DBASE format
//

extern  DB_NAME  g_ServerDbaseName;

//
//  UDP completion port
//

extern  HANDLE  g_hUdpCompletionPort;

//
//  Socket globals
//

#define DNS_INVALID_SOCKET      (0)
//  #define DNS_INVALID_IP          ((IP_ADDRESS)(-1))

extern  PDNS_ADDR_ARRAY         g_ServerIp4Addrs;
extern  PDNS_ADDR_ARRAY         g_ServerIp6Addrs;
extern  PDNS_ADDR_ARRAY         g_BoundAddrs;

extern  FD_SET                  g_fdsListenTcp;

extern  SOCKET                  g_UdpSendSocket;

extern  WORD                    g_SendBindingPort;

//  TCP select wakeup to allow server to add connections it initiates
//      to select() FD_SET

extern  SOCKET                  g_TcpSelectWakeupSocket;
extern  BOOL                    g_bTcpSelectWoken;


//
//  TCP client connection
//

typedef VOID (* CONNECT_CALLBACK)( PDNS_MSGINFO, BOOL );

//
//  Socket list
//
//  Keep list of ALL active sockets, so we can cleanly insure that
//  they are all closed on shutdown.
//
//  I/O completion returns ptr to context.
//      - MUST include the Overlapped struct as it must stay valid
//      during i/o operation
//      - include WsaBuf, Flags, BytesRecv since they are all dropped
//      down with WSARecvFrom and thus properly should be associated
//      with the socket and not on the thread's stack
//
//  Easiest approach was to combine the i/o completion context with
//  this other socket information.  Cleanup is easier when sockets
//  added and deleted.  Also leverages socket list, to search through
//  and restart recv() when get a recv() failure.
//

#define LOCK_DNS_SOCKET_INFO(_p)    EnterCriticalSection(&(_p)->LockCs)
#define UNLOCK_DNS_SOCKET_INFO(_p)  LeaveCriticalSection(&(_p)->LockCs)

typedef struct _OvlArray {

    UINT          Index;
    OVERLAPPED    Overlapped;
    PDNS_MSGINFO  pMsg;
    WSABUF        WsaBuf;

} OVL, *POVL;

typedef struct _DnsSocket
{
    LIST_ENTRY      List;
    SOCKET          Socket;
    HANDLE          hPort;

    DNS_ADDR        ipAddr;
    INT             SockType;

    BOOL            fListen;

    DWORD           State;
    BOOLEAN         fRecvPending;
    BOOLEAN         fRetry;
    BOOLEAN         fPad1;
    BOOLEAN         fPad2;

    CRITICAL_SECTION LockCs;

    //  recv context

    DWORD           BytesRecvd;
    DWORD           RecvfromFlags;

    //  TCP connection context

    CONNECT_CALLBACK pCallback;         //  callback on connection failure
    DWORD           dwTimeout;          //  timeout until connection closed
    DNS_ADDR        ipRemote;
    PDNS_MSGINFO    pMsg;

    // UDP connection
    POVL            OvlArray;

}
DNS_SOCKET, *PDNS_SOCKET;


//
//  Socket context states
//

#define SOCKSTATE_UDP_RECV_DOWN         (1)
#define SOCKSTATE_UDP_COMPLETED         (2)
#define SOCKSTATE_UDP_RECV_ERROR        (3)
#define SOCKSTATE_UDP_GQCS_ERROR        (4)

#define SOCKSTATE_TCP_LISTEN            (16)
#define SOCKSTATE_TCP_ACCEPTING         (17)
#define SOCKSTATE_TCP_RECV_DOWN         (18)
#define SOCKSTATE_TCP_RECV_INDICATED    (19)
#define SOCKSTATE_TCP_RECV_FIN          (20)

#define SOCKSTATE_TCP_CONNECT_ATTEMPT   (32)
#define SOCKSTATE_TCP_CONNECT_COMPLETE  (33)
#define SOCKSTATE_TCP_CONNECT_FAILURE   (34)

#define SOCKSTATE_DEAD                  (0xffffffff)

//
//  Flag to indicate need to retry receives on UDP sockets
//

extern  BOOL    g_fUdpSocketsDirty;

//
//  Wrap UDP check and retry in macro
//  This takes away unnecessary function call in the 99.999% case
//

#define UDP_RECEIVE_CHECK() \
            if ( SrvCfg_dwQuietRecvLogInterval ) \
            {                           \
                Udp_RecvCheck();        \
            }                           \
            if ( g_fUdpSocketsDirty )   \
            {                           \
                Sock_StartReceiveOnUdpSockets(); \
            }

//
//  Select wakeup socket
//      -- needed by tcpsrv, to avoid attempting recv() from socket
//

extern SOCKET  socketTcpSelectWakeup;

extern BOOL    gbTcpSelectWoken;

//
//  Connect attempt (to remote DNS)
//

#define DNS_TCP_CONNECT_ATTEMPT_TIMEOUT (5)     // 5 seconds


//
//  Net order loopback address
//

#define NET_ORDER_LOOPBACK      (0x0100007f)


//
//  Need open individual listen sockets on each bound IP address?
//  If FALSE, need to listen on single INADDR_ANY UDP socket instead.
//  This catches the disjoint net scenario when we are sending on
//  port 53 and the server is listening only on a subset of available
//  IP addresses.
//

#define DNS_OPEN_INDIVIDUAL_LISTEN_SOCKETS()                        \
    ( SrvCfg_dwSendPort == DNS_PORT_HOST_ORDER                      \
        && g_BoundAddrs                                             \
        && g_ServerIp4Addrs                                         \
        && g_BoundAddrs->AddrCount != g_ServerIp4Addrs->AddrCount )


//
//  TCP connection list (tcpcon.c)
//

BOOL
Tcp_ConnectionListFdSet(
    IN OUT  fd_set *        pReadFdSet,
    IN OUT  fd_set *        pWriteFdSet,
    IN OUT  fd_set *        pExceptFdSet,
    IN      DWORD           dwLastSelectTime
    );

BOOL
Tcp_ConnectionCreate(
    IN      SOCKET              Socket,
    IN      CONNECT_CALLBACK    pCallbackFunction,
    IN OUT  PDNS_MSGINFO        pMsg        OPTIONAL
    );

VOID
Tcp_ConnectionListReread(
    VOID
    );

BOOL
Tcp_ConnectionCreateForRecursion(
    IN      PDNS_MSGINFO    pRecurseMsg,
    IN      SOCKET          Socket
    );

VOID
Tcp_ConnectionDeleteForSocket(
    IN      SOCKET          Socket,
    IN      PDNS_MSGINFO    pMsg        OPTIONAL
    );

PDNS_SOCKET
Tcp_ConnectionFindForSocket(
    IN      SOCKET          Socket
    );

PDNS_MSGINFO
Tcp_ConnectionMessageFindOrCreate(
    IN      SOCKET          Socket
    );

VOID
Tcp_ConnectionUpdateTimeout(
    IN      SOCKET          Socket
    );

VOID
Tcp_ConnectionUpdateForCompleteMessage(
    IN      PDNS_MSGINFO    pMsg
    );

VOID
Tcp_ConnectionUpdateForPartialMessage(
    IN      PDNS_MSGINFO    pMsg
    );

BOOL
Tcp_ConnectionListInitialize(
    VOID
    );

VOID
Tcp_ConnectionListShutdown(
    VOID
    );

VOID
Tcp_CloseAllConnectionSockets(
    VOID
    );


//
//  TCP Forwarding\Recursion
//

BOOL
Tcp_ConnectForForwarding(
    IN OUT  PDNS_MSGINFO        pMsg,
    IN      PDNS_ADDR           pDnsAddr,
    IN      CONNECT_CALLBACK    ConnectFailureCallback
    );

VOID
Tcp_ConnectionCompletion(
    IN      SOCKET          Socket
    );

VOID
Tcp_CleanupFailedConnectAttempt(
    IN      SOCKET          Socket
    );


#endif // _TCPCON_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\srvcfg.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    srvcfg.c

Abstract:

    Domain Name System (DNS) Server

    Server configuration.

Author:

    Jim Gilroy (jamesg)     October, 1995

Revision History:

--*/


#include "dnssrv.h"

#include "ntverp.h"


//
//  Server configuration global
//

DNS_SERVER_INFO     SrvInfo;

//
//  Server versions
//

#if 1

#define DNSSRV_MAJOR_VERSION    VER_PRODUCTMAJORVERSION
#define DNSSRV_MINOR_VERSION    VER_PRODUCTMINORVERSION

#define DNSSRV_SP_VERSION       VER_PRODUCTBUILD

#else

#define DNSSRV_MAJOR_VERSION    (5)         //  NT 5 (Windows 2000, Whistler)
#define DNSSRV_MINOR_VERSION    (1)         //  .0 is Windows 2000, .1 is Whistler

#define DNSSRV_SP_VERSION       (2246)      //  use build number for now
//#define DNSSRV_SP_VERSION       (0x0)      //  FINAL

#endif


//
//  Private server configuration (not in dnsrpc.h)
//

#define DNS_REGKEY_REMOTE_DS                ("RemoteDs")

#define DNS_REGKEY_PREVIOUS_SERVER_NAME     "PreviousLocalHostname"
#define DNS_REGKEY_PREVIOUS_SERVER_NAME_PRIVATE \
        (LPSTR)TEXT(DNS_REGKEY_PREVIOUS_SERVER_NAME)

#define DNS_REGKEY_FORCE_SOA_SERIAL         ("ForceSoaSerial")
#define DNS_REGKEY_FORCE_SOA_MINIMUM_TTL    ("ForceSoaMinimumTtl")
#define DNS_REGKEY_FORCE_SOA_REFRESH        ("ForceSoaRefresh")
#define DNS_REGKEY_FORCE_SOA_RETRY          ("ForceSoaRetry")
#define DNS_REGKEY_FORCE_SOA_EXPIRE         ("ForceSoaExpire")
#define DNS_REGKEY_FORCE_NS_TTL             ("ForceNsTtl")
#define DNS_REGKEY_FORCE_TTL                ("ForceTtl")

//
//  EDNS
//

#define DNS_REGKEY_ENABLE_EDNS_RECEPTION    ("EnableEDnsReception")

#define DNS_REGKEY_RELOAD_EXCEPTION         ("ReloadException")
#define DNS_REGKEY_SYNC_DS_ZONE_SERIAL      ("SyncDsZoneSerial")

//  Address answer limit (for protecting against WIN95 resolver bug)
//  is constrained to reasonable range

#define MIN_ADDRESS_ANSWER_LIMIT    (5)
#define MAX_ADDRESS_ANSWER_LIMIT    (28)

//  Max UDP Packet size - must be between RFC minimum and "sane" maximum

#define MIN_UDP_PACKET_SIZE         (DNS_RFC_MAX_UDP_PACKET_LENGTH)
#define MAX_UDP_PACKET_SIZE         (16384)

#define MIN_EDNS_CACHE_TIMEOUT      (60*60)         // one hour
#define MAX_EDNS_CACHE_TIMEOUT      (60*60*24*182)  // 6 months (182 days)

//  Recursion timeout
//  Must be limited to reasonable values for proper recursion functioning

#define MAX_RECURSION_TIMEOUT       (120)       // max two minutes
#define MIN_RECURSION_TIMEOUT       (3)         // min three seconds

//  Cache control - sizes in kilobytes

#define MIN_MAX_CACHE_SIZE          (500)       //  min value for MaxCacheSize

//  Reloading exceptions
//  By default reload retail, but let debug crash

#if DBG
#define DNS_DEFAULT_RELOAD_EXCEPTION    (0)
#else
#define DNS_DEFAULT_RELOAD_EXCEPTION    (1)
#endif


//
//  For specialized property management functions,
//  these flags indicate no need to write property or
//  save it to registry.
//

#define PROPERTY_NOWRITE            (0x00000001)
#define PROPERTY_NOSAVE             (0x00000002)
#define PROPERTY_FORCEWRITE         (0x00000004)
#define PROPERTY_UPDATE_BOOTFILE    (0x00000008)
#define PROPERTY_NODEFAULT          (0x00000010)

#define PROPERTY_ERROR              (0x80000000)


//
//  Special property management functions
//

typedef DNS_STATUS (* DWORD_PROPERTY_SET_FUNCTION) (
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetEnableRegistryBoot(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetBootMethod(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetAddressAnswerLimit(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetLogFilePath(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetLogLevel(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetLogIPFilterList(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetBreakOnUpdateFromList(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetServerLevelPlugin(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetBreakOnRecvFromList(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetMaxUdpPacketSize(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetTcpRecvPacketSize(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetEDnsCacheTimeout(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetMaxCacheSize(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetRecursionTimeout(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetAdditionalRecursionTimeout(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

#if DBG
DNS_STATUS
cfg_SetDebugLevel(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );
#else
#define cfg_SetDebugLevel     NULL
#endif

DNS_STATUS
cfg_SetNoRecursion(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetScavengingInterval(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetDoNotRoundRobinTypes(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetForestDpBaseName(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetDomainDpBaseName(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

//
//  Server properties
//
//  Server properties are accessed through this table.
//  The name is used for remote access and is the name of the regvalue
//  storing the property.  All these registry values are attempted to be
//  loaded on boot.
//
//  For DWORD properties, the table also gives pointer into the SrvCfg
//  structure for the property and a default value that is used when
//  -- as is usually the case -- the property is NOT found in the registry.
//

typedef struct _ServerProperty
{
    LPSTR                           pszPropertyName;
    PDWORD                          pDword;
    DWORD                           dwDefault;
    DWORD_PROPERTY_SET_FUNCTION     pFunction;
}
SERVER_PROPERTY;

SERVER_PROPERTY ServerPropertyTable[] =
{
    DNS_REGKEY_BOOT_REGISTRY                        ,
        &SrvCfg_fEnableRegistryBoot                 ,
            DNS_FRESH_INSTALL_BOOT_REGISTRY_FLAG    ,
                cfg_SetEnableRegistryBoot           ,

    DNS_REGKEY_BOOT_METHOD                          ,
        &SrvCfg_fBootMethod                         ,
            BOOT_METHOD_UNINITIALIZED               ,
                cfg_SetBootMethod                   ,

    DNS_REGKEY_ADMIN_CONFIGURED                     ,
        &SrvCfg_fAdminConfigured                    ,
            0                                       ,
                NULL                                ,

    DNS_REGKEY_RELOAD_EXCEPTION                     ,
        &SrvCfg_bReloadException                    ,
            DNS_DEFAULT_RELOAD_EXCEPTION            ,
                NULL                                ,

    DNS_REGKEY_RPC_PROTOCOL                         ,
        &SrvCfg_dwRpcProtocol                       ,
            DNS_DEFAULT_RPC_PROTOCOL                ,
                NULL                                ,

    DNS_REGKEY_ENABLE_ADVDB_LOCKING                 ,
        &SrvCfg_dwEnableAdvancedDatabaseLocking     ,
            DNS_DEFAULT_DB_LOCKING                  ,
                NULL                                ,
                
    //  Addressing \ Connection

    DNS_REGKEY_LISTEN_ADDRESSES                     ,
        NULL                                        ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_SEND_PORT                            ,
        &SrvCfg_dwSendPort                          ,
            DNS_DEFAULT_SEND_PORT                   ,
                NULL                                ,
    DNS_REGKEY_DISJOINT_NETS                        ,
        &SrvCfg_fDisjointNets                       ,
            DNS_DEFAULT_DISJOINT_NETS               ,
                NULL                                ,
    DNS_REGKEY_NO_TCP                               ,
        &SrvCfg_fNoTcp                              ,
            DNS_DEFAULT_NO_TCP                      ,
                NULL                                ,
    DNS_REGKEY_XFR_CONNECT_TIMEOUT                  ,
        &SrvCfg_dwXfrConnectTimeout                 ,
            DNS_DEFAULT_XFR_CONNECT_TIMEOUT         ,
                NULL                                ,
#if 0
    DNS_REGKEY_LISTEN_ON_AUTONET                    ,
        &SrvCfg_fListenOnAutonet                    ,
            DNS_DEFAULT_LISTEN_ON_AUTONET           ,
                NULL                                ,
#endif

    //  Logging

    DNS_REGKEY_EVENTLOG_LEVEL                       ,
        &SrvCfg_dwEventLogLevel                     ,
           DNS_DEFAULT_EVENTLOG_LEVEL               ,
                NULL                                ,
    DNS_REGKEY_USE_SYSTEM_EVENTLOG                  ,
        &SrvCfg_dwUseSystemEventLog                 ,
           DNS_DEFAULT_USE_SYSTEM_EVENTLOG          ,
                NULL                                ,
    DNS_REGKEY_LOG_LEVEL                            ,
        &SrvCfg_dwLogLevel                          ,
           DNS_DEFAULT_LOG_LEVEL                    ,
                cfg_SetLogLevel                     ,
    DNS_REGKEY_OPS_LOG_LEVEL1                       ,
        &SrvCfg_dwOperationsLogLevel_LowDword       ,
           DNS_DEFAULT_LOG_LEVEL                    ,
                NULL                                ,
    DNS_REGKEY_OPS_LOG_LEVEL2                       ,
        &SrvCfg_dwOperationsLogLevel_HighDword      ,
           DNS_DEFAULT_LOG_LEVEL                    ,
                NULL                                ,
    DNS_REGKEY_LOG_FILE_MAX_SIZE                    ,
        &SrvCfg_dwLogFileMaxSize                    ,
           DNS_DEFAULT_LOG_FILE_MAX_SIZE            ,
                NULL                                ,
    DNS_REGKEY_LOG_FILE_PATH                        ,
        NULL                                        ,
            0                                       ,
                cfg_SetLogFilePath                  ,
    DNS_REGKEY_LOG_IP_FILTER_LIST                   ,
        NULL                                        ,
            0                                       ,
                cfg_SetLogIPFilterList              ,
    DNS_REGKEY_DEBUG_LEVEL                          ,
        &SrvCfg_dwDebugLevel                        ,
            DNS_DEFAULT_DEBUG_LEVEL                 ,
                cfg_SetDebugLevel                   ,
    DNS_REGKEY_EVENT_CONTROL                        ,
        &SrvCfg_dwEventControl                      ,
            0                                       ,
                NULL                                ,


    //  Recursion \ forwarding

#if 0
    DNS_REGKEY_RECURSION                            ,
        &SrvCfg_fRecursion                          ,
            DNS_DEFAULT_RECURSION                   ,
                NULL                                ,
#endif
    DNS_REGKEY_NO_RECURSION                         ,
        &SrvCfg_fNoRecursion                        ,
            DNS_DEFAULT_NO_RECURSION                ,
                cfg_SetNoRecursion                  ,
    DNS_REGKEY_RECURSE_SINGLE_LABEL                 ,
        &SrvCfg_fRecurseSingleLabel                 ,
            DNS_DEFAULT_RECURSE_SINGLE_LABEL        ,
                NULL                                ,
    DNS_REGKEY_MAX_CACHE_TTL                        ,
        &SrvCfg_dwMaxCacheTtl                       ,
            DNS_DEFAULT_MAX_CACHE_TTL               ,
                NULL                                ,
    DNS_REGKEY_MAX_NEGATIVE_CACHE_TTL               ,
        &SrvCfg_dwMaxNegativeCacheTtl               ,
            DNS_DEFAULT_MAX_NEGATIVE_CACHE_TTL      ,
                NULL                                ,
    DNS_REGKEY_LAME_DELEGATION_TTL                  ,
        &SrvCfg_dwLameDelegationTtl                 ,
            DNS_DEFAULT_LAME_DELEGATION_TTL         ,
                NULL                                ,
    DNS_REGKEY_SECURE_RESPONSES                     ,
        &SrvCfg_fSecureResponses                    ,
            DNS_DEFAULT_SECURE_RESPONSES            ,
                NULL                                ,
    DNS_REGKEY_RECURSION_RETRY                      ,
        &SrvCfg_dwRecursionRetry                    ,
            DNS_DEFAULT_RECURSION_RETRY             ,
                NULL                                ,
    DNS_REGKEY_RECURSION_TIMEOUT                    ,
        &SrvCfg_dwRecursionTimeout                  ,
            DNS_DEFAULT_RECURSION_TIMEOUT           ,
                cfg_SetRecursionTimeout             ,
    DNS_REGKEY_ADDITIONAL_RECURSION_TIMEOUT         ,
        &SrvCfg_dwAdditionalRecursionTimeout        ,
            DNS_DEFAULT_ADDITIONAL_RECURSION_TIMEOUT,
                cfg_SetAdditionalRecursionTimeout   ,
    DNS_REGKEY_FORWARDERS                           ,
        NULL                                        ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORWARD_TIMEOUT                      ,
        &SrvCfg_dwForwardTimeout                    ,
            DNS_DEFAULT_FORWARD_TIMEOUT             ,
                NULL                                ,
    DNS_REGKEY_SLAVE                                ,
        &SrvCfg_fSlave                              ,
            DNS_DEFAULT_SLAVE                       ,
                NULL                                ,
    DNS_REGKEY_FORWARD_DELEGATIONS                  ,
        &SrvCfg_fForwardDelegations                 ,
            DNS_DEFAULT_FORWARD_DELEGATIONS         ,
                NULL                                ,
    DNS_REGKEY_INET_RECURSE_TO_ROOT_MASK            ,
        &SrvCfg_dwRecurseToInetRootMask             ,
            DNS_DEFAULT_INET_RECURSE_TO_ROOT_MASK   ,
                NULL                                ,
    DNS_REGKEY_AUTO_CREATE_DELEGATIONS              ,
        &SrvCfg_dwAutoCreateDelegations             ,
            DNS_DEFAULT_AUTO_CREATION_DELEGATIONS   ,
                NULL                                ,
    DNS_REGKEY_ALLOW_CNAME_AT_NS                    ,
        &SrvCfg_dwAllowCNAMEAtNS                    ,
            DNS_DEFAULT_ALLOW_CNAME_AT_NS           ,
                NULL                                ,

    //  Question\response config

    DNS_REGKEY_ROUND_ROBIN                          ,
        &SrvCfg_fRoundRobin                         ,
            DNS_DEFAULT_ROUND_ROBIN                 ,
                NULL                                ,
    DNS_REGKEY_LOCAL_NET_PRIORITY                   ,
        &SrvCfg_fLocalNetPriority                   ,
            DNS_DEFAULT_LOCAL_NET_PRIORITY          ,
                NULL                                ,
    DNS_REGKEY_LOCAL_NET_PRIORITY_NETMASK           ,
        &SrvCfg_dwLocalNetPriorityNetMask           ,
            DNS_DEFAULT_LOCAL_NET_PRIORITY_NETMASK  ,
                NULL                                ,
    DNS_REGKEY_ADDRESS_ANSWER_LIMIT                 ,
        &SrvCfg_cAddressAnswerLimit                 ,
            DNS_DEFAULT_ADDRESS_ANSWER_LIMIT        ,
                cfg_SetAddressAnswerLimit           ,

    DNS_REGKEY_NAME_CHECK_FLAG                      ,
        &SrvCfg_dwNameCheckFlag                     ,
            DNS_DEFAULT_NAME_CHECK_FLAG             ,
                NULL                                ,
#if 0
    //  may want to just ALWAYS do this
    DNS_REGKEY_CASE_PRESERVATION                    ,
        &SrvCfg_fCasePreservation                   ,
            DNS_DEFAULT_CASE_PRESERVATION           ,
                NULL                                ,
#endif

    DNS_REGKEY_WRITE_AUTHORITY_NS                   ,
        &SrvCfg_fWriteAuthorityNs                   ,
            DNS_DEFAULT_WRITE_AUTHORITY_NS          ,
                NULL                                ,

    DNS_REGKEY_LOOSE_WILDCARDING                    ,
        &SrvCfg_fLooseWildcarding                   ,
            DNS_DEFAULT_LOOSE_WILDCARDING           ,
                NULL                                ,
    DNS_REGKEY_BIND_SECONDARIES                     ,
        &SrvCfg_fBindSecondaries                    ,
            DNS_DEFAULT_BIND_SECONDARIES            ,
                NULL                                ,

    DNS_REGKEY_APPEND_MS_XFR_TAG                    ,
        &SrvCfg_fAppendMsTagToXfr                   ,
            DNS_DEFAULT_APPEND_MS_XFR_TAG           ,
                NULL                                ,

    //
    //  Update, DS, autoconfig management
    //

    DNS_REGKEY_ALLOW_UPDATE                         ,
        &SrvCfg_fAllowUpdate                        ,
            DNS_DEFAULT_ALLOW_UPDATE                ,
                NULL                                ,

//  DEVNOTE:  better to have update property flag
//      perhaps just AllowUpdate gets are range of values
//      record types, delegations, zone root

    DNS_REGKEY_NO_UPDATE_DELEGATIONS                ,
        &SrvCfg_fNoUpdateDelegations                ,
            DNS_DEFAULT_NO_UPDATE_DELEGATIONS       ,
                NULL                                ,
    DNS_REGKEY_UPDATE_OPTIONS                       ,
        &SrvCfg_dwUpdateOptions                     ,
            DNS_DEFAULT_UPDATE_OPTIONS              ,
                NULL                                ,
    DNS_REGKEY_ENABLE_UPDATE_FORWARDING             ,
        &SrvCfg_dwEnableUpdateForwarding            ,
            DNS_DEFAULT_ENABLE_UPDATE_FORWARDING    ,
                NULL                                ,
    DNS_REGKEY_MAX_RRS_IN_NONSECURE_UPDATE          ,
        &SrvCfg_dwMaxRRsInNonSecureUpdate           ,
            DNS_DEFAULT_MAX_RRS_IN_NONSECURE_UPDATE ,
                NULL                                ,

    DNS_REGKEY_ENABLE_WINSR                         ,
        &SrvCfg_dwEnableWinsR                       ,
            DNS_DEFAULT_ENABLE_WINSR                ,
                NULL                                ,

    DNS_REGKEY_REMOTE_DS                            ,
        &SrvCfg_fRemoteDs                           ,
            0                                       ,
                NULL                                ,

    //  Auto config

    DNS_REGKEY_AUTO_CONFIG_FILE_ZONES               ,
        &SrvCfg_fAutoConfigFileZones                ,
            DNS_DEFAULT_AUTO_CONFIG_FILE_ZONES      ,
                NULL                                ,
    DNS_REGKEY_PUBLISH_AUTONET                      ,
        &SrvCfg_fPublishAutonet                     ,
            DNS_DEFAULT_PUBLISH_AUTONET             ,
                NULL                                ,
    DNS_REGKEY_NO_AUTO_REVERSE_ZONES                ,
        &SrvCfg_fNoAutoReverseZones                 ,
            DNS_DEFAULT_NO_AUTO_REVERSE_ZONES       ,
                NULL                                ,
    DNS_REGKEY_AUTO_CACHE_UPDATE                    ,
        &SrvCfg_fAutoCacheUpdate                    ,
            DNS_DEFAULT_AUTO_CACHE_UPDATE           ,
                NULL                                ,
    DNS_REGKEY_DISABLE_AUTONS                       ,
        &SrvCfg_fNoAutoNSRecords                    ,
            DNS_DEFAULT_DISABLE_AUTO_NS_RECORDS     ,
                NULL                                ,

    //  Data integrity

    DNS_REGKEY_STRICT_FILE_PARSING                  ,
        &SrvCfg_fStrictFileParsing                  ,
            DNS_DEFAULT_STRICT_FILE_PARSING         ,
                NULL                                ,
    DNS_REGKEY_DELETE_OUTSIDE_GLUE                  ,
        &SrvCfg_fDeleteOutsideGlue                  ,
            DNS_DEFAULT_DELETE_OUTSIDE_GLUE         ,
                NULL                                ,

    //  DS config

    DNS_REGKEY_DS_POLLING_INTERVAL                  ,
        &SrvCfg_dwDsPollingInterval                 ,
            DNS_DEFAULT_DS_POLLING_INTERVAL         ,
                NULL                                ,
    DNS_REGKEY_DS_TOMBSTONE_INTERVAL                ,
        &SrvCfg_dwDsTombstoneInterval               ,
            DNS_DEFAULT_DS_TOMBSTONE_INTERVAL       ,
                NULL                                ,
    DNS_REGKEY_SYNC_DS_ZONE_SERIAL                  ,
        &SrvCfg_dwSyncDsZoneSerial                  ,
            DNS_DEFAULT_SYNC_DS_ZONE_SERIAL         ,
                NULL                                ,
    DNS_REGKEY_DS_LAZY_UPDATE_INTERVAL              ,
        &SrvCfg_dwDsLazyUpdateInterval              ,
            DNS_DEFAULT_DS_LAZY_UPDATE_INTERVAL     ,
                NULL                                ,

    "ForceForestBehaviorVersion"                    ,
        &SrvCfg_dwForceForestBehaviorVersion        ,
            DNS_INVALID_BEHAVIOR_VERSION            ,
                NULL                                ,
    "ForceDomainBehaviorVersion"                    ,
        &SrvCfg_dwForceDomainBehaviorVersion        ,
            DNS_INVALID_BEHAVIOR_VERSION            ,
                NULL                                ,
    "ForceDsaBehaviorVersion"                       ,
        &SrvCfg_dwForceDsaBehaviorVersion           ,
            DNS_INVALID_BEHAVIOR_VERSION            ,
                NULL                                ,

    //  Aging \ Scavenging

    DNS_REGKEY_SCAVENGING_INTERVAL                  ,
        &SrvCfg_dwScavengingInterval                ,
            DNS_DEFAULT_SCAVENGING_INTERVAL         ,
                cfg_SetScavengingInterval           ,
    DNS_REGKEY_DEFAULT_AGING_STATE                  ,
        &SrvCfg_fDefaultAgingState                  ,
            DNS_DEFAULT_AGING_STATE                 ,
                NULL                                ,
    DNS_REGKEY_DEFAULT_REFRESH_INTERVAL             ,
        &SrvCfg_dwDefaultRefreshInterval            ,
            DNS_DEFAULT_REFRESH_INTERVAL            ,
                NULL                                ,
    DNS_REGKEY_DEFAULT_NOREFRESH_INTERVAL           ,
        &SrvCfg_dwDefaultNoRefreshInterval          ,
            DNS_DEFAULT_NOREFRESH_INTERVAL          ,
                NULL                                ,

    //  Cache control

    DNS_REGKEY_MAX_CACHE_SIZE                       ,
        &SrvCfg_dwMaxCacheSize                      ,
            DNS_SERVER_UNLIMITED_CACHE_SIZE         ,
                cfg_SetMaxCacheSize                 ,
    DNS_REGKEY_CACHE_EMPTY_AUTH_RESPONSES           ,
        &SrvCfg_dwCacheEmptyAuthResponses           ,
            TRUE                                    ,
                NULL                                ,

    //  SOA overrides

    DNS_REGKEY_FORCE_SOA_SERIAL                     ,
        &SrvCfg_dwForceSoaSerial                    ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORCE_SOA_MINIMUM_TTL                ,
        &SrvCfg_dwForceSoaMinimumTtl                ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORCE_SOA_REFRESH                    ,
        &SrvCfg_dwForceSoaRefresh                   ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORCE_SOA_RETRY                      ,
        &SrvCfg_dwForceSoaRetry                     ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORCE_SOA_EXPIRE                     ,
        &SrvCfg_dwForceSoaExpire                    ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORCE_NS_TTL                         ,
        &SrvCfg_dwForceNsTtl                        ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORCE_TTL                            ,
        &SrvCfg_dwForceTtl                          ,
            0                                       ,
                NULL                                ,

    DNS_REGKEY_TCP_RECV_PACKET_SIZE                 ,
        &SrvCfg_dwTcpRecvPacketSize                 ,
            DNS_DEFAULT_TCP_RECEIVE_PACKET_SIZE     ,
                cfg_SetTcpRecvPacketSize            ,

    //  EDNS

    DNS_REGKEY_MAX_UDP_PACKET_SIZE                  ,
        &SrvCfg_dwMaxUdpPacketSize                  ,
            1280                                    ,   //  DNS_RFC_MAX_UDP_PACKET_LENGTH
                cfg_SetMaxUdpPacketSize             ,
    DNS_REGKEY_ENABLE_EDNS_RECEPTION                ,
        &SrvCfg_dwEnableEDnsReception               ,
            1                                       ,
                NULL                                ,
    DNS_REGKEY_ENABLE_EDNS                          ,
        &SrvCfg_dwEnableEDnsProbes                  ,
            1                                       ,
                NULL                                ,
    DNS_REGKEY_EDNS_CACHE_TIMEOUT                   ,
        &SrvCfg_dwEDnsCacheTimeout                  ,
            (24*60*60) /* one day */                ,
                cfg_SetEDnsCacheTimeout             ,

    //  DNSSEC

    DNS_REGKEY_ENABLE_DNSSEC                        ,
        &SrvCfg_dwEnableDnsSec                      ,
            DNS_DNSSEC_ENABLE_DEFAULT               ,
                NULL                                ,

    DNS_REGKEY_ENABLE_SENDERR_SUPPRESSION           ,
        &SrvCfg_dwEnableSendErrSuppression          ,
            1                                       ,
                NULL                                ,

    //  Random flags

    DNS_REGKEY_ENABLE_FAKEIQUERY                    ,
        &SrvCfg_dwEnableFakeIQuery                  ,
            0                                       ,
                NULL                                ,

    "HeapDebug"                                     ,
        &SrvCfg_dwHeapDebug                         ,
            0                                       ,
                NULL                                ,

    //  Test flags

    DNS_REGKEY_TEST1                                ,
        &SrvCfg_fTest1                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST2                                ,
        &SrvCfg_fTest2                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST3                                ,
        &SrvCfg_fTest3                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST4                                ,
        &SrvCfg_fTest4                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST5                                ,
        &SrvCfg_fTest5                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST6                                ,
        &SrvCfg_fTest6                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST7                                ,
        &SrvCfg_fTest7                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST8                                ,
        &SrvCfg_fTest8                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST9                                ,
        &SrvCfg_fTest9                              ,
            0                                       ,
                NULL                                ,

    //  Fixed test flags

    DNS_REGKEY_QUIET_RECV_LOG_INTERVAL              ,
        &SrvCfg_dwQuietRecvLogInterval              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_QUIET_RECV_FAULT_INTERVAL            ,
        &SrvCfg_dwQuietRecvFaultInterval            ,
            0                                       ,
                NULL                                ,

    //  Round robin

    DNS_REGKEY_NO_ROUND_ROBIN                       ,
        NULL                                        ,
            0                                       ,
                NULL                                ,

    //  Zone transfers

    DNS_REGKEY_XFR_THROTTLE_MULTIPLIER              ,
        &SrvCfg_dwXfrThrottleMultiplier             ,
            DNS_DEFAULT_XFR_THROTTLE_MULTIPLIER     ,
                NULL                                ,

    //  Directory partition support

    DNS_REGKEY_ENABLE_DP                            ,
        &SrvCfg_dwEnableDp                          ,
            1                                       ,
                NULL                                ,
    DNS_REGKEY_FOREST_DP_BASE_NAME                  ,
        NULL                                        ,
            0                                       ,
                cfg_SetForestDpBaseName             ,
    DNS_REGKEY_DOMAIN_DP_BASE_NAME                  ,
        NULL                                        ,
            0                                       ,
                cfg_SetDomainDpBaseName             ,
    DNS_REGKEY_DP_ENLIST_INTERVAL                   ,
        &SrvCfg_dwDpEnlistInterval                  ,
            DNS_DEFAULT_DP_ENLIST_INTERVAL          ,
                NULL                                ,

    DNS_REGKEY_SILENT_IGNORE_CNAME_UPDATE_CONFLICT  ,
        &SrvCfg_fSilentlyIgnoreCNameUpdateConflict  ,
            0                                       ,
                NULL                                ,

    //  Self diagnosis
    
    DNS_REGKEY_SELFTEST                             ,
        &SrvCfg_dwSelfTestFlag                      ,
            DNS_SELFTEST_DEFAULT                    ,
                NULL                                ,

    //  IPv6 support
    
    DNS_REGKEY_ENABLEIPV6                           ,
        &SrvCfg_dwEnableIPv6                        ,
            FALSE                                   ,
                NULL                                ,

    //  Debugging

    DNS_REGKEY_BREAK_ON_ASC_FAILURE                 ,
        &SrvCfg_dwBreakOnAscFailure                 ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_BREAK_ON_UPDATE_FROM                 ,
        NULL                                        ,
            0                                       ,
                cfg_SetBreakOnUpdateFromList        ,
    DNS_REGKEY_BREAK_ON_RECV_FROM                   ,
        NULL                                        ,
            0                                       ,
                cfg_SetBreakOnRecvFromList          ,
    DNS_REGKEY_IGNORE_RPC_ACCESS_FAILURES           ,
        &SrvCfg_dwIgnoreRpcAccessFailures           ,
            0                                       ,
                NULL                                ,
    
    //  Plugin

    DNS_REGKEY_SERVER_PLUGIN                        ,
        NULL                                        ,
            0                                       ,
                cfg_SetServerLevelPlugin            ,

    NULL, NULL, 0, NULL
};

//
//  Value to indicate property not in table or index not in table.
//

#define BAD_PROPERTY_INDEX  ((DWORD)(-1))



DNS_STATUS
loadDwordPropertyByIndex(
    IN      DWORD           PropertyIndex,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Load DWORD server property from registry.

Arguments:

    PropertyIndex -- ID of server property

    Flag -- flags for function,
        PROPERTY_NODEFAULT  -- if do not want to write default of property

Return Value:

    ERROR_SUCCESS
    ErrorCode for registry failure.
    BAD_PROPERTY_INDEX to indicate index at end of property table.

--*/
{
    DWORD                           value;
    DWORD                           status;
    DWORD                           fread = FALSE;
    DWORD                           len = sizeof(DWORD);
    PDWORD                          pvalueProperty;
    LPSTR                           nameProperty;
    DWORD_PROPERTY_SET_FUNCTION     pfunction;
    DNS_PROPERTY_VALUE              dnsPropertyValue;


    //
    //  check for end of property list
    //

    nameProperty = ServerPropertyTable[ PropertyIndex ].pszPropertyName;
    if ( !nameProperty )
    {
        return BAD_PROPERTY_INDEX;
    }

    //
    //  verify valid DWORD server property
    //  and get pointer to DWORD property's position in SrvCfg block
    //

    pvalueProperty = ServerPropertyTable[ PropertyIndex ].pDword;
    if ( !pvalueProperty )
    {
        return ERROR_SUCCESS;
    }

    //
    //  read DWORD server property from registry
    //  or get default value from table
    //
    //  implementation note:
    //      could enum registry values, however would still need to
    //      write defaults, AND dispatch function calls where required
    //      (hence maintain info on whether value read) so considering
    //      this is only called on start, it's good
    //

    len = sizeof(DWORD);

    status = Reg_GetValue(
                NULL,
                NULL,
                nameProperty,
                REG_DWORD,
                (PBYTE) & value,
                &len );

    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "Opened <%s> key\n"
            "    value = %d\n",
            nameProperty,
            value ));
        fread = TRUE;
    }
    else
    {
        value = ServerPropertyTable[ PropertyIndex ].dwDefault;
        DNS_DEBUG( INIT, (
            "Defaulted server property <%s>\n"
            "    value = %d\n",
            nameProperty,
            value ));
    }

    //
    //  if NO default, then leave here when not read from registry
    //

    if ( !fread  &&  (Flag & PROPERTY_NODEFAULT) )
    {
        return ERROR_SUCCESS;
    }

    //
    //  special processing function for this property?
    //

    status = ERROR_SUCCESS;

    pfunction = ServerPropertyTable[ PropertyIndex ].pFunction;
    if ( pfunction )
    {
        dnsPropertyValue.dwPropertyType = REG_DWORD;
        dnsPropertyValue.dwValue = value;
        status = (*pfunction) (
                    &dnsPropertyValue,
                    PropertyIndex,
                    TRUE,               //  at server load
                    (BOOL)(fread) );    //  registry read?
        if ( status == PROPERTY_ERROR )
        {
            return GetLastError();
        }
    }

    //
    //  write property to server config block
    //  note:  we allow function to write itself or choose not to write
    //

    if ( !(status & PROPERTY_NOWRITE) )
    {
        *pvalueProperty = value;
    }

    //
    //  save property to registry, if function demands write back
    //

    if ( status & PROPERTY_FORCEWRITE )
    {
        status = Reg_SetDwordValue(
                    0,                      //  flags
                    NULL,
                    NULL,
                    nameProperty,
                    value );

        DNS_DEBUG( INIT, (
            "Writing server DWORD property <%s> to registry\n"
            "    value = %d\n"
            "    status = %p\n",
            nameProperty,
            value,
            status ));
        return status;
    }

    return ERROR_SUCCESS;
}



DWORD
findIndexForPropertyName(
    IN      LPSTR           pszName
    )
/*++

Routine Description:

    Retrieve index of server property desired.

Arguments:

    pszName - name property desired

Return Value:

    Index of property name.
    Otherwise BAD_PROPERTY_INDEX.

--*/
{
    INT     i = 0;
    PCHAR   propertyString;

    if ( !pszName || *pszName == '\0' )
    {
        return BAD_PROPERTY_INDEX;
    }

    //
    //  Check properties in table for name match
    //

    while ( propertyString = ServerPropertyTable[ i ].pszPropertyName )
    {
        if ( _stricmp( pszName, propertyString ) == 0 )
        {
            return i;
        }
        i++;
    }
    return BAD_PROPERTY_INDEX;
}



DNS_STATUS
loadDwordPropertyByName(
    IN      LPSTR           pszProperty,
    OUT     PDWORD          pdwPropertyValue
    )
/*++

Routine Description:

    Load DWORD server property from registry.

Arguments:

    pszProperty -- name of property

    pdwPropertyValue -- addr to receive DWORD value of property

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PROPERTY if not known DWORD property.

--*/
{
    DWORD       index;
    PDWORD      pvalue;
    DNS_STATUS  status;

    //  get index for property

    index = findIndexForPropertyName( pszProperty );
    if ( index == BAD_PROPERTY_INDEX )
    {
        return( DNS_ERROR_INVALID_PROPERTY );
    }

    //  verify DWORD property

    pvalue = ServerPropertyTable[index].pDword;
    if ( !pvalue )
    {
        return( DNS_ERROR_INVALID_PROPERTY );
    }

    //  load property

    status = loadDwordPropertyByIndex( index, 0 );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    //  return property value

    *pdwPropertyValue = *pvalue;

    return ERROR_SUCCESS;
}



DNS_STATUS
loadAllDwordProperties(
    IN      DWORD   Flag
    )
/*++

Routine Description:

    Load DWORD server property from registry.

Arguments:

    PropertyIndex -- ID of server property

    Flag -- flags for function,
        PROPERTY_NODEFAULT  -- if do not want to write default of property

Return Value:

    ERROR_SUCCESS
    ErrorCode for registry failure.
    BAD_PROPERTY_INDEX to indicate index at end of property table.

--*/
{
    DWORD       iprop = 0;
    DNS_STATUS  status = 0;

    while ( ServerPropertyTable[ iprop ].pszPropertyName )
    {
        status = loadDwordPropertyByIndex( iprop, Flag );
        
        //
        //  Backward compatibility hack. In .NET we do not allow setting
        //  of the LogLevel flag with a setting that would result in no
        //  logging. However W2K allowed this so after a W2K upgrade we
        //  have have a LogLevel value that is considered invalid for
        //  .NET. In this case, reset the LogLevel value.
        //
        
        if ( status != ERROR_SUCCESS &&
             strcmp( ServerPropertyTable[ iprop ].pszPropertyName,
                     DNS_REGKEY_LOG_LEVEL ) == 0 )
        {
            DNS_PROPERTY_VALUE prop = { REG_DWORD, 0 };

            status = Config_ResetProperty(
                        0,
                        DNS_REGKEY_LOG_LEVEL,
                        &prop );
        }
                
        if ( status != ERROR_SUCCESS )
        {
            PSTR    pargs[] =
            {
                ServerPropertyTable[ iprop ].pszPropertyName
            };

            DNS_LOG_EVENT_FLAGS(
                DNS_EVENT_INVALID_REGISTRY_VALUE,
                sizeof( pargs ) / sizeof( pargs[ 0 ] ),
                pargs,
                EVENTARG_ALL_UTF8,
                DNSEVENTLOG_FORCE_LOG_ALWAYS,
                status );
            break;
        }
        iprop++;
    }

    return status;
}



BOOL
Config_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize server configuration.

Arguments:

    None.

Return Value:

    TRUE if successful.
    FALSE if registry error.

--*/
{
    DWORD               iprop;
    DWORD               version;
    DNS_STATUS          status;
    PWSTR               pwsz;
    DNS_PROPERTY_VALUE  propValue;
    DWORD               index;

    //
    //  clear server configuration
    //

    RtlZeroMemory( &SrvInfo, sizeof( SrvInfo ) );

    UPDATE_DNS_TIME();      //  current time is a member of SrvInfo

    //
    //  Calculate the system boot time in CRT terms so we can convert
    //  DNS_TIME into CRT time. Note that the calculated boot time
    //  will be WRONG if the DNS server is restarted after the
    //  tick count has wrapped (at 49.7 days). But this is okay
    //  because the DNS_TIME will also be wrong so the time conversion
    //  will still work.
    //

    SrvInfo_crtSystemBootTime = time( NULL ) - DNS_TIME();

    //
    //  get DNS server version
    //      - SP version is high word
    //      - minor version is high byte of low word
    //      - major version is low byte of low word
    //

    version = DNSSRV_SP_VERSION;
    version <<= 8;
    version |= DNSSRV_MINOR_VERSION;
    version <<= 8;
    version |= DNSSRV_MAJOR_VERSION;
    SrvCfg_dwVersion = version;

    //  DS available on this box

    SrvCfg_fDsAvailable = Ds_IsDsServer();

    //
    //  read \ default DWORD server properties
    //

    g_bRegistryWriteBack = FALSE;
    if ( loadAllDwordProperties( 0 ) != ERROR_SUCCESS )
    {
        return FALSE;
    }
    g_bRegistryWriteBack = TRUE;

    //
    //  other server properties
    //      - listen addresses
    //      - publish addresses
    //      - forwarders
    //      - database directory
    //      - previous server name
    //      - log file name


    SrvCfg_aipListenAddrs = Reg_GetAddrArray(
                                NULL,
                                NULL,
                                DNS_REGKEY_LISTEN_ADDRESSES );

    SrvCfg_aipPublishAddrs = Reg_GetAddrArray(
                                NULL,
                                NULL,
                                DNS_REGKEY_PUBLISH_ADDRESSES );

    //
    //  forwarders read skipped for FILE boot, as it is boot file property
    //

    if ( SrvCfg_fBootMethod != BOOT_METHOD_FILE )
    {
        Config_ReadForwarders();
    }

    //
    //  read directory
    //      - if bootfile has directory directive it can overwrite
    //

    Config_ReadDatabaseDirectory( NULL, 0 );

    //
    //  Read log file path from the registry.
    //

    SrvCfg_pwsLogFilePath = (PWSTR) Reg_GetValueAllocate(
                                        NULL,
                                        NULL,
                                        DNS_REGKEY_LOG_FILE_PATH_PRIVATE,
                                        DNS_REG_WSZ,
                                        NULL );
    DNS_DEBUG( INIT, (
        "Default log file path: %S\n",
        SrvCfg_pwsLogFilePath ));

    //
    //  Read server level plugin DLL name from the registry.
    //

    SrvCfg_pwszServerLevelPluginDll = (PWSTR) Reg_GetValueAllocate(
                                                NULL,
                                                NULL,
                                                DNS_REGKEY_SERVER_PLUGIN_PRIVATE,
                                                DNS_REG_WSZ,
                                                NULL );
    DNS_DEBUG( INIT, (
        "Server level plugin DLL: %S\n",
        SrvCfg_pwszServerLevelPluginDll ));

    //
    //  Read log filter IP list from the registry.
    //

    SrvCfg_aipLogFilterList = Reg_GetAddrArray(
                                    NULL,
                                    NULL,
                                    DNS_REGKEY_LOG_IP_FILTER_LIST );
    IF_DEBUG( INIT )
    {
        DnsDbg_DnsAddrArray(
            "LogIPFilterList from registry: ",
            NULL,
            SrvCfg_aipLogFilterList );
    }

    //
    //  Read list of types not round robined from registry.
    //

    index = findIndexForPropertyName( DNS_REGKEY_NO_ROUND_ROBIN );
    if ( index != BAD_PROPERTY_INDEX )
    {
        pwsz = ( PWSTR ) Reg_GetValueAllocate(
                            NULL,
                            NULL,
                            DNS_REGKEY_NO_ROUND_ROBIN_PRIVATE,
                            DNS_REG_WSZ,
                            NULL );
        DNS_DEBUG( INIT, (
            "will not round robin: %S\n",
            pwsz ? pwsz : L"NULL" ));
        if ( pwsz )
        {
            propValue.dwPropertyType = DNS_REG_WSZ;
            propValue.pwszValue = pwsz;
            cfg_SetDoNotRoundRobinTypes(
                &propValue,
                index,
                TRUE,
                TRUE );
            FREE_HEAP( pwsz );
        }
    }

    //
    //  Read directory partition settings from registry.
    //

    SrvCfg_pszDomainDpBaseName = ( PSTR ) Reg_GetValueAllocate(
                                        NULL,
                                        NULL,
                                        DNS_REGKEY_DOMAIN_DP_BASE_NAME,
                                        DNS_REG_UTF8,
                                        NULL );
    if ( !SrvCfg_pszDomainDpBaseName )
    {
        SrvCfg_pszDomainDpBaseName = 
            Dns_StringCopyAllocate_A( DNS_DEFAULT_DOMAIN_DP_BASE, 0 );
    }

    SrvCfg_pszForestDpBaseName = ( PSTR ) Reg_GetValueAllocate(
                                        NULL,
                                        NULL,
                                        DNS_REGKEY_FOREST_DP_BASE_NAME,
                                        DNS_REG_UTF8,
                                        NULL );
    if ( !SrvCfg_pszForestDpBaseName )
    {
        SrvCfg_pszForestDpBaseName = 
            Dns_StringCopyAllocate_A( DNS_DEFAULT_FOREST_DP_BASE, 0 );
    }

    //
    //  read previous server name from registry
    //
    //  DEVNOTE: currently this is ANSI only, extended will get bogus name
    //

    SrvCfg_pszPreviousServerName = Reg_GetValueAllocate(
                                        NULL,
                                        NULL,
                                        DNS_REGKEY_PREVIOUS_SERVER_NAME_PRIVATE,
                                        DNS_REG_UTF8,
                                        NULL );
    DNS_DEBUG( INIT, (
        "Previous DNS server host name %s\n",
        SrvCfg_pszPreviousServerName ));

    return TRUE;
}



DNS_STATUS
Config_ResetProperty(
    IN      DWORD                   dwRegFlags,
    IN      LPSTR                   pszPropertyName,
    IN      PDNS_PROPERTY_VALUE     pPropValue
    )
/*++

Routine Description:

    Reset server property from registry. 

Arguments:

    dwRegFlags -- flags to pass into registry functions
    
    pszPropertyName -- property name

    pPropValue -- property type and value 

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD                           status = ERROR_SUCCESS;
    DWORD                           index;
    DWORD                           currentValue;
    PDWORD                          pvalueProperty;
    DWORD_PROPERTY_SET_FUNCTION     pSetFunction;

    //
    //  Get index for property.
    //

    index = findIndexForPropertyName( pszPropertyName );
    if ( index == BAD_PROPERTY_INDEX )
    {
        DNS_PRINT((
            "ERROR: property name %s, not found\n",
            pszPropertyName ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //
    //  Verify the incoming type matches the server property table type.
    //

    if ( pPropValue->dwPropertyType == REG_DWORD &&
            ServerPropertyTable[ index ].pDword == NULL ||
        pPropValue->dwPropertyType != REG_DWORD &&
            ServerPropertyTable[ index ].pDword != NULL )
    {
        DNS_PRINT((
            "ERROR: property %s set type %d does not match property table\n",
            pszPropertyName,
            pPropValue->dwPropertyType ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //
    //  Call the special processing function for this value (if there is one).
    //

    pSetFunction = ServerPropertyTable[ index ].pFunction;
    if ( pSetFunction )
    {
        status = ( *pSetFunction ) (
                    pPropValue,
                    index,
                    FALSE,      // reset
                    FALSE );    // not registry read
        if ( status == PROPERTY_ERROR )
        {
            status = GetLastError();
            ASSERT( status != ERROR_SUCCESS );
            return status;
        }
    }

    //
    //  For DWORD properties, write the property value to server config 
    //  block unless the special processing function told us not to.
    //

    if ( pPropValue->dwPropertyType == REG_DWORD &&
        !( status & PROPERTY_NOWRITE ) )
    {
        *ServerPropertyTable[ index ].pDword = ( DWORD ) pPropValue->dwValue;
    }

    //
    //  If booting from boot file, some properties need to cause
    //  a boot info update.
    //

    if ( SrvCfg_fBootMethod == BOOT_METHOD_FILE &&
        status & PROPERTY_UPDATE_BOOTFILE )
    {
        Config_UpdateBootInfo();
    }

    //
    //  Save the property to registry, unless the special processing
    //  function told us not to. Note, we write back even if no changes
    //  are made. This may overwrite any manual changes made while the
    //  server is running.
    //

    if ( status & PROPERTY_NOSAVE )
    {
        return ERROR_SUCCESS;
    }

    switch ( pPropValue->dwPropertyType )
    {
        case REG_DWORD:
            status = Reg_SetDwordValue(
                        dwRegFlags,
                        NULL,
                        NULL,
                        pszPropertyName,
                        pPropValue->dwValue );
            DNS_DEBUG( INIT, (
                "wrote server DWORD property %s to registry, status %p\n"
                "    value = %d\n",
                pszPropertyName,
                status,
                pPropValue->dwValue ));
            break;

        case DNS_REG_WSZ:
        {
            LPWSTR      pwszPropertyName;

            pwszPropertyName = Dns_StringCopyAllocate(
                                    pszPropertyName,
                                    0,
                                    DnsCharSetUtf8,
                                    DnsCharSetUnicode );
            status = Reg_SetValue(
                        dwRegFlags,
                        NULL,
                        NULL,
                        ( LPSTR ) pwszPropertyName,
                        DNS_REG_WSZ,
                        pPropValue->pwszValue ? pPropValue->pwszValue : L"",
                        0 );                // length
            FREE_HEAP( pwszPropertyName );
            DNS_DEBUG( INIT, (
                "wrote server WSZ property %s to registry, status %p\n"
                "    value = %S\n",
                pszPropertyName,
                status,
                pPropValue->pwszValue ));
            break;
        }

        case DNS_REG_IPARRAY:
            status = Reg_SetAddrArray(
                        dwRegFlags,
                        NULL,
                        NULL,
                        pszPropertyName,
                        pPropValue->pipArrayValue );
            DNS_DEBUG( INIT, (
                "wrote server IpArray property %s to registry, status %p, value %p\n",
                pszPropertyName,
                status,
                pPropValue->pipArrayValue ));
            IF_DEBUG( INIT )
            {
                DnsDbg_DnsAddrArray(
                    "Config_ResetProperty",
                    NULL,
                    pPropValue->pipArrayValue );
            }
            break;

        default:
            ASSERT( FALSE );
            DNS_DEBUG( INIT, (
                "ERROR: unsupported property type %d for property name %s\n",
                pPropValue->dwPropertyType,
                pszPropertyName ));
            break;
    }

    return status;
}



//
//  NT5+ RPC Query server property
//

DNS_STATUS
Rpc_QueryServerDwordProperty(
    IN      DWORD           dwClientVersion,
    IN      LPSTR           pszQuery,
    OUT     PDWORD          pdwTypeId,
    OUT     PVOID *         ppData
    )
/*++

Routine Description:

    Query DWORD server property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD   index;
    PDWORD  pvalue;

    DNS_DEBUG( RPC, (
        "Rpc_QueryServerDwordProperty( %s )\n",
        pszQuery ));

    //  find server property index, then grab its value

    index = findIndexForPropertyName( (LPSTR)pszQuery );
    if ( index == BAD_PROPERTY_INDEX )
    {
        DNS_PRINT((
            "ERROR:  Unknown server property %s\n",
            pszQuery ));
        return( DNS_ERROR_INVALID_PROPERTY );
    }

    //  get ptr to its value, then read value

    pvalue = ServerPropertyTable[ index ].pDword;
    if ( !pvalue )
    {
        DNS_PRINT((
            "ERROR:  Property %s, has no address in property table\n",
            pszQuery ));
        return( DNS_ERROR_INVALID_PROPERTY );
    }

    *(PDWORD)ppData = *pvalue;
    *pdwTypeId = DNSSRV_TYPEID_DWORD;
    return ERROR_SUCCESS;
}



//
//  NT5+ RPC Query server property
//

DNS_STATUS
Rpc_QueryServerStringProperty(
    IN      DWORD           dwClientVersion,
    IN      LPSTR           pszQuery,
    OUT     PDWORD          pdwTypeId,
    OUT     PVOID *         ppData
    )
/*++

Routine Description:

    Query string server property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD   index;
    LPWSTR  pwszValue = NULL;

    DNS_DEBUG( RPC, (
        "Rpc_QueryServerStringProperty( %s )\n",
        pszQuery ));

    //  find server property index, to check that the property exists at all

    index = findIndexForPropertyName( ( LPSTR ) pszQuery );
    if ( index == BAD_PROPERTY_INDEX )
    {
        DNS_PRINT((
            "ERROR: unknown server property %s\n",
            pszQuery ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    if ( ServerPropertyTable[ index ].pDword )
    {
        DNS_PRINT((
            "ERROR: string query for dword property %s\n",
            pszQuery ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //  This part is currently manual.

    *pdwTypeId = DNSSRV_TYPEID_LPWSTR;
    if ( _stricmp( pszQuery, DNS_REGKEY_LOG_FILE_PATH ) == 0 )
    {
        pwszValue = SrvCfg_pwsLogFilePath;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_FOREST_DP_BASE_NAME ) == 0 )
    {
        pwszValue = ( LPWSTR ) SrvCfg_pszForestDpBaseName;
        *pdwTypeId = DNSSRV_TYPEID_LPSTR;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_DOMAIN_DP_BASE_NAME ) == 0 )
    {
        pwszValue = ( LPWSTR ) SrvCfg_pszDomainDpBaseName;
        *pdwTypeId = DNSSRV_TYPEID_LPSTR;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_SERVER_PLUGIN ) == 0 )
    {
        pwszValue = SrvCfg_pwszServerLevelPluginDll;
    }
    else
    {
        DNS_PRINT((
            "ERROR: string query for non-string property %s\n",
            pszQuery ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    if ( *pdwTypeId == DNSSRV_TYPEID_LPWSTR )
    {
        * ( LPWSTR * ) ppData = pwszValue ?
            Dns_StringCopyAllocate_W( pwszValue, 0 ) :
            NULL;
    }
    else
    {
        * ( LPSTR * ) ppData = ( LPSTR ) pwszValue ?
            Dns_StringCopyAllocate_A( ( LPSTR ) pwszValue, 0 ) :
            NULL;
    }
    return ERROR_SUCCESS;
}   //  Rpc_QueryServerStringProperty



//
//  NT5+ RPC Query server property
//

DNS_STATUS
Rpc_QueryServerIPArrayProperty(
    IN      DWORD           dwClientVersion,
    IN      LPSTR           pszQuery,
    OUT     PDWORD          pdwTypeId,
    OUT     PVOID *         ppData
    )
/*++

Routine Description:

    Query IP list server property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD               index;
    PDNS_ADDR_ARRAY     pipValue = NULL;

    DNS_DEBUG( RPC, (
        "Rpc_QueryServerIPArrayProperty( %s )\n",
        pszQuery ));

    //  find server property index, to check that the property exists at all

    index = findIndexForPropertyName( ( LPSTR ) pszQuery );
    if ( index == BAD_PROPERTY_INDEX )
    {
        DNS_PRINT((
            "ERROR: unknown server property %s\n",
            pszQuery ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    if ( ServerPropertyTable[ index ].pDword )
    {
        DNS_PRINT((
            "ERROR: IP list query for dword property %s\n",
            pszQuery ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //  This part is currently manual.

    if ( _stricmp( pszQuery, DNS_REGKEY_LOG_IP_FILTER_LIST ) == 0 )
    {
        pipValue = SrvCfg_aipLogFilterList;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_BREAK_ON_RECV_FROM ) == 0 )
    {
        pipValue = SrvCfg_aipRecvBreakList;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_BREAK_ON_UPDATE_FROM ) == 0 )
    {
        pipValue = SrvCfg_aipUpdateBreakList;
    }
    else
    {
        DNS_PRINT((
            "ERROR: IP list query for non-IP list property %s\n",
            pszQuery ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    * ( PIP_ARRAY * ) ppData = pipValue ?
        DnsAddrArray_CreateIp4Array( pipValue ) :
        NULL;
    *pdwTypeId = DNSSRV_TYPEID_IPARRAY;
    return ERROR_SUCCESS;
}   //  Rpc_QueryServerIPArrayProperty



//
//  Public configuration functions
//

PDNS_ADDR_ARRAY
Config_ValidateAndCopyNonLocalIpArray(
    IN      PDNS_ADDR_ARRAY     pipArray
    )
/*++

Routine Description:

    Validate and make copy of IP array for non-local IPs.

    Validation includes verifying that no local addresses
    are included.

Arguments:

    pipArray -- IP array to validate

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_ADDR_ARRAY     pnewArray = NULL;
    PDNS_ADDR_ARRAY     pintersectArray = NULL;

    //
    //  validate array
    //      - ok to specify no secondaries
    //

    if ( !pipArray )
    {
        goto Done;
    }
    
    //  check for bogus addresses

    if ( !Dns_ValidateDnsAddrArray( pipArray, 0 ) )
    {
        goto Done;
    }

    //
    //  screen out loopback
    //

    DnsAddrArray_DeleteIp4(
        pipArray,
        NET_ORDER_LOOPBACK );

    //
    //  verify no intersection with local IPs
    //      - intersection indicates failure
    //      - but just return scrubbed IP array
    //

    DnsAddrArray_Diff(
        pipArray,
        g_ServerIp4Addrs,
        DNSADDR_MATCH_IP,
        &pnewArray,
        NULL,
        &pintersectArray );

    if( !pintersectArray || !pnewArray )
    {
        FREE_HEAP( pnewArray );
        pnewArray = NULL;
    }

    if ( pintersectArray && pintersectArray->AddrCount )
    {
        DNS_PRINT((
            "ERROR: invalid addresses specified to IP array\n" ));
    }

    Done:
    
    FREE_HEAP( pintersectArray );
    
    return pnewArray;
}



DNS_STATUS
Config_SetListenAddresses(
    IN      PDNS_ADDR_ARRAY     aipListenAddrs
    )
/*++

Routine Description:

    Setup server's IP address interfaces. Pass zero addresses
    to reset to IP listen list to the default, which is all
    addresses.

Arguments:

    aipListenAddrs  -- list of forwarders IP addresses

Return Value:

    Error code.

--*/
{
    DNS_STATUS          status;
    PDNS_ADDR_ARRAY     oldListenAddrs;
    PDNS_ADDR_ARRAY     newListenAddrs = NULL;
    DWORD               i;

    //
    //  Screen IP addresses
    //

    if ( RpcUtil_ScreenIps( 
                aipListenAddrs,
                DNS_IP_ALLOW_SELF,
                NULL ) != ERROR_SUCCESS )
    {
        return DNS_ERROR_INVALID_IP_ADDRESS;
    }

    //
    //  if given list, validate and build new listen array
    //

    if ( aipListenAddrs && aipListenAddrs->AddrCount )
    {
        if ( !Dns_ValidateDnsAddrArray(
                    aipListenAddrs,
                    0 ) )
        {
            return DNS_ERROR_INVALID_IP_ADDRESS;
        }

        newListenAddrs = DnsAddrArray_CreateCopy( aipListenAddrs );
        if ( !newListenAddrs )
        {
            return DNS_ERROR_NO_MEMORY;
        }
        ASSERT_IF_HUGE_ARRAY( newListenAddrs );
    }

    //
    //  clear fields, delete old list
    //

    Config_UpdateLock();

    oldListenAddrs = SrvCfg_aipListenAddrs;
    SrvCfg_fListenAddrsStale = TRUE;
    SrvCfg_aipListenAddrs = newListenAddrs;

    //
    //  intimate dynamic changes to our centralized pnp handler
    //      - if fails, back out change
    //

    status = Sock_ChangeServerIpBindings();
    if ( status != ERROR_SUCCESS )
    {
        SrvCfg_aipListenAddrs = oldListenAddrs;
        oldListenAddrs =  newListenAddrs;       // for FREE below
    }

    //
    //  set registry values
    //
    //  note:  if no listen addresses, then we just delete them
    //      all and clear registry entry, on next service boot, we'll
    //      get default behavior of using all addresses
    //

    else if ( g_bRegistryWriteBack )
    {
        status = Reg_SetAddrArray(
                    0,                      //  flags
                    NULL,
                    NULL,
                    DNS_REGKEY_LISTEN_ADDRESSES,
                    SrvCfg_aipListenAddrs );
    }

    SrvCfg_fListenAddrsStale = FALSE;

    Config_UpdateUnlock();

    Timeout_Free( oldListenAddrs );

    IF_DEBUG( RPC )
    {
        DnsDbg_DnsAddrArray(
            "Config_SetListenAddresses()\n",
            "SrvCfg listen IP address list",
            SrvCfg_aipListenAddrs );
    }
    return status;
}



DNS_STATUS
Config_SetupForwarders(
    IN      PDNS_ADDR_ARRAY     aipForwarders,
    IN      DWORD               dwForwardTimeout,
    IN      BOOL                fSlave
    )
/*++

Routine Description:

    Setup forwarding servers

Arguments:

    cForwarders         -- count of forwarders server
    pIpForwarders       -- list of forwarders IP addresses
    dwForwardTimeout    -- timeout on a forwarding
    fSlave              -- server is slave to forwarders servers

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    DWORD               dwFlag;
    DWORD               i;
    PDNS_ADDR_ARRAY     forwardersArray = NULL;

    //
    //  Screen IP addresses
    //

    if ( aipForwarders &&
         RpcUtil_ScreenIps( 
                aipForwarders,
                0,
                NULL ) != ERROR_SUCCESS )
    {
        return DNS_ERROR_INVALID_IP_ADDRESS;
    }

    //
    //  check and copy forwarders addresses
    //      - valid
    //      - not pointing at this server
    //
    //  no forwarders turns forwarding off
    //

    if ( aipForwarders && aipForwarders->AddrCount )
    {
        forwardersArray = Config_ValidateAndCopyNonLocalIpArray( aipForwarders );
        if ( !forwardersArray )
        {
            return DNS_ERROR_INVALID_IP_ADDRESS;
        }
        DnsAddrArray_SetPort( forwardersArray, DNS_PORT_NET_ORDER );
    }

    //
    //  reset forwarding info
    //      - timeout and slave first so set before we come on-line
    //      with new forwarders
    //      - timeout delete any old forwarders
    //

    Config_UpdateLock();

    if ( dwForwardTimeout == 0 )
    {
        dwForwardTimeout = DNS_DEFAULT_FORWARD_TIMEOUT;
    }
    SrvCfg_dwForwardTimeout = dwForwardTimeout;

    SrvCfg_fSlave = fSlave;

    Timeout_FreeDnsAddrArray( SrvCfg_aipForwarders );
    SrvCfg_aipForwarders = forwardersArray;

    DNS_DEBUG( INIT, (
        "Set forwarders:\n"
        "    aipForwarders    = %p\n"
        "    dwTimeout        = %d\n"
        "    fSlave           = %d\n",
        SrvCfg_aipForwarders,
        SrvCfg_dwForwardTimeout,
        SrvCfg_fSlave ));

    //
    //  set registry values
    //

    if ( g_bRegistryWriteBack )
    {
        if ( forwardersArray )
        {
            Reg_SetAddrArray(
                0,                      //  flags
                NULL,
                NULL,
                DNS_REGKEY_FORWARDERS,
                SrvCfg_aipForwarders );

            Reg_SetDwordValue(
                0,                      //  flags
                NULL,
                NULL,
                DNS_REGKEY_FORWARD_TIMEOUT,
                dwForwardTimeout );

            Reg_SetDwordValue(
                0,                      //  flags
                NULL,
                NULL,
                DNS_REGKEY_SLAVE,
                (DWORD) fSlave );
        }
        else
        {
            Reg_DeleteValue(
                0,                      //  flags
                NULL,
                NULL,
                DNS_REGKEY_FORWARDERS );

            Reg_DeleteValue(
                0,                      //  flags
                NULL,
                NULL,
                DNS_REGKEY_FORWARD_TIMEOUT );

            Reg_DeleteValue(
                0,                      //  flags
                NULL,
                NULL,
                DNS_REGKEY_SLAVE );
        }
    }

    Config_UpdateUnlock();
    return status;
}



DNS_STATUS
Config_ReadForwarders(
    VOID
    )
/*++

Routine Description:

    Read forwarders from registry.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status;

    //
    //  read forwarders array from registry
    //

    SrvCfg_aipForwarders = Reg_GetAddrArray(
                                NULL,
                                NULL,
                                DNS_REGKEY_FORWARDERS );
    if ( !SrvCfg_aipForwarders )
    {
        DNS_DEBUG( INIT, ( "No forwarders found in in registry\n" ));
        return ERROR_SUCCESS;
    }
    IF_DEBUG( INIT )
    {
        DnsDbg_DnsAddrArray(
            "Forwarders from registry\n",
            NULL,
            SrvCfg_aipForwarders );
    }

    //
    //  forwarding timeout and slave status already read in reading
    //  server DWORD properties
    //
    //  simply confirm sane values
    //

    if ( SrvCfg_dwForwardTimeout == 0 )
    {
        SrvCfg_dwForwardTimeout = DNS_DEFAULT_FORWARD_TIMEOUT;
    }
    return ERROR_SUCCESS;

#if 0
Failed:

    DNS_LOG_EVENT(
        DNS_EVENT_INVALID_REGISTRY_FORWARDERS,
        0,
        NULL,
        NULL,
        0 );

    DNS_PRINT(( "ERROR:  Reading forwarders info from registry\n" ));

    return status;
#endif
}



VOID
Config_UpdateBootInfo(
    VOID
    )
/*++

Routine Description:

    Update boot info.
    Call whenever admin makes change that affects boot file info (new zone,
        change zone type, forwarders, etc.)

Arguments:

    None

Return Value:

    None.

--*/
{
    //  if booted from boot file (or reset to do so)
    //  write back boot file

    if ( SrvCfg_fBootMethod == BOOT_METHOD_FILE )
    {
        SrvCfg_fBootFileDirty = TRUE;
        File_WriteBootFile();
        return;
    }

    //  for registry boot, no need to write, as info is written to registry
    //      incrementally
    //
    //  however, if in freshly installed state, switch to full DS-registry boot

    if ( SrvCfg_fBootMethod == BOOT_METHOD_UNINITIALIZED )
    {
        DNS_PROPERTY_VALUE  prop = { REG_DWORD, BOOT_METHOD_DIRECTORY };

        Config_ResetProperty(
            0,
            DNS_REGKEY_BOOT_METHOD,
            &prop );
        return;
    }
}



VOID
Config_PostLoadReconfiguration(
    VOID
    )
/*++

Routine Description:

    Post-load configuration work.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    //  after load, save current DNS server host name as previous name
    //
    //  note, this is not done until after load, so that load failure
    //  does not stop result in partial replacement
    //

    //  DEVNOTE: if want to skip write, then need another global
    //      - can skip only if the same as previous
    //      SrvCfg_pszPreviousServerName == NULL doesn't cut it for
    //      case where this was NULL on start

    Reg_SetValue(
        0,                      //  flags
        NULL,
        NULL,
        DNS_REGKEY_PREVIOUS_SERVER_NAME_PRIVATE,
        DNS_REG_UTF8,
        SrvCfg_pszServerName,
        0 );
}



DNS_STATUS
Config_ReadDatabaseDirectory(
    IN      PCHAR           pchDirectory,       OPTIONAL
    IN      DWORD           cchDirectoryNameLength
    )
/*++

Routine Description:

    Get database directory from registry or use default name.

Arguments:

    pchDirectory -- ptr to directory name;
        OPTIONAL  read from registry or defaulted if not given

    cchDirectoryNameLength -- name length, required if name not NULL terminatated

Return Value:

    ERROR_SUCCESS if successful.
    Error code on error.

--*/
{
    PWSTR   pdirectory = NULL;
    PWSTR   pdirectoryUnexpanded;
    WCHAR   tempBuffer[ MAX_PATH + 1 ];
    DWORD   lengthDir = 0;

    //
    //  once per customer
    //  this simplifies code for file boot case;  may call when encounter
    //  directory directive, then always call again to setup before zone load
    //

    if ( SrvCfg_pwsDatabaseDirectory )
    {
        DNS_DEBUG( INIT, (
            "Directory already initialized to %S\n",
            SrvCfg_pwsDatabaseDirectory ));

        return ERROR_SUCCESS;
    }

    //
    //  init globals for "unable to create" case
    //

    g_pFileDirectoryAppend = NULL;
    g_pFileBackupDirectoryAppend = NULL;

    //
    //  name from boot file?
    //
    //  DEVNOTE: error\event on bogus directory name
    //      - non-existence
    //      - bad length
    //

    if ( pchDirectory )
    {
        pdirectory = Dns_StringCopyAllocate(
                            pchDirectory,
                            cchDirectoryNameLength,
                            DnsCharSetAnsi,             // ANSI in
                            DnsCharSetUnicode           // unicode out
                            );
    }

    //
    //  check registry
    //

    else
    {
        pdirectoryUnexpanded = (PWSTR) Reg_GetValueAllocate(
                                            NULL,
                                            NULL,
                                            DNS_REGKEY_DATABASE_DIRECTORY_PRIVATE,
                                            DNS_REG_EXPAND_WSZ,
                                            NULL );
        if ( pdirectoryUnexpanded )
        {
            pdirectory = Reg_AllocateExpandedString_W( pdirectoryUnexpanded );
            FREE_HEAP( pdirectoryUnexpanded );
        }
    }

    //
    //  read in specific directory name
    //

    if ( pdirectory )
    {
        lengthDir = wcslen( pdirectory );
        if ( lengthDir >= MAX_PATH-20 )
        {
            //  DEVNOTE-LOG: log event!
            //      note we only get here if configured to do so

            DNS_PRINT(( "ERROR:  invalid directory length!\n" ));
            FREE_HEAP( pdirectory );
            pdirectory = NULL;
        }

        //  try create here and if fail (excluding already-exists)
        //      then continue
    }

    //
    //  if no specified name use default name
    //

    if ( ! pdirectory )
    {
        pdirectory = Dns_StringCopyAllocate_W(
                            DNS_DATABASE_DIRECTORY,
                            0 );
        IF_NOMEM( !pdirectory )
        {
            ASSERT( FALSE );
            return DNS_ERROR_NO_MEMORY;
        }
        lengthDir = wcslen( pdirectory );

        DNS_DEBUG( INIT, (
            "Database directory not in registry, using default: %S\n",
            pdirectory ));

        DNS_DEBUG( INIT, (
            "Database directory %S\n"
            "    strlen = %d\n"
            "    sizeof = %d\n",
            pdirectory,
            lengthDir,
            sizeof( DNS_DATABASE_DIRECTORY ) ));
    }

    DNS_DEBUG( INIT, (
        "Database directory %S\n",
        pdirectory ));

    SrvCfg_pwsDatabaseDirectory = pdirectory;


    //
    //  create database directory
    //
    //  DEVNOTE: catch appropriate ALREADY_EXISTS error and fix
    //

    if ( !CreateDirectory(
                pdirectory,
                NULL ) )
    {
        DNS_STATUS status = GetLastError();

        DNS_PRINT((
            "ERROR:  creating directory %S\n"
            "    status = %d (%p)\n",
            pdirectory,
            status, status ));
        //return status;
    }

    //
    //  create "appendable" names to avoid doing work at runtime
    //      - "dns\"         for directory
    //      - "dns\backup\"  for backup
    //

    g_FileDirectoryAppendLength = lengthDir + 1;

    wcscpy( tempBuffer, pdirectory );
    tempBuffer[ lengthDir ] = L'\\';
    tempBuffer[ g_FileDirectoryAppendLength ] = '\0';

    g_pFileDirectoryAppend = Dns_StringCopyAllocate_W(
                                    tempBuffer,
                                    g_FileDirectoryAppendLength );
    IF_NOMEM( !g_pFileDirectoryAppend )
    {
        return DNS_ERROR_NO_MEMORY;
    }


    //
    //  create backup directory
    //      - note string already has forward separators "\backup"
    //

    g_FileBackupDirectoryAppendLength = lengthDir + wcslen(DNS_DATABASE_BACKUP_SUBDIR) + 1;
    if ( g_FileBackupDirectoryAppendLength >= MAX_PATH - 20 )
    {
        DNS_PRINT(( "ERROR:  backup directory path is too long!\n" ));
        goto Done;
    }

    wcscpy( tempBuffer, pdirectory );
    wcscat( tempBuffer, DNS_DATABASE_BACKUP_SUBDIR );

    //  create the backup directory

    if ( ! CreateDirectory(
                tempBuffer,
                NULL ) )
    {
        DNS_STATUS status = GetLastError();

        DNS_PRINT((
            "ERROR:  creating backup directory %S\n"
            "    status = %d (%p)\n",
            tempBuffer,
            status, status ));
    }
    tempBuffer[ g_FileBackupDirectoryAppendLength-1 ] = L'\\';
    tempBuffer[ g_FileBackupDirectoryAppendLength ] = 0;

    g_pFileBackupDirectoryAppend = Dns_StringCopyAllocate_W(
                                        tempBuffer,
                                        g_FileBackupDirectoryAppendLength );
    IF_NOMEM( !g_pFileDirectoryAppend )
    {
        return DNS_ERROR_NO_MEMORY;
    }

Done:

    DNS_DEBUG( INIT, (
        "Database directory %S\n"
        "    append directory %S\n"
        "    backup directory %S\n",
        SrvCfg_pwsDatabaseDirectory,
        g_pFileDirectoryAppend,
        g_pFileBackupDirectoryAppend ));

    return ERROR_SUCCESS;
}


#if 0

//
//  Obsolete code, keeping around in case flexibility becomes an issue:
//      - boot file always named "boot"
//      - directory always SystemRoot\system32\dns
//


LPSTR
Config_GetBootFileName(
    VOID
    )
/*++

Routine Description:

    Get boot file name.

    User must free filename string returned.

Arguments:

    None

Return Value:

    Ptr to name of boot file, if successful.
    NULL on error.

--*/
{
    LPSTR   pszBootFile;
    LPSTR   pszBootFileUnexpanded;

    //
    //  check registry
    //

    pszBootFileUnexpanded = Reg_GetValueAllocate(
                                NULL,
                                NULL,
                                DNS_REGKEY_BOOT_FILENAME_PRIVATE,
                                DNS_REG_EXPAND_WSZ,
                                NULL );

    pszBootFile = Reg_ExpandAndAllocatedString(
                        pszBootFileUnexpanded );

    //
    //  if no registry name use default name
    //

    if ( ! pszBootFile )
    {
        pszBootFile = DnsCreateStringCopy(
                            DEFAULT_PATH_TO_BOOT_FILE,
                            0 );
        IF_DEBUG( INIT )
        {
            DNS_PRINT((
                "Boot file not in registry, using default: %s\n",
                pszBootFile ));
        }
    }

    if ( pszBootFileUnexpanded )
    {
        FREE_HEAP( pszBootFileUnexpanded );
    }

    if ( !pszBootFile )
    {
        PVOID parg = TEXT("boot file");

        DNS_LOG_EVENT(
            DNS_EVENT_COULD_NOT_INITIALIZE,
            1,
            & parg,
            NULL,
            0 );

        DNS_DEBUG( INIT, (
            "Could not locate or create boot file name\n" ));
    }

    return( pszBootFile );
}
#endif



//
//  Server configuration setup functions
//

DNS_STATUS
cfg_SetBootMethod(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set boot method -- boot file or registry.

Arguments:

    fBootMethod -- boot from registry

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCES, if successful.
    Combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    DWORD       previousBootMethod;
    DNS_STATUS  status = ERROR_SUCCESS;

    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  Input range check.
    //
    
    if ( pValue->dwValue != BOOT_METHOD_UNINITIALIZED &&
         pValue->dwValue != BOOT_METHOD_FILE &&
         pValue->dwValue != BOOT_METHOD_REGISTRY && 
         pValue->dwValue != BOOT_METHOD_DIRECTORY )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return PROPERTY_ERROR;
    }
    
    //
    //  On load, no action except range check.
    //

    if ( bLoad )
    {
        return ERROR_SUCCESS;
    }

    //
    //  no action if boot method already same as desired
    //

    if ( SrvCfg_fBootMethod == pValue->dwValue )
    {
        return ERROR_SUCCESS;
    }

    //
    //  switch to DS-registry boot
    //      - open DS (if on DC)
    //      - if using cache file, write it to directory, but ONLY
    //      if actually have some data;  otherwise ignore
    //

    if ( pValue->dwValue == BOOT_METHOD_DIRECTORY )
    {
        DNS_STATUS  st;

        st = Ds_OpenServer( 0 );
        if ( st == ERROR_SUCCESS )
        {
            if ( g_pCacheZone )
            {
                Ds_WriteZoneToDs(
                    g_pCacheZone,
                    0 );        //  if already exists, leave it
            }
        }
        ELSE
        {
            DNS_DEBUG ( DS, (
               "Warning <%lu>: set default method to DS on non DSDC\n",
               st ));
        }
    }

    //
    //  can not have DS zones when booting from file
    //
    //  DEVNOTE-LOG: log EVENT for no-switch to boot file if using DS
    //      must explain way to switch:  all zones out of DS
    //      reboot server, fix
    //

    if ( pValue->dwValue==BOOT_METHOD_FILE  &&  Zone_DoesDsIntegratedZoneExist() )
    {
        SetLastError( DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE );
        return PROPERTY_ERROR;
    }

    //
    //  set boot method global
    //

    previousBootMethod = SrvCfg_fBootMethod;
    SrvCfg_fBootMethod = pValue->dwValue;

    //
    //  if leaving DS, make sure not-dependent on DS backed root-hints
    //      - force write of root hints
    //
    //  DEVNOTE: forcing root-hints write back?
    //      note:  currently forcing root hint write back
    //      want to make sure we're not whacking an existing cache.dns
    //      when we have less reliable (or perhaps NO) data
    //

    if ( previousBootMethod == BOOT_METHOD_DIRECTORY ||
         (  previousBootMethod == BOOT_METHOD_REGISTRY &&
            pValue->dwValue == BOOT_METHOD_FILE ) )
    {
        ASSERT( pValue->dwValue != BOOT_METHOD_DIRECTORY );

        if ( g_pCacheZone )
        {
            g_pCacheZone->fDsIntegrated = FALSE;

            status = Zone_WriteBackRootHints( TRUE );
            if ( status != ERROR_SUCCESS )
            {
                //
                // DEVNOTE-LOG: Need to report event.
                // write debug, but leave as non-dsintegrated since this is where we are.
                //
                DNS_DEBUG( INIT, (
                    "Error <%lu>: Failed to write back root hints because there's no cache zone\n",
                    status ));
            }
        }
    }

    //
    //  switching back to boot file
    //      - write boot file for current registry info
    //      - if previously uninitialized boot method, then we've just
    //          successfully read a boot file and booted, no write back
    //          if necessary
    //
    //  DEVNOTE: stay registry boot, if can't write boot file
    //      - time delay here, make sure locking adequate so not overwriting
    //      successful action with failure
    //

    if ( pValue->dwValue == BOOT_METHOD_FILE )
    {
        if ( previousBootMethod != BOOT_METHOD_UNINITIALIZED )
        {
            File_WriteBootFile();

            DeleteFile( DNS_BOOT_FILE_MESSAGE_PATH );

            DNS_LOG_EVENT(
                DNS_EVENT_SWITCH_TO_BOOTFILE,
                0,
                NULL,
                NULL,
                0 );
        }
    }

    //
    //  if switching from boot file
    //      - rename the boot file to avoid confusion
    //

    else if ( previousBootMethod == BOOT_METHOD_FILE )
    {
        HANDLE  hfileBoot;
#if 0
        Reg_DeleteValue(
            NULL,
            NULL,
            DNS_REGKEY_BOOT_FILENAME );
#endif
        MoveFileEx(
            DNS_BOOT_FILE_PATH,
            DNS_BOOT_FILE_LAST_BACKUP,
            MOVEFILE_REPLACE_EXISTING );

        hfileBoot = OpenWriteFileEx(
                        DNS_BOOT_FILE_MESSAGE_PATH,
                        FALSE );        //  overwrite
        if ( hfileBoot )
        {
            WriteMessageToFile(
                hfileBoot,
                DNS_BOOTFILE_BACKUP_MESSAGE );
            CloseHandle( hfileBoot );
        }
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
cfg_SetEnableRegistryBoot(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set boot method -- having read EnableRegistryBoot key.

    This is for backward compatibility to NT4.
    New BootMethod key is set.
    Old EnableRegistryBoot key is deleted.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCES, if successful.
    Combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    DNS_STATUS  status;

    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  on reset, no action
    //  if not in registry, no action boot method defaults itself
    //

    if ( !bLoad || !bRegistry )
    {
        return PROPERTY_NOSAVE;
    }

    //
    //  on load, map EnableRegistryBoot, to new BootMethod key
    //

    if ( !pValue->dwValue )
    {
        //  file boot

        SrvCfg_fBootMethod = BOOT_METHOD_FILE;
    }

    else if ( pValue->dwValue == DNS_FRESH_INSTALL_BOOT_REGISTRY_FLAG )
    {
        //  key was NOT present (or in some default new install state)

        SrvCfg_fBootMethod = BOOT_METHOD_UNINITIALIZED;
    }

    else
    {
        SrvCfg_fBootMethod = BOOT_METHOD_REGISTRY;
    }

    status = Reg_SetDwordValue(
                0,                      //  flags
                NULL,
                NULL,
                DNS_REGKEY_BOOT_METHOD,
                SrvCfg_fBootMethod );

    if ( status != ERROR_SUCCESS )
    {
        SetLastError( status );
        return  PROPERTY_ERROR;
    }

    //  delete old EnableRegistryBoot key
    //      and return NOSAVE so no creation of new one

    Reg_DeleteValue(
        0,                      //  flags
        NULL,
        NULL,
        DNS_REGKEY_BOOT_REGISTRY );

    return PROPERTY_NOSAVE;
}



DNS_STATUS
cfg_SetAddressAnswerLimit(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit AddressAnswerLimit value to appropriate value.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  limit to 5 < ? < 28
    //
    //  28 limit imposed by broken Win95 resolver,
    //  5 sees like a reasonable lower limit -- providing server-down
    //  redundancy without too much wasted bandwidth
    //

    if ( pValue->dwValue > 0 )
    {
        if ( pValue->dwValue < MIN_ADDRESS_ANSWER_LIMIT )
        {
            pValue->dwValue = MIN_ADDRESS_ANSWER_LIMIT;
        }
        else if ( pValue->dwValue > MAX_ADDRESS_ANSWER_LIMIT )
        {
            pValue->dwValue = MAX_ADDRESS_ANSWER_LIMIT;
        }
    }

    //
    //  set value ourselves, as may be different from input
    //

    SrvCfg_cAddressAnswerLimit = pValue->dwValue;

    return PROPERTY_NOWRITE;
}



DNS_STATUS
cfg_SetLogFilePath(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set the log file path and trigger the log module to open the new file.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    LPWSTR      pwszOldLogFilePath = SrvCfg_pwsLogFilePath;
    DNS_STATUS  status;

    ASSERT( pValue->dwPropertyType == DNS_REG_WSZ );

    SrvCfg_pwsLogFilePath =
        pValue->pwszValue ?
            Dns_StringCopyAllocate_W( pValue->pwszValue, 0 ) :
            NULL;

    status = Log_InitializeLogging( FALSE );
    
    //  File name global has been regenerated with a new string so free old one.
    
    Timeout_Free( pwszOldLogFilePath );

    if ( status != ERROR_SUCCESS )
    {
        SetLastError( status );
        status = PROPERTY_ERROR;
    }
    return status;
}   //  cfg_SetLogFilePath



DNS_STATUS
cfg_SetLogLevel(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set the log level for debug logging. If the flags specified are
    non-zero but do not result in any logging return
    DNS_ERROR_NO_PACKET. This is to prevent admins from mistakenly
    setting log settings that will result in no actual packets
    being logged.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    DWORD       dwValue = pValue->dwValue;

    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  Verify that if any log bits are on that the bits will result in
    //  at least some logging.
    //

    if ( ( dwValue & DNS_LOG_LEVEL_ALL_PACKETS ) && (

        //  Must choose at least one of send and receive.
        ( ( dwValue & DNS_LOG_LEVEL_SEND ) == 0 &&
            ( dwValue & DNS_LOG_LEVEL_RECV ) == 0 ) ||

        //  Must choose at least one protocol.
        ( ( dwValue & DNS_LOG_LEVEL_TCP ) == 0 &&
            ( dwValue & DNS_LOG_LEVEL_UDP ) == 0 ) ||

        //  Must choose at least one packet content category.
        ( ( dwValue & DNS_LOG_LEVEL_QUERY ) == 0 &&
            ( dwValue & DNS_LOG_LEVEL_NOTIFY ) == 0 &&
            ( dwValue & DNS_LOG_LEVEL_UPDATE ) == 0 ) ||

        //  Must choose at least one of request/response.
        ( ( dwValue & DNS_LOG_LEVEL_QUESTIONS ) == 0 &&
            ( dwValue & DNS_LOG_LEVEL_ANSWERS ) == 0 ) ) )
    {
        SetLastError( DNS_ERROR_INVALID_DATA );
        return PROPERTY_ERROR;
    }

    SrvCfg_dwLogLevel = dwValue;

    return ERROR_SUCCESS;
}   //  cfg_SetLogLevel



DNS_STATUS
cfg_SetLogIPFilterList(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set the log file IP filter list. 

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    PDNS_ADDR_ARRAY     pipOldIPArray = SrvCfg_aipLogFilterList;

    ASSERT( pValue->dwPropertyType == DNS_REG_IPARRAY );

    if ( pValue->pipArrayValue )
    {
        SrvCfg_aipLogFilterList = DnsAddrArray_CreateCopy( pValue->pipArrayValue );
    }
    else
    {
        SrvCfg_aipLogFilterList = NULL;
    }

    Timeout_FreeDnsAddrArray( pipOldIPArray );

    return ERROR_SUCCESS;
}   //  cfg_SetLogIPFilterList



DNS_STATUS
cfg_SetServerLevelPlugin(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set the server level plugin DLL file name.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    LPWSTR      pwszOldValue = SrvCfg_pwszServerLevelPluginDll;

    ASSERT( pValue->dwPropertyType == DNS_REG_WSZ );

    SrvCfg_pwszServerLevelPluginDll =
        pValue->pwszValue ?
            Dns_StringCopyAllocate_W( pValue->pwszValue, 0 ) :
            NULL;

    Timeout_Free( pwszOldValue );

    return ERROR_SUCCESS;
}   //  cfg_SetServerLevelPlugin



DNS_STATUS
cfg_SetForestDpBaseName(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set forest directory partition base name.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;

    ASSERT( pValue->dwPropertyType == DNS_REG_UTF8 );

    if ( pValue->pwszValue )
    {
        LPSTR       psz;

        psz = Dns_StringCopyAllocate_A( pValue->pszValue, 0 );
        if ( psz )
        {
            Timeout_Free( SrvCfg_pszForestDpBaseName );
            SrvCfg_pszForestDpBaseName = psz;
        }
        else
        {
            SetLastError( DNS_ERROR_NO_MEMORY );
            status = PROPERTY_ERROR;
        }
    }
    else
    {
        Timeout_Free( SrvCfg_pszForestDpBaseName );
        SrvCfg_pszForestDpBaseName = NULL;
    }

    return status;
}   //  cfg_SetForestDpBaseName



DNS_STATUS
cfg_SetDomainDpBaseName(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set domain directory partition base name.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;

    ASSERT( pValue->dwPropertyType == DNS_REG_UTF8 );

    if ( pValue->pwszValue )
    {
        LPSTR       psz;

        psz = Dns_StringCopyAllocate_A( pValue->pszValue, 0 );
        if ( psz )
        {
            Timeout_Free( SrvCfg_pszDomainDpBaseName );
            SrvCfg_pszDomainDpBaseName = psz;
        }
        else
        {
            SetLastError( DNS_ERROR_NO_MEMORY );
            status = PROPERTY_ERROR;
        }
    }
    else
    {
        Timeout_Free( SrvCfg_pszDomainDpBaseName );
        SrvCfg_pszDomainDpBaseName = NULL;
    }

    return status;
}   //  cfg_SetDomainDpBaseName



DNS_STATUS
cfg_SetBreakOnUpdateFromList(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set the update break list of IPs. We will execute a hard breakpoint when
    an update is received from one of these IPs.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    PDNS_ADDR_ARRAY     pipOldIPArray = SrvCfg_aipUpdateBreakList;

    ASSERT( pValue->dwPropertyType == DNS_REG_IPARRAY );

    if ( pValue->pipArrayValue )
    {
        SrvCfg_aipUpdateBreakList = DnsAddrArray_CreateCopy( pValue->pipArrayValue );
    }
    else
    {
        SrvCfg_aipUpdateBreakList = NULL;
    }

    Timeout_FreeDnsAddrArray( pipOldIPArray );

    return ERROR_SUCCESS;
}   //  cfg_SetBreakOnUpdateFromList



DNS_STATUS
cfg_SetBreakOnRecvFromList(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set the recevie break list of IPs. We will execute a hard breakpoint when
    a packet is received from one of these IPs.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    PDNS_ADDR_ARRAY     pipOldIPArray = SrvCfg_aipRecvBreakList;

    ASSERT( pValue->dwPropertyType == DNS_REG_IPARRAY );

    if ( pValue->pipArrayValue )
    {
        SrvCfg_aipRecvBreakList = DnsAddrArray_CreateCopy( pValue->pipArrayValue );
    }
    else
    {
        SrvCfg_aipRecvBreakList = NULL;
    }

    Timeout_FreeDnsAddrArray( pipOldIPArray );

    return ERROR_SUCCESS;
}   //  cfg_SetBreakOnRecvFromList



DNS_STATUS
cfg_SetMaxUdpPacketSize(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit MaxUdpPacketSize to appropriate range of values.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  Debug - test limits for alignment.
    //
    
    #ifdef _WIN64
    ASSERT( IS_DWORD_ALIGNED( MIN_UDP_PACKET_SIZE ) );
    ASSERT( IS_DWORD_ALIGNED( MAX_UDP_PACKET_SIZE ) );
    #else
    ASSERT( IS_QWORD_ALIGNED( MIN_UDP_PACKET_SIZE ) );
    ASSERT( IS_QWORD_ALIGNED( MAX_UDP_PACKET_SIZE ) );
    #endif

    //
    //  Limit to MIN_UDP_PACKET_SIZE < ? < MAX_UDP_PACKET_SIZE.
    //
    
    if ( pValue->dwValue < MIN_UDP_PACKET_SIZE )
    {
        pValue->dwValue = MIN_UDP_PACKET_SIZE;
    }
    else if ( pValue->dwValue > MAX_UDP_PACKET_SIZE )
    {
        pValue->dwValue = MAX_UDP_PACKET_SIZE;
    }
    
    //
    //  Align!
    //
    
    #ifdef _WIN64
    pValue->dwValue = ( DWORD ) ( DWORD_PTR )
                      QWORD_ALIGN( ( PBYTE ) ( DWORD_PTR ) pValue->dwValue );
    #else
    pValue->dwValue = ( DWORD ) ( DWORD_PTR )
                      DWORD_ALIGN( ( PBYTE ) ( DWORD_PTR ) pValue->dwValue );
    #endif

    //
    //  Set value ourselves, as may be different from input.
    //

    SrvCfg_dwMaxUdpPacketSize = pValue->dwValue;

    return PROPERTY_NOWRITE;
}   //  cfg_SetMaxUdpPacketSize



DNS_STATUS
cfg_SetTcpRecvPacketSize(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit SrvCfg_dwTcpRecvPacketSize to appropriate range of values.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  Debug - test limits for alignment.
    //
    
    #ifdef _WIN64
    ASSERT( IS_DWORD_ALIGNED( MIN_TCP_PACKET_SIZE ) );
    ASSERT( IS_DWORD_ALIGNED( MAX_TCP_PACKET_SIZE ) );
    #else
    ASSERT( IS_QWORD_ALIGNED( MIN_TCP_PACKET_SIZE ) );
    ASSERT( IS_QWORD_ALIGNED( MAX_TCP_PACKET_SIZE ) );
    #endif

    //
    //  Limit to MIN_TCP_PACKET_SIZE < ? < MAX_TCP_PACKET_SIZE.
    //
    
    if ( pValue->dwValue < MIN_TCP_PACKET_SIZE )
    {
        pValue->dwValue = MIN_TCP_PACKET_SIZE;
    }
    else if ( pValue->dwValue > MAX_TCP_PACKET_SIZE )
    {
        pValue->dwValue = MAX_TCP_PACKET_SIZE;
    }
    
    //
    //  Align!
    //
    
    #ifdef _WIN64
    pValue->dwValue = ( DWORD ) ( DWORD_PTR )
                      QWORD_ALIGN( ( PBYTE ) ( DWORD_PTR ) pValue->dwValue );
    #else
    pValue->dwValue = ( DWORD ) ( DWORD_PTR )
                      DWORD_ALIGN( ( PBYTE ) ( DWORD_PTR ) pValue->dwValue );
    #endif

    //
    //  Set value ourselves, as may be different from input.
    //

    SrvCfg_dwTcpRecvPacketSize = pValue->dwValue;

    return PROPERTY_NOWRITE;
}   //  cfg_SetTcpRecvPacketSize



DNS_STATUS
cfg_SetEDnsCacheTimeout(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit EDnsCacheTimeout to appropriate range of values.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  limit to MIN_EDNS_CACHE_TIMEOUT < ? < MAX_EDNS_CACHE_TIMEOUT
    //

    if ( pValue->dwValue > 0 )
    {
        if ( pValue->dwValue < MIN_EDNS_CACHE_TIMEOUT )
        {
            pValue->dwValue = MIN_EDNS_CACHE_TIMEOUT;
        }
        else if ( pValue->dwValue > MAX_EDNS_CACHE_TIMEOUT )
        {
            pValue->dwValue = MAX_EDNS_CACHE_TIMEOUT;
        } 
    }

    //
    //  set value ourselves, as may be different from input
    //

    SrvCfg_dwEDnsCacheTimeout = pValue->dwValue;

    return PROPERTY_NOWRITE;
} // cfg_SetEDnsCacheTimeout



DNS_STATUS
cfg_SetMaxCacheSize(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit MaxCacheSize to appropriate value.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    if ( pValue->dwValue < MIN_MAX_CACHE_SIZE )
    {
        pValue->dwValue = MIN_MAX_CACHE_SIZE;
    }

    SrvCfg_dwMaxCacheSize = pValue->dwValue;

    return PROPERTY_NOWRITE;
}   //  cfg_SetMaxCacheSize



DNS_STATUS
cfg_SetRecursionTimeout(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit SrvCfg_dwRecursionTimeout value to appropriate value.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  recursion timeout MUST be reasonable value for proper
    //      operation
    //
    //  if zero, never launch recursion
    //  if too big, keep lots of packets around
    //

    if ( pValue->dwValue > MAX_RECURSION_TIMEOUT )
    {
        pValue->dwValue = MAX_RECURSION_TIMEOUT;
    }
    else if ( pValue->dwValue < MIN_RECURSION_TIMEOUT )
    {
        pValue->dwValue = MIN_RECURSION_TIMEOUT;
    }

    SrvCfg_dwRecursionTimeout = pValue->dwValue;

    return PROPERTY_NOWRITE;
}



DNS_STATUS
cfg_SetAdditionalRecursionTimeout(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit SrvCfg_dwAdditionalRecursionTimeout value to appropriate value.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    if ( pValue->dwValue > MAX_RECURSION_TIMEOUT )
    {
        pValue->dwValue = MAX_RECURSION_TIMEOUT;
    }
    else if ( pValue->dwValue < MIN_RECURSION_TIMEOUT )
    {
        pValue->dwValue = MIN_RECURSION_TIMEOUT;
    }

    SrvCfg_dwAdditionalRecursionTimeout = pValue->dwValue;

    return PROPERTY_NOWRITE;
}   //  cfg_SetAdditionalRecursionTimeout



#if DBG
DNS_STATUS
cfg_SetDebugLevel(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set\reset actual debug flag, turning on debugging as necessary.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //  actual debug flag is separate global, so that we can
    //  debug this code on load
    //  reset if
    //      - NOT startup or
    //      - no current debug flag
    //
    //  in effect give the file flag an override of registry value

    if ( !bLoad || DnsSrvDebugFlag==0 )
    {
        //  If dnslib logging is not yet turned on, start it up
        //  with minimal debug flags.

        if ( ( !pDnsDebugFlag || *pDnsDebugFlag == 0 ) && pValue->dwValue )
        {
            Dns_StartDebug(
                0x1000000D,
                NULL,
                NULL,
                DNS_DEBUG_FILENAME,
                DNS_SERVER_DEBUG_LOG_WRAP
                );
        }

        //  Set server debug log level.

        DNS_PRINT(( "DebugFlag reset to %p\n", pValue->dwValue ));
        DnsSrvDebugFlag = pValue->dwValue;

        return ERROR_SUCCESS;
    }

    //
    //  if loading and already have DebugFlag, then write
    //  its value to SrvCfg value so that it is visible to admin
    //

    else
    {
        SrvCfg_dwDebugLevel = DnsSrvDebugFlag;
        return PROPERTY_NOWRITE;
    }
}
#endif



DNS_STATUS
cfg_SetNoRecursion(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set\reset fRecursionAvailable flag based on
    value of NoRecursion property.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    PROPERTY_UPDATE_BOOTFILE -- boot file must be rewritten when this changes

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    SrvCfg_fRecursionAvailable = !pValue->dwValue;

    return( PROPERTY_UPDATE_BOOTFILE );
}



DNS_STATUS
cfg_SetScavengingInterval(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit scavenging interval value to appropriate value.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    //
    //  on load, no other action
    //

    if ( bLoad )
    {
        return ERROR_SUCCESS;
    }

    //
    //  runtime -- reset scavenge timer for new interval
    //      - not forcing scavenge now
    //      - need to set interval so it's picked up in timer reset
    //

    SrvCfg_dwScavengingInterval = pValue->dwValue;
    Scavenge_TimeReset();

    return ERROR_SUCCESS;
}



DNS_STATUS
cfg_SetDoNotRoundRobinTypes(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set types that will not be round robined. By default all types
    are RRed. The types are delivered in a WSTR.

    DEVNOTE: I have not yet implemented this setting via RPC since
    an array of words isn't easily added as a new setting. My thought
    is to add it as a simple WSTR setting and have the server do the
    parsing.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    LPSTR   pszTypeString = NULL;
    INT     iTypeCount = 0;
    PWORD   pwTypeArray = NULL;
    INT     idx;

    ASSERT( pValue );
    ASSERT( pValue->pwszValue );
    ASSERT( pValue->dwPropertyType == DNS_REG_WSZ );

    if ( !pValue ||
        pValue->dwPropertyType != DNS_REG_WSZ ||
        !pValue->pwszValue )
    {
        goto Cleanup;
    }

    //
    //  Allocate a UTF8 copy of the type string for dnslib routine.
    //

    pszTypeString = Dns_StringCopyAllocate(
                            ( PCHAR ) pValue->pwszValue,
                            0,
                            DnsCharSetUnicode,
                            DnsCharSetUtf8 );
    if ( !pszTypeString )
    {
        goto Cleanup;
    }

    //
    //  Parse the type string into a type array.
    //

    if ( Dns_CreateTypeArrayFromMultiTypeString(
                pszTypeString,
                &iTypeCount,
                &pwTypeArray ) != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  Reset the default value for all types to the default, then
    //  reset the specified types to zero.
    //  DEVNOTE: possible thread-safe issue here but no possibility
    //  of disastrous outcome (ie. no possible AV).
    //

    for ( idx = 0;
        RecordTypePropertyTable[ idx ][ RECORD_PROP_ROUND_ROBIN ] !=
            RECORD_PROP_TERMINATOR;
        ++idx ) 
    {
        RecordTypePropertyTable[ idx ][ RECORD_PROP_ROUND_ROBIN ] = 1;
    }

    for ( idx = 0; idx < iTypeCount; ++idx ) 
    {
        INT     iPropIndex = INDEX_FOR_QUERY_TYPE( pwTypeArray[ idx ] );

        if ( iPropIndex != 0 )
        {
            RecordTypePropertyTable
                [ iPropIndex ][ RECORD_PROP_ROUND_ROBIN ] = 0;
        }
    }

    //
    //  Save the new array in the global SrvCfg - this will only be
    //  used if the "DoNotRoundTobin" type list is queried through RPC.
    //

    SrvCfg_dwNumDoNotRoundRobinTypes = 0;       //  MT protection
    Timeout_Free( SrvCfg_pwDoNotRoundRobinTypeArray );
    SrvCfg_pwDoNotRoundRobinTypeArray = pwTypeArray;
    SrvCfg_dwNumDoNotRoundRobinTypes = iTypeCount;
    pwTypeArray = NULL;                         //  So we don't free below

    //
    //  Free allocated stuff and return.
    //

    Cleanup:

    FREE_HEAP( pszTypeString );
    FREE_HEAP( pwTypeArray );

    return ERROR_SUCCESS;
}




#if DBG
DWORD
SrvCfg_UpdateDnsTime(
    IN      LPSTR           pszFile,
    IN      INT             LineNo
    )
/*++

Routine Description:

Arguments:

    pszFile         -- name of file logging the event
    LineNo          -- line number of call to event logging

Return Value:

    New DNS time.

--*/
{
    DNS_TIME() = Dns_GetCurrentTimeInSeconds();

    DNS_DEBUG( TIMEOUT, (
        "DNS_TIME() = %d  ... set in file %s, line %d\n",
        DNS_TIME(),
        pszFile,
        LineNo ));

    return DNS_TIME();
}

#endif

//
//  End srvcfg.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\socket.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    socket.c

Abstract:

    Domain Name System (DNS) Server

    Listening socket setup.

Author:

    Jim Gilroy (jamesg)     November, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Winsock version
//

#ifdef DNS_WINSOCK1
#define DNS_WINSOCK_VERSION (0x0101)    //  Winsock 1.1
#else
#define DNS_WINSOCK_VERSION (0x0002)    //  Winsock 2.0
#endif


//
//  Server name in DBASE format
//

DB_NAME  g_ServerDbaseName;

//
//  Backlog on listen, before dropping
//

#define LISTEN_BACKLOG 20

//
//  Default allocation for socket list
//

#define DEFAULT_SOCKET_ARRAY_COUNT (30)

//
//  Hostents only return 35 IP addresses.  If hostent contains
//  35, we do NOT know if more exist.
//

#define HOSTENT_MAX_IP_COUNT    (35)

//
//  Count number of listen sockets == number of interfaces.
//
//  Warn user when use is excessive.
//  Use smaller recv buffer size when socket count gets larger.
//

INT     g_UdpBoundSocketCount;

#define MANY_IP_WARNING_COUNT       (10)
#define SMALL_BUFFER_SOCKET_COUNT   (3)

//
//  Socket receive buffers
//  If only a few sockets, we can increase the default buffer size
//  substaintially to avoid dropping packets.  If many sockets must
//  leave buffer at default.
//

#define UDP_MAX_RECV_BUFFER_SIZE    (0x10000)  // 64k max buffer

DWORD   g_UdpRecvBufferSize;

//
//  TCP send buffer size
//      - strictly informational
//

DWORD   g_SendBufferSize;

//
//  Socket list
//
//  Keep list of ALL active sockets, so we can cleanly insure that
//  they are all closed on shutdown.
//

#define DNS_SOCKLIST_UNINITIALIZED  (0x80000000)

INT                 g_SocketListCount = DNS_SOCKLIST_UNINITIALIZED;
LIST_ENTRY          g_SocketList;
CRITICAL_SECTION    g_SocketListCs;
UINT                g_OverlapCount;

#define LOCK_SOCKET_LIST()      EnterCriticalSection( &g_SocketListCs )
#define UNLOCK_SOCKET_LIST()    LeaveCriticalSection( &g_SocketListCs )


//
//  Combined socket-list and debug print lock
//
//  To avoid deadlock, during Dbg_SocketList() print, MUST take socket list
//  lock OUTSIDE of debug print lock.   This is because Dbg_SocketList() will
//  do printing while holding the socket list lock.
//
//  So if Dbg_SocketList will be wrapped with other prints in a lock, use
//  the combined lock below to take the locks in the correct order.
//

#define LOCK_SOCKET_LIST_DEBUG()        { LOCK_SOCKET_LIST();  Dbg_Lock(); }
#define UNLOCK_SOCKET_LIST_DEBUG()      { UNLOCK_SOCKET_LIST();  Dbg_Unlock(); }


//
//  Flag to indicate need to retry receives on UDP sockets
//

BOOL    g_fUdpSocketsDirty;


//
//  Server IP addresses
//      ServerAddrs -- all IPs on the box
//      BoundAddrs -- the IPs we are or should be listening on
//          (intersection of server addresses and listen addresses)
//

PDNS_ADDR_ARRAY     g_ServerIp4Addrs = NULL;
PDNS_ADDR_ARRAY     g_ServerIp6Addrs = NULL;
PDNS_ADDR_ARRAY     g_BoundAddrs = NULL;


//
//  UDP send socket
//
//  For multi-homed DNS server, there is a problem with sending server
//  server initiated queries (recursion, SOA, NOTIFY), on a socket
//  that is EXPLICITLY BOUND to a particular IP address.  The stack will
//  put that address as the IP source address -- regardless of interface
//  chosen to reach remote server.  And the remote server may not have
//  a have a route back to the source address given.
//
//  To solve this problem, we keep a separate global UDP send socket,
//  that -- at least for multi-homed servers -- is bound to INADDR_ANY.
//  For single IP address servers, this can be the same as a listening
//  socket.
//
//  Keep another variable to indicate if the UDP send socket is bound
//  to INADDR_ANY.  This enables us to determine whether need new UDP
//  send socket or need to close old socket, when a PnP event or listen
//  list change occurs.
//

SOCKET  g_UdpSendSocket;
SOCKET  g_UdpZeroBoundSocket;


//
//  Non-DNS port operation
//
//  To allow admins to firewall off the DNS port (53), there is a
//  registry parameter to force send sockets to be bound to another
//  port.
//  Init value to unused (for DNS) port to distinguish from values in use.
//

WORD    g_SendBindingPort;


//
//  TCP send sockets
//
//  A similar, but less serious problem exists for TCP sends for
//  zone transfers.  If we are multi-homed and only listening on a
//  subset of the machines addresses, then connecting with a socket
//  bound to INADDR_ANY, will not necessarily result in a connection
//  from one of the DNS interfaces.  If the receiving DNS server
//  requires a connection from one of those addresses (secondary security)
//  then it will fail.
//
//  Our solution to this is to use the IP address of the socket that
//  received the SOA query response.  This eliminates the need to
//  determine safe, reachable bind() address.  We are always using a
//  valid address on the machine that is also an address that the primary
//  DNS can respond to.
//


//
//  TCP listen-on-all socket (bound to INADDR_ANY)
//
//  Since TCP is connection oriented, no need to explicitly bind()
//  TCP sockets in order to satisfy client that it is talking to the
//  correct address.
//  Hence only need to explictly bind TCP listening sockets when server
//  is operating on only a subset of the total addresses.  Otherwise
//  can bind to single INADDR_ANY socket.  Keep a global to this listen-on-all
//  socket so we can take the appropriate action when PnP event or listen
//  list change, changes the appropriate use.
//

SOCKET      g_TcpZeroBoundSocket;


//
//  Listening fd_set
//

FD_SET      g_fdsListenTcp;


//
//  IPv6 listen sockets:
//

SOCKET      g_TcpListenSocketV6;
SOCKET      g_UdpListenSocketV6;


//
//  Hard-coded IP6 DNS server addresses.
//

DNS_ADDR    g_Ip6DnsServerAddrs[ 3 ];


//
//  Private protos
//

DNS_STATUS
openListeningSockets(
    VOID
    );

DNS_STATUS
Sock_CreateSocketsForIpArray(
    IN      PDNS_ADDR_ARRAY     pIpArray,
    IN      INT                 SockType,
    IN      WORD                Port,
    IN      DWORD               Flags
    );

DNS_STATUS
Sock_ResetBoundSocketsToMatchIpArray(
    IN      PDNS_ADDR_ARRAY     pIpArray,
    IN      INT                 SockType,
    IN      WORD                Port,
    IN      DWORD               Flags,
    IN      BOOL                fCloseZeroBound
    );

DNS_STATUS
Sock_CloseSocketsListeningOnUnusedAddrs(
    IN      PDNS_ADDR_ARRAY     pIpArray,
    IN      INT                 iSockType,
    IN      BOOL                fIncludeZeroBound,
    IN      BOOL                fIncludeLoopback
    );

SOCKET
Sock_GetAssociatedSocket(
    IN      PDNS_ADDR       ipAddr,
    IN      INT             SockType
    );


//  DEVNOTE: move to DNS lib

LPSTR
Dns_GetLocalDnsName(
    VOID
    );



VOID
Sock_Free(
    IN OUT  PDNS_SOCKET     pSocket
    )
/*++

Routine Description:

    Free socket structure.

Arguments:

    pSocket -- socket to free

Return Value:

    None

--*/
{
    if ( pSocket )
    {
        DeleteCriticalSection( &pSocket->LockCs );
        FREE_TAGHEAP(
            pSocket->OvlArray,
            g_OverlapCount * sizeof ( OVL ),
            MEMTAG_SOCKET );
        FREE_HEAP( pSocket );
    }
}   //  Sock_Free



DNS_STATUS
Sock_ReadAndOpenListeningSockets(
    VOID
    )
/*++

Routine Description:

    Read listen address list and open listening sockets.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    DWORD               length;
    DWORD               countIp;
    INT                 i;
    BOOLEAN             fregistryListen;
    WSADATA             wsaData;
    PCHAR               pszhostFqdn;
    struct hostent *    phostent;
    PIP_ADDRESS         pIpAddresses = NULL;
    PDNS_ADDR_ARRAY     dnsapiArrayIpv4 = NULL;
    PDNS_ADDR_ARRAY     dnsapiArrayIpv6 = NULL;

    DNS_DEBUG( SOCKET, ( "Sock_ReadAndOpenListeningSockets()\n" ));

    //
    //  init socket globals
    //
    //  see descriptions at top;
    //  we re-init here to allow for server restart
    //

    g_hUdpCompletionPort = INVALID_HANDLE_VALUE;

    g_UdpBoundSocketCount = 0;

    g_UdpRecvBufferSize = 0;

    g_SendBufferSize = 0;

    g_SocketListCount = DNS_SOCKLIST_UNINITIALIZED;

    g_fUdpSocketsDirty = FALSE;

    g_ServerIp4Addrs = NULL;
    g_ServerIp6Addrs = NULL;
    g_BoundAddrs = NULL;

    g_UdpSendSocket = 0;
    g_UdpZeroBoundSocket = 0;
    g_SendBindingPort = 1;
    g_TcpZeroBoundSocket = 0;
    g_TcpListenSocketV6 = 0;
    g_UdpListenSocketV6 = 0;

    if ( g_ProcessorCount == 1 )
    {
        g_OverlapCount = 2;
    }
    else
    {
        g_OverlapCount = g_ProcessorCount;
    }

    //
    //  Initialize server addr globals. There is probably
    //  a better way to do this, but for now this is fine.
    //
    //  fec0:0:0:ffff::1, fec0:0:0:ffff::2, fec0:0:0:ffff::3
    //

    for ( i = 0; i < 3; ++i )
    {
        IP6_ADDRESS     ip6;

        RtlZeroMemory( &ip6, sizeof( ip6 ) );
        ip6.IP6Byte[ 00 ] = 0xFE;
        ip6.IP6Byte[ 01 ] = 0xC0;
        ip6.IP6Byte[ 06 ] = 0xFF;
        ip6.IP6Byte[ 07 ] = 0xFF;
        ip6.IP6Byte[ 15 ] = ( UCHAR ) ( i + 1 );

        DnsAddr_BuildFromIp6(
            &g_Ip6DnsServerAddrs[ i ],
            &ip6,
            0,                          //  scope
            DNS_PORT_NET_ORDER );
    }

    //
    //  init socket list
    //

    status = DnsInitializeCriticalSection( &g_SocketListCs );
    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    InitializeListHead( &g_SocketList );
    g_SocketListCount = 0;

    //
    //  create UDP i/o completion port
    //

    g_hUdpCompletionPort = CreateIoCompletionPort(
                                INVALID_HANDLE_VALUE,
                                NULL,
                                0,
                                g_ProcessorCount );
    if ( !g_hUdpCompletionPort )
    {
        ASSERT( g_hUdpCompletionPort );
        goto Cleanup;
    }
    DNS_DEBUG( SOCKET, (
        "Created UDP i/o completion port %p\n",
        g_hUdpCompletionPort ));

    //
    //  start winsock
    //

    status = WSAStartup( DNS_WINSOCK_VERSION, &wsaData );
    if ( status == SOCKET_ERROR )
    {
        status = WSAGetLastError();
        DNS_PRINT(( "ERROR:  WSAStartup failure %d.\n", status ));
        goto Cleanup;
    }

    //
    //  read server host name
    //
    //  check if change from previous hostname, if not
    //  then NULL out previous field which serves as flag for
    //  need to upgrade default records (ex. SOA primary DNS)
    //

    SrvCfg_pszServerName = Dns_GetLocalDnsName();

    if ( !SrvCfg_pszServerName )
    {
        DNS_PRINT(( "ERROR:  no server name return!!!\n" ));
        SrvCfg_pszServerName = "FixMe";
    }

    else if ( SrvCfg_pszPreviousServerName &&
        strcmp( SrvCfg_pszPreviousServerName, SrvCfg_pszServerName ) == 0 )
    {
        DNS_DEBUG( INIT, (
            "Previous server name <%s>, same as current <%s>\n",
            SrvCfg_pszPreviousServerName,
            SrvCfg_pszServerName ) );

        FREE_HEAP( SrvCfg_pszPreviousServerName );
        SrvCfg_pszPreviousServerName = NULL;
    }

    //
    //  DEVNOTE: temp hack while GetComputerNameEx is confused
    //

    {
        INT lastIndex = strlen( SrvCfg_pszServerName ) - 1;

        DNS_DEBUG( INIT, (
            "Server name <%s>, lastIndex = %d\n",
            SrvCfg_pszServerName,
            lastIndex ));

        if ( lastIndex &&
            SrvCfg_pszServerName[ lastIndex ] == '.' &&
            SrvCfg_pszServerName[ lastIndex-1 ] == '.' )
        {
            SrvCfg_pszServerName[ lastIndex ] = 0;
        }
    }

    //  save server name as DBASE name

    status = Name_ConvertFileNameToCountName(
                & g_ServerDbaseName,
                SrvCfg_pszServerName,
                0 );
    if ( status == DNS_ERROR_INVALID_NAME )
    {
        ASSERT( FALSE );
        goto Cleanup;
    }

    //  warn when using single label name

    if ( g_ServerDbaseName.LabelCount <= 1 )
    {
         DNS_LOG_EVENT(
            DNS_EVENT_SINGLE_LABEL_HOSTNAME,
            0,
            NULL,
            NULL,
            0 );
    }

    //
    //  Get all IPv4 addresses on server.
    //

    dnsapiArrayIpv4 = ( PDNS_ADDR_ARRAY )
        DnsQueryConfigAllocEx(
            DnsConfigLocalAddrsIp4,
            NULL,                       //  adapter name
            FALSE );                    //  local alloc
    if ( !dnsapiArrayIpv4 )
    {
        DNS_DEBUG( ANY, (
            "ERROR: could not retrieve local IPv4 list from DnsQueryConfigAlloc\n" ));
        status = ERROR_NO_NETWORK;
        goto Cleanup;
    }

    DnsAddrArray_SetPort( dnsapiArrayIpv4, DNS_PORT_NET_ORDER );
    
    g_ServerIp4Addrs = DnsAddrArray_CreateCopy( dnsapiArrayIpv4 );
    if ( !g_ServerIp4Addrs )
    {
        status = ERROR_NO_NETWORK;
        goto Cleanup;
    }

    IF_DEBUG( INIT )
    {
        DnsDbg_DnsAddrArray(
            "Server IPv4 addresses:",
            NULL,
            g_ServerIp4Addrs );
    }

    if ( SrvCfg_dwEnableIPv6 )
    {
        //
        //  Get all IPv6 addresses on server.
        //

        dnsapiArrayIpv6 = ( PDNS_ADDR_ARRAY )
            DnsQueryConfigAllocEx(
                DnsConfigLocalAddrsIp6,
                NULL,                       //  adapter name
                FALSE );                    //  local alloc
        if ( dnsapiArrayIpv6 )
        {
            DnsAddrArray_SetPort( dnsapiArrayIpv6, DNS_PORT_NET_ORDER );
            
            g_ServerIp6Addrs = DnsAddrArray_CreateCopy( dnsapiArrayIpv6 );
            if ( !g_ServerIp6Addrs )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Cleanup;
            }

            IF_DEBUG( INIT )
            {
                DnsDbg_DnsAddrArray(
                    "Server IPv6 addresses:",
                    NULL,
                    g_ServerIp6Addrs );
            }
        }
        else
        {
            //
            //  It's possible to enable IPv6 without actually installing the
            //  IPv6 stack. This should not be treated as an error condition.
            //

            DNS_DEBUG( ANY, (
                "WARNING: could not retrieve local IPv6 list from DnsQueryConfigAlloc\n" ));
            status = ERROR_SUCCESS;
        }
    }
    
    //
    //  check admin configured IP addresses from registry
    //

    if ( SrvCfg_aipListenAddrs )
    {
        IF_DEBUG( INIT )
        {
            DnsDbg_DnsAddrArray(
                "Listen IP addresses from registry",
                NULL,
                SrvCfg_aipListenAddrs );
        }
        DnsAddrArray_DeleteIp4( SrvCfg_aipListenAddrs, 0 );
        IF_DEBUG( INIT )
        {
            DnsDbg_DnsAddrArray(
                "After NULLs deleted",
                NULL,
                SrvCfg_aipListenAddrs );
        }
        fregistryListen = TRUE;

        //
        //  get array of addresses that are in listen list AND
        //      available on the machines
        //

        if ( g_BoundAddrs )
        {
            Timeout_FreeDnsAddrArray( g_BoundAddrs );
        }

        DnsAddrArray_Diff(
            g_ServerIp4Addrs,
            SrvCfg_aipListenAddrs,
            DNSADDR_MATCH_IP,
            NULL, NULL,
            &g_BoundAddrs );

        IF_DEBUG( SOCKET )
        {
            DnsDbg_DnsAddrArray(
                "Bound IP addresses:",
                NULL,
                g_BoundAddrs );
        }

        //
        //  if ListenAddress list was busted or out of date, may not
        //  have intersection between bindings and listen list
        //

        if ( g_BoundAddrs->AddrCount == 0 )
        {
            IF_DEBUG( ANY )
            {
                DNS_PRINT((
                    "ERROR:  Listen Address list contains no valid entries.\n" ));
                DnsDbg_DnsAddrArray(
                    "Listen IP addresses from registry",
                    NULL,
                    SrvCfg_aipListenAddrs );
            }

            FREE_HEAP( g_BoundAddrs );
            g_BoundAddrs = DnsAddrArray_CreateCopy( g_ServerIp4Addrs );
            IF_NOMEM( !g_BoundAddrs )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Cleanup;
            }

            FREE_HEAP( SrvCfg_aipListenAddrs );
            SrvCfg_aipListenAddrs = NULL;
            fregistryListen = FALSE;

            Reg_DeleteValue(
                0,                      //  flags
                NULL,
                NULL,
                DNS_REGKEY_LISTEN_ADDRESSES );

            DNS_LOG_EVENT(
                DNS_EVENT_INVALID_LISTEN_ADDRESSES,
                0,
                NULL,
                NULL,
                0 );
        }

        //
        //  log a warning, if listen list contains addresses not on machine
        //

        else if ( g_BoundAddrs->AddrCount
                    < SrvCfg_aipListenAddrs->AddrCount )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_UPDATE_LISTEN_ADDRESSES,
                0,
                NULL,
                NULL,
                0 );
        }

        DnsAddrArray_DeleteIp4( g_BoundAddrs, 0 );
    }

    //
    //  no explicit listen addresses, use ALL server addresses
    //
    //  log warning if hostent list was completely full, because in this
    //  case we may have dropped addresses that user wanted to have server
    //  respond to
    //
    //  screen out zero IPs -- unconnected RAS adapters show up as
    //  zero IPs in list
    //

    else
    {
        g_BoundAddrs = DnsAddrArray_CreateCopy( g_ServerIp4Addrs );
        IF_NOMEM( ! g_BoundAddrs )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }
#if 0
        Dns_CleanIpArray(
            g_BoundAddrs,
            SrvCfg_fListenOnAutonet
                ?   DNS_IPARRAY_CLEAN_ZERO
                :   (DNS_IPARRAY_CLEAN_ZERO | DNS_IPARRAY_CLEAN_AUTONET)
            );
#endif
        DnsAddrArray_DeleteIp4( g_BoundAddrs, INADDR_ANY );
        IF_DEBUG( INIT )
        {
            DnsDbg_DnsAddrArray(
                "After Eliminating NULLs we are listening on:",
                NULL,
                g_BoundAddrs );
        }
        fregistryListen = FALSE;
    }

    //
    //  Setup connection list
    //

    if ( !Tcp_ConnectionListInitialize() )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    //
    //  open listening sockets
    //

    FD_ZERO( &g_fdsListenTcp );         // zero listening FD_SETS

    status = openListeningSockets();

    IF_DEBUG( INIT )
    {
        DnsDbg_DnsAddrArray(
            "Server IP addresses:",
            NULL,
            g_ServerIp4Addrs );
        DnsDbg_DnsAddrArray(
            "Bound IP addresses:",
            NULL,
            g_BoundAddrs );
    }
    
    Cleanup:
    
    DnsFreeConfigStructure( dnsapiArrayIpv4, DnsConfigLocalAddrsIp4 );
    DnsFreeConfigStructure( dnsapiArrayIpv6, DnsConfigLocalAddrsIp6 );

    return status;
}



DNS_STATUS
Sock_ChangeServerIpBindings(
    VOID
    )
/*++

Routine Description:

    Change IP interface bindings of DNS server.

    May be called due to
        - PnP event (service controller sends PARAMCHANGE)
        - listen list is altered by admin

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_INVALID_IP_ADDRESS if listen change and no valid listening addrs.
    Error code on failure.

--*/
{
    DWORD               countIp;
    PDNS_ADDR_ARRAY     machineAddrs = NULL;
    PDNS_ADDR_ARRAY     newBoundAddrs = NULL;
    PDNS_ADDR_ARRAY     dnsapiArray = NULL;
    DWORD               status;
    BOOL                bpnpChange = FALSE;

    dnsapiArray = ( PDNS_ADDR_ARRAY )
        DnsQueryConfigAllocEx(
            DnsConfigLocalAddrsIp4,
            NULL,                       //  adapter name
            FALSE );
    if ( !dnsapiArray )
    {
        status = ERROR_NO_NETWORK;
        goto Exit;
    }

    DnsAddrArray_SetPort( dnsapiArray, DNS_PORT_NET_ORDER );

    machineAddrs = DnsAddrArray_CreateCopy( dnsapiArray );
    if ( !machineAddrs )
    {
        ASSERT( machineAddrs );
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }
    ASSERT_IF_HUGE_ARRAY( machineAddrs );

    IF_DEBUG( SOCKET )
    {
        LOCK_SOCKET_LIST_DEBUG();
        DNS_PRINT(( "Sock_ChangeServerIpBindings()\n" ));
        Dbg_SocketList( "Socket list before change:" );
        DnsDbg_DnsAddrArray(
            "New machine Addrs:",
            NULL,
            machineAddrs );
        UNLOCK_SOCKET_LIST_DEBUG();
    }

    Config_UpdateLock();

    //
    //  specific listen addresses
    //      - either listen address or machine addresss may be new
    //      - compute intersection of listen and machine addresses,
    //      then diff with what is currently bound to DNS server to figure
    //      out what should be started
    //

    if ( SrvCfg_aipListenAddrs )
    {
        status = DnsAddrArray_Diff(
                    machineAddrs,
                    SrvCfg_aipListenAddrs,
                    DNSADDR_MATCH_IP,
                    NULL, NULL,
                    &newBoundAddrs );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "DnsIntersectionofIpArrays failed with %p\n", status ));
            goto Exit;
        }
        ASSERT_IF_HUGE_ARRAY( newBoundAddrs );

        //  check that have an intersection, if entering new addresses from admin

        if ( newBoundAddrs->AddrCount == 0 && SrvCfg_fListenAddrsStale )
        {
            status = DNS_ERROR_INVALID_IP_ADDRESS;
            goto Exit;
        }
    }

    //  no listening addrs, then will bind to all addrs
    //
    //  screen out zero IPs -- unconnected RAS adapters show up as
    //  zero IPs in list

    else
    {
        newBoundAddrs = DnsAddrArray_CreateCopy( machineAddrs );
        IF_NOMEM( !newBoundAddrs )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
#if 0
        Dns_CleanIpArray(
            newBoundAddrs,
            SrvCfg_fListenOnAutonet
                ?   DNS_IPARRAY_CLEAN_ZERO
                :   (DNS_IPARRAY_CLEAN_ZERO | DNS_IPARRAY_CLEAN_AUTONET)
            );
#endif
        DnsAddrArray_DeleteIp4( newBoundAddrs, 0 );
    }
    IF_DEBUG( SOCKET )
    {
        DnsDbg_DnsAddrArray(
            "New binding addrs:",
            NULL,
            newBoundAddrs );
    }

    //
    //  detect if actual PnP change
    //
    //  socket code figures differences directly in socket lists,
    //  which is more robust if a socket is lost;
    //
    //  however for determining if change has actually occured --
    //  for purposes of rebuilding default records (below), want
    //  to know if actual change
    //

    if ( !DnsAddrArray_IsEqual(
                newBoundAddrs,
                g_BoundAddrs,
                DNSADDR_MATCH_IP ) )
    {
        DNS_DEBUG( PNP, (
            "New binding list after PnP, different from previous\n" ));
        bpnpChange = TRUE;
    }

    //  no protection required here
    //      - timeout free keeps other users happy
    //      - only doing this on SC thread, so no race

    Timeout_FreeDnsAddrArray( g_ServerIp4Addrs );
    g_ServerIp4Addrs = machineAddrs;
    machineAddrs = NULL;        // skip free

    Timeout_FreeDnsAddrArray( g_BoundAddrs );
    g_BoundAddrs = newBoundAddrs;
    newBoundAddrs = NULL;       // skip free

    //
    //  open sockets for the newly arrived folks and closesockets for those
    //  guys who have left the building
    //
    //  DEVNOTE: PnP clean up;  when open listen socket, assoc. completion port
    //

    status = openListeningSockets();
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "openListeningSockets failed with %d %p\n", status, status ));
        goto Exit;
    }

    status = Sock_StartReceiveOnUdpSockets();

Exit:

    ASSERT_IF_HUGE_ARRAY( SrvCfg_aipListenAddrs );
    ASSERT_IF_HUGE_ARRAY( g_ServerIp4Addrs );
    ASSERT_IF_HUGE_ARRAY( g_BoundAddrs  );

    IF_DEBUG( SOCKET )
    {
        LOCK_SOCKET_LIST_DEBUG();
        DNS_PRINT(( "Leaving Sock_ChangeServerIpBindings()\n" ));
        Dbg_SocketList( "Socket list after PnP:" );
        DnsDbg_DnsAddrArray(
            "New bound addrs:",
            NULL,
            g_BoundAddrs );
        UNLOCK_SOCKET_LIST_DEBUG();
    }

    Config_UpdateUnlock();

    //  free IP arrays in error path

    FREE_HEAP( machineAddrs );
    FREE_HEAP( newBoundAddrs );

    //
    //  update auto-configured records for local DNS registration
    //
    //  note:  there's a problem with PnP activity causing DNS client
    //  to do delete update to remove DNS server's own address;
    //  to protect against this we'll redo the auto-config, even if
    //  we detect no change;  except we'll protect against needlessly
    //  do
    //

    Zone_UpdateOwnRecords( TRUE );
    
    DnsFreeConfigStructure( dnsapiArray, DnsConfigLocalAddrsIp4 );

    return status;
}



DNS_STATUS
openListeningSockets(
    VOID
    )
/*++

Routine Description:

    Open listen sockets on addresses specified.

Arguments:

    None.

Globals:

    Read access to server IP addr list globals:
        g_BoundAddrs
        SrvCfg_aipListenAddrs
        g_ServerIp4Addrs

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    SOCKET      s;
    SOCKET      previousUdpZeroSocket;
    BOOL        fneedSendSocket = FALSE;
    BOOL        flistenOnAll;
    WORD        bindPort = htons( ( WORD ) SrvCfg_dwSendPort );
    DWORD       status;
    DWORD       flags;
    DWORD       sockCreateflags = DNSSOCK_LISTEN | DNSSOCK_REUSEADDR;

    if ( bindPort == DNS_PORT_NET_ORDER )
    {
        sockCreateflags |= DNSSOCK_NO_EXCLUSIVE;
    }

    //
    //  implemenation note
    //
    //  note, i've reworked this code so that all the socket closure (and removal)
    //  is done at the end;  i believe it is now in a state where we'll always
    //  have a valid socket
    //

    LOCK_SOCKET_LIST();

    ASSERT( g_BoundAddrs );

    ASSERT( !SrvCfg_aipListenAddrs ||
        (SrvCfg_aipListenAddrs->AddrCount >= g_BoundAddrs->AddrCount) );

    ASSERT( g_ServerIp4Addrs->AddrCount >= g_BoundAddrs->AddrCount );

    //
    //  determine if currently using all interfaces
    //  if no listen list, then obviously listening on all
    //  if listen list, then must verify that all addresses certainly
    //
    //  DEVNOTE: assumes ServerAddresses contains no dups
    //

    flistenOnAll = ! SrvCfg_aipListenAddrs;
    if ( !flistenOnAll )
    {
        flistenOnAll = ( g_ServerIp4Addrs->AddrCount == g_BoundAddrs->AddrCount );
    }

    //
    //  UDP sockets
    //
    //  to make sure we return to client with source IP the same as IP
    //  the client sent to, UDP listen sockets are ALWAYS bound to specific
    //  IP addresses
    //
    //  set UDP receive buffer size
    //  if small number of sockets, use large receive buffer
    //  if many sockets, this is too expensive, so we use default
    //  variable itself serves as the flag
    //

    if ( g_BoundAddrs->AddrCount <= 3 )
    {
        g_UdpRecvBufferSize = UDP_MAX_RECV_BUFFER_SIZE;
    }
    else if ( g_BoundAddrs->AddrCount > MANY_IP_WARNING_COUNT )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_MANY_IP_INTERFACES,
            0,
            NULL,
            NULL,
            0 );
    }

    //
    //  open\close bound UDP sockets to match current bound addrs
    //
    //  If the BindPort is set to the DNS port, we cannot use exclusive
    //  socket mode because we will need to open multiple sockets on this
    //  port!
    //

    flags = DNSSOCK_REUSEADDR | DNSSOCK_LISTEN;
    if ( bindPort == DNS_PORT_NET_ORDER )
    {
        flags |= DNSSOCK_NO_EXCLUSIVE;
    }
    status = Sock_ResetBoundSocketsToMatchIpArray(
                g_BoundAddrs,
                SOCK_DGRAM,
                DNS_PORT_NET_ORDER,
                flags,
                FALSE );                //  do not close zero-bound, handled below

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  creating UDP listen sockets %p (%d)\n",
            status, status ));
    }

    //  may run with no interfaces now for PnP

    if ( g_UdpBoundSocketCount == 0 )
    {
        DNS_PRINT(( "WARNING:  no UDP listen sockets!!!\n" ));
        ASSERT( g_BoundAddrs->AddrCount == 0 );

        Log_Printf( "WARNING:  NO UDP listen sockets!\r\n" );
    }
    
    //
    //  Open UDP IPv6 listening sockets. For .Net we are going to listen
    //  on the ANY address and not support a listen address list.
    //
    
    if ( SrvCfg_dwEnableIPv6 && g_ServerIp6Addrs )
    {
        DNS_ADDR    dnsAddr;
        DWORD       i;
        
        DnsAddr_BuildFromIp6(
            &dnsAddr,
            ( PIP6_ADDRESS ) &in6addr_any,
            0,      // no scope
            DNS_PORT_NET_ORDER );
        
        s = Sock_CreateSocket(
                    SOCK_DGRAM,
                    &dnsAddr,
                    sockCreateflags | DNSSOCK_NO_EVENT_LOGS );
        if ( s == INVALID_SOCKET )
        {
            DNS_DEBUG( ANY, (
                "Error creating UDP IPv6 listen socket\n" ));
        }
        else
        {
            g_UdpListenSocketV6 = s;
        }
        
        //
        //  Bind explicitly to each of the machines IPv6 addresses. This
        //  is required so that DNS client's will see the corrent IPv6
        //  source address on response packets.
        //
        
        for ( i = 0; i < g_ServerIp6Addrs->AddrCount; ++i )
        {
            if ( !DNS_ADDR_IS_IP6( &g_ServerIp6Addrs->AddrArray[ i ] ) )
            {
                continue;
            }
            
            s = Sock_CreateSocket(
                        SOCK_DGRAM,
                        &g_ServerIp6Addrs->AddrArray[ i ],
                        sockCreateflags |
                            DNSSOCK_NO_EVENT_LOGS |
                            DNSSOCK_NO_EXCLUSIVE );
            if ( s == DNS_INVALID_SOCKET )
            {
                DNS_DEBUG( ANY, (
                    "Error creating UDP IPv6 listen socket\n" ));
            }
        }
        
        //
        //  Bind explicitly to the pre-defined DNS server IPv6 addresses.
        //

        for ( i = 0; i < 3; ++i )
        {
            s = Sock_CreateSocket(
                        SOCK_DGRAM,
                        &g_Ip6DnsServerAddrs[ i ],
                        sockCreateflags |
                            DNSSOCK_NO_EVENT_LOGS |
                            DNSSOCK_NO_EXCLUSIVE );
            if ( s == DNS_INVALID_SOCKET )
            {
                DNS_DEBUG( ANY, (
                    "Error creating UDP IPv6 DNS server address socket\n" ));
            }
        }
    }

    //
    //  send sockets:
    //      -- determine UDP send socket
    //      -- determine TCP send socket port binding
    //
    //  four basic cases:
    //
    //  0) not sending on port-53
    //  in this case must have separate send socket
    //
    //  1) single socket for DNS
    //  in this case just use it, all DNS traffic
    //
    //  2) all IP interfaces used by DNS
    //  in this case, use INADDR_ANY socket;  stack selects best
    //  interface, but since DNS will be listening on whatever it
    //  selects, we're ok
    //
    //  3) multiple IPs, some not used
    //  in this case, use first interface;  we'll be broken in the case
    //  of disjoint nets, but there's nothing we can do about it anyway
    //
    //  Note:  DisjointNets "fix" is only guaranteed to work in case #2.
    //  In case #3 there may be a problem depending on the whether the IP
    //  the stack selects is used by the DNS server.  However, for backward
    //  compatibility, we'll at least TRY the INADDR_ANY socket when
    //  DisjointNets is setup -- in some cases it will suffice.
    //
    //
    //  non-DNS port binding
    //
    //  some folks who wish to firewall off DNS queries, will
    //  want to do sends on non-DNS port (non-53);
    //  this UDP socket must be added to listen list in order to receive
    //  responses, but it will use the same binding address as selected
    //  by the three cases above;  currently just using INADDR_ANY in all
    //  cases
    //
    //  DEVNOTE: need to handle no active interfaces when load case
    //
    //  DEVNOTE: better solution:  always go INADDR_ANY to send, screen out queries
    //              on that socket accepting only sends
    //
    //  DEVNOTE: probably best to default to opening non-53 send socket, only
    //              do 53 when forced
    //

    //  backward compatibility

    fneedSendSocket = TRUE;

    //  if binding port is DNS port, then need special handling
    //      - if single interface, just use it -- no send socket necessary
    //      - if listening on all interfaces -- build ANY_ADDR socket
    //      - if not listening on some interfaces (refused port 53 bind)
    //

    if ( bindPort == DNS_PORT_NET_ORDER )
    {
        if ( g_UdpBoundSocketCount == 1 )
        {
            //  only listening on one socket, so just use it for send

            fneedSendSocket = FALSE;
        }
        else if ( !flistenOnAll )
        {
            //  multi-homed and not using all interfaces;  to protect against
            //  disjoint nets the safest course is to go off port 53

            bindPort = 0;
            DNS_LOG_EVENT(
                DNS_EVENT_NON_DNS_PORT,
                0,
                NULL,
                NULL,
                0 );

        }
    }

    //
    //  UDP send socket uses first listen socket
    //      - this is "listening-on-one-socket" case above
    //      - note, may have multiple IP in g_BoundAddrs, but have failed
    //      to bind to all but one (perhaps NOT the first one);  in that case
    //      just build non-53 send socket
    //
    //  DEVNOTE: or create zero-bound non-listening send socket
    //      - desired IPs have sockets that get packets that match them
    //      - small tcp/ip recv buffer gets filled, but never recv
    //          so quickly just drop on floor
    //

    previousUdpZeroSocket = g_UdpZeroBoundSocket;

    if ( !fneedSendSocket )
    {
        PDNS_ADDR   pdnsddr = &g_BoundAddrs->AddrArray[ 0 ];

        s = Sock_GetAssociatedSocket( pdnsddr, SOCK_DGRAM );
        if ( s != DNS_INVALID_SOCKET )
        {
            g_UdpSendSocket = s;
            g_UdpZeroBoundSocket = 0;
        }
        else
        {
            DNS_DEBUG( ANY, (
                "ERROR:  No UDP socket on bound IP %s"
                "    can NOT use as send socket, building separate send socket.\n",
                DNSADDR_STRING( pdnsddr ) ));
            bindPort = 0;
            fneedSendSocket = TRUE;
        }
    }

    //
    //  need INADDR_ANY UDP send socket
    //
    //  if previous zero bound UDP send socket exists, we can use it
    //  as long as we haven't done a port switch (to or from non-53)
    //
    //  non-53 bound socket must listen to recv() responses
    //  53 send socket only exists when already listening on all IP interfaces
    //      sockets, so no need to listen on it
    //
    //  DEVNOTE: allow for port 53 usage of disjoint send by screening response
    //              then

    if ( fneedSendSocket && bindPort != g_SendBindingPort )
    {
        DNS_ADDR    dnsAddr;
        
        DnsAddr_BuildFromIp4(
            &dnsAddr,
            INADDR_ANY,
            bindPort );

        s = Sock_CreateSocket(
                    SOCK_DGRAM,
                    &dnsAddr,
                    sockCreateflags );
        if ( s == DNS_INVALID_SOCKET )
        {
            status = WSAGetLastError();
            DNS_PRINT((
                "ERROR:  Failed to open UDP send socket.\n"
                "    port = %hx\n",
                bindPort ));
            status = ERROR_INVALID_HANDLE;
            goto Failed;
        }
        g_UdpSendSocket = s;
        g_SendBindingPort = bindPort;
        g_UdpZeroBoundSocket = s;
    }

    //
    //  close any previous unbound UDP send socket
    //  can happen when
    //      - no longer using unbound send socket
    //      - switch to or from using non-53 port
    //
    //  UDP send socket which was listen socket need not be closed;  it was
    //  either already closed OR is still in use
    //

    if ( previousUdpZeroSocket &&
        previousUdpZeroSocket != g_UdpSendSocket )
    {
        Sock_CloseSocket( previousUdpZeroSocket );
    }

    //
    //  TCP sockets -- two main cases
    //
    //  1) listening on ALL
    //      - use single INADDR_ANY bound socket
    //      (this saves non-paged pool and instructions during recvs())
    //      - close any previous individually bound sockets
    //      - then create single listen socket
    //
    //  2) listen on individual sockets
    //      - close any listen on all socket
    //      - close any sockets on remove addrs (like UDP case)
    //      - open sockets on new addrs (like UDP)
    //
    //  Note, reuseaddr used with all listening sockets, simply to avoid
    //  failure when attempt to create new socket, right after close of
    //  previous listen socket.  Winsock (or the stack) may not be cleaned
    //  up enough to allow the create to succeed.
    //

    if ( flistenOnAll )
    {
        Sock_CloseSocketsListeningOnUnusedAddrs(
                NULL,           // remove all bound TCP sockets
                SOCK_STREAM,
                FALSE,          // don't remove zero bound (if exists)
                FALSE );        // don't close loopback -- though don't need it

        if ( !g_TcpZeroBoundSocket )
        {
            DNS_ADDR    dnsAddr;
            
            DnsAddr_BuildFromIp4(
                &dnsAddr,
                0,
                DNS_PORT_NET_ORDER );

            s = Sock_CreateSocket(
                        SOCK_STREAM,
                        &dnsAddr,
                        sockCreateflags );
            if ( s == DNS_INVALID_SOCKET )
            {
                DNS_PRINT(( "ERROR:  unable to create zero-bound TCP socket!\n" ));
                goto Failed;
            }
            ASSERT( g_TcpZeroBoundSocket == s );
        }
    }

    //
    //  listening on individual interfaces
    //
    //  handle like UDP:
    //      - close sockets for IP not currently in Bound list
    //      - create sockets for bound IP, that do not currently exist
    //

    else
    {
        status = Sock_ResetBoundSocketsToMatchIpArray(
                    g_BoundAddrs,
                    SOCK_STREAM,
                    DNS_PORT_NET_ORDER,
                    DNSSOCK_REUSEADDR | DNSSOCK_LISTEN,
                    TRUE );             // close zero-bound also
    }

#if 0
    //
    //  listening on individual interfaces
    //
    //  two cases:
    //      1) currently have zero bound
    //          - kill all TCP listens and rebuild
    //          - rebuild entire bound list
    //
    //      2) currently mixed socket list
    //          - kill only remove sockets
    //          - rebuild new addrs list
    //

    else if ( g_TcpZeroBoundSocket )   // listen on individual addresses
    {

        //  remove zero bound socket
        //      -- just remove all TCP listens for robustness

        Sock_CloseSocketsListeningOnAddrs(
                NULL,
                SOCK_STREAM,
                TRUE );                 //  and remove zero bound socket

        ASSERT( g_TcpZeroBoundSocket == 0 );

        //  open socket on all bound interfaces

        Sock_CreateSocketsForIpArray(
            g_BoundAddrs,
            SOCK_STREAM,
            DNS_PORT_NET_ORDER,
            sockCreateflags );
    }

    else    // no zero bound socket
    {
        if ( pRemoveAddrs )
        {
            Sock_CloseSocketsListeningOnAddrs(
                    pRemoveAddrs,       //  remove retiring addresses
                    SOCK_STREAM,
                    TRUE );             //  and remove zero bound socket
        }
        ASSERT( g_TcpZeroBoundSocket == 0 );

        //  open new interfaces

        Sock_CreateSocketsForIpArray(
            pAddAddrs,
            SOCK_STREAM,
            DNS_PORT_NET_ORDER,
            sockCreateflags );
    }
#endif

    //
    //  Open TCP IPv6 listening socket. For .Net we are going to listen
    //  on the ANY address and not support a listen address list.
    //
    
    if ( SrvCfg_dwEnableIPv6 && g_ServerIp6Addrs )
    {
        DNS_ADDR    dnsAddr;
        DWORD       i;
        
        DnsAddr_BuildFromIp6(
            &dnsAddr,
            ( PIP6_ADDRESS ) &in6addr_any,
            0,      // no scope
            DNS_PORT_NET_ORDER );

        s = Sock_CreateSocket(
                    SOCK_STREAM,
                    &dnsAddr,
                    sockCreateflags | DNSSOCK_NO_EVENT_LOGS );
        if ( s == DNS_INVALID_SOCKET )
        {
            DNS_DEBUG( ANY, (
                "Error creating TCP IPv6 listen socket\n" ));
        }
        else
        {
            g_TcpListenSocketV6 = s;
        }

        //
        //  Bind explicitly to each of the machines IPv6 addresses. This
        //  is required so that DNS client's will see the corrent IPv6
        //  source address on response packets.
        //
        
        for ( i = 0; i < g_ServerIp6Addrs->AddrCount; ++i )
        {
            if ( !DNS_ADDR_IS_IP6( &g_ServerIp6Addrs->AddrArray[ i ] ) )
            {
                continue;
            }
            
            s = Sock_CreateSocket(
                        SOCK_STREAM,
                        &g_ServerIp6Addrs->AddrArray[ i ],
                        sockCreateflags | DNSSOCK_NO_EVENT_LOGS );
            if ( s == DNS_INVALID_SOCKET )
            {
                DNS_DEBUG( ANY, (
                    "Error creating TCP IPv6 listen socket\n" ));
            }
        }

        //
        //  Bind explicitly to the pre-defined DNS server IPv6 addresses.
        //

        for ( i = 0; i < 3; ++i )
        {
            s = Sock_CreateSocket(
                        SOCK_STREAM,
                        &g_Ip6DnsServerAddrs[ i ],
                        sockCreateflags |
                            DNSSOCK_NO_EVENT_LOGS |
                            DNSSOCK_NO_EXCLUSIVE );
            if ( s == DNS_INVALID_SOCKET )
            {
                DNS_DEBUG( ANY, (
                    "Error creating TCP IPv6 DNS server address socket\n" ));
            }
        }
    }

    status = ERROR_SUCCESS;

Failed:

    IF_DEBUG( SOCKET )
    {
        LOCK_SOCKET_LIST_DEBUG();
        Dbg_SocketList( "Socket list after openListeningSockets():" );
        DNS_PRINT((
            "    SendBindingPort = %hx\n",
            ntohs( g_SendBindingPort ) ));
        DnsDbg_FdSet(
            "TCP Listen fd_set:",
            & g_fdsListenTcp );
        UNLOCK_SOCKET_LIST_DEBUG();
    }

    //
    //  wake TCP select() to rebuild array
    //  even if failure need to try to run with what we have
    //

    UNLOCK_SOCKET_LIST();

    Tcp_ConnectionListReread();

    return status;
}   //  openListeningSockets



//
//  Socket creation functions.
//

SOCKET
Sock_CreateSocket(
    IN      INT             SockType,
    IN      PDNS_ADDR       pDestAddr,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Create socket.

Arguments:

    SockType -- SOCK_DGRAM or SOCK_STREAM

    pDestAddr -- address to listen on

    Flags -- socket usage flags
    
Return Value:

    Socket if successful.
    DNS_INVALID_SOCKET otherwise.

--*/
{
    SOCKET              s;
    INT                 err;
    INT                 bindCount = 0;

    //
    //  create socket
    //      - for winsock 2.0, UDP sockets must be overlapped
    //

    if ( SockType == SOCK_DGRAM )
    {
        s = WSASocket(
                pDestAddr->SockaddrIn6.sin6_family,
                SockType,
                IPPROTO_UDP,
                NULL,       // no protocol info
                0,          // no group
                WSA_FLAG_OVERLAPPED );

        if ( s == INVALID_SOCKET )
        {
            if ( !( Flags & DNSSOCK_NO_EVENT_LOGS ) )
            {
                DNS_LOG_EVENT(
                    DNS_EVENT_CANNOT_CREATE_UDP_SOCKET,
                    0,
                    NULL,
                    NULL,
                    GetLastError() );
            }
            goto Failed;
        }
    }
    else
    {
        s = socket( pDestAddr->SockaddrIn6.sin6_family, SockType, 0 );

        if ( s == INVALID_SOCKET )
        {
            if ( !( Flags & DNSSOCK_NO_EVENT_LOGS ) )
            {
                DNS_LOG_EVENT(
                    DNS_EVENT_CANNOT_CREATE_TCP_SOCKET,
                    0,
                    NULL,
                    NULL,
                    GetLastError() );
            }
            goto Failed;
        }
#if DBG
        if ( ! g_SendBufferSize )
        {
            DWORD   optionLength = sizeof(DWORD);

            getsockopt( s, SOL_SOCKET, SO_SNDBUF, (PCHAR)&g_SendBufferSize, &optionLength );
            DNS_DEBUG( ANY, (
                "TCP send buffer length = %d\n",
                g_SendBufferSize ));
        }
#endif
    }
    ASSERT( s != 0 && s != INVALID_SOCKET );

    //
    //  grab exclusive ownership of this socket
    //      - prevents ordinary user from using
    //
    //  IPv6: Disable this feature if IPv6 is enabled. I have found
    //  that I am unable to bind an IPv6 socket if there is an
    //  IPv4 socket on the same port bound with EXCLUSIVEADDRUSE.
    //

    if ( pDestAddr->SockaddrIn6.sin6_port != 0 &&
         SockType == SOCK_DGRAM &&
         !( Flags & DNSSOCK_NO_EXCLUSIVE ) &&
         !SrvCfg_dwEnableIPv6 )
    {
        DWORD   optval = 1;

        err = setsockopt(
                s,
                SOL_SOCKET,
                SO_EXCLUSIVEADDRUSE,
                (char *) &optval,
                sizeof( DWORD ) );
        if ( err )
        {
            ASSERT( err == SOCKET_ERROR );
            DNS_DEBUG( INIT, (
                "ERROR:  setsockopt(%d, EXCLUSIVEADDRUSE) failed.\n"
                "    with error = %d.\n",
                s,
                GetLastError() ));
        }
    }

    //
    //  Bind socket. Use a loop to retry with SO_REUSEADDR if necessary.
    //
    //  IPV6NOTE: this is broken for addresses other than INADDR_ANY
    //

    while ( 1 )
    {
        CHAR    szaddr[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

        err = bind( s, &pDestAddr->Sockaddr, pDestAddr->SockaddrLength );
        if ( err == 0 )
        {
            break;
        }
        err = ( INT ) GetLastError();

        DnsAddr_WriteIpString_A( szaddr, pDestAddr );

        DNS_DEBUG( INIT, (
            "Failed to bind() socket %d, to port %d, address %s.\n"
            "    error = %d.\n",
            s,
            ntohs( pDestAddr->SockaddrIn6.sin6_port ),
            szaddr,
            err ));

        //
        //  If the bind fails with error WSAEADDRINUSE, try clearing
        //  SO_EXCLUSIVEADDRUSE and setting SO_REUSEADDR. Not that these
        //  two options are mutually exclusive, so if EXCL is set it is
        //  not possible to set REUSE.
        //

        if ( bindCount == 0  &&  err == WSAEADDRINUSE )
        {
            BOOL    optval = 0;
            INT     terr;

            terr = setsockopt(
                    s,
                    SOL_SOCKET,
                    SO_EXCLUSIVEADDRUSE,
                    (char *) &optval,
                    sizeof(BOOL) );
            DNS_DEBUG( INIT, (
                "setsockopt(%d, EXCLUSIVEADDRUSE, %d) %s\n"
                "    with error = %d.\n",
                s,
                optval,
                terr == 0 ? "succeeded" : "failed",
                GetLastError() ));

            optval = 1;
            terr = setsockopt(
                    s,
                    SOL_SOCKET,
                    SO_REUSEADDR,
                    (char *) &optval,
                    sizeof(BOOL) );
            if ( terr == 0 )
            {
                DNS_DEBUG( INIT, (
                    "Attempt rebind on socket %d with REUSEADDR.\n",
                    s ));
                bindCount++;
                continue;
            }
            DNS_DEBUG( INIT, (
                "ERROR:  setsockopt(%d, REUSEADDR, %d) failed.\n"
                "    with error = %d.\n",
                s,
                optval,
                GetLastError() ));
        }

        //  log bind failure

        if ( !( Flags & DNSSOCK_NO_EVENT_LOGS ) )
        {
            PVOID   parg = szaddr;
            
            if ( SockType == SOCK_DGRAM )
            {
                DNS_LOG_EVENT(
                    DNS_EVENT_CANNOT_BIND_UDP_SOCKET,
                    1,
                    &parg,
                    EVENTARG_ALL_UTF8,
                    err );
            }
            else
            {
                DNS_LOG_EVENT(
                    DNS_EVENT_CANNOT_BIND_TCP_SOCKET,
                    1,
                    &parg,
                    EVENTARG_ALL_UTF8,
                    err );
            }
        }
        goto Failed;
    }

    //
    //  set as non-blocking?
    //
    //  this makes all accept()ed sockets non-blocking
    //

    if ( !( Flags & DNSSOCK_BLOCKING ) )
    {
        err = TRUE;
        ioctlsocket( s, FIONBIO, &err );
    }

    //
    //  listen on socket?
    //      - set actual listen for TCP
    //      - configure recv buffer size for UDP
    //
    //  if only a receiving interfaces (only a few UDP listen sockets),
    //  then set a 64K recv buffer per socket;
    //  this allows us to queue up roughly 1000 typical UDP messages
    //  if lots of sockets this is too expensive so stay with default 8K
    //

    if ( Flags & DNSSOCK_LISTEN )
    {
        if ( SockType == SOCK_STREAM )
        {
            err = listen( s, LISTEN_BACKLOG );
            if ( err == SOCKET_ERROR )
            {
                PVOID parg = pDestAddr;

                err = GetLastError();
                Sock_CloseSocket( s );

                if ( !( Flags & DNSSOCK_NO_EVENT_LOGS ) )
                {
                    DNS_LOG_EVENT(
                        DNS_EVENT_CANNOT_LISTEN_TCP_SOCKET,
                        1,
                        &parg,
                        EVENTARG_ALL_IP_ADDRESS,
                        err );
                }
                goto Failed;
            }
        }
        else if ( g_UdpRecvBufferSize )
        {
            if ( setsockopt(
                    s,
                    SOL_SOCKET,
                    SO_RCVBUF,
                    (PCHAR) &g_UdpRecvBufferSize,
                    sizeof(INT) ) )
            {
                DNS_PRINT((
                    "ERROR:  %d setting larger socket recv buffer on socket %d.\n",
                    WSAGetLastError(),
                    s ));
            }
        }

        if ( SockType == SOCK_DGRAM )
        {
            int     optval = 0xffffffff;
            int     optvalsize = sizeof( optval );

            getsockopt(
                s,
                SOL_SOCKET,
                SO_SNDBUF,
                ( PCHAR ) &optval,
                &optvalsize );

            optval = 50000;

            if ( setsockopt(
                    s,
                    SOL_SOCKET,
                    SO_SNDBUF,
                    ( PCHAR ) &optval,
                    sizeof( optval ) ) )
            {
                ASSERT( FALSE );
            }
        }
    }

    //
    //  add to socket to socket list
    //

    if ( ! ( Flags & DNSSOCK_NO_ENLIST ) )
    {
        Sock_EnlistSocket(
            s,
            SockType,
            pDestAddr,
            ( DNSSOCK_LISTEN & Flags ) );
    }

    DNS_DEBUG( SOCKET, (
        "Created socket %d, of type %d, for address %s port %d\n"
        "    listen = %d, reuse = %d, blocking = %d, exclusive = %d\n",
        s,
        SockType,
        DNSADDR_STRING( pDestAddr ),
        ntohs( pDestAddr->SockaddrIn6.sin6_port ),
        ( DNSSOCK_LISTEN & Flags ),
        ( DNSSOCK_REUSEADDR & Flags ),
        ( DNSSOCK_BLOCKING & Flags ),
        !( DNSSOCK_NO_EXCLUSIVE & Flags ) ));

    return s;

Failed:

    //
    //  DEVNOTE: different event for runtime socket create failure?
    //

    DNS_DEBUG( SOCKET, (
        "ERROR:  Unable to create socket of type %d, for address %s port %d\n"
        "    listen = %d, reuse = %d, blocking = %d\n",
        SockType,
        DNSADDR_STRING( pDestAddr ),
        ntohs( pDestAddr->SockaddrIn6.sin6_port ),
        ( DNSSOCK_LISTEN & Flags ),
        ( DNSSOCK_REUSEADDR & Flags ),
        ( DNSSOCK_BLOCKING & Flags ) ));

    if ( !( Flags & DNSSOCK_NO_EVENT_LOGS ) )
    {
        PVOID parg = pDestAddr;

        DNS_LOG_EVENT(
            DNS_EVENT_OPEN_SOCKET_FOR_ADDRESS,
            1,
            &parg,
            EVENTARG_ALL_IP_ADDRESS,
            0 );
    }

    if ( s != 0  &&  s != INVALID_SOCKET )
    {
        closesocket( s );
    }
    return DNS_INVALID_SOCKET;
}



DNS_STATUS
Sock_CreateSocketsForIpArray(
    IN      PDNS_ADDR_ARRAY     pIpArray,
    IN      INT                 SockType,
    IN      WORD                Port,
    IN      DWORD               Flags
    )
/*++

Routine Description:

    Create sockets for all values in IP array.

Arguments:

    pIpArray    -- IP array

    SockType    -- SOCK_DGRAM or SOCK_STREAM

    ipAddress   -- IP address to listen on (net byte order)

    Port        -- desired port in net order
                    - DNS_PORT_NET_ORDER for DNS listen sockets
                    - 0 for any port

    fReUseAddr  -- TRUE if reuseaddr

    fListen     -- TRUE if listen socket

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_INVALID_HANDLE if unable to create one or more sockets.

--*/
{
    SOCKET      s;
    DWORD       i;
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  loop through IP array creating socket on each address
    //

    for ( i = 0; i < pIpArray->AddrCount; ++i )
    {
        s = Sock_CreateSocket(
                SockType,
                &pIpArray->AddrArray[ i ],
                Flags );

        if ( s == DNS_INVALID_SOCKET )
        {
            status = GetLastError();
            continue;
        }
    }
    return status;
}



//
//  Socket list functions.
//
//  Maintain a list of sockets and their associated information.
//  This serves several functions:
//      - simple to close sockets on shutdown
//      - can determine IP binding from socket
//      - can find \ bind to completetion port
//

VOID
Sock_EnlistSocket(
    IN      SOCKET      Socket,
    IN      INT         SockType,
    IN      PDNS_ADDR   pDnsAddr,
    IN      BOOL        fListen
    )
/*++

Routine Description:

    Adds socket to dns socket list.

Arguments:

    socket -- socket to add

Return Value:

    None.

--*/
{
    PDNS_SOCKET pentry;
    INT         err;
    HANDLE      hport;

    //
    //  never add sockets after shutdown -- just kill 'em off
    //

    DNS_DEBUG( SOCKET, (
        "Enlisting socket %d type %d with ipaddr %s\n",
        Socket,
        SockType,
        DNSADDR_STRING( pDnsAddr ) ));
    IF_DEBUG( SOCKET )
    {
        Dbg_SocketList( "Socket list before enlist:" );
    }

    if ( fDnsServiceExit )
    {
        DNS_DEBUG( SHUTDOWN, (
            "Attempt to add socket %d to list after shutdown.\n"
            "    closing socket instead.\n",
            socket ));
        closesocket( Socket );
        return;
    }

    //
    //  stick socket on socket list
    //

    pentry = ( PDNS_SOCKET )
        ALLOC_TAGHEAP_ZERO( sizeof( DNS_SOCKET ), MEMTAG_SOCKET );
    IF_NOMEM( !pentry )
    {
        goto Cleanup;
    }

    pentry->OvlArray =
        ( POVL ) ALLOC_TAGHEAP_ZERO( ( g_OverlapCount * sizeof ( OVL ) ), MEMTAG_SOCKET );
    IF_NOMEM( !pentry->OvlArray )
    {
        goto Cleanup;
    }

    if ( DnsInitializeCriticalSection( &pentry->LockCs ) != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    DnsAddr_Copy( &pentry->ipAddr, pDnsAddr );

    pentry->Socket          = Socket;
    pentry->SockType        = SockType;
    pentry->fListen         = fListen;

    LOCK_SOCKET_LIST();

    InsertTailList( &g_SocketList, ( PLIST_ENTRY ) pentry );
    g_SocketListCount++;

    //  listen socket

    if ( fListen )
    {
        if ( SockType == SOCK_DGRAM )
        {
            if ( !DnsAddr_IsClear( &pentry->ipAddr ) )
            {
                ++g_UdpBoundSocketCount;
            }

            hport = CreateIoCompletionPort(
                        (HANDLE) Socket,
                        g_hUdpCompletionPort,
                        (UINT_PTR) pentry,
                        g_ProcessorCount );
            if ( !hport )
            {
                DNS_PRINT(( "ERROR: in CreateIoCompletionPort\n" ));
                ASSERT( FALSE );
                goto Unlock;
            }
            ASSERT( hport == g_hUdpCompletionPort );
        }
        else
        {
            ASSERT( SockType == SOCK_STREAM );

            FD_SET( Socket, &g_fdsListenTcp );
            if ( DnsAddr_IsClear( &pentry->ipAddr ) &&
                 DnsAddr_Family( &pentry->ipAddr ) == AF_INET )
            {
                g_TcpZeroBoundSocket = Socket;
            }
        }
    }

Unlock:

    UNLOCK_SOCKET_LIST();

    DNS_DEBUG( SOCKET, (
        "\nEnlisted socket %d type %d for IP %s\n",
        Socket,
        SockType,
        DNSADDR_STRING( pDnsAddr ) ));
    IF_DEBUG( SOCKET )
    {
        Dbg_SocketList( "Socket list after enlist:" );
    }
    return;

Cleanup:

    //
    //  There was an error - clean up partly-allocated socket entry
    //  and return.
    //

    if ( pentry )
    {    
        if ( pentry->OvlArray )
        {
            FREE_TAGHEAP(
                pentry->OvlArray,
                g_OverlapCount * sizeof ( OVL ),
                MEMTAG_SOCKET );
        }
        FREE_TAGHEAP( pentry, sizeof( DNS_SOCKET ), MEMTAG_SOCKET );
    }

    IF_DEBUG( SOCKET )
    {
        Dbg_SocketList( "Socket list after enlist failure:" );
    }

    return;
}



VOID
Sock_CloseSocket(
    IN      SOCKET      Socket
    )
/*++

Routine Description:

    Closes socket in socket list.

Arguments:

    socket -- socket to close

Return Value:

    None.

--*/
{
    PDNS_SOCKET pentry;
    INT         err;

    DNS_DEBUG( TCP, (
        "Closing socket %d and removing from list.\n",
        Socket ));

    //
    //  find socket in socket list
    //      - remove if in TCP listen list
    //      - dequeue and free
    //      - dec socket count
    //

    LOCK_SOCKET_LIST();

    for ( pentry = (PDNS_SOCKET) g_SocketList.Flink;
          pentry != (PDNS_SOCKET) &g_SocketList;
          pentry = (PDNS_SOCKET) pentry->List.Flink )
    {
        if ( pentry->Socket == Socket )
        {
            RemoveEntryList( (PLIST_ENTRY)pentry );

            if ( pentry->SockType == SOCK_STREAM &&
                 pentry->fListen )
            {
                FD_CLR( Socket, &g_fdsListenTcp );
            }
            Timeout_FreeWithFunction( pentry, Sock_Free );
            g_SocketListCount--;
            break;
        }
    }
    UNLOCK_SOCKET_LIST();

    //
    //  close it down
    //      - do this whether we found it or not
    //

    err = closesocket( Socket );

    IF_DEBUG( ANY )
    {
        if ( pentry == (PDNS_SOCKET) &g_SocketList )
        {
            DNS_PRINT((
                "ERROR:  closed socket %d, not found in socket list.\n",
                Socket ));
        }

        DNS_DEBUG( TCP, (
            "Closed socket %d -- error %d.\n",
            Socket,
            err ? WSAGetLastError() : 0 ));

        if ( err )
        {
            DNS_PRINT((
                "WARNING:  closesocket( %d ) error %d\n"
                "    socket was %s socket list.\n",
                Socket,
                WSAGetLastError(),
                ( pentry == (PDNS_SOCKET) &g_SocketList ) ? "in" : "NOT in" ));
        }
    }
}



PDNS_SOCKET
sockFindDnsSocketForIpAddr(
    IN      PDNS_ADDR       ipAddr,
    IN      INT             iSockType,
    IN      DWORD           addrMatchFlag
    )
/*++

Routine Description:

    Gets the socket info for a given ipaddress and type.
    Only interested in DNS port sockets.

Arguments:

    ipAddr -- IP address of socket entry to find

    iSockType -- type of socket desired
    
    addrMatchFlag -- match flag for DNS_ADDR - use
        DNSADDR_MATCH_ALL as default

Return Value:

    Ptr to DNS_SOCKET struct matching IP and type.
    NULL if not found.

--*/
{
    PDNS_SOCKET     pentry;

    LOCK_SOCKET_LIST();

    for ( pentry = ( PDNS_SOCKET ) g_SocketList.Flink;
          pentry != ( PDNS_SOCKET ) &g_SocketList;
          pentry = ( PDNS_SOCKET ) pentry->List.Flink )
    {
        if ( DnsAddr_IsEqual(
                &pentry->ipAddr,
                ipAddr,
                addrMatchFlag )  &&
             pentry->SockType == iSockType )
        {
            goto Done;
        }
    }
    pentry = NULL;

Done:

    UNLOCK_SOCKET_LIST();
    return pentry;
}



SOCKET
Sock_GetAssociatedSocket(
    IN      PDNS_ADDR       ipAddr,
    IN      INT             iSockType
    )
/*++

Routine Description:

    Gets the socket associated with a certain IP Address.
    This is the socket bound to the DNS port.

Arguments:

    ipAddr -- IP address of socket entry to find

    iSockType -- type of socket desired

Return Value:

    Socket, if socket found.
    Otherwise DNS_INVALID_SOCKET.

--*/
{
    PDNS_SOCKET     pentry;
    SOCKET          socket = 0;

    pentry = sockFindDnsSocketForIpAddr(
                    ipAddr,
                    iSockType,
                    DNSADDR_MATCH_ALL );
    if ( pentry )
    {
        socket = pentry->Socket;
    }
    return socket;
}



BOOL
Sock_GetAssociatedIpAddr(
    IN      SOCKET          Socket,
    OUT     PDNS_ADDR       pDnsAddr
    )
/*++

Routine Description:

    Gets the ipaddress associated with a certain socket

Arguments:

    Socket -- associated with an ipAddr
    
    pDnsAddr -- IP address for socket copied to this location

Return Value:

    FALSE if no socket found.

--*/
{
    INT             i;
    PDNS_SOCKET     pentry;
    BOOL            foundSocket = FALSE;

    ASSERT( pDnsAddr );

    LOCK_SOCKET_LIST();

    for ( pentry = (PDNS_SOCKET) g_SocketList.Flink;
          pentry != (PDNS_SOCKET) &g_SocketList;
          pentry = (PDNS_SOCKET) pentry->List.Flink )
    {
        if ( pentry->Socket == Socket )
        {
            foundSocket = TRUE;
            break;
        }
    }

    if ( foundSocket )
    {
        DnsAddr_Copy( pDnsAddr, &pentry->ipAddr );
    }
    else
    {
        DnsAddr_Reset( pDnsAddr );
    }

    UNLOCK_SOCKET_LIST();
    
    return foundSocket;
}




DNS_STATUS
Sock_StartReceiveOnUdpSockets(
    VOID
    )
/*++

Routine Description:

    Start receiving on any new sockets.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    INT             i;
    PDNS_SOCKET     pentry;
    DWORD           status;
    DWORD           failedCount = 0;

    DNS_DEBUG( SOCKET, (
        "StartReceiveOnUdpSockets()\n" ));

    STAT_INC( PrivateStats.UdpRestartRecvOnSockets );
#if DBG
    if ( g_fUdpSocketsDirty )
    {
        Dbg_SocketList( "Socket list entering StartReceiveOnUdpSockets()" );
    }
#endif
    if ( SrvCfg_fTest1 )
    {
        Log_Printf( "Start listen on UDP sockets!\r\n" );
    }

    //
    //  go through list of UDP sockets
    //  enable receive on those listening sockets without a pending receive
    //      - hPort serves as a flag indicating socket has pending recv
    //      - note:  zeroing retry, as when we are rebuilding here because of
    //      lots of WSAECONNRESET failures, don't want to reset and then have
    //      the a failure on first recv (quite likely if we got here in the
    //      first place) send us back here immediately
    //

    LOCK_SOCKET_LIST();

    for ( pentry = (PDNS_SOCKET) g_SocketList.Flink;
          pentry != (PDNS_SOCKET) &g_SocketList;
          pentry = (PDNS_SOCKET) pentry->List.Flink )
    {
        if ( pentry->SockType == SOCK_DGRAM  &&
                pentry->fListen  &&
                pentry->hPort == 0 )
        {
            pentry->hPort = g_hUdpCompletionPort;
            pentry->fRetry = 0;

            for ( i = 0; i < ( INT ) g_OverlapCount; i++ )
            {
                pentry->OvlArray[ i ].Index = i;
                Udp_DropReceive( pentry, i );
            }

            if ( pentry->hPort == 0 )
            {
                Log_SocketFailure(
                    "Start UDP listen failed!",
                    pentry,
                    0 );
                failedCount++;
            }
        }
    }

    //  all UDP listen sockets successfully listening?

    if ( failedCount == 0 )
    {
        g_fUdpSocketsDirty = FALSE;
    }
    else
    {
        LOCK_SOCKET_LIST_DEBUG();
        DNS_DEBUG( ANY, (
            "ERROR:  StartReceiveOnUdpSockets() failed!\n"
            "    failedCount = %d.\n",
            failedCount ));
        Dbg_SocketList( "Socket list after StartReceiveOnUdpSockets()" );
        ASSERT( g_fUdpSocketsDirty );
        UNLOCK_SOCKET_LIST_DEBUG();
    }

    UNLOCK_SOCKET_LIST();

    IF_DEBUG( SOCKET )
    {
        Dbg_SocketList( "Socket list after StartReceiveOnUdpSockets()" );
    }
    return ERROR_SUCCESS;
}



VOID
Sock_IndicateUdpRecvFailure(
    IN OUT  PDNS_SOCKET     pContext,
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Set a given socket\context to indicate failure of recv()

Arguments:

    pConext -- socket context

Return Value:

    None

--*/
{
    PDNS_SOCKET   pentry;
    DWORD         status;
    DWORD         finalStatus = ERROR_SUCCESS;

    DNS_DEBUG( ANY, (
        "ERROR:  Sock_IndicateUdpRecvFailure(), context = %p\n",
        pContext ));

    Log_SocketFailure(
        "ERROR:  RecvFrom() failed causing listen shutdown!",
        pContext,
        Status );

    //
    //  set flag under lock, so can't override reinitialization
    //

    STAT_INC( PrivateStats.UdpIndicateRecvFailures );
    LOCK_SOCKET_LIST();

    //  reset recv context to indicate error

    if ( pContext )
    {
        pContext->hPort = (HANDLE)NULL;
    }

    //  when flag set, reinitialization of uninitialized sockets will
    //      be done after timeout

    g_fUdpSocketsDirty = TRUE;

    UNLOCK_SOCKET_LIST();
}



VOID
Sock_CloseAllSockets(
    )
/*++

Routine Description:

    Close all outstanding sockets.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PDNS_SOCKET  pentry;
    SOCKET  s;
    INT     err;

    ASSERT( fDnsServiceExit );
    if ( g_SocketListCount == DNS_SOCKLIST_UNINITIALIZED )
    {
        return;
    }

    //
    //  close ALL outstanding sockets
    //

    IF_DEBUG( SHUTDOWN )
    {
        Dbg_SocketList( "Closing all sockets at shutdown:" );
    }

    LOCK_SOCKET_LIST();

    while ( !IsListEmpty(&g_SocketList) )
    {
        pentry = (PDNS_SOCKET) RemoveHeadList( &g_SocketList );
        g_SocketListCount--;

        s = pentry->Socket;

        err = closesocket( s );

        IF_DEBUG( SHUTDOWN )
        {
            DNS_PRINT((
                "Closing socket %d -- error %d.\n",
                s,
                err ? WSAGetLastError() : 0 ));
            DnsDebugFlush();
        }
        ASSERT( !err );

        Timeout_FreeWithFunction( pentry, Sock_Free );
    }

    UNLOCK_SOCKET_LIST();
}


#if DBG

VOID
Dbg_SocketContext(
    IN      LPSTR           pszHeader,
    IN      PDNS_SOCKET     pContext
    )
{
    DnsPrintf(
        "%s\n"
        "    ptr          = %p\n"
        "    socket       = %d (%c)\n"
        "    IP           = %s\n"
        "    port         = %d\n"
        "    state        = %d\n"
        "    listen       = %d\n"
        "    hPort        = %d\n"
        "    pCallback    = %p\n"
        "    dwTimeout    = %d\n",
        pszHeader ? pszHeader : "DNS Socket Context:",
        pContext,
        pContext->Socket,
        ( pContext->SockType == SOCK_DGRAM ) ? 'U' : 'T',
        DNSADDR_STRING( &pContext->ipAddr ),
        ntohs( DnsAddr_GetPort( &pContext->ipAddr ) ),
        pContext->State,
        pContext->fListen,
        pContext->hPort,
        pContext->pCallback,
        pContext->dwTimeout );
}



VOID
Dbg_SocketList(
    IN      LPSTR   pszHeader
    )
{
    PDNS_SOCKET   pentry;

    LOCK_SOCKET_LIST();

    Dbg_Lock();

    DnsPrintf(
        "%s\n"
        "    Socket count     = %d\n"
        "    TCP listen count = %d\n"
        "    TCP zero socket  = %d\n"
        "    TCP IPv6 socket  = %d\n"
        "    UDP bound count  = %d\n"
        "    UDP zero socket  = %d\n"
        "    UDP send socket  = %d\n"
        "    UDP IPv6 socket  = %d\n"
        "    sock\tAF\ttype\t      IP       \tport\tlisten\thPort\n"
        "    ----\t--\t----\t---------------\t----\t------\t-----\n",
        pszHeader ? pszHeader : "Socket List:",
        g_SocketListCount,
        g_fdsListenTcp.fd_count,
        g_TcpZeroBoundSocket,
        g_TcpListenSocketV6,
        g_UdpBoundSocketCount,
        g_UdpZeroBoundSocket,
        g_UdpSendSocket,
        g_UdpListenSocketV6 );

    for ( pentry = ( PDNS_SOCKET ) g_SocketList.Flink;
          pentry != ( PDNS_SOCKET ) &g_SocketList;
          pentry = ( PDNS_SOCKET ) pentry->List.Flink )
    {
        ASSERT( pentry );
        DnsPrintf(
            "    %4d\t%d\t%s\t%15s\t%4d\t%d\t%d\n",
            pentry->Socket,
            DnsAddr_Family( &pentry->ipAddr ),
            ( pentry->SockType == SOCK_DGRAM ) ? "UDP" : "TCP",
            DNSADDR_STRING( &pentry->ipAddr ),
            ntohs( DnsAddr_GetPort( &pentry->ipAddr ) ),
            pentry->fListen,
            pentry->hPort );
    }
    Dbg_Unlock();

    UNLOCK_SOCKET_LIST();
}
#endif

//
//  End socket.c
//



LPSTR
Dns_GetLocalDnsName(
    VOID
    )
/*++

Routine Description:

    Get DNS name of local machine.

    Name is returned in UTF8

Arguments:

    None

Return Value:

    Ptr to machines DNS name -- caller must free.
    NULL on error.

--*/
{
    DNS_STATUS      status;
    DWORD           length;
    DWORD           countIp;
    INT             i;
    PCHAR           pszname;
    DWORD           size;
    PCHAR           pszhostFqdn;
    struct hostent * phostent;
    ANSI_STRING     ansiString;
    UNICODE_STRING  unicodeString;
    CHAR            szhostName[ DNS_MAX_NAME_BUFFER_LENGTH + 1 ];
    WCHAR           wszhostName[ DNS_MAX_NAME_BUFFER_LENGTH + 1 ];

    DNSDBG( SOCKET, (
        "Dns_GetLocalDnsName()\n" ));

    //
    //  get local machines FQDN (in unicode)
    //  if fails settle for host name
    //

    size = DNS_MAX_NAME_BUFFER_LENGTH;

    if ( ! GetComputerNameExW(
                ComputerNameDnsFullyQualified,
                wszhostName,
                &size ) )
    {
        status = GetLastError();
        DNS_PRINT((
            "ERROR:  GetComputerNameExW() failed!\n"
            "    GetLastError = %d (%p)\n",
            status, status ));

        // reset size back to max buffer length
        size = DNS_MAX_NAME_BUFFER_LENGTH;

        if ( ! GetComputerNameExW(
                    ComputerNameDnsHostname,
                    wszhostName,
                    &size ) )
        {
            status = GetLastError();
            DNS_PRINT((
                "ERROR:  GetComputerNameExW() failed -- NO HOSTNAME!\n"
                "    GetLastError = %d (%p)\n",
                status, status ));
            ASSERT( FALSE );
            return NULL;
        }
    }

    DNSDBG( SOCKET, (
        "GetComputerNameEx() FQDN = <%S>\n"
        "    size = %d\n",
        wszhostName,
        size ));

    pszname = Dns_NameCopyAllocate(
                (PCHAR) wszhostName,
                size,
                DnsCharSetUnicode,   // unicode in
                DnsCharSetUtf8 );    // UTF8 out
    if ( !pszname )
    {
        ASSERT( FALSE );
        return NULL;
    }

    DNSDBG( SOCKET, (
        "GetComputerNameEx() FQDN UTF8 = <%s>\n",
        pszname ));
    return pszname;

    //
    //  read server host name
    //

    if ( gethostname( szhostName, DNS_MAX_NAME_LENGTH ) )
    {
        status = WSAGetLastError();
        DNS_PRINT(( "ERROR:  gethostname() failure %d.\n", status ));
        return NULL;
    }
    DNS_DEBUG( INIT, ( "DNS server hostname = %s\n", szhostName ));

    //  return hostname if that's all user wants
#if 0
    if ( )
    {
        pszname = Dns_CreateStringCopy( szhostName, 0 );
        if ( ! pszname )
        {
            SetLastError( DNS_ERROR_NO_MEMORY );
            return NULL;
        }
        return pszname;
    }
#endif

    //
    //  get server's hostent
    //      - contains alias list, use for server FQDN
    //      - contains IP address list
    //

    phostent = gethostbyname( szhostName );
    if ( ! phostent )
    {
        DNS_PRINT(( "ERROR:  gethostbyname() failure %d.\n", status ));
        return NULL;
    }

    //
    //  find server FQDN
    //      - if none available, use plain hostname

    DNSDBG( SOCKET, ( "Parsing hostent alias list.\n" ));

    i = -1;
    pszhostFqdn = phostent->h_name;

    while ( pszhostFqdn )
    {
        DNSDBG( SOCKET, (
            "Host alias[%d] = %s.\n",
            i,
            pszhostFqdn ));

        if ( strchr( pszhostFqdn, '.' ) )
        {
            break;
        }
        pszhostFqdn = phostent->h_aliases[++i];
    }
    if ( !pszhostFqdn )
    {
        pszhostFqdn = szhostName;
    }

    DNSDBG( SOCKET, (
        "ANSI local FQDN = %s.\n",
        pszhostFqdn ));

    //
    //  convert from ANSI to unicode, then over to UTF8
    //      - note, unicode string lengths in bytes NOT wchar count
    //

    RtlInitAnsiString(
        & ansiString,
        pszhostFqdn );

    unicodeString.Length = 0;
    unicodeString.MaximumLength = DNS_MAX_NAME_BUFFER_LENGTH*2 - 2;
    unicodeString.Buffer = wszhostName;

    status = RtlAnsiStringToUnicodeString(
                & unicodeString,
                & ansiString,
                FALSE );        // no allocation

    DNSDBG( SOCKET, (
        "Unicode local FQDN = %S.\n",
        unicodeString.Buffer ));

    pszname = Dns_NameCopyAllocate(
                    (PCHAR) unicodeString.Buffer,
                    (unicodeString.Length / 2),
                    DnsCharSetUnicode,   // unicode in
                    DnsCharSetUtf8 );    // UTF8 out

    DNSDBG( SOCKET, (
        "UTF8 local FQDN = %s.\n",
        pszname ));

    //
    //  DEVNOTE: to provide UTF8 need to take to unicode and back to UTF8
    //

    return pszname;
}




DNS_STATUS
Sock_CloseSocketsListeningOnUnusedAddrs(
    IN      PDNS_ADDR_ARRAY     pIpArray,
    IN      INT                 iSockType,
    IN      BOOL                fIncludeZeroBound,
    IN      BOOL                fIncludeLoopback
    )
/*++

Routine Description:

    Close listening sockets not in current listen IP array.

Arguments:

    pIpArray    -- array of IP addresses to listen on

    iSockType   -- socket type to close up on

    fIncludeZeroBound   -- close zero

    fIncludeLoopback    -- close loopback

Return Value:

    None.

--*/
{
    PDNS_SOCKET     pentry;
    PDNS_SOCKET     prevEntry;
    SOCKET          socket;
    PDNS_ADDR       pdnsaddr;

    LOCK_SOCKET_LIST();

    for ( pentry = (PDNS_SOCKET) g_SocketList.Flink;
          pentry != (PDNS_SOCKET) &g_SocketList;
          pentry = (PDNS_SOCKET) pentry->List.Flink )
    {
        DNS_DEBUG( PNP, (
            "Checking socket %d for closure\n",
            pentry->Socket ));

        if ( !pentry->fListen   ||
            ( iSockType && pentry->SockType != iSockType ) )
        {
            continue;
        }

        //
        //  ignore sockets
        //      - in passed in array (IPs still listening on)
        //      - INADDR_ANY (unless explictly configured to do so)
        //      - loopback (as we'll just have to rebind it anyway)
        //

        pdnsaddr = &pentry->ipAddr;
        if ( DnsAddr_IsClear( pdnsaddr ) )
        {
            if ( !fIncludeZeroBound )
            {
                continue;
            }
        }
        else if ( DnsAddr_IsLoopback( pdnsaddr, 0 ) )
        {
            if ( !fIncludeLoopback )
            {
                continue;
            }
        }
        else if ( pIpArray &&
                  DnsAddrArray_ContainsAddr(
                        pIpArray,
                        pdnsaddr,
                        DNSADDR_MATCH_IP ) )
        {
            continue;
        }

        socket = pentry->Socket;

        //
        //  Alter globals to reflect closure of this socket.
        //
        
        if ( socket == g_TcpListenSocketV6 )
        {
            g_TcpListenSocketV6 = 0;
        }
        if ( socket == g_UdpListenSocketV6 )
        {
            g_UdpListenSocketV6 = 0;
        }

        if ( pentry->SockType == SOCK_STREAM )
        {
            FD_CLR( socket, &g_fdsListenTcp );
            if ( DnsAddr_IsClear( pdnsaddr ) )
            {
                g_TcpZeroBoundSocket = 0;
            }
        }
        else
        {
            g_UdpBoundSocketCount--;
            ASSERT( (INT)g_UdpBoundSocketCount >= 0 );
        }

        //  DEVNOTE: who cleans up message?
        //      problem because can easily have active message
        //      even message being processed associated with context
        //
        //      could NULL pMsg in context when take off with it
        //      but still window when just woke on valid socket, right
        //      before this close -- don't want to have to run through
        //      lock
        //
        //  close socket
        //      - remove from list
        //      - mark dead
        //      - close
        //
        //  marking dead before and after close because want to have marked
        //  when close wakes other threads, BUT mark before close might be
        //  immediately overwritten by new WSARecvFrom() that just happens
        //  to be occuring on another thread;
        //  still tricky window through this, Sock_CleanupDeadSocket() finally
        //  handles the message cleanup atomically and insures the context rests
        //  in peace as DEAD
        //

        prevEntry = (PDNS_SOCKET) pentry->List.Blink;
        RemoveEntryList( (PLIST_ENTRY)pentry );
        g_SocketListCount--;

        ASSERT( (INT)g_SocketListCount >= 0 );
        pentry->State = SOCKSTATE_DEAD;

        closesocket( socket );
        pentry->State = SOCKSTATE_DEAD;

        Timeout_FreeWithFunction( pentry, Sock_Free );

        DNS_DEBUG( ANY, (
            "closed listening socket %d for IP %s ptr %p\n",
            socket,
            DNSADDR_STRING( pdnsaddr ),
            pentry ));

        pentry = prevEntry;
    }

    UNLOCK_SOCKET_LIST();
    return ERROR_SUCCESS;
}



DNS_STATUS
Sock_ResetBoundSocketsToMatchIpArray(
    IN      PDNS_ADDR_ARRAY     pIpArray,
    IN      INT                 SockType,
    IN      WORD                Port,
    IN      DWORD               Flags,
    IN      BOOL                fCloseZeroBound
    )
/*++

Routine Description:

    Create sockets for all values in IP array.

Arguments:

    pIpArray    -- IP array

    SockType    -- SOCK_DGRAM or SOCK_STREAM

    Port        -- desired port in net order
                    - DNS_PORT_NET_ORDER for DNS listen sockets
                    - 0 for any port

    Flags       -- flags to Sock_CreateSocket() call

    fCloseZeroBound -- close zero bound socket

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_INVALID_HANDLE if unable to create one or more sockets.

--*/
{
    SOCKET          s;
    DWORD           i;
    DNS_STATUS      status;
    PDNS_SOCKET     psock;
    DNS_ADDR        addr;

    DNS_DEBUG( SOCKET, (
        "Sock_ResetBoundSocketsToMatchIpArray()\n"
        "    IP array = %p (count = %d)\n"
        "    type     = %d\n"
        "    port     = %hx\n"
        "    flags    = %d\n",
        pIpArray,
        pIpArray->AddrCount,
        SockType,
        Port,
        Flags ));

    //
    //  close sockets for unused addresses
    //

    status = Sock_CloseSocketsListeningOnUnusedAddrs(
                pIpArray,
                SockType,
                fCloseZeroBound,        //  zero-bound close?
                FALSE );                //  not closing loopback

    //
    //  loop through IP array creating socket on each address
    //
    //  note:  assuming here that sockFindDnsSocketForIpAddr()
    //      only matches DNS port sockets;  and that we are only
    //      interested in DNS port;  if port can very need to add
    //      param to sockFindDnsSocketForIpAddr()
    //

    ASSERT( Port == DNS_PORT_NET_ORDER );

    for ( i = 0; i < pIpArray->AddrCount; ++i )
    {
        PDNS_ADDR       pdnsaddr = &pIpArray->AddrArray[ i ];

        DNS_DEBUG( SOCKET, (
            "    checking if binding for (type=%d) already exists for %s\n",
            SockType,
            DNSADDR_STRING( pdnsaddr ) ));

        psock = sockFindDnsSocketForIpAddr(
                    pdnsaddr,
                    SockType,
                    DNSADDR_MATCH_ALL );
        if ( psock )
        {
            DNS_DEBUG( SOCKET, (
                "    socket (type=%d) already exists for %s -- skip create.\n",
                SockType,
                DNSADDR_STRING( pdnsaddr ) ));
            continue;
        }

        s = Sock_CreateSocket( SockType, pdnsaddr, Flags );
        if ( s == DNS_INVALID_SOCKET )
        {
            status = GetLastError();
            continue;
        }
    }

    //
    //  special case loopback
    //
    //  DEVNOTE: loopback probably ought to be in calculating machine addrs
    //      this lets admin kill it in listen list -- good?  bad?
    //
    //  note:  finding loopback socket only works by relying on
    //  sockFindDnsSockForIpAddr() to only return DNS port matches;
    //  as there will always by TCP wakeup socket on loopback
    //

    DnsAddr_BuildFromIp4( &addr, ntohl( INADDR_LOOPBACK ), Port );
    psock = sockFindDnsSocketForIpAddr(
                &addr,
                SockType,
                DNSADDR_MATCH_ALL );
    if ( psock )
    {
        DNS_DEBUG( SOCKET, (
            "Loopback socket (type=%d) already exists\n",
            SockType ));
        goto Done;
    }

    DNS_DEBUG( SOCKET, (
        "Loopback address unbound, bind()ing.\n" ));

    s = Sock_CreateSocket(
            SockType,
            &addr,
            Flags );

    if ( s == DNS_INVALID_SOCKET )
    {
        DNS_STATUS tstatus = GetLastError();
        DNS_DEBUG( ANY, (
            "ERROR:  %p (%d), unable to bind() loopback address.\n",
            tstatus, tstatus ));
    }

    Done:
    
    DNS_DEBUG( SOCKET, (
        "Leave  Sock_ResetBoundSocketsToMatchIpArray()\n" ));

    return status;
}



VOID
Sock_CleanupDeadSocketMessage(
    IN OUT  PDNS_SOCKET     pContext
    )
/*++

Routine Description:

    Cleanup dead socket.

Arguments:

    pContext -- context for socket being recieved

Return Value:

    None.

--*/
{
    PDNS_MSGINFO pmsg;
    INT i;

    DNS_DEBUG( ANY, (
        "cleanupDeadThread( %p )\n",
        pContext ));

    ASSERT( pContext->State == SOCKSTATE_DEAD
            || pContext->State == SOCKSTATE_UDP_RECV_ERROR );

    //
    //  insure that pMsg is only cleaned up by one thread;
    //  also insures that socket finally ends up DEAD, and
    //  any threads woken will proceed through this function
    //  and drop the context
    //

    LOCK_SOCKET_LIST();

    for ( i=0; i < ( INT ) g_OverlapCount; i++ ) 
    {
        pmsg = pContext->OvlArray[ i ].pMsg;
        pContext->OvlArray[ i ].pMsg = NULL;

        if ( pmsg ) 
        {
            STAT_INC( PrivateStats.UdpSocketPnpDelete );
            Packet_FreeUdpMessage( pmsg );
        }
    }

    pContext->State = SOCKSTATE_DEAD;
    UNLOCK_SOCKET_LIST();
}


//
//  end of socket.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\stats.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    stats.c

Abstract:

    Domain Name System (DNS) Server

    Statics processing.

Author:

    Jim Gilroy (jamesg)  August 1995

Revision History:

--*/


#include "dnssrv.h"

//  Perfmon support

#include <winperf.h>

#include "datadns.h"           // perfmon header
#include "perfutil.h"
#include "perfconfig.h"

#include <loadperf.h>

#include <stdio.h>
#include <ctype.h>


//
//  Statistics globals
//

DWORD   beforeStats = BEFORE_BUF_VALUE;

DNSSRV_TIME_STATS           TimeStats;
DNSSRV_QUERY_STATS          QueryStats;
DNSSRV_QUERY2_STATS         Query2Stats;
DNSSRV_RECURSE_STATS        RecurseStats;
DNSSRV_MASTER_STATS         MasterStats;
DNSSRV_SECONDARY_STATS      SecondaryStats;
DNSSRV_WINS_STATS           WinsStats;
DNSSRV_UPDATE_STATS         WireUpdateStats;
DNSSRV_UPDATE_STATS         NonWireUpdateStats;
DNSSRV_SKWANSEC_STATS       SkwansecStats;
DNSSRV_DS_STATS             DsStats;
DNSSRV_MEMORY_STATS         MemoryStats;
DNSSRV_TIMEOUT_STATS        TimeoutStats;
DNSSRV_DBASE_STATS          DbaseStats;
DNSSRV_RECORD_STATS         RecordStats;
DNSSRV_PACKET_STATS         PacketStats;
DNSSRV_NBSTAT_STATS         NbstatStats;
DNSSRV_PRIVATE_STATS        PrivateStats;
DNSSRV_ERROR_STATS          ErrorStats;
DNSSRV_CACHE_STATS          CacheStats;

DWORD   afterStats = AFTER_BUF_VALUE;


//
//  Stats table
//
//  This simple lets us handle all the logic in loop
//  through various stat types.
//

DWORD   beforeStatsTable = BEFORE_BUF_VALUE;

struct StatsTableEntry StatsTable[] =
{
    DNSSRV_STATID_TIME,
        FALSE,
            sizeof(DNSSRV_TIME_STATS),
                & TimeStats,

    DNSSRV_STATID_QUERY,
        TRUE,
            sizeof(DNSSRV_QUERY_STATS),
                & QueryStats,

    DNSSRV_STATID_QUERY2,
        TRUE,
            sizeof(DNSSRV_QUERY2_STATS),
                & Query2Stats,

    DNSSRV_STATID_RECURSE,
        TRUE,
            sizeof(DNSSRV_RECURSE_STATS),
                & RecurseStats,

    DNSSRV_STATID_MASTER,
        TRUE,
            sizeof(DNSSRV_MASTER_STATS),
                & MasterStats,

    DNSSRV_STATID_SECONDARY,
        TRUE,
            sizeof(DNSSRV_SECONDARY_STATS),
                & SecondaryStats,

    DNSSRV_STATID_WINS,
        TRUE,
            sizeof(DNSSRV_WINS_STATS),
                & WinsStats,

    DNSSRV_STATID_WIRE_UPDATE,
        TRUE,
            sizeof(DNSSRV_UPDATE_STATS),
                & WireUpdateStats,

    DNSSRV_STATID_NONWIRE_UPDATE,
        TRUE,
            sizeof(DNSSRV_UPDATE_STATS),
                & NonWireUpdateStats,

    DNSSRV_STATID_SKWANSEC,
        TRUE,
            sizeof(DNSSRV_SKWANSEC_STATS),
                & SkwansecStats,

    DNSSRV_STATID_DS,
        TRUE,
            sizeof(DNSSRV_DS_STATS),
                & DsStats,

    DNSSRV_STATID_MEMORY,
        FALSE,
            sizeof(DNSSRV_MEMORY_STATS),
                & MemoryStats,

    DNSSRV_STATID_TIMEOUT,
        FALSE,
            sizeof(DNSSRV_TIMEOUT_STATS),
                & TimeoutStats,

    DNSSRV_STATID_DBASE,
        FALSE,
            sizeof(DNSSRV_DBASE_STATS),
                & DbaseStats,

    DNSSRV_STATID_RECORD,
        FALSE,
            sizeof(DNSSRV_RECORD_STATS),
                & RecordStats,

    DNSSRV_STATID_PACKET,
        FALSE,
            sizeof(DNSSRV_PACKET_STATS),
                & PacketStats,

    DNSSRV_STATID_NBSTAT,
        FALSE,
            sizeof(DNSSRV_NBSTAT_STATS),
                & NbstatStats,

    DNSSRV_STATID_ERRORS,
        FALSE,
            sizeof(DNSSRV_ERROR_STATS),
                & ErrorStats,

    DNSSRV_STATID_CACHE,
        FALSE,
            sizeof(DNSSRV_CACHE_STATS),
                & CacheStats,

    DNSSRV_STATID_PRIVATE,
        FALSE,
            sizeof(DNSSRV_PRIVATE_STATS),
                & PrivateStats,

    0, 0, 0, NULL   // termination
};
DWORD   afterStatsTable = AFTER_BUF_VALUE;


//
//  Private protos
//

VOID
perfmonCounterBlockInit(
    VOID
    );




VOID
Stats_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize DNS statistics.

Arguments:

    None

Return Value:

    None.

--*/
{
    PDNSSRV_STATS   pstat;
    DWORD           i;
    WORD            length;
    DNS_SYSTEMTIME  timeSystem;
    DWORD           secondsTime;

    //
    //  initialize all stat buffers
    //

    i = 0;
    while( pstat = (PDNSSRV_STATS) StatsTable[i].pStats )
    {
        pstat->Header.StatId    = StatsTable[i].Id;
        pstat->Header.fClear    = StatsTable[i].fClear;
        pstat->Header.fReserved = 0;

        length = StatsTable[i].wLength - sizeof(DNSSRV_STAT_HEADER);
        pstat->Header.wLength   = length;

        RtlZeroMemory(
            pstat->Buffer,
            length
            );
        i++;
    }

    //
    //  save server start time
    //  this is also time of last clear
    //

    secondsTime = GetCurrentTimeInSeconds();
    TimeStats.ServerStartTimeSeconds    = secondsTime;
    TimeStats.LastClearTimeSeconds      = secondsTime;

    GetSystemTime( ( PSYSTEMTIME ) &timeSystem );
    TimeStats.ServerStartTime   = timeSystem;
    TimeStats.LastClearTime     = timeSystem;

    //
    //  init perfmon block
    //

    perfmonCounterBlockInit();
}



VOID
deriveSkwansecStats(
    VOID
    )
/*++

Routine Description:

    Write SkwanSec stats to stats buffer.

Arguments:

    None

Return Value:

    None.

--*/
{
    //  security context caching stuff

    SkwansecStats.SecContextCreate              =   SecContextCreate;
    SkwansecStats.SecContextFree                =   SecContextFree;
    SkwansecStats.SecContextQueue               =   SecContextQueue;
    SkwansecStats.SecContextQueueInNego         =   SecContextQueueInNego;
    SkwansecStats.SecContextDequeue             =   SecContextDequeue;
    SkwansecStats.SecContextTimeout             =   SecContextTimeout;

    SkwansecStats.SecContextQueueNegoComplete   =
                SkwansecStats.SecContextQueue - SkwansecStats.SecContextQueueInNego;
    SkwansecStats.SecContextQueueLength         =
                SkwansecStats.SecContextQueue -
                SkwansecStats.SecContextDequeue -
                SkwansecStats.SecContextTimeout;

    //  security packet info alloc\free

    SkwansecStats.SecPackAlloc                  =   SecPackAlloc;
    SkwansecStats.SecPackFree                   =   SecPackFree;

    //  TKEY and TSIG handling

    SkwansecStats.SecTkeyInvalid                =   SecTkeyInvalid;
    SkwansecStats.SecTkeyBadTime                =   SecTkeyBadTime;
    SkwansecStats.SecTsigFormerr                =   SecTsigFormerr;
    SkwansecStats.SecTsigEcho                   =   SecTsigEcho;
    SkwansecStats.SecTsigBadKey                 =   SecTsigBadKey;
    SkwansecStats.SecTsigVerifySuccess          =   SecTsigVerifySuccess;
    SkwansecStats.SecTsigVerifyFailed           =   SecTsigVerifyFailed;

    //  Temp hacks in private stats

    PrivateStats.SecTsigVerifyOldSig            =   SecTsigVerifyOldSig;
    PrivateStats.SecTsigVerifyOldFailed         =   SecTsigVerifyOldFailed;
    PrivateStats.SecBigTimeSkewBypass           =   SecBigTimeSkewBypass;
}



VOID
deriveAndTimeSetStats(
    VOID
    )
/*++

Routine Description:

    Get copy of current statistics.

Arguments:

    None

Return Value:

    None.

--*/
{
    DWORD   secondsTime;

    //Stats_Lock();

    //
    //  some statistics are derived
    //

    NTree_WriteDerivedStats();
    RR_WriteDerivedStats();
    Packet_WriteDerivedStats();
    Nbstat_WriteDerivedStats();
    Up_WriteDerivedUpdateStats();
    Mem_WriteDerivedStats();
    deriveSkwansecStats();

    //
    //  time delta
    //

    secondsTime = GetCurrentTimeInSeconds();
    TimeStats.SecondsSinceLastClear = secondsTime - TimeStats.LastClearTimeSeconds;
    TimeStats.SecondsSinceServerStart = secondsTime - TimeStats.ServerStartTimeSeconds;

    //Stats_Unlock();
}



VOID
Stats_Clear(
    VOID
    )
/*++

Routine Description:

    Clear statistics.

Arguments:

    None

Return Value:

    None.

--*/
{
    PDNSSRV_STATS   pstat;
    DNS_SYSTEMTIME  timeSystem;
    DWORD           timeSeconds;
    DWORD           i;

    //
    //  Note: times in UTC.
    //

    GetSystemTime( ( PSYSTEMTIME ) &timeSystem );
    timeSeconds = GetCurrentTimeInSeconds();

    //Stats_Lock();

    //
    //  clear query and response stats
    //  database stats unaffected
    //

    i = 0;
    while( pstat = (PDNSSRV_STAT) StatsTable[i].pStats )
    {
        i++;
        if ( pstat->Header.fClear )
        {
            RtlZeroMemory(
                pstat->Buffer,
                pstat->Header.wLength
                );
        }
    }

    //  save time of last clear

    TimeStats.LastClearTime = timeSystem;
    TimeStats.LastClearTimeSeconds = timeSeconds;

    //Stats_Unlock();

}   // Stats_Clear



#if DBG
VOID
Dbg_Statistics(
    VOID
    )
{
    DWORD           i;
    PDNSSRV_STAT    pstat;

    //
    //  print all available stats
    //

    DnsDebugLock();
    DnsPrintf( "DNS Server Statistics:\n" );

    i = 0;
    while ( pstat = (PDNSSRV_STAT) StatsTable[i++].pStats )
    {
        DnsDbg_RpcSingleStat(
            NULL,
            pstat );
    }
    DnsDebugUnlock();
}
#endif  // DBG



//
//  Statistics RPC utilities.
//

DNS_STATUS
Rpc_GetStatistics(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Get server statistics.
    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

Return Value:

    None

--*/
{
    DWORD           filter = (DWORD)(ULONG_PTR) pDataIn;
    DWORD           i;
    DWORD           length;
    PDNSSRV_STAT    pstat;
    PCHAR           pch;
    PDNS_RPC_BUFFER pbuf;

    DNS_DEBUG( RPC, (
        "RpcGetStatistics():\n"
        "\tFilter = %p\n",
        filter ));

    //
    //  determine necessary space, and allocate
    //

    length = 0;
    i = 0;

    while ( pstat = (PDNSSRV_STAT)StatsTable[i].pStats )
    {
        if ( filter & pstat->Header.StatId )
        {
            length += TOTAL_STAT_LENGTH(pstat);
        }
        i++;
    }

    pbuf = (PDNS_RPC_BUFFER) MIDL_user_allocate( length + sizeof(DNS_RPC_BUFFER) );
    IF_NOMEM( !pbuf )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pbuf->dwLength = length;
    pch = pbuf->Buffer;

    //
    //  derive stats and copy desired stats to buffer
    //

    deriveAndTimeSetStats();

    i = 0;
    while ( pstat = (PDNSSRV_STAT)StatsTable[i].pStats )
    {
        if ( filter & pstat->Header.StatId )
        {
            length = TOTAL_STAT_LENGTH(pstat);

            RtlCopyMemory(
                pch,
                (PCHAR) pstat,
                length );

            pch += length;
        }
        i++;
    }

    *(PDNS_RPC_BUFFER *)ppDataOut = pbuf;
    *pdwTypeOut = DNSSRV_TYPEID_BUFFER;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcStatsBuffer(
            "Leaving R_DnsGetStatistics():",
            pbuf );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
Rpc_ClearStatistics(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      DWORD       dwSize,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Clear statistics info.

Arguments:

    Server -- server string handle

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    Stats_Clear();
    return( ERROR_SUCCESS );
}



//
//  PerfMon Support
//

//
//  PerfMon counters
//

volatile unsigned long * pcTotalQueryReceived;
volatile unsigned long * pcUdpQueryReceived;
volatile unsigned long * pcTcpQueryReceived;
volatile unsigned long * pcTotalResponseSent;
volatile unsigned long * pcUdpResponseSent;
volatile unsigned long * pcTcpResponseSent;
volatile unsigned long * pcRecursiveQueries;
volatile unsigned long * pcRecursiveTimeOut;
volatile unsigned long * pcRecursiveQueryFailure;
volatile unsigned long * pcNotifySent;
volatile unsigned long * pcZoneTransferRequestReceived;
volatile unsigned long * pcZoneTransferSuccess;
volatile unsigned long * pcZoneTransferFailure;
volatile unsigned long * pcAxfrRequestReceived;
volatile unsigned long * pcAxfrSuccessSent;
volatile unsigned long * pcIxfrRequestReceived;
volatile unsigned long * pcIxfrSuccessSent;
volatile unsigned long * pcNotifyReceived;
volatile unsigned long * pcZoneTransferSoaRequestSent;
volatile unsigned long * pcAxfrRequestSent;
volatile unsigned long * pcAxfrResponseReceived;
volatile unsigned long * pcAxfrSuccessReceived;
volatile unsigned long * pcIxfrRequestSent;
volatile unsigned long * pcIxfrResponseReceived;
volatile unsigned long * pcIxfrSuccessReceived;
volatile unsigned long * pcIxfrUdpSuccessReceived;
volatile unsigned long * pcIxfrTcpSuccessReceived;
volatile unsigned long * pcWinsLookupReceived;
volatile unsigned long * pcWinsResponseSent;
volatile unsigned long * pcWinsReverseLookupReceived;
volatile unsigned long * pcWinsReverseResponseSent;
volatile unsigned long * pcDynamicUpdateReceived;
volatile unsigned long * pcDynamicUpdateNoOp;
volatile unsigned long * pcDynamicUpdateWriteToDB;
volatile unsigned long * pcDynamicUpdateRejected;
volatile unsigned long * pcDynamicUpdateTimeOut;
volatile unsigned long * pcDynamicUpdateQueued;
volatile unsigned long * pcSecureUpdateReceived;
volatile unsigned long * pcSecureUpdateFailure;
volatile unsigned long * pcDatabaseNodeMemory;
volatile unsigned long * pcRecordFlowMemory;
volatile unsigned long * pcCachingMemory;
volatile unsigned long * pcUdpMessageMemory;
volatile unsigned long * pcTcpMessageMemory;
volatile unsigned long * pcNbstatMemory;

//
//  Dummy counter to point counter pointers at if unable to open counter block
//

unsigned long DummyCounter;


//
//  Configuration utils
//

DWORD
perfmonGetParam(
    IN      LPTSTR          pszParameter,
    OUT     PVOID           pValue,
    IN      DWORD           dwSize
    )
{
    DWORD   status;
    DWORD   regType;
    HKEY    hkey;

    DNS_DEBUG( INIT, (
        "perfmonGetParam() ** attempt to read [%s] \"%S\" param\n",
        DNS_CONFIG_SECTION,
        pszParameter ));

    status = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                TEXT(DNS_CONFIG_SECTION),
                &hkey
                );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "Error <%lu>: Cannot open key %S\n",
            status,
            TEXT(DNS_CONFIG_SECTION) ));
        return status;
    }

    status = RegQueryValueEx(
                 hkey,
                 pszParameter,
                 NULL,
                 &regType,
                 (LPBYTE) pValue,
                 &dwSize
                 );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            " ** [%s] \"%S\" param not found. Status = %lu\n",
            DNS_CONFIG_SECTION,
            pszParameter,
            status ));
    }
    else if ( regType == REG_SZ )
    {
        DNS_DEBUG( INIT, (
            " ** [%s] \"%S\" param = \"%S\"\n",
            DNS_CONFIG_SECTION,
            pszParameter,
            (LPTSTR) pValue ));
    }
    else
    {
        DNS_DEBUG( INIT, (
            " ** [%s] \"%S\" param = \"0x%x\"\n",
            DNS_CONFIG_SECTION,
            pszParameter,
            *(PDWORD) pValue ));
    }

    RegCloseKey( hkey );

    return status;
}


DWORD
perfmonSetParam(
    IN      LPTSTR          pszParameter,
    IN      DWORD           regType,
    OUT     PVOID           pValue,
    IN      DWORD           dwSize
    )
{
    DWORD   status;
    HKEY    hkey;

    DNS_DEBUG( INIT, (
        "perfmonSetParam() ** attempt to write [%s] \"%s\" param\n",
        DNS_CONFIG_SECTION,
        pszParameter ));

    status = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                TEXT(DNS_CONFIG_SECTION),
                &hkey
                );

    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    status = RegSetValueEx(
                hkey,
                pszParameter,
                0,
                regType,
                (LPBYTE) pValue,
                dwSize );

    RegCloseKey( hkey );

    return status;
}


DWORD
reloadPerformanceCounters(
    VOID
    )
/*++

Routine Description:

    This routine sets up the performance counters for the ds

    See instructions for adding new counters in perfdsa\datadsa.h

Parameters:

    None.

Return Values:

    0 if succesful; winerror otherwise

--*/
{
    DWORD   status;
    DWORD   IgnoreError;
    WCHAR   IniFilePath[2*MAX_PATH];
    WCHAR   SystemDirectory[MAX_PATH+1];
    DWORD   PerfCounterVersion = 0;


    //
    //  DEVNOTE: should check if perf counters there
    //      if NOT then reload
    //

    if ( ! GetSystemDirectoryW(
                SystemDirectory,
                sizeof(SystemDirectory)/sizeof(SystemDirectory[0])))
    {
        return GetLastError();
    }

    wcscpy( IniFilePath, L"lodctr " );
    wcscat( IniFilePath, SystemDirectory );
    wcscat( IniFilePath, L"\\dnsperf.ini" );

    // Get version in registry.  If non-existent, use zero

    status = perfmonGetParam(
                    TEXT(PERF_COUNTER_VERSION),
                    &PerfCounterVersion,
                    sizeof(DWORD)
                    );

    // version param not found, set it:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "Get Version param failed! Set param here.\n"
            "PerfCounterVersion = %d\n",
            PerfCounterVersion ));

        PerfCounterVersion = DNS_PERFORMANCE_COUNTER_VERSION;

        status = perfmonSetParam(
                        TEXT(PERF_COUNTER_VERSION),
                        REG_DWORD,
                        &PerfCounterVersion,
                        sizeof(DWORD)
                        );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "Set 'Performance Counter Version' failed: %d\n",
                status ));
        }
    }
    else
    {
        // If version is not up to date, unload counters and update version
        if ( PerfCounterVersion != DNS_PERFORMANCE_COUNTER_VERSION )
        {
            __try
            {
                //status = UnloadPerfCounterTextStringsW( L"unlodctr DNS", TRUE );
                status = (DWORD)UnloadPerfCounterTextStringsW( TEXT("unlodctr DNS"), TRUE );
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                status = RtlNtStatusToDosError( GetExceptionCode() );
            }

            if (status == ERROR_SUCCESS)
            {
                DNS_DEBUG( ANY, (
                    "System has old DNS performance counter version %d: "
                    "reloading performance counters.\n",
                    PerfCounterVersion ));

                PerfCounterVersion = DNS_PERFORMANCE_COUNTER_VERSION;
                status = perfmonSetParam(
                                TEXT(PERF_COUNTER_VERSION),
                                REG_DWORD,
                                &PerfCounterVersion,
                                sizeof(DWORD)
                                );
                if ( status != ERROR_SUCCESS )
                {
                    DNS_DEBUG( ANY, (
                        "Set 'Performance Counter Version' failed: %d, (%p)\n",
                        status, status ));
                }

            }
            else
            {
                DNS_DEBUG( ANY, (
                    "Can't update perf counters: Unload failed %d (%p)\n",
                    status, status ));
            }
        }
    }

    __try
    {
        status = (DWORD)LoadPerfCounterTextStringsW( IniFilePath, TRUE );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        status = RtlNtStatusToDosError( GetExceptionCode() );
    }

    return status;
}


/** PerfInit
 *
 *  Initialize PerfMon extension support.  This consists of allocating a
 *  block of shared memory and initializing a bunch of global pointers to
 *  point into the block.
 *
 */

VOID
perfmonCounterBlockInit(
    VOID
    )
/*++

Routine Description:

    Initialize perfmon counter block.

    Allocate a block of shared memory to hold counters, then init
    our internal pointer counters to point to correct locations in this block.

    See instructions for adding new counters in perfdns\datadns.h

Parameters:

    None.

Return Values:

    None.

--*/
{
    HANDLE          hMappedObject;
    unsigned long * pCounterBlock;
    int     err = 0;

    DNS_STATUS              status;
    SECURITY_ATTRIBUTES     secAttr;
    PSECURITY_ATTRIBUTES    psecAttr = NULL;
    PSECURITY_DESCRIPTOR    psd = NULL;
    DWORD                   maskArray[ 3 ] = { 0 };
    PSID                    sidArray[ 3 ] = { 0 };

    //
    //  create security on perfmon mapped file
    //
    //  security will be AuthenticatedUsers get to read
    //

    maskArray[ 0 ] = GENERIC_READ;
    sidArray[ 0 ] = g_pAuthenticatedUserSid;
    maskArray[ 1 ] = GENERIC_ALL;
    sidArray[ 1 ] = g_pLocalSystemSid;

    status = Dns_CreateSecurityDescriptor(
                & psd,
                2,              //  number of ACEs
                sidArray,
                maskArray );

    if ( status == ERROR_SUCCESS )
    {
        secAttr.lpSecurityDescriptor = psd;
        secAttr.bInheritHandle = FALSE;
        secAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
        psecAttr = &secAttr;
    }
    ELSE
    {
        DNS_DEBUG( ANY, (
            "ERROR:  <%d> failed SD create for perfmon memory!\n",
            status ));
    }

    pCounterBlock = NULL;
    /*
     *  create named section for the performance data
     */
    hMappedObject = CreateFileMapping(
                        INVALID_HANDLE_VALUE,
                        psecAttr,
                        PAGE_READWRITE,
                        0,
                        4096,
                        DNS_PERF_COUNTER_BLOCK
                        );
    if (hMappedObject == NULL)
    {
        /* Hmm.  Maybe PerfMon has already created the block? */
        hMappedObject = OpenFileMapping(
                            FILE_MAP_WRITE,
                            FALSE,
                            DNS_PERF_COUNTER_BLOCK);
        #if DBG
        if ( hMappedObject == NULL )
        {
            DNS_DEBUG( ANY, (
                "ERROR: perfmon object already created but error %d while opening\n",
                GetLastError() ));
        }
        #endif
    }

    if (hMappedObject)
    {
        /* Mapped object created okay
         *
         * map the section and assign the counter block pointer
         * to this section of memory
         */
        pCounterBlock = (unsigned long *) MapViewOfFile(hMappedObject,
                                                        FILE_MAP_ALL_ACCESS,
                                                        0,
                                                        0,
                                                        0);
        if (pCounterBlock == NULL) {
            //LogUnhandledError(GetLastError());
            /* Failed to Map View of file */
        }
    }

    // TODO: this code assumes that all counters are sizeof LONG.  The pointer
    // should be built from a base using the NUM_xxx offsets in datadns.h

    //
    //  DEVNOTE: just overlay a structure and set offsets
    //
    //  DEVNOTE: could also let all PERF_INC, DEC operate through struct element
    //      ex. pPerfBlob->UdpRecv though this is slightly more expensive;
    //

    if (pCounterBlock)
    {
        pcTotalQueryReceived    = pCounterBlock + 1 +
                (TOTALQUERYRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcUdpQueryReceived    = pCounterBlock + 1 +
                (UDPQUERYRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcTcpQueryReceived    = pCounterBlock + 1 +
                (TCPQUERYRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcTotalResponseSent    = pCounterBlock + 1 +
                (TOTALRESPONSESENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcUdpResponseSent    = pCounterBlock + 1 +
                (UDPRESPONSESENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcTcpResponseSent    = pCounterBlock + 1 +
                (TCPRESPONSESENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcRecursiveQueries    = pCounterBlock + 1 +
                (RECURSIVEQUERIES_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcRecursiveTimeOut    = pCounterBlock + 1 +
                (RECURSIVETIMEOUT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcRecursiveQueryFailure = pCounterBlock + 1 +
                (RECURSIVEQUERYFAILURE_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcNotifySent    = pCounterBlock + 1 +
                (NOTIFYSENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcZoneTransferRequestReceived    = pCounterBlock + 1 +
                (ZONETRANSFERREQUESTRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcZoneTransferSuccess    = pCounterBlock + 1 +
                (ZONETRANSFERSUCCESS_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcZoneTransferFailure    = pCounterBlock + 1 +
                (ZONETRANSFERFAILURE_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcAxfrRequestReceived    = pCounterBlock + 1 +
                (AXFRREQUESTRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcAxfrSuccessSent    = pCounterBlock + 1 +
                (AXFRSUCCESSSENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrRequestReceived    = pCounterBlock + 1 +
                (IXFRREQUESTRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrSuccessSent   = pCounterBlock + 1 +
                ( IXFRSUCCESSSENT_OFFSET- TOTALQUERYRECEIVED_OFFSET)/4;
        pcNotifyReceived   = pCounterBlock + 1 +
                (NOTIFYRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcZoneTransferSoaRequestSent   = pCounterBlock + 1 +
                (ZONETRANSFERSOAREQUESTSENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcAxfrRequestSent   = pCounterBlock + 1 +
                (AXFRREQUESTSENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcAxfrResponseReceived   = pCounterBlock + 1 +
                (AXFRRESPONSERECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcAxfrSuccessReceived   = pCounterBlock + 1 +
                (AXFRSUCCESSRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrRequestSent   = pCounterBlock + 1 +
                (IXFRREQUESTSENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrResponseReceived   = pCounterBlock + 1 +
                (IXFRRESPONSERECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrSuccessReceived   = pCounterBlock + 1 +
                (IXFRSUCCESSRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrUdpSuccessReceived   = pCounterBlock + 1 +
                (IXFRUDPSUCCESSRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrTcpSuccessReceived   = pCounterBlock + 1 +
                (IXFRTCPSUCCESSRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcWinsLookupReceived   = pCounterBlock + 1 +
                (WINSLOOKUPRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcWinsResponseSent   = pCounterBlock + 1 +
                (WINSRESPONSESENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcWinsReverseLookupReceived   = pCounterBlock + 1 +
                (WINSREVERSELOOKUPRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcWinsReverseResponseSent   = pCounterBlock + 1 +
                (WINSREVERSERESPONSESENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDynamicUpdateReceived   = pCounterBlock + 1 +
                (DYNAMICUPDATERECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDynamicUpdateNoOp   = pCounterBlock + 1 +
                (DYNAMICUPDATENOOP_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDynamicUpdateWriteToDB   = pCounterBlock + 1 +
                (DYNAMICUPDATEWRITETODB_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDynamicUpdateRejected   = pCounterBlock + 1 +
                (DYNAMICUPDATEREJECTED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDynamicUpdateTimeOut   = pCounterBlock + 1 +
                (DYNAMICUPDATETIMEOUT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDynamicUpdateQueued   = pCounterBlock + 1 +
                (DYNAMICUPDATEQUEUED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcSecureUpdateReceived   = pCounterBlock + 1 +
                (SECUREUPDATERECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcSecureUpdateFailure   = pCounterBlock + 1 +
                (SECUREUPDATEFAILURE_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDatabaseNodeMemory   = pCounterBlock + 1 +
                (DATABASENODEMEMORY_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcRecordFlowMemory   = pCounterBlock + 1 +
                (RECORDFLOWMEMORY_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcCachingMemory   = pCounterBlock + 1 +
                (CACHINGMEMORY_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcUdpMessageMemory   = pCounterBlock + 1 +
                (UDPMESSAGEMEMORY_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcTcpMessageMemory   = pCounterBlock + 1 +
                (TCPMESSAGEMEMORY_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcNbstatMemory   = pCounterBlock + 1 +
                (NBSTATMEMORY_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;


        // SANITY CHECK (RsRaghav) - we seem to have allocated this magic(?) 4096
        // and keep adding counters. Please update the assert below with the highest
        // counter added to the perf block.

        //ASSERT(((TCPCLICONN/2) * sizeof(unsigned long)) <= 4096);
        ASSERT(((pcNbstatMemory-pCounterBlock+1) * sizeof(unsigned long)) <= 4096);

        memset(pCounterBlock, 0, 4096);
    }

    //  failed to allocate shared memory for counters
    //  init all pointers to point at DummyCounter -- just dumping data

    else
    {
        pcTotalQueryReceived =  pcUdpQueryReceived =  pcTcpQueryReceived =
            pcTotalResponseSent =  pcUdpResponseSent =  pcTcpResponseSent =
            pcRecursiveQueries =  pcRecursiveTimeOut =  pcRecursiveQueryFailure =
            pcNotifySent =  pcZoneTransferRequestReceived =  pcZoneTransferSuccess =
            pcZoneTransferFailure =  pcAxfrRequestReceived =  pcAxfrSuccessSent =
            pcIxfrRequestReceived =  pcIxfrSuccessSent =  pcNotifyReceived =
            pcZoneTransferSoaRequestSent =  pcAxfrRequestSent =
            pcAxfrResponseReceived =  pcAxfrSuccessReceived =  pcIxfrRequestSent =
            pcIxfrResponseReceived =  pcIxfrSuccessReceived =
            pcIxfrUdpSuccessReceived =  pcIxfrTcpSuccessReceived =
            pcWinsLookupReceived =  pcWinsResponseSent =
            pcWinsReverseLookupReceived =  pcWinsReverseResponseSent =
            pcDynamicUpdateReceived =  pcDynamicUpdateNoOp =
            pcDynamicUpdateWriteToDB =  pcDynamicUpdateRejected =
            pcDynamicUpdateTimeOut =  pcDynamicUpdateQueued =
            pcSecureUpdateReceived =  pcSecureUpdateFailure =
            pcDatabaseNodeMemory =  pcRecordFlowMemory =  pcCachingMemory =
            pcUdpMessageMemory =  pcTcpMessageMemory =  pcNbstatMemory =
         &DummyCounter;
    }

    // Reload the perfmon counter. Done here to ensure DNS counter gets
    // reloaded after an upgrade. If the counter is
    // already loaded, this is a no-op

    //err = reloadPerformanceCounters();

    if ( err == ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, ("DNS Perfmon Counters loaded\n" ));
    }
    else if ( err == ERROR_ALREADY_EXISTS )
    {
        DNS_DEBUG( INIT, ("DNS Perfmon Counter is already loaded\n" ));
    }
    else
    {
        DNS_DEBUG( INIT, (
            "ERROR:  Problem loading DNS perfmon counter %d (%p)!\n",
            err, err ));
    }

    //
    //  free security descriptor
    //

    FREE_HEAP( psd );
}


VOID
Stats_updateErrorStats(
    IN  DWORD   dwErr
    )
/*++

Routine Description:

    Increment corresponding stats on given error code
Arguments:

    dwErr: Error code.


Return Value:


--*/
{

    switch ( dwErr )
    {
        case DNS_RCODE_NOERROR:
            STAT_INC( ErrorStats.NoError );
            break;
        case DNS_RCODE_FORMERR:
            STAT_INC( ErrorStats.FormError );
            break;
        case DNS_RCODE_SERVFAIL:
            STAT_INC( ErrorStats.ServFail );
            break;
        case DNS_RCODE_NXDOMAIN:
            STAT_INC( ErrorStats.NxDomain );
            break;
        case DNS_RCODE_NOTIMPL:
            STAT_INC( ErrorStats.NotImpl );
            break;
        case DNS_RCODE_REFUSED:
            STAT_INC( ErrorStats.Refused );
            break;
        case DNS_RCODE_YXDOMAIN:
            STAT_INC( ErrorStats.YxDomain );
            break;
        case DNS_RCODE_YXRRSET:
            STAT_INC( ErrorStats.YxRRSet );
            break;
        case DNS_RCODE_NXRRSET:
            STAT_INC( ErrorStats.NxRRSet );
            break;
        case DNS_RCODE_NOTAUTH:
            STAT_INC( ErrorStats.NotAuth );
            break;
        case DNS_RCODE_NOTZONE:
            STAT_INC( ErrorStats.NotZone );
            break;
        case DNS_RCODE_MAX:
            STAT_INC( ErrorStats.Max );
            break;
        case DNS_RCODE_BADSIG:
            STAT_INC( ErrorStats.BadSig );
            break;
        case DNS_RCODE_BADKEY:
            STAT_INC( ErrorStats.BadKey );
            break;
        case DNS_RCODE_BADTIME:
            STAT_INC( ErrorStats.BadTime );
            break;
        default:
            STAT_INC( ErrorStats.UnknownError );
    }
}


VOID
Stat_IncrementQuery2Stats(
    IN      WORD            wType
    )
/*++

Routine Description:

    This routine implements the appropriate breakout counter in
    the Query2Stats structure given wType.

Arguments:

    wType: type of query

Return Value:


--*/
{
    switch ( wType )
    {
        case DNS_TYPE_A:
            STAT_INC( Query2Stats.TypeA );              break;
        case DNS_TYPE_NS:
            STAT_INC( Query2Stats.TypeNs );             break;
        case DNS_TYPE_SOA:
            STAT_INC( Query2Stats.TypeSoa );            break;
        case DNS_TYPE_MX:
            STAT_INC( Query2Stats.TypeMx );             break;
        case DNS_TYPE_PTR:
            STAT_INC( Query2Stats.TypePtr );            break;
        case DNS_TYPE_SRV:
            STAT_INC( Query2Stats.TypeSrv );            break;
        case DNS_TYPE_ALL:
            STAT_INC( Query2Stats.TypeAll );            break;
        case DNS_TYPE_AXFR:
            STAT_INC( Query2Stats.TypeAxfr );           break;
        case DNS_TYPE_IXFR:
            STAT_INC( Query2Stats.TypeIxfr );           break;
        default:
            STAT_INC( Query2Stats.TypeOther );          break;
    }
}   //  Stat_IncrementQuery2Stats

//
//  End stats.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\srvrpc.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    srvrpc.c

Abstract:

    Domain Name System (DNS) Server

    Server configuration RPC API.

Author:

    Jim Gilroy (jamesg)     October, 1995

Revision History:

--*/


#include "dnssrv.h"

#include "rpcw2k.h"     //  downlevel Windows 2000 RPC functions



//
//  RPC utilities
//

VOID
freeRpcServerInfo(
    IN OUT  PDNS_RPC_SERVER_INFO    pServerInfo
    )
/*++

Routine Description:

    Deep free of DNS_RPC_SERVER_INFO structure.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( !pServerInfo )
    {
        return;
    }

    //
    //  free substructures
    //      - server name
    //      - server IP address array
    //      - listen address array
    //      - forwarders array
    //  then server info itself
    //

    if ( pServerInfo->pszServerName )
    {
        MIDL_user_free( pServerInfo->pszServerName );
    }
    if ( pServerInfo->aipServerAddrs )
    {
        MIDL_user_free( pServerInfo->aipServerAddrs );
    }
    if ( pServerInfo->aipListenAddrs )
    {
        MIDL_user_free( pServerInfo->aipListenAddrs );
    }
    if ( pServerInfo->aipForwarders )
    {
        MIDL_user_free( pServerInfo->aipForwarders );
    }
    if ( pServerInfo->aipLogFilter )
    {
        MIDL_user_free( pServerInfo->aipLogFilter );
    }
    if ( pServerInfo->pwszLogFilePath )
    {
        MIDL_user_free( pServerInfo->pwszLogFilePath );
    }
    if ( pServerInfo->pszDsContainer )
    {
        MIDL_user_free( pServerInfo->pszDsContainer );
    }
    if ( pServerInfo->pszDomainName )
    {
        MIDL_user_free( pServerInfo->pszDomainName );
    }
    if ( pServerInfo->pszForestName )
    {
        MIDL_user_free( pServerInfo->pszForestName );
    }
    if ( pServerInfo->pszDomainDirectoryPartition )
    {
        MIDL_user_free( pServerInfo->pszDomainDirectoryPartition );
    }
    if ( pServerInfo->pszForestDirectoryPartition )
    {
        MIDL_user_free( pServerInfo->pszForestDirectoryPartition );
    }
    MIDL_user_free( pServerInfo );
}



//
//  NT5 RPC Server Operations
//

DNS_STATUS
RpcUtil_ScreenIps(
    IN      PDNS_ADDR_ARRAY     pIpAddrs,
    IN      DWORD           dwFlags,
    OUT     DWORD *         pdwErrorIp      OPTIONAL
    )
/*++

Routine Description:

    Screen a list of IP addresses for use by the server.
    The basic rules are that the IP list cannot contain:
        - server's own IP addresses
        - loopback addresses
        - multicast addresses
        - broadcast addresses

Arguments:

    pIpAddrs - pointer to array of  IP addresses

    dwFlags - modify rules with DNS_IP_XXX flags - pass zero for the
        most restrictive set of rules

        DNS_IP_ALLOW_LOOPBACK -- loopback address is allowed

        DNS_IP_ALLOW_SELF_BOUND -- this machine's own IP addresses
            are allowed but only if they are currently bound for DNS

        DNS_IP_ALLOW_SELF_ANY -- any of this machine's own IP addresses
            are allowed (bound for DNS and not bound for DNS)

    pdwErrorIp - optional - set to index of first invalid IP
        in the array or -1 if there are no invalid IPs

Return Value:

    ERROR_SUCCESS -- IP list contains no unwanted IP addresses
    DNS_ERROR_INVALID_IP_ADDRESS -- IP list contains one or more invalid IPs

--*/
{
    DBG_FN( "RpcUtil_ScreenIps" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           i = -1;

    if ( !pIpAddrs )
    {
        goto Done;
    }

    #define BAD_IP();   status = DNS_ERROR_INVALID_IP_ADDRESS; break;

    for ( i = 0; i < pIpAddrs->AddrCount; ++i )
    {
        PDNS_ADDR   pdnsaddr = &pIpAddrs->AddrArray[ i ];
        DWORD       j;

        //
        //  These IPs are never allowable.
        //

        if ( DnsAddr_IsClear( pdnsaddr ) ||
             DnsAddr_IsIp4( pdnsaddr ) &&
                ( DnsAddr_GetIp4( pdnsaddr ) == ntohl( INADDR_BROADCAST ) ||
                  IN_MULTICAST( htonl( DnsAddr_GetIp4( pdnsaddr ) ) ) ) )
        {
            BAD_IP();
        }

        //
        //  These IPs may be allowable if flags are set.
        //

        if ( DnsAddr_IsLoopback( pdnsaddr, 0 ) &&
            !( dwFlags & DNS_IP_ALLOW_LOOPBACK ) )
        {
            BAD_IP();
        }

        if ( g_ServerIp4Addrs &&
             !( dwFlags & DNS_IP_ALLOW_SELF ) &&
             DnsAddrArray_ContainsAddr(
                    g_ServerIp4Addrs,
                    pdnsaddr,
                    DNSADDR_MATCH_IP ) )
        {
            BAD_IP();
        }
    }

    Done:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "%s: invalid IP index %d %s with flags %08X\n", fn,
            i,
            DNSADDR_STRING( &pIpAddrs->AddrArray[ i ] ),
            dwFlags ));
    }

    if ( pdwErrorIp )
    {
        *pdwErrorIp = status == ERROR_SUCCESS ? -1 : i;
    }

    return status;
}   //  RpcUtil_ScreenIps



DNS_STATUS
Rpc_Restart(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Dump server's cache.

Arguments:

Return Value:

    None.

--*/
{
    ASSERT( dwTypeId == DNSSRV_TYPEID_NULL );
    ASSERT( !pData );

    DNS_DEBUG( RPC, ( "Rpc_Restart()\n" ));

    //
    //  restart by notifying server exactly as if caught
    //      exception on thread
    //

    Service_IndicateRestart();

    return ERROR_SUCCESS;
}



#if DBG

DWORD
WINAPI
ThreadDebugBreak(
    IN      LPVOID          lpVoid
    )
/*++

Routine Description:

   Declare debugbreak function

Arguments:

Return Value:

    None.

--*/
{
   DNS_DEBUG( RPC, ( "Calling DebugBreak()...\n" ));
   DebugBreak();
   return ERROR_SUCCESS;
}


DNS_STATUS
Rpc_DebugBreak(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Fork a dns thread & break into the debugger

Arguments:

Return Value:

    None.

--*/
{
    ASSERT( dwTypeId == DNSSRV_TYPEID_NULL );
    ASSERT( !pData );

    DNS_DEBUG( RPC, ( "Rpc_DnsDebugBreak()\n" ));

    if( !Thread_Create("ThreadDebugBreak", ThreadDebugBreak, NULL, 0) )
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
Rpc_RootBreak(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Break root to test AV protection.

Arguments:

Return Value:

    None.

--*/
{
    ASSERT( dwTypeId == DNSSRV_TYPEID_NULL );
    ASSERT( !pData );

    DNS_DEBUG( RPC, ( "Rpc_RootBreak()\n" ));

    DATABASE_ROOT_NODE->pZone = (PVOID)(7);

    return ERROR_SUCCESS;
}
#endif


DNS_STATUS
Rpc_ClearDebugLog(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Clear both the debug log and the retail log.

Arguments:

Return Value:

    None.

--*/
{
    ASSERT( dwTypeId == DNSSRV_TYPEID_NULL );
    ASSERT( !pData );

    DNS_DEBUG( RPC, ( "Rpc_ClearDebugLog()\n" ));

    //
    //  Clear debug log.
    //
    
    #if DBG    
    DnsDbg_WrapLogFile();
    #endif
    
    //
    //  Clear retail log.
    //
    
    Log_InitializeLogging( FALSE );

    return ERROR_SUCCESS;
}



DNS_STATUS
Rpc_WriteRootHints(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Write root-hints back to file or DS.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    ASSERT( dwTypeId == DNSSRV_TYPEID_NULL );
    ASSERT( !pData );

    DNS_DEBUG( RPC, ( "Rpc_WriteRootHints()\n" ));

    return Zone_WriteBackRootHints(
                FALSE );        //  don't write if not dirty
}



DNS_STATUS
Rpc_ClearCache(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Dump server's cache.

Arguments:

Return Value:

    None.

--*/
{
    ASSERT( dwTypeId == DNSSRV_TYPEID_NULL );
    ASSERT( !pData );

    DNS_DEBUG( RPC, ( "Rpc_ClearCache()\n" ));

    if ( !g_pCacheZone || g_pCacheZone->pLoadTreeRoot )
    {
        return( DNS_ERROR_ZONE_LOCKED );
    }
    if ( !Zone_LockForAdminUpdate(g_pCacheZone) )
    {
        return( DNS_ERROR_ZONE_LOCKED );
    }

    return Zone_LoadRootHints();
}



DNS_STATUS
Rpc_ResetServerDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset DWORD server property.

Arguments:

Return Value:

    None.

--*/
{
    DNS_PROPERTY_VALUE prop =
    {
        REG_DWORD,
        ( ( PDNS_RPC_NAME_AND_PARAM ) pData )->dwParam
    };

    ASSERT( dwTypeId == DNSSRV_TYPEID_NAME_AND_PARAM );
    ASSERT( pData );

    DNS_DEBUG( RPC, (
        "Rpc_ResetDwordProperty( %s, val=%d (%p) )\n",
        ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName,
        ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam,
        ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam ));

    //
    //  This property cannot be set while the server is running or
    //  memory will be corrupted.
    //
    
    if ( _stricmp(
            ( ( PDNS_RPC_NAME_AND_PARAM ) pData )->pszNodeName,
            DNS_REGKEY_MAX_UDP_PACKET_SIZE ) == 0 )
    {
        return DNS_ERROR_INVALID_PROPERTY;
    }

    return Config_ResetProperty(
                DNS_REG_IMPERSONATING,
                ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName,
                &prop );
}



DNS_STATUS
Rpc_ResetServerStringProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset string server property.

    The string property value is Unicode string.

Arguments:

Return Value:

    None.

--*/
{
    DNS_PROPERTY_VALUE prop = { DNS_REG_WSZ, 0 };

    ASSERT( dwTypeId == DNSSRV_TYPEID_LPWSTR );

    DNS_DEBUG( RPC, (
        "Rpc_ResetServerStringProperty( %s, val=\"%S\" )\n",
        pszProperty,
        ( LPWSTR ) pData ));

    prop.pwszValue = ( LPWSTR ) pData;
    return Config_ResetProperty( DNS_REG_IMPERSONATING, pszProperty, &prop );
}   //  Rpc_ResetServerStringProperty



DNS_STATUS
Rpc_ResetServerIPArrayProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset IP List server property.

Arguments:

Return Value:

    None.

--*/
{
    DNS_PROPERTY_VALUE      prop = { DNS_REG_IPARRAY, 0 };
    DNS_STATUS              status;

    ASSERT( dwTypeId == DNSSRV_TYPEID_IPARRAY );

    DNS_DEBUG( RPC, (
        "Rpc_ResetServerIPArrayProperty( %s, iplist=%p )\n",
        pszProperty,
        pData ));

    //
    //  Note: a NULL IP array is valid. The desired effect is that the IP list
    //  property is cleared.
    //
    
    if ( pData )
    {
        prop.pipArrayValue = DnsAddrArray_CreateFromIp4Array( ( PIP_ARRAY ) pData );
        if ( !prop.pipArrayValue )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
    }
    
    status = Config_ResetProperty( DNS_REG_IMPERSONATING, pszProperty, &prop );

    DnsAddrArray_Free( prop.pipArrayValue );
    
    Done:
    return status;
}   //  Rpc_ResetServerIPArrayProperty



DNS_STATUS
Rpc_ResetForwarders(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset forwarders.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    PDNS_ADDR_ARRAY     piparray = NULL;

    DNS_DEBUG( RPC, ( "Rpc_ResetForwarders()\n" ));

    //
    //  Note: aipForwarders can be NULL if the admin is clearing the
    //  forwarder list.
    //
    
    if ( ( ( PDNS_RPC_FORWARDERS ) pData )->aipForwarders )
    {
        piparray = DnsAddrArray_CreateFromIp4Array(
                        ( ( PDNS_RPC_FORWARDERS ) pData )->aipForwarders );
        if ( !piparray )
        {
            return DNS_ERROR_NO_MEMORY;
        }
    }
    
    status = Config_SetupForwarders(
                piparray,
                ((PDNS_RPC_FORWARDERS)pData)->dwForwardTimeout,
                ((PDNS_RPC_FORWARDERS)pData)->fSlave );
    if ( status == ERROR_SUCCESS )
    {
        Config_UpdateBootInfo();
    }

    DnsAddrArray_Free( piparray );

    //
    //  If forwarders were successfully modified, mark the server as configured.
    //
    
    if ( status == ERROR_SUCCESS && !SrvCfg_fAdminConfigured )
    {
        DnsSrv_SetAdminConfigured( TRUE );
    }

    return status;
}



DNS_STATUS
Rpc_ResetListenAddresses(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset forwarders.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    PIP_ARRAY           pip4array = ( PIP_ARRAY ) pData;
    PDNS_ADDR_ARRAY     piparray = NULL;

    DNS_DEBUG( RPC, ( "Rpc_ResetListenAddresses()\n" ));

    if ( pip4array )
    {
        piparray = DnsAddrArray_CreateFromIp4Array( pip4array );
        if ( !piparray )
        {
            return DNS_ERROR_NO_MEMORY;
        }
    }

    status = Config_SetListenAddresses( piparray );

    DnsAddrArray_Free( piparray );

    return status;
}



DNS_STATUS
Rpc_StartScavenging(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Launches the scavenging thread (admin initiated scavenging)

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS status;

    DNS_DEBUG( RPC, ( "Rpc_StartScavenging()\n" ));

    //  reset scavenging timer
    //      TRUE forces scavenge now

    status = Scavenge_CheckForAndStart( TRUE );

    return status;
}



DNS_STATUS
Rpc_AbortScavenging(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Launches the scavenging thread (admin initiated scavenging)

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, ( "Rpc_AbortScavenging()\n" ));

    Scavenge_Abort();

    return ERROR_SUCCESS;
}



DNS_STATUS
Rpc_AutoConfigure(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Auto configure the DNS server and client.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD       dwflags = 0;
    
    DNS_DEBUG( RPC, ( "Rpc_AutoConfigure()\n" ));

    if ( dwTypeId == DNSSRV_TYPEID_DWORD && pData )
    {
        dwflags = ( DWORD ) ( ULONG_PTR ) pData;
    }
    if ( !dwflags )
    {
        dwflags = DNS_RPC_AUTOCONFIG_ALL;
    }
    return Dnssrv_AutoConfigure( dwflags );
}   //  Rpc_AutoConfigure



//
//  NT5+ RPC Server query API
//

DNS_STATUS
Rpc_GetServerInfo(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get server info.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_SERVER_INFO    pinfo;
    CHAR                    szfqdn[ DNS_MAX_NAME_LENGTH + 1 ];

    DNS_DEBUG( RPC, (
        "Rpc_GetServerInfo( dwClientVersion=0x%lX)\n",
        dwClientVersion ));

    if ( dwClientVersion == DNS_RPC_W2K_CLIENT_VERSION )
    {
        return W2KRpc_GetServerInfo(
                    dwClientVersion,
                    pszQuery,
                    pdwTypeId,
                    ppData );
    }

    //
    //  allocate server info buffer
    //

    pinfo = MIDL_user_allocate_zero( sizeof(DNS_RPC_SERVER_INFO) );
    if ( !pinfo )
    {
        DNS_PRINT(( "ERROR:  unable to allocate SERVER_INFO block.\n" ));
        goto DoneFailed;
    }

    //
    //  fill in fixed fields
    //

    pinfo->dwVersion                = SrvCfg_dwVersion;
    pinfo->dwRpcProtocol            = SrvCfg_dwRpcProtocol;
    pinfo->dwLogLevel               = SrvCfg_dwLogLevel;
    pinfo->dwDebugLevel             = SrvCfg_dwDebugLevel;
    pinfo->dwEventLogLevel          = SrvCfg_dwEventLogLevel;
    pinfo->dwLogFileMaxSize         = SrvCfg_dwLogFileMaxSize;
    pinfo->dwDsForestVersion        = g_ulDsForestVersion;
    pinfo->dwDsDomainVersion        = g_ulDsDomainVersion;
    pinfo->dwDsDsaVersion           = g_ulDsDsaVersion;
    pinfo->dwNameCheckFlag          = SrvCfg_dwNameCheckFlag;
    pinfo->cAddressAnswerLimit      = SrvCfg_cAddressAnswerLimit;
    pinfo->dwRecursionRetry         = SrvCfg_dwRecursionRetry;
    pinfo->dwRecursionTimeout       = SrvCfg_dwRecursionTimeout;
    pinfo->dwForwardTimeout         = SrvCfg_dwForwardTimeout;
    pinfo->dwMaxCacheTtl            = SrvCfg_dwMaxCacheTtl;
    pinfo->dwDsPollingInterval      = SrvCfg_dwDsPollingInterval;
    pinfo->dwScavengingInterval     = SrvCfg_dwScavengingInterval;
    pinfo->dwDefaultRefreshInterval     = SrvCfg_dwDefaultRefreshInterval;
    pinfo->dwDefaultNoRefreshInterval   = SrvCfg_dwDefaultNoRefreshInterval;

    if ( g_LastScavengeTime  )
    {
        pinfo->dwLastScavengeTime   = ( DWORD ) DNS_TIME_TO_CRT_TIME( g_LastScavengeTime );
    }

    //  boolean flags

    pinfo->fBootMethod              = (BOOLEAN) SrvCfg_fBootMethod;
    pinfo->fAdminConfigured         = (BOOLEAN) SrvCfg_fAdminConfigured;
    pinfo->fAllowUpdate             = (BOOLEAN) SrvCfg_fAllowUpdate;
    pinfo->fAutoReverseZones        = (BOOLEAN) ! SrvCfg_fNoAutoReverseZones;
    pinfo->fAutoCacheUpdate         = (BOOLEAN) SrvCfg_fAutoCacheUpdate;

    pinfo->fSlave                   = (BOOLEAN) SrvCfg_fSlave;
    pinfo->fForwardDelegations      = (BOOLEAN) SrvCfg_fForwardDelegations;
    pinfo->fNoRecursion             = (BOOLEAN) SrvCfg_fNoRecursion;
    pinfo->fSecureResponses         = (BOOLEAN) SrvCfg_fSecureResponses;
    pinfo->fRoundRobin              = (BOOLEAN) SrvCfg_fRoundRobin;
    pinfo->fLocalNetPriority        = (BOOLEAN) SrvCfg_fLocalNetPriority;
    pinfo->fBindSecondaries         = (BOOLEAN) SrvCfg_fBindSecondaries;
    pinfo->fWriteAuthorityNs        = (BOOLEAN) SrvCfg_fWriteAuthorityNs;

    pinfo->fStrictFileParsing       = (BOOLEAN) SrvCfg_fStrictFileParsing;
    pinfo->fLooseWildcarding        = (BOOLEAN) SrvCfg_fLooseWildcarding;
    pinfo->fDefaultAgingState       = (BOOLEAN) SrvCfg_fDefaultAgingState;


    //  DS available

    //pinfo->fDsAvailable = SrvCfg_fDsAvailable;
    pinfo->fDsAvailable     = (BOOLEAN) Ds_IsDsServer();

    //
    //  server name
    //

    if ( ! RpcUtil_CopyStringToRpcBuffer(
                &pinfo->pszServerName,
                SrvCfg_pszServerName ) )
    {
        DNS_PRINT(( "ERROR:  unable to copy SrvCfg_pszServerName.\n" ));
        goto DoneFailed;
    }

    //
    //  path to DNS container in DS
    //  unicode since Marco will build unicode LDAP paths
    //

    if ( g_pwszDnsContainerDN )
    {
        pinfo->pszDsContainer = (LPWSTR) Dns_StringCopyAllocate(
                                            (LPSTR) g_pwszDnsContainerDN,
                                            0,
                                            DnsCharSetUnicode,   // unicode in
                                            DnsCharSetUnicode    // unicode out
                                            );
        if ( ! pinfo->pszDsContainer )
        {
            DNS_PRINT(( "ERROR:  unable to copy g_pszDsDnsContainer.\n" ));
            goto DoneFailed;
        }
    }

    //
    //  server IP address list
    //  listening IP address list
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipServerAddrs,
                g_ServerIp4Addrs ) )
    {
        goto DoneFailed;
    }

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipListenAddrs,
                SrvCfg_aipListenAddrs ) )
    {
        goto DoneFailed;
    }

    //
    //  Forwarders list
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipForwarders,
                SrvCfg_aipForwarders ) )
    {
        goto DoneFailed;
    }

    //
    //  Logging
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipLogFilter,
                SrvCfg_aipLogFilterList ) )
    {
        goto DoneFailed;
    }

    if ( SrvCfg_pwsLogFilePath )
    {
        pinfo->pwszLogFilePath =
            Dns_StringCopyAllocate_W(
                SrvCfg_pwsLogFilePath,
                0 );
        if ( !pinfo->pwszLogFilePath )
        {
            goto DoneFailed;
        }
    }

    //
    //  Directory partition stuff
    //

    if ( g_pszForestDefaultDpFqdn )
    {
        pinfo->pszDomainDirectoryPartition =
            Dns_StringCopyAllocate_A( g_pszDomainDefaultDpFqdn, 0 );
        if ( !pinfo->pszDomainDirectoryPartition )
        {
            goto DoneFailed;
        }
    }

    if ( g_pszForestDefaultDpFqdn )
    {
        pinfo->pszForestDirectoryPartition =
            Dns_StringCopyAllocate_A( g_pszForestDefaultDpFqdn, 0 );
        if ( !pinfo->pszForestDirectoryPartition )
        {
            goto DoneFailed;
        }
    }

    if ( DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal )
    {
        Ds_ConvertDnToFqdn( 
            DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal,
            szfqdn );
        pinfo->pszDomainName = Dns_StringCopyAllocate_A( szfqdn, 0 );
        if ( !pinfo->pszDomainName )
        {
            goto DoneFailed;
        }
    }

    if ( DSEAttributes[ I_DSE_ROOTDMN_NC ].pszAttrVal )
    {
        Ds_ConvertDnToFqdn( 
            DSEAttributes[ I_DSE_ROOTDMN_NC ].pszAttrVal,
            szfqdn );
        pinfo->pszForestName = Dns_StringCopyAllocate_A( szfqdn, 0 );
        if ( !pinfo->pszForestName )
        {
            goto DoneFailed;
        }
    }

    //
    //  set ptr
    //

    pinfo->dwRpcStructureVersion = DNS_RPC_SERVER_INFO_VER;
    *(PDNS_RPC_SERVER_INFO *)ppData = pinfo;
    *pdwTypeId = DNSSRV_TYPEID_SERVER_INFO;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcServerInfo(
            "GetServerInfo return block",
            pinfo );
    }
    return ERROR_SUCCESS;

DoneFailed:

    //  free newly allocated info block

    if ( pinfo )
    {
        freeRpcServerInfo( pinfo );
    }
    return DNS_ERROR_NO_MEMORY;
}



DNS_STATUS
DnsSrv_SetAdminConfigured(
    IN      DWORD       dwNewAdminConfiguredValue
    )
/*++

Routine Description:

    Wrapper to set the server's admin-configured flag and write it
    back to the registry.
    
    Note: this function should be called only during RPC operation
    where the server is impersonating the RPC client.

Arguments:

    dwNewAdminConfiguredValue -- new flag value

Return Value:

    Status code.

--*/
{
    DNS_PROPERTY_VALUE prop =
    {
        REG_DWORD,
        dwNewAdminConfiguredValue
    };

    return Config_ResetProperty(
                DNS_REG_IMPERSONATING,
                DNS_REGKEY_ADMIN_CONFIGURED,
                &prop );
}   //  DnsSrv_SetAdminConfigured


//
//  End of srvrpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\stats.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    stats.h

Abstract:

    Domain Name System (DNS) Server

    DNS statistics header.

Author:

    Jim Gilroy (jamesg)  August 1995

Revision History:

--*/


#ifndef _DNS_STATS_INCLUDED_
#define _DNS_STATS_INCLUDED_



#define STAT_INC( stat )            InterlockedIncrement( &( stat ) )

#if DBG
#define STAT_DEC( stat )            InterlockedDecrement( &( stat ) )
#else
#define STAT_DEC( stat )            InterlockedDecrement( &( stat ) ); ASSERT( ( LONG ) stat > 0 )
#endif

#define STAT_ADD( stat, delta )     InterlockedExchangeAdd( &( stat ), ( delta ) )
#define STAT_SUB( stat, delta )     InterlockedExchangeAdd( &( stat ), -( LONG )( delta ) )

//
//  Server statistics globals
//

extern  DNSSRV_TIME_STATS           TimeStats;
extern  DNSSRV_QUERY_STATS          QueryStats;
extern  DNSSRV_RECURSE_STATS        RecurseStats;
extern  DNSSRV_WINS_STATS           WinsStats;
extern  DNSSRV_UPDATE_STATS         WireUpdateStats;
extern  DNSSRV_UPDATE_STATS         NonWireUpdateStats;
extern  DNSSRV_DS_STATS             DsStats;
extern  DNSSRV_DBASE_STATS          DbaseStats;
extern  DNSSRV_RECORD_STATS         RecordStats;
extern  DNSSRV_PACKET_STATS         PacketStats;
extern  DNSSRV_NBSTAT_STATS         NbstatStats;
extern  DNSSRV_TIMEOUT_STATS        TimeoutStats;
extern  DNSSRV_QUERY2_STATS         Query2Stats;
extern  DNSSRV_MASTER_STATS         MasterStats;
extern  DNSSRV_SECONDARY_STATS      SecondaryStats;
extern  DNSSRV_MEMORY_STATS         MemoryStats;
extern  DNSSRV_PRIVATE_STATS        PrivateStats;
extern  DNSSRV_ERROR_STATS          ErrorStats;
extern  DNSSRV_CACHE_STATS          CacheStats;

#if 0
extern  DNSSRV_DEBUG_STATS          DebugStats;
#endif

//
//  Statistics routines
//

VOID
Stats_Initialize(
    VOID
    );

VOID
Stats_Clear(
    VOID
    );

VOID
Stats_CopyUpdate(
    OUT     PDNSSRV_STATS   pStats
    );

VOID
Stats_updateErrorStats(
    IN      DWORD           dwErr
    );

VOID
Stat_IncrementQuery2Stats(
    IN      WORD            wType
    );

//
//  Perfmon initialization
//

VOID
Stats_InitializePerfmon(
    VOID
    );


//
//  Stat table entry structure
//

struct StatsTableEntry
{
    DWORD       Id;
    BOOLEAN     fClear;
    WORD        wLength;
    PVOID       pStats;
};


#endif  // _DNS_STATS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\srvcfg.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    srvcfg.h

Abstract:

    Domain Name System (DNS) Server

    Server configuration definitions.

Author:

    Jim Gilroy (jamesg)     11-Oct-1995

Revision History:

--*/


#ifndef _DNS_SRVCFG_INCLUDED_
#define _DNS_SRVCFG_INCLUDED_

//
//  Global protection values
//

#define BEFORE_BUF_VALUE    (0xbbbbbbbb)
#define AFTER_BUF_VALUE     (0xaaaaaaaa)

//
//  Server configuration structure
//
//  Implementation note:
//
//  Obviously this flat structure is less friendly debug wise.
//  It's easier if these are just individual globals with symbols.
//  The upside is initialization is much easier -- RtlZeroMemory()
//  which is useful for server restart.
//  Fortunately, all access is macroized.  So changing this to
//  individual globals is possible.
//
//  Win64 -- this is a single instance structure so alignment not
//      really critical
//

typedef struct _DNS_SERVER_INFO
{
    DWORD       dwVersion;
    LPSTR       pszServerName;
    LPSTR       pszPreviousServerName;

    //  runtime information

    BOOL        fStarted;
    BOOL        fThreadAlert;
    BOOL        fServiceExit;
    BOOL        fWinsInitialized;
    BOOL        fWarnAdmin;
    DWORD       dwCurrentTime;
    time_t      crtSystemBootTime;      //  CRT time of machine boot
    DWORD       fBootFileDirty;
    BOOL        fDsOpen;
    BOOL        fAdminConfigured;

    //  boot

    DWORD       fEnableRegistryBoot;
    DWORD       fBootMethod;
    DWORD       cDsZones;
    DWORD       fRemoteDs;
    BOOL        bReloadException;

    //  database

    PWSTR       pwsDatabaseDirectory;
    PSTR        pszRootHintsFile;
    BOOL        fDsAvailable;
    PWSTR       pwszServerLevelPluginDll;
    DWORD       dwEnableAdvancedDatabaseLocking;

    //  RPC support

    DWORD       dwRpcProtocol;
                               //  IP interfaces
    //  logging

    LPWSTR              pwsLogFilePath;
    PDNS_ADDR_ARRAY     aipLogFilterList;
    DWORD               dwLogLevel;
    DWORD               dwOperationsLogLevel_LowDword;
    DWORD               dwOperationsLogLevel_HighDword;
    UINT64              dwOperationsLogLevel;
    DWORD               dwLogFileMaxSize;
    DWORD               dwEventLogLevel;
    DWORD               dwUseSystemEventLog;
    DWORD               dwDebugLevel;
    DWORD               dwEventControl;

    //  socket config

    PDNS_ADDR_ARRAY     aipListenAddrs;
    PDNS_ADDR_ARRAY     aipPublishAddrs;
    BOOL                fListenAddrsSet;            // used for pnp
    BOOL                fListenAddrsStale;
    BOOL                fDisjointNets;
    BOOL                fNoTcp;
    DWORD               dwSendPort;
    DWORD               dwXfrConnectTimeout;        // connection timeout for dial out
    DWORD               dwTcpRecvPacketSize;

    //  forwarders

    PDNS_ADDR_ARRAY     aipForwarders;
    DWORD               dwForwardTimeout;
    BOOL                fSlave;

    //  recursion

    BOOL        fNoRecursion;
    BOOL        fRecurseSingleLabel;
    BOOL        fRecursionAvailable;
    DWORD       dwRecursionRetry;
    DWORD       dwRecursionTimeout;
    DWORD       dwAdditionalRecursionTimeout;
    DWORD       dwMaxCacheTtl;
    DWORD       dwMaxNegativeCacheTtl;
    DWORD       dwLameDelegationTtl;
    BOOL        fSecureResponses;
    BOOL        fForwardDelegations;
    DWORD       dwRecurseToInetRootMask;
    DWORD       dwAutoCreateDelegations;
    DWORD       dwAllowCNAMEAtNS;

    //  allow UPDATEs

    BOOL        fAllowUpdate;

//  DEVNOTE:  better to have update property flag
//      perhaps just AllowUpdate gets are range of values
//      record types, delegations, zone root

    DWORD       fNoUpdateDelegations;
    DWORD       dwUpdateOptions;
    DWORD       dwEnableUpdateForwarding;
    DWORD       dwMaxRRsInNonSecureUpdate;
    
    DWORD       dwEnableWinsR;

    //  name validity

    DWORD       dwNameCheckFlag;


    //  DS control

    DWORD       dwDsPollingInterval;
    DWORD       dwDsTombstoneInterval;
    DWORD       dwSyncDsZoneSerial;
    DWORD       dwDsLazyUpdateInterval;

    DWORD       dwForceDomainBehaviorVersion;
    DWORD       dwForceForestBehaviorVersion;
    DWORD       dwForceDsaBehaviorVersion;

    //  automatic configuration

    DWORD       fAutoConfigFileZones;
    BOOL        fPublishAutonet ;
    DWORD       fNoAutoReverseZones;
    DWORD       fAutoCacheUpdate;
    DWORD       fNoAutoNSRecords;

    //  A record processing

    DWORD       fRoundRobin;
    BOOL        fLocalNetPriority;
    DWORD       dwLocalNetPriorityNetMask;
    DWORD       cAddressAnswerLimit;

    //  BIND compatibility

    DWORD       fBindSecondaries;
    DWORD       fWriteAuthorityNs;
    DWORD       fStrictFileParsing;
    DWORD       fDeleteOutsideGlue;
    DWORD       fLooseWildcarding;
    DWORD       fWildcardAllTypes;
    DWORD       fAppendMsTagToXfr;

    //  SOA forcing (for DuetscheTelekom)

    DWORD       dwForceSoaSerial;
    DWORD       dwForceSoaMinimumTtl;
    DWORD       dwForceSoaRefresh;
    DWORD       dwForceSoaRetry;
    DWORD       dwForceSoaExpire;
    DWORD       dwForceNsTtl;
    DWORD       dwForceTtl;

    //  EDNS

    DWORD       dwMaxUdpPacketSize;
    DWORD       dwEnableEDnsProbes;
    DWORD       dwEnableEDnsReception;
    DWORD       dwEDnsCacheTimeout;

    //  DNSSEC

    DWORD       dwEnableDnsSec;

    DWORD       dwEnableSendErrSuppression;

    //  Scavenging

    DWORD       fScavengingState;
    DWORD       dwScavengingInterval;

    DWORD       fDefaultAgingState;
    DWORD       dwDefaultRefreshInterval;
    DWORD       dwDefaultNoRefreshInterval;

    //  Cache control

    DWORD       dwMaxCacheSize;
    DWORD       dwCacheEmptyAuthResponses;

    //  Round robin - types that won't be round-robined (default is ALL)

    DWORD       dwNumDoNotRoundRobinTypes;
    PWORD       pwDoNotRoundRobinTypeArray;     //  allocated array

    //  Permanent test flags

    DWORD       dwQuietRecvLogInterval;
    DWORD       dwQuietRecvFaultInterval;

    //  Zone transfers

    DWORD       dwXfrThrottleMultiplier;

    //  Directory partitions

    DWORD       dwEnableDp;
    LPSTR       pszDomainDpBaseName;
    LPSTR       pszForestDpBaseName;
    DWORD       dwDpEnlistInterval;

    //  Strict RFC compliance flags

    BOOL        fSilentlyIgnoreCNameUpdateConflict;

    //  Debugging aids

    PDNS_ADDR_ARRAY     aipUpdateBreakList;
    PDNS_ADDR_ARRAY     aipRecvBreakList;
    DWORD               dwBreakOnAscFailure;
    DWORD               dwIgnoreRpcAccessFailures;

    //  Self diagnosis

    DWORD       dwSelfTestFlag;
    
    //
    //  IPv6 support
    //
    
    DWORD       dwEnableIPv6;
    
    //  Random flags
    
    DWORD       dwEnableFakeIQuery;
    DWORD       dwHeapDebug;

    //  Reusable test flags

    DWORD       fTest1;
    DWORD       fTest2;
    DWORD       fTest3;
    DWORD       fTest4;
    DWORD       fTest5;
    DWORD       fTest6;
    DWORD       fTest7;
    DWORD       fTest8;
    DWORD       fTest9;
}
DNS_SERVER_INFO, *PDNS_SERVER_INFO;


//
//  Server configuration global
//

extern  DNS_SERVER_INFO     SrvInfo;


//
//  Macros to hide storage implementation
//

//  Runtime Info

#define SrvCfg_fStarted                     ( SrvInfo.fStarted )
#define SrvCfg_fThreadAlert                 ( SrvInfo.fThreadAlert )
#define SrvCfg_fServiceExit                 ( SrvInfo.fServiceExit )
#define SrvCfg_fWinsInitialized             ( SrvInfo.fWinsInitialized )
#define SrvCfg_fBootFileDirty               ( SrvInfo.fBootFileDirty )
#define SrvInfo_dwCurrentTime               ( SrvInfo.dwCurrentTime )
#define SrvInfo_crtSystemBootTime           ( SrvInfo.crtSystemBootTime )
#define SrvInfo_fWarnAdmin                  ( SrvInfo.fWarnAdmin )

//  Configuration Info

#define SrvCfg_dwVersion                    ( SrvInfo.dwVersion )
#define SrvCfg_pszServerName                ( SrvInfo.pszServerName )
#define SrvCfg_pszPreviousServerName        ( SrvInfo.pszPreviousServerName )
#define SrvCfg_fEnableRegistryBoot          ( SrvInfo.fEnableRegistryBoot )
#define SrvCfg_fBootMethod                  ( SrvInfo.fBootMethod )
#define SrvCfg_fAdminConfigured             ( SrvInfo.fAdminConfigured )
#define SrvCfg_fRemoteDs                    ( SrvInfo.fRemoteDs )
#define SrvCfg_bReloadException             ( SrvInfo.bReloadException )
#define SrvCfg_cDsZones                     ( SrvInfo.cDsZones )
#define SrvCfg_fDsAvailable                 ( SrvInfo.fDsAvailable )
#define SrvCfg_pwsDatabaseDirectory         ( SrvInfo.pwsDatabaseDirectory )
#define SrvCfg_pszRootHintsFile             ( SrvInfo.pszRootHintsFile )
#define SrvCfg_pwszServerLevelPluginDll     ( SrvInfo.pwszServerLevelPluginDll )
#define SrvCfg_dwEnableAdvancedDatabaseLocking ( SrvInfo.dwEnableAdvancedDatabaseLocking )
#define SrvCfg_dwRpcProtocol                ( SrvInfo.dwRpcProtocol )

#define SrvCfg_dwLogLevel                   ( SrvInfo.dwLogLevel )
#define SrvCfg_dwOperationsLogLevel_LowDword    ( SrvInfo.dwOperationsLogLevel_LowDword )
#define SrvCfg_dwOperationsLogLevel_HighDword   ( SrvInfo.dwOperationsLogLevel_HighDword )
#define SrvCfg_dwOperationsLogLevel         ( SrvInfo.dwOperationsLogLevel )
#define SrvCfg_dwLogFileMaxSize             ( SrvInfo.dwLogFileMaxSize )
#define SrvCfg_pwsLogFilePath               ( SrvInfo.pwsLogFilePath )
#define SrvCfg_aipLogFilterList             ( SrvInfo.aipLogFilterList )
#define SrvCfg_dwEventLogLevel              ( SrvInfo.dwEventLogLevel )
#define SrvCfg_dwUseSystemEventLog          ( SrvInfo.dwUseSystemEventLog )
#define SrvCfg_dwDebugLevel                 ( SrvInfo.dwDebugLevel )
#define SrvCfg_dwEventControl               ( SrvInfo.dwEventControl )

#define SrvCfg_aipServerAddrs               ( SrvInfo.aipServerAddrs )
#define SrvCfg_aipBoundAddrs                ( SrvInfo.aipBoundAddrs )
#define SrvCfg_aipListenAddrs               ( SrvInfo.aipListenAddrs )
#define SrvCfg_aipPublishAddrs              ( SrvInfo.aipPublishAddrs )
#define SrvCfg_fListenAddrsSet              ( SrvInfo.fListenAddrsSet )
#define SrvCfg_fListenAddrsStale            ( SrvInfo.fListenAddrsStale )
#define SrvCfg_fDisjointNets                ( SrvInfo.fDisjointNets )
#define SrvCfg_fNoTcp                       ( SrvInfo.fNoTcp )
#define SrvCfg_dwSendPort                   ( SrvInfo.dwSendPort )

#define SrvCfg_aipForwarders                ( SrvInfo.aipForwarders )
#define SrvCfg_dwForwardTimeout             ( SrvInfo.dwForwardTimeout )
#define SrvCfg_fSlave                       ( SrvInfo.fSlave )
#define SrvCfg_fNoRecursion                 ( SrvInfo.fNoRecursion )
#define SrvCfg_fRecurseSingleLabel          ( SrvInfo.fRecurseSingleLabel )
#define SrvCfg_fRecursionAvailable          ( SrvInfo.fRecursionAvailable )
#define SrvCfg_dwRecursionRetry             ( SrvInfo.dwRecursionRetry )
#define SrvCfg_dwRecursionTimeout           ( SrvInfo.dwRecursionTimeout )
#define SrvCfg_dwAdditionalRecursionTimeout ( SrvInfo.dwAdditionalRecursionTimeout )
#define SrvCfg_dwXfrConnectTimeout          ( SrvInfo.dwXfrConnectTimeout )
#define SrvCfg_dwTcpRecvPacketSize          ( SrvInfo.dwTcpRecvPacketSize )
#define SrvCfg_dwMaxCacheTtl                ( SrvInfo.dwMaxCacheTtl )
#define SrvCfg_dwMaxNegativeCacheTtl        ( SrvInfo.dwMaxNegativeCacheTtl)
#define SrvCfg_dwLameDelegationTtl          ( SrvInfo.dwLameDelegationTtl)
#define SrvCfg_fSecureResponses             ( SrvInfo.fSecureResponses )
#define SrvCfg_fForwardDelegations          ( SrvInfo.fForwardDelegations )
#define SrvCfg_dwRecurseToInetRootMask      ( SrvInfo.dwRecurseToInetRootMask )
#define SrvCfg_dwAutoCreateDelegations      ( SrvInfo.dwAutoCreateDelegations )
#define SrvCfg_dwAllowCNAMEAtNS             ( SrvInfo.dwAllowCNAMEAtNS )

#define SrvCfg_fRoundRobin                  ( SrvInfo.fRoundRobin )
#define SrvCfg_fLocalNetPriority            ( SrvInfo.fLocalNetPriority )
#define SrvCfg_dwLocalNetPriorityNetMask    ( SrvInfo.dwLocalNetPriorityNetMask )
#define SrvCfg_cAddressAnswerLimit          ( SrvInfo.cAddressAnswerLimit )
#define SrvCfg_fBindSecondaries             ( SrvInfo.fBindSecondaries )
#define SrvCfg_fWriteAuthorityNs            ( SrvInfo.fWriteAuthorityNs )
#define SrvCfg_fWriteAuthority              ( SrvInfo.fWriteAuthorityNs )
#define SrvCfg_fStrictFileParsing           ( SrvInfo.fStrictFileParsing )
#define SrvCfg_fDeleteOutsideGlue           ( SrvInfo.fDeleteOutsideGlue )
#define SrvCfg_fLooseWildcarding            ( SrvInfo.fLooseWildcarding )
#define SrvCfg_fAppendMsTagToXfr            ( SrvInfo.fAppendMsTagToXfr )

#define SrvCfg_fAllowUpdate                 ( SrvInfo.fAllowUpdate )
#define SrvCfg_dwUpdateOptions              ( SrvInfo.dwUpdateOptions)
#define SrvCfg_fNoUpdateDelegations         ( SrvInfo.fNoUpdateDelegations )
#define SrvCfg_dwEnableUpdateForwarding     ( SrvInfo.dwEnableUpdateForwarding )
#define SrvCfg_dwMaxRRsInNonSecureUpdate    ( SrvInfo.dwMaxRRsInNonSecureUpdate )
#define SrvCfg_dwEnableWinsR                ( SrvInfo.dwEnableWinsR )
#define SrvCfg_dwNameCheckFlag              ( SrvInfo.dwNameCheckFlag )

#define SrvCfg_fAutoConfigFileZones         ( SrvInfo.fAutoConfigFileZones )
#define SrvCfg_fPublishAutonet              ( SrvInfo.fPublishAutonet )
#define SrvCfg_fNoAutoReverseZones          ( SrvInfo.fNoAutoReverseZones )
#define SrvCfg_fAutoCacheUpdate             ( SrvInfo.fAutoCacheUpdate )
#define SrvCfg_fNoAutoNSRecords             ( SrvInfo.fNoAutoNSRecords )

#define SrvCfg_dwSyncDsZoneSerial           ( SrvInfo.dwSyncDsZoneSerial)
#define SrvCfg_dwDsPollingInterval          ( SrvInfo.dwDsPollingInterval )
#define SrvCfg_dwDsTombstoneInterval        ( SrvInfo.dwDsTombstoneInterval )
#define SrvCfg_dwDsLazyUpdateInterval       ( SrvInfo.dwDsLazyUpdateInterval )

#define SrvCfg_dwForceDomainBehaviorVersion ( SrvInfo.dwForceDomainBehaviorVersion )
#define SrvCfg_dwForceForestBehaviorVersion ( SrvInfo.dwForceForestBehaviorVersion )
#define SrvCfg_dwForceDsaBehaviorVersion    ( SrvInfo.dwForceDsaBehaviorVersion )

#define SrvCfg_dwScavengingInterval         ( SrvInfo.dwScavengingInterval )
#define SrvCfg_fDefaultAgingState           ( SrvInfo.fDefaultAgingState)
#define SrvCfg_dwDefaultRefreshInterval     ( SrvInfo.dwDefaultRefreshInterval )
#define SrvCfg_dwDefaultNoRefreshInterval   ( SrvInfo.dwDefaultNoRefreshInterval )

#define SrvCfg_dwMaxCacheSize               ( SrvInfo.dwMaxCacheSize )
#define SrvCfg_dwCacheEmptyAuthResponses    ( SrvInfo.dwCacheEmptyAuthResponses )

#define SrvCfg_dwForceSoaSerial             ( SrvInfo.dwForceSoaSerial )
#define SrvCfg_dwForceSoaMinimumTtl         ( SrvInfo.dwForceSoaMinimumTtl )
#define SrvCfg_dwForceSoaRefresh            ( SrvInfo.dwForceSoaRefresh )
#define SrvCfg_dwForceSoaRetry              ( SrvInfo.dwForceSoaRetry )
#define SrvCfg_dwForceSoaExpire             ( SrvInfo.dwForceSoaExpire )
#define SrvCfg_dwForceNsTtl                 ( SrvInfo.dwForceNsTtl )
#define SrvCfg_dwForceTtl                   ( SrvInfo.dwForceTtl )

#define SrvCfg_dwMaxUdpPacketSize           ( SrvInfo.dwMaxUdpPacketSize )

#define SrvCfg_dwEDnsCacheTimeout           ( SrvInfo.dwEDnsCacheTimeout )
#define SrvCfg_dwEnableEDnsProbes           ( SrvInfo.dwEnableEDnsProbes )
#define SrvCfg_dwEnableEDnsReception        ( SrvInfo.dwEnableEDnsReception )

#define SrvCfg_dwEnableDnsSec               ( SrvInfo.dwEnableDnsSec )

#define SrvCfg_dwEnableSendErrSuppression   ( SrvInfo.dwEnableSendErrSuppression )

#define SrvCfg_dwEnableFakeIQuery           ( SrvInfo.dwEnableFakeIQuery )
#define SrvCfg_dwHeapDebug                  ( SrvInfo.dwHeapDebug )

#define SrvCfg_dwNumDoNotRoundRobinTypes    ( SrvInfo.dwNumDoNotRoundRobinTypes )
#define SrvCfg_pwDoNotRoundRobinTypeArray   ( SrvInfo.pwDoNotRoundRobinTypeArray )


//
//  Globals to tweak behavior during testing
//

#define DNS_REGKEY_QUIET_RECV_LOG_INTERVAL      "QuietRecvLogInterval"
#define DNS_REGKEY_QUIET_RECV_FAULT_INTERVAL    "QuietRecvFaultInterval"

#define SrvCfg_dwQuietRecvLogInterval       ( SrvInfo.dwQuietRecvLogInterval )
#define SrvCfg_dwQuietRecvFaultInterval     ( SrvInfo.dwQuietRecvFaultInterval )


//
//  Zone transfers
//

#define SrvCfg_dwXfrThrottleMultiplier  ( SrvInfo.dwXfrThrottleMultiplier )


//
//  Directory partitions
//

#define SrvCfg_dwEnableDp               ( SrvInfo.dwEnableDp )
#define SrvCfg_pszDomainDpBaseName      ( SrvInfo.pszDomainDpBaseName )
#define SrvCfg_pszForestDpBaseName      ( SrvInfo.pszForestDpBaseName )
#define SrvCfg_dwDpEnlistInterval       ( SrvInfo.dwDpEnlistInterval )


//
//  String RFC compliance flags
//

#define SrvCfg_fSilentlyIgnoreCNameUpdateConflict  ( SrvInfo.fSilentlyIgnoreCNameUpdateConflict)


//
//  Debugging aids
//

#define SrvCfg_dwBreakOnAscFailure          ( SrvInfo.dwBreakOnAscFailure )
#define SrvCfg_aipUpdateBreakList           ( SrvInfo.aipUpdateBreakList )
#define SrvCfg_aipRecvBreakList             ( SrvInfo.aipRecvBreakList )
#define SrvCfg_dwIgnoreRpcAccessFailures    ( SrvInfo.dwIgnoreRpcAccessFailures )



//
//  Self diagnosis
//

#define SrvCfg_dwSelfTestFlag               ( SrvInfo.dwSelfTestFlag )

//
//  IPv6 support
//

#define SrvCfg_dwEnableIPv6                 ( SrvInfo.dwEnableIPv6 )


//
//  Reusable test flags
//

#define DNS_REGKEY_TEST1                    "Test1"
#define DNS_REGKEY_TEST2                    "Test2"
#define DNS_REGKEY_TEST3                    "Test3"
#define DNS_REGKEY_TEST4                    "Test4"
#define DNS_REGKEY_TEST5                    "Test5"
#define DNS_REGKEY_TEST6                    "Test6"
#define DNS_REGKEY_TEST7                    "Test7"
#define DNS_REGKEY_TEST8                    "Test8"
#define DNS_REGKEY_TEST9                    "Test9"

#define SrvCfg_fTest1                       ( SrvInfo.fTest1 )
#define SrvCfg_fTest2                       ( SrvInfo.fTest2 )
#define SrvCfg_fTest3                       ( SrvInfo.fTest3 )
#define SrvCfg_fTest4                       ( SrvInfo.fTest4 )
#define SrvCfg_fTest5                       ( SrvInfo.fTest5 )
#define SrvCfg_fTest6                       ( SrvInfo.fTest6 )
#define SrvCfg_fTest7                       ( SrvInfo.fTest7 )
#define SrvCfg_fTest8                       ( SrvInfo.fTest8 )
#define SrvCfg_fTest9                       ( SrvInfo.fTest9 )

//
//  Current test flag owners
//
//  Test1 --
//  Test2 --
//  Test3 -- turn off bad IP suppression
//  Test4 --
//  Test5 --
//  Test6 -- set SecBigTimeSkew
//  Test7 -- memory (small allocs)
//  Test8 -- always indicate DS available
//  Test9 -- RPC old SD used as global SD;  allow zone checks
//


//
//  Auto-config file zones
//

#define ZONE_AUTO_CONFIG_NONE                   (0)
#define ZONE_AUTO_CONFIG_UPDATE                 (0x00000001)
#define ZONE_AUTO_CONFIG_STATIC                 (0x00000002)
#define ZONE_AUTO_CONFIG_ALL                    (0x00000003)

#define DNS_DEFAULT_AUTO_CONFIG_FILE_ZONES      ( ZONE_AUTO_CONFIG_UPDATE )

//
//  DS zone serial sync
//

#define ZONE_SERIAL_SYNC_OFF                    (0)
#define ZONE_SERIAL_SYNC_SHUTDOWN               (1)
#define ZONE_SERIAL_SYNC_XFR                    (2)
#define ZONE_SERIAL_SYNC_VIEW                   (3)
#define ZONE_SERIAL_SYNC_READ                   (4)

#define DNS_DEFAULT_SYNC_DS_ZONE_SERIAL         ( ZONE_SERIAL_SYNC_READ )

//
//  Update options (bitmask)
//
//  Defaults:
//  - non-secure -> no NS or SOA or server host
//  - secure -> no NS or SOA at root;
//      allow delegations and server host updates
//

#define UPDATE_ANY                              (0)
#define UPDATE_NO_SOA                           (0x00000001)
#define UPDATE_NO_ROOT_NS                       (0x00000002)
#define UPDATE_NO_DELEGATION_NS                 (0x00000004)
#define UPDATE_NO_SERVER_HOST                   (0x00000008)
#define UPDATE_SECURE_NO_SOA                    (0x00000100)
#define UPDATE_SECURE_NO_ROOT_NS                (0x00000200)
#define UPDATE_SECURE_NO_DELEGATION_NS          (0x00000400)
#define UPDATE_SECURE_NO_SERVER_HOST            (0x00000800)

#define UPDATE_NO_DS_PEERS                      (0x01000000)
//  #define UPDATE_OFF                              (0x80000000)        //  unused - NT4??

#define DNS_DEFAULT_UPDATE_OPTIONS              (0x0000030f)

//
//  Publishing autonet addresses
//

#define DNS_REGKEY_PUBLISH_AUTONET              "PublishAutonet"
#define DNS_DEFAULT_PUBLISH_AUTONET             (FALSE)


//
//  Server configuration locking
//
//  DEVNOTE:  need to do something here to insure integrity
//              when mutliple writers, perhaps just use zone list cs
//

#define Config_UpdateLock()
#define Config_UpdateUnlock()


//
//  On fresh installs EnableRegistryBoot is not set either way.
//  Default fBootMethod to this flag to determine if in this state.
//

#define DNS_FRESH_INSTALL_BOOT_REGISTRY_FLAG    ((DWORD)(-1))

//
//  DS state unknown on startuap
//  Can not just do immediate ldap_open() because DS can
//  take a long time after boot to load -- much longer than DNS server
//

#define DS_STATE_UNKNOWN                        ((DWORD)(-1))


#define DNS_REG_IPARRAY     0x00010000  //  Bogus type for DNS_PROPERTY_VALUE
#define DNS_REG_ADDRARRAY   0x00020000  //  Bogus type for DNS_PROPERTY_VALUE

typedef struct
{
    DWORD           dwPropertyType;     //  REG_DWORD or one of DNS_REG_XXX
    union
    {
        DWORD               dwValue;
        LPSTR               pszValue;
        LPWSTR              pwszValue;
        PDNS_ADDR_ARRAY     pipArrayValue;
    };
} DNS_PROPERTY_VALUE, *PDNS_PROPERTY_VALUE;


BOOL
Config_Initialize(
    VOID
    );

DNS_STATUS
Config_ResetProperty(
    IN      DWORD                   dwRegFlags,
    IN      LPSTR                   pszPropertyName,
    IN      PDNS_PROPERTY_VALUE     pPropValue
    );

VOID
Config_PostLoadReconfiguration(
    VOID
    );

//
//  Create non-local IP array
//

PDNS_ADDR_ARRAY
Config_ValidateAndCopyNonLocalIpArray(
    IN      PDNS_ADDR_ARRAY     pipArray
    );

//
//  Set server's IP address interfaces
//

DNS_STATUS
Config_SetListenAddresses(
    IN      PDNS_ADDR_ARRAY     aipListenAddrs
    );

//
//  Forwarders configuration
//

DNS_STATUS
Config_SetupForwarders(
    IN      PDNS_ADDR_ARRAY     aipForwarders,
    IN      DWORD               dwForwardTimeout,
    IN      BOOL                fSlave
    );

DNS_STATUS
Config_ReadForwarders(
    VOID
    );

//
//  Boot info update
//

VOID
Config_UpdateBootInfo(
    VOID
    );

//
//  File Directory
//

DNS_STATUS
Config_ReadDatabaseDirectory(
    IN      PCHAR           pchDirectory,       OPTIONAL
    IN      DWORD           cchDirectoryNameLength
    );


//
//  Time keeping
//

#define DNS_TIME()  ( SrvInfo_dwCurrentTime )

#define DNS_STARTUP_TIME()  (( SrvInfo_dwCurrentTime )       \
                                ? SrvInfo_dwCurrentTime      \
                                : GetCurrentTimeInSeconds() )

#define UPDATE_DNS_TIME()   ( DNS_TIME() = Dns_GetCurrentTimeInSeconds() )

#define DNS_TIME_TO_CRT_TIME( dnsTime )     ( SrvInfo_crtSystemBootTime + dnsTime )


#endif //   _DNS_SRVCFG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\test.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    test.c

Abstract:

    Test code for DNS server.

Author:

    Jeff Westhead (jwesth)     June 2002

Revision History:

--*/


#include "dnssrv.h"


#if DBG



DNS_STATUS
Test_Thread(
    IN      PVOID           pvDummy
    )
/*++

Routine Description:

    Test thread.

Arguments:

    Unreferenced.

Return Value:

--*/
{
    PDNS_MSGINFO    pMsg = Packet_AllocateUdpMessage();
    int             i = 0;

    while ( 1 )
    {
        for ( i = 0; Thread_ServiceCheck() && i < 60; ++i )
        {
            Sleep( 1000 );
            
            DNS_LOG_EVENT_BAD_PACKET(
                DNS_EVENT_BAD_UPDATE_PACKET,
                pMsg );
        }
        
        Sleep( 4 * 60000 );    //  Sleep 4 minutes to allow suppression to turn itself off.
    }
    
    return 0;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\tcpcon.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    tcpcon.c

Abstract:

    Domain Name System (DNS) Server

    TCP connection list routines.  Manages list of current TCP client
    connections to the DNS server.

Author:

    Jim Gilroy (jamesg) June 20, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  DEVNOTE: fd_set limits???
//

//
//  Implementation note:
//
//  TCP connection structures are NOT FULLY thread safe.
//
//  The list is protected for insertion and deletion.
//  The routines that operate on TCP connection structures -- associating
//  messages and timeouts with the connections -- are NOT protected and
//  are assumed to be called ONLY FROM TCP RECIEVE thread.
//


//
//  TCP client connection list.
//

BOOL        mg_TcpConnectionListInitialized;

LIST_ENTRY  mg_TcpConnectionList;

CRITICAL_SECTION    mg_TcpConnectionListCS;

#define LOCK_TCPCON_LIST()     EnterCriticalSection( &mg_TcpConnectionListCS )
#define UNLOCK_TCPCON_LIST()   LeaveCriticalSection( &mg_TcpConnectionListCS )


//
//  Timeout
//      - in-bound connections killed after one minute of no action
//      - out-bound given 15s for query\response
//

#define DNS_TCP_CONNECTION_TIMEOUT      (60)

#define TCP_QUERY_TIMEOUT               (15)

#define DNSCON_NO_TIMEOUT               (MAXULONG)


//
//  Wakeup socket included in TCP select()
//
//  Allows us to enter new connections (for TCP recursion)
//  into connection list.
//  Flag to indicate need for new wakeup socket.
//

SOCKET  g_TcpSelectWakeupSocket;

BOOL    g_bTcpSelectWoken;

SOCKADDR_IN     wakeupSockaddr;




//
//  Connection list utils
//

PDNS_SOCKET
Tcp_ConnectionFindForSocket(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Find TCP connection for socket.

Arguments:

    Socket -- socket to find connection for

Return Value:

    Ptr to connection, if found.
    NULL otherwise.

--*/
{
    PDNS_SOCKET pcon;

    //
    //  loop through all active TCP connections checking for socket
    //

    LOCK_TCPCON_LIST();

    pcon = (PDNS_SOCKET) mg_TcpConnectionList.Flink;

    while ( (PLIST_ENTRY)pcon != &mg_TcpConnectionList )
    {
        if ( pcon->Socket == Socket )
        {
            UNLOCK_TCPCON_LIST();
            return pcon;
        }
        pcon = (PDNS_SOCKET) pcon->List.Flink;
    }
    UNLOCK_TCPCON_LIST();
    return NULL;
}



VOID
tcpConnectionDelete(
    IN OUT  PDNS_SOCKET     pTcpCon,
    IN OUT  PLIST_ENTRY     pCallbackList
    )
/*++

Routine Description:

    Delete TCP connection.
        - close the socket
        - remove connection from list
        - free the memory
        - free the message info (if any)

    However if connection requires callback, the connection blob is not
    freed, but returned to caller for callback completion.

Arguments:

    pTcpCon -- connection to delete

Return Value:

    NULL completely deleted.
    Ptr to connection, if requires callback cleanup.

--*/
{
    ASSERT( !pTcpCon->pCallback || pTcpCon->pMsg );

    //
    //  delete connection
    //    - remove connection from list
    //    - close the socket
    //    - free the memory
    //
    //  closing after removal so new socket with same handle can not
    //      be in list
    //

    DNS_DEBUG( TCP, (
        "Closing TCP client connection (%p) socket %d\n",
        pTcpCon,
        pTcpCon->Socket ));

    //
    //  hold lock until connection out of list
    //      AND
    //  references to it in message are eliminated
    //
    //  delete message, EXCEPT when connecting, those message are
    //      recursive queries that are resent
    //

    LOCK_TCPCON_LIST();
    RemoveEntryList( &pTcpCon->List );
    UNLOCK_TCPCON_LIST();

    closesocket( pTcpCon->Socket );

    if ( pTcpCon->pMsg )
    {
        PDNS_MSGINFO  pmsg = pTcpCon->pMsg;

        if ( !pTcpCon->pCallback )
        {
            DNS_DEBUG( TCP, (
                "WARNING:  connection timeout for socket with EXISTING message\n"
                "    Socket = %d\n"
                "    Deleting associated message at %p\n"
                "    Message is %scomplete\n",
                pTcpCon->Socket,
                pmsg,
                pmsg->fMessageComplete ? "IN" : "" ));

            ASSERT( pmsg->pConnection == pTcpCon );
            ASSERT( pmsg->Socket == pTcpCon->Socket );
#if DBG
            // free routine will ASSERT no outstanding connection
            pmsg->pConnection = NULL;
#endif
            Packet_Free( pmsg );
        }

        else
        {
            DNS_DEBUG( TCP, (
                "Deleting callback connection %p, with pMsg %p\n",
                pTcpCon,
                pmsg ));

            InsertTailList( pCallbackList, (PLIST_ENTRY)pTcpCon );
            return;
        }
    }

    FREE_TAGHEAP( pTcpCon, 0, MEMTAG_CONNECTION );
}



VOID
callbackConnectFailureList(
    IN      PLIST_ENTRY     pCallbackList
    )
/*++

Routine Description:

    Cleanup list of TCP connection failures.
        - connection (socket) closed
        - pMsg cleared from connection, and returned to UDP
        - callback function called

    Need list, as may be several when do a timeout.

Arguments:

    pCallbackList -- list of connection callbacks

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    PDNS_SOCKET         pcon;
    PDNS_SOCKET         pconNext;
    PDNS_MSGINFO        pmsg;
    CONNECT_CALLBACK    pcallback;

    //  DEVNOTE: missing failure stat


    DNS_DEBUG( TCP, ( "tcpConnectFailureCallback()\n" ));

    pconNext = (PDNS_SOCKET) pCallbackList->Flink;

    while ( (pcon = pconNext) && pcon != (PDNS_SOCKET)pCallbackList )
    {
        DNS_DEBUG( TCP, (
            "Connect failure callback (pcon=%p, sock=%d, pmsg=%p)\n",
            pcon,
            pcon->Socket,
            pcon->pMsg ));

        pconNext = (PDNS_SOCKET) pcon->List.Flink;

        //  extract connection info

        pcallback = pcon->pCallback;
        ASSERT( pcallback );

        pmsg = pcon->pMsg;
        ASSERT( pmsg && pmsg->fTcp );

        //
        //  clear TCP info from message
        //  dispatch to connect callback with failed indication
        //

        pmsg->pConnection = NULL;
        pmsg->fTcp = FALSE;
        pmsg->Socket = g_UdpSendSocket;

        (pcallback)( pmsg, FALSE );

        //  delete connection block

        FREE_TAGHEAP( pcon, 0, MEMTAG_CONNECTION );
    }
}



//
//  Public TCP connection list routines
//

BOOL
Tcp_ConnectionListFdSet(
    IN OUT  fd_set *        pReadFdSet,
    IN OUT  fd_set *        pWriteFdSet,
    IN OUT  fd_set *        pExceptFdSet,
    IN      DWORD           dwLastSelectTime
    )
/*++

Routine Description:

    Add TCP connection list sockets to fd_set.
    Timeout connections that were already past timeout at last select.

Arguments:

    None.

Return Value:

    TRUE if connecting socket
    FALSE otherwise

--*/
{
    PDNS_SOCKET pcon;
    PDNS_SOCKET pconNext;
    BOOL        fconnecting = FALSE;
    LIST_ENTRY  callbackList;

    //  init callback failure list

    InitializeListHead( &callbackList );

    //
    //  empty wakeups
    //
    //  need to do this BEFORE build list, so that any wakeup requested
    //  while we build list will be processed on the next cycle
    //

    if ( g_bTcpSelectWoken )
    {
        DWORD   buf;
        INT     err;

        g_bTcpSelectWoken = FALSE;
        while( 1 )
        {
            err = recvfrom(
                        g_TcpSelectWakeupSocket,
                        (PBYTE) &buf,
                        sizeof(DWORD),
                        0,
                        NULL,
                        0 );
            if ( err > 0 )
            {
                DNS_DEBUG( TCP, (
                    "Received %d bytes (bufval=%p) on wakeup socket\n",
                    err,
                    buf ));
                continue;
            }

            err = WSAGetLastError();
            if ( err != WSAEWOULDBLOCK )
            {
                DNS_PRINT((
                    "ERROR:  error %d other than WOULDBLOCK on wakeup socket\n",
                    err ));
                ASSERT( fDnsServiceExit );      // will fail WSAENOTSOCK on shutdown
            }
            break;
        }
    }

    //
    //  DEVNOTE: reaching FD_SETSIZE
    //
    //      should have own TCP starting value
    //      at minimum check and log when reached limit, perhaps
    //          dump longest waiting connection
    //      alternatively, realloc when overflow
    //

    //
    //  loop through all active TCP connections
    //

    LOCK_TCPCON_LIST();

    pconNext = (PDNS_SOCKET) mg_TcpConnectionList.Flink;

    while ( (PLIST_ENTRY)pconNext != &mg_TcpConnectionList )
    {
        //  get next here, since connection may be deleted

        pcon = pconNext;
        pconNext = (PDNS_SOCKET) pconNext->List.Flink;

        //
        //  timeout reached
        //

        if ( dwLastSelectTime > pcon->dwTimeout )
        {
            DNS_DEBUG( TCP, (
                "Timing out connection on TCP socket %d\n",
                pcon->Socket ));

            tcpConnectionDelete( pcon, &callbackList );
            continue;
        }

        //
        //  socket is connecting to remote DNS
        //      - add to Write and Except FD_SETs
        //      - clear them if this is first connector
        //

        if ( pcon->pCallback )
        {
            DNS_DEBUG( TCP, (
                "Add TCP connect attempt on socket %d to connect fd_sets\n"
                "    connect block = %p\n",
                pcon->Socket,
                pcon ));

            if ( !fconnecting )
            {
                FD_ZERO( pWriteFdSet );
                FD_ZERO( pExceptFdSet );
            }
            fconnecting = TRUE;

            if ( pWriteFdSet->fd_count < FD_SETSIZE )
            {
                FD_SET( pcon->Socket, pWriteFdSet );
                FD_SET( pcon->Socket, pExceptFdSet );
                continue;
            }
        }

        //
        //  add socket to read fd_set
        //      - check that don't overflow fd_set, always leaving space
        //      in fd_set for wakeup socket
        //

        else if ( pReadFdSet->fd_count < FD_SETSIZE-1 )
        {
            FD_SET( pcon->Socket, pReadFdSet );
            continue;
        }

        //
        //  out of space in fd_set
        //
        //  DEVNOTE-LOG: log dropping connection
        //

        DNS_DEBUG( ANY, (
            "ERROR:  TCP FD_SET overflow\n"
            "    deleting connection on TCP socket %d\n",
            pcon->Socket ));

        tcpConnectionDelete( pcon, &callbackList );
    }

    //
    //  add select() wakeup socket to fd_set
    //

    FD_SET( g_TcpSelectWakeupSocket, pReadFdSet );

    UNLOCK_TCPCON_LIST();

    //
    //  cleanup any timedout (or dropped) connect attempt failures
    //

    callbackConnectFailureList( &callbackList );

    //  return value indicates whether connecting sockets
    //  at in Write and Except fd_sets

    return fconnecting;
}



BOOL
Tcp_ConnectionCreate(
    IN      SOCKET              Socket,
    IN      CONNECT_CALLBACK    pCallback,  OPTIONAL
    IN OUT  PDNS_MSGINFO        pMsg
    )
/*++

Routine Description:

    Create entry in connection list for new connection.

    Note:  this routine is NOT truly multi-thread safe.  It assumes
    only ONE thread will own socket at a particular time.  It does
    NOT check whether socket is already in list, while holding CS.

Arguments:

    Socket - socket for new connection.

    pCallback - connecting failed callback

    pMsg - message currently servicing connection

Return Value:

    None

--*/
{
    register PDNS_SOCKET    pcon;
    DWORD   timeout;

    //
    //  create connection struct
    //

    pcon = ALLOC_TAGHEAP_ZERO( sizeof(DNS_SOCKET), MEMTAG_CONNECTION );
    IF_NOMEM( !pcon )
    {
        return FALSE;
    }

    //
    //  set values
    //      - socket
    //      - remote IP
    //      - message ptr
    //      - timeout

    pcon->pCallback = pCallback;
    pcon->Socket    = Socket;
    pcon->pMsg      = pMsg;
    DnsAddr_Copy( &pcon->ipRemote, &pMsg->RemoteAddr );

    timeout = DNS_TCP_CONNECTION_TIMEOUT;
    if ( pCallback )
    {
        timeout = SrvCfg_dwXfrConnectTimeout;
    }
    pcon->dwTimeout = DNS_TIME() + timeout;

    //
    //  alert message that it is connected
    //  indicate that message is incomplete
    //

    if ( pMsg )
    {
        pMsg->pConnection = pcon;
        pMsg->fMessageComplete = FALSE;
    }

    IF_DEBUG( TCP )
    {
        Dbg_SocketContext(
            "TCP Connection Create",
            pcon );
    }

    //
    //  insert connection
    //      - front of list, so socket ends up at front of fd_set
    //        which is important until have guaranteed inclusion in
    //        read fd_set
    //
    //  if connect attempt, then wake TCP select() to force rebuild
    //      of lists
    //

    LOCK_TCPCON_LIST();

    InsertHeadList( &mg_TcpConnectionList, (PLIST_ENTRY)pcon );

    if ( pCallback )
    {
        Tcp_ConnectionListReread();
    }
    UNLOCK_TCPCON_LIST();
    return TRUE;
}



VOID
Tcp_ConnectionListReread(
    VOID
    )
/*++

Routine Description:

    Force rebuild of connection list by waking socket.

Arguments:

    None

Return Value:

    None

--*/
{
    DNS_DEBUG( TCP, ( "Waking TCP select()\n" ));

    //
    //  send to wakeup socket triggering TCP select()
    //  protect with CS, so that we protect the g_bTcpSelectWoken flag
    //      otherwise TCP thread could have just built its list and then
    //      set the flag FALSE, immediately after we read it as TRUE
    //  alternative is to ALWAYS send which is more expensive
    //

    LOCK_TCPCON_LIST();

    if ( ! g_bTcpSelectWoken )
    {
        DWORD   buf;
        INT     err;

        g_bTcpSelectWoken = TRUE;
        err = sendto(
                    g_TcpSelectWakeupSocket,
                    (PBYTE) &buf,
                    sizeof(DWORD),
                    0,
                    (PSOCKADDR) &wakeupSockaddr,
                    sizeof(SOCKADDR_IN) );
        if ( err < 0 )
        {
            err = WSAGetLastError();
            if ( err != WSAEWOULDBLOCK )
            {
                DNS_PRINT((
                    "ERROR:  error %d other than WOULDBLOCK on wakeup socket send\n",
                    err ));
                ASSERT( FALSE );
            }
        }
    }

    UNLOCK_TCPCON_LIST();
}



VOID
Tcp_ConnectionDeleteForSocket(
    IN      SOCKET          Socket,
    IN      PDNS_MSGINFO    pMsg        OPTIONAL
    )
/*++

Routine Description:

    Delete TCP connection.
        - close the socket
        - remove connection from list
        - free the memory

Arguments:

    Socket -- socket to delete connection for

    pMsg -- message associated with connection, if known

Return Value:

    None

--*/
{
    PDNS_SOCKET     pcon;
    PDNS_MSGINFO    pfreeMsg = NULL;
    LIST_ENTRY      callbackList;

    //  init callback failure list

    InitializeListHead( &callbackList );

    //
    //  find connection for socket
    //

    LOCK_TCPCON_LIST();

    pcon = Tcp_ConnectionFindForSocket( Socket );
    if ( !pcon )
    {
        DNS_DEBUG( TCP, (
            "WARNING:  Socket NOT FOUND in TCP client connection list\n"
            "    Closing socket %d\n",
            Socket ));

        Sock_CloseSocket( Socket );
        if ( pMsg )
        {
            Packet_Free( pMsg );
        }
        UNLOCK_TCPCON_LIST();
        return;
    }

    //
    //  delete TCP connection blob
    //

    ASSERT( !pMsg || pMsg->Socket == Socket );

    ASSERT( !pMsg || pcon->pMsg == pMsg );
    ASSERT( !pMsg || pMsg->pConnection == pcon );

    if ( pMsg && pMsg != pcon->pMsg )
    {
        DNS_PRINT((
            "ERROR:  Freeing pMsg=%p, not associated with connection %p\n",
            pMsg,
            pcon ));

        pfreeMsg = pMsg;
        ASSERT( FALSE );
    }

    //  delete connection, close socket

    tcpConnectionDelete( pcon, &callbackList );

    UNLOCK_TCPCON_LIST();

    //  callback with failure

    callbackConnectFailureList( &callbackList );

    //  free standalone message

    if ( pfreeMsg )
    {
        Packet_Free( pfreeMsg );
    }
}



PDNS_MSGINFO
Tcp_ConnectionMessageFindOrCreate(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Find message associated with TCP connection.

    If existing message -- return it.
    If NO existing message -- allocate new message.

Arguments:

    Socket -- socket to find connection for

Return Value:

    Ptr to connection, if found.
    NULL otherwise.

--*/
{
    PDNS_SOCKET     pcon;
    PDNS_MSGINFO    pmsg;

    //
    //  find connection for this socket
    //

    pcon = Tcp_ConnectionFindForSocket( Socket );
    if ( !pcon )
    {
        DNS_PRINT((
            "WARNING:  tcpConnectionFindForSocket( %d )\n"
            "    NO connection for this socket\n"
            "    This may happen when closing listening socket\n",
            Socket ));

        //
        //  DEVNOTE: not sure this is correct approach,
        //      ideally we'd detect whether this was previously closed
        //      listening socket and only close when it was not
        //
        // Sock_CloseSocket( Socket );

        return NULL;
    }

    //
    //  verify this is connected socket -- connection callback should be gone
    //
    //  really want the check, because MUST not allow pMsg on callback to be
    //      interpreted as RECEIVE message;  if there's a window on connection
    //      completion and callback MUST find it
    //
    //  a window could well exist if remote DNS SENDS a packet on connection before
    //  even getting query -- need to make sure handle connection response first
    //  cleaning callback, before handling incoming, in case socket is in both
    //  FD_SETs
    //

    if ( pcon->pCallback )
    {
        DNS_PRINT((
            "ERROR:  attempting to recv() on connecting socket %d\n"
            "    pContext = %p\n",
            Socket,
            pcon ));
        ASSERT( FALSE );
        return NULL;
    }

    //
    //  found connection for socket, update timeout
    //

    if ( pcon->dwTimeout != DNSCON_NO_TIMEOUT )
    {
        pcon->dwTimeout = DNS_TIME() + DNS_TCP_CONNECTION_TIMEOUT;
    }

    //
    //  message exists?
    //

    pmsg = pcon->pMsg;
    if ( pmsg )
    {
        ASSERT( pmsg->Socket == Socket );
        ASSERT( pmsg->pConnection == pcon );
        ASSERT( ! pmsg->fMessageComplete );
        return( pmsg );
    }

    //
    //  no current message
    //      - allocate new one (default size)
    //      - set to this socket
    //      - attach it to connection
    //

    pmsg = Packet_AllocateTcpMessage( 0 );
    IF_NOMEM( !pmsg )
    {
        DNS_PRINT((
            "ERROR:  Allocating TCP message for socket %d\n"
            "    Deleting TCP connection at %p\n",
            Socket,
            pcon ));
        ASSERT( FALSE );
        tcpConnectionDelete( pcon, NULL );
        return NULL;
    }

    pmsg->pConnection = pcon;
    pmsg->Socket = Socket;
    DnsAddr_Copy( &pmsg->RemoteAddr, &pcon->ipRemote );

    pcon->pMsg = pmsg;

    return pmsg;
}



VOID
Tcp_ConnectionUpdateTimeout(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Reset timeout on TCP connection.

Arguments:

    Socket -- socket to reset timeout on

Return Value:

    None

--*/
{
    PDNS_SOCKET pcon;

    //
    //  find connection for socket and update timeout (if necessary)
    //

    LOCK_TCPCON_LIST();

    pcon = Tcp_ConnectionFindForSocket( Socket );
    if ( pcon )
    {
        if ( pcon->dwTimeout < DNSCON_NO_TIMEOUT )
        {
            pcon->dwTimeout = DNS_TIME() + DNS_TCP_CONNECTION_TIMEOUT;
        }
    }
    else
    {
        //  socket not found in connection list
        //
        //  although unlikely this is possible, if the TCP recv thread recv()s
        //  a FIN and closes the connection between the send() and the
        //  call to the update connection routine

        DNS_DEBUG( TCP, (
            "WARNING:  Attempt to update socket %d, not in connection list\n",
            Socket ));
    }

    UNLOCK_TCPCON_LIST();
}



VOID
Tcp_ConnectionUpdateForCompleteMessage(
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Reset connection to point at correct socket, on realloc.

        - clear message info from connection info
        - reset timeout on TCP connection

Arguments:

    pMsg -- message received on connection

Return Value:

    None

--*/
{
    PDNS_SOCKET pcon;

    //
    //  hold lock with clear so that connection can not be deleted out from under us
    //

    LOCK_TCPCON_LIST();

    pcon = ( PDNS_SOCKET ) pMsg->pConnection;
    ASSERT( pcon );
    ASSERT( pcon->Socket == pMsg->Socket );

    DNS_DEBUG( TCP, (
        "Clearing reference to pmsg at %p, in TCP connection at %p."
        "    for socket %d\n",
        pMsg,
        pcon,
        pcon->Socket ));

    pcon->pMsg = NULL;
    pcon->dwTimeout = DNS_TIME() + DNS_TCP_CONNECTION_TIMEOUT;
    pMsg->pConnection = NULL;

    UNLOCK_TCPCON_LIST();
}



VOID
Tcp_ConnectionUpdateForPartialMessage(
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Reset connection info for completed message.

        - clear message info from connection info
        - reset timeout on TCP connection

Arguments:

    pMsg -- message partially received on connection

Return Value:

    None

--*/
{
    PDNS_SOCKET pcon;

    //
    //  hold lock while update so that connection can not be deleted out from under us
    //

    LOCK_TCPCON_LIST();
    pcon = (PDNS_SOCKET)pMsg->pConnection;
    ASSERT( pcon );
    ASSERT( pcon->Socket == pMsg->Socket );

    pcon->pMsg = pMsg;
    UNLOCK_TCPCON_LIST();
}



//
//  Init and shutdown
//

BOOL
Tcp_ConnectionListInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize connection list.

Arguments:

    None.

Return Value:

    TRUE/FALSE on success/failure.

--*/
{
    DWORD       nonBlocking = TRUE;
    INT         size;
    DNS_ADDR    addr;

    InitializeListHead( &mg_TcpConnectionList );

    if ( DnsInitializeCriticalSection( &mg_TcpConnectionListCS ) != ERROR_SUCCESS )
    {
        return FALSE;
    }

    mg_TcpConnectionListInitialized = TRUE;

    //
    //  create wakeup socket on loopback address, any port
    //

    g_bTcpSelectWoken = TRUE;

    DnsAddr_BuildFromIp4( &addr, NET_ORDER_LOOPBACK, 0 );
    g_TcpSelectWakeupSocket = Sock_CreateSocket(
                                    SOCK_DGRAM,
                                    &addr,
                                    0 );

    if ( g_TcpSelectWakeupSocket == DNS_INVALID_SOCKET )
    {
        DNS_PRINT(( "ERROR:  Failed to create wakeup socket!!!\n" ));
        ASSERT( g_TcpSelectWakeupSocket != DNS_INVALID_SOCKET );
        return FALSE;
    }
    DNS_DEBUG( TCP, (
        "Created wakeup socket = %d\n",
        g_TcpSelectWakeupSocket ));

    ioctlsocket( g_TcpSelectWakeupSocket, FIONBIO, &nonBlocking );

    //
    //  save wakeup sockaddr to send wakeups to
    //

    size = sizeof(SOCKADDR);

    getsockname(
        g_TcpSelectWakeupSocket,
        (PSOCKADDR) &wakeupSockaddr,
        & size );

    return TRUE;
}



VOID
Tcp_ConnectionListShutdown(
    VOID
    )
/*++

Routine Description:

    Cleanup connection list.
        - close connection list sockets
        - delete CS

Arguments:

    None.

Return Value:

    Ptr to connection, if found.
    NULL otherwise.

--*/
{
    PDNS_SOCKET  pentry;
    SOCKET  s;
    INT     err;

    ASSERT( fDnsServiceExit );
    if ( !mg_TcpConnectionListInitialized )
    {
        return;
    }

    //
    //  close ALL outstanding sockets
    //

    LOCK_TCPCON_LIST();

    while ( !IsListEmpty(&mg_TcpConnectionList) )
    {
        pentry = (PDNS_SOCKET) RemoveHeadList( &mg_TcpConnectionList );

        s = pentry->Socket;
        err = closesocket( s );

        IF_DEBUG( SHUTDOWN )
        {
            DNS_PRINT((
                "Closing TCP connection socket %d -- error %d\n",
                s,
                err ? WSAGetLastError() : 0 ));
            DnsDebugFlush();
        }
        ASSERT( !err );

        //Timeout_Free( pentry );
    }

    UNLOCK_TCPCON_LIST();

    //  delete list CS

    RtlDeleteCriticalSection( &mg_TcpConnectionListCS );
}


#if 0
//
//  Remote server could conceivable send two messages in response
//  (a bug), and so we shouldn't depend on connection NOT being in
//  the process of receiving another message on a given socket.
//


VOID
Tcp_ConnectionVerifyClearForSocket(
    VOID
    )
/*++

Routine Description:

    Verify that TCP connection for socket is NOT pointing at any
    message buffer.

Arguments:

    Socket -- socket connection is on

Return Value:

    None.  ASSERT()s on failure.

--*/
{
    PDNS_SOCKET pcon;

    pcon = Tcp_ConnectionFindForSocket( Socket );

    DNS_PRINT((
        "WARNING:  no TCP connection exists for socket %d\n",
        Socket ));

    ASSERT( pcon->pMsg == NULL );
}
#endif



//
//  TCP connect routines
//
//  Outbound TCP connections, used by
//      - recursion
//      - update forwarding
//

BOOL
Tcp_ConnectForForwarding(
    IN OUT  PDNS_MSGINFO        pMsg,
    IN      PDNS_ADDR           pDnsAddr,
    IN      CONNECT_CALLBACK    ConnectFailureCallback
    )
/*++

Routine Description:

    Initiate TCP connection for forwarding.

Arguments:

    pMsg -- message to forward
        - for recursion this is pRecurseMsg
        - for update forwarding the update message itself

    pDnsAddr -- remote DNS to connect to

    ConnectFailureCallback -- callback function on connect failure

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    IF_DEBUG( TCP )
    {
        Dbg_DnsMessage(
            "Attempting TCP forwarding on message:",
            pMsg );
    }

    //
    //  connect to server
    //
    //  if fail, just continue with next server
    //

    if ( !Msg_MakeTcpConnection(
                pMsg,
                pDnsAddr,
                NULL,                   //  no bind() address
                DNSSOCK_NO_ENLIST ) )   //  do NOT put the socket in the socket list
    {
        goto Failed;
    }

    ASSERT( pMsg->Socket != g_UdpSendSocket );
    ASSERT( pMsg->Socket != DNS_INVALID_SOCKET );
    ASSERT( pMsg->fTcp );

    //
    //  if successful, add socket to TCP connection list so we can
    //      receive responses
    //
    //      - on failure close connection socket

    if ( !Tcp_ConnectionCreate(
                pMsg->Socket,
                ConnectFailureCallback,
                pMsg ) )
    {
        //  only failure is allocation failure
        Sock_CloseSocket( pMsg->Socket );
        goto Failed;
    }
    return TRUE;

Failed:

    //  on failure, clear socket and TCP fields
    //  simply execute the connect callback function with failure,
    //      this avoids duplicating the failure path code

    DNS_DEBUG( ANY, (
        "Failed to create TCP connection to server %s\n"
        "    for forwarding %p\n",
        DNSADDR_STRING( pDnsAddr ),
        pMsg ));

    ASSERT( FALSE );
    pMsg->fTcp = FALSE;
    pMsg->Socket = g_UdpSendSocket;

    ConnectFailureCallback(
        pMsg,
        FALSE );        //  connect failed
    return FALSE;
}



VOID
Tcp_ConnectionCompletion(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Send recursive query after successful TCP connection.

Arguments:

    Socket -- socket connect failure occured on.

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    PDNS_SOCKET         pcon;
    PDNS_MSGINFO        pmsg;
    CONNECT_CALLBACK    pcallback;

    DNS_DEBUG( TCP, (
        "Tcp_ConnectionCompletion( sock=%d )\n",
        Socket ));

    STAT_INC( RecurseStats.TcpConnect );

    //
    //  find connection for socket
    //

    LOCK_TCPCON_LIST();

    pcon = Tcp_ConnectionFindForSocket( Socket );
    if ( !pcon )
    {
        ASSERT( FALSE );
        UNLOCK_TCPCON_LIST();
        return;
    }

    //  extract callback function and message

    pcallback = pcon->pCallback;
    ASSERT( pcallback );

    pmsg = pcon->pMsg;
    ASSERT( pmsg->fTcp );
    ASSERT( !DnsAddr_IsClear( &pcon->ipRemote ) );
    ASSERT( DnsAddr_IsEqual( &pcon->ipRemote, &pmsg->RemoteAddr, DNSADDR_MATCH_IP ) );

    //  update callback
    //      - clear callback to indicate connected
    //      - clear msg, as this is NOT recv message
    //      - update timeout to allow callback function to launch query

    pcon->pCallback = NULL;
    pcon->pMsg = NULL;
    pcon->dwTimeout = DNS_TIME() + TCP_QUERY_TIMEOUT;

    UNLOCK_TCPCON_LIST();

    //
    //  callback with success
    //

    pmsg->pConnection = NULL;

    if ( pcallback )
    {
        ( pcallback )( pmsg, TRUE );
    }
}



VOID
Tcp_CleanupFailedConnectAttempt(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Cleanup TCP connection failure, and continue normal query.

Arguments:

    Socket -- socket connect failure occured on.

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    PDNS_SOCKET         pcon;
    PDNS_MSGINFO        pmsg;
    PDNS_MSGINFO        pmsgQuery;
    CONNECT_CALLBACK    pcallback;
    LIST_ENTRY          callbackList;

    DNS_DEBUG( TCP, (
        "Tcp_CleanupFailedConnectAttempt( sock=%d )\n",
        Socket ));

    //  init callback failure list

    InitializeListHead( &callbackList );

    //
    //  find connection for socket
    //

    LOCK_TCPCON_LIST();

    pcon = Tcp_ConnectionFindForSocket( Socket );
    if ( !pcon )
    {
        DNS_PRINT((
            "ERROR:  socket %d not in connection list!!!\n",
            Socket ));
        ASSERT( FALSE );
        UNLOCK_TCPCON_LIST();
        return;
    }

    //  close connection
    //  connection block will be put on callback list

    ASSERT( pcon->pCallback );
    ASSERT( pcon->pMsg );
    tcpConnectionDelete( pcon, &callbackList );

    UNLOCK_TCPCON_LIST();

    //  callback with failure

    callbackConnectFailureList( &callbackList );
}



#if 0
//
//  Unable to do any sort of TCP connect attempt or connection
//  cancellation from other threads, as have no idea if TCP thread
//  is currently servicing this connection blob -- receiving on socket
//  or processing message
//

VOID
Tcp_StopTcpForwarding(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Stop TCP recursion for query.
        - close TCP connection
        - reset recursion info for further queries as UDP

    Note caller does any query continuation logic, which may be
    requerying (from timeout thread) or processing TCP response
    (from worker thread).

Arguments:

    pMsg -- recurse message using TCP

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    DNS_DEBUG( RECURSE, (
        "Tcp_StopTcpRecursion() for recurse message at %p\n",
        pMsg ));

    //
    //  delete connection to server
    //

    ASSERT( pMsg->pRecurseMsg );
    ASSERT( pMsg->fTcp );

    STAT_INC( PrivateStats.TcpDisconnect );
    Tcp_ConnectionDeleteForSocket( pMsg->Socket, pMsg );

    //
    //  reset for UDP query
    //

    pMsg->pConnection = NULL;
    pMsg->fTcp = FALSE;
    pMsg->Socket = g_UdpSendSocket;
}
#endif


PDNS_SOCKET
Tcp_ConnectionFindAndVerifyForMsg(
    IN      PDNS_MSGINFO          pMsg
    )
/*++

Routine Description:

    Find a connection object matching the socket and remote
    address for the message. If no connection object matching
    the remote address and port in the message exists, NULL
    will be returned.

Arguments:

    pMsg -- message to find connection for

Return Value:

    Ptr to connection, if found.
    NULL otherwise.

--*/
{
    PDNS_SOCKET pcon;

    LOCK_TCPCON_LIST();

    pcon = ( PDNS_SOCKET ) mg_TcpConnectionList.Flink;

    while ( ( PLIST_ENTRY ) pcon != &mg_TcpConnectionList )
    {
        if ( pcon->Socket == pMsg->Socket )
        {
            //
            //  Match the connection address with the message
            //  remote address. NOTE: match address AND port.
            //  We want to make sure we are talking to the same
            //  remote process.
            //
            
            if ( !DnsAddr_IsEqual(
                        &pMsg->RemoteAddr,
                        &pcon->ipRemote,
                        DNSADDR_MATCH_SOCKADDR ) )
            {
                break;
            }

            UNLOCK_TCPCON_LIST();
            return pcon;
        }
        pcon = ( PDNS_SOCKET ) pcon->List.Flink;
    }

    pcon = NULL;
    UNLOCK_TCPCON_LIST();
    return pcon;
}   //  Tcp_ConnectionFindAndVerifyForMsg


//
//  End of tcpcon.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\tcpsrv.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    tcpsrv.c

Abstract:

    Domain Name System (DNS) Server

    Handles TCP server side connections.

Author:

    Jim Gilroy      June 1995

Revision History:

    jamesg  Nov 1995    -   insertion of client side connections
    jamesg  Jan 1997    -   select() failure protection
                            bad TCP packet protection / cleanup

--*/

#include "dnssrv.h"


//
//  FD_SETs
//      - read for listen and recv
//      - write for connection completion
//      - except for connection failure
//

FD_SET fdsReadTcp;
FD_SET fdsWriteTcp;
FD_SET fdsExceptTcp;

//  Connect timeout

#define TCP_CONNECT_TIMEOUT     (5)     // five seconds

//  Max retries on select() failure before logging error and whacking sockets

#define SELECT_RETRY_LIMIT      (20)


//
//  Initial length for recv()s
//  Specify length that includes header gives us cut at info
//  we can use to throw aways packets and close connections before
//  wasting too many cycles
//

#define INITIAL_RECV_LENGTH (sizeof(WORD) + sizeof(DNS_HEADER))



//
//  Private protos
//

VOID
Tcp_AcceptRequest(
    IN       SOCKET     sListenSocket
    );



BOOL
Tcp_Receiver(
    VOID
    )
/*++

Routine Description:

    Receiving thread routine.  Loops waiting on sockets, recieving DNS
    requests and queuing requests to worker threads.

Arguments:

    TcpListener - TCP listening socket

Return Value:

    TRUE on normal service shutdown
    FALSE on socket error

--*/
{
    SOCKET          socket;
    BOOL            fconnecting;
    INT             err;
    INT             count;
    INT             selectFailCount = 0;
    INT             i;
    DWORD           lastSelectTime = DNS_TIME();
    PDNS_MSGINFO    pmsg;
    struct timeval  timeout;

    DNS_DEBUG( INIT, ( "Entering TCP receiver loop\n" ));

    //  set connect timeout

    timeout.tv_sec = SrvCfg_dwXfrConnectTimeout;
    timeout.tv_usec = 0;

    //
    //  Loop receiving
    //      - incoming TCP connection attempts
    //      - TCP messages to connected sockets
    //

    //
    //  DEVNOTE:  replace select() with winsock2 recvfrom
    //              - handle termination with event or
    //                close socket handles to terminate recvfrom
    //

    while ( TRUE )
    {
        //
        //  Check for service pause or shutdown.
        //

        if ( !Thread_ServiceCheck() )
        {
            DNS_DEBUG( TCP, ( "Terminating TCP receiver thread\n" ));
            return 1;
        }

        //
        //  setup select FD_SET
        //      - copy of listening socket list
        //      - then add current connection sockets
        //      - and current connection attempt sockets
        //

        RtlCopyMemory(
            & fdsReadTcp,
            & g_fdsListenTcp,
            sizeof( FD_SET ) );

        fconnecting = Tcp_ConnectionListFdSet(
                        & fdsReadTcp,
                        & fdsWriteTcp,
                        & fdsExceptTcp,
                        lastSelectTime );

        //
        //  Wait for DNS request or shutdown.
        //

        if ( fconnecting )
        {
            IF_DEBUG( TCP )
            {
                DnsPrint_Lock();
                DNS_PRINT((
                    "Entering select with connect timeout %d\n",
                    timeout.tv_sec ));
                DnsDbg_FdSet(
                    "TCP select() read fd_set:",
                    & fdsReadTcp );
                DnsDbg_FdSet(
                    "TCP select() write fd_set:",
                    & fdsWriteTcp );
                DnsDbg_FdSet(
                    "TCP select() except fd_set:",
                    & fdsExceptTcp );
                DnsPrint_Unlock();
            }
            count = select( 0, &fdsReadTcp, &fdsWriteTcp, &fdsExceptTcp, &timeout );

            //
            //  if timeout, then rebuild list
            //

            if ( count == 0 )
            {
                lastSelectTime = DNS_TIME();
                DNS_DEBUG( TCP, (
                    "TCP select timeout -- timing out failed connection attempts!\n" ));
                continue;
            }

            ASSERT( count == SOCKET_ERROR ||
                    count == (INT)fdsReadTcp.fd_count +
                                (INT)fdsWriteTcp.fd_count +
                                (INT)fdsExceptTcp.fd_count );

        }
        else
        {
            IF_DEBUG( TCP )
            {
                DnsDbg_FdSet(
                    "TCP select() fd_set:",
                    & fdsReadTcp );
            }
            count = select( 0, &fdsReadTcp, NULL, NULL, NULL );

            ASSERT( count == SOCKET_ERROR ||
                    count == (INT)fdsReadTcp.fd_count );
        }

        lastSelectTime = DNS_TIME();
        DNS_DEBUG( TCP, (
            "TCP select fired at (%d), count = %d\n",
            lastSelectTime,
            count ));

        //
        //  Check and possibly wait on service status
        //
        //  Check before socket error check, as service termination
        //  will cause WINS socket closure.
        //

        if ( fDnsThreadAlert )
        {
            if ( ! Thread_ServiceCheck() )
            {
                DNS_DEBUG( TCP, ( "Terminating TCP receiver thread\n" ));
                return 1;
            }
        }

        //
        //  If select() wakeup to add new socket -- do it.
        //

        if ( g_bTcpSelectWoken )
        {
            DNS_DEBUG( TCP, (
                "TCP select()==%lx woken by wakeup socket = %lx\n",
                count,
                g_TcpSelectWakeupSocket ));
            continue;
        }

        if ( count == SOCKET_ERROR )
        {
            err = WSAGetLastError();
            DNS_DEBUG( ANY, (
                "ERROR:  TCP receiver select() failed\n"
                "    GetLastError = 0x%08lx\n"
                "    failure retry count = %d\n",
                err,
                selectFailCount ));

            selectFailCount++;

            //
            //  possible failure from connection socket being closed
            //      after copied to fd_set
            //  just continue and give fd_set rebuild a chance to clear
            //      the condition

            if ( selectFailCount < SELECT_RETRY_LIMIT )
            {
                continue;
            }

            //
            //  we are in a select() spin
            //      - log the first time through only
            //
            //  then delete last connection
            //      - find last socket, ignoring wakeup socket on the end
            //      - make sure socket NOT listen socket
            //      - delete connection for socket
            //      - retry select()
            //
            //  DEVNOTE: check list and eliminate bad sockets
            //

            if ( selectFailCount == SELECT_RETRY_LIMIT )
            {
                DNS_LOG_EVENT(
                    DNS_EVENT_SELECT_CALL_FAILED,
                    0,
                    NULL,
                    NULL,
                    err );
            }

            socket = fdsReadTcp.fd_array[ fdsReadTcp.fd_count-2 ];
            if ( !FD_ISSET( socket, &g_fdsListenTcp ) )
            {
                Tcp_ConnectionDeleteForSocket( socket, NULL );
            }

            DNS_DEBUG( ANY, (
                "Retry TCP select after %d failures at time=%d\n"
                "    eliminating socket %d for retry!\n",
                selectFailCount,
                DNS_TIME(),
                socket ));
            continue;
        }

        //  successful select, reset select retry count

        selectFailCount = 0;

        //
        //  Connections completed or rejected
        //      - socket in Write fd_set, indicates successful connection,
        //          send recursive query
        //      - socket in Except fd_set, indicates failure,
        //          continue processing this query
        //

        if ( fconnecting )
        {
            for( i=0; i<(INT)fdsWriteTcp.fd_count; i++ )
            {
                socket = fdsWriteTcp.fd_array[i];
                count--;
                Tcp_ConnectionCompletion( socket );
            }

            for( i=0; i<(INT)fdsExceptTcp.fd_count; i++ )
            {
                socket = fdsExceptTcp.fd_array[i];
                count--;
                Tcp_CleanupFailedConnectAttempt( socket );
            }
        }

        //
        //  Recv DNS messages on TCP listening sockets
        //      - remaining indications must be in Read fd_set
        //

        ASSERT( count == (INT)fdsReadTcp.fd_count );

        //  don't trust winsock guys

        count = (INT)fdsReadTcp.fd_count;

        while( count-- )
        {
            socket = fdsReadTcp.fd_array[count];

            //  protect against wakeup flag not being set
            //  if wakeup socket signalled, set flag so wakeup processing is done

            if ( socket == g_TcpSelectWakeupSocket )
            {
                DNS_PRINT((
                    "Wakeup socket %d in selected fd_set but flag not set!\n"
                    "    This can happen if two wakeups done while TCP thread\n"
                    "    is reading out the wakeup socket\n"
                    "    We'll just re-read before next select\n",
                    socket ));
                g_bTcpSelectWoken = TRUE;
                continue;
            }

            //
            //  new connection request ?
            //      - check socket against listening sockets
            //

            if ( FD_ISSET( socket, &g_fdsListenTcp ) )
            {
                Tcp_AcceptRequest( socket );
                continue;
            }

            //
            //  receive message on EXISTING connection
            //
            //  more of existing message
            //      OR
            //  allocate new message buffer for connection
            //

            pmsg = Tcp_ConnectionMessageFindOrCreate( socket );
            if ( !pmsg )
            {
                DNS_DEBUG( TCP, (
                    "WARNING:  no connection found for non-listening socket %d\n"
                    "    this is possible when socket is terminated through PnP\n",
                    socket ));
                continue;
            }

            //
            //  receive message -- ignore socket
            //      - message error
            //      - FIN
            //      - message not complete

            pmsg = Tcp_ReceiveMessage( pmsg );

            if ( !pmsg || !pmsg->fMessageComplete )
            {
                continue;
            }

            //
            //  count query reception
            //

            if ( pmsg->Head.IsResponse )
            {
                STAT_INC( QueryStats.TcpResponsesReceived );
            }
            else
            {
                STAT_INC( QueryStats.TcpQueries );
                PERF_INC( pcTcpQueryReceived );
                PERF_INC( pcTotalQueryReceived );
            }

            //
            //  queue query to worker thread
            //

            Answer_ProcessMessage( pmsg );

        }   //  end loop through fdsReadTcp set sockets

    }   //  main receive loop

} // Tcp_Receiver



VOID
Tcp_AcceptRequest(
    IN      SOCKET  sListenSocket
    )
/*++

Routine Description:

    Accept and queue request on TCP socket.

    May fail on socket error or request info memory allocation error.

Arguments:

    sListenSocket - TCP listening socket

Return Value:

    None.

--*/
{
    PDNS_MSGINFO        pmsg;
    SOCKET              socket;
    DNS_ADDR            addr;

    //
    //  accept the client connection
    //

    DnsAddr_Reset( &addr );
    
    socket = accept( sListenSocket, &addr.Sockaddr, &addr.SockaddrLength );
    if ( socket == INVALID_SOCKET )
    {
        DWORD err = GetLastError();

        if ( fDnsServiceExit )
        {
            DNS_DEBUG( SHUTDOWN, (
                "TCP thread encounter service shutdown on accept()\n" ));
            return;
        }
        if ( err == WSAEWOULDBLOCK )
        {
            DNS_DEBUG( RECV, (
                "WARNING:  accept() failed WSAEWOULDBLOCK on socket %d\n",
                sListenSocket ));
            return;
        }
        DNS_LOG_EVENT(
            DNS_EVENT_ACCEPT_CALL_FAILED,
            0,
            NULL,
            NULL,
            err );
        DNS_DEBUG( ANY, (
            "ERROR:  accept() failed on socket %d\n"
            "    GetLastError = 0x%08lx\n",
            sListenSocket,
            err ));
        return;
    }

    //
    //  count TCP connections and query reception
    //

    STAT_INC( QueryStats.TcpClientConnections );

    //
    //  allocate message info buffer
    //

    pmsg = Packet_AllocateTcpMessage( 0 );
    IF_NOMEM( !pmsg )
    {
        //
        //  DEVNOTE: need TCP allocation failure recv(), response routine
        //

        DNS_PRINT(( "ERROR:  TCP allocation failure\n" ));
        closesocket( socket );
        return;
    }

    //
    //  save client info to message info
    //

    DnsAddr_Copy( &pmsg->RemoteAddr, &addr );
    pmsg->Socket = socket;

    DNS_DEBUG( TCP, (
        "Accepting new connection on socket %d from client %s\n",
        socket,
        MSG_IP_STRING( pmsg ) ));

    //
    //  create connection info
    //

    Tcp_ConnectionCreate(
        socket,
        NULL,       // no callback, as not connecting
        pmsg );

    //
    //  receive request on new socket
    //      - on failure it will close socket
    //

    pmsg = Tcp_ReceiveMessage( pmsg );
    if ( !pmsg )
    {
        return;
    }

    //
    //  Message complete -- process message.
    //

    if ( pmsg->fMessageComplete )
    {
        if ( pmsg->Head.IsResponse )
        {
            STAT_INC( QueryStats.TcpResponsesReceived );
        }
        else
        {
            STAT_INC( QueryStats.TcpQueries );
            PERF_INC( pcTcpQueryReceived );
            PERF_INC( pcTotalQueryReceived );
        }
        Answer_ProcessMessage( pmsg );
    }
    return;
}



PDNS_MSGINFO
Tcp_ReceiveMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Receive TCP DNS message.

Arguments:

    pMsg - message info buffer to receive packet;  must contain connected
            TCP socket

Return Value:

    pMsg info of result
        - may be reallocated
        - may be NULL on FIN or ERROR

--*/
{
    PCHAR   pchrecv;        // ptr to recv location
    INT     recvLength;     // length left to recv()
    SOCKET  socket;
    INT     err;
    WORD    messageLength;


    ASSERT( pMsg );
    ASSERT( pMsg->Socket );

    socket = pMsg->Socket;

    //
    //  Receive the message
    //
    //  Receive up to message length minus previous receive total.
    //

    DNS_DEBUG( TCP, (
        "Receiving message on socket %d\n"
        "    Message info at %p\n"
        "    Bytes left to receive = %d\n",
        socket,
        pMsg,
        pMsg->BytesToReceive ));

    //
    //  new message -- set to receive message length and message header
    //      - reusing buffer
    //      - new buffer
    //
    //  otherwise continuing receive of message
    //

    if ( !pMsg->pchRecv )
    {
        pchrecv = (PCHAR) &pMsg->MessageLength;
        recvLength = INITIAL_RECV_LENGTH;
        pMsg->MessageLength = 0;
    }
    else
    {
        pchrecv = (PCHAR) pMsg->pchRecv;
        recvLength = (INT) pMsg->BytesToReceive;
    }

    ASSERT( recvLength );
    pMsg->fMessageComplete = FALSE;

    //
    //  receive the message
    //
    //  we only receive data for this message, as another could
    //  immediately follow on VC (esp. for AXFR)
    //

    while ( 1 )
    {
        ASSERT_VALID_HANDLE( socket );

        err = recv(
                socket,
                pchrecv,
                recvLength,
                0 );

        //
        //  done? -- FIN or error
        //

        if ( err <= 0 )
        {
            if ( err == 0 )
            {
                goto FinReceived;
            }
            ASSERT( err == SOCKET_ERROR );
            goto SockError;
        }
        DNS_DEBUG( TCP, (
            "Received %d bytes on TCP socket %d\n",
            err,
            socket ));

        //
        //  update buffer params
        //

        recvLength -= err;
        pchrecv += err;

        ASSERT( recvLength >= 0 );

        //
        //  received
        //      - entire message or
        //      - message length + header
        //

        if ( recvLength == 0 )
        {
            //  done receiving message?

            if ( pchrecv > (PCHAR)&pMsg->MessageLength + INITIAL_RECV_LENGTH )
            {
                break;
            }

            //
            //  recv'd initial length (message length + header)
            //  setup to recv() rest of message
            //      - byte flip length and header
            //      - continue reception with this length
            //

            ASSERT( pchrecv == pMsg->MessageBody );

            DNSMSG_SWAP_COUNT_BYTES( pMsg );
            messageLength = pMsg->MessageLength;
            pMsg->MessageLength = messageLength = ntohs( messageLength );
            if ( messageLength < sizeof(DNS_HEADER) )
            {
                DNS_DEBUG( RECV, (
                    "ERROR:  Received TCP message with bad message"
                    " length %d\n",
                    messageLength ));
                goto BadTcpMessage;
            }
            recvLength = messageLength - sizeof(DNS_HEADER);

            DNS_DEBUG( TCP, (
                "Received TCP message length %d, on socket %d,\n"
                "    for msg at %p\n",
                messageLength,
                socket,
                pMsg ));

            //
            //  DEVNOTE:  sanity checks on TCP recv
            //      - if fail, log and kill VC
            //

            //
            //  continue recving valid message
            //  realloc, if existing message too small
            //  and not recving static buffer
            //

            if ( messageLength <= pMsg->BufferLength )
            {
                continue;
            }
            goto CloseConnection;
#if 0
            pMsg = Tcp_ReallocateMessage( pMsg, messageLength );
            if ( !pMsg )
            {
                return( NULL );
            }
#endif
        }
    }

    //
    //  Message received
    //      - recv ptr serves as flag, clear to start new message on reuse
    //      - set fields for recv (recv time)
    //      - log message (if desired)
    //      note:  header field flip was done above
    //

    pMsg->fMessageComplete = TRUE;
    pMsg->pchRecv = NULL;

    SET_MESSAGE_FIELDS_AFTER_RECV( pMsg );

    DNSLOG_MESSAGE_RECV( pMsg );

    IF_DEBUG( RECV )
    {
        Dbg_DnsMessage(
            "Received TCP packet",
            pMsg );
    }

    //
    //  Reset connection info
    //      - clear pMsg from connection info
    //      - reset connection timeout
    //

    if ( pMsg->pConnection )
    {
        Tcp_ConnectionUpdateForCompleteMessage( pMsg );
    }

    return( pMsg );


SockError:

    //
    //  WSAEWOULD block is NORMAL return for message not fully recv'd.
    //      - save state of message reception
    //
    //  We use non-blocking sockets, so bad client (that fails to complete
    //  message) doesn't hang TCP receiver.
    //

    err = GetLastError();

    if ( err == WSAEWOULDBLOCK )
    {
        pMsg->pchRecv = pchrecv;
        pMsg->BytesToReceive = (WORD) recvLength;

        DNS_DEBUG( TCP, (
            "Leave ReceiveTcpMessage() after WSAEWOULDBLOCK\n"
            "    Socket=%d, Msg=%p, Connection=%p\n"
            "    Bytes left to receive = %d\n",
            socket,
            pMsg,
            pMsg->pConnection,
            pMsg->BytesToReceive ));

        if ( pMsg->pConnection )
        {
            Tcp_ConnectionUpdateForPartialMessage( pMsg );
        }
        return( pMsg );
    }

    //  service exit?

    if ( fDnsServiceExit )
    {
        DNS_DEBUG( SHUTDOWN, ( "TCP thread shutdown on recv() of msg\n" ));
        return( NULL );
    }

    //
    //  cancelled connection
    //
    //  if at beginning of message (set to recv message length)
    //  then this error is not out of line
    //      - remote RESET
    //      - we shutdown(2) on AXFR thread while already indicated
    //      select() on this thread for more remote data or even FIN
    //

    if ( pchrecv == (PCHAR) &pMsg->MessageLength
            &&
          ( err == WSAESHUTDOWN ||
            err == WSAECONNABORTED ||
            err == WSAECONNRESET ) )
    {
        DNS_DEBUG( TCP, (
            "WARNING:  Recv RESET (%d) on socket %d\n",
            err,
            socket ));
        goto CloseConnection;
    }

    DNS_LOG_EVENT(
        DNS_EVENT_RECV_CALL_FAILED,
        0,
        NULL,
        NULL,
        err );

    DNS_DEBUG( ANY, (
        "ERROR:  recv() of TCP message failed\n"
        "    %d bytes recvd\n"
        "    %d bytes left\n"
        "    GetLastError = 0x%08lx\n",
        pchrecv - (PCHAR)&pMsg->MessageLength,
        recvLength,
        err ));

    goto CloseConnection;

FinReceived:

    //
    //  valid FIN -- if recv'd between messages (before message length)
    //

    DNS_DEBUG( TCP, (
        "Recv TCP FIN (0 bytes) on socket %d\n",
        socket,
        recvLength ));

    if ( pMsg->MessageLength == 0  &&  pchrecv == (PCHAR)&pMsg->MessageLength )
    {
        ASSERT( recvLength == INITIAL_RECV_LENGTH );
        goto CloseConnection;
    }

    //
    //  FIN during message -- invalid message
    //      - don't bother to respond
    //      - note that if decide to respond, need to make sure that
    //      we know whether or not message length has yet been flipped
    //      not, worth making this check for bogus case like this
    //      so nixing response
    //

#if 0
    if ( ! pMsg->Head.IsResponse
            && pMsg->MessageLength > sizeof(DNS_HEADER) )
    {
        pMsg->fDelete = FALSE;
        Reject_UnflippedRequest(
            pMsg,
            DNS_RCODE_FORMAT_ERROR );
    }
#endif

    DNS_DEBUG( ANY, (
        "ERROR:  TCP message received has incorrect length\n"
        "    %d bytes left when recv'd FIN\n",
        recvLength ));
    //goto BadTcpMessage;


BadTcpMessage:

    DNS_LOG_EVENT_BAD_PACKET(
        DNS_EVENT_BAD_TCP_MESSAGE,
        pMsg );

CloseConnection:

    //
    //  close connection
    //
    //  if in connection list, cut from connection list
    //  otherwise just close
    //

    Tcp_ConnectionDeleteForSocket( socket, pMsg );
    return NULL;
}



//
//  End of tcpsrv.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\timeout.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    timeout.h

Abstract:

    Domain Name System (DNS) Server

    Timeout system definitions.

Author:

    Jim Gilroy (jamesg)     February 1995

Revision History:

--*/

#ifndef _TIMEOUT_INCLUDED_
#define _TIMEOUT_INCLUDED_


//
//  Timeout node ptr array type
//
//  These are big enough so list processing is minimized, but are allocated and
//  deallocated as move through bins, so generally will not use up too much
//  memory.  And they are small enough that the total usage is reasonably
//  tailored to the actually outstanding timeouts to be done.
//
//  These structures will be overlayed in standard dbase nodes.
//

#define TIMEOUT_BIN_COUNT       (256)
#define MAX_ALLOWED_BIN_OFFSET  (253)

#define MAX_TIMEOUT_NODES       (64)

typedef struct _DnsTimeoutArray
{
    struct _DnsTimeoutArray *   pNext;
    DWORD                       Count;
    PDB_NODE                    pNode[ MAX_TIMEOUT_NODES ];
}
TIMEOUT_ARRAY, *PTIMEOUT_ARRAY;


#endif  // _TIMEOUT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\tcpcon.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

Module Name:

    tcpcon.h

Abstract:

    Domain Name System (DNS) Server

    TCP Connection list definitions.

    DNS server must allow clients to send multiple messages on a connection.
    These are definitions which allow server to maintain list of client
    connections which it holds open for a limited timeout.

Author:

    Jim Gilroy (jamesg)     June 20, 1995

Revision History:

--*/


#ifndef _TCPCON_INCLUDED_
#define _TCPCON_INCLUDED_

//
//  TCP client connection
//

typedef struct
{
    LIST_ENTRY  ListEntry;

    SOCKET      Socket;         //  connection socket
    DWORD       dwTimeout;      //  timeout until connection closed

    PDNS_MSGINFO    pMsg;       //  partially received message on connection
}
TCP_CONNECTION, *PTCP_CONNECTION;

//
//  Select wakeup socket
//      -- needed by tcpsrv, to avoid attempting recv() from socket
//

extern SOCKET  socketTcpSelectWakeup;

extern BOOL    gbTcpSelectWoken;


//
//  TCP connection list (tcpcon.c)
//

VOID
dns_TcpConnectionListFdSet(
    IN OUT  fd_set *    pFdSet,
    IN      DWORD       dwLastSelectTime
    );

BOOL
dns_TcpConnectionCreate(
    IN      SOCKET              Socket,
    IN      BOOL                fTimeout,
    IN OUT  PDNS_MSGINFO    pMsg        OPTIONAL
    );

VOID
dns_TcpConnectionListReread(
    VOID
    );

BOOL
dns_TcpConnectionCreateForRecursion(
    IN      SOCKET  Socket
    );

VOID
dns_TcpConnectionDeleteForSocket(
    IN      SOCKET  Socket
    );

PDNS_MSGINFO
dns_TcpConnectionMessageFindOrCreate(
    IN      SOCKET  Socket
    );

VOID
dns_TcpConnectionUpdateTimeout(
    IN      SOCKET  Socket
    );

VOID
dns_TcpConnectionUpdateForCompleteMessage(
    IN      PDNS_MSGINFO    pMsg
    );

VOID
dns_TcpConnectionUpdateForPartialMessage(
    IN      PDNS_MSGINFO    pMsg
    );

VOID
dns_TcpConnectionListInitialize(
    VOID
    );

VOID
dns_TcpConnectionListDelete(
    VOID
    );

PDNS_SOCKET
Tcp_ConnectionFindAndVerifyForMsg(
    IN      PDNS_MSGINFO          pMsg
    );

#endif // _TCPCON_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\timeout.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    timeout.c

Abstract:

    Domain Name System (DNS) Server

    Timeout thread routines.

Author:

    Jim Gilroy (jamesg)     September 1997

Revision History:

--*/


#include "dnssrv.h"


//
//  Timeout implementation
//
//  There are two basic approaches to handling node timeout:
//      1) walk the database every so often and time nodes out
//      2) keep list of nodes to be timed out at particular times
//
//  To avoid the expense of timeout walk on large database i'm doing option #2.
//  This is more expensive in terms of memory, but much cheaper in terms of
//  performance.
//
//  However, rather than a simple list of nodes and timeouts,
//  my timeout structure will consist of
//      1) a static ptr array for 256 time interval bins
//      2) an index to current bin (bin for current time interval)
//      3) for each bin a structure that is essentially an array of node ptrs
//          to be timed out in the interval corresponding to the bin
//      4) a field in each node giving index of the bin that is the furthest
//          off timeout on that node
//
//  This structure gives us several advantages over a simple list:
//
//  1) Less memory
//      Beyond overhead, just single ptr on node timeout.  Time is known from
//      the bin.
//
//  2) No list traversal to setup timeout
//      Just stick node ptr on end of array to setup timeout.  Do not need to
//      find its position in the list.
//
//  3) Suppress unnecessary timeout caching
//      When a RR is cached with a given timeout, we calculate the bin index
//      corresponding to that timeout.  If it is a bin that is "further away",
//      than the current timeout bin index on the node, we add the node ptr to
//      the timeout array for that bin, reset the node's bin index to it and
//      bump the node's reference count.  In this way we avoid keeping timeout
//      node ptrs for unnecessary short timeouts or repeated timeouts at the
//      same value.
//


//
//  Timeout bins
//
//  Current bin is bin corresponding to current time.
//      - this is origin for calculating cache timeouts
//  Check bin trails current by 2, so that there is always an interval
//      before delete
//      - safe for access, safe for zero TTL
//      - no sense cleaning up, if we will definitely requery\recache at node
//  Last bin trails check by one
//      - this is simply as-far-away-as-possible bin


PTIMEOUT_ARRAY   TimeoutBinArray[ TIMEOUT_BIN_COUNT ];

UCHAR   CurrentTimeoutBin;
UCHAR   CheckTimeoutBin;

CRITICAL_SECTION    csTimeoutLock;

#define LOCK_TIMEOUT()      EnterCriticalSection( &csTimeoutLock );
#define UNLOCK_TIMEOUT()    LeaveCriticalSection( &csTimeoutLock );


//
//  Time for each bin
//
//  Time delayed free's are protected.
//  This time should be longer (by short protect interval) than max
//  time queries are kept around for, so all queries referencing
//  object being freed, are dead by the time object is deleted.
//  Note, existing zone dumped by XFR can not be deleted until this
//  interval has passed.  So important to keep this reasonable.
//

#if DBG
#define TIMEOUT_INTERVAL    (300)
#define TIMEOUT_FREE_DELAY  (90)
#else
#define TIMEOUT_INTERVAL    (300)       //  5 minute retail
#define TIMEOUT_FREE_DELAY  (90)
#endif

#define TIMEOUT_ALLOC_FAILURE_DELAY     30
#define TIMEOUT_MIN_WAIT_TIME           10

#define TIMEOUT_MAX_TIME    (TIMEOUT_BIN_COUNT * TIMEOUT_INTERVAL)

DWORD   TimeoutBaseTime;
DWORD   TimeoutInterval;


//
//  Delayed timeout structure
//

typedef struct _DnsDelayedFree
{
    struct _DnsDelayedFree *    pNext;
    PVOID                       pItem;
    VOID                        (*pFreeFunction)( PVOID );
    LPSTR                       pszFile;
    DWORD                       Tag;
    DWORD                       LineNo;
}
DELAYED_FREE, *PDELAYED_FREE;

#define DELAYED_TAG                     (0xde1aedfe)
#define IS_DELAYED_TIMEOUT(ptr)         (((PDELAYED_FREE)ptr)->Tag == DELAYED_TAG)

//
//  Keep two delayed timeout lists.
//      - one collecting entries
//      - one waiting through one timeout
//

PDELAYED_FREE   CurrentDelayedFreeList;
PDELAYED_FREE   CoolingDelayedFreeList;

DWORD   CurrentDelayedCount;
DWORD   CoolingDelayedCount;


//
//  Cache limit stuff - see enforceCacheLimit().
//

static DWORD g_CacheLimitTimeAdjustments[] =
{
    0,                          //  1st pass - no adjustment - free if expired
    3600,                       //  2cd pass - adjust current time by one hour
    3600 * 24,                  //  3rd pass - adjust current time by one day
    DNS_CACHE_LIMIT_DISCARD_ALL,    //  4th pass - free all eligible RRs
};

DWORD   g_dwCacheLimitCurrentTimeAdjustment = 0;
DWORD   g_dwCacheFreeCount = 0;

//
//  Timeout thread
//

DWORD   TimeoutThreadId;



BOOL
Timeout_Initialize(
    VOID
    )
/*++

Routine Description:

    Init timeout array.

Arguments:

    None

Return Value:

    TRUE/FALSE on success/error.

--*/
{
    //  clear timeout array

    RtlZeroMemory(
        TimeoutBinArray,
        sizeof( TimeoutBinArray ) );

    //  init time base time
    //  will do this again on timeout thread start, but do here so any
    //  caching before start completed is handled correctly

    TimeoutBaseTime = DNS_TIME();

    //
    //  init globals
    //      - init in code to allow restart
    //

    TimeoutInterval = TIMEOUT_INTERVAL;

    //  bin pointers

    CurrentTimeoutBin   = 0;
    CheckTimeoutBin     = 254;

    //  delayed free lists

    CurrentDelayedFreeList = NULL;
    CoolingDelayedFreeList = NULL;

    //  debug info

    CoolingDelayedCount = 0;
    CurrentDelayedCount = 0;

    //  lock to protect simultaneous access to bins

    if ( DnsInitializeCriticalSection( &csTimeoutLock ) != ERROR_SUCCESS )
    {
        return FALSE;
    }

    return TRUE;
}



VOID
Timeout_Shutdown(
    VOID
    )
/*++

Routine Description:

    Cleanup timeout on shutdown.

Arguments:

    None

Return Value:

    None

--*/
{
    RtlDeleteCriticalSection( &csTimeoutLock );
}



//
//  Private timeout functions
//

PTIMEOUT_ARRAY
createTimeoutArray(
    VOID
    )
/*++

Routine Description:

    Set timeout on node.

Arguments:

    pNode -- node to check at timeout

    dwTimeout -- time of this timeout

Return Value:

    None.

--*/
{
    PTIMEOUT_ARRAY  parray;

    DNS_DEBUG( TIMEOUT, ( "Creating new timeout array struct\n" ));

    //
    //  for first cut using node structure as blocks
    //

    parray = (PTIMEOUT_ARRAY) ALLOC_TAGHEAP( sizeof(TIMEOUT_ARRAY), MEMTAG_TIMEOUT );
    IF_NOMEM( !parray )
    {
        return NULL;
    }
    STAT_INC( TimeoutStats.ArrayBlocksCreated );

    parray->Count = 0;
    parray->pNext = NULL;

    return parray;
}



VOID
deleteTimeoutArray(
    IN OUT  PTIMEOUT_ARRAY  pArray
    )
/*++

Routine Description:

    Delete timeout array block.

Arguments:

    pArray -- ptr to timeout array block being deleted

Return Value:

    None.

--*/
{
    DNS_DEBUG( TIMEOUT, ( "Deleting timeout array struct\n" ));

    STAT_INC( TimeoutStats.ArrayBlocksDeleted );

    FREE_HEAP( pArray );
}



VOID
insertPtrInTimeout(
    IN OUT  PDB_NODE    pNode,
    IN      UCHAR       Bin
    )
/*++

Routine Description:

    Set timeout on node.

    Note: this function assumes timeout lock held by caller.

Arguments:

    pNode -- node (or delayed free ptr) to check at timeout

    Bin -- index of bin to insert node into

Return Value:

    None.

--*/
{
    PTIMEOUT_ARRAY  ptimeoutArray;
    PTIMEOUT_ARRAY  plastArray;
    DWORD           index;

    DNS_DEBUG( TIMEOUT, (
        "Insert ptr %p in timeout bin %d\n",
        pNode,
        Bin ));

    //
    //  never cache into CheckBin or (CheckBin + 1), as these
    //  may be in use by timeout thread or will be before this
    //  function returns
    //
    //  we should never have even been pointed at CheckTimeoutBin,
    //  but may be aimed at CheckTimeoutBin+1, if we were pointed
    //  at CurrentTimeoutBin and just did bin advance
    //

    if ( Bin == CheckTimeoutBin || Bin == CheckTimeoutBin + 1 )
    {
        ASSERT( Bin != CheckTimeoutBin );
        Bin = CurrentTimeoutBin;
    }

    //  save node ptr
    //      - put in next available slot in bins timeout array

    ptimeoutArray = TimeoutBinArray[ Bin ];
    plastArray = ( PTIMEOUT_ARRAY ) &TimeoutBinArray[ Bin ];

    while ( 1 )
    {
        //  if no timeout array at this bin or all arrays are full
        //      then must create new one

        if ( !ptimeoutArray )
        {
            ptimeoutArray = createTimeoutArray();
            IF_NOMEM( !ptimeoutArray )
            {
                 return;
            }
            plastArray->pNext = ptimeoutArray;
        }

        //  find index for next node in array

        index = ptimeoutArray->Count;
        if ( index < MAX_TIMEOUT_NODES )
        {
            ptimeoutArray->pNode[index] = pNode;
            ptimeoutArray->Count++;
            break;
        }

        //  this array block is full, continue on to next block

        plastArray = ptimeoutArray;
        ptimeoutArray = ptimeoutArray->pNext;
        continue;
    }
}



DNS_STATUS
timeoutDbaseNode(
    IN OUT  PDB_NODE    pNode
    )
/*++

Routine Description:

    Make timeout check on node.

Arguments:

    pNode -- ptr to node to check for timeout

Return Value:

    DNSSRV_STATUS_NODE_RECENTLY_ACCESSED for recent access.
    ERROR_SUCCESS if node still valid.
    ERROR_TIMEOUT if node timed out.

--*/
{

    STAT_INC( TimeoutStats.Checks );

    //
    //  DCR:  move node in timeout list for faster timeout
    //      move forward
    //          - if recent access
    //          - if records didn't time out
    //

    //
    //  if node is recently accessed, then do NOT mess with it, don't want to
    //      delete the records if they are currently being used
    //

    if ( IS_NODE_RECENTLY_ACCESSED( pNode ) )
    {
        STAT_INC( TimeoutStats.RecentAccess );
        return DNSSRV_STATUS_NODE_RECENTLY_ACCESSED;
    }

    //
    //  timeout RR list
    //
    //
    //  DEVNOTE: don't quit if RR list remains on aggressive delete
    //  DEVNOTE: aggressive delete, delete RR list if safe
    //  DEVNOTE: determine timeout on remaining RRs and move (esp. if aggressive delete)
    //

    if ( pNode->pRRList )
    {
        RR_ListTimeout( pNode );

        if ( pNode->pRRList )
        {
            STAT_INC( TimeoutStats.ActiveRecord );
            return ERROR_SUCCESS;
        }
    }

    //
    //  check if node should NOT be freed
    //      - has children
    //      - has static RR records
    //      - referenced by another node
    //      - is authoritative zone root
    //      - accessed in timeout interval
    //
    //  for children or reference, get out immediately
    //      - saves grabbing the lock
    //

    if ( pNode->pChildren
            ||
         pNode->cReferenceCount
            ||
         IS_NODE_NO_DELETE(pNode)
            ||
         IS_AUTH_ZONE_ROOT(pNode) &&
            pNode->pZone &&
            ((PZONE_INFO)(pNode->pZone))->pZoneRoot == pNode )
    {
        STAT_INC( TimeoutStats.CanNotDelete );
        return ERROR_SUCCESS;
    }

#if 0
    //
    //  DEVNOTE:  agressive delete?  delete even untimedout records?
    //
    //      need to test again, inside locks for kids, ref, access
    //      then delete all cached records in the list
    //
    //      don't want to do zone nodes, unless know there is CACHED
    //      DATA
    //

    RR_ListDelete( pNode );
#endif

    //
    //  no RRs -- delete node
    //
    //  NTree_RemoveNode() holds both locks, see it for a description
    //  of locking requirements
    //

    IF_DEBUG( DATABASE )
    {
        Dbg_NodeName(
            "Timeout thread deleting node ",
            pNode,
            "\n" );
    }

    if ( NTree_RemoveNode( pNode ) )
    {
        STAT_INC( TimeoutStats.Deleted );
        return ERROR_TIMEOUT;
    }

    STAT_INC( TimeoutStats.CanNotDelete );
    return ERROR_SUCCESS;
}



VOID
executeDelayedFree(
    IN      PDELAYED_FREE   pTimeoutFree
    )
/*++

Routine Description:

    Execute a delayed (timeout) free.

Arguments:

    pv -- ptr to free after timeout

Return Value:

    None.

--*/
{
    STAT_INC( TimeoutStats.DelayedFreesExecuted );

    ASSERT( pTimeoutFree->Tag == DELAYED_TAG );

    //
    //  Check for delayed free blocks that are already marked as
    //  free. In release mode, leak them. In debug mode or in release
    //  mode if heap debug flag is set, break.
    //

    #if DBG
    if ( 1 )
    #else
    if ( SrvCfg_dwHeapDebug )
    #endif
    {
        HARD_ASSERT( Mem_VerifyHeapBlock( pTimeoutFree->pItem, 0, 0 ) );
    }
    else
    {
        if ( !Mem_VerifyHeapBlock( pTimeoutFree->pItem, 0, 0 ) )
        {
            DNS_PRINT((
                "WARNING: executeDelayedFree() leaking corrupt block %p\n",
                "    Tag       = %d\n"
                "    File      = %s\n"
                "    Line      = %d\n",
                pTimeoutFree->pItem,
                pTimeoutFree->Tag,
                pTimeoutFree->pszFile,
                pTimeoutFree->LineNo ));
            goto Done;
        }
    }

    if ( pTimeoutFree->pFreeFunction )
    {
        STAT_INC( TimeoutStats.DelayedFreesExecutedWithFunction );

#if DBG
        // catch bogus record frees

        if ( *pTimeoutFree->pFreeFunction == RR_Free )
        {
            SET_SLOWFREE_RANK( ((PDB_RECORD)pTimeoutFree->pItem) );
        }
#endif

        (*pTimeoutFree->pFreeFunction)( pTimeoutFree->pItem );
    }
    else
    {
        FREE_HEAP( pTimeoutFree->pItem );
    }

    Done:
    
    //  free timeout free struct itself

    FREE_TAGHEAP( pTimeoutFree, sizeof(DELAYED_FREE), MEMTAG_TIMEOUT );
}



VOID
checkNodesInTimeoutBin(
    IN      UCHAR       Bin
    )
/*++

Routine Description:

    Set timeout on node.

Arguments:

    Bin -- timeout bin to check

Return Value:

    None.

--*/
{
    PTIMEOUT_ARRAY  ptimeoutArray;
    PTIMEOUT_ARRAY  pback;
    DWORD           i;
    DNS_STATUS      status;
    PDB_NODE        pnode;

    DNS_DEBUG( TIMEOUT, (
        "Checking nodes in timeout bin %d\n",
        Bin ));

    //
    //  walk all timeout arrays in this bin
    //      - execute delayed timeouts
    //      - check nodes, possibly timing out

    pback = (PTIMEOUT_ARRAY) &TimeoutBinArray[ Bin ];

    while ( ptimeoutArray = pback->pNext )
    {
        i = 0;

        while ( i < ptimeoutArray->Count )
        {
            pnode = ptimeoutArray->pNode[i];

            //  check for service exit, before dumping node

            if ( fDnsServiceExit )
            {
                return;
            }
            status = timeoutDbaseNode( pnode );
            if ( status == ERROR_SUCCESS )
            {
                i++;
                continue;
            }
            ASSERT( status == ERROR_TIMEOUT || status == DNSSRV_STATUS_NODE_RECENTLY_ACCESSED );

            //  remove entry from this array

            ptimeoutArray->Count--;
            ptimeoutArray->pNode[i] = ptimeoutArray->pNode[ ptimeoutArray->Count ];

            //  if node was recently accessed, then requeue to current bin
            //  this saves full cycle wait when node has been touched but
            //      still should be in timeout system

            if ( status == DNSSRV_STATUS_NODE_RECENTLY_ACCESSED )
            {
                LOCK_TIMEOUT();
                insertPtrInTimeout( pnode, CurrentTimeoutBin );
                pnode->uchTimeoutBin = CurrentTimeoutBin;
                UNLOCK_TIMEOUT();
            }
        }

        //  check for service exit on each array

        if ( fDnsServiceExit )
        {
            return;
        }

        //  if deleted all nodes in timeout array, then delete array from chain
        //  otherwise reset pback to move forward

        if ( ptimeoutArray->Count == 0 )
        {
            pback->pNext = ptimeoutArray->pNext;
            deleteTimeoutArray( ptimeoutArray );
            continue;
        }
        else
        {
            pback = ptimeoutArray;
        }
    }
}



VOID
enforceCacheLimit(
    VOID
    )
/*++

Routine Description:

    This function makes several passes through the cache, becoming more
    aggressive on each pass, attempting to free enough nodes to put the
    cache below it's maximum limit. Note that the maximum cache size
    is a soft limit - the cache can exceed it for brief periods of time.

    We assume that this function is only called by the timeout thread so
    that the bin pointers will not be changing during this function.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "enforceCacheLimit" )

    INT                     passCount = sizeof( g_CacheLimitTimeAdjustments ) /
                                            sizeof( g_CacheLimitTimeAdjustments[ 0 ] );
    INT                     passIdx = -1;
    ULONG                   desiredCacheSize;   //  in bytes
    BOOLEAN                 fDone = FALSE;

    g_dwCacheFreeCount = 0;

    //
    //  This function should never be called if a cache limit is not set.
    //

    if ( SrvCfg_dwMaxCacheSize == DNS_SERVER_UNLIMITED_CACHE_SIZE )
    {
        DNS_DEBUG( TIMEOUT, (
            "%s: called but cache is not limited!\n", fn ));
        ASSERT( FALSE );
        return;
    }

    //
    //  The desired cache size is 90% of maximum.
    //
    //  DEVNOTE: tune this? make sure delta is not too small?
    //

    desiredCacheSize = ( ULONG ) ( SrvCfg_dwMaxCacheSize * 1000 * 0.90 );

    DNS_DEBUG( TIMEOUT, (
        "%s: starting at %d\n"
        "    currentCacheSize   = %lu\n"
        "    desiredCacheSize   = %lu\n"
        "    excess mem in use  = %ld (negative means below limit)\n"
        "    CheckTimeoutBin    = %d\n"
        "    CurrentTimeoutBin  = %d\n",
        fn,
        DNS_TIME(),
        DNS_SERVER_CURRENT_CACHE_BYTES,
        desiredCacheSize,
        DNS_SERVER_CURRENT_CACHE_BYTES - desiredCacheSize,
        ( int ) CheckTimeoutBin,
        ( int ) CurrentTimeoutBin ));

    //
    //  Loop until the cache is "sufficiently clear", becoming more
    //  aggressive each pass.
    //

    while ( !fDone && ++passIdx < passCount )
    {
        UCHAR   bin = CheckTimeoutBin;

        DNS_DEBUG( TIMEOUT, (
            "%s: starting pass %d adjustment %d\n", fn,
            passIdx,
            g_CacheLimitTimeAdjustments[ passIdx ] ));

        //
        //  If this enforcement requires at least one iteration with
        //  a time adjustment, bump "aggressive" stat.
        //

        if ( passIdx == 1 )
        {
            STAT_INC( CacheStats.PassesRequiringAggressiveFree );
        }

        //
        //  Set current time adjustment for this pass.
        //

        g_dwCacheLimitCurrentTimeAdjustment =
            g_CacheLimitTimeAdjustments[ passIdx ];

        //
        //  Loop through bins checking for nodes to free. 
        //

        while ( bin != CurrentTimeoutBin )
        {
            //
            //  Do nothing if this bin is empty.
            //

            if ( TimeoutBinArray[ bin ] &&
                ( TimeoutBinArray[ bin ]->Count ||
                    TimeoutBinArray[ bin ]->pNext ) )
            {
                //
                //  Are we done? Check for service exit or if the cache
                //  is now acceptable in size.
                //

                if ( fDnsServiceExit ||
                    DNS_SERVER_CURRENT_CACHE_BYTES < desiredCacheSize )
                {
                    fDone = TRUE;
                    break;
                }

                //
                //  Free nodes in this bin. 
                //

                DNS_DEBUG( TIMEOUT, (
                    "%s: checking bin=%d pass=%d timeAdjust=%d\n", fn,
                    bin,
                    passIdx,
                    g_dwCacheLimitCurrentTimeAdjustment ));

                checkNodesInTimeoutBin( bin );
            }
            --bin;
        }
    }

    if ( g_dwCacheFreeCount == 0 )
    {
        STAT_INC( CacheStats.PassesWithNoFrees );
    }

    //
    //  Reset current time adjustment to zero.
    //

    g_dwCacheLimitCurrentTimeAdjustment = 0;

    DNS_DEBUG( TIMEOUT, (
        "%s: finished at %d\n"
        "    currentCacheSize   = %lu\n"
        "    desiredCacheSize   = %lu\n"
        "    excess mem in use  = %ld (negative means below limit)\n"
        "    freed items        = %ld\n",
        fn,
        DNS_TIME(),
        DNS_SERVER_CURRENT_CACHE_BYTES,
        desiredCacheSize,
        DNS_SERVER_CURRENT_CACHE_BYTES - desiredCacheSize,
        g_dwCacheFreeCount ));

    if ( DNS_SERVER_CURRENT_CACHE_BYTES > desiredCacheSize )
    {
        STAT_INC( CacheStats.FailedFreePasses );
    }
    else
    {
        STAT_INC( CacheStats.SuccessfulFreePasses );
    }
}   //  enforceCacheLimit



//
//  Timeout thread.
//

DWORD
Timeout_Thread(
    IN      LPVOID  Dummy
    )
/*++

Routine Description:

    Thread to delete expired cached resource records and corresponding
    emptry domain nodes.

Arguments:

    Dummy - unused

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    DWORD   err;
    DWORD   waitTime;
    DWORD   nextBinTimeout;
    DWORD   nextDelayedCleanup;
    DWORD   lastUpdateOwnRecordsTime = DNS_TIME();
    DWORD   lastAllocFailure;
    DWORD   now;

    HANDLE  arrayWaitHandles[] =
        {
        hDnsCacheLimitEvent,
        hDnsShutdownEvent
        };

    //  save off timeout thread ID

    TimeoutThreadId = GetCurrentThreadId();

    //  hold timeout until started

    if ( !Thread_ServiceCheck() )
    {
        DNS_DEBUG( ANY, ( "Terminating timeout thread.\n" ));
        return 1;
    }

    //  init time base time
    //  force current time, after startup, so base time can not possibly
    //      include any load time

    TimeoutBaseTime = UPDATE_DNS_TIME();
    nextBinTimeout = TimeoutBaseTime + TimeoutInterval;
    nextDelayedCleanup = TimeoutBaseTime + TIMEOUT_FREE_DELAY;

    //
    //  Post-startup initialization. Perform any tasks here that must be
    //  executed as close as possible to server startup time but that
    //  require the local DNS listen to be running. In particular, anything
    //  that may require a remote LDAP connection may timeout if the local
    //  DNS client happens to be pointing at the local machine if the task
    //  is attempted before the local DNS listener is running.
    //
    
    Dp_TimeoutThreadTasks();

    //
    //  loop until service exit
    //

    while ( TRUE )
    {
        DWORD   timeSlept;

        //  calculate timeout
        //      - nearer of next delayed free or next timeout bin
        //      - note we wait an extra second to allow for slop in DNS_TIME()

        waitTime = nextDelayedCleanup;
        if ( waitTime > nextBinTimeout )
        {
            waitTime = nextBinTimeout;
        }
        waitTime -= DNS_TIME() - 1;

        //  protect against less than zero wrap

        EnterWait:

        if ( ( INT ) waitTime < TIMEOUT_MIN_WAIT_TIME )
        {
            waitTime = TIMEOUT_MIN_WAIT_TIME;
        }

        DNS_DEBUG( TIMEOUT, (
            "Entering timeout wait at %d:\n"
            "    timebase = %d\n"
            "    bin      = %d\n"
            "    wait     = %d\n",
            DNS_TIME(),
            TimeoutBaseTime,
            CurrentTimeoutBin,
            waitTime ));

        //
        //  Wait for
        //      - timer expiration
        //      - termination event
        //

        timeSlept = UPDATE_DNS_TIME();

        err = WaitForMultipleObjects(
                    sizeof( arrayWaitHandles ) / sizeof( arrayWaitHandles[ 0 ] ),
                    arrayWaitHandles,
                    FALSE,
                    waitTime * 1000 );

        now = UPDATE_DNS_TIME();
        timeSlept = now - timeSlept;

        //
        //  Update log level.
        //

        DNSLOG_UPDATE_LEVEL();

        //
        //  Check and possibly wait on service status
        //

        if ( !Thread_ServiceCheck() )
        {
            DNS_DEBUG( ANY, ( "Terminating timeout thread.\n" ));
            return 1;
        }

        //
        //  Adjust timeout for time slept in case we just right back up to
        //  the Wait call above. If we don't jump back up we will recalculate
        //  waitTime at the top of the loop.
        //

        waitTime -= timeSlept;

        //
        //  Signalled to enforce cache limit?
        //

        if ( err == WAIT_OBJECT_0 )
        {
            DNS_DEBUG( TIMEOUT, (
                "TimeoutThread: cache limit event at %d\n",
                DNS_TIME() ));
            enforceCacheLimit();
            goto EnterWait;
        }

        //
        //  Normal timeout has occurred.
        //

        ASSERT( err == WAIT_TIMEOUT );

        DNS_DEBUG( TIMEOUT, (
            "Timeout wakeup at %d\n"
            "    cleanup interval = %d\n"
            "    next cleanup     = %d\n"
            "    current bin      = %d\n"
            "    check bin        = %d\n"
            "    timeout interval = %d\n"
            "    next timeout     = %d\n",
            DNS_TIME(),
            TIMEOUT_FREE_DELAY,
            nextDelayedCleanup,
            CurrentTimeoutBin,
            CheckTimeoutBin,
            TimeoutInterval,
            nextBinTimeout ));

        //
        //  Test for recent memory failure. If memory allocations are
        //  failing we must not perform timeout tasks. The threads that
        //  are waiting for memory may have pointers to objects in the
        //  timeout system. This is a bit of a catch-22: we can't free
        //  memory while we're waiting for memory to become free, but
        //  memory exhaustion is catastrophic. Hopefully it is not DNS
        //  but some other process that is consuming excess memory.
        //
        
        lastAllocFailure = Mem_GetLastAllocFailureTime();
        if ( lastAllocFailure &&
             now < lastAllocFailure + TIMEOUT_INTERVAL * 2 )
        {
            continue;
        }

        //
        //  Push the log buffer to disk (if any logging is enabled). This
        //  is not a necessity, but on a server where only a few infrequent
        //  packets are logged it's nice to see them get dumped to disk
        //  every so often.
        //

        if ( SrvCfg_dwLogLevel != 0 )
        {
            Log_PushToDisk();
        }

        //
        //  check for and if necessary start scavenging
        //

        Scavenge_CheckForAndStart( FALSE );

        //
        //  Call tombstone function. This may or may not trigger a tombstone
        //  search-and-destroy thread.
        //

        Tombstone_Trigger();

        //
        //  Directory partition timeout tasks - manage built-in partitions.
        //

        Dp_TimeoutThreadTasks();

        //
        //  Update self-registrations. Do this every 20 minutes. The
        //  shortest refresh interval is 60 minutes, so perform refresh
        //  of own records every 20 minute to ensure it will be updated
        //  at least two or three times per refresh interval.
        //

        if ( now > lastUpdateOwnRecordsTime + 20*60 )
        {
            DNS_DEBUG( TIMEOUT, (
                "TimeoutThread: updating own zone records at %d\n"
                "    last done at           %d\n",
                now,
                lastUpdateOwnRecordsTime ));

            Zone_UpdateOwnRecords( FALSE );

            lastUpdateOwnRecordsTime = now;
        }

        //
        //  Free delayed frees
        //
        //  this is done on a faster time scale than timeout bin, so if not
        //  time for a full timeout bin cleanup, cycle back to wait
        //

        if ( now > nextDelayedCleanup )
        {
            Timeout_CleanupDelayedFreeList();
            nextDelayedCleanup = now + TIMEOUT_FREE_DELAY;
        }
#if DBG
        else if ( now < nextBinTimeout )
        {
            DNS_PRINT((
                "ERROR:  Timeout thread still messed up!!!\n"
                "    Failed delayed free test; failed timeout bin test!\n"
                "Timeout wakeup at %d\n"
                "    cleanup interval = %d\n"
                "    next cleanup     = %d\n"
                "    current bin      = %d\n"
                "    check bin        = %d\n"
                "    timeout interval = %d\n"
                "    next timeout     = %d\n",
                now,
                TIMEOUT_FREE_DELAY,
                nextDelayedCleanup,
                CurrentTimeoutBin,
                CheckTimeoutBin,
                TimeoutInterval,
                nextBinTimeout ));
        }
#endif
        //
        //  timeout next bin?
        //      - if wokeup only for delayed frees list, then
        //      go back into wait

        if ( now < nextBinTimeout )
        {
            continue;
        }

        //
        //  reset timeout globals for next interval
        //
        //  to allow recovery from debug session where clock gets
        //  past next timeout interval, we'll just reset TimeoutBaseTime
        //  at current time;  total drift over a cycle will be minimal
        //  and correction to caching bin is made continuously.
        //

        CurrentTimeoutBin++;
        CheckTimeoutBin++;

        DNS_DEBUG( TIMEOUT, (
            "Moving to timeout bin %d\n"
            "    check bin        = %d\n"
            "    timeout interval = %d\n"
            "    prev timebase    = %d\n"
            "    current time     = %d\n",
            CurrentTimeoutBin,
            CheckTimeoutBin,
            TimeoutInterval,
            TimeoutBaseTime,
            now ));

        ASSERT( CurrentTimeoutBin == (UCHAR)(CheckTimeoutBin + (UCHAR)2) );
        //ASSERT( nextBinTimeout + TimeoutInterval > DNS_TIME() );

        TimeoutBaseTime = now;
        nextBinTimeout = TimeoutBaseTime + TimeoutInterval;

        //  cleanup expired security sessions

        if ( g_fSecurityPackageInitialized )
        {
            Dns_TimeoutSecurityContextList( 0 );
        }

        //
        //  Check database nodes for timeout
        //

        checkNodesInTimeoutBin( CheckTimeoutBin );

        //
        //  check for exit
        //      - do again here as may be in timeout quite some time,
        //      likely to be aborted in timeout
        //

        if ( fDnsServiceExit )
        {
            DNS_DEBUG( ANY, ( "Terminating expiration timeout thread.\n" ));
            return 1;
        }

        //
        //  zone write back timeout
        //
        //  since debug builds have a very short timeout interval, we'll avoid
        //  writing back every time on debug builds;  every fifth time brings
        //  this up to ten minutes, more in line with retail 15minute interval
        //
#if 0
#if DBG
        if ( CurrentTimeoutBin % 5 )
        {
            continue;
        }
#endif
#endif
        Zone_WriteBackDirtyZones( FALSE );
    }
}



//
//  Public timeout functions
//

VOID
Timeout_SetTimeoutOnNodeEx(
    IN OUT  PDB_NODE        pNode,
    IN      DWORD           dwTimeout,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Set timeout on node.

Arguments:

    pNode       -- node to check at timeout

    dwTimeout   -- timeout for caching nodes in seconds

    dwFlag      -- flags, currently is BOOL,
        TIMEOUT_REFERENCE if added from deleting reference to node
        TIMEOUT_PARENT if added from deleting child
        0 for direct timeout

Return Value:

    None.

--*/
{
    UCHAR   binIndex;

    DNS_DEBUG( TIMEOUT, (
        "SetTimeoutOnNodeEx( %p )\n"
        "    flag     = %lx\n"
        "    timeout  = %d\n"
        "    label    = %s\n",
        pNode,
        dwFlag,
        dwTimeout,
        pNode->szLabel ));
        
    if ( !pNode )
    {
        return;
    }

    //
    //  never enter node in timeout system more than once
    //  so no need to worry about multiple references to node;
    //  timeout thread does any moving around of nodes.
    //
    //  toss nodes already in timeout system -- before we lock
    //

    if ( IS_TIMEOUT_NODE(pNode) )
    {
        STAT_INC( TimeoutStats.AlreadyInSystem );
        return;
    }

    //  lock node while insert in timeout system

    LOCK_TIMEOUT();

    if ( IS_TIMEOUT_NODE(pNode) )
    {
        STAT_INC( TimeoutStats.AlreadyInSystem );
        goto Unlock;
    }

    SET_TIMEOUT_NODE( pNode );
    SET_NODE_ACCESSED( pNode );

    //
    //  log why we are setting timeout
    //

    if ( dwFlag & TIMEOUT_REFERENCE )
    {
        STAT_INC( TimeoutStats.SetFromDereference );
    }
    else if ( dwFlag & TIMEOUT_PARENT )
    {
        STAT_INC( TimeoutStats.SetFromChildDelete );
    }
    else
    {
        ASSERT( dwFlag == 0 || dwFlag == TIMEOUT_NODE_LOCKED );
        STAT_INC( TimeoutStats.SetDirect );
    }
    STAT_INC( TimeoutStats.SetTotal );

    //
    //  if caching timeout, then determine bin
    //  otherwise default is next bin
    //
    //  determine bin (offset from current) for this timeout
    //      - determine timeout in number of intervals
    //      - then use only mod256
    //

    if ( dwTimeout )
    {
        binIndex = ( UCHAR ) ( ( dwTimeout / TimeoutInterval ) & 0xff );
        DNS_DEBUG( TIMEOUT2, (
            "Timeout bin offset %d for node at %p\n",
            binIndex,
            pNode ));

        //
        //  determine actual bin
        //  note, if CurrentBin increments after calcing offset, we are
        //  still ok, we just end up one bin further along before trying timeout
        //
        //  however restrict so that DO NOT write into CheckBin or CheckBin+1,
        //  as these may be read by timeout thread asynchronously with this call;
        //  write to current bin instead
        //

        if ( binIndex > MAX_ALLOWED_BIN_OFFSET )
        {
            binIndex = 0;
        }
        binIndex += CurrentTimeoutBin;
    }
    else
    {
        binIndex = CurrentTimeoutBin;
    }

    //  insert node in timeout system

    insertPtrInTimeout( pNode, binIndex );
    pNode->uchTimeoutBin = binIndex;

Unlock:

    UNLOCK_TIMEOUT();
}



BOOL
Timeout_ClearNodeTimeout(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Clear node from timeout bin.

Arguments:

    pNode -- node (or delayed free ptr) to check at timeout

Return Value:

    TRUE -- if pNode removed from timeout
    FALSE -- if timeout thread will clean up

--*/
{
    PTIMEOUT_ARRAY  ptimeoutArray;
    DWORD           i;
    UCHAR           bin = pNode->uchTimeoutBin;


    DNS_DEBUG( TIMEOUT, (
        "Clearing node %p from timeout bin %d\n",
        pNode,
        bin ));

    ASSERT( GetCurrentThreadId() == TimeoutThreadId );

    //
    //  DEVNOTE:  this function should ONLY run under timeout thread
    //      if so can avoid this check and always cleanup
    //
    //  if timeout going on on bin -- stop
    //      - let timeout thread clean up this node
    //
    //  however, all tree deletes on once-active trees, are done by delayed
    //  free, so we should always BE the timeout thread if we get here
    //

    if ( bin == CheckTimeoutBin || bin == CheckTimeoutBin+1 )
    {
        if ( GetCurrentThreadId() != TimeoutThreadId )
        {
            DNS_PRINT((
                "ERROR:  clearing node (%p) timeout outside timeout thread!!!!\n",
                pNode ));
            ASSERT( FALSE );
            return( FALSE );
        }
    }

    //
    //  traverse this bin, until find pNode ptr and remove
    //

    LOCK_TIMEOUT();

    ptimeoutArray = TimeoutBinArray[ bin ];

    while ( 1 )
    {
        if ( !ptimeoutArray )
        {
            break;
        }

        //  check this array block for pNode ptr
        //      - if pNode found, delete it, replace with last ptr in array

        for ( i = 0; i < ptimeoutArray->Count; ++i )
        {
            if ( ptimeoutArray->pNode[ i ] == pNode )
            {
                --ptimeoutArray->Count;
                ptimeoutArray->pNode[ i ] =
                    ptimeoutArray->pNode[ ptimeoutArray->Count ];
                goto Done;
            }
        }

        //  check next array block

        ptimeoutArray = ptimeoutArray->pNext;
        continue;
    }

    DNS_DEBUG( ANY, (
        "ERROR:  node %p, not found in timeout bin %d as indicated!\n",
        pNode,
        bin ));
    ASSERT( FALSE );

Done:

    UNLOCK_TIMEOUT();
    return TRUE;
}



//
//  Timeout free
//

VOID
Timeout_FreeWithFunctionEx(
    IN      PVOID           pItem,
    IN      VOID            (*pFreeFunction)( PVOID ),
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Set ptr to be freed after timeout.

Arguments:

    pItem -- item to be freed

    pFreeFunction -- function to free the desired item

    pszFile -- file name of caller

    LineNo -- line number of caller

Return Value:

    None.

--*/
{
    PDELAYED_FREE   pfree;

    //  handle NULL ptrs to simplify calling code

    if ( !pItem )
    {
        return;
    }

    HARD_ASSERT( Mem_VerifyHeapBlock( pItem, 0, 0 ) );

    //
    //  allocate timeout free list element
    //

    pfree = (PDELAYED_FREE) ALLOC_TAGHEAP( sizeof(DELAYED_FREE), MEMTAG_TIMEOUT );
    IF_NOMEM( !pfree )
    {
        return;
    }
    pfree->Tag = DELAYED_TAG;
    pfree->pItem = pItem;
    pfree->pFreeFunction = pFreeFunction;
    pfree->pszFile = pszFile;
    pfree->LineNo = LineNo;

    STAT_INC( TimeoutStats.DelayedFreesQueued );
    if ( pFreeFunction )
    {
        STAT_INC( TimeoutStats.DelayedFreesQueuedWithFunction );
    }

    //
    //  Collect delayed frees in a list
    //      - just stick entry on the front of the list
    //

    LOCK_TIMEOUT();

    #if 0 && DBG
    {
        //
        //  See if the item is already queued for free.
        //

        PDELAYED_FREE   p;
        INT             pass;

        for ( pass = 0; pass < 2; ++pass )
        {
            p = pass == 0
                    ? CoolingDelayedFreeList
                    : CurrentDelayedFreeList;
        
            for ( ; p != NULL ; p = p->pNext )
            {
                ASSERT( p->pItem != pItem );
            }
        }
    }
    #endif

    pfree->pNext = CurrentDelayedFreeList;
    CurrentDelayedFreeList = pfree;
    CurrentDelayedCount++;

    UNLOCK_TIMEOUT();
}



VOID
Timeout_CleanupDelayedFreeList(
    VOID
    )
/*++

Routine Description:

    Cleanup delayed free list.

Arguments:

    None

Return Value:

    None

--*/
{
    PDELAYED_FREE   pfree;
    PDELAYED_FREE   pdeleteList;
    DWORD   count;

    DNS_DEBUG( TIMEOUT, (
        "Executing delayed frees for this timeout interval.\n"
        "    CurrentDelayedFreeList = %p\n"
        "    CoolingDelayedFreeList = %p\n",
        CurrentDelayedFreeList,
        CoolingDelayedFreeList ));

    //
    //  switch lists around
    //      - current goes into wait
    //      - wait list can now be deleted
    //
    //  need to do this under lock, to protect queuing
    //

    LOCK_TIMEOUT();
    pdeleteList = CoolingDelayedFreeList;
    CoolingDelayedFreeList = CurrentDelayedFreeList;
    CurrentDelayedFreeList = NULL;

    count = CoolingDelayedCount;
    CoolingDelayedCount = CurrentDelayedCount;
    CurrentDelayedCount = 0;
    UNLOCK_TIMEOUT();

    //
    //  delete entries in Delete list
    //      - since list can be long, check for service exit on each free
    //

    while ( pdeleteList )
    {
        if ( fDnsServiceExit )
        {
            return;
        }
        pfree = pdeleteList;
        pdeleteList = pfree->pNext;
        executeDelayedFree( pfree );
        count--;
    }

    ASSERT( count == 0 );
}



VOID
Timeout_FreeAndReplaceZoneDataEx(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PVOID *         ppZoneData,
    IN      PVOID           pNewData,
    IN      VOID            (*pFreeFunction)( PVOID ),
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Timeout free zone data and replace within lock.

    The purpose of the function is to correctly handle the interlocking
    in one place to avoid possiblity of double free from MT access.

Arguments:

    pZone -- zone ptr

    ppZoneData -- addr in zone block of item to free

    pNewData -- ptr to new data

    pFreeFunction -- function to free the desired item

    pszFile -- file name of caller

    LineNo -- line number of caller

Return Value:

    None.

--*/
{
    PVOID   poldData = *ppZoneData;

    //
    //  replace zone data ptr -- within lock
    //

    Zone_UpdateLock( pZone );

    poldData = *ppZoneData;

    *ppZoneData = pNewData;

    Zone_UpdateUnlock( pZone );

    //
    //  timeout free the old data
    //

    Timeout_FreeWithFunctionEx(
        poldData,
        pFreeFunction,
        pszFile,
        LineNo );
}

//
//  End of timeout.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\thread.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    thread.c

Abstract:

    Domain Name System (DNS) Server

    DNS thread management.

    Need to maintain a list of thread handles so we can wait on these
    handles to insure all threads terminate at shutdown.

Author:

    Jim Gilroy (jamesg)     September 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Thread arrays
//
//  Need to store thread handles for main thread to wait on at
//  service shutdown.
//
//  Need to store thread ids so that dynamic threads (zone transfer)
//  can reliably find their own handle and close it when they terminate.
//

#define DNS_MAX_THREAD_COUNT    (120)

DWORD   g_ThreadCount;

CRITICAL_SECTION    csThreadList;

HANDLE  g_ThreadHandleArray[ DNS_MAX_THREAD_COUNT ];
DWORD   g_ThreadIdArray[ DNS_MAX_THREAD_COUNT ];
LPSTR   g_ThreadTitleArray[ DNS_MAX_THREAD_COUNT ];

//
//  Limit XFR receive threads -- building database can produce quite a bit
//      of lock contention
//

#define XFR_THREAD_COUNT_LIMIT      ((g_ProcessorCount*2) + 3)

DWORD   g_XfrThreadCount;


//
//  Thread timeout on shutdown
//      - if debug set longer timeout to allow for printing

#if DBG
#define THREAD_TERMINATION_WAIT         30000   // give them 30 seconds
#define THREAD_DEBUG_TERMINATION_WAIT   1000    // one sec to find offender
#else
#define THREAD_TERMINATION_WAIT         10000   // give them 10 seconds
#endif


//
//  Private protos
//

#if DBG
VOID
Dbg_ThreadHandleArray(
    VOID
    );

VOID
Dbg_Thread(
    IN      LPSTR   pszHeader,
    IN      DWORD   iThread
    );
#else

#define Dbg_Thread(a,b)
#define Dbg_ThreadHandleArray()

#endif


typedef struct  _DnsThreadStartContext
{
    LPTHREAD_START_ROUTINE      Function;
    LPVOID                      Parameter;
}
THREAD_START_CONTEXT, *PTHREAD_START_CONTEXT;



DWORD
threadTopFunction(
    IN      PTHREAD_START_CONTEXT   pvThreadContext
    )
/*++

Routine Description:

    Top level function of new DNS thread.

    This function provides a single location for handling thread exception
    handling code.  All DNS thread start under this function.

Arguments:

    pvThreadContext -- context of thread being created;  contains ptr to actual
        functional top routine of thread and its parameter

Return Value:

    Return from actual thread function.
    Zero on exception.

--*/
{
    LPTHREAD_START_ROUTINE  function;
    LPVOID                  param;

    //
    //  execute thread function with param
    //      - free context block
    //

    try
    {
        function = pvThreadContext->Function;
        param = pvThreadContext->Parameter;

        DNS_DEBUG( INIT, (
            "NEW THREAD:\n"
            "    function     = %p\n"
            "    parameter    = %p\n",
            function,
            param ));

        FREE_HEAP( pvThreadContext );

        return (* function)( param );
    }

    except( TOP_LEVEL_EXCEPTION_TEST() )
    {
        DNS_DEBUG( ANY, (
            "EXCEPTION: %p (%d) on thread\n",
            GetExceptionCode(),
            GetExceptionCode() ));

        //TOP_LEVEL_EXCEPTION_BODY();
        Service_IndicateException();
    }
    return 0;
}



HANDLE
Thread_Create(
    IN      LPSTR                   pszThreadTitle,
    IN      LPTHREAD_START_ROUTINE  lpStartAddr,
    IN      LPVOID                  lpThreadParam,
    IN      DWORD                   dwFailureEvent  OPTIONAL
    )
/*++

Routine Description:

    Creates DNS threads.

Arguments:

    pszThreadTitle -- title of this thread

    lpStartAddr -- thread start routine

    lpThreadParam -- startup parameter

    dwFailureEvent -- event to log on failure

Return Value:

    Thread handle, if successful
    NULL if unable to create thread

--*/
{
    HANDLE  threadHandle;
    DWORD   threadId;
    PTHREAD_START_CONTEXT pthreadStartContext;

    DNS_DEBUG( INIT, ( "Creating thread %s\n", pszThreadTitle ));

    //
    //  initialize if first thread
    //

    if ( g_ThreadCount == 0 )
    {
        g_XfrThreadCount = 0;

        if ( DnsInitializeCriticalSection( &csThreadList ) != ERROR_SUCCESS )
        {
            return NULL;
        }
    }

    //
    //  verify validity of another thread
    //

    if ( g_ThreadCount >= DNS_MAX_THREAD_COUNT )
    {
        DNS_PRINT(( "WARNING:  Thread handle array maximum exceeded\n" ));
        Dbg_ThreadHandleArray();
        return ( HANDLE ) NULL;
    }

    if ( lpStartAddr == Xfr_ReceiveThread &&
        g_XfrThreadCount > XFR_THREAD_COUNT_LIMIT )
    {
        DNS_DEBUG( ANY, (
            "WARNING: suppressed XFR receive thread create - %d threads outstanding\n",
            g_XfrThreadCount ));
        return ( HANDLE ) NULL;
    }

    //
    //  create thread context to pass to startup routine
    //

    pthreadStartContext = (PTHREAD_START_CONTEXT) ALLOC_TAGHEAP(
                                                        sizeof(THREAD_START_CONTEXT),
                                                        MEMTAG_THREAD );
    IF_NOMEM( !pthreadStartContext )
    {
        return ( HANDLE ) NULL;
    }
    pthreadStartContext->Function = lpStartAddr;
    pthreadStartContext->Parameter = lpThreadParam;

    //
    //  create thread
    //
    //  note, we do this withing critical section, so that we can
    //  wait on CS when thread terminates, and we are guaranteed that
    //  it has been added to the list
    //

    EnterCriticalSection( &csThreadList );

    threadHandle = CreateThread(
                        NULL,           // security attributes
                        0,              // init stack size (process default)
                        threadTopFunction,
                        pthreadStartContext,
                        0,              // creation flags
                        &threadId );
    if ( threadHandle == NULL )
    {
        LeaveCriticalSection( &csThreadList );

        if ( ! dwFailureEvent )
        {
            dwFailureEvent = DNS_EVENT_CANNOT_CREATE_THREAD;
        }
        DNS_LOG_EVENT(
            dwFailureEvent,
            0,
            NULL,
            NULL,
            GetLastError()
            );
        return( NULL );
    }

    //
    //  created thread, add info to list, inc thread count
    //

    g_ThreadHandleArray[ g_ThreadCount ]  = threadHandle;
    g_ThreadIdArray    [ g_ThreadCount ]  = threadId;
    g_ThreadTitleArray [ g_ThreadCount ]  = pszThreadTitle;

    IF_DEBUG( INIT )
    {
        Dbg_Thread(
            "Created new thread ",
            g_ThreadCount );
    }

    g_ThreadCount++;
    if ( lpStartAddr == Xfr_ReceiveThread )
    {
        g_XfrThreadCount++;
    }
    LeaveCriticalSection( &csThreadList );

    return threadHandle;
}



VOID
Thread_Close(
    IN      BOOL            fXfrRecv
    )
/*++

Routine Description:

    Close handle for current thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD   threadId;
    DWORD   i;

    //  get current thread id

    threadId = GetCurrentThreadId();

    //
    //  find thread id in thread array
    //      - close thread handle
    //      - replace thread info, with info at top of arrays
    //

    EnterCriticalSection( &csThreadList );

    for ( i = 0; i < g_ThreadCount; i++ )
    {
        if ( threadId == g_ThreadIdArray[i] )
        {
            IF_DEBUG( SHUTDOWN )
            {
                Dbg_Thread( "Closing thread ", i );
            }

            if ( g_ThreadHandleArray[ i ] )
            {
                CloseHandle( g_ThreadHandleArray[ i ] );
            }

            --g_ThreadCount;
            g_ThreadTitleArray[i]  = g_ThreadTitleArray[g_ThreadCount];
            g_ThreadHandleArray[i] = g_ThreadHandleArray[g_ThreadCount];
            g_ThreadIdArray[i]     = g_ThreadIdArray[g_ThreadCount];

            goto Unlock;
        }
    }

    //
    //  somethings broken
    //

    DNS_PRINT((
        "ERROR:  Attempt to close unknown thread id %d\n"
        "    Not in thread handle array\n",
        threadId ));

    Dbg_ThreadHandleArray();
    ASSERT( FALSE );

Unlock:

    //
    //  track count of outstand XFR receive threads
    //

    if ( fXfrRecv )
    {
        g_XfrThreadCount--;
    }
    LeaveCriticalSection( &csThreadList );
}



VOID
Thread_ShutdownWait(
    VOID
    )
/*++

Routine Description:

    Wait for all DNS threads to shutdown.

Arguments:

    None.

Return Value:

    None.

--*/
{
    INT     err;
    DWORD   i;

    //
    //  Wait on outstanding thread handles.
    //

    IF_DEBUG( INIT )
    {
        DNS_PRINT(( "Thread shutdown wait\n" ));
        Dbg_ThreadHandleArray();
    }

    if ( g_ThreadCount > 0 )
    {
        err = WaitForMultipleObjects(
                    g_ThreadCount,
                    g_ThreadHandleArray,
                    TRUE,                       //  wait for all
                    THREAD_TERMINATION_WAIT );  //  but don't allow hang
        IF_DEBUG( SHUTDOWN )
        {
            DNS_PRINT((
                "Thread shutdown wait completed, return = %lx\n",
                err ));
        }

        //
        //  if wait fails, find hanging thread and KILL IT
        //

        if ( err == WAIT_TIMEOUT )
        {
            DNS_PRINT(( "ERROR:  Shutdown thread handle wait failed\n" ));

            Dbg_ThreadHandleArray();

            //
            //  Try each thread to find hanging thread. There should be
            //  no worker threads still alive. If any have hung we need
            //  to figure out why and fix the problem.
            //

            //  LOW PRI BUG: this needs to be fixed for Longhorn.
            //  ASSERT( g_ThreadCount == 0 );

            for ( i = 0; i < g_ThreadCount; i++ )
            {
                err = WaitForSingleObject(
                        g_ThreadHandleArray[i],
                        0 );
                if ( err == WAIT_TIMEOUT )
                {
                    DNS_PRINT((
                        "ERROR: thread %d did not terminate\n",
                        g_ThreadIdArray[ i ] ));

                    //
                    //  It's dangerous to call TerminateThread. This
                    //  needs to be changed for Longhorn.

                    TerminateThread( g_ThreadHandleArray[ i ], 1 );
                }
            }
        }

        //
        //  Close all remaining worker thread handles.
        //

        EnterCriticalSection( &csThreadList );
        for ( i = 0; i < g_ThreadCount; i++ )
        {
            err = CloseHandle( g_ThreadHandleArray[ i ] );

            //
            //  NULL the handle in case any worker threads are still running
            //  and end up calling Thread_Close after this.
            //

            g_ThreadHandleArray[ i ] = 0;

            #if DBG
            if ( !err )
            {
                DNS_PRINT((
                    "ERROR:  error %d closing thread handle %p\n",
                    g_ThreadHandleArray[i],
                    err ));
            }
            #endif
        }
        LeaveCriticalSection( &csThreadList );
    }
}   //  Thread_ShutdownWait



LPSTR
Thread_DescrpitionMatchingId(
    IN      DWORD           ThreadId
    )
/*++

Routine Description:

    Debug print title of thread matching given thread ID.

Arguments:

    ThreadId -- ID of desired thread.

Return Value:

    None.

--*/
{
    LPSTR   pszthreadName = NULL;
    DWORD   i;

    //
    //  get title of matching thread id
    //      - since all names are static in DNS.exe binary
    //      they can be returned outside of thread list CS, even
    //      though mapping with ID may no longer be valid
    //

    EnterCriticalSection( &csThreadList );
    for ( i=0; i<g_ThreadCount; i++ )
    {
        if ( ThreadId == g_ThreadIdArray[i] )
        {
            pszthreadName = g_ThreadTitleArray[i];
            break;
        }
    }
    LeaveCriticalSection( &csThreadList );

    return pszthreadName;
}



#if DBG

VOID
Dbg_ThreadHandleArray(
    VOID
    )
/*++

Routine Description:

    Debug print DNS thread handle array.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD i;

    //
    //  Print handles and descriptions of all threads.
    //

    DnsDebugLock();

    DnsPrintf(
        "\nThread handle array (%d active threads):\n",
        g_ThreadCount );

    for ( i=0; i<g_ThreadCount; i++ )
    {
        Dbg_Thread( NULL, i );
    }
    DnsDebugUnlock();
}



VOID
Dbg_Thread(
    IN      LPSTR       pszHeader,
    IN      DWORD       iThread
    )
/*++

Routine Description:

    Debug print DNS thread.

Arguments:

    pThread -- ptr to DNS thread.

Return Value:

    None.

--*/
{
    DnsPrintf(
        "%s%s:\n"
        "    handle = %p\n"
        "    id = %d\n",
        pszHeader ? pszHeader : "",
        g_ThreadTitleArray[iThread],
        g_ThreadHandleArray[iThread],
        g_ThreadIdArray[iThread] );
}



VOID
Dbg_ThreadDescrpitionMatchingId(
    IN      DWORD   ThreadId
    )
/*++

Routine Description:

    Debug print title of thread matching given thread ID.

Arguments:

    ThreadId -- ID of desired thread.

Return Value:

    None.

--*/
{
    LPSTR   pszthreadName;

    pszthreadName = Thread_DescrpitionMatchingId( ThreadId );

    if ( pszthreadName )
    {
        DnsPrintf(
            "Thread %s matches thread ID %d\n",
            pszthreadName,
            ThreadId );
    }
    else
    {
        DnsPrintf(
            "Thread ID %d not found in thread handle array\n",
            ThreadId );
    }

#if 0
    //
    //  print title of thread matching thread ID
    //

    EnterCriticalSection( &csThreadList );
    for ( i=0; i<g_ThreadCount; i++ )
    {
        if ( ThreadId == g_ThreadIdArray[i] )
        {
            DnsPrintf(
                "Thread %s matches thread ID %d\n",
                g_ThreadTitleArray[i],
                ThreadId );

            LeaveCriticalSection( &csThreadList );
            return;
        }
    }
    LeaveCriticalSection( &csThreadList );

    DnsPrintf(
        "Thread ID %d not found in thread handle array\n",
        ThreadId );
#endif
}

#endif  // DBG




//
//  Service control utility for DNS threads
//

BOOL
Thread_ServiceCheck(
    VOID
    )
/*++

Routine Description:

    Wrap up all service checking functions for use by worker threads.

Arguments:

    None.

Return Value:

    TRUE if service continues.
    FALSE for service exit.

--*/
{
    DWORD   err;

    #if DBG
    if ( !g_RunAsService )
    {
        return TRUE;
    }
    #endif

    //
    //  Implementation note:
    //
    //  Checking for pause first.
    //  Service termination sets the pause event to free paused threads.
    //
    //  1)  Can use pause event to hold new worker threads during
    //  startup.  Then if initialization fails, immediately fall into
    //  shutdown without touching, perhaps broken, data structures.
    //
    //  2)  We can shutdown from paused state, without releasing threads
    //  for another thread processing cycle.
    //

    //
    //  Service is paused?  ->  wait for it to become unpaused.
    //

    if ( DnsServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING ||
         DnsServiceStatus.dwCurrentState == SERVICE_PAUSED ||
         DnsServiceStatus.dwCurrentState == SERVICE_START_PENDING )
    {
        DWORD   waiterr;

        waiterr = WaitForSingleObject( hDnsContinueEvent, INFINITE );

        ASSERT( waiterr != WAIT_FAILED || fDnsServiceExit );
    }

    //
    //  Service termination?  ->  exit
    //

    if ( fDnsServiceExit )
    {
        return FALSE;
    }

    return TRUE;
}



//
//  Cheap, low-use critical section routines.
//
//  These allow flag to do work of CS, by piggy backing on
//  single general purpose CS, without requiring it to be held
//  for entire CS.
//

BOOL
Thread_TestFlagAndSet(
    IN OUT  PBOOL           pFlag
    )
/*++

Routine Description:

    Test flag and set if currently clear.

Arguments:

    pFlag -- ptr to BOOL variable

Return Value:

    TRUE if flag was clear -- flag is now set.
    FALSE if flag already set.

--*/
{
    BOOL    result = FALSE;

    GENERAL_SERVER_LOCK()

    if ( ! *pFlag )
    {
        result = TRUE;
        *pFlag = TRUE;
    }

    GENERAL_SERVER_UNLOCK()
    return result;
}


VOID
Thread_ClearFlag(
    IN OUT  PBOOL           pFlag
    )
/*++

Routine Description:

    Clear flag (assumes flag is currently set).

Arguments:

    pFlag -- ptr to BOOL variable

Return Value:

    None

--*/
{
    GENERAL_SERVER_LOCK()
    *pFlag = FALSE;
    GENERAL_SERVER_UNLOCK()
}

//
//  End thread.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\tombston.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    Tombston.c

Abstract:

    Domain Name System (DNS) Server

    Implementation of tombstone search and destroy mechanism.

Author:

    Jeff Westhead   September 1999

Revision History:

--*/


/*
Tombstone notes:

A node is marked as dead or "tombstoned" in the DS by giving it a
DNS record type of zero and an attribute value of "dNSTombstoned=TRUE".
Tombstoned records must be held in the DS for a certain time interval
to allow the deletion to replicate to other DS servers. When this
interval has expired, the record must be deleted from the DS. The
data in the DNS data blob holds the time when the record was tombstoned
int FILETIME format.

Tombstone_Thread will periodically do the following:
1) perform an LDAP search to find all tombstoned records
2) delete expired tombstoned records
*/


/*
JJW issues:
- increment stats as in ds.c - tombstone delete count at the very least
*/


//
//  Include directives
//


#include "dnssrv.h"
#include "ds.h"


//
//  Define directives
//


#define SECONDS_IN_FILETIME( secs ) (secs*10000000i64)

#ifdef UNICODE //  copied this from ds.c - why do we do this?
#undef UNICODE
#endif

#if DBG
#define TRIGGER_INTERVAL (30*60)            //  30 minutes
#else
#define TRIGGER_INTERVAL (24*60*60)         //  24 hours
#endif



//
//  Types
//


//
//  Static global variables
//


static WCHAR    g_szTombstoneFilter[] = LDAP_TEXT("(dNSTombstoned=TRUE)");
static LONG     g_TombstoneThreadRunning = 0;


//
//  Functions
//



DNS_STATUS
startTombstoneSearch(
    IN OUT  PDS_SEARCH      pSearchBlob,
    IN      PDNS_DP_INFO    pDpInfo
    )
/*++

Routine Description:

    Starts a paged LDAP search for tombstoned DNS records.

Arguments:

    pSearchBlob -- pointer to a search blob

    pDpInfo -- pointer to directory partition to search or
        NULL to search the legacy partition

Return Value:

    ERROR_SUCCESS or error code

--*/
{
    DBG_FN( "startTombstoneSearch" )

    DNS_STATUS      status;
    PLDAPSearch     psearch = NULL;
    PLDAPControl    ctrls[] =
                    {
                        &NoDsSvrReferralControl,
                        NULL
                    };
    PWSTR           searchAttrs[] =
                    {
                        DSATTR_DNSRECORD,
                        NULL
                    };

    Ds_InitializeSearchBlob( pSearchBlob );

    psearch = ldap_search_init_page(
                    pServerLdap,
                    pDpInfo ?
                        pDpInfo->pwszDpDn :
                        DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal,
                    LDAP_SCOPE_SUBTREE,         //  search scope
                    g_szTombstoneFilter,        //  search filter
                    searchAttrs,                //  attribute list
                    FALSE,                      //  attributes only
                    ctrls,                      //  server controls
                    NULL,                       //  client controls
                    0,                          //  page time limit
                    0,                          //  total size limit
                    NULL );                     //  sort keys

    if ( !psearch )
    {
        DNS_DEBUG( TOMBSTONE,
            ( "%s: error %lu trying to init search\n", fn, LdapGetLastError() ));
        status = Ds_ErrorHandler( LdapGetLastError(), NULL, pServerLdap, 0 );
        ASSERT( status != ERROR_SUCCESS );
        if ( status == ERROR_SUCCESS )
        {
            status = DNSSRV_STATUS_DS_UNAVAILABLE;
        }
        goto Failed;
    }

    pSearchBlob->pSearchBlock = psearch;

    return ERROR_SUCCESS;

Failed:

    if ( psearch )
    {
        ldap_search_abandon_page(
            pServerLdap,
            psearch );
    }
    DNS_DEBUG( TOMBSTONE, ( "%s: failed %d\n", fn, status ));
    return status;
}   //  startTombstoneSearch



DNS_STATUS
checkPartitionForTombstones(
    IN      PDNS_DP_INFO    pDpInfo
    )
/*++

Routine Description:

    This function checks a partition for tombstones, deleting any that
    have expired.

Arguments:

    pDpInfo -- directory partition or NULL to check legacy partition

Return Value:

    Error code.

--*/
{
    DBG_FN( "Tombstone_Thread" )

    DNS_STATUS      status = ERROR_SUCCESS;
    ULONG           deleteStatus = LDAP_SUCCESS;
    DS_SEARCH       searchBlob;
    INT             deleteCount = 0;

    DNS_DEBUG( TOMBSTONE, ( "%s: start at %d (ldap=%p)\n", fn, DNS_TIME(), pServerLdap ));

    //
    //  Log start message.
    //

    if ( pDpInfo )
    {
        DNSLOG( TOMBSTN, (
            "Checking directory partition %s for expired tombstones\n",
            pDpInfo->pszDpFqdn ));
    }
    else
    {
        DNSLOG( TOMBSTN, (
            "Checking the legacy partition for expired tombstones\n" ));
    }

    Ds_InitializeSearchBlob( &searchBlob );

    //  Search for tombstoned records
    //  JJW: ds.c keeps stats with DS_SEARCH_START - should do that here?

    if ( startTombstoneSearch( &searchBlob, pDpInfo ) != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //  Iterate through the entries in the paged LDAP search result.

    while ( 1 )
    {
        PLDAP_BERVAL *  ppvals = NULL;
        PDS_RECORD      pdsRecord = NULL;
        BOOL            isTombstoned = FALSE;
        ULARGE_INTEGER  tombstoneTime = { 0 };
        PWSTR           wdn = NULL;

        //  Get the next search result.

        status = Ds_GetNextMessageInSearch( &searchBlob );
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( status != LDAP_CONSTRAINT_VIOLATION );
            break;
        }

        //  Retrieve the DN of the result. This is mostly for logging
        //  but it does provide a sanity test on the record.

        wdn = ldap_get_dn( pServerLdap, searchBlob.pNodeMessage );
        DNS_DEBUG( TOMBSTONE, (
            "%s: found tombstoned entry %S\n",
            fn, wdn ? wdn : LDAP_TEXT( "NULL-DN" ) ));
        if ( !wdn || *wdn == 0 )
        {
            DNS_DEBUG( TOMBSTONE, (
                "%s: skipping tombstone search result (no dn)\n", fn ));
            if ( wdn )
                ldap_memfree( wdn ); //  dn can be empty but not NULL
            continue; //  Skip this result
        }

        //  Read the DNS data blob out of the record. Check for the
        //  correct record type and copy the tombstone time if this
        //  is in fact a tombstoned record.
        //  If the tombstoned record has no DNS data blob the record
        //  has gotten screwy somehow so delete it.

        ppvals = ldap_get_values_len(
            pServerLdap,
            searchBlob.pNodeMessage,
            DSATTR_DNSRECORD );
        if ( ppvals && ppvals[ 0 ] )
        {
            pdsRecord = ( PDS_RECORD )( ppvals[0]->bv_val );
            if ( pdsRecord->wType == DNSDS_TOMBSTONE_TYPE )
            {
                isTombstoned = TRUE;
                memcpy(
                    &tombstoneTime,
                    &pdsRecord->Data,
                    sizeof( tombstoneTime ) );
            }
            else
            {
                DNS_DEBUG( TOMBSTONE, (
                    "%s: record found but record type is %d\n",
                    fn, ( int ) pdsRecord->wType ));
            }
        }
        else
        {
            DNS_DEBUG( TOMBSTONE, (
                "%s: deleting bogus tombstone %S\n", fn, wdn ));

            deleteStatus = ldap_delete_s( pServerLdap, wdn );

            if ( deleteStatus != LDAP_SUCCESS )
            {
                DNS_DEBUG( TOMBSTONE, (
                    "%s: error <%lu> deleting bogus tombstone %S\n",
                    fn, deleteStatus, wdn ));
            }
            else
            {
                ++deleteCount;
            }
        }
        ldap_value_free_len( ppvals );
        ppvals = NULL;

        //  If the record is tombstoned, see if the tombstone has expired.
        //  Delete the record if the tombstone is expired.

        if ( isTombstoned )
        {
            ULARGE_INTEGER      now;

            GetSystemTimeAsFileTime( ( PFILETIME ) &now );

            DNS_DEBUG( TOMBSTONE, (
                "%s: tombstone age is %I64u (max %lu) seconds\n",
                fn, ( now.QuadPart - tombstoneTime.QuadPart ) / 10000000,
                ( ULONG ) SrvCfg_dwDsTombstoneInterval ));

            if ( now.QuadPart - tombstoneTime.QuadPart >
                 ( ULONGLONG )
                 SECONDS_IN_FILETIME( SrvCfg_dwDsTombstoneInterval ) )
            {
                DNS_DEBUG( TOMBSTONE, (
                    "%s: deleting tombstone %S\n", fn, wdn ));

                deleteStatus = ldap_delete_s( pServerLdap, wdn );

                if ( deleteStatus != LDAP_SUCCESS )
                {
                    DNS_DEBUG( TOMBSTONE, (
                        "%s: error <%lu> deleting tombstone %S\n",
                        fn, deleteStatus, wdn ));
                }
                else
                {
                    ++deleteCount;
                }
            }
        }

        ldap_memfree( wdn );
        wdn = NULL;
    }

    Cleanup:

    Ds_CleanupSearchBlob( &searchBlob );

    //
    //  Log start message.
    //

    if ( pDpInfo )
    {
        DNSLOG( TOMBSTN, (
            "Deleted %d expired tombstones from directory partition %s\n",
            deleteCount,
            pDpInfo->pszDpFqdn ));
    }
    else
    {
        DNSLOG( TOMBSTN, (
            "Deleted %d expired tombstones from the legacy partition\n",
            deleteCount ));
    }

    return status;
}   //  checkPartitionForTombstones



VOID
refreshZoneSerials(
    VOID
    )
/*++

Routine Description:

    This function attempts to do a DS write of the ..Serial record for the
    local DNS server for all DS-integrated primary zones present on this
    server.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PZONE_INFO      pzone = NULL;

    while ( pzone = Zone_ListGetNextZone( pzone ) )
    {
        //
        //  This operation is only for DS-integrated primary zones.
        //
        
        if ( !IS_ZONE_DSINTEGRATED( pzone ) || !IS_ZONE_PRIMARY( pzone ) )
        {
            continue;
        }

        DNS_DEBUG( DS, ( "Refreshing DS serial for zone %s\n", pzone->pszZoneName ));

        Ds_CheckForAndForceSerialWrite( pzone, ZONE_SERIAL_SYNC_READ, TRUE );
    }
}



DNS_STATUS
Tombstone_Thread(
    IN      PVOID           pvDummy
    )
/*++

Routine Description:

    Main tombstone processing. This thread will fire at regular intervals
    to check for tombstoned records that have expired. Any expired records
    can be deleted from the DS.

Arguments:

    Unreferenced.

Return Value:

    Status in win32 error space

--*/
{
    DBG_FN( "Tombstone_Thread" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_DP_INFO    pdp = NULL;

    DNS_DEBUG( TOMBSTONE, ( "%s: start at %d (ldap=%p)\n", fn, DNS_TIME(), pServerLdap ));

    if ( InterlockedIncrement( &g_TombstoneThreadRunning ) != 1 )
    {
        DNS_DEBUG( TOMBSTONE, ( "%s: thread already running\n", fn ));
        goto Done;
    }

    //
    //  Refresh zone serial numbers so that they are not tombstoned. This
    //  prevent serial number rollback. If ..Serial records are tombstoned
    //  that hold the highest zone serial numbers when the DC is rebooted
    //  serial numbers will roll back to a previous value.
    //
    
    refreshZoneSerials();

    //
    //  Delete old tombstones in the legacy partition.
    //

    checkPartitionForTombstones( NULL );

    //
    //  Delete old tombstones in each directory partition.
    //

    while ( ( pdp = Dp_GetNext( pdp ) ) != NULL )
    {
        checkPartitionForTombstones( pdp );
    }

    DNS_DEBUG( TOMBSTONE, ( "%s: exit at %d\n", fn, DNS_TIME() ));

    Done:
    
    Thread_Close( FALSE );

    InterlockedDecrement( &g_TombstoneThreadRunning );

    return status;
}   //  Tombstone_Thread



DNS_STATUS
Tombstone_Trigger(
    VOID
    )
/*++

Routine Description:

    Main entry point for tombstone search and destroy. If more than
    24 hours have elapsed since the last time a tombstone thread was
    kicked off, then kick off another thread.

Arguments:

    Unreferenced.

Return Value:

    Status in win32 error space

--*/
{
    DBG_FN( "Tombstone_Trigger" )

    static DWORD lastTriggerTime = 0;
    #if 0


    #else

    static WORD lastRunHour = -1;
    SYSTEMTIME localTime;
    BOOL runNow = FALSE;
    WORD start_hour = 2;
    WORD recur_hour = 0;

    #endif

    //
    //  We do not do any tombstone searching if the DS is not available.
    //

    if ( !SrvCfg_fDsAvailable )
    {
        DNS_DEBUG( TOMBSTONE, (
            "%s: DS unavailable\n", fn ));
        return ERROR_SUCCESS;
    }

    if ( !pServerLdap )
    {
        DNS_DEBUG( TOMBSTONE, (
            "%s: no server LDAP session\n", fn ));
        return ERROR_SUCCESS;
    }

    #if 0

    //
    //  Create tombstone thread if proper time has passed since last run.
    //

    if ( !lastTriggerTime )
    {
        lastTriggerTime = DNS_TIME();
    }
    else if ( DNS_TIME() - lastTriggerTime > TRIGGER_INTERVAL &&
              g_TombstoneThreadRunning == 0 )
    {
        if ( Thread_Create(
                "Tombstone_Thread",
                Tombstone_Thread,
                NULL,
                0 ) )
        {
            DNS_DEBUG( TOMBSTONE, (
                "Tombstone_Trigger: dispatched tombstone thread\n" ));
            lastTriggerTime = DNS_TIME();
        }
        else
        {
            DNS_PRINT(( "ERROR:  Failed to create tombstone thread!\n" ));
        }
    }
    else
    {
        DNS_DEBUG( TOMBSTONE, (
            "Tombstone_Trigger: no thread dispatch at %d (interval %d)\n",
            DNS_TIME(), TRIGGER_INTERVAL ));
    }

    #else

    //
    //  Decide if this is the right time to kick off a tombstone thread.
    //    for example:
    //    start_hour=2, recur_hour=0: run only at 2:00 every day
    //    start_hour=5, recur_hour=8: run at 5:00, 13:00, 21:00 every day
    //

    GetLocalTime( &localTime );
    if ( lastRunHour != localTime.wHour )
    {
        if ( recur_hour == 0 )
        {
            runNow = localTime.wHour == start_hour;
        }
        else if ( localTime.wHour >= start_hour )
        {
            runNow = ( localTime.wHour - start_hour ) % recur_hour == 0;
        }
    }

    //
    //  Create tombstone thread if the time is right.
    //

    if ( runNow )
    {
        if ( Thread_Create(
                "TombstoneThread",
                Tombstone_Thread,
                NULL,
                0 ) )
        {
            DNS_DEBUG( TOMBSTONE, (
                "%s: dispatched tombstone thread\n", fn ));
            lastRunHour = localTime.wHour;
        }
        else
        {
            DNS_PRINT((
                "%s: ERROR - Failed to create tombstone thread!\n", fn ));
        }
    }
    else
    {
        DNS_DEBUG( TOMBSTONE, (
            "%s: no thread dispatch for %d:00 "
            "(start %d:00 every %d hours)\n",
            fn,
            ( int ) localTime.wHour,
            ( int ) start_hour,
            ( int ) recur_hour ));
    }

    #endif

    return ERROR_SUCCESS;
}   //  Tombstone_Trigger



DNS_STATUS
Tombstone_Initialize(
    VOID
    )
/*++

Routine Description:

    Initializes the tombstone searching system

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    return ERROR_SUCCESS;
}



VOID
Tombstone_Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleanup tombstone searching system

Arguments:

    None

Return Value:

    None

--*/
{
    return;
}


//
//   End of tombston.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\tree.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    tree.c

Abstract:

    Domain Name System (DNS) Server

    Tree routines.

    DNS server's database will be stored in the form of an Tree,
    matching the global domain space.  I.e. each level of label in a
    domain name will correspond to a level in the Tree.

Author:

    Jim Gilroy (jamesg)     March 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Child list locking
//
//  Currently just hold database lock.
//
//  DEVNOTE: need node locking, or global read\write locking
//

#define LOCK_CHILD_LIST( pParent )        Dbase_LockDatabase()
#define UNLOCK_CHILD_LIST( pParent )      Dbase_UnlockDatabase()


//
//  Masks for quick compare labels of less than a DWORD in size
//      - & these with label to mask out bytes beyond label length
//

DWORD QuickCompareMask[] =
{
    0,
    0xff000000,
    0xffff0000,
    0xffffff00
};


//
//  At 255 references -- lock node down permanently
//

#define NO_DELETE_REF_COUNT     (0xff)


//
//  Case preservation
//
//  Probably best to just ALWAYS have this on.
//  It doesn't really cost much, and elminates unnecessary option.
//

#define SrvCfg_fCasePreservation    (TRUE)


//
//  Length of a node
//

#define DB_NODE_LENGTH( _cchLabelLength )                                   \
    ( ( DB_NODE_FIXED_LENGTH ) + ( _cchLabelLength ) +                      \
        ( ( SrvCfg_fCasePreservation ) ? ( _cchLabelLength ) + 1 : 0 ) )


//
//  Private protos
//

DWORD
makeQuickCompareDwordLabel(
    IN      PCHAR   pchLabel,
    IN      DWORD   cchLabel
    );

#define DOWNCASED_NODE_NAME( pnode )  ( NTree_GetDowncasedLabel( pnode ) )


#ifndef DBG
#define NTreeVerifyNode( pNode )    (TRUE)
#endif

#ifndef DBG
#define NTree_VerifyNode( pNode )    (TRUE)
#endif

BOOL
NTree_VerifyNodeInSiblingList(
    IN      PDB_NODE       pNode
    );



PDB_NODE
NTree_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize Tree.

    Initializes tree including creation of root node.

Arguments:

    None.

Return Value:

    Ptr to root if successful.
    NULL on error.

--*/
{
    PDB_NODE    pnodeRoot;

    pnodeRoot = NTree_CreateNode( NULL, NULL, 0, 0 );

    //  tree root always zone root
    //      - setting flag makes search terminations on ZONE_ROOT flag safe

    if ( pnodeRoot )
    {
        SET_ZONE_ROOT( pnodeRoot );
    }

    return pnodeRoot;
}



PDB_NODE
NTree_CreateNode(
    IN      PCHAR       pchLabel,
    IN      PCHAR       pchDownLabel,
    IN      DWORD       cchLabelLength,
    IN      DWORD       dwMemTag            //  zero for generic node
    )
/*++

Routine Description:

    Create Tree node.

    This is essentially an allocate and initialize function.

    It handles initialization of
        - name
        - corresponding quick comparision
        - parent link
        - parent's zone
        - parent's child count

    Note, this does NOT INSERT node into the sibling list.

Arguments:

    pchLabel -- label

    pchDownLabel -- downcased label

    cchLabelLength -- label length

    dwMemTag -- mem tag for new node or zero for generic

Return Value:

    Pointer to new node.

--*/
{
    PDB_NODE    pNode;
    DWORD       length;

    if ( cchLabelLength > DNS_MAX_LABEL_LENGTH )
    {
        ASSERT( FALSE );
        return NULL;
    }

    DNS_DEBUG( DATABASE, (
        "NTree_CreateNode( %.*s, down=%s, tag=%d )\n",
        cchLabelLength,
        pchLabel,
        pchDownLabel,
        dwMemTag ));

    //
    //  allocate node -- use standard allocator
    //

    length = DB_NODE_LENGTH( cchLabelLength );

    pNode = ALLOC_TAGHEAP( length, dwMemTag ? dwMemTag : MEMTAG_NODE );
    IF_NOMEM( !pNode )
    {
        DNS_DEBUG( DATABASE, (
            "Unable to allocate new node for %.*s\n",
            cchLabelLength,
            pchLabel ));
        return NULL;
    }

    STAT_INC( DbaseStats.NodeUsed );
    STAT_INC( DbaseStats.NodeInUse );
    STAT_ADD( DbaseStats.NodeMemory, length );
    PERF_ADD( pcDatabaseNodeMemory , length );       // PerfMon hook

    //
    //  clear all fixed fields
    //

    RtlZeroMemory(
        pNode,
        DB_NODE_FIXED_LENGTH );

    //
    //  write node name
    //      - must NULL terminate so shorter name compares correctly
    //        e.g.  so on compare jamesg < jamesg1
    //

    RtlCopyMemory(
        pNode->szLabel,
        pchLabel,
        cchLabelLength );

    pNode->szLabel[ cchLabelLength ] = 0;
    pNode->cchLabelLength = (UCHAR) cchLabelLength;

    if ( SrvCfg_fCasePreservation )
    {
        PCHAR   pdown = DOWNCASED_NODE_NAME(pNode);

        //  note, i'm not storing DownLabelLength
        //      assuming that it will be the same as original

        RtlCopyMemory(
            pdown,
            pchDownLabel,
            cchLabelLength );

        pdown[ cchLabelLength ] = 0;
    }
#if 0
    //  can't do this until have debug routine that handles node
    //  without associate database context, esp. parents

    IF_DEBUG( DATABASE2 )
    {
        Dbg_DbaseNode(
            "New tree node:\n",
            pNode );
    }
#endif
    DNS_DEBUG( DATABASE2, (
        "Created tree node at 0x%p:\n"
        "    Label        = %.*s\n"
        "    Length       = %d\n",
        pNode,
        cchLabelLength,
        pchLabel,
        cchLabelLength ));

    return pNode;
}



PDB_NODE
NTree_CopyNode(
    IN      PDB_NODE    pNode
    )
/*++

Routine Description:

    Copy a node.

    This is useful in creating temporary nodes for secure update.
    This does NOT correct or fix up node's links in tree.

Arguments:

    pNode   -- node to copy

Return Value:

    Pointer to new node.

--*/
{
    PDB_NODE    pnodeCopy;
    DWORD       length;

    //
    //  allocate node -- use standard allocator
    //

    length = DB_NODE_LENGTH( pNode->cchLabelLength );

    pnodeCopy = ALLOC_TAGHEAP( length, MEMTAG_NODE_COPY );
    IF_NOMEM( !pnodeCopy )
    {
        DNS_DEBUG( DATABASE, (
            "ERROR:  Unable to allocate copy of node %p\n",
            pNode ));
        return NULL;
    }

    STAT_INC( DbaseStats.NodeUsed );
    STAT_INC( DbaseStats.NodeInUse );
    STAT_ADD( DbaseStats.NodeMemory, length );
    PERF_ADD( pcDatabaseNodeMemory , length );

    //
    //  copy node data
    //

    RtlCopyMemory(
        pnodeCopy,
        pNode,
        length );

    //
    //  clear "inappropriate" flags
    //

    pnodeCopy->dwNodeFlags = ( pNode->dwNodeFlags & NODE_FLAGS_SAVED_ON_COPY );

    DNS_DEBUG( DATABASE2, (
        "Created tree node copy at 0x%p:\n",
        pnodeCopy ));

    return pnodeCopy;
}



VOID
NTree_FreeNode(
    IN OUT  PDB_NODE    pNode
    )
/*++

Routine Description:

    Free a tree node.

    This is in function as it used both in normal NTree_RemoveNode()
    and in hard subtree delete.

Arguments:

    pNode - node to delete

Return Value:

    None.

--*/
{
    DWORD length;

    //
    //  verify NOT in timeout system
    //      - if in system, just cut node loose, let system clean it up
    //
    //  DEVNOTE: cleanup of nodes in timeout system
    //      need to locate timeout system reference and delete
    //      rogue node is possibly lame
    //

    if ( IS_TIMEOUT_NODE(pNode) )
    {
        //
        //  should only be doing free on nodes in timeout system from
        //      timeout thread -- i.e. delayed tree free
        //
        //  should not have free on node already cut from list
        //  except when timeout thread fires, and it will clear the
        //      TIMEOUT flag in NTree_RemoveNode()

        if ( !Timeout_ClearNodeTimeout(pNode) )
        {
            IF_DEBUG( DATABASE )
            {
                Dbg_DbaseNode(
                    "WARNING:  Unable to free node from timeout system.\n",
                    pNode );
            }
            ASSERT( FALSE );
            //STAT_INC( DebugStats.NodeDeleteFailure );
            return;
        }

        DNS_DEBUG( DATABASE, (
            "Successfully removed node %p (l=%s) from timeout system.\n"
            "    Now continue with standard node free.\n",
            pNode,
            pNode->szLabel ));
    }

    length = DB_NODE_LENGTH( pNode->cchLabelLength );

    //  note:  may be copy node or regular node so can't tag the free

    FREE_TAGHEAP( pNode, length, 0 );

    STAT_INC( DbaseStats.NodeReturn );
    STAT_DEC( DbaseStats.NodeInUse );
    STAT_SUB( DbaseStats.NodeMemory, length );
    PERF_SUB( pcDatabaseNodeMemory , length );
}



BOOL
NTree_RemoveNode(
    IN OUT  PDB_NODE    pNode
    )
/*++

Routine Description:

    Remove a node from Tree.

    This deletes the node from the tree ONLY if it is legal:
        - no children
        - no RR list
        - no reference count
        - no recent access

    Caller MUST HOLD lock on access to this node AND to child list
    of parent.  In current implementation this means database lock.

    In current implementation this is ONLY called by the timeout
    thread, to cleanup node.

Arguments:

    pNode - node to delete

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PDB_NODE    pparent;

    ASSERT( pNode != NULL );
    ASSERT( !IS_ON_FREE_LIST(pNode) );

    //
    //  lock
    //
    //  Must hold both database and RR list locks during a delete, because
    //  node access flag may be SET under either:
    //      - Dbase lock, when doing lookup
    //      - Node data (RR list) lock, when doing indirect access
    //
    //  DEVNOTE: zone\tree specific locking for deletes
    //      should pass zone\dbase\lock
    //

    Dbase_LockDatabase();

#if DBG
    NTree_VerifyNode( pNode );
#endif

    //
    //  verify - NO children
    //

    if ( pNode->pChildren != NULL )
    {
        ASSERT( pNode->cChildren );
        DNS_DEBUG( DATABASE, (
            "Fail delete (has children) of node at %p.\n", pNode ));
        goto NoDelete;
    }

    //
    //  TYPE_SPECIFIC:
    //      - verify NO resource records
    //      - verify NO reference count
    //      - NOT recently accessed
    //

    if ( pNode->pRRList && !IS_NOEXIST_NODE( pNode ) ||
        pNode->cReferenceCount  ||
        IS_NODE_RECENTLY_ACCESSED( pNode ) ||
        IS_NODE_NO_DELETE( pNode ) )
    {
        DNS_DEBUG( DATABASE, (
            "Fail delete of node at %p.\n", pNode ));
        goto NoDelete;
    }

    //  database root should have been marked no-delete

    pparent = pNode->pParent;
    ASSERT( pparent );

    //
    //  cut node from sibling list
    //

    NTree_CutNode( pNode );

    //
    //  if removing last child node, then make sure parent is put into timeout system
    //
    //  DEVNOTE: we could have a bit more subtlety here and ignore for zone nodes with
    //      data
    //

    if ( pparent && !pparent->pChildren && !IS_TIMEOUT_NODE( pparent ) )
    {
        Timeout_SetTimeoutOnNodeEx(
            pparent,
            0,
            TIMEOUT_PARENT | TIMEOUT_NODE_LOCKED );
    }

    //
    //  delete node
    //      - must clear timeout flag, so NTree_FreeNode() will not
    //      check that we're in timeout system -- which we already know
    //

    Dbase_UnlockDatabase();

    DNS_DEBUG( DATABASE, (
        "Deleted tree node at 0x%p:\n"
        "    Label  = %s\n"
        "    Length = %d\n",
        pNode,
        pNode->szLabel,
        pNode->cchLabelLength ));

    CLEAR_TIMEOUT_NODE( pNode );
    NTree_FreeNode( pNode );
    return TRUE;

NoDelete:

    //  no delete -- unlock database

    Dbase_UnlockDatabase();
    return FALSE;
}



VOID
NTree_ReferenceNode(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Increment reference count of node in database.

Arguments:

    pNode -- ptr to node

Return Value:

    None

--*/
{
    ASSERT( !IS_ON_FREE_LIST(pNode) );

    if ( pNode->cReferenceCount == NO_DELETE_REF_COUNT )
    {
        return;
    }

    Dbase_LockDatabase();
    pNode->cReferenceCount++;
    Dbase_UnlockDatabase();
}



BOOL
FASTCALL
NTree_DereferenceNode(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Dereference node.

Arguments:

    pNode - node to deref

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    ASSERT( !IS_ON_FREE_LIST(pNode) );

    NTree_VerifyNode( pNode );

    //
    //  dereference
    //
    //  DEVNOTE: currently NOT dereferencing on retail builds
    //  DEVNOTE: hence NEVER timing out referenced nodes
    //
    //  when figure out ref count < 0 bug, then can put back into build
    //

    if ( pNode->cReferenceCount == NO_DELETE_REF_COUNT )
    {
        return TRUE;
    }

    //  error if already at zero

    if ( pNode->cReferenceCount == 0 )
    {
        DnsDebugLock();
        Dbg_NodeName(
            "ERROR:  Dereferencing zero ref count node ", pNode, "\n" );
        ASSERT( FALSE );
        DnsDebugUnlock();

        Dbase_LockDatabase();
        pNode->cReferenceCount = NO_DELETE_REF_COUNT;
        Dbase_UnlockDatabase();
        return TRUE;
    }

    Dbase_LockDatabase();
    pNode->cReferenceCount--;

    //
    //  if removing last reference set access so can NOT be cleaned up
    //  while any reference is outstanding;  this makes sure it is at least
    //  a timeout interval before node is deleted
    //
    //  if last ref on leaf node, then make sure node is in timeout system,
    //

    if ( pNode->cReferenceCount == 0 )
    {
        SET_NODE_ACCESSED(pNode);
        Dbase_UnlockDatabase();
        if ( !pNode->pChildren && !IS_TIMEOUT_NODE(pNode) )
        {
            Timeout_SetTimeoutOnNodeEx(
                pNode,
                0,
                TIMEOUT_REFERENCE | TIMEOUT_NODE_LOCKED );
        }
    }
    else
    {
        Dbase_UnlockDatabase();
    }

    DNS_DEBUG( DATABASE, (
        "Dereferenced node %p (label=%s), ref count now = %d\n",
        pNode,
        pNode->szLabel,
        pNode->cReferenceCount ));

    return TRUE;
}



#if DBG
BOOL
NTree_VerifyNode(
    IN      PDB_NODE       pNode
    )
/*++

Routine Description:

    Verify valid tree node.

Arguments:

    pNode - node to verify

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PDB_RECORD  pRR;

    ASSERT( pNode != NULL );
    ASSERT( !IS_ON_FREE_LIST(pNode) );

    //
    //  verify this node's child list
    //

    IF_DEBUG( DATABASE2 )
    {
        ASSERT( NTree_VerifyChildList( pNode, NULL ) );
    }

    //
    //  verify this node's sibling list
    //

#if 0
    //  this just wastes cycles -- in general we've done the parent on the way in

    if ( pNode->pParent )
    {
        IF_DEBUG( DATABASE2 )
        {
            ASSERT( NTree_VerifyChildList( pNode->pParent, pNode ) );
        }
    }
#endif

    //
    //  verify RR list
    //      - this just AVs if RR list is busted
    //

    if ( !IS_NOEXIST_NODE(pNode) )
    {
        pRR = FIRST_RR( pNode );

        while ( pRR != NULL )
        {
            pRR = pRR->pRRNext;
        }
    }
    return TRUE;
}
#endif



VOID
NTree_WriteDerivedStats(
    VOID
    )
/*++

Routine Description:

    Write derived statistics.

    Calculate stats dervived from basic record counters.
    This routine is called prior to stats dump.

    Caller MUST hold stats lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
}



//
//  Sibling list architecture
//
//  The sibling list is implemented as a balanced B-tree, with dynamically
//  added hash "nodes" extending this to an N-tree when necessary to limit
//  B-tree size and improve performance.
//
//  Design goals:
//
//  1) not expensive for terminal or single nodes;  in additional to
//  all the terminal nodes, probably half the cached nodes will have
//  a single child (ex. www.mycompany.com);  any method to handle
//  the large zones, must also handle this common case inexpensively
//
//  2) able to handle LARGE zones;  authoritative domains for larger
//  organizations can obviously run above 100,000 hosts;  then if we
//  wish to be a root server we must be able to handle the huge top level
//  domains -- most notably the "com" domain
//
//  3) able to handle large zones, dynamically;  with WINS integration
//  and dynamic DNS we can't assume we can determine load at startup;
//  must be able to handle a large number of nodes DYNAMICALLY entering
//  sibling list and still do efficient lookup
//
//  4) be able to determine large zones dynamically;  with the use of
//  the WEB it will be quite common for SPs and even forwarding servers
//  at larger organizations to build up large "cached" domains;  most
//  obvious is the monstrous "com" domain, but other domains may have
//  similar problems in other organizations or countries and new domain
//  structures may evolve
//
//
//  Implementation details:
//
//  - Sibling list defaults to B-tree.
//  - When B-trees reach a given size, a simple alphabetic hash is added
//    for the next character in the label.  Each bucket in the hash may point
//    to a root of a B-tree for nodes in that bucket.  The nodes of the
//    existing B-tree are then reloaded to spread across these buckets.
//  - Hash expansion is limited to four levels (first four characters of
//    label name).  After that B-trees may grow without bound.
//  - Once created hash "nodes" are not deleted.  Except at parent node
//    delete (hence no nodes in sibling list at all).
//  - The B-trees are kept balanced only when loading database or re-loading
//    nodes into a new hash's buckets.
//
//
//  Why not just a B-Tree?
//  The main reason is that some B-trees would still be very big.  This
//  has two disadvantages:
//  1)  You still touch log(n) nodes which for the largest zones (ex. com)
//      can still run 15-20 levels, and still allows significant chance
//      of unnecessary page faults.
//  2)  More important to make sure you stay reasonably balanced to keep
//      your tree close the the optimium level.  Even limit rebalancing
//      to only during load, this will be a major time ssync, and may
//      make top level domains unloadable.
//
//  Why not always a hash?
//  Essentially because of design goal #1 above. The hash table is much
//  bigger than a node.  We do not want to add this overhead for the many
//  domains which do not need it.
//
//  Why dynamic hashing?
//  Essentially design goal #4 -- big cached domains.  We want efficient
//  lookup for larger cached domains as well as large authoritative zones.
//
//  Why multi-level hash?
//  Same reasons as hashing at all.  Want to restrict B-trees to managable
//  size.  Yet don't want to layout large hash as (since in-order alphabetic)
//  we'd either have to know how the names break down in advance, or we'd
//  waste a lot of space on unused buckets (ex. the zb, zc, zd buckets).
//  Multi-level hash lets amount of hashing adapt dynamically to the names
//  at the domain, putting the required level of hashing at just the right
//  places to keep the B-trees small.
//  Example:
//      Entire z?.com B-tree in one bucket of top level com domain hash.
//      But might even have hash at mic?.com.  Yet no third level hash
//      at mh?.com.
//


//
//  Rebalancing B-Trees
//
//  Global flag indicates that we strictly balance B-trees.  This is
//  sensible during initial load (likely in-order), and when replace
//  B-tree with hash, initializing a set of new B-trees.
//

INT gcFullRebalance = 0;

//
//  Rebalance array -- on stack so make big enough that
//      never overflow even if our count gets messed up
//

#define DEFAULT_REBALANCE_ARRAY_LEN  (500)


INT
NTree_HashTableIndexEx(
    IN      PDB_NODE        pNode,
    IN      PCHAR           pszName,
    IN      UCHAR           cLevel
    );

#define NTree_HashTableIndex( pNode, cLevel ) \
        NTree_HashTableIndexEx( (pNode), NULL, (cLevel) )

PDB_NODE
FASTCALL
NTree_NextHashedNode(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pNode   OPTIONAL
    );

VOID
NTree_CreateHashAtNode(
    IN      PDB_NODE        pNode
    );

INT
NTree_AddNodeInHashBucket(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pNode
    );

VOID
NTree_SetNodeAsHashBucketRoot(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pNode
    );

#if DBG
VOID
Dbg_SiblingHash(
    IN      PSIB_HASH_TABLE pHash
    );
#else
#define Dbg_SiblingHash(pHash)
#endif



//
//  Private tree utils
//

DWORD
makeQuickCompareDwordLabel(
    IN      PCHAR           pchLabel,
    IN      DWORD           cchLabel
    )
/*++

Routine Description:

    Create quick comparison DWORD, from first four bytes of label.

        - downcase
        - byte flip so first label byte in high byte
        - NULL terminate if less than three characters

Arguments:

    pchLabel -- ptr to label

    cchLabel -- count of bytes in label

Return Value:

    DWORD with first four bytes of label downcased.

--*/
{
    DWORD   dwQuickLabel = 0;
    DWORD   i;
    CHAR    ch;

    for ( i=0; i<4; i++ )
    {
        dwQuickLabel <<= 8;

        if ( i < cchLabel )
        {
            ch = *pchLabel++;
            dwQuickLabel += tolower( ch );
        }
    }
    return dwQuickLabel;
}



PCHAR
NTree_GetDowncasedLabel(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Return downcased label for node.

    This simply hides the issue of where downcased label is stored.

Arguments:

    pNode -- ptr to node

Return Value:

    Ptr to downcased label.

--*/
{
    if ( !SrvCfg_fCasePreservation )
    {
        return pNode->szLabel;
    }
    else
    {
        return pNode->szLabel + pNode->cchLabelLength + 1;
    }
}



//
//  B-Tree Rebalancing utilities
//

VOID
btreeReadToArray(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE *      pNodeArray,
    IN      DWORD           dwCount
    )
/*++

Routine Description:

    Read nodes into array.

Arguments:

    pNodeArray - array to hold nodes

    pRootNode - root node of existing B-tree

    dwCount - count of nodes in B-tree

Return Value:

    TRUE if successful.
    FALSE on allocation error.

--*/
{
    DWORD           index = 0;
    PDB_NODE        ptemp;

    //
    //  read existing B-tree into array
    //      - sever root node's uplink to hash (if any) to limit traversal
    //      to sibling nodes in other hash buckets;  (we're only traversing
    //      sibling list in this node's B-tree)
    //      - NULL terminate ptr array;  caller can use this instead of count
    //      to protect against bogus counts
    //

    pNode->pSibUp = NULL;

    while ( ptemp = pNode->pSibLeft )
    {
        pNode = ptemp;
    }
    while ( pNode )
    {
        pNodeArray[index++] = pNode;
        pNode = NTree_NextSibling( pNode );
    }
    ASSERT( index == dwCount );
    pNodeArray[index] = NULL;
}



PDB_NODE
btreeRebalanceLeftJustifyPrivate(
    IN      PDB_NODE *      apNodes,
    IN      DWORD           dwCount
    )
/*++

Routine Description:

    Rebalance B-tree.

    This is a recursive function.  At each level it is called to pick the
    subtree root from the array, then attach it to the result of the
    recursive call on the left and right sides of the array.

Arguments:

    apNodes - array of ptrs to domain nodes

    dwCount - array count

Return Value:

    New B-tree root.

--*/
{
    PDB_NODE        proot;
    PDB_NODE        pleft;
    PDB_NODE        pright;
    DWORD           index;
    DWORD           twoToN;

    ASSERT( dwCount != 0 );

    //
    //  do terminal optimizations
    //
    //  instead of drilling down to NULL, this saves the last couple
    //      of recursions, which will acount for 3/4 of the total
    //      function calls in a real scenario
    //

    if ( dwCount <= 3 )
    {
        if ( dwCount == 1 )
        {
            proot = apNodes[0];
            proot->pSibLeft = NULL;
            proot->pSibRight = NULL;
        }
        else if ( dwCount == 2 )
        {
            pleft = apNodes[0];
            proot = apNodes[1];

            proot->pSibLeft = pleft;
            proot->pSibRight = NULL;

            pleft->pSibUp = proot;
            pleft->pSibLeft = NULL;
            pleft->pSibRight = NULL;
        }
        else    // dwCount == 3
        {
            pleft = apNodes[0];
            proot = apNodes[1];
            pright = apNodes[2];

            proot->pSibLeft = pleft;
            proot->pSibRight = pright;

            pleft->pSibUp = proot;
            pleft->pSibLeft = NULL;
            pleft->pSibRight = NULL;

            pright->pSibUp = proot;
            pright->pSibLeft = NULL;
            pright->pSibRight = NULL;
        }
        return proot;
    }

    //
    //  find next lowest 2**N value
    //

    twoToN = 1;
    index = dwCount;
    while ( (index >>= 1) )
    {
        twoToN <<= 1;
    }

    //
    //  find b-tree root index
    //
    //  example (N=3);  8 <= dwCount <= 15
    //      count   index
    //          8       4
    //          9       5
    //         10       6
    //         11       7
    //         12       7
    //         13       7
    //         14       7
    //         15       7
    //

    index = (twoToN >> 1) + (dwCount - twoToN);
    if ( index > twoToN )
    {
        index = twoToN;
    }
    index--;

    //
    //  get root node
    //      - point at parent
    //

    proot = apNodes[index];

    //
    //  balance left side
    //      - nodes in array from 0 to index-1
    //

    ASSERT( index );

    pleft = btreeRebalanceLeftJustifyPrivate(
                apNodes,
                index );
    proot->pSibLeft = pleft;
    pleft->pSibUp = proot;

    //
    //  balance right side
    //      - nodes in array from index+1 to dwCount-1

    index++;
    dwCount -= index;
    ASSERT( dwCount );

    pright = btreeRebalanceLeftJustifyPrivate(
                &apNodes[index],
                dwCount );
    proot->pSibRight = pright;
    pright->pSibUp = proot;

    //
    //  reset root balance
    //

    return proot;
}



VOID
btreeRebalance(
    IN      PDB_NODE        pRootNode,
    IN      DWORD           dwCount
    )
/*++

Routine Description:

    Rebalance B-tree.

Arguments:

    pNodeArray - array to hold nodes

    pRootNode - root node of existing B-tree

    dwCount - count of nodes in B-tree

Return Value:

    TRUE if successful.
    FALSE on allocation error.

--*/
{
    PDB_NODE        arrayNodes[ DEFAULT_REBALANCE_ARRAY_LEN ];
    PDB_NODE *      pnodeArray = arrayNodes;
    PDB_NODE        pnodeUp;
    PDB_NODE *      ppnodeRoot;

    //
    //  verify that have space for rebalance
    //

    if ( dwCount > DEFAULT_REBALANCE_ARRAY_LEN )
    {
        pnodeArray = (PDB_NODE *) ALLOCATE_HEAP( dwCount * sizeof(PDB_NODE) );
        IF_NOMEM( !pnodeArray )
        {
            return;
        }
        ASSERT( FALSE );
    }

    //
    //  save uplink info
    //      - up itself
    //      - addr of ptr in up that points at root
    //

    pnodeUp = pRootNode->pSibUp;

    if ( !pnodeUp )
    {
        ppnodeRoot = & pRootNode->pParent->pChildren;
    }
    else if ( IS_HASH_TABLE(pnodeUp) )
    {
        ppnodeRoot = NULL;
    }
    else if ( pnodeUp->pSibLeft == pRootNode )
    {
        ppnodeRoot = & pnodeUp->pSibLeft;
    }
    else
    {
        ASSERT( pnodeUp->pSibRight == pRootNode );
        ppnodeRoot = & pnodeUp->pSibRight;
    }

    //
    //  read B-tree into array
    //

    btreeReadToArray(
        pRootNode,
        pnodeArray,
        dwCount );

    //
    //  rebalance then reattach
    //

    pRootNode = btreeRebalanceLeftJustifyPrivate(
                    pnodeArray,
                    dwCount );

    if ( ppnodeRoot )
    {
        *ppnodeRoot = pRootNode;
        pRootNode->pSibUp = pnodeUp;
    }
    else    //  up node is hash
    {
        NTree_SetNodeAsHashBucketRoot(
            (PSIB_HASH_TABLE) pnodeUp,
            pRootNode );
    }

    if ( dwCount > DEFAULT_REBALANCE_ARRAY_LEN )
    {
        FREE_HEAP( pnodeArray );
    }
    IF_DEBUG( BTREE2 )
    {
        Dbg_SiblingList(
            "B-tree after rebalance:\n",
            pRootNode );
    }
}



//
//  Hash Table Routines
//

INT
NTree_HashTableIndexEx(
    IN      PDB_NODE        pNode,
    IN      PCHAR           pszName,
    IN      UCHAR           cLevel
    )
/*++

Routine Description:

    Find index to hash table.

Arguments:

    pszName - name, MUST be downcased

    cLevel - hash table level

Return Value:

    Index into hash table.

--*/
{
    PCHAR   pname;
    UCHAR   ch;
    INT     i;

    //  if passing in name, use it

    if ( pszName )
    {
        pname = pszName;
    }

    //  if node, use downcased name for node

    else
    {
        pname = DOWNCASED_NODE_NAME(pNode);
    }

    //  must rule out walking off end of name
    //      since not given name length

    i = 0;
    do
    {
        ch = (UCHAR) pname[i];
        if ( ch == 0 )
        {
            return( 0 );
        }
        i++;
    }
    while ( i <= cLevel );

    return ( INT ) ch;

#if 0
    //
    //  There's a huge problem with hashes that don't completely
    //  discriminate between every character.
    //  Essentially they end up putting several characters together
    //  in a hash bucket making it less simple to discriminate at
    //  the next level in the hash.
    //
    //  Example:
    //      ep
    //      ep-7
    //      ep0-
    //      ep08
    //  at in zero bucket for third character.  Hashing fourth character
    //  is now more complicated (ep-7 is < ep0-, so can't be in '7' bucket).
    //
    //  Now, it is possible to check previous characters against a "standard"
    //  character for their bucket and determine that it was lesser and
    //  hence for all further hashing always goes into zero bucket OR was
    //  greater and hence for all further caching goes into MAX bucket.
    //
    //  The huge disadvantage of this is UTF8.  You must either include all
    //  characters OR you quickly lose hashing as all names are confined to
    //  0 or MAX buckets as you hash down.
    //
    //  So either do a specialized UTF8-expando-hash, or you might as well
    //  use 0-255 hash from the get go.
    //

    DWORD   indexBucket;
    INT     i;

    //
    //  find character to index hash
    //      push through name until reach desired index
    //      - this protects us from end of name problem
    //
    //  DEVNOTE: could eliminate by passing name and namelength
    //      which still requires strlen on lookup name
    //      for any realistic case this loop terminates quickly
    //

    i = 0;
    do
    {
        indexBucket = (UCHAR) pszName[i];
        if ( indexBucket == 0 )
        {
            return( 0 );
        }
        i++;
    }
    while ( i <= cLevel );

    ASSERT( indexBucket > 'Z' || indexBucket < 'A' );

    //
    //  determine hash bucket index for character
    //
    //  note:  obviously there are better hashes, BUT I want to hash
    //      and maintain sorted order for writing back to files and
    //      enumerating nodes to admin tool;  also the secure NAME_ERROR
    //      responses (if implemented) will require knowledge of ordering
    //      withing a zone;
    //      for the main purpose of chopping down the B-tree size simply
    //      using character is good enough, probably within a
    //      factor of two of a perfect hash
    //
    //  Note also that main emphasis is on forward lookup zones.
    //  Reverse lookup nodes will only have 256 children which make
    //  would only be depth 8 tree, and most reverse nodes start with
    //  '1' or '2'.  We hash only to avoid breaking out a multiple hash
    //  depth.
    //
    //  chars   hash bucket
    //  -----   -----------
    //  < 0         0
    //  0 - 9       0 - 9
    //  9< - <a     9
    //  a - z       10 - 35
    //  > z         35
    //

    if ( indexBucket >= 'a' )
    {
        indexBucket -= ('a' - 10);
        if ( indexBucket > LAST_HASH_INDEX )
        {
            indexBucket = LAST_HASH_INDEX;
        }
    }
    else if ( indexBucket >= '0' )
    {
        indexBucket -= '0';
        if ( indexBucket > 9 )
        {
            indexBucket = 9;
        }
    }
    else
    {
        indexBucket = 0;
    }

    ASSERT( indexBucket <= LAST_HASH_INDEX );
    return( (INT)indexBucket );
#endif
}



PDB_NODE
FASTCALL
NTree_NextHashedNode(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pNode   OPTIONAL
    )
/*++

Routine Description:

    Get next sibling of node.

Arguments:

    pHash -- hash containing sibling node

    pNode -- node in sibling list;  if not given, get first node of parent

Return Value:

    None.

--*/
{
    PDB_NODE        ptemp;
    INT             index;

    ASSERT( pHash && IS_HASH_TABLE(pHash) );

    DNS_DEBUG( BTREE2, (
        "NTree_NextHashedNode()\n"
        "    level = %d\n"
        "    current = %s\n",
        pHash->cLevel,
        pNode ? pNode->szLabel : NULL ));

    //
    //  if node given, find its index -- will start at next index
    //  no node, start at 0
    //

    index = 0;
    if ( pNode )
    {
        index = NTree_HashTableIndex( pNode, pHash->cLevel );
        index++;
    }

    //
    //  find hash bucket that contains node(s)
    //

    while ( 1 )
    {
        //  if out of buckets
        //      - check for hashing at next level up and continue
        //      - if out of levels, no more siblings, done

        if ( index > LAST_HASH_INDEX )
        {
            if ( pHash->cLevel == 0 )
            {
                return NULL;
            }
            index = (INT) pHash->iBucketUp + 1;
            ASSERT( pHash->pHashUp );
            ASSERT( pHash->pHashUp->cLevel == pHash->cLevel-1 );
            ASSERT( pHash->pHashUp->aBuckets[index-1] == (PDB_NODE)pHash );
            pHash = pHash->pHashUp;
            continue;
        }

        //  get node (or hash) at hash bucket
        //  if empty bucket, move to next

        ptemp = pHash->aBuckets[index];
        if ( !ptemp )
        {
            index++;
            continue;
        }

        //  hashing at next level down?

        if ( IS_HASH_TABLE(ptemp) )
        {
            ASSERT( ((PSIB_HASH_TABLE)ptemp)->pHashUp == pHash );
            ASSERT( ((PSIB_HASH_TABLE)ptemp)->iBucketUp == index );
            ASSERT( ((PSIB_HASH_TABLE)ptemp)->cLevel == pHash->cLevel+1 );
            pHash = (PSIB_HASH_TABLE)ptemp;
            index = 0;
            continue;
        }

        //  otherwise ptemp is valid B-tree root

        break;
    }

    //
    //  drops here when find bucket with domain node at B-tree top
    //  find leftmost node in B-tree for this bucket
    //

    while ( pNode = ptemp->pSibLeft )
    {
        ptemp = pNode;
    }
    return ptemp;
}



VOID
NTree_CreateHashAtNode(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Replace sibling B-tree with hash.

Arguments:

    pNode -- root of sibling B-tree to be replaced by hash

Return Value:

    None.

--*/
{
    PSIB_HASH_TABLE phashTable;
    PDB_NODE        pnodeParent = pNode->pParent;
    PDB_NODE        pnodeNext;
    PSIB_HASH_TABLE phashUp = (PSIB_HASH_TABLE) pNode->pSibUp;
    INT             index;
    INT             count;          //  count of nodes
    INT             ihash;          //  hash bucket index
    INT             ihashCurrent;   //  index of bucket being filled
    INT             iarray;         //  array of nodes index
    INT             iarrayStart;    //  index of first node in bucket
    INT             bucketCount;    //  num of nodes in bucket
    PDB_NODE        arrayNodes[DEFAULT_REBALANCE_ARRAY_LEN];

    ASSERT( pNode );
    ASSERT( phashUp == NULL || IS_HASH_TABLE(phashUp) );

    DNS_DEBUG( BTREE, (
        "Switching node to hashed sibling list:\n"
        "    parent node label %s\n"
        "    child B-tree node %s\n",
        pnodeParent->szLabel,
        pNode->szLabel ));

    //
    //  create hash table
    //

    phashTable = (PSIB_HASH_TABLE) ALLOC_TAGHEAP_ZERO( sizeof(SIB_HASH_TABLE), MEMTAG_NODEHASH );
    IF_NOMEM( !phashTable )
    {
        DNS_PRINT((
            "ERROR:  Memory allocation failure creating hash table"
            "    at sibling node %s\n",
            pNode->szLabel ));
        return;
    }

    //
    //  init hash table
    //      - set hash flag
    //      - set level
    //      - link to parent or higher level hash
    //      - get count
    //

    SET_HASH_FLAG(phashTable);

    if ( phashUp )
    {
        phashTable->pHashUp = phashUp;
        phashTable->cLevel = phashUp->cLevel + 1;

        ihash = NTree_HashTableIndex( pNode, phashUp->cLevel );

        ASSERT( phashUp->aBuckets[ihash] == pNode );

        phashUp->aBuckets[ihash] = (PDB_NODE)phashTable;
        phashTable->iBucketUp = (UCHAR) ihash;
        count = phashUp->aBucketCount[ihash];
    }
    else
    {
        pnodeParent->pChildren = (PDB_NODE)phashTable;
        count = pnodeParent->cChildren;
    }

    //
    //  build node array from existing b-tree
    //
    //  DEVNOTE: should return count so that if count is off, we're
    //      still ok (other alternative would be to zero ptr to signify end)
    //

    ASSERT( count < DEFAULT_REBALANCE_ARRAY_LEN );
    btreeReadToArray(
        pNode,
        arrayNodes,
        count );

    //
    //  read node array into hash table
    //
    //  find all nodes in each hash bucket, then
    //      - build new B-tree
    //      - link B-tree root to hash table
    //      - set bucket count

    iarray = -1;
    iarrayStart = 0;
    ihash = 0;
    ihashCurrent = 0;

    IF_DEBUG( BTREE2 )
    {
        DWORD i = 0;;
        Dbg_Lock();
        DNS_PRINT((
            "B-tree nodes to hash:\n"
            "    cLevel       = %d\n"
            "    count        = %d\n",
            phashTable->cLevel,
            count ));
        while ( arrayNodes[i] )
        {
            Dbg_DbaseNode( NULL, arrayNodes[i] );
            i++;
        }
        Dbg_Unlock();
    }

    while ( 1 )
    {
        //  get hash index for next node
        //      - if same as previous node, continue

        pnodeNext = arrayNodes[++iarray];

        if ( pnodeNext )
        {
            ihash = NTree_HashTableIndex(
                        pnodeNext,
                        phashTable->cLevel );

            //  DEVNOTE:  when confident this never happens, pullout debug
            //ASSERT( ihash >= ihashCurrent );
            if ( ihash < ihashCurrent )
            {
                DWORD i = 0;;

                Dbg_Lock();
                DNS_PRINT((
                    "ERROR:  broken B-tree ordering!!!\n"
                    "    cLevel       = %d\n"
                    "    count        = %d\n"
                    "    iarray       = %d\n"
                    "    iarrayStart  = %d\n"
                    "    pnode        = %p (l=%s)\n"
                    "    ihash        = %d\n"
                    "    ihashCurrent = %d\n",
                    phashTable->cLevel,
                    count,
                    iarray,
                    iarrayStart,
                    pnodeNext, pnodeNext->szLabel,
                    ihash,
                    ihashCurrent ));

                DnsDbg_Flush();

                while ( arrayNodes[i] )
                {
                    Dbg_DbaseNode( NULL, arrayNodes[i] );
                    i++;
                }
                Dbg_Unlock();

                ASSERT( ihash >= ihashCurrent );
            }

            if ( ihash == ihashCurrent )
            {
                continue;
            }
        }

        //  node is not in same bucket as previous
        //
        //  build B-tree for previous hash bucket
        //      non-zero test required for startup

        bucketCount = iarray - iarrayStart;
        if ( bucketCount > 0 )
        {
            pNode = btreeRebalanceLeftJustifyPrivate(
                        &arrayNodes[iarrayStart],
                        bucketCount );

            phashTable->aBuckets[ ihashCurrent ] = pNode;
            phashTable->aBucketCount[ ihashCurrent ] = (UCHAR)bucketCount;
            pNode->pSibUp = (PDB_NODE) phashTable;
        }

        //  reset to build next bucket

        if ( pnodeNext )
        {
            iarrayStart = iarray;
            ihashCurrent = ihash;
            continue;
        }
        break;
    }

    IF_DEBUG( BTREE )
    {
        DNS_PRINT(( "New hash table replacing overflowing B-tree:\n" ));
        Dbg_SiblingHash( phashTable );
    }
}



INT
NTree_AddNodeInHashBucket(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Add node in hash bucket.
    This keeps count of nodes in buckets, and opens new hash
    when necessary.

Arguments:

    pHash -- hash containing sibling node

    pNode -- node in sibling list under hash

Return Value:

    TRUE if node added in hash bucket without incident.
    FALSE if adding node required new secondary hash.

--*/
{
    INT index;

    ASSERT( IS_HASH_TABLE(pHash) );
    ASSERT( !IS_HASH_TABLE(pNode) );

    //
    //  track nodes in each hash bucket
    //      - break out new secondary hashes as necessary
    //
    //  note:  tracking counts even in last hash bucket, so that we can
    //      easily rebalance them during load
    //

    index = NTree_HashTableIndex(
                pNode,
                pHash->cLevel
                );
    pHash->aBucketCount[index]++;

    ASSERT( pHash->cLevel < 63 );

    //
    //  note:  may be desirable to use different (higher) hash limit for
    //      these interior hashes to avoid overhead
    //
    //  zero level hash works well as decent distribution across characters
    //  however interior characters distribute much less effectively
    //  because of "vowel problem" (ex. no names start with mb)
    //

    if ( pHash->aBucketCount[index] >= HASH_BUCKET_MAX0 )
    {
        ASSERT( pHash->aBuckets[index] );
        ASSERT( !IS_HASH_TABLE(pHash->aBuckets[index]) );
        NTree_CreateHashAtNode( pHash->aBuckets[index] );
        return FALSE;
    }

    return TRUE;
}



VOID
NTree_DeleteNodeInHashBucket(
    IN      PDB_NODE        pNodeUp,
    IN      PDB_NODE        pNodeCut,
    IN      PDB_NODE        pNodeReplace
    )
/*++

Routine Description:

    Remove node from hash bucket.

    This is called after node has been removed from B-tree,
    and we only need to update hash count and possibly bucket root.

Arguments:

    pNodeUp -- node above cut node in b-tree (may be hash)

    pNodeCut -- node being cut from tree

    pNodeReplace -- node replacing node being cut (may be NULL)

Return Value:

    None

--*/
{
    PSIB_HASH_TABLE phash = (PSIB_HASH_TABLE)pNodeUp;
    INT index;

    ASSERT( pNodeUp );
    ASSERT( !IS_HASH_TABLE(pNodeCut) );
    ASSERT( !pNodeReplace || !IS_HASH_TABLE(pNodeReplace) );

    //
    //  find hash node and decrement appropriate bucket count
    //

    while ( !IS_HASH_TABLE(phash) )
    {
        phash = (PSIB_HASH_TABLE) ((PDB_NODE)phash)->pSibUp;
    }
    index = NTree_HashTableIndex(
                pNodeCut,
                phash->cLevel );

    phash->aBucketCount[index]--;

    //
    //  if cutting old hash bucket root, then replace
    //

    if ( phash->aBuckets[index] == pNodeCut )
    {
        ASSERT( phash == (PSIB_HASH_TABLE)pNodeUp );
        phash->aBuckets[index] = pNodeReplace;
    }
    ELSE_ASSERT( phash != (PSIB_HASH_TABLE)pNodeUp
        && phash->aBucketCount[index] > 0 );
}



VOID
NTree_SetNodeAsHashBucketRoot(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Set node as hash bucket's B-tree root.

Arguments:

    pHash -- hash containing sibling node

    pNode -- node in sibling list to be bucket's B-tree root

Return Value:

    None

--*/
{
    INT index;

    ASSERT( IS_HASH_TABLE(pHash) );
    ASSERT( !IS_HASH_TABLE(pNode) );

    index = NTree_HashTableIndex(
                pNode,
                pHash->cLevel );

    pHash->aBuckets[index] = pNode;
    pNode->pSibUp = (PDB_NODE) pHash;
}



VOID
NTree_HashRebalance(
    IN      PSIB_HASH_TABLE pHash
    )
/*++

Routine Description:

    Rebalance all B-trees in this and underlying hashes.

    Note this function calls itself recursively to balance B-trees in
    underlying hashes.

Arguments:

    pHash -- hash containing sibling node

Return Value:

    None.

--*/
{
    INT             i;
    PDB_NODE        ptemp;

    ASSERT( pHash && IS_HASH_TABLE(pHash) );

    IF_DEBUG( BTREE2 )
    {
        DNS_PRINT((
            "NTree_HashRebalance()\n"
            "    level = %d\n",
            pHash->cLevel ));
    }

    //
    //  check each hash bucket
    //      - nothing ignore
    //      - if normal node, rebalance btree
    //      - if next level down is hash, recurse

    for (i=0; i<=LAST_HASH_INDEX; i++)
    {
        ptemp = pHash->aBuckets[i];
        if ( !ptemp )
        {
            ASSERT( pHash->aBucketCount[i] == 0 );
            continue;
        }
        if ( IS_HASH_TABLE(ptemp) )
        {
            NTree_HashRebalance( (PSIB_HASH_TABLE)ptemp );
        }
        else
        {
            btreeRebalance(
                ptemp,
                pHash->aBucketCount[i] );
        }
    }
}



//
//  Debug routines
//

#if DBG

#define BLANK_STRING    "| | | | | | | | | | | | | | | | | | | | | | | | | |"


VOID
Dbg_SiblingBTree(
    IN      PDB_NODE        pNode,
    IN      INT             iIndent
    )
/*++

Routine Description:

    Debug print subtree of sibling B-Tree.

    NOTE:   This function should NOT BE CALLED DIRECTLY!
            This function calls itself recursively and hence to avoid
            unnecessary overhead, prints in this function are not protected.

Arguments:

    pNode - root node of tree/subtree to print

    iIndent - indent level

Return Value:

    None.

--*/
{
    ASSERT( !IS_HASH_TABLE(pNode) );

    //  print left subtree

    if ( pNode->pSibLeft )
    {
        Dbg_SiblingBTree(
            pNode->pSibLeft,
            iIndent + 1 );
    }

    //  print the node

    DnsPrintf(
        "%.*s%s (me=%p, l=%p, r=%p, up=%p)\n",
        (iIndent << 1),
        BLANK_STRING,
        pNode->szLabel,
        pNode,
        pNode->pSibLeft,
        pNode->pSibRight,
        pNode->pSibUp );

    //  print right subtree

    if ( pNode->pSibRight )
    {
        Dbg_SiblingBTree(
            pNode->pSibRight,
            iIndent + 1 );
    }
}



VOID
Dbg_SiblingHash(
    IN      PSIB_HASH_TABLE pHash
    )
/*++

Routine Description:

    Print sibling hash table.

Arguments:

    pHash - child hash table to print

Return Value:

    None

--*/
{
    INT             index;
    INT             indentLevel;
    PDB_NODE        pnode;
    INT             count;

    ASSERT( pHash != NULL );
    ASSERT( IS_HASH_TABLE(pHash) );

    DnsDebugLock();

    //
    //  print hash info
    //

    indentLevel = pHash->cLevel;

    DnsPrintf(
        "%.*sHashTable %p (l=%d, upbuck=%d, up=%p)\n",
        (indentLevel << 1),
        BLANK_STRING,
        pHash,
        pHash->cLevel,
        pHash->iBucketUp,
        pHash->pHashUp );

    indentLevel++;

    //
    //  print hash buckets
    //

    indentLevel <<= 1;

    for (index=0; index<=LAST_HASH_INDEX; index++)
    {
        pnode = pHash->aBuckets[index];
        count = pHash->aBucketCount[index];

        if ( !pnode )
        {
            ASSERT( count == 0 );
            DnsPrintf(
                "%.*sBucket[%d] => NULL\n",
                indentLevel,
                BLANK_STRING,
                index );
        }
        else
        {
            ASSERT( count > 0 );
            DnsPrintf(
                "%.*sBucket[%d] (c=%d) (%s=%p):\n",
                indentLevel,
                BLANK_STRING,
                index,
                count,
                IS_HASH_TABLE(pnode) ? "hash" : "node",
                pnode );

            IF_DEBUG( BTREE2 )
            {
                if ( IS_HASH_TABLE(pnode) )
                {
                    Dbg_SiblingHash( (PSIB_HASH_TABLE)pnode );
                }
                else
                {
                    Dbg_SiblingBTree( pnode, indentLevel );
                }
            }
        }
    }
    DnsPrintf(
        "%.*sEnd level %d hash %p.\n\n",
        (pHash->cLevel << 1),
        BLANK_STRING,
        pHash->cLevel,
        pHash );

    DnsDebugUnlock();
}



VOID
Dbg_SiblingList(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Debug print subtree of sibling B-Tree.

Arguments:

    pszHeader - header for B-Tree

    pNode - root node of tree/subtree to print

Return Value:

    None.

--*/
{
    DnsDebugLock();

    DnsPrintf(
        "%s\n",
        pszHeader );

    if ( !pNode )
    {
        DnsPrintf( "    NULL node\n" );
    }
    else if ( IS_HASH_TABLE(pNode) )
    {
        Dbg_SiblingHash(
            (PSIB_HASH_TABLE) pNode );
    }
    else
    {
        Dbg_SiblingBTree(
            pNode,
            0 );
        DnsPrintf( "\n" );
    }

    DnsDebugUnlock();
}



DWORD
NTree_VerifyChildBTree(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pParent,
    IN      PDB_NODE        pNodeChild,     OPTIONAL
    IN      PDWORD          pfFoundChild    OPTIONAL
    )
/*++

Routine Description:

    Verify valid child list for node.

Arguments:

    pNode - node in sibling list to verify

    pParent - DNS parent node

    pNodeChild - node that should be in child list

    pfFoundChild - flag to set if pNodeChild found

Return Value:

    Number of BTree nodes in node's subtree (including node itself).

--*/
{
    PDB_NODE        pleft;
    PDB_NODE        pright;
    DWORD           cleft;
    DWORD           cright;

    ASSERT( pNode != NULL );

    //
    //  verify parent
    //      - can not be its own parent
    //

    if( pNode->pParent != pParent )
    {
        DNS_PRINT((
            "ERROR:  Node (%p) in child list has incorrect parent.\n"
            "    expected parent = %p\n"
            "    pnode->pParent = %p\n",
            pNode,
            pParent,
            pNode->pParent ));
        Dbg_DnsTree( "ERROR:  Self-parenting node", pNode );
        ASSERT( FALSE );
        return FALSE;
    }
    ASSERT( pNode != pParent );

    //
    //  is child we are verifying?
    //

    if ( pNode == pNodeChild )
    {
        *pfFoundChild = TRUE;
    }

    //
    //  verify left
    //

    pleft = pNode->pSibLeft;
    cleft = 0;
    if ( pleft )
    {
        ASSERT( pleft->pSibUp == pNode );
        cleft = NTree_VerifyChildBTree(
                    pleft,
                    pParent,
                    pNodeChild,
                    pfFoundChild );
    }

    //
    //  verify right
    //

    pright = pNode->pSibRight;
    cright = 0;
    if ( pright )
    {
        ASSERT( pright->pSibUp == pNode );
        cright = NTree_VerifyChildBTree(
                    pright,
                    pParent,
                    pNodeChild,
                    pfFoundChild );
    }

    return cright+cleft+1;
}



DWORD
NTree_VerifyChildHash(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pParent,
    IN      PDB_NODE        pNodeChild,     OPTIONAL
    IN      PDWORD          pfFoundChild    OPTIONAL
    )
/*++

Routine Description:

    Verify valid child hash table.

Arguments:

    pHash - child hash table to verify

    pParent - DNS parent node

    pNodeChild - node that should be in child list

    pfFoundChild - flag to set if pNodeChild found

Return Value:

    Number of BTree nodes in node's subtree (including node itself).

--*/
{
    INT             index;
    PDB_NODE        pnode;
    DWORD           countChildren;
    DWORD           countTotalChildren = 0;

    ASSERT( pHash != NULL );
    ASSERT( IS_HASH_TABLE(pHash) );
    ASSERT( pHash->pHashUp || pParent->pChildren == (PDB_NODE)pHash );

    //
    //  verify hash or B-tree for each bucket
    //

    for (index=0; index<=LAST_HASH_INDEX; index++)
    {
        pnode = pHash->aBuckets[index];

        if ( !pnode )
        {
            ASSERT( pHash->aBucketCount[index] == 0 );
            continue;
        }

        else if ( IS_HASH_TABLE(pnode) )
        {
            ASSERT( ((PSIB_HASH_TABLE)pnode)->pHashUp == pHash );
            ASSERT( ((PSIB_HASH_TABLE)pnode)->cLevel == pHash->cLevel+1 );
            ASSERT( ((PSIB_HASH_TABLE)pnode)->iBucketUp == index );

            countChildren = NTree_VerifyChildHash(
                                (PSIB_HASH_TABLE)pnode,
                                pParent,
                                pNodeChild,
                                pfFoundChild );
        }

        //  verify B-tree for bucket
        //  except at last hash level -- where there is no limit
        //  on the number of nodes and hence they don't necessarily
        //  fit in our counter -- the B-tree size should match our
        //  bucket count

        else
        {
            countChildren = NTree_VerifyChildBTree(
                                pnode,
                                pParent,
                                pNodeChild,
                                pfFoundChild );

            ASSERT( countChildren == (DWORD)pHash->aBucketCount[index] );
        }

        countTotalChildren += countChildren;
    }

    return countTotalChildren;
}



BOOL
NTree_VerifyChildList(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeChild      OPTIONAL
    )
/*++

Routine Description:

    Verify valid child list for node.

Arguments:

    pNode - node to verify child list of

    pNodeChild - optional node that should be in child list

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PDB_NODE        pchild;
    DWORD           countChildren;
    BOOL            foundChild = FALSE;

    ASSERT( pNode != NULL );

    //
    //  no children
    //

    pchild = pNode->pChildren;
    if ( !pchild )
    {
        if ( pNode->cChildren != 0 )
        {
            DNS_PRINT((
                "ERROR:  Node (%s) has child count %d but no child list!\n"
                "    pNode = %p\n"
                "    countChildren = %d\n",
                pNode->szLabel,
                pNode,
                pNode->cChildren ));
            ASSERT( pNode->cChildren == 0 );
            return FALSE;
        }
        return TRUE;
    }

    //
    //  first level hash
    //

    if ( IS_HASH_TABLE(pchild) )
    {
        countChildren = NTree_VerifyChildHash(
                            (PSIB_HASH_TABLE)pchild,
                            pNode,
                            pNodeChild,
                            & foundChild );
    }

    //
    //  B-tree only
    //

    else
    {
        countChildren = NTree_VerifyChildBTree(
                            pchild,
                            pNode,
                            pNodeChild,
                            & foundChild );
    }

    if ( pNode->cChildren != countChildren )
    {
        DNS_PRINT((
            "WARNING:  Node (%s) child count does not match child list length.\n"
            "    pNode = %p\n"
            "    countChildren = %d\n"
            "    count found   = %d\n",
            pNode->szLabel,
            pNode,
            pNode->cChildren,
            countChildren ));

        //
        //  DEVNOTE: I believe there's a problem maintaining child count over hash
        //      nodes, needs fixing but not now
        //
        //  count only has functional value for determining when to pop out hash
        //  and as rough estimate of child nodes to come in rpc enum
        //

        ASSERT( pNode->cChildren == countChildren );
        //  Dbg_DumpTree( pNode );
        //  return FALSE;
        return TRUE;
    }

    if ( pNodeChild && !foundChild )
    {
        DNS_PRINT((
            "ERROR:  Node (%s %p) not found in parent's child list.\n"
            "    pParent = %p\n",
            pNodeChild->szLabel,
            pNodeChild,
            pNode ));
        Dbg_DnsTree( "ERROR:  node not in parent's child list", pNode );
        Dbg_DbaseNode(
            "Missing child node.\n",
            pNodeChild );
        ASSERT( FALSE );
        return FALSE;
    }
    return TRUE;
}

#endif



BOOL
NTree_VerifyNodeInSiblingList(
    IN      PDB_NODE       pNode
    )
/*++

Routine Description:

    Verify node is valid member of sibling list.

Arguments:

    pNode - node to verify

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PDB_NODE        pnode;
    PDB_NODE        pparent;
    PDB_NODE        pchild;
    PSIB_HASH_TABLE phash;
    PSIB_HASH_TABLE phashUp;
    INT             index;

    ASSERT( pNode != NULL );
    ASSERT( !IS_ON_FREE_LIST(pNode) );

    //
    //  find parent
    //      - if root, then no siblings
    //

    pparent = pNode->pParent;
    if ( !pparent )
    {
        HARD_ASSERT( pNode->pSibUp == NULL );
        HARD_ASSERT( pNode->pSibLeft == NULL );
        HARD_ASSERT( pNode->pSibRight == NULL );
        return TRUE;
    }

    //
    //  verify immediate B-tree children
    //      - node is their B-tree parent
    //      - node's DNS parent, is their DNS parent
    //

    pchild = pNode->pSibLeft;
    if ( pchild )
    {
        HARD_ASSERT( pchild->pSibUp == pNode );
        HARD_ASSERT( pchild->pParent == pparent );
    }
    pchild = pNode->pSibRight;
    if ( pchild )
    {
        HARD_ASSERT( pchild->pSibUp == pNode );
        HARD_ASSERT( pchild->pParent == pparent );
    }

    //
    //  traverse up B-tree
    //      - verify top node is parent's direct child
    //

    pnode = pNode;

    while ( 1 )
    {
        phash = (PSIB_HASH_TABLE) pnode->pSibUp;
        if ( !phash )
        {
            HARD_ASSERT( pparent->pChildren == pnode );
            return TRUE;
        }
        if ( !IS_HASH_TABLE(phash) )
        {
            pnode = (PDB_NODE) phash;
            continue;
        }
        break;
    }

    //  have hash block
    //      - find our bin, and verify hash points at top of our B-tree

    index = NTree_HashTableIndex(
                pNode,
                phash->cLevel
                );
    HARD_ASSERT( phash->aBuckets[index] == pnode );

    //
    //  traverse up hash blocks
    //      - note, could verify index at each node
    //      - verify top hash block is parent's direct child
    //

    while ( phashUp = phash->pHashUp )
    {
        HARD_ASSERT( phashUp->cLevel == phash->cLevel-1 );
        phash = phashUp;
    }

    HARD_ASSERT( phash->cLevel == 0 );
    HARD_ASSERT( pparent->pChildren == (PDB_NODE)phash );

    return TRUE;
}



//
//  Public Sibling list functions
//

VOID
NTree_StartFileLoad(
    VOID
    )
/*++

Routine Description:

    Turn on full rebalancing of sibling trees.

Arguments:

    None.

Return Value:

    None.

--*/
{
    gcFullRebalance++;
}


VOID
NTree_StopFileLoad(
    VOID
    )
/*++

Routine Description:

    Turn off full rebalancing of sibling trees.

Arguments:

    None.

Return Value:

    None.

--*/
{
    gcFullRebalance--;
}



PDB_NODE
FASTCALL
NTree_FirstChild(
    IN      PDB_NODE        pParent
    )
/*++

Routine Description:

    Get first child node.

Arguments:

    pParent -- parent node to get child of

Return Value:

    None.

--*/
{
    PDB_NODE        pleft;
    PDB_NODE        ptemp;

    ASSERT( pParent );

    //
    //  get child tree root
    //

    LOCK_CHILD_LIST( pParent );

    pleft = pParent->pChildren;
    if ( !pleft )
    {
        // done
    }

    //
    //  hash table node?
    //

    else if ( IS_HASH_TABLE(pleft) )
    {
        pleft = NTree_NextHashedNode(
                    (PSIB_HASH_TABLE)pleft,
                    NULL );
    }

    //
    //  go all the way left for first node
    //

    else
    {
        while ( ptemp = pleft->pSibLeft )
        {
            pleft = ptemp;
        }
    }

    UNLOCK_CHILD_LIST( pParent );
    return pleft;
}



PDB_NODE
FASTCALL
NTree_NextSibling(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Get next sibling of node.

Arguments:

    pNode -- node in sibling list

Return Value:

    None.

--*/
{
    PDB_NODE    ptemp;

    ASSERT( pNode );

    DNS_DEBUG( BTREE2, (
        "NTree_NextSibling(%s)\n",
        pNode->szLabel ));

    //
    //  if node has right child
    //      => go down right subtree, then all the way left

    if ( ptemp = pNode->pSibRight )
    {
        while ( pNode = ptemp->pSibLeft )
        {
            ptemp = pNode;
        }
        return ptemp;
    }

    //
    //  if no right child, then go back up until first "right ancestor"
    //  right ancestor means we came up left branch of its subtree
    //
    //  if encounter hash table, then find first node in next hash bucket
    //

    else
    {
        while ( ptemp = pNode->pSibUp )
        {
            if ( IS_HASH_TABLE(ptemp) )
            {
                return  NTree_NextHashedNode(
                            (PSIB_HASH_TABLE)ptemp,
                            pNode );
            }

            //  if node was left child, then ptemp is next node

            if ( ptemp->pSibLeft == pNode )
            {
                return ptemp;
            }

            //  right child, continue up tree

            ASSERT( ptemp->pSibRight == pNode );
            pNode = ptemp;
        }
        return NULL;
    }
}



PDB_NODE
FASTCALL
NTree_NextSiblingWithLocking(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Get next sibling of node.

Arguments:

    pNode -- node in sibling list

Return Value:

    None.

--*/
{
    PDB_NODE    ptemp;

    //
    //  note we set ACCESS flag so timeout thread can NOT whack this node
    //  before we've moved in
    //  better solution is to do traverse with timeout thread locked out
    //

    LOCK_CHILD_LIST( pNode->pParent );

    ptemp = NTree_NextSibling(pNode);
    if ( ptemp )
    {
        SET_NODE_ACCESSED( ptemp );
    }

    UNLOCK_CHILD_LIST( pNode->pParent );

#if DBG
    IF_DEBUG( BTREE )
    {
        if ( ptemp )
        {
            NTree_VerifyNode( pNode );
        }
    }
#endif
    return ptemp;
}



VOID
FASTCALL
NTree_RebalanceChildList(
    IN      PDB_NODE        pParent
    )
/*++

Routine Description:

    Rebalance child list of node.

Arguments:

    pParent -- node who's child list is to be rebalanced

Return Value:

    None.

--*/
{
    PDB_NODE        pnodeChildRoot;

    ASSERT( pParent );
    DNS_DEBUG( BTREE, (
        "NTree_RebalanceChildList( %s )\n",
        pParent->szLabel ));

    //
    //  less than three children -- no point to rebal
    //

    if ( pParent->cChildren < 3 )
    {
        return;
    }
    ASSERT( pParent->pChildren );

    //
    //  if B-tree at root rebal
    //

    pnodeChildRoot = pParent->pChildren;

    if ( !IS_HASH_TABLE(pnodeChildRoot) )
    {
        btreeRebalance( pnodeChildRoot, pParent->cChildren );
        return;
    }

    //
    //  balance B-trees in all sibling hashes
    //

    NTree_HashRebalance( (PSIB_HASH_TABLE)pnodeChildRoot );
}



int
quickStrCmp(
    IN      int             keyLength,
    IN      PCHAR           pszKey,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Does a fast string compare between a key string and the label
    string for a node. Before calling this function you must try 
    DWORD compare to see if the compare can be resolved that way.
    If you call this function before comparing the DWORD compare
    values you may get incorrect results!

Arguments:

    keyLength - length of pszKey

    pszKey - the search string

    pNode - node whose label will be compared against the key

Return Value:

    Returns:
        -1 if key < node label
         0 if key == node label
        +1 if key > node label

--*/
{
    int iCompare;
    int iLabelLengthDiff = keyLength - pNode->cchLabelLength;

    ASSERT( pszKey );
    ASSERT( pNode );

    if ( keyLength <= sizeof( DWORD ) ||
        pNode->cchLabelLength <= sizeof( DWORD ) )
    {
        if ( iLabelLengthDiff == 0 )
        {
            return 0;
        }
        iCompare = iLabelLengthDiff;
    }
    else
    {
        iCompare = strncmp(
                        pszKey,
                        DOWNCASED_NODE_NAME( pNode ),
                        keyLength );
        if ( !iCompare )
        {
            if ( !iLabelLengthDiff )
            {
                return 0;
            }
            iCompare = iLabelLengthDiff;
            ASSERT( iCompare < 0 );
        }
    }
    return iCompare;
} // quickStrCmp



void
walkBinaryTree(
    DWORD           dwordSearchKey,     IN
    PCHAR           szlabel,            IN
    DWORD           labelLength,        IN
    PDB_NODE *      ppnodePrev,         OUT
    PDB_NODE *      ppnodeCurrent,      OUT
    PDB_NODE **     pppnodeNext,        IN
    PDB_NODE *      ppnodeNxt           OUT
    )
/*++

Routine Description:

    This function performs the guts of the binary tree walking
    for NTree_FindOrCreateChildNode().

    As we go, test if the current node is a candidate
    for being the node that immediately precedes the node we're
    searching for. The node is a candidate if:
        node->value < searchkey &&
        ( node->right->value == NULL || node->right->value > searchkey )

    This is called the NXT node because it's the node that can
    be used to satisfy the NXT requirement for the search name.

Arguments:

    dwordSearchKey - lookup name converted to 4 bytes for fast compares

    szlabel - lookup name in regular string form

    ppnodePrev - ptr to the previous node

    ppnodeCurrent - ptr to the current node

    pppnodeNext - ptr to the next node - INPUT: starting node for search

    ppnodeNxt - ptr to the NXT node - the node preceding the search key

Return Value:

--*/
{
    LONG            icompare;

    ASSERT( szlabel );
    ASSERT( ppnodePrev );
    ASSERT( ppnodeCurrent );
    ASSERT( pppnodeNext );

    while ( *ppnodeCurrent = **pppnodeNext )
    {
        //  save backptr for adds

        *ppnodePrev = *ppnodeCurrent;

        //
        //  compare labels
        //      - database string store WITHOUT case
        //      - compare DWORD faster comparison first
        //      - full case sensitive compare only on DWORD compare match
        //

        //  check for no DWORD match
        //      - drop appropriately to left or right node
        //      - save back ptr for adding new node
        //
        //  note can NOT use integer diff to compare;  need to know which is greater
        //      in absolute unwrapped terms to handle extended characters

        if ( ppnodeNxt &&
            (*ppnodeCurrent)->dwCompare < dwordSearchKey &&
            ( (*ppnodeCurrent)->pSibRight == NULL ||
                (*ppnodeCurrent)->pSibRight->dwCompare > dwordSearchKey ||
                ( (*ppnodeCurrent)->pSibRight->dwCompare == dwordSearchKey &&
                    quickStrCmp(
                        labelLength,
                        szlabel,
                        (*ppnodeCurrent)->pSibRight ) > 0 ) ) )
        {
            *ppnodeNxt = *ppnodeCurrent;
        }

        if ( dwordSearchKey < (*ppnodeCurrent)->dwCompare )
        {
            *pppnodeNext = &(*ppnodeCurrent)->pSibLeft;
            continue;
        }
        else if ( dwordSearchKey > (*ppnodeCurrent)->dwCompare )
        {
            *pppnodeNext = &(*ppnodeCurrent)->pSibRight;
            continue;
        }

        //
        //  quick compare DWORD exact match
        //

        //
        //  compare label lengths
        //  if either label contained in quick-compare DWORD ?
        //
        //  - labels lengths equal => complete match
        //  - else length diff indicates which larger
        //

        icompare = quickStrCmp(
                        labelLength,
                        szlabel,
                        *ppnodeCurrent );
        
        if ( !icompare )
        {
            return;
        }

        //
        //  drop appropriately to left or right node
        //      - save address in previous node for ptr
        //      - cut allowed imbalance in half
        //

        if ( ppnodeNxt &&
            icompare > 0 &&
            ( (*ppnodeCurrent)->pSibRight == NULL ||
                (*ppnodeCurrent)->pSibRight->dwCompare > dwordSearchKey ||
                ( (*ppnodeCurrent)->pSibRight->dwCompare == dwordSearchKey &&
                    quickStrCmp(
                        labelLength,
                        szlabel,
                        (*ppnodeCurrent)->pSibRight ) > 0 ) ) )
        {
            *ppnodeNxt = *ppnodeCurrent;
        }

        if ( icompare < 0 )
        {
            *pppnodeNext = &(*ppnodeCurrent)->pSibLeft;
            continue;
        }
        else
        {
            ASSERT( icompare > 0 );
            *pppnodeNext = &(*ppnodeCurrent)->pSibRight;
            continue;
        }
    }
}   //  walkBinaryTree



PSIB_HASH_TABLE
NTree_PreviousHash(
    IN      PSIB_HASH_TABLE     pHash,
    IN OUT  PINT                pHashIdx
    )
/*++

Routine Description:

    Finds the previous hash node and index starting from a given hash node
    and index. NULL hash buckets are skipped over.
    
    pHash must be a hash node, and pHashIdx must be set to the index
    at which to begin the traverse. The node returned will be a hash node, and
    the value at pHashIdx will be set to the index of the next node in the
    returned hash node.

    The returned hash bucket will be bottom-level, that is, the pointer will
    be a pointer to a DB_NODE, not to another hash table.

    JJW: LOCKING!!

Arguments:

    pHash - ptr to starting hash node

    pHashIdx - IN: ptr to starting hash idx
               OUT: ptr to hash index in returned hash node

Return Value:

    Pointer to previous hash node, with hash index at pHashIdx. NULL if there
    is no non-empty hash bucket before the specified bucket.

--*/
{
    PSIB_HASH_TABLE     pPrevNode;

    --( *pHashIdx );

    while ( 1 )
    {
        DNS_DEBUG( LOOKUP, (
            "NTree_PreviousHash: pHash %p hashIdx %d\n",
            pHash,
            *pHashIdx ));

        //
        //  If out of buckets in this hash node, move up to parent hash node
        //  and set index for the index of the current node in the parent.
        //

        if ( *pHashIdx < 0 )
        {
            if ( pHash->cLevel == 0 )
            {
                //  Hit top of tree - no more nodes!
                *pHashIdx = -1;
                return NULL;
            }
            *pHashIdx = pHash->iBucketUp - 1;

            ASSERT( pHash->pHashUp );
            ASSERT( pHash->pHashUp->cLevel == pHash->cLevel - 1 );
            ASSERT( pHash->pHashUp->aBuckets[ *pHashIdx + 1 ] ==
                    ( PDB_NODE ) pHash );

            pHash = pHash->pHashUp;
            continue;
        }
        ASSERT( *pHashIdx < LAST_HASH_INDEX );

        //
        //  Check pointer in the current node at the current index. If NULL,
        //  advance to next bucket pointer.
        //

        pPrevNode = ( PSIB_HASH_TABLE ) pHash->aBuckets[ *pHashIdx ];
        if ( !pPrevNode )
        {
            --( *pHashIdx );
            continue;
        }

        //
        //  If the node is another hash table, set the index to the last
        //  element and continue to search for a non-NULL bucket pointer.
        //

        if ( IS_HASH_TABLE( pPrevNode ) )
        {
            ASSERT( pPrevNode->pHashUp == pHash );
            ASSERT( pPrevNode->iBucketUp == *pHashIdx );
            ASSERT( pPrevNode->cLevel ==
                        pHash->cLevel + 1 );
            pHash = pPrevNode;
            *pHashIdx = LAST_HASH_INDEX - 1;
            continue;
        }

        break;      //  We've found the previous non-null hash bucket!
    }
    return pHash;
}   //  NTree_PreviousHash



PDB_NODE
NTree_FindOrCreateChildNode(
    IN      PDB_NODE        pParent,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    IN      BOOL            fCreate,
    IN      DWORD           dwMemTag,
    OUT     PDB_NODE *      ppnodePrevious          OPTIONAL
    )
/*++

Routine Description:

    Find or create a node in child list of tree.

    Assumes lock held on child B-tree.

Arguments:

    pParent - parent of child node to find

    pchName - child node's label

    cchNameLength - child node's label length

    fCreate - create flag TRUE to create node if not found

    dwMemTag - tag for node or zero for generic

    ppnodePrevious - If no match found or created, will be set
        to the node that immediately precedes the search key
        e.g. if the tree contains A, B, D, E and you search for
        C, ppnodePrevious will point at B. Pass NULL if you
        don't care.

Return Value:

    Ptr to child node if found or created.
    NULL if pchName is invalid name or in find case
    if NOT a child node of pParent.

--*/
{
    PDB_NODE        pnodeCurrent;
    LONG            icompare;
    LONG            ilabelLengthDiff;
    DWORD           labelLength;
    DWORD           dwordName;
    INT             downResult;
    PDB_NODE        pnodeAdd;
    PDB_NODE        pnodePrev;
    PDB_NODE *      ppnodeNext;
    PZONE_INFO      pzone;
    DWORD           nameCheckFlag;
    CHAR            szlabel[ DNS_MAX_LABEL_BUFFER_LENGTH ] = "";
    INT             hashIdx = 0;
    PDB_NODE        pHash = NULL;

#if DBG
    ASSERT( pParent != NULL );
    IF_DEBUG( DATABASE )
    {
        ASSERT( NTree_VerifyNode(pParent) );
    }
    IF_DEBUG( BTREE2 )
    {
        DnsDebugLock();
        DnsPrintf(
            "NTree_FindOrCreateChild()\n"
            "    parent label: (%s)\n"
            "        child count = %d\n"
            "        zone        = %p\n"
            "    child label: (%.*s)\n",
            pParent->szLabel,
            pParent->cChildren,
            pParent->pZone,
            cchNameLength,
            pchName );
        Dbg_SiblingList(
            "Child list before lookup:",
            pParent->pChildren );
        DnsDebugUnlock();
    }
#endif

    //
    //  verify node, minimum AV protection
    //

    if ( pParent == NULL )
    {
        ASSERT( FALSE );
        return NULL;
    }

    if ( ppnodePrevious )
    {
        *ppnodePrevious = NULL;
    }

    //
    //  child count problem detection\protection
    //

    if ( pParent->pChildren == NULL )
    {
        if ( pParent->cChildren != 0 )
        {
            DNS_PRINT((
                "ERROR:  Bachelor node (%s) (%p) has non-zero child count = %d\n",
                pParent->szLabel,
                pParent,
                pParent->cChildren ));
            TEST_ASSERT( FALSE );
            pParent->cChildren = 0;
        }
    }
    ELSE_IF_DEBUG( ANY )
    {
        if ( pParent->cChildren == 0 )
        {
            DnsDebugLock();
            DNS_PRINT((
                "ERROR:  Parent node (%s) (%p) has zero child count.\n",
                pParent->szLabel,
                pParent ));
            Dbg_SiblingList(
                "Child list of parent with zero children:\n",
                pParent->pChildren );
            //  TEST_ASSERT( FALSE );
            //  JJW: this will hit occasionally - the source should be found for Longhorn
            DnsDebugUnlock();
        }
    }

    //
    //  zero children on find -- done
    //

    if ( pParent->pChildren == NULL  &&  !fCreate )
    {
        return NULL;
    }

    //
    //  validate and downcase incoming label
    //
    //  - in primary zones, use configurable NameCheckFlag
    //  - in secondaries, must take anything primary sends
    //  - in cache, allow anything
    //
    //      - ASCII -> 0 (length must be the same as input)
    //      - error -> (-1)
    //      - extended -> length of extended name
    //


    nameCheckFlag = DNS_ALLOW_ALL_NAMES;

    pzone = (PZONE_INFO) pParent->pZone;
    if ( pzone && IS_ZONE_PRIMARY(pzone) )
    {
        nameCheckFlag = SrvCfg_dwNameCheckFlag;
    }

    downResult = Dns_DowncaseNameLabel(
                    szlabel,
                    pchName,
                    cchNameLength,
                    nameCheckFlag );

    if ( downResult == 0 )
    {
        labelLength = cchNameLength;
    }
    else if ( downResult == (-1) )
    {
        DNS_DEBUG( LOOKUP, (
            "Label %.*s failed validity-downcase check\n"
            "    NameCheckFlag = %d\n"
            "    NTree_FindOrCreate() bailing out\n",
            cchNameLength,
            pchName,
            nameCheckFlag ));

        SetLastError( DNS_ERROR_INVALID_NAME );
        return NULL;
    }

    //
    //  extended name
    //      - result is downcased label length
    //      for UTF8 this "could" be different than input length

    else
    {
        labelLength = downResult;
        if ( labelLength != cchNameLength )
        {
            DNS_DEBUG( LOOKUP, (
                "WARNING:  Label %.*s validity-downcase check returned new length\n"
                "    length in    = %d\n"
                "    length out   = %d\n",
                cchNameLength,
                pchName,
                cchNameLength,
                labelLength ));
        }
        DNS_DEBUG( LOOKUP, (
            "Label %.*s\n"
            "    cannonicalize to %s\n"
            "    name length = %d\n"
            "    label length = %d\n",
            cchNameLength,
            pchName,
            szlabel,
            cchNameLength,
            labelLength ));
    }


    //
    //  make DWORD label for quick compare
    //      - mask off bytes beyond label name
    //

    INLINE_DWORD_FLIP( dwordName, *(PDWORD)szlabel );
    if ( labelLength < 4 )
    {
        dwordName &= QuickCompareMask[ labelLength ];
    }

    //
    //  get sibling B-tree root
    //

    pnodePrev = NULL;
    ppnodeNext = &pParent->pChildren;
    while ( ( pnodeCurrent = *ppnodeNext ) != NULL &&
        IS_HASH_TABLE( pnodeCurrent ) )
    {
        pHash = pnodePrev = pnodeCurrent;
        hashIdx = NTree_HashTableIndexEx(
                        NULL,
                        szlabel,
                        ( ( PSIB_HASH_TABLE ) pHash )->cLevel );
        ppnodeNext = &( ( PSIB_HASH_TABLE ) pHash )->aBuckets[ hashIdx ];
    }

    //
    //  Walk the binary tree we've found, searching for the node.
    //

    walkBinaryTree( 
        dwordName,
        szlabel,
        labelLength,
        &pnodePrev,
        &pnodeCurrent,
        &ppnodeNext,
        ppnodePrevious );
    
    if ( pnodeCurrent )
    {
        return pnodeCurrent;
    }

    #if 0
    DNS_DEBUG( ANY, (
        "JJW: search %.*s found %.*s previous %.*s\n",
        cchNameLength, pchName,
        pnodeCurrent ? pnodeCurrent->cchLabelLength : 4,
        pnodeCurrent ? pnodeCurrent->szLabel : "NULL",
        ppnodePrevious && *ppnodePrevious ? (*ppnodePrevious)->cchLabelLength : 4,
        ppnodePrevious && *ppnodePrevious  ? (*ppnodePrevious)->szLabel : "NULL" ));
    #endif

    //
    //  We drop here if NOT found.
    //

    ASSERT( pnodeCurrent == NULL );

    if ( !fCreate )
    {
        //
        //  If we don't have a "previous node", the previous node is in
        //  another tree. Find the root of the next tree, and search it
        //  for the previous node. BUT we can only do this if pHash is not
        //  NULL - if we didn't start searching in a tree with no hash tables.
        //

        if ( ppnodePrevious && !*ppnodePrevious && pHash )
        {
            pnodeCurrent = ( PDB_NODE )
                NTree_PreviousHash( ( PSIB_HASH_TABLE ) pHash, &hashIdx );
            if ( pnodeCurrent )
            {
                ppnodeNext =
                    &( ( PSIB_HASH_TABLE ) pnodeCurrent )->aBuckets[ hashIdx ];
                #if 0
                DNS_DEBUG( ANY, (
                    "JJW: regressing to previous tree %.*s\n",
                    *ppnodeNext ? (*ppnodeNext)->cchLabelLength : 4,
                    *ppnodeNext ? (*ppnodeNext)->szLabel : "NULL" ));
                #endif
                pnodePrev = pnodeCurrent = NULL;
                walkBinaryTree( 
                    dwordName,
                    szlabel,
                    labelLength,
                    &pnodePrev,
                    &pnodeCurrent,
                    &ppnodeNext,
                    ppnodePrevious );
            }
        }
        return NULL;
    }

    //
    //  creating new node -- allocate and build
    //
    //  note:  do NOT preserve case on extended names,
    //  for multibyte names, case preservation is "problematic"
    //  (casing language issues) so UTF8 is always downcased on the
    //  wire, and we should NOT preserve case;  this also eliminates
    //  the problem of original\downcased having different lengths
    //

    if ( downResult == 0 )      // no-multibyte
    {
        pnodeAdd = NTree_CreateNode(
                        pchName,            // original name
                        szlabel,            // downcased name
                        labelLength,
                        dwMemTag );
    }
    else                        // multibyte
    {
        pnodeAdd = NTree_CreateNode(
                        szlabel,            // downcased name
                        szlabel,            // downcased name
                        labelLength,
                        dwMemTag );
    }

    if ( !pnodeAdd )
    {
        ASSERT( FALSE );
        return NULL;
    }

    //
    //  set quick compare DWORD
    //

    pnodeAdd->dwCompare = dwordName;

    //
    //  link to parent
    //  set label count from parent
    //

    pParent->cChildren++;
    pnodeAdd->pParent = pParent;
    pnodeAdd->cLabelCount = pParent->cLabelCount + 1;

    //  point at parent's zone
    //      - when creating zone root we'll immediately overwrite

    pnodeAdd->pZone = pParent->pZone;

    //
    //  DEVNOTE: this messes up zonetree;
    //      inheritance is desirable in 99% case in zone data trees, but currently
    //          overwriting every node anyway
    //      we could go either way here and allow zone ptr, and do more figuring
    //          but this is harder to clean up on zone shutdown\unload
    //      or could have zone tree traverse NULL out non-AUTH_ROOT nodes
    //

    //
    //  link to sibling tree
    //  or sets parent's child tree, if first node at parent
    //  or sets hash table ptr, if first node in hash bucket
    //

    *ppnodeNext = pnodeAdd;
    pnodeAdd->pSibUp = pnodePrev;

    //
    //  siblings in one b-tree
    //      - check if need top level hash
    //

    if ( !IS_HASH_TABLE(pParent->pChildren) )
    {
        if ( pParent->cChildren > HASH_BUCKET_MAX0 )
        {
            NTree_CreateHashAtNode( pParent->pChildren );
        }
        IF_DEBUG( DATABASE )
        {
            ASSERT( NTree_VerifyNode(pParent) );
        }
    }

    //
    //  if under hash table -- reset count, routine should rebal
    //      if ADDing over given value
    //

    else
    {
        pnodeCurrent = pnodeAdd;
        while ( (pnodeCurrent = pnodeCurrent->pSibUp)
                && !IS_HASH_TABLE(pnodeCurrent) )
        {
        }
        ASSERT( pnodeCurrent && IS_HASH_TABLE(pnodeCurrent) );
        NTree_AddNodeInHashBucket(
            (PSIB_HASH_TABLE) pnodeCurrent,
            pnodeAdd );

        IF_DEBUG( DATABASE )
        {
            ASSERT( NTree_VerifyNode(pParent) );
        }
    }

    IF_DEBUG( BTREE2 )
    {
        Dbg_SiblingList(
            "Full sibling list after insert:",
            pParent->pChildren );
    }
    IF_DEBUG( DATABASE2 )
    {
        Dbg_DbaseNode(
            "Node after create and insert:",
            pnodeAdd );
    }

    NTree_VerifyNodeInSiblingList( pnodeAdd );

    return pnodeAdd;
}



VOID
NTree_CutNode(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Cut node from sibling B-tree.

Arguments:

    pNode -- node to cut out

Return Value:

    None.

--*/
{
    PDB_NODE        preplace;
    PDB_NODE        ptemp;
    PDB_NODE        preplaceUp;
    PDB_NODE        pnodeUp;
    PDB_NODE        pleft;
    PDB_NODE        pright;
    PDB_NODE        pParent = pNode->pParent;

    ASSERT( pNode );

    DNS_DEBUG( BTREE, (
        "NTree_CutNode(%s)\n",
        pNode->szLabel ));

    IF_DEBUG( BTREE2 )
    {
        Dbg_SiblingList(
            "Cutting node.  Node's subtree:",
            pNode );
    }
    NTree_VerifyNodeInSiblingList( pNode );

    //
    //  save pNode's links
    //

    pParent = pNode->pParent;
    ASSERT( pParent );              // can not delete root node
    pnodeUp = pNode->pSibUp;
    pleft = pNode->pSibLeft;
    pright = pNode->pSibRight;

    //
    //  if leaf node, cut it out cleanly
    //

    if ( !pleft && !pright )
    {
        preplace = NULL;
        goto FixBTreeParent;
    }

    //
    //  not a leaf -- must replace with node node in sub-tree
    //
    //  default to left side, then try right
    //

    if ( pleft )
    {
        //  step left, then go all the way right

        preplace = pleft;
        ASSERT( preplace );
        while ( ptemp = preplace->pSibRight )
        {
            preplace = ptemp;
        }
        ASSERT( preplace->pSibRight == NULL );
        preplaceUp = preplace->pSibUp;

        //
        //  replacing with immediate left child of node being cut
        //      - no right child
        //      - simply slide up to replace cut node
        //

        if ( preplaceUp == pNode )
        {
            ASSERT( preplace == pleft );

            preplace->pSibUp = pnodeUp;
            if ( pright )
            {
                preplace->pSibRight = pright;
                pright->pSibUp = preplace;
            }
            goto FixBTreeParent;
        }

        //
        //  replace with rightmost node in cut node's left subtree
        //
        //  - replace node must be right child of its parent
        //  - "pulling" replacement left up a level
        //      - point parent->right at replace->left
        //      - point replace->left->up points to parent
        //

        ASSERT( preplaceUp->pSibRight == preplace );

        ptemp = preplace->pSibLeft;
        preplaceUp->pSibRight = ptemp;
        if ( ptemp )
        {
            ptemp->pSibUp = preplaceUp;
        }
    }
    else
    {
        //  step right, then go all the way left

        preplace = pright;
        ASSERT( preplace );
        while ( ptemp = preplace->pSibLeft )
        {
            preplace = ptemp;
        }
        ASSERT( preplace->pSibLeft == NULL );
        preplaceUp = preplace->pSibUp;

        //
        //  replacing with immediate right child of node being cut
        //      - simply slide up to replace cut node
        //

        if ( preplaceUp == pNode )
        {
            ASSERT( preplace == pright );

            preplace->pSibUp = pnodeUp;
            if ( pleft )
            {
                preplace->pSibLeft = pleft;
                pleft->pSibUp = preplace;
            }
            goto FixBTreeParent;
        }

        //
        //  replace with leftmost node in cut node's right subtree
        //
        //  - replace node must be left child of its parent
        //  - "pulling" replacement right up a level
        //      - point parent->left at replace->right
        //      - point replace->right->up points to parent
        //

        ASSERT( preplaceUp->pSibLeft == preplace );

        ptemp = preplace->pSibRight;
        preplaceUp->pSibLeft = ptemp;
        if ( ptemp )
        {
            ptemp->pSibUp = preplaceUp;
        }
    }

    //
    //  drop here if replace node NOT immediate child of pNode
    //  hook replacement into pNode's place in tree
    //

    preplace->pSibUp    = pnodeUp;
    preplace->pSibLeft  = pleft;
    preplace->pSibRight = pright;

    if ( pleft )
    {
        pleft->pSibUp = preplace;
    }
    if ( pright )
    {
        pright->pSibUp = preplace;
    }

FixBTreeParent:

    //
    //  point cut node's B-tree parent at replacement node
    //      - note need this if no (NULL) replacement
    //

    if ( !pnodeUp )
    {
        //  cutting top node in tree, must replace DNS tree parent's
        //      child ptr

        ASSERT( pParent->pChildren == pNode );
        pParent->pChildren = preplace;
    }
    else if ( IS_HASH_TABLE(pnodeUp) )
    {
        //  no action -- handled by delete in hash bucket function below
    }
    else if ( pnodeUp->pSibLeft == pNode )
    {
        //  cut node was left child of B-Tree parent
        pnodeUp->pSibLeft = preplace;
    }
    else
    {
        //  cut node was right child of B-Tree parent
        ASSERT( pnodeUp->pSibRight == pNode );
        pnodeUp->pSibRight = preplace;
    }

    //
    //  one less DNS tree child
    //

    pParent->cChildren--;

    //
    //  if node was under hash table -- reset count
    //

    if ( pParent->pChildren && IS_HASH_TABLE(pParent->pChildren) )
    {
        NTree_DeleteNodeInHashBucket(
            pnodeUp,
            pNode,
            preplace );
    }

    IF_DEBUG( BTREE2 )
    {
        Dbg_SiblingList(
            "Full sibling list after cut",
            pNode->pParent->pChildren );
    }

    //
    //  verify sibling list memembers happy
    //

    if ( preplace )
    {
        NTree_VerifyNodeInSiblingList( preplace );
    }
    if ( pnodeUp )
    {
        if ( !IS_HASH_TABLE(pnodeUp) )
        {
            NTree_VerifyNodeInSiblingList( pnodeUp );
        }
    }
}



VOID
NTree_RebalanceSubtreeChildLists(
    IN OUT  PDB_NODE    pParent,
    IN      PVOID       pZone
    )
/*++

Routine Description:

    Rebalance child lists of all nodes in subtree.

    Note calls itself recursively.

Arguments:

    pParent -- parent node of subtree

    pZone -- zone to limit rebalance to

Return Value:

    None.

--*/
{
    PDB_NODE    pchild;

    ASSERT( pParent );
    IF_DEBUG( BTREE2 )
    {
        DNS_PRINT((
            "NTree_RebalanceSubtreeChildLists( %s )\n",
            pParent->szLabel ));
    }

    //
    //  if no children -- done
    //

    if ( !pParent->pChildren )
    {
        ASSERT( pParent->cChildren == 0 );
        return;
    }

    //
    //  rebalance parent node's child list first
    //      - optimize away unnecessary case to avoid even making call
    //

    if ( pParent->cChildren > 3 )
    {
        NTree_RebalanceChildList( pParent );
    }

    //
    //  recurse to rebalance children's child lists
    //

    ASSERT( pParent->cChildren && pParent->pChildren );

    pchild = NTree_FirstChild( pParent );
    ASSERT( pchild );

    while ( pchild )
    {
        NTree_RebalanceSubtreeChildLists(
            pchild,
            pZone );
        pchild = NTree_NextSiblingWithLocking( pchild );
    }
}




//
//  Subtree delete routines
//
//  Need special routines to delete all nodes in sibling list, because
//  walk functions do "in order" walk.  When we delete B-tree nodes in-order
//  we can no longer safely continue the in-order walk.
//
//  Since the full sibling list delete is ONLY used when we are deleting
//  the entire DNS subtree, under a node, these routines are coded to
//  delete all the DNS children, as we delete the nodes in the sibling
//  list.
//
//  Note, there is NO LOCKING in these routines.  Currently they are
//  used only to delete temp database used in zone transfer receive,
//  which are owned by a single thread.  If other use is made, caller
//  should get top level lock, or recode.
//

VOID
btreeDeleteSubtree(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Hard delete of B-tree subtree and their DNS tree children.

    This is used to delete temp database after zone transfer, so
        - delete RR list without dereference
        - delete all nodes, ignoring ref counts and access

Arguments:

    pNode -- B-tree root

Return Value:

    None.

--*/
{
    ASSERT( pNode );

    //
    //  delete all nodes in left subtree, including their DNS tree children
    //  then same for right subtree
    //

    if ( pNode->pSibLeft )
    {
        btreeDeleteSubtree( pNode->pSibLeft );
    }
    if ( pNode->pSibRight )
    {
        btreeDeleteSubtree( pNode->pSibRight );
    }

    //
    //  delete this node's DNS subtree
    //

    NTree_DeleteSubtree( pNode );
}



VOID
NTree_HashDeleteSubtree(
    IN      PSIB_HASH_TABLE pHash
    )
/*++

Routine Description:

    Hard delete of nodes in hash and their DNS tree children.

    This is used to delete temp database after zone transfer, so
        - delete RR list without dereference
        - delete all nodes, ignoring ref counts and access

Arguments:

    pHash -- hash containing nodes to delete

Return Value:

    None.

--*/
{
    INT             i;
    PDB_NODE        ptemp;

    ASSERT( pHash && IS_HASH_TABLE(pHash) );

    //
    //  delete all nodes (and DNS subtrees) in B-tree or hash
    //      at each hash bucket
    //

    for (i=0; i<=LAST_HASH_INDEX; i++)
    {
        ptemp = pHash->aBuckets[i];
        if ( !ptemp )
        {
            ASSERT( pHash->aBucketCount[i] == 0 );
            continue;
        }
        if ( IS_HASH_TABLE(ptemp) )
        {
            NTree_HashDeleteSubtree( (PSIB_HASH_TABLE)ptemp );
        }
        else
        {
            btreeDeleteSubtree( ptemp );
        }
    }

    //  delete hash table

    FREE_TAGHEAP( pHash, sizeof(SIB_HASH_TABLE), MEMTAG_NODEHASH );
}



VOID
NTree_DeleteSubtree(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Hard delete of node and its DNS subtree.

    This is used to delete temp database after zone transfer, so
        - delete RR list without dereference
        - delete all nodes, ignoring ref counts and access

Arguments:

    pNode -- root of subtree to delete

Return Value:

    None.

--*/
{
    PDB_NODE        pchild;

    ASSERT( pNode );

    //
    //  if children, delete all the children
    //

    pchild = pNode->pChildren;

    if ( !pchild )
    {
        ASSERT( pNode->cChildren == 0 );
    }
    else if ( IS_HASH_TABLE(pchild) )
    {
        NTree_HashDeleteSubtree( (PSIB_HASH_TABLE) pchild );
    }
    else
    {
        ASSERT( pNode->cChildren != 0 );
        btreeDeleteSubtree( pchild );
    }

    //  make sure RR list is deleted

    if ( pNode->pRRList )
    {
        RR_ListDelete( pNode );
    }

    //  delete this node itself

    NTree_FreeNode( pNode );
}

//
//  End tree.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\tree.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    tree.h

Abstract:

    Domain Name System (DNS) Server

    N-Tree definitions and declarations.
    N-Tree is used for DNS database.

Author:

    Jim Gilroy (jamesg)     Feb 25, 1995

Revision History:

    October 1996    jamesg  -   B-tree sibling list with multi-level drop
                                down hash

--*/


#ifndef _TREE_H_INCLUDED_
#define _TREE_H_INCLUDED_


#if DBG
#define TREE_ID_VALID 0xADED
#define TREE_ID_DONE 0xFFED
#endif


//
//  Implementation Note:
//
//  Domain names are stored in original case in database.  Pre RFC name
//  recovery is desirable.  Use a DWORD first four bytes downcased for
//  fast comparison -- even in huge domain this will get binary search
//  down to just a few (often no) names that need case insensitive
//  comparsion.
//
//  Using a default length for the label that encompassed most cases
//  and allows lables at this length or smaller to be stored in standard
//  sized blocks -- which simplifies memory use.
//  This standard length should be adjusted to keep the end of the
//  structure DWORD aligned.
//

#define STANDARD_NODE_LABEL_LENGTH  (15)


//
//  Tree definition
//
//  Note:  nice to dump reference count, but can not unitl another
//      way to handle update list reference issue.
//  One possibility would be a single bit.  Node stays if referenced
//  in update list at all.
//

typedef struct _DnsTreeNode
{
    struct _DnsTreeNode * pParent;      //  parent

    //  sibling B-Tree

    struct _DnsTreeNode * pSibUp;       //  sibling parent
    struct _DnsTreeNode * pSibLeft;     //  left sibling
    struct _DnsTreeNode * pSibRight;    //  right sibling

    struct _DnsTreeNode * pChildren;    //  child tree

    PVOID       pZone;                  // ptr to zone for node
    PVOID       pRRList;

    DWORD       dwCompare;              //  first four byte of name, for quick compare
    
    DWORD       dwTypeAllTtl;           //  TTL for using this node's RRs in type ALL response

    DWORD       dwContinueToParentTtl;  //  TTL for continuing up to parent if no NS can be found

    ULONG       cChildren;              //  count of children

    DWORD       dwNodeFlags;            //  flags
    
    UCHAR       uchAuthority;           //  authority, zone, delegation, outside
    UCHAR       cReferenceCount;        //  references to node

    UCHAR       uchAccessBin;           //  timeout bin of last access to node
    UCHAR       uchTimeoutBin;          //  timeout bin node is in

    UCHAR       cLabelCount;            //  label count
    UCHAR       cchLabelLength;

    CHAR        szLabel[ STANDARD_NODE_LABEL_LENGTH+1 ];

    //
    //  Variable length allocation
    //
    //  Node's with labels longer than default length, will have size
    //  allocated will that extend szLabel to accomodate NULL
    //  terminated string for its label.
    //
}
DB_NODE, *PDB_NODE;

typedef const DB_NODE  *PCDB_NODE;

#define DB_NODE_FIXED_LENGTH    ( sizeof(DB_NODE) - STANDARD_NODE_LABEL_LENGTH )

#define DB_REVERSE_ZONE_ROOT    ( &((PDB_NODE)REVERSE_TABLE)->pRRList )
#define DB_REVERSE_ZONE_DATA    ( &((PDB_NODE)REVERSE_DATA_TABLE)->pZone )

#define DB_CLEAR_TYPE_ALL_TTL( pNode )  ( ( pNode )->dwTypeAllTtl = 0 )


//
//  Tree Node Flags
//

//  Node state

#define NODE_NOEXIST            0x00000001      //  cached name error
#define NODE_THIS_HOST          0x00000002      //  DNS server's host node
#define NODE_TOMBSTONE          0x00000004      //  Node is DS-tombstoned
#define NODE_SECURE_EXPIRED     0x00000008      //  Node security info has exprired (pre- zone secure time)

//  Node database properties

#define NODE_ZONE_ROOT          0x00000010
#define NODE_CNAME              0x00000020
#define NODE_WILDCARD_PARENT    0x00000040
#define NODE_AUTH_ZONE_ROOT     0x00000100
#define NODE_ZONETREE           0x00000200

#define NODE_ADMIN_RESERVED     0x00000400
#define NODE_AVAIL_TO_AUTHUSER  0x00000800

//  Permanent properties

#define NODE_IN_TIMEOUT         0x00001000      //  node in timeout list
#define NODE_FORCE_ENUM         0x00002000
#define NODE_SELECT             0x00004000
#define NODE_NO_DELETE          0x00008000

#define NODE_FORCE_AUTH         0x00010000      //  node is authoritative even if in cache


//
//  DEVNOTE: cleanup these security check macros;
//      pretty sure they're unnecessary;  at best they should
//      be flagged here as purely temp node issues that could
//      be overloaded if necessary (better might be overloading
//      node timeout stuff, as temp nodes not queued for timeout)
//

//
//  Node property checks
//

#define IS_NOEXIST_NODE(pNode)      ( (pNode)->dwNodeFlags & NODE_NOEXIST )

#define IS_THIS_HOST_NODE(pNode)    ( (pNode)->dwNodeFlags & NODE_THIS_HOST )
#define IS_TOMBSTONE_NODE(pNode)    ( (pNode)->dwNodeFlags & NODE_TOMBSTONE )
#define IS_ZONE_ROOT(pNode)         ( (pNode)->dwNodeFlags & NODE_ZONE_ROOT )
#define IS_AUTH_ZONE_ROOT(pNode)    ( (pNode)->dwNodeFlags & NODE_AUTH_ZONE_ROOT )
#define IS_CNAME_NODE(pNode)        ( (pNode)->dwNodeFlags & NODE_CNAME )
#define IS_WILDCARD_PARENT(pNode)   ( (pNode)->dwNodeFlags & NODE_WILDCARD_PARENT )
#define IS_TIMEOUT_NODE(pNode)      ( (pNode)->dwNodeFlags & NODE_IN_TIMEOUT     )
#define IS_ENUM_NODE(pNode)         ( (pNode)->dwNodeFlags & NODE_FORCE_ENUM )
#define IS_NODE_NO_DELETE(pNode)    ( (pNode)->dwNodeFlags & NODE_NO_DELETE )
//#define IS_SELECT_NODE(pNode)       ( (pNode)->dwNodeFlags & NODE_SELECT )
#define IS_SELECT_NODE(pNode)       ( FALSE )
#define IS_ZONETREE_NODE(pNode)     ( (pNode)->dwNodeFlags & NODE_ZONETREE )
#define IS_NODE_FORCE_AUTH(pNode)   ( (pNode)->dwNodeFlags & NODE_FORCE_AUTH )

#define IS_SECURE_EXPIRED_NODE(pNode)   ( (pNode)->dwNodeFlags & NODE_SECURE_EXPIRED )

#define IS_AVAIL_TO_AUTHUSER(pNode)     ( (pNode)->dwNodeFlags & NODE_AVAIL_TO_AUTHUSER )

#define IS_SECURITY_UPDATE_NODE(pNode)  ( (pNode)->dwNodeFlags &      \
                                          ( NODE_TOMBSTONE      |    \
                                            NODE_SECURE_EXPIRED))

//
//  Node property set/clear
//

#define SET_NOEXIST_NODE(pNode)     ( (pNode)->dwNodeFlags |= NODE_NOEXIST )
#define SET_THIS_HOST_NODE(pNode)   ( (pNode)->dwNodeFlags |= NODE_THIS_HOST )
#define SET_TOMBSTONE_NODE(pNode)   ( (pNode)->dwNodeFlags |= NODE_TOMBSTONE )
#define SET_SECURE_EXPIRED_NODE(pNode)   ( (pNode)->dwNodeFlags |= NODE_SECURE_EXPIRED )
#define SET_AVAIL_TO_AUTHUSER_NODE(pNode)   ( (pNode)->dwNodeFlags |= NODE_AVAIL_TO_AUTHUSER )
#define SET_NEW_NODE(pNode)         ( (pNode)->dwNodeFlags |= NODE_NEW_ZONE )
#define SET_ZONE_ROOT(pNode)        ( (pNode)->dwNodeFlags |= NODE_ZONE_ROOT )
#define SET_AUTH_ZONE_ROOT(pNode)   ( (pNode)->dwNodeFlags |= NODE_AUTH_ZONE_ROOT )
#define SET_CNAME_NODE(pNode)       ( (pNode)->dwNodeFlags |= NODE_CNAME )
#define SET_WILDCARD_PARENT(pNode)  ( (pNode)->dwNodeFlags |= NODE_WILDCARD_PARENT )
#define SET_TIMEOUT_NODE(pNode)     ( (pNode)->dwNodeFlags |= NODE_IN_TIMEOUT )
#define SET_ENUM_NODE(pNode)        ( (pNode)->dwNodeFlags |= NODE_FORCE_ENUM )
#define SET_SELECT_NODE(pNode)      ( (pNode)->dwNodeFlags |= NODE_SELECT )
#define SET_NODE_NO_DELETE(pNode)   ( (pNode)->dwNodeFlags |= NODE_NO_DELETE )
#define SET_ZONETREE_NODE(pNode)    ( (pNode)->dwNodeFlags |= NODE_ZONETREE )
#define SET_NODE_FORCE_AUTH(pNode)  ( (pNode)->dwNodeFlags |=  NODE_FORCE_AUTH )

#define CLEAR_NOEXIST_NODE(pNode)   ( (pNode)->dwNodeFlags &= ~NODE_NOEXIST )
#define CLEAR_THIS_HOST_NODE(pNode)   ( (pNode)->dwNodeFlags &= ~NODE_THIS_HOST )
#define CLEAR_TOMBSTONE_NODE(pNode)   ( (pNode)->dwNodeFlags &= ~NODE_TOMBSTONE )
#define CLEAR_SECURE_EXPIRED_NODE(pNode)   ( (pNode)->dwNodeFlags &= ~NODE_SECURE_EXPIRED )
#define CLEAR_AVAIL_TO_AUTHUSER_NODE(pNode)   ( (pNode)->dwNodeFlags &= ~NODE_AVAIL_TO_AUTHUSER )
#define CLEAR_NEW_NODE(pNode)       ( (pNode)->dwNodeFlags &= ~NODE_NEW_ZONE )
#define CLEAR_ZONE_ROOT(pNode)      ( (pNode)->dwNodeFlags &= ~NODE_ZONE_ROOT )
#define CLEAR_AUTH_ZONE_ROOT(pNode) ( (pNode)->dwNodeFlags &= ~NODE_AUTH_ZONE_ROOT )
#define CLEAR_CNAME_NODE(pNode)     ( (pNode)->dwNodeFlags &= ~NODE_CNAME )
#define CLEAR_WILDCARD_PARENT(pNode)( (pNode)->dwNodeFlags &= ~NODE_WILDCARD_PARENT )
#define CLEAR_TIMEOUT_NODE(pNode)   ( (pNode)->dwNodeFlags &= ~NODE_IN_TIMEOUT )
#define CLEAR_ENUM_NODE(pNode)      ( (pNode)->dwNodeFlags &= ~NODE_FORCE_ENUM )
#define CLEAR_NODE_NO_DELETE(pNode) ( (pNode)->dwNodeFlags &= ~NODE_NO_DELETE )
#define CLEAR_ZONETREE_NODE(pNode)  ( (pNode)->dwNodeFlags &= ~NODE_ZONETREE )
#define CLEAR_TOMBSTONE_NODE(pNode)         ( (pNode)->dwNodeFlags &= ~NODE_TOMBSTONE )
#define CLEAR_SECURE_EXPIRED_NODE(pNode)    ( (pNode)->dwNodeFlags &= ~NODE_SECURE_EXPIRED )
#define CLEAR_ADMIN_RESERVED_NODE(pNode)    ( (pNode)->dwNodeFlags &= ~NODE_ADMIN_RESERVED )
#define CLEAR_NODE_FLAGS(pNode)         ( (pNode)->dwNodeFlags = 0 )
#define CLEAR_EXCEPT_FLAG(pNode, Flag)  ( (pNode)->dwNodeFlags &= Flag )
#define CLEAR_NODE_FORCE_AUTH(pNode)    ( (pNode)->dwNodeFlags &= NODE_FORCE_AUTH )

// clear all node security related flags
#define CLEAR_NODE_SECURITY_FLAGS(pNode)        ( (pNode)->dwNodeFlags &= (~(NODE_TOMBSTONE      |  \
                                                                            NODE_SECURE_EXPIRED) ) )


//  Flags to save on making copy of node.
//      More or less those that apply to immediate record data.
//      Key flag to remove is TIMEOUT which eliminates possibility of delete.
//

#define NODE_FLAGS_SAVED_ON_COPY \
            ( NODE_NOEXIST | NODE_CNAME | NODE_ZONE_ROOT | NODE_AUTH_ZONE_ROOT | NODE_THIS_HOST )

#define COPY_BACK_NODE_FLAGS( pNodeReal, pNodeCopy )    \
        {                                               \
            DWORD   _flags;                             \
            _flags = (pNodeReal)->dwNodeFlags;          \
            _flags &= ~NODE_FLAGS_SAVED_ON_COPY;        \
            _flags |= ((pNodeCopy)->dwNodeFlags & NODE_FLAGS_SAVED_ON_COPY);    \
            (pNodeReal)->dwNodeFlags = _flags;          \
        }


//
//  Node authority
//

#define AUTH_ZONE               (0xf2)
#define AUTH_DELEGATION         (0x43)
#define AUTH_GLUE               (0x23)
#define AUTH_OUTSIDE            (0x10)
#define AUTH_NONE               (0x00)

#define AUTH_ZONE_SUBTREE_BIT   (0x02)
#define AUTH_SUBZONE_BIT        (0x01)

//
//  In zone tree or cache
//

#define IS_ZONE_TREE_NODE(pNode)        ((pNode)->pZone)
#define IS_CACHE_TREE_NODE(pNode)       (!((pNode)->pZone))

//
//  Authority level of node in zone tree
//

#define IS_OUTSIDE_ZONE_NODE(pNode)     ((pNode)->uchAuthority == AUTH_OUTSIDE)
#define IS_AUTH_NODE(pNode)             ((pNode)->uchAuthority == AUTH_ZONE)
#define IS_DELEGATION_NODE(pNode)       ((pNode)->uchAuthority == AUTH_DELEGATION)
#define IS_GLUE_NODE(pNode)             ((pNode)->uchAuthority == AUTH_GLUE)

#define SET_AUTH_NODE(pNode)            ((pNode)->uchAuthority = AUTH_ZONE)
#define SET_DELEGATION_NODE(pNode)      ((pNode)->uchAuthority = AUTH_DELEGATION)
#define SET_GLUE_NODE(pNode)            ((pNode)->uchAuthority = AUTH_GLUE)
#define SET_OUTSIDE_ZONE_NODE(pNode)    ((pNode)->uchAuthority = AUTH_OUTSIDE)

//  Entire zone subtree including delegation -- zone root on down

#define IS_ZONE_SUBTREE_NODE(pNode)     ((pNode)->uchAuthority & AUTH_ZONE_SUBTREE_BIT)

//  In any subzone including at delegation

#define IS_SUBZONE_NODE(pNode)          ((pNode)->uchAuthority & AUTH_SUBZONE_BIT)
  

//
//  Node access
//  When we access a node set its bin to the current timeout bin.
//

extern UCHAR    CurrentTimeoutBin;

#define IS_NODE_RECENTLY_ACCESSED(pNode) \
            ( (pNode)->uchAccessBin == CurrentTimeoutBin || \
              (pNode)->uchAccessBin == (UCHAR)(CurrentTimeoutBin-1) )

#define SET_NODE_ACCESSED(pNode)    \
            ( (pNode)->uchAccessBin = CurrentTimeoutBin )


//
//  Other useful macros
//

#define NODE_ZONE( pNode )      ( ( PZONE_INFO ) ( pNode ? pNode->pZone : NULL ) )


//
//  Ptr to indicate node already cut from list.
//  This allows timeout thread reference to be cleaned up after node already cut loose
//      and no longer part of database.

#ifdef _WIN64
#define CUT_NODE_PTR            ((PVOID) (0xccffccffccffccff))
#else
#define CUT_NODE_PTR            ((PVOID) (0xccffccff))
#endif

#define IS_CUT_NODE(pNode)      ((pNode)->pSibUp == CUT_NODE_PTR)


//
//  Main lookup routine
//

PDB_NODE
NTree_FindOrCreateChildNode(
    IN OUT  PDB_NODE        pParent,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    IN      BOOL            fCreate,
    IN      DWORD           dwMemTag,
    OUT     PDB_NODE *      ppnodeFollowing
    );


//
//  Tree routines
//

PDB_NODE
NTree_Initialize(
    VOID
    );

VOID
NTree_StartFileLoad(
    VOID
    );

VOID
NTree_StopFileLoad(
    VOID
    );

PDB_NODE
NTree_CreateNode(
    IN      PCHAR       pchLabel,
    IN      PCHAR       pchDownLabel,
    IN      DWORD       cchLabelLength,
    IN      DWORD       dwMemTag            //  zero for generic node
    );

PDB_NODE
NTree_CopyNode(
    IN      PDB_NODE    pNode
    );

VOID
NTree_FreeNode(
    IN OUT  PDB_NODE    pNode
    );

BOOL
NTree_InsertChildNode(
    IN OUT  PDB_NODE    pParent,
    IN OUT  PDB_NODE    pNewNode
    );

PDB_NODE
FASTCALL
NTree_FirstChild(
    IN      PDB_NODE    pParent
    );

PDB_NODE
FASTCALL
NTree_NextSibling(
    IN      PDB_NODE    pNode
    );

PDB_NODE
FASTCALL
NTree_NextSiblingWithLocking(
    IN      PDB_NODE    pNode
    );

BOOL
NTree_RemoveNode(
    IN OUT  PDB_NODE    pNode
    );

VOID
NTree_ReferenceNode(
    IN OUT  PDB_NODE    pNode
    );

BOOL
FASTCALL
NTree_DereferenceNode(
    IN OUT  PDB_NODE    pNode
    );

VOID
NTree_DeleteSubtree(
    IN OUT  PDB_NODE    pNode
    );

#if DBG
BOOL
NTree_VerifyNode(
    IN      PDB_NODE    pNode
    );
#endif

VOID
NTree_RebalanceSubtreeChildLists(
    IN OUT  PDB_NODE    pParent,
    IN      PVOID       pZone
    );


//
//  Sibling list B-Tree
//
//  Public only for purposes of use by tree routines.
//

extern INT gcFullRebalance;

VOID
NTree_CutNode(
    IN      PDB_NODE    pNode
    );

BOOL
NTree_VerifyChildList(
    IN      PDB_NODE    pNode,
    IN      PDB_NODE    pNodeChild      OPTIONAL
    );

#if DBG
VOID
Dbg_SiblingList(
    IN      LPSTR       pszHeader,
    IN      PDB_NODE    pNode
    );
#else
#define Dbg_SiblingList(pszHeader,pNode)
#endif


//
//  Node statistics collection
//

VOID
NTree_WriteDerivedStats(
    VOID
    );


//
//  Other tree functions
//

PCHAR
NTree_GetDowncasedLabel(
    IN      PDB_NODE        pNode
    );


//
//  Internal tree structures. These definitions are in a header file 
//  only so that the DNS server debugger extension can see them. No
//  other server module should use these definitions.
//

//
//  Hash table
//

//#define LAST_HASH_INDEX     (35)
#define LAST_HASH_INDEX     (255)

#define HASH_BUCKET_MAX0    (64)        // 64 nodes in b-tree then hash

#define IS_HASH_FLAG        (0xff)

#define IS_HASH_TABLE(phash) \
        ( ((PSIB_HASH_TABLE)phash)->IsHash == (UCHAR)IS_HASH_FLAG )

#define SET_HASH_FLAG(phash) \
        ( phash->IsHash = (UCHAR)IS_HASH_FLAG )

//
//  Hash table structure
//
//  Note, the IsHash flag is set to 0xffff.
//  This position would correspond to the low byte of the pParent ptr
//  in a domain node.  Since 0xffff can never be valid as the low byte
//  of a domain node pointer, we can test domain nodes and immediate
//  see that we have a hash table rather than a B-tree root.
//

typedef struct _SibHashTable
{
    UCHAR                   IsHash;
    UCHAR                   Resv;
    UCHAR                   cLevel;
    UCHAR                   iBucketUp;
    struct _SibHashTable *  pHashUp;
    PDB_NODE                aBuckets[ LAST_HASH_INDEX+1 ];
    DWORD                   aBucketCount[ LAST_HASH_INDEX+1 ];
}
SIB_HASH_TABLE, *PSIB_HASH_TABLE;


//
//  Debug aids
//

#if DBG
#define ASSERT_NODE_NOT_LEAKED( pNode )                     \
    if ( pNode &&                                           \
         pNode->pZone == NULL &&                            \
         pNode->pChildren == NULL &&                        \
         pNode->pRRList == NULL &&                          \
         pNode->cchLabelLength > 10 )                       \
    {                                                       \
        ASSERT( IS_TIMEOUT_NODE( pNode ) );                 \
    }
#else
#define ASSERT_NODE_NOT_LEAKED( pNode )
#endif


#endif  //  _TREE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\udp.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    udp.c

Abstract:

    Receives and processes UDP DNS packets using i/o completion ports.

Author:

    Jim Gilroy,  November 1996

Revision History:

--*/

#include "dnssrv.h"

//
//  UDP completion port
//

HANDLE  g_hUdpCompletionPort;

//
//  Limit retries to protect against WSAECONNRESET nonsense
//
//  Retry on CONRESET for 10000 times then give up for unbind and
//      slow retry.
//  We retry on repeated GQCS failures at 10ms interval.
//

#define RECV_RETRY_MAX_COUNT            (10000)
#define RECV_RETRY_SLEEP_TIME           (10)

//
//  Recv counters to detect socket failures
//

DWORD   UdpRecvCount        = 0;
DWORD   LastUdpRecvTime     = 0;
DWORD   NextUdpLogTime      = 0;

#define UDP_RECV_TICK() \
        {               \
            UdpRecvCount++;                 \
            LastUdpRecvTime = DNS_TIME();   \
        }



VOID
Udp_DropReceive(
    IN OUT  PDNS_SOCKET     pContext,
    IN      UINT            Index
    )
/*++

Routine Description:

    Drop down UDP receive request.

Arguments:

    pContext -- context for socket being recieved

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    pmsg;
    DNS_STATUS      status;

    IF_DEBUG( READ2 )
    {
        DNS_PRINT((
            "Drop WSARecvFrom on socket %d (thread=%p)\n",
            pContext->Socket,
            GetCurrentThreadId() ));
    }

    //
    //  Check for service shutdown/pause.
    //

    if ( !Thread_ServiceCheck() )
    {
        DNS_DEBUG( SHUTDOWN, (
            "Udp_DropReceive detected shutdown -- returning\n" ));
        goto Done;
    }

    //  We now have multiple receives so context may already be in this state.
    //  ASSERT( pContext->State != SOCKSTATE_UDP_RECV_DOWN );

    //
    //  get DNS message buffer
    //
    //  DEVNOTE: allocation failure handling
    //

    pmsg = Packet_AllocateUdpMessage();
    IF_NOMEM( !pmsg )
    {
        ASSERT( pmsg );
        goto Done;
    }

    DNS_MSG_ASSERT_BUFF_INTACT( pmsg );

    pContext->OvlArray[Index].pMsg = pmsg;
    pContext->OvlArray[Index].WsaBuf.len = pmsg->MaxBufferLength;
    pContext->OvlArray[Index].WsaBuf.buf = ( PCHAR ) DNS_HEADER_PTR( pmsg );
    pContext->RecvfromFlags = 0;

    pmsg->Socket = pContext->Socket;

    //
    //  loop until successful WSARecvFrom() is down
    //
    //  this loop is only active while we continue to recv
    //  WSAECONNRESET or WSAEMSGSIZE errors, both of which
    //  cause us to dump data and retry;
    //
    //  note loop rather than recursion (to this function) is
    //  required to avoid possible stack overflow from malicious
    //  send
    //
    //  normal returns from WSARecvFrom() are
    //      SUCCESS -- packet was waiting, GQCS will fire immediately
    //      WSA_IO_PENDING -- no data yet, GQCS will fire when ready
    //

    while ( 1 )
    {
        DNS_ADDR            addr;

        pContext->State = SOCKSTATE_UDP_RECV_DOWN;

        ASSERT_VALID_HANDLE( pContext->Socket );
        
        DnsAddr_SetSockaddrRecvLength( &pmsg->RemoteAddr );
        
        status = WSARecvFrom(
                    pContext->Socket,
                    &pContext->OvlArray[Index].WsaBuf,
                    1,
                    &pContext->BytesRecvd,
                    &pContext->RecvfromFlags,
                    &pmsg->RemoteAddr.Sockaddr,
                    &pmsg->RemoteAddr.SockaddrLength,
                    &pContext->OvlArray[Index].Overlapped,
                    NULL );

        if ( status == ERROR_SUCCESS )
        {
            DNS_DEBUG( RECV, (
                "WSARecvFrom( %d ) completed %d bytes from %s\n",
                pContext->Socket,
                pContext->BytesRecvd,
                MSG_IP_STRING( pmsg ) ));
            pContext->fRetry = 0;
            break;
        }

        status = GetLastError();
        if ( status == WSA_IO_PENDING )
        {
            DNS_DEBUG( RECV, (
                "WSARecvFrom( %d ) WSA_IO_PENDING\n",
                pContext->Socket ));
            pContext->fRetry = 0;
            break;
        }

        //
        //  if we are doing processing here, then it means completion port
        //      should not be waking folks on these errors
        //

        ASSERT( pContext->State == SOCKSTATE_UDP_RECV_DOWN ||
                pContext->State == SOCKSTATE_DEAD );

        if ( pContext->State != SOCKSTATE_UDP_RECV_DOWN )
        {
            DWORD   state = pContext->State;

            DnsDbg_Lock();
            DNS_DEBUG( ANY, (
                "ERROR:  WSARecvFrom() failed with socket %d in state %d\n"
                "    thread = %p\n",
                pContext->Socket,
                state,
                GetCurrentThreadId() ));
            Dbg_SocketContext(
                "WSARecvFrom() failed socket in incorrect state\n"
                "    note state shown below may be altered!\n",
                pContext );
            DnsDbg_Unlock();

            if ( state == SOCKSTATE_DEAD )
            {
                ASSERT( status == WSAENOTSOCK );
                Sock_CleanupDeadSocketMessage( pContext );
            }
            ELSE_ASSERT_FALSE;

            Log_SocketFailure(
                "ERROR:  RecvFrom failure in weird state.",
                pContext,
                status );
            break;
        }

        pContext->State = SOCKSTATE_UDP_RECV_ERROR;

        DNS_DEBUG( RECV, (
            "WSARecvFrom() error %d %p\n"
            "    pContext = %p\n"
            "    socket   = %d\n"
            "    thread   = %p\n",
            status, status,
            pContext,
            pContext->Socket,
            GetCurrentThreadId() ));

        //
        //  new winsock feature returns WSAECONNRESET when last send ICMP'd
        //      - set flag to indicate retry and repost send
        //      - if over some reasonable number of retries, assume error
        //          and fall through recv failure code
        //

        if ( status == WSAECONNRESET )
        {
            DNS_DEBUG( RECV, ( "WSARecvFrom() WSAECONNRESET\n" ));
            if ( pContext->fRetry < RECV_RETRY_MAX_COUNT )
            {
                DNS_DEBUG( RECV, (
                    "WSARecvFrom( %d ) ECONNRESET (retry=%d)\n",
                    pContext->Socket,
                    pContext->fRetry ));
                pContext->fRetry++;
                STAT_INC( PrivateStats.UdpConnResets );
                continue;
            }
            DNS_DEBUG( ANY, (
                "ERROR:  unsuccessful in shaking CONNRESET in %d retries\n"
                "    Indicating recv() error on socket %d to avoid cycle on this\n"
                "    thread\n",
                pContext->fRetry,
                pContext->Socket ));

            STAT_INC( PrivateStats.UdpConnResetRetryOverflow );
        }

        //
        //  message too big
        //      - treat like truncated message
        //
        //  DEVNOTE: treat WSAEMSGSIZE like trunctated message
        //

        if ( status == WSAEMSGSIZE )
        {
            DNS_DEBUG( RECV, (
                "WSARecvFrom( %d ) EMSGSIZE (retry=%d)\n",
                pContext->Socket,
                pContext->fRetry ));

            STAT_INC( PrivateStats.UdpErrorMessageSize );
            continue;
        }

        //
        //  DEVNOTE: Plug+Play may byte us on WSARecvFrom, need to cleanup
        //      gracefully
        //  note, I believe we can return cleanly GetQueuedCompletionStatus()
        //  will get new context
        //  if add PnP event, the event handling must generate all init on
        //  socket

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, (
                "WSARecvFrom failed (%d) due to shutdown -- returning\n",
                status ));
            break;
        }

        //
        //  check for PnP delete of socket
        //  note, socket list is locked for entire time we do PnP reconfig
        //      so when GetAssociateIpAddr() returns we only have valid
        //      address if socket is still enlisted

        if ( !Sock_GetAssociatedIpAddr( pContext->Socket, &addr ) )
        {
            DNS_DEBUG( SOCKET, (
                "WSARecvFrom( %d ) failure, socket no longer enlisted\n"
                "    context ptr = %p\n",
                pContext->Socket,
                pContext ));

            Sock_CleanupDeadSocketMessage( pContext );
            break;
        }

        //
        //  recvfrom() failure with active socket
        //      - set global flag to indicate retry after timeout
        //      - log event
        //

        Packet_FreeUdpMessage( pmsg );
        STAT_INC( PrivateStats.UdpRecvFailure );
        Sock_IndicateUdpRecvFailure( pContext, status );

        DNS_PRINT((
            "ERROR: WSARecvFrom( %d ) failed = %d\n"
            "    context ptr %p\n",
            pContext->Socket,
            status,
            pContext ));

#if DBG
        DNS_LOG_EVENT(
           DNS_EVENT_RECVFROM_CALL_FAILED,
           0,
           NULL,
           NULL,
           status );
#endif
        break;
    }
    
    Done:
    
    return;
}



BOOL
Udp_RecvThread(
    IN      LPVOID  pvDummy
    )
/*++

Routine Description:

    UDP receiving thread.

    Loops waiting on sockets, recieving then processing DNS requests.

Arguments:

    pvDummy -- unused

Return Value:

    TRUE on normal service shutdown
    FALSE on socket error

--*/
{
    PDNS_SOCKET   pcontext;
    PDNS_MSGINFO  pmsg;
    DNS_STATUS    status;
    DWORD         bytesRecvd;
    LPOVERLAPPED  poverlapped = NULL;
    POVL          pCurrMsg;

    DNS_DEBUG( INIT, ( "\nStart UDP receive thread\n" ));

    //  hold off processing until started

    if ( ! Thread_ServiceCheck() )
    {
        DNS_DEBUG( ANY, ( "Terminating UDP thread\n" ));
        return( 1 );
    }

    //
    //  loop receiving and processing packets, until service shutdown
    //

    while ( TRUE )
    {
        pcontext = NULL;        //  PREFIX paranoia

        //
        //  Wait for incoming packet
        //

        if ( !GetQueuedCompletionStatus(
                    g_hUdpCompletionPort,
                    &bytesRecvd,
                    &( ULONG_PTR ) pcontext,
                    &poverlapped,
                    INFINITE ) )
        {
            DWORD   state = 0;

            status = GetLastError();

            pCurrMsg = CONTAINING_RECORD(poverlapped, OVL, Overlapped);

#if 0
            // ideal to fast path this, but avoid too much duplicate code
            //
            //  ICMP port unreachable
            //      when response is late, and client has left (hence no port)
            //      socket is indicated with conn-reset (WSARecvFrom)
            //      or port-unreachable GQCS
            //
            //  DEVNOTE: perhaps a similar error when clients IP is entirely
            //      down, should trap it also

            if ( status == ERROR_PORT_UNREACHABLE )
            {
                STAT_INC( PrivateStats.UdpGQCSConnReset );

                if ( pcontext )
                {
                    pcontext->State = SOCKSTATE_UDP_GQCS_ERROR;
                    DNS_DEBUG( SOCKET, (
                        "GQCS port-unreachable on socket %d (%p)\n"
                        "    time         = %d\n"
                        "    pcontext     = %p\n",
                        pcontext ? pcontext->Socket : 0,
                        pcontext ? pcontext->Socket : 0,
                        DNS_TIME(),
                        pcontext ));

                    //  free message (if any)
                    //  redrop recv
                    //  wait again in GQCS

                    Packet_FreeUdpMessage( pcontext->pMsg );
                    Udp_DropReceive( pcontext );
                }
                continue;
            }
#endif
            //
            //  if fail with socket context, MUST own context
            //  no other thread should own context
            //
            //  if detect another thread messing with context, then
            //  clear context -- it belongs to other guy
            //

            if ( pcontext )
            {
                LOCK_DNS_SOCKET_INFO(pcontext);
                
                state = pcontext->State;

                //
                //  winsock -- if shutdown just get outta dodge, don't
                //      expect that they haven't woken 27 threads on this socket
                //

                if ( fDnsServiceExit )
                {
                    DNS_DEBUG( SHUTDOWN, ( "Terminating UDP receive thread\n" ));

                    IF_DEBUG( ANY )
                    {
                        if ( state != SOCKSTATE_UDP_RECV_DOWN &&
                             state != SOCKSTATE_DEAD &&
                             state != SOCKSTATE_UDP_GQCS_ERROR )
                        {
                            DNS_DEBUG( ANY, (
                                "Winsock getting weird during socket shutdown:\n"
                                "    socket handle    = %d\n"
                                "    sock state       = %d\n",
                                pcontext->Socket,
                                pcontext->State ));
                        }
                    }

                    UNLOCK_DNS_SOCKET_INFO(pcontext);
                    return 1;
                }

                //  DEVNOTE: winsock has a bug waking up multiple threads on socket close
                //      so it's possible on shutdown to also have the GQCS
                //      state set by first woken thread, when second comes through
                //      hence the additional shutdown case
                //
                //      now i've also seen a bug here where state = UDP_COMPLETE which
                //      again implies that winsock has woken another thread which is
                //      processing this socket (this context);  this is handled by
                //      the second case which just bails from the context
                //

                ASSERT( state == SOCKSTATE_UDP_RECV_DOWN || state == SOCKSTATE_DEAD
                    || (fDnsServiceExit && state == SOCKSTATE_UDP_GQCS_ERROR) );

                //
                //  normal failure
                //      - signal in failed state
                //      - fall through to standard failure processing below

                if ( state == SOCKSTATE_UDP_RECV_DOWN )
                {
                    pcontext->State = SOCKSTATE_UDP_GQCS_ERROR;
                }

                //
                //  socket dead (probably via PnP)
                //      - standard cleanup

                else if ( state == SOCKSTATE_DEAD )
                {
                    Log_SocketFailure(
                        "ERROR:  GQCS failure on dead socket.",
                        pcontext,
                        status );

                    Sock_CleanupDeadSocketMessage( pcontext );
                    
                    UNLOCK_DNS_SOCKET_INFO(pcontext);
                    pcontext = NULL;
                }
                else
                {
#if 0
                    if ( fDnsServiceExit )
                    {
                        DNS_DEBUG( SHUTDOWN, ( "\nTerminating UDP receive thread\n" ));
                        return( 1 );
                    }
#endif
                    DNS_DEBUG( ANY, (
                        "ERROR:  GQCS() failed with socket %d in state %d\n"
                        "    thread = %p\n",
                        pcontext->Socket,
                        state,
                        GetCurrentThreadId() ));
                    Dbg_SocketContext(
                        "GCQS() failed socket in incorrect state\n"
                        "    note state shown below has been altered!\n",
                        pcontext );

                    Log_SocketFailure(
                        "ERROR:  GQCS failure in weird state.",
                        pcontext,
                        status );
                    ASSERT( FALSE );

                    UNLOCK_DNS_SOCKET_INFO(pcontext);
                    pcontext = NULL;
                }
            }

            //
            //  if i/o failed, check for shutdown
            //
            //  errors seen:
            //      995 (operation aborted) -- on socket close
            //      1234 (port unreachable) -- ICMP port unreachable \ WSAECONNRESET
            //

            if ( !Thread_ServiceCheck() )
            {
                DNS_DEBUG( SHUTDOWN, (
                    "\nTerminating UDP receive thread\n" ));

                if ( pcontext )
                {
                    UNLOCK_DNS_SOCKET_INFO(pcontext);
                }
                return 1;
            }
#if DBG
            //  exclude port-unreach errors from ANY print

            if ( status != ERROR_PORT_UNREACHABLE )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  GetQueuedCompletionStatus (GQCS) failed %d (%p)\n"
                    "    thread id    = %d\n"
                    "    time         = %d\n"
                    "    pcontext     = %p\n"
                    "    bytesRecvd   = %d\n",
                    status, status,
                    GetCurrentThreadId(),
                    DNS_TIME(),
                    pcontext,
                    bytesRecvd ));
                if ( pcontext )
                {
                    Dbg_SocketContext(
                        "GCQS() failure context\n",
                        pcontext );
                }
            }
#endif
            STAT_INC( PrivateStats.UdpGQCSFailure );

            //
            //  no socket context? -- continue wait on GQCS()
            //

            if ( !pcontext )
            {
                continue;
            }

            //
            //  socket context with failure
            //      - attempt to restart recv() on socket
            //      - then continue to wait on GQCS()
            //
            //  DEVNOTE: need action here -- restart all UDP sockets?
            //                  rebuild new completion port?
            //

            STAT_INC( PrivateStats.UdpGQCSFailureWithContext );

            if ( status == ERROR_PORT_UNREACHABLE )
            {
                STAT_INC( PrivateStats.UdpGQCSConnReset );
            }

            Packet_FreeUdpMessage( pCurrMsg->pMsg );

            //
            //  keep dropping recv
            //  Udp_DropReceive has code to handle the retry\giveup-unbind-retry issue
            //
            //  but avoid CPU spin, if continually banging on this go into very
            //  light (10ms) sleep to allow any other socket to run
            //

            if ( pcontext->fRetry > RECV_RETRY_MAX_COUNT )
            {
                Log_SocketFailure(
                    "ERROR:  GQCS failure forcing socket sleep.",
                    pcontext,
                    status );

                Sleep( RECV_RETRY_SLEEP_TIME );
            }
            Udp_DropReceive( pcontext, pCurrMsg->Index);
            
            UNLOCK_DNS_SOCKET_INFO(pcontext);
            continue;
        }

        //
        //  successful completion
        //

       pCurrMsg = CONTAINING_RECORD(poverlapped, OVL, Overlapped);

       if ( !pcontext )
       {
           if ( ! Thread_ServiceCheck() )
           {
               DNS_DEBUG( SHUTDOWN, ( "Terminating UDP receive thread\n" ));
               return 1;
           }
           ASSERT( FALSE );
           continue;
       }

       LOCK_DNS_SOCKET_INFO(pcontext);

        #if DBG

        //
        //  Verify that winsock has not written too many bytes to the packet.
        //

        if ( pcontext && pCurrMsg->pMsg )
        {
            if ( bytesRecvd > pCurrMsg->pMsg->MaxBufferLength )
            {
                DNS_DEBUG( ANY, (
                    "FATAL: too many bytes: %d expected max %d msg %p\n",
                    bytesRecvd,
                    pcontext->pMsg->MaxBufferLength,
                    pcontext->pMsg ));
                HARD_ASSERT( bytesRecvd <= pCurrMsg->pMsg->MaxBufferLength );
            }

            //
            //  NOTE: this is expensive!
            //

            //  HeapDbgValidateAllocList();
        }

        //  check if main thread signalling service shutdown

        if ( pcontext->State != SOCKSTATE_UDP_RECV_DOWN )
        {
            DNS_DEBUG( ANY, (
                "unexpected socket state %ul for %d %s %p\n",
                pcontext->State,
                pcontext->Socket,
                DNSADDR_STRING( &pcontext->ipAddr ),
                pcontext ));
        }
        #endif

        ASSERT( pcontext->State == SOCKSTATE_UDP_RECV_DOWN );
        pcontext->State = SOCKSTATE_UDP_COMPLETED;

        //
        //  get message info from context
        //
        //  immediately clear pMsg from context so that alternative
        //  GQCS wakeup (like socket close) will not have ptr to message
        //  in use;
        //  this should NOT be necessary, but reliablity of
        //  GQCS not to wakeup before WSARecvFrom (and hence new pMsg)
        //  is in some doubt;
        //      - there seem to be cases where it wakes up even when WSARecvFrom()
        //      fails through
        //      - also may wake up on socket close, before WSARecvFrom() reposts
        //      completion request
        //

        pmsg = pCurrMsg->pMsg;
        
        if ( !pmsg )
        {
            DNS_PRINT((
                "ERROR:  no message came back with pcontext = %p\n",
                pcontext ));
            ASSERT( FALSE );

            Udp_DropReceive( pcontext, pCurrMsg->Index);

            UNLOCK_DNS_SOCKET_INFO(pcontext);
            continue;
        }

        pCurrMsg->pMsg = NULL;
        
        pcontext->fRetry = 0;

        DNS_DEBUG( RECV2, (
            "I/O completion:\n"
            "    bytes recvd      = %d\n"
            "    overlapped       = %p\n"
            "    pcontext         = %p\n"
            "        pmsg         = %p\n"
            "        socket       = %d\n"
            "    bytes recvd      = %d\n",
            bytesRecvd,
            poverlapped,
            pcontext,
            pcontext->pMsg,
            pcontext->Socket,
            pcontext->BytesRecvd ));

        ASSERT( pmsg->Socket == pcontext->Socket );

        //  track successful recv

        UDP_RECV_TICK();


        //
        //  Check and possibly wait on service status
        //      - even if pause dump packet as now useless
        //

        if ( fDnsThreadAlert )
        {
            DNS_DEBUG( RECV, ( "\nThread alert in UDP recv thread\n" ));

            if ( ! Thread_ServiceCheck() )
            {
                DNS_DEBUG( SHUTDOWN, ( "\nTerminating UDP receive thread\n" ));
                return( 1 );
            }
            Packet_FreeUdpMessage( pmsg );
            Udp_DropReceive( pcontext, pCurrMsg->Index);

            UNLOCK_DNS_SOCKET_INFO(pcontext);
            continue;
        }

        //
        //  drop another recv on socket
        //  do this here rather than after processing -- so that if
        //  on MP machine, we can have another thread receive and
        //  process message from this socket
        //

        Udp_DropReceive( pcontext, pCurrMsg->Index);
        UNLOCK_DNS_SOCKET_INFO(pcontext);

        //
        //  Update log level.
        //

        DNSLOG_UPDATE_LEVEL();

        //
        //  received packet stats
        //

        if ( pmsg->Head.IsResponse )
        {
            STAT_INC( QueryStats.UdpResponsesReceived );
        }
        else
        {
            STAT_INC( QueryStats.UdpQueries );
            PERF_INC( pcUdpQueryReceived );
            PERF_INC( pcTotalQueryReceived );
        }

        //
        //  set info / header
        //      - set for UDP
        //      - save length
        //      - flip XID and RR count bytes
        //

        SET_MESSAGE_FIELDS_AFTER_RECV( pmsg );
        pmsg->MessageLength = ( WORD ) bytesRecvd;

        DNSMSG_SWAP_COUNT_BYTES( pmsg );

        DNSLOG_MESSAGE_RECV( pmsg );

        DNS_MSG_ASSERT_BUFF_INTACT( pmsg );

        IF_DEBUG( RECV )
        {
            Dbg_DnsMessage(
                "Received UDP packet",
                pmsg );
        }

        //  process the packet

        #if DBG
        if ( SrvCfg_fTest9 )
        {
            DNS_DEBUG( ANY, ( "fTest9: ignoring UDP packet\n" ));
        }
        else
        #endif

        Answer_ProcessMessage( pmsg );

        //
        //  for debug dump statistics every so often
        //

        IF_DEBUG( ANY )
        {
            if ( QueryStats.UdpQueries == 10 )
            {
                //  Dbg_Statistics();
            }
            if ( ! (QueryStats.UdpQueries % 10000) )
            {
                //  Dbg_Statistics();
            }
        }

        //  loop back to wait on next available message
    }
}



VOID
Udp_RecvCheck(
    VOID
    )
/*++

Routine Description:

    Check that UDP socket recv is functioning properly.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD timeDelta;

    //  no action if not logging

    if ( !SrvCfg_dwQuietRecvLogInterval )
    {
        return;
    }

    //
    //  if received packets since last check -- we're fine
    //

    if ( UdpRecvCount )
    {
        UdpRecvCount = 0;
        return;
    }

    //  reset time on startup

    if ( LastUdpRecvTime == 0 )
    {
        LastUdpRecvTime = DNS_TIME();
    }

    //
    //  test if recv quiet for a long interval
    //      - but count loggings and only log once per log interval
    //
    //  note:  none of these globals are protected by CS, so entirely
    //      possible for recv thread to reset while in this function
    //      but effect is limited to:
    //      - an extra logging, right when recv counted
    //      (RecvFailureLogCount dropped after timeDelta calculated)
    //      - or logging or faulting appropriately, but immediately
    //      after recv has reset globals (only problem is that in
    //      debugging globals won't look correct)
    //

    timeDelta = DNS_TIME() - LastUdpRecvTime;

    if ( timeDelta < SrvCfg_dwQuietRecvLogInterval ||
        DNS_TIME() < NextUdpLogTime )
    {
        return;
    }

    DNSLOG( ANY, (
        "WARNING:  No recv for %d seconds\r\n",
        timeDelta ));
    NextUdpLogTime = DNS_TIME() + SrvCfg_dwQuietRecvLogInterval;

    //
    //  quiet a REALLY long time -- fault
    //

    if ( timeDelta > SrvCfg_dwQuietRecvFaultInterval )
    {
        DNS_DEBUG( ANY, (
            "Recv quiet for longer than fault interval %d -- fault now!\n",
            SrvCfg_dwQuietRecvFaultInterval ));
        #if DBG
        HARD_ASSERT( FALSE );
        #endif
    }
}



DNS_STATUS
Udp_CreateReceiveThreads(
    VOID
    )
/*++

Routine Description:

    Setup UDP I/O and dispatch threads.

Arguments:

    None.

Return Value:

    TRUE if successful.
    FALSE if failure.

--*/
{
    PDNS_SOCKET     pcontext;
    DWORD           countUdpThreads;
    DWORD           i;
    SOCKET          s;
    HANDLE          hport;
    DWORD           status;

    //
    //  calculate number of worker threads to create
    //      - twice total processors in system (Paula Tomlison
    //      assuming so that with blocked threads (on send?), still
    //      thread to run on processor)
    //
    //  DEVNOTE: like to set number of threads limit
    //      - low  >= 2
    //      - high  above say 4 processors, processors * 80% for scaling
    //

    //
    //  setup sockets with completion port
    //  then drop initial receive on each socket
    //

    status = Sock_StartReceiveOnUdpSockets();
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        //  DEVNOTE: figure out what to do here, if started on some
        //              sockets continue
        //return( FALSE );
    }

    //
    //  dispatch UDP recv() threads
    //

    for ( i=0; i < g_ProcessorCount; i++ )
    {
        if ( ! Thread_Create(
                    "UDP Listen",
                    Udp_RecvThread,
                    (PVOID) 0,
                    0 ) )
        {
            DNS_PRINT((
                "ERROR:  failed to create UDP recv thread %d\n",
                i ));
            ASSERT( FALSE );
            return ERROR_SERVICE_NO_THREAD;
        }
    }

    return ERROR_SUCCESS;
}



VOID
Udp_ShutdownListenThreads(
    VOID
    )
/*++

Routine Description:

    Shutdown UDP listen threads.
    All threads do not necessarily terminate due to socket
    closure as they are not directly associated with a socket.

Arguments:

    None.

Return Value:

    TRUE if successful.
    FALSE if failure.

--*/
{
    HANDLE hport = g_hUdpCompletionPort;

    //  wake up threads hung in wait

    PostQueuedCompletionStatus(
        g_hUdpCompletionPort,
        0,
        0,
        NULL );

    //
    //  if allowing UDP threads to shutdown, then have concurrency issue
    //      avoiding double close or NULL close
    //  interlocked set value?

    g_hUdpCompletionPort = NULL;
    if ( !hport )
    {
        CloseHandle( hport );
    }
}

//
//  End udp.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\update.h ===
/*++

Copyright(c) 1996-1999 Microsoft Corporation

Module Name:

    update.h

Abstract:

    Domain Name System (DNS) Server

    Dynamic update definitions.

Author:

    Jim Gilroy (jamesg)     September 20, 1996

Revision History:

--*/


#ifndef _UPDATE_INCLUDED_
#define _UPDATE_INCLUDED_

//
//  Updates
//
//  For ADDs pRR points to a single record, no context to its next pointer
//  which may be in database, or further along in a delete list.
//
//  For DELETEs pRR is a list of records, since they are unowned in the
//  database, record next pointer is valid (i.e. it points to new record
//  in update/delete RR list).
//

typedef struct _DnsUpdate
{
    struct _DnsUpdate * pNext;          //  next update in list
    PDB_NODE            pNode;          //  node at which update occured
    PDB_RECORD          pAddRR;         //  RR added
    PDB_RECORD          pDeleteRR;      //  RR or RR list deleted
    DWORD               dwVersion;      //  zone version of update
    DWORD               dwFlag;
    WORD                wDeleteType;
    WORD                wAddType;
}
UPDATE, *PUPDATE;

//
//  Update operations
//
//  Standard dynamic updates are determined by interplay of
//  pAddRR, pDeleteRR and wDeleteType.
//
//  Overload wDeleteType to indicate various non-standard
//  update operations.
//

#define  UPDATE_OP_PRECON           (0xf2f2)

//  Scavenge updates

#define  UPDATE_OP_SCAVENGE         (0xf3f3)

//  Force aging updates

#define  UPDATE_OP_FORCE_AGING      (0xf4f4)

//
//  Duplicate update add
//
//  In update list, IXFR will send entire RR set after any add
//  operation.  This means it is unnecessary to send OR to keep
//  any prior add updates for same RR set -- the set is in the
//  database.  Once detected these updates can be marked, so
//  they need not be "redetected" or sent.
//

#define UPDATE_OP_DUPLICATE_ADD     (0xf5f5)

#define IS_UPDATE_DUPLICATE_ADD(pup)   \
        ( (pup)->wAddType == UPDATE_OP_DUPLICATE_ADD )

#define UPDATE_OP_NON_DUPLICATE_ADD (0xf5f6)

#define IS_UPDATE_NON_DUPLICATE_ADD(pup)   \
        ( (pup)->wDeleteType == UPDATE_OP_NON_DUPLICATE_ADD )

//
//  Rejected update
//      - mark rejected updates with opcode,
//      this prevents "empty-update" ASSERT() from firing

#define UPDATE_OP_REJECTED          (0xfcfc)


//
//  Executed update
//
//  Mark individual updates as "Executed" to avoid free
//  of pAddRR if entire update fails.  Overloading version field
//  which is fine since version field is set in zone update list
//  AND pAddRR is cleared anyway.
//

#define MARK_UPDATE_EXECUTED(pUpdate)   \
            ( (pUpdate)->dwFlag |= DNSUPDATE_EXECUTED )

#define IS_UPDATE_EXECUTED(pUpdate)     ( (pUpdate)->dwFlag & DNSUPDATE_EXECUTED )



//
//  Update list
//

typedef struct _DnsUpdateList
{
    PUPDATE     pListHead;
    PUPDATE     pCurrent;
    PDB_NODE    pTempNodeList;
    PDB_NODE    pNodeFailed;
    PVOID       pMsg;
    DWORD       Flag;
    DWORD       dwCount;
    DWORD       dwStartVersion;
    DWORD       dwHighDsVersion;
    INT         iNetRecords;
}
UPDATE_LIST, *PUPDATE_LIST;

//
//  Empty list
//

#define IS_EMPTY_UPDATE_LIST(pList)     ((pList)->pListHead == NULL)


//
//  Types of updates
//

#define DNSUPDATE_PACKET            0x00000001
#define DNSUPDATE_ADMIN             0x00000002
#define DNSUPDATE_DS                0x00000004
#define DNSUPDATE_IXFR              0x00000008
#define DNSUPDATE_AUTO_CONFIG       0x00000010
#define DNSUPDATE_SCAVENGE          0x00000020
#define DNSUPDATE_PRECON            0x00000040

//  Type properties

#define DNSUPDATE_COPY              0x00000100
#define DNSUPDATE_LOCAL_SYSTEM      0x00000200
#define DNSUPDATE_SECURE_PACKET     0x00000400
#define DNSUPDATE_NONSECURE_PACKET  0x00000800

//  Aging info

#define DNSUPDATE_AGING_ON          0x00001000
#define DNSUPDATE_AGING_OFF         0x00002000

#define DNSUPDATE_OPEN_ACL          0x00004000

#define DNSUPDATE_NEW_RECORD        0x00008000

//
//  Update completion flags
//

#define DNSUPDATE_NO_NOTIFY         0x00010000
#define DNSUPDATE_NO_INCREMENT      0x00020000
#define DNSUPDATE_ROOT_DIRTY        0x00040000
#define DNSUPDATE_NO_UNLOCK         0x00080000
#define DNSUPDATE_DS_PEERS          0x00100000

//  Tell ApplyUpdatesToDatabase to complete update

#define DNSUPDATE_COMPLETE          0x01000000

//  Tell ExecuteUpdate()

#define DNSUPDATE_ALREADY_LOCKED    0x02000000

//  Cleanup properties

#define DNSUPDATE_NO_DEREF          0x10000000

#define DNSUPDATE_EXECUTED          0x80000000

//
//  Stat update - choose correct stat struct based on update type
//

#define UPDATE_STAT_INC( pUpdateList, UpdateStatMember ) \
    ASSERT( pUpdateList ); \
    if ( !pUpdateList || pUpdateList->Flag & DNSUPDATE_PACKET ) \
        { STAT_INC( WireUpdateStats.##UpdateStatMember ); } \
    else \
        { STAT_INC( NonWireUpdateStats.##UpdateStatMember ); }

//
//  Update implementation
//
//  Still messing with best way to do this.  See update.c for detail
//  current implementation defined here, as IXFR code needs to know.

#define UPIMPL3 1


//
//  Update zone lock waits
//
//  For packet updates do not wait for zone locks
//  Admin updates can wait briefly.
//  Scavenging updates can wait quite a while, as if proceed while zone
//  still locked, you just bang into the lock on the next one.
//

#define DEFAULT_ADMIN_ZONE_LOCK_WAIT        (10000)     // 10s
#define DEFAULT_SCAVENGE_ZONE_LOCK_WAIT     (120000)    // 2 minutes


//
//  Temporary nodes used in DS update, need to hold ptr to real node
//  (need to expose for list walking in ds.c)
//

#define TNODE_MATCHING_REAL_NODE(pnodeTemp)     ((pnodeTemp)->pSibUp)

#define TNODE_NEXT_TEMP_NODE(pnodeTemp)         ((pnodeTemp)->pSibRight)

#define TNODE_WRITE_STATE(pnodeTemp)            ((pnodeTemp)->dwCompare)
#define TNODE_RECORD_CHANGE(pnodeTemp)          (TNODE_WRITE_STATE(pnodeTemp)==RRLIST_NO_MATCH)
#define TNODE_AGING_REFRESH(pnodeTemp)          (TNODE_WRITE_STATE(pnodeTemp)==RRLIST_AGING_REFRESH)
#define TNODE_AGING_OFF(pnodeTemp)              (TNODE_WRITE_STATE(pnodeTemp)==RRLIST_AGING_OFF)
#define TNODE_AGING_ON(pnodeTemp)               (TNODE_WRITE_STATE(pnodeTemp)==RRLIST_AGING_ON)

#define TNODE_FLAG(pnodeTemp)           ((pnodeTemp)->cChildren)
#define TNODE_FLAG_MASK                 0x88880000
#define TNODE_FLAG_NEW                  0x88880000
#define TNODE_FLAG_NEEDS_WRITE          0x88880001
#define TNODE_FLAG_DS_WRITTEN           0x88880010
#define TNODE_FLAG_ROLLED_BACK          0x88880100

#define IS_TNODE(pnode)                 ((TNODE_FLAG(pnode) & TNODE_FLAG_MASK) == TNODE_FLAG_MASK)

#define TNODE_NEEDS_DS_WRITE(pnode)     (TNODE_FLAG(pnode) == TNODE_FLAG_NEEDS_WRITE)
#define TNODE_SET_FOR_DS_WRITE(pnode)   (TNODE_FLAG(pnode) = TNODE_FLAG_NEEDS_WRITE)


#define IS_AGING_OPTIONS(dwFlag)        ( 0x30000000 & dwFlag )
#define IS_NO_AGING_OPTIONS(dwFlag)     ( ~IS_AGING_OPTIONS(dwFlag) )


//
//  Aging time \ calculations
//

extern DWORD    g_CurrentTimeHours;

#define AGING_ZONE_REFRESH_TIME(pZone)   \
        ( g_CurrentTimeHours - (pZone)->dwNoRefreshInterval)

#define AGING_ZONE_EXPIRE_TIME(pZone)   \
        ( g_CurrentTimeHours - (pZone)->dwNoRefreshInterval - (pZone)->dwRefreshInterval)

#define AGING_IS_RR_EXPIRED( pRR, ExpireBelowTime ) \
        ( (pRR)->dwTimeStamp < (ExpireBelowTime) && (pRR)->dwTimeStamp != 0 )

#define AGING_DOES_RR_NEED_REFRESH( pRR, RefreshBelowTime ) \
        ( (pRR)->dwTimeStamp < (RefreshBelowTime) && (pRR)->dwTimeStamp != 0 )

//
//  Scavenging
//

extern BOOL     g_bAbortScavenging;

#define Scavenge_Abort()                ( g_bAbortScavenging = TRUE )


//
//  Update type + update list routines (update.c)
//

PUPDATE_LIST
Up_InitUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList
    );

PUPDATE_LIST
Up_CreateUpdateList(
    IN      PUPDATE_LIST    pUpdateList
    );

VOID
Up_AppendUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PUPDATE_LIST    pAppendList,
    IN      DWORD           dwVersion
    );

PUPDATE
Up_CreateUpdate(
    IN      PDB_NODE        pNode,
    IN      PDB_RECORD      pAddRR,
    IN      WORD            wDeleteType,
    IN      PDB_RECORD      pDeleteRR
    );

PUPDATE
Up_CreateAppendUpdate(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNode,
    IN      PDB_RECORD      pAddRR,
    IN      WORD            wDeleteType,
    IN      PDB_RECORD      pDeleteRR
    );

PUPDATE
Up_CreateAppendUpdateMultiRRAdd(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNode,
    IN      PDB_RECORD      pAddRR,
    IN      WORD            wDeleteType,
    IN      PDB_RECORD      pDeleteRR
    );

VOID
Up_DetachAndFreeUpdate(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PUPDATE         pUpdate
    );

VOID
Up_FreeUpdatesInUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList
    );

VOID
Up_FreeUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList
    );

VOID
Up_FreeUpdateStructOnly(
    IN      PUPDATE         pUpdate
    );

PUPDATE
Up_FreeUpdateEx(
    IN      PUPDATE         pUpdate,
    IN      BOOL            fExecuted,
    IN      BOOL            fDeref
    );

BOOL
Up_IsDuplicateAdd(
    IN OUT  PUPDATE_LIST    pUpdateList,    OPTIONAL
    IN OUT  PUPDATE         pUpdate,
    IN OUT  PUPDATE         pUpdatePrev     OPTIONAL
    );

#endif // _UPDATE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\update.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    update.c

Abstract:

    Domain Name System (DNS) Server

    Dynamic update routines.

Author:

    Jim Gilroy (jamesg)     September 1996

Revision History:

--*/


#include "dnssrv.h"

//  Bring in security definitions

#define SECURITY_WIN32
#include "sspi.h"
#include "sdutl.h"

//
//  Update implementation
//

#define UPTYPE


//
//  Update queue info
//

PPACKET_QUEUE   g_UpdateQueue;
PPACKET_QUEUE   g_UpdateForwardingQueue;

//
//  Security TKEY negotiation queue
//      - security calls can block for significant time so negotiation
//      must be done outside of main threads
//

PPACKET_QUEUE   g_SecureNegoQueue;

//
//  Update validity interval
//  Note:  this MUST be kept to a value that is less than the final
//      client update timeout, otherwise the server may process an update
//      after the client has given up, and the client may try again to
//      another server (in DS case) resulting in DS replication collision
//

#define UPDATE_TIMEOUT     (15)    // 15 seconds

//
//  Buffering for writing log file
//      - twice max record insures lots of space so everything gets buffered
//

#define UPDATE_LOG_BUFFER_SIZE      (2*MAX_RECORD_FILE_WRITE)


//
//  Update log file limit
//

#define UPDATE_LOG_FILE_LIMIT   (100000)

//
//  Always keep a last few updates in update list to allow small
//  zones to do IXFR and avoid TCP connection.
//

#define MIN_UPDATE_LIST_LENGTH      (20)

#define MAX_UPDATE_LIST_LENGTH      (0x10000)   // 64k


//
//  Use RCODEs as status, so need to note highest update RCODE
//  so can distinguish non-rcode status codes.
//

#define MAX_UPDATE_RCODE    (DNS_RCODE_NOTZONE)


//
//  Flag to create records for delete
//

#define PSUEDO_DELETE_RECORD_TTL    (0xf1e2d3f0)


#define checkForEmptyUpdate( pUpdateList, pZone ) \
            ( !(pUpdateList->pListHead) )


//
//  Implementation note
//
//  Each zone has associated update list containing essentially a recent
//  history of zone changes.
//
//  There are several possibilities for representing this information.
//  Unfortunately the best -- keeping no data and identifying the RR sets
//  (node and type) is not possible because of the IXFR RFC, which
//  requires history.
//
//  Delete Data:
//
//  IXFR requires that we keep pDeleteRR.  In all cases the update pDeleteRR
//  ptr is the "final" reference to the record and it is available for delete.
//  (Under some scenarios, a previous update's pAddRR may also reference the
//  record, but it would be deleted first.)
//
//  Add Data:
//
//  Here there are essentially three choices:
//
//  1) pAddRR are independent (copies) of actual added data.
//  Advantages:
//      - fairly clean, (always free pAddRR on delete, can execute on copies)
//      - directly maps into IXFR write
//  Disadvantage
//      - eats up more memory
//      - execution essentially equivalent to two update lists
//
//  2) pAddRR are actual added records.
//  They then point either to actual list data OR to records in later
//  delete updates.
//  Advantages:
//      - no extra memory
//      - directly maps into IXFR write
//  Disadvantage
//      - update MUST be executed on real database node
//      can not execute on temporary node and copy result, as the pAddRR in
//      previous updates may be dumped;
//      so effectively update must be executed twice, at least in DS case where
//      need rollback;  this in turn requires extra complexity to make sure
//      aging data properly propagated
//
//  3) no pAddRR pointers in update list
//
//  Advantages:
//      - simplicity
//      - no extra memory
//  Disadvantages
//      - extra IXFR traffic, if touching multi-IP server
//      - a bit more complexity to maintain logging info
//
//
//  We're chosen #3.  No add pointers or records are kept.  We send complete RR sets
//  for ANY RR-set that has had an add.
//


//
//  Private protos
//

DWORD
Update_Thread(
    IN      LPVOID          Dummy
    );

DNS_STATUS
prepareUpdateListForExecution(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

BOOL
checkTempNodesForUpdateEffect(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

VOID
resetAndSuppressTempUpdatesForCompletion(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

DNS_STATUS
processNonDsUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

DNS_STATUS
processDsUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

DNS_STATUS
processDsSecureUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

BOOL
processWireUpdateMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    );

DNS_STATUS
parseUpdatePacket(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

VOID
rejectUpdateWithRcode(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           Rcode
    );

DNS_STATUS
initiateDsPeerUpdate(
    IN      PUPDATE_LIST    pUpdateList
    );

DNS_STATUS
checkDnsServerHostUpdate(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNodeReal,
    IN      PDB_NODE        pNodeTemp
    );

#if DBG
#define VALIDATE_UPDATE_LIST(plist) \
        IF_DEBUG( UPDATE )          \
        {                           \
            Up_VerifyUpdateList( plist );  \
        }

#else
#define Dbg_UpdateList(psz,plist)
#define Dbg_Update(psz,pup)
#define Up_VerifyUpdateList(plist)
#define Up_VerifyUpdate(pUp)
#define VALIDATE_UPDATE_LIST(plist)
#endif



//
//  Update list routines
//

#if DBG
VOID
Dbg_Update(
    IN      LPSTR           pszHeader,
    IN      PUPDATE         pUpdate
    )
/*++

Routine Description:

    Debug print update.

Arguments:

    pszHeader - header message to print

    pUpdate - update

Return Value:

    None

--*/
{
    DnsDebugLock();
    DnsPrintf(
        "%s\n"
        "    ptr          = %p\n"
        "    version      = %d\n"
        "    pNode        = %p (%s) %s\n"
        "    pAdd RR      = %p (type=%d)\n"
        "    add type     = %d\n"
        "    pDelete RR   = %p (type=%d)\n"
        "    delete type  = %d\n"
        "    pNext        = %p\n",
        pszHeader ? pszHeader : "Update:",
        pUpdate,
        pUpdate->dwVersion,
        pUpdate->pNode,
        (pUpdate->pNode)
            ?   pUpdate->pNode->szLabel
            :   NULL,
        (pUpdate->pNode && IS_TNODE(pUpdate->pNode))
            ?   "[Temp]"
            :   "",
        pUpdate->pAddRR,
        (pUpdate->pAddRR)
            ?   pUpdate->pAddRR->wType
            :   0,
        pUpdate->wAddType,
        pUpdate->pDeleteRR,
        (pUpdate->pDeleteRR)
            ?   pUpdate->pDeleteRR->wType
            :   0,
        pUpdate->wDeleteType,
        pUpdate->pNext );


    if ( pUpdate->pAddRR )
    {
        Dbg_DbaseRecord( "    Add RR:", pUpdate->pAddRR );
    }
    if ( pUpdate->pDeleteRR )
    {
        PDB_RECORD prr = pUpdate->pDeleteRR;
        while ( prr )
        {
            Dbg_DbaseRecord( "    Delete RR:", prr );
            prr = NEXT_RR(prr);
        }
    }

    DnsDebugUnlock();
}


VOID
Dbg_UpdateList(
    IN      LPSTR           pszHeader,
    IN      PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Debug print update list.

Arguments:

    pszHeader - header message to print

    pUpdateList - update list

Return Value:

    None

--*/
{
    PUPDATE     pupdate;

    DnsDebugLock();
    DnsPrintf(
        "%s\n"
        "    list ptr     = %p\n"
        "    flag         = %p\n"
        "    count        = %d\n"
        "    head         = %p\n"
        "    tail         = %p\n"
        "    pMsg         = %p\n"
        "    net records  = %d\n",
        pszHeader ? pszHeader : "Update List:",
        pUpdateList,
        pUpdateList->Flag,
        pUpdateList->dwCount,
        pUpdateList->pListHead,
        pUpdateList->pCurrent,
        pUpdateList->pMsg,
        pUpdateList->iNetRecords );

    pupdate = (PUPDATE) pUpdateList;

    while ( pupdate = pupdate->pNext )
    {
        Dbg_Update( "--Update", pupdate );
    }

    if ( pUpdateList->pTempNodeList )
    {
        PDB_NODE    pnodeTemp;

        DnsPrintf(
            "--Temporary node list:\n" );

        for ( pnodeTemp = pUpdateList->pTempNodeList;
              pnodeTemp != NULL;
              pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp) )
        {
            PDB_NODE pnodeReal = TNODE_MATCHING_REAL_NODE(pnodeTemp);
            DnsPrintf(
                "    temp node %s (%p) (f=%p) (w=%p) for real node %s (%p)\n",
                pnodeTemp->szLabel,
                pnodeTemp,
                TNODE_FLAG(pnodeTemp),
                TNODE_WRITE_STATE(pnodeTemp),
                pnodeReal->szLabel,
                pnodeReal );
        }
    }
    DnsPrintf(
        "--- End Update List ---\n" );

    DnsDebugUnlock();
}



BOOL
Up_VerifyUpdate(
    IN      PUPDATE         pUpdate
    )
/*++

Routine Description:

    Verify validity of update.

Arguments:

    pUpdate - update

Return Value:

    TRUE if valid
    FALSE if invalid

--*/
{
    if ( !pUpdate )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    //
    //  verify pUpdate memory
    //      - valid heap
    //      - UPDATE tag
    //      - adequate length
    //      - not on free list
    //

    if ( !Mem_VerifyHeapBlock(
                pUpdate,
                MEMTAG_UPDATE,
                sizeof(UPDATE) ) )
    {
        DNS_PRINT((
            "\nERROR:  Update at %p, failed mem check!!!\n",
            pUpdate ));
        ASSERT( FALSE );
        return FALSE;
    }

    ASSERT( !IS_ON_FREE_LIST(pUpdate) );

    //
    //  validate update record lists
    //

    if ( pUpdate->pAddRR )
    {
#if 0
        //  we seem to hit this on SOA replace updates
        //  where the SOA in the update has already been
        //  dumped into a SLOW_FREE

        RR_ListVerifyDetached(
            pUpdate->pAddRR,
            pUpdate->wAddType,
            0       // no required source
            );
#endif
    }
    if ( pUpdate->pDeleteRR )
    {
        RR_ListVerifyDetached(
            pUpdate->pDeleteRR,
            (WORD) ((pUpdate->wDeleteType >= DNS_TYPE_ALL) ? 0 : pUpdate->wDeleteType),
            0       // no required source
            );
    }

    //  validate update node

    RR_ListVerify( pUpdate->pNode );

    //  should always have something in there

    if ( !pUpdate->pAddRR  &&
         ! pUpdate->pDeleteRR  &&
         ! pUpdate->wAddType  &&
         ! pUpdate->wDeleteType )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    return TRUE;
}



BOOL
Up_VerifyUpdateList(
    IN      PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Verify validity of update list.

Arguments:

    pUpdateList - update list

Return Value:

    TRUE if valid
    FALSE if invalid

--*/
{
    PUPDATE     pupdate;
    PUPDATE     pback;

    //
    //  empty list?
    //

    if ( pUpdateList->dwCount == 0
        || pUpdateList->pListHead == NULL
        || pUpdateList->pCurrent == NULL )
    {
        if ( pUpdateList->dwCount != 0
            || pUpdateList->pListHead != NULL
            || pUpdateList->pCurrent != NULL )
        {
            Dbg_UpdateList( "ERROR:  Invalid empty update list:", pUpdateList );
            ASSERT( FALSE );
            return FALSE;
        }
        return TRUE;
    }

    //
    //  one entry
    //

    if ( pUpdateList->dwCount == 1
        || pUpdateList->pListHead == pUpdateList->pCurrent )
    {
        if ( pUpdateList->dwCount != 1
            || pUpdateList->pListHead != pUpdateList->pCurrent )
        {
            Dbg_UpdateList( "ERROR:  Invalid single value update list:", pUpdateList );
            ASSERT( FALSE );
            return FALSE;
        }
        Up_VerifyUpdate( pUpdateList->pListHead );
        return TRUE;
    }

    //
    //  anything else, just walk it to make sure it is valid
    //

    pback = (PUPDATE) pUpdateList;

    while ( pupdate = pback->pNext )
    {
        Up_VerifyUpdate(pupdate);
        pback = pupdate;
    }

    if ( pback != pUpdateList->pCurrent )
    {
        Dbg_UpdateList( "ERROR:  Invalid tail of update list:", pUpdateList );
        ASSERT( FALSE );
        return FALSE;
    }
    return TRUE;
}
#endif



PUPDATE_LIST
Up_InitUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Initialize update list.

Arguments:

    pUpdateList - update list

Return Value:

    Returns a pointer to initialized update list.
    (good for returning ptrs to update list from the call stack)

--*/
{
    RtlZeroMemory(
        pUpdateList,
        sizeof(UPDATE_LIST) );
    return pUpdateList;
}



PUPDATE_LIST
Up_CreateUpdateList(
    IN      PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Create (allocate) and update list.

Arguments:

    None

Return Value:

    New update list.
    NULL on allocation failure.

--*/
{
    PUPDATE_LIST    pnewList;

    //
    //  allocate update list, then init
    //

    pnewList = (PUPDATE_LIST) ALLOC_TAGHEAP( sizeof(UPDATE_LIST), MEMTAG_UPDATE_LIST );
    IF_NOMEM( !pnewList )
    {
        return NULL;
    }

    //  if given, make copy
    //  otherwise init

    if ( pUpdateList )
    {
        RtlCopyMemory(
            pnewList,
            pUpdateList,
            sizeof(UPDATE_LIST) );
    }
    else
    {
        Up_InitUpdateList( pnewList );
    }

    return pnewList;
}



VOID
Up_CleanAndVersionPostUpdate(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      DWORD           dwVersion
    )
/*++

Routine Description:

    Cleans up after update execution.

Arguments:

    pUpdateList - update list to append to

    dwVersion - zone version of updates

Return Value:

    None

--*/
{
    register    PUPDATE pup;

    ASSERT( pUpdateList );

    VALIDATE_UPDATE_LIST( pUpdateList );

    //
    //  set version in new updates
    //
    //  DEVNOTE: some sort of counting heuristic?
    //

    pup = (PUPDATE) pUpdateList;
    while ( pup = pup->pNext )
    {
#ifdef UPIMPL3
        pup->pAddRR = NULL;
#endif
        pup->dwVersion = dwVersion;
    }
}



VOID
Up_AppendUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PUPDATE_LIST    pAppendList,
    IN      DWORD           dwVersion
    )
/*++

Routine Description:

    Append one update list to another.

    Sets zone version in updates being appended.  This is not done while
    updates are built or executed as may not know final resting serial of
    zone after update for SOA changes \ DS read cases.

Arguments:

    pUpdateList - update list to append to

    pAppendList - update list to append

    dwVersion - zone version of updates

Return Value:

    None

--*/
{
    register    PUPDATE pup;

    ASSERT( pUpdateList && pAppendList );

    VALIDATE_UPDATE_LIST( pAppendList );

    //
    //  no-op if nothing to append
    //

    if ( !pAppendList->pListHead )
    {
        ASSERT( !pAppendList->pCurrent );
        return;
    }
    ASSERT( pAppendList->pCurrent );

    //
    //  set version in new updates
    //      - need to have this while this is used by IXFR
    //      to version each add\delete pass
    //
    //  DEVNOTE: some sort of counting heuristic?
    //

    pup = (PUPDATE) pAppendList;
    while ( pup = pup->pNext )
    {
        pup->dwVersion = dwVersion;
    }

    //
    //  add update count
    //

    pUpdateList->dwCount += pAppendList->dwCount;

    //
    //  empty list
    //

    if ( !pUpdateList->pListHead )
    {
        ASSERT( !pUpdateList->pCurrent );
        pUpdateList->pListHead  = pAppendList->pListHead;
        pUpdateList->pCurrent   = pAppendList->pCurrent;
    }

    //
    //  not empty, just whack append list onto end
    //

    else
    {
        ASSERT( pUpdateList->pCurrent );

        pUpdateList->pCurrent->pNext = pAppendList->pListHead;
        pUpdateList->pCurrent = pAppendList->pCurrent;

        VALIDATE_UPDATE_LIST( pUpdateList );
    }

    //  clear appended list
    //  need to do this for update lists, where temp list will be sent
    //      to list free function to free temp nodes
    //  can NOT do reinit of update list because still need to keep temp
    //      node list around for final delete (unless we decide to do that
    //      here also -- one reason not to is modest perf boost in getting
    //      to unlock)

    pAppendList->pListHead = NULL;
    pAppendList->pCurrent = NULL;
    pAppendList->dwCount = 0;
}



PUPDATE
Up_CreateUpdate(
    IN      PDB_NODE        pNode,
    IN      PDB_RECORD      pAddRR,
    IN      WORD            wDeleteType,
    IN      PDB_RECORD      pDeleteRR
    )
/*++

Routine Description:

    Create UPDATE entry.

Arguments:

    pNode - node where update occurred

    pAddRR - update RR added

    wDeleteType - delete type

    pDeleteRR - update RR or RR list deleted

Return Value:

    Ptr to update list.
    NULL on allocation error.

--*/
{
    PUPDATE pupdate;

    //
    //  allocate update
    //

    pupdate = (PUPDATE) ALLOC_TAGHEAP( sizeof(UPDATE), MEMTAG_UPDATE );
    IF_NOMEM( !pupdate )
    {
        return NULL;
    }

    //
    //  bump reference count of node to prevent delete
    //

    NTree_ReferenceNode( pNode );

    //
    //  set node and RRs
    //

    pupdate->pNext          = NULL;
    pupdate->pNode          = pNode;
    pupdate->pAddRR         = pAddRR;
    pupdate->pDeleteRR      = pDeleteRR;
    pupdate->dwVersion      = 0;
    pupdate->dwFlag         = 0;
    pupdate->wAddType       = 0;
    pupdate->wDeleteType    = wDeleteType;

    IF_DEBUG( UPDATE2 )
    {
        Dbg_Update(
            "New update:",
            pupdate );
    }

    //
    //  Conditional breakpoint if node name matches break name, or if the
    //  break name is "..ALL".
    //

    if ( pNode &&
        pNode->pZone &&
        ( ( PZONE_INFO ) pNode->pZone )->pszBreakOnUpdateName )
    {
        PZONE_INFO  pZone = ( PZONE_INFO ) pNode->pZone;
        LPSTR       pszBreakOnUpdateName =
                        ( ( PZONE_INFO ) pNode->pZone )->pszBreakOnUpdateName;

        if ( strcmp( pszBreakOnUpdateName, "..ALL" ) == 0 ||
             _stricmp( pszBreakOnUpdateName, pNode->szLabel ) == 0 )
        {
            DNS_PRINT(( "HARD BREAK: " 
                DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE
                " \"%s\" in zone %s\n",
                pszBreakOnUpdateName,
                (( PZONE_INFO ) pNode->pZone )->pszZoneName ));
            DebugBreak();
        }
    }
    
    return pupdate;
}   //  Up_CreateUpdate



PUPDATE
Up_CreateAppendUpdate(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNode,
    IN      PDB_RECORD      pAddRR,
    IN      WORD            wDeleteType,
    IN      PDB_RECORD      pDeleteRR
    )
/*++

Routine Description:

    Create UPDATE entry and append to update list.

Arguments:

    pUpdateList - update list

    pNode - node where update occurred

    pAddRR - update RR added

    wDeleteType - delete type

    pDeleteRR - update RR or RR list deleted

Return Value:

    Ptr to update list.
    NULL on allocation error.

--*/
{
    PUPDATE pupdate;

    //
    //  create update
    //

    pupdate = Up_CreateUpdate(
                pNode,
                pAddRR,
                wDeleteType,
                pDeleteRR );
    IF_NOMEM( !pupdate )
    {
        return NULL;
    }

    //
    //  append to list, inc update count
    //

    if ( pUpdateList->pCurrent )
    {
        pUpdateList->pCurrent->pNext = pupdate;
        pUpdateList->pCurrent = pupdate;
    }
    else
    {
        ASSERT( pUpdateList->pListHead == NULL );

        pUpdateList->pListHead = pupdate;
        pUpdateList->pCurrent = pupdate;
    }

    pUpdateList->dwCount++;

    VALIDATE_UPDATE_LIST( pUpdateList );
    return pupdate;
}   //  Up_CreateAppendUpdate



PUPDATE
Up_CreateAppendUpdateMultiRRAdd(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNode,
    IN      PDB_RECORD      pAddRR,
    IN      WORD            wDeleteType,
    IN      PDB_RECORD      pDeleteRR
    )
/*++

Routine Description:

    Create UPDATE entry and append to update list.

    Same as above except for multiple RRs in pAddRR
    These are not currently supported in updates, hence must
    break into individual update blobs.

Arguments:

    pUpdateList - update list

    pNode - node where update occurred

    pAddRR - update RR added

    wDeleteType - delete type

    pDeleteRR - update RR list deleted (currently unsupported)

Return Value:

    Ptr to update list.
    NULL on allocation error.

--*/
{
    PUPDATE     pupdate = NULL;
    PDB_RECORD  prrNext;

    ASSERT( pNode && !pDeleteRR );

    //
    //  create individual updates for all these updates
    //      - first Add creates update with wDeleteType making it a replace
    //      - remaining Adds are just plain adds
    //
    //  problem is update list keep pAddRR as ptrs to actual RRs
    //      IN the database;  to fix need to process
    //
    //  DEVNOTE: multi RR add problem
    //
    //      note:  one solution would be special casing update to
    //      indicate replace;  these would get copy and be stored
    //      as copy;
    //
    //      note how this problem stems from having to maintain history
    //      list, hence ultimately from IXFR RFC
    //

    if ( pAddRR )
    {
        prrNext = pAddRR->pRRNext;
        pAddRR->pRRNext = NULL;

        pupdate = Up_CreateAppendUpdate(
                    pUpdateList,
                    pNode,
                    pAddRR,
                    wDeleteType,
                    NULL );

        while ( prrNext )
        {
            pAddRR = prrNext;
            prrNext = prrNext->pRRNext;
            pAddRR->pRRNext = NULL;

            Up_CreateAppendUpdate(
                pUpdateList,
                pNode,
                pAddRR,
                0,
                NULL );
        }
    }

    return pupdate;
}   //  Up_CreateAppendUpdateMultiAddRR



VOID
Up_DetachAndFreeUpdateGivenPrevious(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PUPDATE         pUpdatePrevious,
    IN OUT  PUPDATE         pUpdateDelete
    )
/*++

Routine Description:

    Remove update from update list, and delete it.

Arguments:

    pUpdateList - update list

    pUpdatePrevious - previous update in list

    pUpdate - update to delete from list

Return Value:

    None

--*/
{
    PUPDATE     pnext;

    //  can not validate this update list as it legitimately may
    //  have no-ops -- which we are now catching with validation function
    // VALIDATE_UPDATE_LIST( pUpdateList );

    //
    //  hack update from list
    //

    pnext = pUpdateDelete->pNext;
    pUpdatePrevious->pNext = pnext;

    //
    //  fix up update list parameters
    //      - dec count
    //      - if deleting list head, new list head written automatically
    //          by statement above
    //      - but need to special case pCurrent field
    //

    pUpdateList->dwCount--;

    if ( pUpdateList->pCurrent == pUpdateDelete )
    {
        pUpdateList->pCurrent = pUpdatePrevious;
        if( pUpdatePrevious == (PUPDATE) pUpdateList )
        {
            ASSERT( pUpdateList->pListHead == NULL && pUpdateList->dwCount == 0 );
            pUpdateList->pCurrent = NULL;
        }
    }

    Up_FreeUpdateEx(
        pUpdateDelete,
        pUpdateList->Flag & DNSUPDATE_EXECUTED,     // already executed?
        TRUE                                        // deref update nodes
        );

    //  can not validate this update list as it legitimately may
    //  have no-ops -- which we are now catching with validation function
    //  even after detach, there may be update further down in the list
    //  which is not kosher
    //
    // VALIDATE_UPDATE_LIST( pUpdateList );

}



VOID
Up_DetachAndFreeUpdate(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PUPDATE         pUpdate
    )
/*++

Routine Description:

    Remove update from update list, and delete it.

Arguments:

    pUpdateList - update list

    pUpdate - update to delete from list

Return Value:

    None

--*/
{
    PUPDATE     pcheck;
    PUPDATE     pback;

    //
    //  loop through list until find update, then hack it out and free it
    //

    pback = (PUPDATE) pUpdateList;

    while ( pcheck = pback->pNext )
    {
        if ( pcheck == pUpdate )
        {
            Up_DetachAndFreeUpdateGivenPrevious(
                pUpdateList,
                pback,
                pcheck );
            return;
        }
        pback = pcheck;
    }

    //  assuming this is only called when update actually in list

    ASSERT( FALSE );
}



VOID
Up_FreeUpdateStructOnly(
    IN      PUPDATE     pUpdate
    )
/*++

Routine Description:

    Free UPDATE structures.

Arguments:

    pUpdate - update to be freed

Return Value:

    None.

--*/
{
    FREE_TAGHEAP( pUpdate, sizeof(UPDATE), MEMTAG_UPDATE );
}   //  Up_FreeUpdateStructOnly



PUPDATE
Up_FreeUpdateEx(
    IN      PUPDATE         pUpdate,
    IN      BOOL            fExecuted,
    IN      BOOL            fDeref
    )
/*++

Routine Description:

    Free UPDATE struct and substructures.

Arguments:

    pUpdate -- update to be freed

    fExecuted -- TRUE if update has been applied to zone
        in that case do NOT delete ADD records

    fDeref -- deref the node (default behavior only time
        you don't do this is on temp node

Return Value:

    Ptr to next update in list.

--*/
{
    register    PDB_RECORD  prr;
    PUPDATE     pnextUpdate;

    DNS_DEBUG( UPDATE, (
        "Up_FreeUpdateEx( %p, executed=%d, deref=%d )\n",
        pUpdate,
        fExecuted,
        fDeref ));

    //
    //  free records
    //      - ADD RRs only deleted if NOT executed update
    //          executed ADD RRs are either
    //              - in temp node
    //              - in active zone node
    //              - in delete RR list of later zone update
    //      - DELETE RRs always free
    //

    prr = pUpdate->pAddRR;
    if ( prr  &&  !IS_UPDATE_EXECUTED(pUpdate) )
    {
        RR_ListFree( prr );
    }

    prr = pUpdate->pDeleteRR;
    if ( prr )
    {
        RR_ListFree( prr );
    }

    //  dereference node
    //      make sure we deref real nodes only

    if ( fDeref )
    {
        PDB_NODE pnode = pUpdate->pNode;
        if ( IS_TNODE(pnode) )
        {
            pnode = TNODE_MATCHING_REAL_NODE( pnode );
        }
        NTree_DereferenceNode( pnode );
    }

    //  delete update struct
    //      first saving ptr to next update

    pnextUpdate = pUpdate->pNext;

    FREE_TAGHEAP( pUpdate, sizeof(UPDATE), MEMTAG_UPDATE );

    return pnextUpdate;
}   //  Up_FreeUpdateEx



VOID
Up_FreeUpdatesInUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Free updates in list.
    Deletes update RRs and derefs nodes depending on
    update list properties.

    Note, there's no cleanup of update list block itself.
    If user is going to reuse, they must re-init.

Arguments:

    pUpdateList -- update list to free

Return Value:

    None

--*/
{
    PUPDATE     pupdate;
    PUPDATE     pupdateNext;
    PDB_RECORD  prr;
    PDB_RECORD  prrNext;
    DWORD       deleteCount;
    PDB_NODE    pnodeTemp;
    PDB_NODE    pnodeTempNext;
    BOOL        fexecuted;
    BOOL        fderef;


    DNS_DEBUG( UPDATE, (
        "Up_FreeUpdatesInUpdateList( %p )\n",
        pUpdateList ));

    if ( pUpdateList == NULL )
    {
        return;
    }
    IF_DEBUG( UPDATE )
    {
        Up_VerifyUpdateList( pUpdateList );
    }

    //
    //  delete updates
    //      - free delete RRs in update
    //      - frees add RRs if NOT executed update
    //      - deref node according to flag;  it can be turned
    //      off when dumping list of dead zone tree
    //

    fexecuted = (pUpdateList->Flag & DNSUPDATE_EXECUTED);
    fderef = !(pUpdateList->Flag & DNSUPDATE_NO_DEREF);

    pupdate = pUpdateList->pListHead;

    while( pupdate )
    {
        pupdate = Up_FreeUpdateEx(
                    pupdate,
                    fexecuted,
                    fderef );
    }

    //
    //  walk temp node list deleting temp nodes
    //
    //  note these may contain mixtures of records copied from real node
    //  and those copied from records built from update packet, but all
    //  the records are copies
    //

    pnodeTemp = pUpdateList->pTempNodeList;

    while ( pnodeTemp )
    {
        pnodeTempNext = TNODE_NEXT_TEMP_NODE(pnodeTemp);

        //  DEVNOTE: verify match with real database node
        //      (if update was successful)

        //  delete temp node
        //      - first record list
        //      - then node itself

        RR_ListFree( pnodeTemp->pRRList );
        NTree_FreeNode( pnodeTemp );

        pnodeTemp = pnodeTempNext;
    }

    DNS_DEBUG( UPDATE, (
        "Leaving Up_FreeUpdatesInUpdateList( %p )\n",
        pUpdateList ));

    return;
}



VOID
Up_FreeUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Free update list.

Arguments:

    pUpdateList -- update list to free

Return Value:

    None

--*/
{
    DNS_DEBUG( UPDATE, (
        "Up_FreeUpdateList( %p )\n",
        pUpdateList ));

    Up_FreeUpdatesInUpdateList( pUpdateList );

    FREE_HEAP( pUpdateList );
}



BOOL
Up_SetUpdateListSerial(
    IN OUT  PZONE_INFO      pZone,
    IN      PUPDATE         pUpdate
    )
/*++

Routine Description:

    Set update list zone serial numbers.

Arguments:

    pZone -- ptr to zone

    pUpdate -- ptr to head of update list

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    while ( pUpdate != NULL )
    {
        pUpdate->dwVersion = pZone->dwSerialNo;

        pUpdate = pUpdate->pNext;   // next update record
    }
    return TRUE;
}



//
//  Zone update list routines
//

DNS_STATUS
Up_LogZoneUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN      PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Log new updates for this zone.

Arguments:

    pZone -- ptr to zone

    pUpdateList -- ptr to update list

Return Value:

    ERROR_SUCCESS if successful
    ErrorCode on failure.

--*/
{
    PUPDATE     pupdate;
    PDB_NODE    pnodeWrite;
    PDB_NODE    pnodePrevious = NULL;
    PDB_RECORD  prr;
    BOOL        fadd;
    HANDLE      hfile;
    LONG        count;
    BUFFER      buffer;
    CHAR        data[ UPDATE_LOG_BUFFER_SIZE ];
    CHAR        sourceBuf[ 50 ];
    PCHAR       psource;
    DWORD       flag;

    DNS_DEBUG( UPDATE, (
        "Up_LogZoneUpdate( zone=%s )\n",
        pZone->pszZoneName ));

    //
    //  allow folks not to log updates
    //      -- at a minimum, need to allow for DS integrated case
    //

    if ( !pZone->fLogUpdates )
    {
        return ERROR_SUCCESS;
    }

    //
    //  don't log incoming DS updates, only originating updates
    //

    if ( pZone->fDsIntegrated && ( pUpdateList->Flag & DNSUPDATE_DS ) )
    {
        DNS_DEBUG( UPDATE, ( "Skip logging of DS update\n" ));
        return ERROR_SUCCESS;
    }

    //
    //  if update log file NOT open -- open it
    //

    hfile = pZone->hfileUpdateLog;

    if ( !hfile )
    {
        WCHAR  wslogName[ MAX_PATH + 20 ];

        ASSERT( IS_ZONE_PRIMARY(pZone) );

        //
        //  if no log file name, create it
        //

        if ( !pZone->pwsLogFile )
        {
            if ( pZone->pszDataFile )
            {
                wcscpy( wslogName, pZone->pwsDataFile );
                wcscat( wslogName, L".log" );
            }
            else
            {
                wcscpy( wslogName, pZone->pwsZoneName );
                wcscat( wslogName, L".dns.log" );
            }
            DNS_DEBUG( UPDATE, (
                "Created new zone log file %S\n",
                wslogName ));

            pZone->pwsLogFile = Dns_StringCopyAllocate_W(
                                    wslogName,
                                    0 );
            if ( !pZone->pwsLogFile )
            {
                goto Failed;
            }
        }

        //  create file path

        if ( !File_CreateDatabaseFilePath(
                    wslogName,
                    NULL,
                    pZone->pwsLogFile ) )
        {
            //  should have checked all names when read in boot file
            //  or entered by admin

            ASSERT( FALSE );
            goto Failed;
        }

        //  open log file -- append

        hfile = OpenWriteFileEx(
                    wslogName,
                    TRUE );     // append
        if ( !hfile )
        {
            DNS_PRINT((
                "ERROR:  Unable to open update log file %S\n",
                wslogName ));
            goto Failed;
        }
        pZone->hfileUpdateLog = hfile;
    }

    //  setup empty buffer

    InitializeFileBuffer(
        & buffer,
        data,
        UPDATE_LOG_BUFFER_SIZE,
        hfile );

    //
    //  write update
    //      - determine update source
    //      - first zone version
    //      - then ADD/DELETE for RR
    //      - then each RR in update
    //

    flag = pUpdateList->Flag;
    if ( flag & DNSUPDATE_PACKET )
    {
        CHAR    szaddr[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

        DnsAddr_WriteIpString_A(
            szaddr,
            & ( ( PDNS_MSGINFO ) ( pUpdateList->pMsg ) )->RemoteAddr );

        sprintf(
            sourceBuf,
            "PACKET %s",
            szaddr );
        psource = sourceBuf;
    }
    else if ( flag & DNSUPDATE_SCAVENGE )
    {
        psource = "SCAVENGE";
    }
    else if ( flag & DNSUPDATE_DS )
    {
        psource = "DIRECTORY";
    }
    else if ( flag & DNSUPDATE_IXFR )
    {
        psource = "IXFR";
    }
    else if ( flag & DNSUPDATE_ADMIN )
    {
        psource = "ADMIN";
    }
    else if ( flag & DNSUPDATE_AUTO_CONFIG )
    {
        psource = "AUTO_CONFIG";
    }
    else
    {
        ASSERT( FALSE );
        psource = "UNKNOWN";
    }

    FormattedWriteToFileBuffer(
        &buffer,
        "\r\n"
        "$SOURCE  %s\r\n"
        "$VERSION %d\r\n",
        psource,
        pZone->dwSerialNo );

    //  fadd indicates previous write of update $ADD or $DELETE, start
    //  to force write (set so neither thinks it was last written)

    fadd = (BOOL)(-1);
    pnodePrevious = NULL;
    count = 0;

    for ( pupdate = pUpdateList->pListHead;
          pupdate != NULL;
          pupdate = pupdate->pNext )
    {
        count++;
        pupdate->dwVersion = pZone->dwSerialNo;

        //  need to write node?
        //  if same as previous just default it

        pnodeWrite = pupdate->pNode;
        if ( pnodeWrite == pnodePrevious )
        {
            pnodeWrite = NULL;
        }
        else
        {
            pnodePrevious = pnodeWrite;
        }
        if ( !pnodePrevious )
        {
            ASSERT( pnodePrevious );
            continue;
        }

        //
        //  delete
        //      - may be multiple delete records
        //      - if fail to write (bogus record), simply continue
        //

        prr = pupdate->pDeleteRR;
        if ( prr )
        {
            if ( fadd != FALSE )
            {
                FormattedWriteToFileBuffer( &buffer, "$DELETE\r\n" );
                fadd = FALSE;
            }
            do
            {
                if ( RR_WriteToFile(
                            &buffer,
                            pZone,
                            prr,
                            pnodeWrite
                            ) )
                {
                    pnodeWrite = NULL;
                }
                prr = prr->pRRNext;
            }
            while ( prr );
        }

        //
        //  add ?
        //
        //  note:  add RRs are valid RRs in database, MUST NOT muck with
        //  them at all;  also must not assume they are still valid as
        //  they may be immediately deleted by another UPDATE packet
        //
        //  two add cases
        //      - single record add, just write record pointed to by update
        //      - RR list replace (DS read) write all the records for the
        //          node

        prr = pupdate->pAddRR;
        if ( prr )
        {
            WORD    replaceType = pupdate->wDeleteType;

            if ( IS_ON_FREE_LIST(prr) || IS_SLOW_FREE_RR(prr) )
            {
                ASSERT( !IS_ON_FREE_LIST(prr) );
                continue;
            }

            if ( fadd != TRUE )
            {
                FormattedWriteToFileBuffer( &buffer, "$ADD\r\n" );
                fadd = TRUE;
            }

            //  RR set replace update
            //      - write entire RR set or entire RR list
            //      - since writing at active node, take lock

            if ( replaceType && replaceType <= DNS_TYPE_ALL )
            {
                LOCK_READ_RR_LIST(pnodePrevious);

                while ( prr  &&
                        ( replaceType == DNS_TYPE_ALL ||
                          prr->wType == replaceType ) )
                {
                    if ( IS_ON_FREE_LIST(prr) || IS_SLOW_FREE_RR(prr) )
                    {
                        ASSERT( !IS_ON_FREE_LIST(prr) );
                        break;
                    }
                    if ( RR_WriteToFile(
                                &buffer,
                                pZone,
                                prr,
                                pnodeWrite ) )
                    {
                        pnodeWrite = NULL;
                    }
                    prr = prr->pRRNext;
                }

                UNLOCK_READ_RR_LIST(pnodePrevious);
            }

            //  single ADD record write

            else
            {
                if ( RR_WriteToFile(
                            &buffer,
                            pZone,
                            prr,
                            pnodeWrite ) )
                {
                    pnodeWrite = NULL;
                }
            }
        }
    }

    //  push log file to disk

    WriteBufferToFile( &buffer );

    //
    //  if log file too big, copy to backup
    //
    //  DEVNOTE: log backup;  catch failures
    //  DEVNOTE: write back datafile when backup log
    //              or at least schedule it for write
    //

    pZone->iUpdateLogCount += count;
    if ( pZone->iUpdateLogCount > UPDATE_LOG_FILE_LIMIT )
    {
        ASSERT( pZone->pwsLogFile );
        DNS_DEBUG( UPDATE, (
            "Update log file %S, exceeds limit\n"
            "    copying to backup directory\n",
            pZone->pwsLogFile ));

        CloseHandle( pZone->hfileUpdateLog );
        pZone->hfileUpdateLog = NULL;
        pZone->iUpdateLogCount = 0;

        if ( !File_MoveToBackupDirectory( pZone->pwsLogFile ) )
        {
            //  should have checked all names when read in boot file
            //  or entered by admin

            ASSERT( FALSE );
            goto Failed;
        }
    }
    return ERROR_SUCCESS;

Failed:

    //
    //  if failed to get access to update file, skip logging
    //
    //  DEVNOTE-LOG: log EVENT on logging failure
    //  DEVNOTE: set flag and try rewrite of entire log
    //

    return ERROR_CANTWRITE;
}



VOID
Up_CleanZoneUpdateList(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Clean update list of unnecessary entries.

Arguments:

    pZone - zone to check

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    PUPDATE     pupdate;
    DWORD       lastVersion;
    DWORD       updateVersion;
    INT         deleteCount;
    INT         maxCount;
    INT         count = pZone->UpdateList.dwCount;

    DNS_DEBUG( UPDATE, (
        "Up_CleanUpdateList(), zone %s = %p\n"
        "    zone RR count %d\n"
        "    zone update count %d\n",
        pZone->pszZoneName,
        pZone,
        pZone->iRRCount,
        count ));

    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList( "Zone update list before cleanup:", &pZone->UpdateList );
    }

    //
    //  if zone not IXFR capable, don't keep update list
    //

    if ( !Zone_IsIxfrCapable(pZone) )
    {
        Up_FreeUpdatesInUpdateList( &pZone->UpdateList );
        Up_InitUpdateList( &pZone->UpdateList );
        pZone->UpdateList.Flag |= DNSUPDATE_EXECUTED;
        return;
    }

    //
    //  limit updates to < 25% of zone record count
    //      - but to keep this working for small zones, always leave a small number
    //      of updates in list, so that even with small zone we can use IXFR on
    //      UDP packet rather than forcing to TCP for AXFR
    //      (also keeps Denise from testing with a small zone and not seeing it
    //      work)
    //
    //  DEVNOTE: zone RR count is not properly maintained
    //  DEVNOTE: once fixed can have legitimate "small zone" test to make sure
    //      enough updates stay around
    //

    ASSERT( count >= 0  );
    if ( pZone->iRRCount < 0 )
    {
        DNS_PRINT(( "ERROR:  zone %s iRRCount = %d\n",
            pZone->pszZoneName,
            pZone->iRRCount ));
        pZone->iRRCount = 1;
    }

    //
    //  determine maximum update list count
    //      - one eight size of zone RR set
    //      - up to hard max limit (for big zones)
    //      - but always allow enough updates even on small zone for UDP IXFR
    //

    maxCount = pZone->iRRCount >> 3;
    if ( maxCount > MAX_UPDATE_LIST_LENGTH )
    {
        maxCount = MAX_UPDATE_LIST_LENGTH;
    }
    else if ( maxCount < MIN_UPDATE_LIST_LENGTH )
    {
        maxCount = MIN_UPDATE_LIST_LENGTH;
    }

    count -= maxCount;
    if ( count <= 0 )
    {
        DNS_DEBUG( UPDATE, (
            "Update count for zone %s less than max count %d, no truncation of list\n",
            pZone->pszZoneName,
            maxCount ));
        return;
    }

    //
    //  strip unecessary updates
    //
    //  delete count number of updates, but always delete all updates
    //  for a given zone version;  hence once reach count to delete, delete
    //  until the NEXT zone version
    //

    DNS_DEBUG( UPDATE, (
        "Update count exceeds desired count, truncating %d entries\n",
        count ));

    deleteCount = 0;
    pupdate = pZone->UpdateList.pListHead;

    while( pupdate )
    {
        //  don't delete the last update
        //      otherwise big last update may drive us below minimum

        updateVersion = pupdate->dwVersion;
        if ( updateVersion == pZone->dwSerialNo )
        {
            break;
        }

        //  when reach delete required update count, stop
        //  but insure delete is on version boundary
        //      - at count save version
        //      - over count stop when reach next update version

        if ( deleteCount >= count )
        {
            if ( deleteCount == count )
            {
                lastVersion = updateVersion;
            }
            else if ( lastVersion != updateVersion )
            {
                break;
            }
        }

        //  delete update
        //      - delete DELETE RRs
        //      - deref node

        pupdate = Up_FreeUpdateEx(
                    pupdate,
                    TRUE,           // executed zone update (no add record delete)
                    TRUE );         // deref node
        deleteCount++;
    }

    //
    //  emptied update list
    //      - reset list
    //
    //  WARNING:  should never delete last update with delete code as above
    //      as we never delete update that takes us to current version
    //      AND there should ALWAYS be an update that takes us to current zone
    //      version
    //

    if ( !pupdate )
    {
        DNS_PRINT((
            "WARNING:  eliminated all updates cleaning update list\n"
            "    for zone %s\n",
            pZone->pszZoneName ));

        Up_InitUpdateList( &pZone->UpdateList );
        pZone->UpdateList.Flag |= DNSUPDATE_EXECUTED;
    }
    else
    {
        pZone->UpdateList.pListHead = pupdate;
        pZone->UpdateList.dwCount -= deleteCount;
        ASSERT( (INT)pZone->UpdateList.dwCount >= 0 );
    }

    IF_DEBUG( UPDATE )
    {
        Up_VerifyUpdateList( &pZone->UpdateList );
    }
    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList( "Zone update list after cleanup:", &pZone->UpdateList );
    }
}   //  Up_CleanUpdateList




DNS_STATUS
Up_ApplyUpdatesToDatabase(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Execute updates to in-memory database.
    Makes the updates to in memory database.

Arguments:

    pUpdateList - list with update

    pZone - zone being updated

    dwFlag - update flags

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    PUPDATE         pupdate;
    PUPDATE         pprevUpdate;
    PDB_RECORD      prr;
    PDB_RECORD      ptempRR;
    PDB_NODE        pnode;
    PDB_NODE        pnodeThisHost = NULL;
    DNS_STATUS      status;
    INT             netRecordCount = 0;
    DWORD           flag = pUpdateList->Flag | dwFlag;


    DNS_DEBUG( UPDATE, (
        "Up_ApplyUpdatesToDatabase(), zone %s = %p\n"
        "    flags            = 0x%08X\n"
        "    zone RR count    = %d\n"
        "    current serial   = %d\n",
        pZone->pszZoneName,
        pZone,
        dwFlag,
        pZone->iRRCount,
        pZone->dwSerialNo ));

    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList(
            "List before ApplyUpdatesToDatabase():",
            pUpdateList );
    }

    //
    //  log empty "ping" updates
    //

    if ( !pUpdateList->pListHead )
    {
        ASSERT( pUpdateList->dwCount == 0 );
        ASSERT( pUpdateList->pCurrent == NULL );
        if ( flag & DNSUPDATE_PACKET )
        {
            //  STAT_INC( UpdateStats.Empty );
            UPDATE_STAT_INC( pUpdateList, Empty );
            PERF_INC( pcDynamicUpdateNoOp );
        }
        DNS_DEBUG( UPDATE, (
            "Leaving Up_ApplyUpdatesToDatabase(), zone %s,\n"
            "    update was empty ping update\n",
            pZone->pszZoneName ));

        //  if completion desired, at least do the unlocking

        goto Complete;
    }

    //
    //  loop through all updates in list
    //
    //  note startup works as front of update list ptr is the first
    //      ptr in UPDATE_LIST and pNext
    //
    //  note, NO LOCKING is required anymore;
    //      for updates, the updates themselves are on temporary nodes
    //      not the real database nodes;
    //      for IXFR the zone is locked but we won't refuse to query just
    //      because the data involving multiple nodes, won't necessarily
    //      be consistent
    //
    //  DEVNOTE:   if nothing left after delete make type ALL (for SIXFR)
    //  DEVNOTE:   if multiple type adds, make type ALL
    //
    //  DEVNOTE:   need cleanup\rollback on failure
    //              most fail silently, but can get outright failures
    //                  - WINS or SOA or NS misplacement
    //                  - CNAME issue if want to fix broken DynUpd RFC
    //

    //
    //  DEVNOTE: whack 'n add problem
    //
    //      one approach -- glom all the update for node together
    //          - if MORE than one, build temp, execute and check
    //          if no change from current (DS thing)
    //


    pprevUpdate = (PUPDATE) pUpdateList;

    while ( pupdate = pprevUpdate->pNext )
    {
        pnode = pupdate->pNode;

        //
        //  Prior to the update, if the node has no RRs, mark the update
        //  flags to indicate this is a new node.
        //
        
        if ( EMPTY_RR_LIST( pnode ) )
        {
            pupdate->dwFlag |= DNSUPDATE_NEW_RECORD;
        }
        
        //
        //  catch disappearing root-hints stuff
        //      - refuse to do update delete on RootHints root node
        //
        //  note:  only "update" root-hints via DS-polling
        //      RPC updates simply mark the root-hints dirty
        //      but do not make an "official" update
        //

        if ( IS_ZONE_CACHE(pZone) )
        {
            ASSERT( pupdate->wDeleteType == DNS_TYPE_ALL );

            if ( pnode == pZone->pTreeRoot )
            {
                IF_DEBUG( UPDATE )
                {
                    Dbg_Update(
                        "Update apply at root-hints root\n",
                        pupdate );
                }

                //  refuse to clear root-hints root
                //      - no-op the update

                if ( !pupdate->pAddRR )
                {
                    Dbg_Update(
                        "BAD Update apply at root-hints root\n",
                        pupdate );

                    Up_DetachAndFreeUpdateGivenPrevious(
                        pUpdateList,
                        pprevUpdate,
                        pupdate );
                    continue;
                }
            }
        }

        //
        //  add or replace
        //
        //  note after update
        //      - pAddRR now points to actual database record
        //      - pDeleteRR may point at database (copy) records deleted
        //

        if ( pupdate->pAddRR )
        {
            //
            //  straight add -- no delete type specified
            //
            //    - note on mandatory replace cases (SOA, CNAME), add may
            //      also delete records from node and set pDeleteRR in update
            //
            //  Packet update is presumed to be good to go and all conditions are
            //  ignoreable -- i.e. execute what's there and party on.
            //
            //  for ADMIN updates status code used to detect duplicate records
            //
            //  DEVNOTE: missing ExecuteUpdate() rollback for terminal errors
            //

            if ( !pupdate->wDeleteType )
            {
                status = RR_UpdateAdd(
                            pZone,
                            pnode,
                            pupdate->pAddRR,
                            pupdate,
                            flag );

                if ( status != ERROR_SUCCESS )
                {
                    if ( (flag & DNSUPDATE_ADMIN) || (flag & DNSUPDATE_PACKET) )
                    {
                        DNS_DEBUG( UPDATE, (
                            "RR_UpdateAdd() failure %d (%p) on admin or packet update\n",
                            status, status ));
                        goto Failed;
                    }

                    DNS_DEBUG( UPDATE, (
                        "WARNING:  Ignoring RR_UpdateAdd() status = %d (%p)\n"
                        "    for IXFR update of zone %s\n",
                        status, status,
                        pZone->pszZoneName ));

                    ASSERT( FALSE );
                }
            }

            //
            //  precondition update
            //      - should ONLY be applying to temp node
            //      - should ONLY fail when DS integrated and read
            //          different RR set then tested prior to lock
            //      - free precon RRs
            //      - clear update as no data impact (just timestamp)
            //

            else if ( pupdate->wDeleteType == UPDATE_OP_PRECON )
            {
                ASSERT( IS_TNODE(pupdate->pNode) );

                if ( !RR_ListIsMatchingSet(
                            pupdate->pNode,
                            pupdate->pAddRR,
                            TRUE        // force refresh
                            ) )
                {
                    IF_DEBUG( UPDATE )
                    {
                        Dbg_DbaseNode(
                            "UPDATE Precon RR set match failure node -- inside APPLY!\n",
                            pupdate->pNode );
                    }
                    ASSERT( pZone->fDsIntegrated );
                    return DNS_RCODE_NXRRSET;
                }

                RR_ListFree( pupdate->pAddRR );
                pupdate->pAddRR = NULL;
            }

            //
            //  full replace update -- type all delete and records to add
            //      - this used on updates from DS
            //
            //  DEVNOTE: for now this ok, but must fix function for full check
            //  handle straight type ALL delete separately as already have code
            //      that saves necessary records (SOA, NS)
            //
            //  DEVNOTE: must fix failure case here;
            //      in multi-update may have already committed some updates
            //      when hit failure
            //          - roll back
            //          - or kick out (and cleanup) this update and continue
            //      in temp node failure, we're ok
            //

            else if ( pupdate->wDeleteType == DNS_TYPE_ALL )
            {
                DWORD addCount = 0;

                prr = pupdate->pAddRR;
                while ( prr )
                {
                    addCount++;
                    prr = prr->pRRNext;
                }

                status = RR_ListReplace(
                            pupdate,
                            pnode,
                            pupdate->pAddRR,
                            & pupdate->pDeleteRR
                            );
                if ( status != ERROR_SUCCESS )
                {
                    DNS_DEBUG( ANY, (
                        "ERROR:  Type all update failure on node %p (l=%s)\n"
                        "    status = %d (%p)\n",
                        pnode, pnode->szLabel,
                        status, status ));

                    if ( IS_TNODE(pnode) )
                    {
                        DNS_DEBUG( UPDATE, (
                            "RR_UpdateAdd() failure %d (%p) on admin or packet update\n",
                            status, status ));
                        ASSERT( (flag & DNSUPDATE_ADMIN) || (flag & DNSUPDATE_PACKET) );
                        goto Failed;
                    }

                    //  failures on real memory nodes are gracefully cleaned up
                    //      - update is no-op'd
                    //      - and rest of list can still be processed

                    ASSERT( (flag & DNSUPDATE_DS) || (flag & DNSUPDATE_IXFR) );
                    ASSERT( pupdate->pDeleteRR == NULL && pupdate->pAddRR == NULL );
                }

                //  replace update
                //      - note we skip generic post-ADD processing below
                //      but use delete processing

                if ( pupdate->pAddRR )
                {
                    pupdate->wAddType = DNS_TYPE_ALL;
                    netRecordCount += addCount;
                }
            }

            //
            //  RR set replace
            //
            //  DEVNOTE: update RR set replace looses info?
            //      looks like there's an issue here if multiple add RR
            //      we'd then end up with interpreting as only one RR
            //      in later XFR
            //

            else
            {
                ASSERT( pupdate->pAddRR->wType == pupdate->wDeleteType );

                prr = RR_ReplaceSet(
                            pZone,
                            pnode,
                            pupdate->pAddRR,
                            0 );    // no flags
                pupdate->pDeleteRR = prr;
                ASSERT( !prr || prr->wType == pupdate->wDeleteType );
            }
        }

        //
        //  delete specfic RR
        //      - pDeleteRR is valid temp RR
        //
        //  note that update delete RR is freed;
        //  update now contains ptr to deleted RR
        //

        else if ( ptempRR = pupdate->pDeleteRR )
        {
            ASSERT( pupdate->pAddRR == NULL );

            prr = RR_UpdateDeleteMatchingRecord(
                        pnode,
                        ptempRR );

            pupdate->pDeleteRR = prr;
            ASSERT( !prr || prr->pRRNext == NULL );

            RR_Free( ptempRR );
        }

        //
        //  scavenge update
        //

        else if ( pupdate->wDeleteType == UPDATE_OP_SCAVENGE )
        {
            prr = RR_UpdateScavenge(
                        pZone,
                        pnode,
                        flag );
            pupdate->pDeleteRR = prr;
        }

        //
        //  force aging update
        //      - mark zone dirty as we have no ADD\DELETE effect
        //      we won't mark it dirty below
        //

        else if ( pupdate->wDeleteType == UPDATE_OP_FORCE_AGING )
        {
            if ( RR_UpdateForceAging(
                        pZone,
                        pnode,
                        flag ) )
            {
                pZone->fDirty = TRUE;
            }
        }

        //
        //  type delete
        //      - wDeleteType is type
        //      - pDeleteRR will contain records actually deleted
        //
        //  note that update now has pointer to actual database (copy) records
        //

        else if ( pupdate->wDeleteType )
        {
            prr = RR_UpdateDeleteType(
                        pZone,
                        pnode,
                        pupdate->wDeleteType,
                        flag );
            pupdate->pDeleteRR = prr;
        }

        //
        //  must have some kind of update!
        //      - only non-executed update should be in root hints

        ELSE_ASSERT( FALSE );

        //
        //  successful update
        //

        if ( pupdate->pAddRR || pupdate->pDeleteRR )
        {
            pprevUpdate = pupdate;

            //  mark update as executed

            MARK_UPDATE_EXECUTED(pupdate);

            //  mark zone dirty
            //  if update at root, mark root dirty
            //      note, that this handles IXFR only, primary updates
            //      are on temporary nodes and zone root gets marked during
            //      check of update effect

            pZone->fDirty = TRUE;
            if ( pnode == pZone->pZoneRoot )
            {
                pZone->fRootDirty = TRUE;
            }

            //  set ADD type
            //  count ADD
            //      - replace case is handled above

            if ( pupdate->pAddRR  &&
                 pupdate->wAddType != DNS_TYPE_ALL )
            {
                pupdate->wAddType = pupdate->pAddRR->wType;
                netRecordCount++;
            }

            //  count delete RRs

            prr = pupdate->pDeleteRR;
            while ( prr )
            {
                prr = prr->pRRNext;
                netRecordCount--;
            }

            RR_ListVerifyDetached(
                pupdate->pDeleteRR,
                (WORD) ((pupdate->wDeleteType >= DNS_TYPE_ALL) ? 0 : pupdate->wDeleteType),
                0 );        //  no required source

            RR_ListVerify( pnode );

            //
            //  check for THIS host update
            //      - actual update, not IXFR or DS write
            //          (check this by checking for TNODE)
            //      - save node ptr
            //

            if ( IS_THIS_HOST_NODE(pnode) &&
                 IS_TNODE(pnode) )
            {
                pnodeThisHost = pnode;
            }
            continue;
        }

        //
        //  eliminate no-op update from list
        //      - this removes update from list and resets update list fields
        //      - previous update doesn't move forward but its next pointer
        //          has been reset to next update
        //      - note this is useful even with final node before\after check
        //          in eliminating individual updates that do nothing, even if
        //          the whole set is valid;  typical example would be a type
        //          delete with no existing data, followed by an add
        //

        IF_DEBUG( UPDATE )
        {
            Dbg_Update(
                "Update turned into no-op on DB-execution.",
                pupdate );
        }

        Up_DetachAndFreeUpdateGivenPrevious(
            pUpdateList,
            pprevUpdate,
            pupdate );
    }

    //
    //  unlock would be here:  see NO LOCKING note above
    //

    //
    //  check for changing DNS server host data
    //      - if "down to zero" delete from packet
    //      then refuse the update at this node
    //      (don't write, don't update)
    //
    //  DEVNOTE: better bail out on suppressing host-A delete
    //      currently all packet updates are atomic in node and
    //      record type;  however other packet updates may not be
    //      desirable to
    //          - bail to produce error code
    //          - reset temp node to match real node
    //          (or match in A records) and proceed
    //

    if ( pnodeThisHost )
    {
        ASSERT( IS_TNODE(pnodeThisHost) );

        if ( (flag & DNSUPDATE_PACKET) &&
              ! RR_FindNextRecord(
                    pnodeThisHost,
                    DNS_TYPE_A,
                    NULL,
                    0 ) )
        {
            DNS_DEBUG( ANY, (
                "Update %p for zone %s is suppressed due to host-A delete\n",
                pUpdateList,
                pZone->pszZoneName ));

            status = DNS_ERROR_RCODE_REFUSED;
            goto Failed;
        }
    }

    //  count updates and no-ops for dynamic update

    if ( flag & DNSUPDATE_PACKET )
    {
        if ( pUpdateList->pListHead )
        {
            ASSERT( pUpdateList->dwCount );
            //  STAT_INC( UpdateStats.Completed );
            UPDATE_STAT_INC( pUpdateList, Completed );
            PERF_INC( pcDynamicUpdateWriteToDB );
        }
        else
        {
            ASSERT( pUpdateList->dwCount == 0 );
            //  STAT_INC( UpdateStats.NoOps );
            UPDATE_STAT_INC( pUpdateList, NoOps );
            PERF_INC( pcDynamicUpdateNoOp );
        }
    }

    //  IXFR execution should always include SOA update

    ASSERT( !(flag & DNSUPDATE_IXFR) || pZone->fRootDirty );

    //  save count of net records

    pUpdateList->iNetRecords = netRecordCount;

    //  flag update list as "EXECUTED"

    pUpdateList->Flag |= DNSUPDATE_EXECUTED;


Complete:

    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList(
            "Update list after ApplyToDatabase():",
            pUpdateList );
    }
    DNS_DEBUG( UPDATE, (
        "Leaving Up_ApplyUpdatesToDatabase(), zone %s = %p\n"
        "    zone RR count = %d\n",
        pZone->pszZoneName,
        pZone,
        pZone->iRRCount ));

    //
    //  if cleanup desired, cleanup
    //

    if ( flag & DNSUPDATE_COMPLETE )
    {
        Up_CompleteZoneUpdate(
            pZone,
            pUpdateList,
            flag );
    }

    return ERROR_SUCCESS;


Failed:

    //  IXFR or DS poll should NEVER fail out of this function
    //  only updates can fail for doing something bogus
    //  or restricted by policy

    ASSERT( !(flag & DNSUPDATE_IXFR) );
    ASSERT( !(flag & DNSUPDATE_DS) );

    return status;
}   //  ApplyUpdatesToDatabase



DNS_STATUS
Up_ExecuteUpdateEx(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      DWORD           Flag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Execute update.

    This is the main routine for executing updates.
        - takes lock
        - executes in DS (if necessary)
        - executes in memory
        - successful update zone processing
        - unlock
        - notify

    This serves as main entry point for non-wire updates.
    Wire updates call into it after parsing, and pass a flag to
    do completion on there own.

Arguments:

    pZone       -- zone context

    pUpdateList -- update list to execute

    Flag        -- additional flags to update

    pszFile     -- source file (for lock tracking)

    dwLine      -- source line (for lock tracking)

Return Value:

    TRUE if update completed.
    FALSE if update requeued.

--*/
{
    DNS_STATUS  status;

    ASSERT( pZone );
    ASSERT( pUpdateList );

    DNS_DEBUG( UPDATE, ( "Up_ExecuteUpdate( z=%s )\n", pZone->pszZoneName ));
    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList( "List entering ExecuteUpdate:", pUpdateList );
    }

    //
    //  lock zone
    //
    //  if admin specific have wait lock here that will wait a few seconds
    //  to get lock and execute
    //

    if ( !(Flag & DNSUPDATE_ALREADY_LOCKED) )
    {
        DWORD   waitTime = 0;

        if ( Flag & DNSUPDATE_ADMIN )
        {
            waitTime = DEFAULT_ADMIN_ZONE_LOCK_WAIT;
        }
        else if ( Flag & DNSUPDATE_SCAVENGE )
        {
            waitTime = DEFAULT_SCAVENGE_ZONE_LOCK_WAIT;
        }

        if ( !Zone_LockForWriteEx(
                    pZone,
                    LOCK_FLAG_UPDATE,
                    waitTime,
                    pszFile,
                    dwLine ) )
        {
            DNS_DEBUG( UPDATE, (
                "WARNING:  unable to lock zone %s for UPDATE\n",
                pZone->pszZoneName ));

            status = DNS_ERROR_ZONE_LOCKED;
            goto FailedLock;
        }
    }

    //
    //  append user supplied flags to update
    //

    pUpdateList->Flag |= Flag;
    Flag = pUpdateList->Flag;

    //
    //  set zone's refresh below time
    //  set timestamps on update records
    //

    Aging_InitZoneUpdate( pZone, pUpdateList );

    //
    //  execute
    //      - clear COMPLETE flag since explicitly completing below
    //
    //  DS zones do additional processing to allow for
    //      - security
    //      - roll back on write failure
    //
    //  Handle non-DS, DS-secure and non-secure separately.
    //  Except that updates from DNS server itself can bypass security.
    //

    if ( !pZone->fDsIntegrated )
    {
        status = processNonDsUpdate(
                    pZone,
                    pUpdateList );
    }

    //
    //  Administrative update in DS-integrated zone -- do security update.
    //
    //  Secure zone -- do secure update
    //      except bypass
    //      - local system updates
    //      - non-secure dynamic update packets
    //      these will be processed to determine if no-op, and only if
    //      update is required, do we refuse;  this avoids security
    //      negotiation phase unless necessary
    //

    else if ( ( Flag & DNSUPDATE_ADMIN ) ||
              pZone->fAllowUpdate == ZONE_UPDATE_SECURE &&
              !( Flag & DNSUPDATE_NONSECURE_PACKET ) &&
              !( Flag & DNSUPDATE_LOCAL_SYSTEM ) )
    {
        status = processDsSecureUpdate(
                    pZone,
                    pUpdateList );
    }
    else    // DS non-secure
    {
        status = processDsUpdate(
                    pZone,
                    pUpdateList );
    }

    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  apply temp update results to database
    //

    resetAndSuppressTempUpdatesForCompletion(
        pZone,
        pUpdateList );

    //
    //  finish update and unlock zone
    //
    //  DEVNOTE: should pass through flag here
    //      didn't have it in there for all NT5 test, so not adding it now
    //      post-ship, add it
    //

    Up_CompleteZoneUpdate(
        pZone,
        pUpdateList,
        0 );            //  flags

    return ERROR_SUCCESS;

Failure:

    //  unlock non-update cases

    Zone_UnlockAfterAdminUpdate( pZone );

FailedLock:

    //  cleanup update list

    Up_FreeUpdatesInUpdateList( pUpdateList );

    return status;
}



VOID
Up_CompleteZoneUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Take all necessary actions on zone once updated in database
    is completed.

    Includes:
        -- serial increment
        -- zone data update on dirty root
        -- update in memory update list
        -- logging
        -- unlock zone
        -- notify any secondaries

Arguments:

    pZone -- zone being updated

    pUpdateList -- completed updates on zone

    dwFlags
        DNSUPDATE_NO_UNLOCK     -- do NOT unlock
        DNSUPDATE_NO_NOTIFY     -- do NOT notify secondaries
        DNSUPDATE_NO_INCREMENT  -- do NOT increment version

Return Value:

    None.

--*/
{
    DNS_STATUS  status;
    DWORD       serialPrevious;

    DNS_DEBUG( UPDATE, (
        "Up_CompleteZoneUpdate() on zone %s\n"
        "    current serial = %d\n",
        pZone->pszZoneName,
        pZone->dwSerialNo ));

    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList( "Update list to complete:", pUpdateList );
    }

    dwFlags |= pUpdateList->Flag;

    //
    //  root-hints zone?
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        DNS_DEBUG( ANY, (
            "WARNING:  CompleteUpdate on root hints zone %p!\n",
            pZone ));
        Up_FreeUpdatesInUpdateList( pUpdateList );
        return;
    }

    //
    //  if zone root is dirty, update zone info
    //

    serialPrevious = pZone->dwSerialNo;

    if ( pZone->fRootDirty )
    {
        Zone_GetZoneInfoFromResourceRecords( pZone );
    }

    //
    //  if update is NULL, ignore, no notify
    //
    //  note, we do this AFTER updating zone info, as root may be dirty from
    //      an aging only update, that changed root records, but did not
    //      change data and hence was no-op'd out of update list
    //

    if ( pUpdateList->dwCount == 0 )
    {
        DNS_DEBUG( UPDATE, (
            "Empty update list, unlock and return\n" ));

        dwFlags |= DNSUPDATE_NO_NOTIFY;
        goto Unlock;
    }

    //
    //  update zone version, EXCEPT do NOT update if
    //
    //  1) serial was moved forward by SOA change (i.e. SOA update keeps serial of update)
    //
    //  2) no serial increment if flag set
    //      this if for DS polls which have already set new version
    //      (to higher of high version in DS update RRs or current+1
    //      -- see Zone_UpdateAfterDsRead() )
    //

    if ( ( dwFlags & ( DNSUPDATE_NO_INCREMENT | DNSUPDATE_IXFR ) ) == 0 &&
         Zone_SerialNoCompare( pZone->dwSerialNo, serialPrevious ) <= 0 )
    {
        Zone_IncrementVersion( pZone );
    }

    //
    //  new serial should always be greater than what we started with
    //  UNLESS, couldn't save start serial
    //
    //  should always have SOA and it should always match pZone->dwSerialNo
    //

    ASSERT( Zone_SerialNoCompare(pZone->dwSerialNo, pUpdateList->dwStartVersion) > 0
            || pUpdateList->dwStartVersion == 0 );

    ASSERT( pZone->pSoaRR || IS_ZONE_CACHE (pZone) );
    ASSERT( IS_ZONE_CACHE(pZone) ||
            ntohl( pZone->pSoaRR->Data.SOA.dwSerialNo ) == pZone->dwSerialNo );

    IF_DEBUG( OFF )
    {
        DnsDebugLock();
        Dbg_DnsTree(
            "Zone after UPDATE packet\n",
            pZone->pZoneRoot );
        DnsDebugUnlock();
    }

    //
    //  log updates to file (if desired)
    //

    Up_LogZoneUpdate( pZone, pUpdateList );

    //
    //  if IXFR allowed
    //      - XFR allowed
    //      - not (DS-integrated and no-XFR)
    //      (can not IXFR a DS zone to secondary that hasn't had XFR)
    //
    //  then save update list to zone update list
    //      - version list
    //      - put in "processed mode"
    //      - append to zone master list
    //
    //  DEVNOTE: possibly over-versioning updates from IXFR
    //      they are version stamped in add\delete passes and
    //      we actually lose information -- granularity that we
    //      can pass to downstream secondaries -- by restamping to
    //      final version
    //
    //  DEVNOTE: leaving in the clean and version to skip ASSERTs on
    //      cleanup (as it checks pAddRecord field for validity);
    //      could fix validity check, but also should be sure here that
    //      pAddRecord does NOT get freed, which shouldn't happen because
    //      of DNSUPDATE_EXECUTED flag;  safest to leave this in and
    //      clear pAddRecord field
    //

    Up_CleanAndVersionPostUpdate( pUpdateList, pZone->dwSerialNo );

    if ( Zone_IsIxfrCapable(pZone) )
    {
        Up_AppendUpdateList( &pZone->UpdateList, pUpdateList, pZone->dwSerialNo );
    }

    //  keep rough record count for zone
    //      if out of whack, fix up

    pZone->iRRCount += pUpdateList->iNetRecords;

    if ( pZone->iRRCount <= 0 )
    {
        DNS_PRINT((
            "ERROR:  zone %s iRRCount %d after update!\n"
            "    resetting to one\n",
            pZone->pszZoneName,
            pZone->iRRCount ));
        pZone->iRRCount = 1;
    }

    Up_CleanZoneUpdateList( pZone );

Unlock:

    //
    //  unlock zone
    //  notify secondaries
    //  update DS peers (if necessary)
    //  free temp nodes and records
    //

    if ( !(dwFlags & DNSUPDATE_NO_UNLOCK) )
    {
        Zone_UnlockAfterAdminUpdate( pZone );
    }

    if ( !(dwFlags & DNSUPDATE_NO_NOTIFY) )
    {
        Xfr_SendNotify( pZone );
    }

    if ( dwFlags & DNSUPDATE_DS_PEERS )
    {
        initiateDsPeerUpdate( pUpdateList );
    }

    Up_FreeUpdatesInUpdateList( pUpdateList );
}



//
//  Dynamic update routines
//

BOOL
Up_InitializeUpdateProcessing(
    VOID
    )
/*++

Routine Description:

    Initializes dynamic update processing.
    Creates update queues and threads.

Arguments:

    None

Return Value:

    TRUE, if successful
    FALSE on error.

--*/
{
    DWORD   countUpdateThreads;

    //
    //  update queue for delayed updates
    //      - set event on queuing
    //      - discard expired and dups
    //      - keep in query order
    //

    g_UpdateQueue = PQ_CreatePacketQueue(
                        "Update",
                        QUEUE_SET_EVENT |
                            QUEUE_DISCARD_EXPIRED |
                            QUEUE_DISCARD_DUPLICATES |
                            QUEUE_QUERY_TIME_ORDER,
                        UPDATE_TIMEOUT,
                        0 );                        //  maximum elements
    if ( !g_UpdateQueue )
    {
        DNS_PRINT(( "Update queue init FAILED!!!\n" ));
        ASSERT( FALSE );
        goto Failed;
    }

    //
    //  setup update forwarding queue to hold packets sent to primary
    //      - NO event on queuing
    //      - discard expired and dups
    //      - keep in query order
    //

    g_UpdateForwardingQueue = PQ_CreatePacketQueue(
                                "UpdateForwarding",
                                QUEUE_DISCARD_EXPIRED |
                                    QUEUE_DISCARD_DUPLICATES |
                                    QUEUE_QUERY_TIME_ORDER,
                                UPDATE_TIMEOUT,
                                0 );                //  maximum elements
    if ( !g_UpdateForwardingQueue )
    {
        DNS_PRINT(( "Update queue init FAILED!!!\n" ));
        ASSERT( FALSE );
        goto Failed;
    }

    //
    //  secure negotiation queue
    //      - negotiation also serviced up update threads
    //      - set event on queuing
    //      - discard expired and dups
    //      - keep in query order
    //

    g_SecureNegoQueue = PQ_CreatePacketQueue(
                                "SecureNego",
                                QUEUE_SET_EVENT |
                                    QUEUE_DISCARD_EXPIRED |
                                    QUEUE_DISCARD_DUPLICATES |
                                    QUEUE_QUERY_TIME_ORDER,
                                UPDATE_TIMEOUT,
                                0 );                //  maximum elements
    if ( !g_SecureNegoQueue )
    {
        DNS_PRINT(( "Secure nego queue init FAILED!!!\n" ));
        ASSERT( FALSE );
        goto Failed;
    }

    //
    //  create update threads
    //

    countUpdateThreads = g_ProcessorCount + 1;
    while ( countUpdateThreads-- )
    {
        if ( !Thread_Create(
                    "Update",
                    Update_Thread,
                    NULL,
                    0 ) )
        {
            DNS_PRINT(( "Update thread create FAILED!!!\n" ));
            ASSERT( FALSE );
            goto Failed;
        }
    }
    return ERROR_SUCCESS;

Failed:

    DNS_DEBUG( ANY, ( "ERROR:  Update init failed\n" ));
    return DNSSRV_UNSPECIFIED_ERROR;
}   //  Up_InitializeUpdateProcessing



VOID
Up_UpdateShutdown(
    VOID
    )
/*++

Routine Description:

    Initializes recursion to other DNS servers.

Arguments:

    None

Return Value:

    TRUE, if successful
    FALSE on error.

--*/
{
    PQ_CleanupPacketQueueHandles( g_UpdateQueue );
    PQ_CleanupPacketQueueHandles( g_UpdateForwardingQueue );
    PQ_CleanupPacketQueueHandles( g_SecureNegoQueue );
}



//
//  Update packet processing
//

VOID
Up_ProcessUpdate(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process dynamic update message.

    This is called by recv thread handling update packet.
    Never called by UpdateThread itself.

Arguments:

    pMsg -- UPDATE packet

Return Value:

    None.

--*/
{
    PDB_NODE        pnode;
    PZONE_INFO      pzone;
    DNS_STATUS      status;
    DWORD           exception;


    ASSERT( pMsg->Head.Opcode == DNS_OPCODE_UPDATE );

    DNS_DEBUG( UPDATE, ( "Up_ProcessUpdate( %p )\n", pMsg ));
    IF_DEBUG( UPDATE2 )
    {
        Dbg_DnsMessage(
            "Received UPDATE request:\n",
            pMsg );
    }

    STAT_INC( WireUpdateStats.Received );
    PERF_INC( pcDynamicUpdateReceived );

    //
    //  verify qtype SOA
    //

    if ( pMsg->wQuestionType != DNS_TYPE_SOA )
    {
        DNS_PRINT(( "WARNING:  message at %p, non-SOA UPDATE\n" ));
        status = DNS_RCODE_FORMAT_ERROR;
        goto Failure;
    }
    
    //
    //  Find the zone that is being updated.
    //

    pzone = Lookup_ZoneForPacketName(
                (PCHAR) pMsg->MessageBody,
                pMsg );
    if ( !pzone )
    {
        Dbg_MessageName(
            "ERROR:  received update for non-authoritative zone ",
            pMsg->MessageBody,
            pMsg );
        status = DNS_RCODE_NOTAUTH;
        goto Failure;
    }
    pMsg->pzoneCurrent = pzone;

    //
    //  If this is a stub zone, reject the update.
    //

    if ( IS_ZONE_STUB( pzone ) || IS_ZONE_FORWARDER( pzone ) )
    {
        rejectUpdateWithRcode(
            pMsg,
            DNS_RCODE_NOTAUTH );
        return;
    }

    //
    //  forward to primary?
    //
    //  DEVNOTE: once DS enabled, do we need separate DS check
    //      should be able to update DS zone
    //

    if ( SrvCfg_dwEnableUpdateForwarding && !IS_ZONE_PRIMARY( pzone ) )
    {
        Up_ForwardUpdateToPrimary( pMsg );
        return;
    }

    //
    //  zone security
    //
    //  DEVNOTE: additional zone centric update security checks!!!
    //      - may want IP list check
    //      - later RFC security
    //

    if ( !pzone->fAllowUpdate )
    {
        Dbg_MessageName(
            "ERROR:  received update for non-updateable zone ",
            pMsg->MessageBody,
            pMsg );
        status = DNS_RCODE_NOT_IMPLEMENTED;
        goto Failure;
    }

    //
    //  If this is a non-secure update to a secure zone with a large
    //  number of RRs in the message it may be a DoS attack so force
    //  a secure update. There is no RR limit protection if the zone
    //  is non-secure.
    //
    //  Note: the update is assumed to be nonsecure if the additional count
    //  is zero. A secure update will always have a TSIG in the additional
    //  section. If the additional count is greater than two (one for
    //  TSIG and one for OPT) this appears to be a bogus update so refuse it.
    //
    //  Note: the SrvCfg_dwMaxRRsInNonSecureUpdate value is used to enable
    //  and disable the check on AdditionalCount > 2.
    //
    
    if ( pzone->fAllowUpdate == ZONE_UPDATE_SECURE &&
         SrvCfg_dwMaxRRsInNonSecureUpdate )
    {
        if ( pMsg->Head.AdditionalCount > 2 )
        {
            DNS_PRINT(( "WARNING: rejecting message at %p with too many additional RRs\n", pMsg ));
            status = DNS_RCODE_REFUSED;
            goto Failure;
        }
        if ( pMsg->Head.AdditionalCount == 0 &&
             ( DWORD ) ( pMsg->Head.QuestionCount +
                         pMsg->Head.AnswerCount +
                         pMsg->Head.NameServerCount ) >
                                SrvCfg_dwMaxRRsInNonSecureUpdate )
        {
            DNS_PRINT(( "WARNING: rejecting message at %p with too many RRs\n", pMsg ));
            status = DNS_RCODE_REFUSED;
            goto Failure;
        }
    }

    //
    //  queue all updates to update thread
    //
    //  this doesn't take great advantage of MP capability, but updates shouldn't
    //  be coming is such great quantity as to make that an issue
    //
    //  at a minimum, some updates can take too long so should be queuing
    //      -- all secure update (potentially way too long)
    //      -- DS updates (DS write potentially too long, especially on single
    //          TCP thread)
    //

    DNS_DEBUG( UPDATE2, (
        "Queuing update packet %p to update queue\n",
        pMsg ));
    PQ_QueuePacketEx( g_UpdateQueue, pMsg, FALSE );
    return;

Failure:

    rejectUpdateWithRcode(
        pMsg,
        status );
}



DNS_STATUS
writeUpdateFromPacketRecord(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNode,
    IN      PPARSE_RECORD   pParseRR,
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Create resource record given in packet, at a given node.

Arguments:

    pUpdateList - update list to append to

    pNode - owner node of record to be created

    pParseRR - parsed RR

    pMsg - ptr to response info

Return Value:

    ERROR_SUCCESS on successful creation.
    Otherwise error status.

--*/
{
    PDB_RECORD  prrAdd;
    PDB_RECORD  prrDelete = NULL;

    //
    //  build wire record
    //

    prrAdd = Wire_CreateRecordFromWire(
                pMsg,
                pParseRR,
                pParseRR->pchData,
                MEMTAG_RECORD_DYNUP
                );
    if ( !prrAdd )
    {
        return DNS_ERROR_RCODE_FORMAT_ERROR;
    }
    
    //
    //  If the update specifies a TTL of -1 use the zone default
    //  TTL instead.
    //
    
    if ( prrAdd->dwTtlSeconds == ( DWORD ) -1 &&
         pNode &&
         NODE_ZONE( pNode ) &&
         NODE_ZONE( pNode )->pSoaRR )
    {
        prrAdd->dwTtlSeconds =
            NODE_ZONE( pNode )->pSoaRR->Data.SOA.dwMinimumTtl;
    }

    //
    //  if delete swap -- record is delete record
    //

    if ( pParseRR->wClass == DNS_RCLASS_NONE )
    {
        prrDelete = prrAdd;
        prrAdd = NULL;

        IF_DEBUG( UPDATE2 )
        {
            Dbg_DbaseRecord(
                "New delete RR from update packet\n",
                prrDelete );
        }
    }
    ELSE_IF_DEBUG( UPDATE2 )
    {
        Dbg_DbaseRecord(
            "New add RR from update packet\n",
            prrAdd );
    }

    //
    //  create update for record
    //

    Up_CreateAppendUpdate(
        pUpdateList,
        pNode,
        prrAdd,         //  record to add
        0,              //  not type delete
        prrDelete );    //  record to delete

    return ERROR_SUCCESS;
}



BOOL
doPreconditionsRRSetsMatch(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      BOOL            bPreconOnly
    )
/*++

Routine Description:

    Check specific RR set match preconditions.

Arguments:

    pUpdateList -- ptr to update list which contains RR set(s) that must
        match

    bPreconOnly -- precon only update

Return Value:

    TRUE -- if match
    FALSE -- no match

--*/
{
    PDB_RECORD      prr;
    PDB_RECORD      prrSetLast = NULL;
    PUPDATE         pupdateFirst = NULL;
    PUPDATE         pupdate;
    PDB_NODE        pnodePrevious = NULL;
    WORD            typePrevious = 0;
    BOOL            fmatch = TRUE;
    INT             countUpdates = 0;

    DNS_DEBUG( UPDATE, ( "doPreconditionsRRSetsMatch()\n" ));

    IF_DEBUG( UPDATE )
    {
        Dbg_UpdateList( "Precon update list", pUpdateList );
    }

    //
    //  DEVNOTE: preconditions and security?
    //      several possible models for precon and security
    //      1) full security
    //          - must validate packet, before security
    //          this keeps folks from forcing DS reads
    //          - in this model, we REFUSE all packet with secure blob
    //          virtue of simplicity here, but expensive if want clients
    //          to do periodic assert updates
    //
    //      2) full "write" security
    //          - can answer precon, but if DS write required to
    //          update aging -- then REFUSE and make them do the
    //          full deal
    //          - with this approach, can do DS write in users
    //          context, per normal op
    //          - if desired can OPTIONALLY skip precon read, unless
    //          write is indicated
    //
    //      3) no security
    //          - do refresh writes in our context, all the time
    //

    //
    //  note:  i've separated collection and execution here because
    //      A)  the code is cleaner
    //      B)  later i may clean up parsing in which case this function
    //      may be delivered a nice clean RR set ready to go
    //

    //
    //  loop through all updates in list
    //      - group precondition RRs into sets
    //

    pupdate = (PUPDATE) pUpdateList->pListHead;
    ASSERT( pupdate && pupdate->pNode );

    while ( pupdate )
    {
        prr = pupdate->pAddRR;
        ASSERT( prr && prr->pRRNext == NULL );

        //
        //  starting new RR set?
        //      - set name\type for update
        //      - if attach update to previous saved update
        //      (may not be attached because previous was built from several
        //      updates)
        //      - reset ptr to first update
        //

        if ( pupdate->pNode != pnodePrevious ||
             prr->wType != typePrevious )
        {
            countUpdates++;
            pnodePrevious = pupdate->pNode;
            typePrevious = prr->wType;
            prrSetLast = prr;

            if ( pupdateFirst )
            {
                pupdateFirst->pNext = pupdate;
            }
            pupdateFirst = pupdate;
            pupdate = pupdate->pNext;
            continue;
        }

        //
        //  same node and type as previous
        //      - cut RR from this update and add it to current RR set
        //      - cut this update from list (careful to save next ptr)
        //      - dump update structure
        //

        else
        {
            register PUPDATE pupdateNext;

            ASSERT( pupdate && prr );
            ASSERT( pupdateFirst && prrSetLast );

            prrSetLast->pRRNext = prr;
            prrSetLast = prr;

            pupdateFirst->pNext = NULL;
            pupdate->pAddRR = NULL;
            pupdateNext = pupdate->pNext;

            Up_FreeUpdateEx(
                pupdate,
                FALSE,      // not executed
                TRUE );     // deref update node

            pupdate = pupdateNext;
            continue;
        }
    }

    //
    //  reset shortened update list
    //

    pUpdateList->pCurrent = pupdateFirst;
    pUpdateList->dwCount = countUpdates;

    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList( "Precon collapsed list", pUpdateList );
    }


    //
    //  execute preconditions check
    //      - if successful, save as PRECON update for refresh
    //

    pupdate = (PUPDATE) pUpdateList->pListHead;
    ASSERT( pupdate && pupdate->pNode );

    while ( pupdate )
    {
        if ( !RR_ListIsMatchingSet(
                    pupdate->pNode,
                    pupdate->pAddRR,
                    FALSE ) )               //  no forcing refresh
        {
            IF_DEBUG( UPDATE )
            {
                Dbg_DbaseNode(
                    "UPDATE Precon RR set match failure node\n",
                    pnodePrevious );
            }
            fmatch = FALSE;
            break;
        }
        pupdate->wDeleteType = UPDATE_OP_PRECON;
        pupdate = pupdate->pNext;
    }

    //
    //  if match, and aging ON, save as PRECON update
    //
    //  if ONLY PRECON update, then execute as local system update
    //  and skip security negotiation even if DS write required
    //
    //  DEVNOTE: not using LOCAL_SYSTEM for precon updates
    //      idea here is we won't WRITE to the DS with anything but user
    //      credentials to avoid precon update (aging update) bug;
    //      once we've made that decision then secure updates, need
    //      to stay in users context;   non-secure can progress in secure
    //      zone UNTIL we decide that we need to write, then they are
    //      refused;
    //
    //      an optimization is possible:
    //      precon updates CAN write as LOCAL_SYSTEM, as long as the
    //      DS node has already been written;  but if open, then must
    //      use users context;   the problem here is to handle secure
    //      update failovers -- if try to go in non-secure and FAIL
    //      must come back and use user credentials;  it is probably
    //      better to simply assume that if we arrive with credentials
    //      then it's because we were REFUSED or want mutual-auth, so
    //      should do full secure update
    //

    if ( fmatch && ( pUpdateList->Flag & DNSUPDATE_AGING_ON ) )
    {
        if ( bPreconOnly )
        {
            DNS_DEBUG( UPDATE, (
                "Precon-only update %p, will be executed as local system\n",
                pUpdateList->pMsg ));

            //pUpdateList->Flag |= DNSUPDATE_LOCAL_SYSTEM | DNSUPDATE_PRECON;
            pUpdateList->Flag |= DNSUPDATE_PRECON;
        }
    }

    //
    //  if precon failure or not aging -- cleanup list
    //

    else
    {
        DWORD   flag;

        //
        //  cleanup update list
        //      - free updates and records
        //      - but save and restore flags
        //

        ASSERT( ! (pUpdateList->Flag & DNSUPDATE_EXECUTED) );
        ASSERT( ! (pUpdateList->Flag & DNSUPDATE_COPY) );

        flag = pUpdateList->Flag;

        Up_FreeUpdatesInUpdateList( pUpdateList );
        Up_InitUpdateList( pUpdateList );

        pUpdateList->Flag = flag;
    }

    return fmatch;
}   //  doPreconditionsRRSetsMatch



BOOL
checkUpdatePolicy(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Checks to see if updates allowed under update policy.

Arguments:

    pUpdateList - list with update

    pZone - zone being updated

Return Value:

    TRUE -- update allowed to proceed
    FALSE -- update failed policy check

--*/
{
    PUPDATE         pupdate;
    PDB_NODE        pnode;
    WORD            type;
    DWORD           options;
    DWORD           nodeMask;
    DWORD           typeMask;
    BOOL            updateAllowed = TRUE;

    DNS_DEBUG( UPDATE, (
        "checkUpdatePolicy(), zone %s = %p\n"
        "    pUpdateList = %p\n",
        pZone->pszZoneName,
        pZone,
        pUpdateList ));

    //
    //  get policy options for this zone update type
    //      - secure option bits are one byte higher
    //

    options = SrvCfg_dwUpdateOptions;

    if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE )
    {
        options = (options >> 8);
    }
    if ( options == 0 )
    {
        goto Done;
    }

    //
    //  loop through all updates in list
    //

    for ( pupdate = pUpdateList->pListHead;
          pupdate != NULL;
          pupdate = pupdate->pNext )
    {
        pnode = pupdate->pNode;

        //
        //  never allow wildcard updates
        //
        
        if ( pnode->cchLabelLength == 1 && *pnode->szLabel == '*' )
        {
            updateAllowed = FALSE;
            goto Done;
        }
        
        //
        //  if precon check, then ignore policy
        //

        if ( pupdate->wDeleteType == UPDATE_OP_PRECON )
        {
            continue;
        }

        //
        //  node check
        //      - zone root             -> root NS SOA checks
        //      - DNS server host node  -> host check, delegation check
        //      - regular node          -> delegation check

        if ( pnode == pZone->pZoneRoot )
        {
            nodeMask = UPDATE_NO_SOA | UPDATE_NO_ROOT_NS;
        }
        else if ( IS_THIS_HOST_NODE(pnode) )
        {
            nodeMask = UPDATE_NO_DELEGATION_NS | UPDATE_NO_SERVER_HOST;
        }
        else
        {
            nodeMask = UPDATE_NO_DELEGATION_NS;
        }

        //
        //  find update type
        //

        if ( pupdate->pAddRR )
        {
            type = pupdate->pAddRR->wType;
        }
        else if ( pupdate->pDeleteRR )
        {
            type = pupdate->pDeleteRR->wType;
        }
        else
        {
            type = pupdate->wDeleteType;
        }

        //
        //  build policy mask for type
        //
        //  delete all is oddball case:
        //  potentially disallowed at root or DNS server host, but
        //  for ordinary node DELEGATION policy only interesting if
        //  node is ALREADY a zone root
        //

        if ( type == DNS_TYPE_A )
        {
            typeMask = UPDATE_NO_SERVER_HOST;
        }
        else if ( type == DNS_TYPE_NS )
        {
            typeMask = UPDATE_NO_ROOT_NS | UPDATE_NO_DELEGATION_NS;
        }
        else if ( type == DNS_TYPE_SOA )
        {
            typeMask = UPDATE_NO_SOA;
        }
        else if ( type == DNS_TYPE_ALL )
        {
            typeMask = 0xffffffff;

            if ( nodeMask == UPDATE_NO_DELEGATION_NS &&
                 ! IS_ZONE_ROOT(pnode) )
            {
                continue;
            }
        }
        else    // type is harmless
        {
            continue;
        }

        //
        //  if type and node have no policy
        //

        if ( (typeMask & nodeMask) & options )
        {
            DNS_DEBUG( UPDATE, (
                "Update policy failure!\n"
                "    zone     = %s (up=%d)\n"
                "    options  = %p\n"
                "    node     = %s\n"
                "    mask     = %p\n"
                "    type     = %d\n"
                "    mask     = %p\n",
                pZone->pszZoneName,
                pZone->fAllowUpdate,
                options,
                pnode->szLabel,
                nodeMask,
                type,
                typeMask ));

            updateAllowed = FALSE;
            goto Done;
        }

        DNS_DEBUG( OFF, (
            "Update policy passes!\n"
            "    zone     = %s (up=%d)\n"
            "    options  = %p\n"
            "    node     = %s\n"
            "    mask     = %p\n"
            "    type     = %d\n"
            "    mask     = %p\n",
            pZone->pszZoneName,
            pZone->fAllowUpdate,
            options,
            pnode->szLabel,
            nodeMask,
            type,
            typeMask ));

        continue;
    }

    Done:
    
    return updateAllowed;
}



DNS_STATUS
parseUpdatePacket(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Check preconditions on UPDATE request.

Arguments:

    pMsg - ptr to response info

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    register PCHAR      pch;
    PCHAR               pchname;
    PCHAR               pchNextName;
    PDB_NODE            pnode = NULL;
    PDB_NODE            pnodeClosest;
    PZONE_INFO          pzone = pMsg->pzoneCurrent;
    INT                 sectionIndex;
    INT                 countSectionRR;
    WORD                type;
    WORD                updateType = 0;
    WORD                class;
    PCHAR               pchpacketEnd;
    DNS_STATUS          status = ERROR_SUCCESS;
    BOOL                fpreconPostProcessing = FALSE;
    PARSE_RECORD        parseRR;
    DWORD               dwFlag;


    DNS_DEBUG( UPDATE, (
        "parseUpdatePacket(), zone %s = %p, pMsg = %p\n",
        pzone->pszZoneName,
        pzone,
        pMsg ));

    //
    //  loop through all resource records
    //      - already processed zone section
    //

    pchpacketEnd = DNSMSG_END( pMsg );
    pchNextName = pMsg->pCurrent;

    sectionIndex = ZONE_SECTION_INDEX;
    countSectionRR = 0;

    while( 1 )
    {
        //
        //  new section?
        //

        if ( countSectionRR == 0 )
        {
            if ( sectionIndex == ADDITIONAL_SECTION_INDEX )
            {
                break;
            }
            sectionIndex++;
            countSectionRR = RR_SECTION_COUNT( pMsg, sectionIndex );
            continue;
        }
        countSectionRR--;

        //
        //  read next RR name
        //      - insure we stay within message

        pchname = pchNextName;

        IF_DEBUG ( READ2 )
        {
            Dbg_MessageName(
                "RR name ",
                pchname,
                pMsg );
        }
        pch = Wire_SkipPacketName( pMsg, pchname );
        if ( !pch )
        {
            DNS_PRINT(( "ERROR:  bad RR owner name in update packet\n" ));
            status = DNS_RCODE_FORMAT_ERROR;
            break;
        }

        //
        //  extract RR info, type, datalength
        //      - verify RR within message
        //

        pchNextName = Wire_ParseWireRecord(
                        pch,
                        pchpacketEnd,
                        FALSE,          // no CLASS_IN requirement
                        &parseRR );
        if ( !pchNextName )
        {
            DNS_PRINT(( "ERROR:  bad RR in packet\n" ));
            status = DNS_RCODE_FORMAT_ERROR;
            break;
        }
        type = parseRR.wType;
        class = parseRR.wClass;

        //
        //  preconditions RR section -- test preconditions
        //

        if ( sectionIndex == PREREQ_SECTION_INDEX )
        {
            //  all preconditions TTLs zero
            //  note:  could argue prereq no-exists should accept type==0
            //      and screen only for existence

            if ( parseRR.dwTtl != 0 || type == 0 )
            {
                DNS_PRINT(( "ERROR:  non-zero TTL in preconditions RR\n" ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }

            //  all preconditions RRs must be within zone
            //
            //  DEVNOTE: should allow non-zone names, in zone subtree?
            //  JJCONVERT:  create lookup that allows specification of FIND in zone or delegation
            //

            pnode = Lookup_ZoneNode(
                        pzone,
                        pchname,
                        pMsg,
                        NULL,           // no lookup name
                        0,              // no flags
                        &pnodeClosest,  // find
                        NULL );         // following node ptr
            if ( !pnodeClosest )
            {
                DNS_DEBUG( UPDATE, (
                    "ERROR:  Update delete RR outside update zone\n" ));
                status = DNS_RCODE_NOTZONE;
                break;
            }
            else if ( IS_OUTSIDE_ZONE_NODE(pnodeClosest) )
            {
                DNS_DEBUG( UPDATE, (
                    "ERROR:  Update delete RR outside update zone\n" ));
                status = DNS_RCODE_NOTZONE;
                break;
            }

            //
            //  zone class -- entire RR set must exist
            //      - type NOT compound type
            //      - name must exist
            //      - build and save temporary RR
            //

            if ( class == DNS_RCLASS_INTERNET )
            {
                if ( IS_COMPOUND_TYPE(type) )
                {
                    DNS_PRINT(( "ERROR:  Bad type (%d) in prereq RR\n", type ));
                    status = DNS_RCODE_FORMAT_ERROR;
                    break;
                }
                if ( !pnode )
                {
                    DNS_DEBUG( UPDATE, (
                        "ERROR:  Prereq RR set at nonexistant node\n" ));
                    status = DNS_RCODE_NXRRSET;
                    break;
                }
                status = writeUpdateFromPacketRecord(
                            pUpdateList,
                            pnode,
                            & parseRR,
                            pMsg );
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                fpreconPostProcessing = TRUE;
                continue;
            }

            //
            //  other classes -- ANY, NONE -- are name and RR set exist\no
            //      - no compound types except ANY
            //      - no data
            //
            //  note:  compound test perhaps not strictly necessary, could
            //      just let the type check succeed or fail
            //

            if ( parseRR.wDataLength != 0 )
            {
                DNS_PRINT(( "ERROR:  Preconditions RR data in non-zone class\n" ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }
            if ( IS_COMPOUND_TYPE_EXCEPT_ANY(type) )
            {
                DNS_PRINT(( "ERROR:  Preconditions RR with invalid type\n" ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }

            //
            //  class ANY -- MUST exist
            //      - for ANY, name MUST exist
            //      - for other types, RR set of type MUST exist
            //

            if ( class == DNS_RCLASS_ALL )
            {
                if ( !RR_ListIsMatchingType(
                            pnode,
                            type ) )
                {
                    if ( type == DNS_TYPE_ANY )
                    {
                        DNS_DEBUG( UPDATE, (
                            "ERROR:  Preconditions missing name\n" ));
                        status = DNS_RCODE_NAME_ERROR;
                        break;
                    }
                    else
                    {
                        DNS_DEBUG( UPDATE, (
                            "ERROR:  Preconditions missing RR set\n" ));
                        status = DNS_RCODE_NXRRSET;
                        break;
                    }
                }
                continue;
            }

            //
            //  class NONE -- MUST NOT exist
            //      - for ANY, name MUST NOT exist
            //      - for other types, RR set of type MUST NOT exist
            //

            else if ( class == DNS_RCLASS_NONE )
            {
                if ( RR_ListIsMatchingType(
                        pnode,
                        type ) )
                {
                    if ( type == DNS_TYPE_ANY )
                    {
                        DNS_DEBUG( UPDATE,
                            ( "ERROR:  Preconditions fail no-exist name\n" ));
                        status = DNS_RCODE_YXDOMAIN;
                        break;
                    }
                    else
                    {
                        DNS_DEBUG( UPDATE,
                            ( "ERROR:  Preconditions fail no-exist RR set\n" ));
                        status = DNS_RCODE_YXRRSET;
                        break;
                    }
                }
                continue;
            }

            //
            //  all other classes are errors
            //

            else
            {
                DNS_PRINT(( "ERROR:  Invalid UPDATE precon class %d\n", class ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }

        }   // end preconditions processing


        //
        //  in Update RR section -- do update processing
        //

        else if ( sectionIndex == UPDATE_SECTION_INDEX )
        {
            //
            //  delayed preconditions processing
            //

            if ( fpreconPostProcessing )
            {
                fpreconPostProcessing = FALSE;
                if ( !doPreconditionsRRSetsMatch(
                            pUpdateList,
                            FALSE           // not precon only
                            ) )
                {
                    status = DNS_RCODE_NXRRSET;
                    break;
                }
            }

            //  trap type==0
            //  note:  could be considered valid for delete conditions
            //      but simpler just to whack right here
            //      type==0, records kick of type existence ASSERT()s

            if ( type == 0 )
            {
                DNS_PRINT(( "ERROR:  zero type in update RR\n" ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }

            //  track update types
            //      - track if single type or mixed type update

            if ( type != updateType )
            {
                if ( updateType )
                {
                    updateType = STATS_TYPE_MIXED;
                }
                else
                {
                    updateType = type;
                }
            }

            //
            //  zone class -- RR add
            //      - find/create name since doing add
            //      - name must be in zone
            //      - type NOT compound type
            //
            //  DEVNOTE: no update of non-glue, non-NS records below zone?
            //

            if ( class == DNS_RCLASS_INTERNET )
            {
                if ( IS_COMPOUND_TYPE(type) )
                {
                    DNS_PRINT(( "ERROR:  Bad (compound) type in update RR\n" ));
                    status = DNS_RCODE_FORMAT_ERROR;
                    break;
                }

                pnode = Lookup_ZoneNode(
                            pzone,
                            pchname,
                            pMsg,
                            NULL,                   // no lookup name
                            LOOKUP_WITHIN_ZONE,     // don't create outside zone
                            NULL,                   // create not find
                            NULL );                 // following node ptr
                if ( !pnode )
                {
                    //  might be bad name, but return NOT_ZONE to keep denise happy
                    status = GetLastError();
                    if ( status == ERROR_INVALID_NAME )
                    {
                        status = DNS_RCODE_FORMERR;
                    }
                    else
                    {
                        status = DNS_RCODE_NOTZONE;
                    }
                    break;
                }
                if ( IS_OUTSIDE_ZONE_NODE(pnode) )
                {
                    status = DNS_RCODE_NOTZONE;
                    break;
                }
                status = writeUpdateFromPacketRecord(
                            pUpdateList,
                            pnode,
                            & parseRR,
                            pMsg );
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                continue;
            }

            //
            //  all other classes -- delete operations
            //      - no TTL
            //      - find name since only doing delete
            //
            //  DEVNOTE: should allow non-zone names, in zone subtree?
            //

            if ( parseRR.dwTtl != 0 )
            {
                DNS_PRINT(( "ERROR:  Non-zero TTL in update delete\n" ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }
            pnode = Lookup_ZoneNode(
                        pzone,
                        pchname,
                        pMsg,
                        NULL,                   // no lookup name
                        LOOKUP_WITHIN_ZONE,     // don't create outside zone
                        &pnodeClosest,          // find
                        NULL );                 // following node ptr
            if ( !pnodeClosest )
            {
                DNS_DEBUG( UPDATE, (
                    "ERROR:  Update delete RR outside update zone\n" ));
                status = DNS_RCODE_NOTZONE;
                break;
            }
            else if ( IS_OUTSIDE_ZONE_NODE(pnodeClosest) )
            {
                DNS_PRINT(( "ERROR:  Update delete RR outside update zone\n" ));
                status = DNS_RCODE_NOTZONE;
                break;
            }

            //
            //  class ANY -- delete RR set, or all sets
            //      - no RR data
            //      - ANY type allow, but no other compound types
            //      - no update if node doesn't exist
            //      - do delete, special case update zone root
            //

            if ( class == DNS_RCLASS_ALL )
            {
                if ( parseRR.wDataLength != 0 || IS_COMPOUND_TYPE_EXCEPT_ANY(type) )
                {
                    DNS_PRINT(( "ERROR:  Update class ANY (delete) invalid\n" ));
                    status = DNS_RCODE_FORMAT_ERROR;
                    break;
                }
                if ( !pnode )
                {
                    DNS_DEBUG( UPDATE, ( "UPDATE delete a non-existant node\n" ));
                    continue;
                }

                if ( !Up_CreateAppendUpdate(
                          pUpdateList,
                          pnode,
                          NULL,
                          type,       // type delete
                          NULL ) )
                {
                    status = DNS_RCODE_SERVER_FAILURE;
                    break;
                }
                continue;
            }

            //
            //  class NONE -- delete a particular RR from an RR set
            //      - no compound types
            //      - ignore attempt to delete SOA
            //      - ignore attempts to delete non-existent record
            //
            //  DEVNOTE: DS issue -- delete non-existant record should query DS
            //          for name, then fail
            //

            else if ( class == DNS_RCLASS_NONE )
            {
                if ( IS_COMPOUND_TYPE(type) )
                {
                    DNS_PRINT((
                        "ERROR:  Update class NONE (delete) invalid with type = %d\n",
                        type ));
                    status = DNS_RCODE_FORMAT_ERROR;
                    break;
                }
                if ( !pnode )
                {
                    DNS_DEBUG( UPDATE, ( "UPDATE delete a non-existant node\n" ));
                    continue;
                }
                if ( type == DNS_TYPE_SOA )
                {
                    DNS_DEBUG( UPDATE, ( "UPDATE delete an SOA record\n" ));
                    continue;
                }
                status = writeUpdateFromPacketRecord(
                            pUpdateList,
                            pnode,
                            & parseRR,
                            pMsg );
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                continue;
            }

            //
            //  unknown class
            //

            else
            {
                DNS_PRINT(( "ERROR:  Invalid UPDATE class %d\n", class ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }

        }   //  end Update section

        //
        //  in Additional section
        //

        else
        {
            ASSERT( sectionIndex == ADDITIONAL_SECTION_INDEX );
            break;
        }

    }   // loop writing update RRs to database

    //
    //  delayed preconditions processing
    //  test again here to allow for case where no update section
    //

    if ( fpreconPostProcessing )
    {
        DNS_DEBUG( UPDATE, (
            "WARNING:  Processing preconditions RR set for packet %p\n"
            "    with no UPDATE section\n",
            pMsg ));

        if ( !doPreconditionsRRSetsMatch(
                    pUpdateList,
                    TRUE ) )            //  precon only
        {
            status = DNS_RCODE_NXRRSET;
        }
    }

    //
    //  update type tracking
    //

    if ( status == ERROR_SUCCESS && updateType )
    {
        if ( updateType > STATS_TYPE_MAX )
        {
            updateType = STATS_TYPE_UNKNOWN;
        }
        STAT_INC( WireUpdateStats.UpdateType[updateType] );
    }

    //
    //  check dynamic update policy
    //

    if ( !checkUpdatePolicy( pzone, pUpdateList ) )
    {
        status = DNS_RCODE_REFUSED;
    }

    DNS_DEBUG( UPDATE, (
        "Parsed UPDATE message at %p\n"
        "    status = %d\n",
        pMsg,
        status ));

    return status;
}   // parseUpdatePacket



VOID
rejectUpdateWithRcode(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           Rcode
    )
/*++

Routine Description:

    Reject update request with given response code.

Arguments:

    pMsg -- update message being rejected

    Rcode -- rcode to return in response

Return Value:

    None.

--*/
{
    LPSTR   pszclientIp = MSG_IP_STRING( pMsg );

    DNS_DEBUG( UPDATE, (
        "ERROR:  Update failure (%s) for packet %p\n"
        "    client IP %s\n",
        Dns_ResponseCodeString( Rcode ),
        pMsg,
        pszclientIp ));

    switch( Rcode )
    {

    case DNS_RCODE_SERVER_FAILURE:
#if 0
        //
        //  server failure now encompasses common case of collision, don't log error
        //

        DNS_LOG_EVENT_BAD_PACKET(
            DNS_EVENT_SERVER_FAILURE_PROCESSING_PACKET,
            pMsg );

#endif
        DNS_DEBUG( UPDATE, (
            "Server failure processing UPDATE packet from %s\n",
            pszclientIp ));
        //ASSERT( FALSE );
        break;

    case DNS_RCODE_FORMAT_ERROR:

        DNS_LOG_EVENT_BAD_PACKET(
            DNS_EVENT_BAD_UPDATE_PACKET,
            pMsg );

        DNS_DEBUG( ANY, (
            "FORMERR in UPDATE packet from %s\n",
            pszclientIp ));
        STAT_INC( WireUpdateStats.FormErr );
        break;

    case DNS_RCODE_NAME_ERROR:

        STAT_INC( WireUpdateStats.NxDomain );
        break;

    case DNS_RCODE_REFUSED:

        DNS_DEBUG( UPDATE, (
            "Refused UPDATE query at %p from %s\n",
            pMsg,
            pszclientIp ));
        STAT_INC( WireUpdateStats.Refused );
        break;

    case DNS_RCODE_YXDOMAIN:

        STAT_INC( WireUpdateStats.YxDomain );
        break;

    case DNS_RCODE_YXRRSET:

        STAT_INC( WireUpdateStats.YxRrset );
        break;

    case DNS_RCODE_NXRRSET:

        STAT_INC( WireUpdateStats.NxRrset );
        break;

    case DNS_RCODE_NOTAUTH:

        STAT_INC( WireUpdateStats.NotAuth );
        break;

    case DNS_RCODE_NOTZONE:

        STAT_INC( WireUpdateStats.NotZone );
        break;

    case DNS_RCODE_NOT_IMPLEMENTED:

        STAT_INC( WireUpdateStats.NotImpl );
        break;

    default:
        DNS_PRINT(( "ERROR:  unknown rcode = %p\n", Rcode ));
        ASSERT( FALSE );
    }

    IF_DEBUG( UPDATE2 )
    {
        Dbg_DnsMessage(
            "Sending update failure response:\n",
            pMsg );
    }
    Reject_RequestIntact( pMsg, ( UCHAR ) Rcode, 0 );
    STAT_INC( WireUpdateStats.Rejected );
    PERF_INC( pcDynamicUpdateRejected );              // PerfMon hook
}



BOOL
processWireUpdateMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process dynamic update message.

    This is the core routine that locks zone and database, calls parser
    do update (if necessary), logs update, unlocks, sends response.

Arguments:

    pMsg -- UPDATE packet

Return Value:

    TRUE if update completed.
    FALSE if update requeued.

--*/
{
    PZONE_INFO      pzone = pMsg->pzoneCurrent;
    DNS_STATUS      status;
    UPDATE_LIST     updateList;
    DWORD           exception;
    DWORD           dwType;
    BOOL            bnoUpdatePrecon = FALSE;

    //
    //  lock zone for update, if fail requeue packet
    //
    //  should not generally happen as check if zone locked before dequeue
    //  but occasionally someone else could sneak in
    //

    if ( !Zone_LockForUpdate( pzone ) )
    {
        DNS_PRINT((
            "WARNING:  unable to lock zone for UPDATE packet %p\n",
            pMsg ));
        PQ_QueuePacketEx( g_UpdateQueue, pMsg, FALSE );
        return FALSE;
    }

    //  init update list
    //  aging on for dynamic updates

    Up_InitUpdateList( &updateList );

    updateList.Flag = DNSUPDATE_PACKET;
    updateList.Flag |= DNSUPDATE_AGING_ON;

    //
    //  parse packet
    //

    status = parseUpdatePacket( pMsg, &updateList );
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //  if precon only and not aging zone -- then no update necessary

    if ( (updateList.Flag & DNSUPDATE_PRECON)  &&  !pzone->bAging )
    {
        goto PreconOnly;
    }

    //  note if has security section
    //
    //  DEVNOTE: should parse update and know if packet secure

    if ( pMsg->Head.AdditionalCount == 0 )
    {
        updateList.Flag |= DNSUPDATE_NONSECURE_PACKET;
    }

    updateList.pMsg = pMsg;

    status = Up_ExecuteUpdate(
                    pzone,
                    &updateList,
                    DNSUPDATE_ALREADY_LOCKED );
    if ( status != ERROR_SUCCESS )
    {
        goto FailAlreadyCleanedUp;
    }

    //  ACK update packet
    //      - setup packet for response

    pMsg->pCurrent = DNSMSG_END( pMsg );
    pMsg->Head.IsResponse = TRUE;
    pMsg->fDelete = TRUE;

    IF_DEBUG( UPDATE2 )
    {
        Dbg_DnsMessage(
            "Sending update response:\n",
            pMsg );
    }
    Send_Msg( pMsg, 0 );

    return TRUE;


PreconOnly:

    DNS_DEBUG( UPDATE2, (
        "Successful precon only update in non-aging zone\n" ));

    //  clear zone lock

    Zone_UnlockAfterAdminUpdate( pzone );

    //  ACK update packet

    pMsg->pCurrent = DNSMSG_END( pMsg );
    pMsg->Head.IsResponse = TRUE;
    pMsg->fDelete = TRUE;

    IF_DEBUG( UPDATE2 )
    {
        Dbg_DnsMessage(
            "Sending precon update response:\n",
            pMsg );
    }
    Send_Msg( pMsg, 0 );

    //  cleanup update list

    Up_FreeUpdatesInUpdateList( &updateList );

    return TRUE;


Failure:

    //
    //  all failure (non-update) cases
    //

    Zone_UnlockAfterAdminUpdate( pzone );

    //  cleanup update list

    Up_FreeUpdatesInUpdateList( &updateList );


FailAlreadyCleanedUp:

    //  determine failure RCODE

    if ( (DWORD)status > MAX_UPDATE_RCODE )
    {
        //  map standard DNS ERRORs corresponding to RCODEs directly

        if ( status > DNS_ERROR_RESPONSE_CODES_BASE  &&
             status < DNS_ERROR_RESPONSE_CODES_BASE + 16 )
        {
            status -= DNS_ERROR_RESPONSE_CODES_BASE;
        }

        //  map invalid into FORMERR

        else if ( status == DNS_ERROR_INVALID_NAME ||
                  status == DNS_ERROR_INVALID_DATA )
        {
            status = DNS_RCODE_FORMAT_ERROR;
        }

        //  default with REFUSED
        //      - handles all possible status codes from secure update

        else
        {
            status = DNS_RCODE_REFUSED;
        }
    }

    rejectUpdateWithRcode(
        pMsg,
        status );

    return TRUE;
}




VOID
Up_WriteDerivedUpdateStats(
    VOID
    )
/*++

Routine Description:

    Write derived UPDATE status.

Arguments:

    None

Return Value:

    None

--*/
{
    //  stats from update queue

    WireUpdateStats.Queued  = g_UpdateQueue->cQueued;
    PERF_SET( pcDynamicUpdateQueued , g_UpdateQueue->cQueued );      // PerfMon hook
    WireUpdateStats.Timeout = g_UpdateQueue->cTimedOut;
    PERF_SET( pcDynamicUpdateTimeOut , g_UpdateQueue->cTimedOut );   // PerfMon hook
    WireUpdateStats.InQueue = g_UpdateQueue->cLength;

    //  stats from forwarding queue

    WireUpdateStats.Forwards        = g_UpdateForwardingQueue->cQueued;
    WireUpdateStats.ForwardTimeouts = g_UpdateForwardingQueue->cTimedOut;
    WireUpdateStats.ForwardInQueue  = g_UpdateForwardingQueue->cLength;
}



//
//  Update forwarding
//

VOID
updateForwardConnectCallback(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      BOOL            fConnected
    )
/*++

Routine Description:

    Callback when TCP forwarding routines complete connect.

    If connected -- send update query
    If not -- continue lookup on query

Arguments:

    pMsg -- update message

    fConnected -- connect to remote DNS completed

Return Value:

    None

--*/
{
    ASSERT( pMsg );
    ASSERT( !pMsg->pConnection );

    DNS_DEBUG( UPDATE, (
        "updateConnectCallback( %p )\n"
        "    TCP = %d\n"
        "    remote DNS = %s\n"
        "    connect successful = %d\n",
        pMsg,
        pMsg->fTcp,
        MSG_IP_STRING( pMsg ),
        fConnected ));

    //
    //  send update forward
    //      - clear forwarding queue of dead entries
    //      - stick on forwarding packet queue
    //      - use new XID in forward
    //
    //  note:  to avoid duplicating this code, we're also calling this routine
    //      to send regular UDP forwards
    //

    if ( fConnected )
    {
        if ( g_UpdateForwardingQueue->cLength )
        {
            PQ_DiscardExpiredQueuedPackets(
                g_UpdateForwardingQueue,
                FALSE );
        }

        pMsg->wQueuingXid = 0;      //  not requeuing, get new XID
        pMsg->dwExpireTime = 0;     //  default expire time

        DNS_DEBUG( UPDATE2, (
            "Forwarding UPDATE packet %p, queuing XID = %hx\n"
            "    to zone primary at %s\n",
            pMsg,
            pMsg->Head.Xid,
            MSG_IP_STRING( pMsg ) ));

        PQ_QueuePacketWithXidAndSend(
                g_UpdateForwardingQueue,
                pMsg );

        STAT_INC( WireUpdateStats.Forwards );
        return;
    }

    //
    //  connection failed
    //      - send failure to client
    //

    else
    {
        IF_DEBUG( UPDATE )
        {
            Dbg_DnsMessage(
                "Failed TCP connect update forward",
                pMsg );
        }
        ASSERT( !pMsg->fTcp );

        RESTORE_FORWARDING_FIELDS(pMsg);
        pMsg->fDelete = TRUE;
        Reject_RequestIntact( pMsg, DNS_RCODE_SERVER_FAILURE, 0 );
        return;
    }
}



VOID
Up_ForwardUpdateToPrimary(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Forward dynamic update to primary DNS for zone.

Arguments:

    pMsg -- UPDATE packet

Return Value:

    None.

--*/
{
    PZONE_INFO      pzone = pMsg->pzoneCurrent;
    DNS_ADDR        primaryAddr;

    DNS_DEBUG( UPDATE, (
        "Up_ForwardUpdateToPrimary( %p ) for zone %s\n",
        pMsg,
        pzone->pszZoneName ));

    //
    //  get primary IP
    //
    //  DEVNOTE: must save primary IP
    //      - get from SOA primary, NS, A
    //      - on load, again on successful transfer
    //

    DnsAddr_Copy( &primaryAddr, &pzone->ipPrimary );
    if ( DnsAddr_IsClear( &primaryAddr ) )
    {
        if ( pzone->aipMasters && pzone->aipMasters->AddrCount > 0 )
        {
            DnsAddr_Copy( &primaryAddr, &pzone->aipMasters->AddrArray[ 0 ] );
            DnsAddr_Copy( &pzone->ipPrimary, &pzone->aipMasters->AddrArray[ 0 ] );
        }
        else
        {
            Reject_RequestIntact( pMsg, DNS_RCODE_SERVER_FAILURE, 0 );
            ASSERT( FALSE );
            return;
        }
    }
    ASSERT( !DnsAddr_IsClear( &pzone->ipPrimary ) );

    //
    //  setup message for queuing and resend
    //

    SAVE_FORWARDING_FIELDS(pMsg);
    pMsg->fDelete = FALSE;
    pMsg->pCurrent = DNSMSG_END( pMsg );
    pMsg->Socket = g_UdpSendSocket;
    DnsAddr_Copy( &pMsg->RemoteAddr, &primaryAddr );
    DnsAddr_SetPort( &pMsg->RemoteAddr, DNS_PORT_NET_ORDER );

    //
    //  DEVNOTE: common forward query architecture?
    //      - save off old
    //      - do TCP check, connect, save circut
    //      - send
    //      - note recurse (cause queries always < 512)
    //          will already have saved
    //

    //
    //  need TCP connection to primary
    //      - must connect if greater than max UDP length
    //

    if ( pMsg->MessageLength > DNS_RFC_MAX_UDP_PACKET_LENGTH )
    {
        ASSERT( pMsg->fTcp );

        STAT_INC( WireUpdateStats.TcpForwards );

        Tcp_ConnectForForwarding(
             pMsg,
             &primaryAddr,
             updateForwardConnectCallback );
        return;
    }

    //
    //  forward update packet
    //
    //  note:  to save duplicate code, we just call TCP forwarding connect
    //      completion routine above, with successful connect indication
    //      this queues and send update to remote DNS
    //

    updateForwardConnectCallback(
        pMsg,
        TRUE );         //  UDP equivalent to successful connect
}



VOID
Up_ForwardUpdateResponseToClient(
    IN OUT  PDNS_MSGINFO    pResponse
    )
/*++

Routine Description:

    Forward dynamic update response back to client.

Arguments:

    pResponse -- UPDATE packet

Return Value:

    None.

--*/
{
    PDNS_MSGINFO  pquery;

    DNS_DEBUG( UPDATE, (
        "Up_ForwardUpdateResponseToClient( %p )\n",
        pResponse ));

    //
    //  note that caller frees pResponse (answer.c)
    //  this routine need only cleanup original query (if found in queue)
    //

    //
    //  dequeue matching update query
    //

    pquery = PQ_DequeuePacketWithMatchingXid(
                g_UpdateForwardingQueue,
                pResponse->Head.Xid );
    if ( !pquery )
    {
        //  no matching query?
        //  this can happen if reponse comes back after timeout

        IF_DEBUG( RECURSE )
        {
            EnterCriticalSection( & g_UpdateForwardingQueue->csQueue );
            DNS_PRINT((
                "No matching UPDATE for response at %p -- discarding\n"
                "    Response XID = 0x%04x\n",
                pResponse,
                pResponse->Head.Xid ));
            Dbg_PacketQueue(
                "Update packet queue -- no matching response",
                g_UpdateForwardingQueue );
            LeaveCriticalSection( & g_UpdateForwardingQueue->csQueue );
        }
        return;
    }

    //
    //  setup message for response to client
    //      - if TCP close connection used for forwarding
    //      - note:  we do NOT close connection from client;  it is
    //      allowed to send multiple messages per RFC
    //

    if ( pResponse->fTcp )
    {
        DNS_DEBUG( UPDATE, (
            "Deleting TCP update forwarding connection on socket %d\n",
            pResponse->Socket ));

        Tcp_ConnectionDeleteForSocket( pResponse->Socket, NULL );
    }
    STAT_INC( WireUpdateStats.ForwardResponses );

    Send_ForwardResponseAsReply(
            pResponse,
            pquery );

    Packet_Free( pquery );
    return;
}



DNS_STATUS
rollBackFailedUpdateFromDs(
    IN      PLDAP           pLdapHandle,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Roll back failed update, rewriting current nodes to DS.

Arguments:

    pUpdateList - list with failed update

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    PDB_NODE        pnodeReal;
    PDB_NODE        pnodeTemp;
    DNS_STATUS      status;

    DNS_DEBUG( UPDATE, (
        "rollBackFailedUpdateFromDs()\n" ));

    //
    //  loop through all updates in list
    //
    //      - find or create temporary node for real database node
    //      - if creating, create copy of node's RR list, to "execute" update on
    //      - update reset to point at temporary node
    //

    for ( pnodeTemp = pUpdateList->pTempNodeList;
          pnodeTemp != NULL;
          pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp) )
    {
        //  if reach node that failed write, we're done rolling back

        if ( pnodeTemp == pUpdateList->pNodeFailed )
        {
            break;
        }

        if ( TNODE_FLAG(pnodeTemp) == TNODE_FLAG_ROLLED_BACK )
        {
            DNS_DEBUG( UPDATE, (
                "Rollback previous completed on temp node %p\n", pnodeTemp ));
            ASSERT( FALSE );
            continue;
        }

        //  find real node corresponding to update temp node
        //  rewrite real node to DS to overwrite previous update
        //
        //  note:  this depends on fact that currently keeping all DNS records
        //      in a single DS attribute;  if this changes, then MUST include
        //      type information here from update OR always rewrite entire
        //      node when rolling back
        //

        pnodeReal = TNODE_MATCHING_REAL_NODE( pnodeTemp );
        TNODE_FLAG(pnodeTemp) = TNODE_FLAG_ROLLED_BACK;

        DNS_DEBUG( UPDATE, (
            "Rollback temp node %p, real node %p\n",
            pnodeTemp, pnodeReal ));

        status = Ds_WriteNodeToDs(
                    pLdapHandle,
                    pnodeReal,
                    DNS_TYPE_ALL,
                    DNSDS_REPLACE,
                    pZone,
                    0 );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  rollback DS write failed on node %s %p\n",
                pnodeReal->szLabel,
                pnodeReal ));
            Ds_ErrorHandler ( status, NULL, pLdapHandle, 0 );
        }
    }

    return ERROR_SUCCESS;
}



//
//  Update thread
//

DWORD
Update_Thread(
    IN      LPVOID      Dummy
    )
/*++

Routine Description:

    Thread to execute dynamic updates.

    There are not done in line, for two reasons:

    1) security updates can take a while, so that any reasonably long list
        of updates would block UDP thread cleaning update list for a while

    2) secure updates come in on TCP thread and hence directly block TCP
        thread's capability to function while update is being processed

Arguments:

    Dummy - unused

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    PDNS_MSGINFO    pmsg;
    HANDLE          waitHandleArray[3];
    DWORD           err;


    UPDATE_DNS_TIME();

    DNS_DEBUG( INIT, (
        "\nStarting update thread at %d\n",
        DNS_TIME() ));

    //
    //  initialize array of objects to wait on
    //      - shutdown
    //      - update packet queued

    waitHandleArray[0] = hDnsShutdownEvent;
    waitHandleArray[1] = g_UpdateQueue->hEvent;
    waitHandleArray[2] = g_SecureNegoQueue->hEvent;


    //
    //  loop until service exit
    //
    //  this thread executes whenever an update is queued to it
    //

    while ( TRUE )
    {
        //  Check and possibly wait on service status
        //  doing this at top of loop, so we hold off any processing
        //  until zones are loaded

        if ( !Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, ( "Terminating recursion timeout thread\n" ));
            return 1;
        }

        UPDATE_DNS_TIME();

        //
        //  process update packet for if it's zone is unlocked
        //

        while ( pmsg = PQ_DequeueNextPacketOfUnlockedZone( g_UpdateQueue ) )
        {
            processWireUpdateMessage(pmsg);
        }

        //
        //  clean forwarding queue -- if anything in there
        //

        if ( g_UpdateForwardingQueue->cLength )
        {
            PQ_DiscardExpiredQueuedPackets(
                g_UpdateForwardingQueue,
                FALSE );        //  queue not locked
        }

        //
        //  handle security negotiation
        //
        //  DEVNOTE: need to delete and respond? at all?
        //      if nego packet is more than client timeout old
        //      interesting side issue:  completing pending negotiations
        //      (in stage two) so that the context is available when
        //      client retries
        //

        while ( pmsg = PQ_DequeueNextPacket( g_SecureNegoQueue, FALSE ) )
        {
            Answer_TkeyQuery( pmsg );
        }

        //
        //  if no more updates available -- wait.
        //      - five minute limit to limit forwarding storm filling queue
        //

        err = WaitForMultipleObjects(
                    3,
                    waitHandleArray,
                    FALSE,                  // either event
                    300000 );               // five minutes

        ASSERT( err <= ( WAIT_OBJECT_0 + 2 ) || err == WAIT_TIMEOUT );

        DNS_DEBUG( UPDATE, (
            "Update thread wakeup for %s\n",
            (err == WAIT_TIMEOUT) ? "timeout" : "event" ));

        //  we immediately check service status before retrying
        //  so no need to separate wait events

    }   //  loop until service shutdown
}




//
//  Update execution subroutines
//

DNS_STATUS
processDsSecureUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Process dynamic update message.

    This is the core routine that locks zone and database, calls parser
    do update (if necessary), logs update, unlocks, sends response.

    This function will always be called in one of these contexts:
    
    1) The DNS server, in which case the DNS server should be the
       update client (and creator/owner) of the record.
    
    2) The DNS server, but the update list will have a pMsg which
       indicates that we must impersonate the pMsg's client identity
       and open up a new DS session for the update.
       
    2) An RPC client. The thread must already be impersonating the
       RPC client. A new DS session will be opened for all admin
       updates so that the RPC client's credentials are used.

Arguments:

    pZone       -- zone being updated

    pUpdateList -- parsed update list

Return Value:

    TRUE if update completed.
    FALSE if update requeued.

--*/
{
    DBG_FN( "processDsSecureUpdate" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DNS_STATUS      statusFinal = ERROR_SUCCESS;
    DNS_STATUS      tempStatus;
    HANDLE          hcontext = NULL;
    PLDAP           pldap = NULL;
    //DNS_SECCTXT_KEY key;
    BOOL            fimpersonatingClient = FALSE;
    PDB_NODE        pnode;
    PDB_NODE        pRealNode, pNode;
    LPSTR           pszFailInfo = NULL;
    PDNS_MSGINFO    pMsg = (PDNS_MSGINFO) pUpdateList->pMsg;

    DNS_DEBUG( UPDATE, ( "Enter processSecureUpdate()\n" ));

    //
    //  DEVNOTE: finally in a position to check for no-ops before security check
    //      i'm not sure this is desirably (our clients in general won't send them,
    //      they'll do precon stuff first -- not sure about Cliff though
    //

    //
    //  reject unsecure packets immediately as optimization
    //      - unless no-ops, in which case just return success, allowing
    //          security stuff to be skipped
    //

    if ( pMsg &&
         pMsg->Head.AdditionalCount == 0 )
    {
        //  shouldn't fall here anymore

        ASSERT( FALSE );

        if ( checkForEmptyUpdate(
                    pUpdateList,
                    pZone ) )
        {
            DNS_DEBUG( UPDATE, (
                "No-op non-secure update %p in secure zone -- returning NOERROR\n",
                pMsg ));
            return ERROR_SUCCESS;
        }
        DNS_DEBUG( UPDATE, (
            "Non-secure update %p in secure zone -- returning REFUSED\n",
            pMsg ));

        UPDATE_STAT_INC( pUpdateList, RefusedNonSecure );
        return DNS_RCODE_REFUSED;
    }

    //
    //  DEVNOTE: eliminate SKWANSEC hacks
    //
    //  HACK:  setup hack arounds
    //

    if ( SrvCfg_fTest6 )
    {
        SecBigTimeSkew = SrvCfg_fTest6;
    }

    if ( pMsg )
    {
        //
        // We have a message to process:
        // wire processing
        //

        ASSERT( pUpdateList->Flag & DNSUPDATE_PACKET );

        //
        //  read TSIG, match to security context and verify sig
        //
        //  if fails and TSIG exists, set appropriate extended RCODE
        //
        //  FIX6:  switch to non-IP4 version when IP6 remote addr fixed
        //

        status = Dns_FindSecurityContextFromAndVerifySignature(
                    &hcontext,
                    &pMsg->RemoteAddr,
                    DNS_HEADER_PTR( pMsg ),
                    DNSMSG_END( pMsg ) );

        if ( status != ERROR_SUCCESS )
        {
            pszFailInfo = "Security context verification";
            goto Failed;
        }
    }

    //
    //  detect, respond to empty updates
    //      - do this now so can avoid security processing
    //
    //  note, could argue to do security check first, to handle REFUSED case
    //  however since we can generate just as much activity with query, there
    //  doesn't seem to be any real denial of service hole that is opened up here
    //  folks simply learn the current state of various names, which they can
    //  learn more easily through query
    //
    //  note: now doing this after security check AS must SIGN the response to
    //      give full security to clients -- client knows update successful
    //

    //
    //  note, we now handle non-secure packets to secure zone that no-op
    //  as success (no security hole there -- think about it)
    //  so this already screens out folks who do NOT NEED mutual auth, and
    //      are no-oping the update
    //  so if we worked around security for no-ops now, that would simply bypass
    //      mutual auth for folks who presumably wanted it
    //
    //  DEVNOTE: we take AdditionaCount==0 to be non-secure, so the one caveat
    //      is that folks who put something in Additional section will not get
    //      this work around above
    //

    //  note, should log-to-stats (empty or duplicate)

    if ( checkForEmptyUpdate(
                pUpdateList,
                pZone ) )
    {
        DNS_DEBUG( UPDATE, (
            "No-op secure update %p, sent directly to signing\n",
            pMsg ));

        // if wire processing sign & send response

        if ( pMsg )
        {
            goto Sign;
        }
        ASSERT( status == ERROR_SUCCESS );
        goto Failed;
    }

    //
    //  build update
    //      1) build temporary node\RR copies of target of updates
    //      2) execute update on these temporary nodes
    //

    status = prepareUpdateListForExecution( pZone, pUpdateList );
    if ( status != ERROR_SUCCESS )
    {
        pszFailInfo = "DS update initialization";
        statusFinal = DNS_ERROR_RCODE_SERVER_FAILURE;
        goto Failed;
    }

    status = Up_ApplyUpdatesToDatabase(
                pUpdateList,
                pZone,
                pUpdateList->Flag | DNSUPDATE_SECURE_PACKET );
    if ( status != ERROR_SUCCESS )
    {
        pszFailInfo = "Update in-memory execution";
        goto Failed;
    }

    //
    //  determine if DS write is necessary
    //      - update changed RRs
    //      OR
    //      - some RRs need refresh
    //
    //  skip impersonation and write, drop to sign response
    //

    if ( !checkTempNodesForUpdateEffect(
                pZone,
                pUpdateList ) )
    {
        //  DEVNOTE: separate these to update stats

        STAT_INC( DsStats.UpdateLists );
        STAT_INC( DsStats.UpdateNodes );
        STAT_INC( DsStats.UpdateSuppressed );
        STAT_INC( DsStats.DsWriteSuppressed );
        goto Sign;
    }

    //
    //  dynamic update -- impersonate client
    //

    if ( pMsg )
    {
        ASSERT( pUpdateList->Flag & DNSUPDATE_PACKET );

        status = Dns_SrvImpersonateClient( hcontext );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "FAILURE: can't impersonate client \n" ));
            ASSERT( FALSE );
            statusFinal = DNS_ERROR_RCODE_SERVER_FAILURE;
            pszFailInfo = "Impersonating incoming client";
            goto Failed;
        }

        #if DBG
        {
            PSID                    pSid = NULL;
            HANDLE                  hToken = NULL;

            if ( OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &hToken ) )
            {
                if ( Dbg_GetUserSidForToken( hToken, &pSid ) )
                {
                    DNS_DEBUG( UPDATE, (
                        "%s: impersonating: %S\n", fn,
                        Dbg_DumpSid( pSid ) ));
                    Dbg_FreeUserSid( &pSid );
                }
                else
                {
                    DNS_DEBUG( UPDATE, (
                        "%s: GetUserSidForToken failed\n", fn ));
                }
                CloseHandle( hToken );
            }
            else
            {
                DNS_DEBUG( RPC, (
                    "%s: error %d opening thread token (debug only!)\n", fn,
                     GetLastError() ));
            }
        }
        #endif

        fimpersonatingClient = TRUE;
    }

    //
    //  Open new LDAP session in impersonated context (for wire updates and
    //  for administrative updates).
    //

    if ( fimpersonatingClient || ( pUpdateList->Flag & DNSUPDATE_ADMIN ) )
    {
        status = Ds_OpenServerForSecureUpdate( &pldap );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "FAILURE: can't open DS server \n" ));
            statusFinal = DNS_ERROR_RCODE_SERVER_FAILURE;
            pszFailInfo = "Contacting DS";
            goto Failed;
        }
        ASSERT( pldap );
    }

    //
    //  attempt to execute update in DS
    //      => if succeeds security check successful
    //      => if fails we roll back DS update by rewriting REAL nodes to DS
    //
    //      -- note if exactly matches what is already in DS, then
    //      then we'll suppress write
    //
    //  If successful, caller will execute updates in memory exactly as in
    //  non-secure case;  only difference is final write to DS is skipped
    //
    //  DEVNOTE: map DS errors into RCODE REFUSED or SERVER_FAILURE
    //

    status = Ds_WriteUpdateToDs(
                pldap,
                pUpdateList,
                pZone );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( UPDATE, (
            "SECURE UPDATE failed on DS write:  status = %d\n",
            status ));

        //  roll back any-nodes already written

        rollBackFailedUpdateFromDs(
            pldap,
            pUpdateList,
            pZone );

        statusFinal = DNS_ERROR_RCODE_REFUSED;
        UPDATE_STAT_INC( pUpdateList, RefusedAccessDenied );
        UPDATE_STAT_INC( pUpdateList, SecureDsWriteFailure );
        pszFailInfo = "Write to the DS";
        goto Failed;
    }

Sign:

    //
    //  sign the response packet
    //      - since signing, set response bit now
    //
    //  DEVNOTE: need failed signing
    //      when fail but can sign
    //

    if ( pMsg )
    {
        ASSERT( pMsg );
        ASSERT( pUpdateList->Flag & DNSUPDATE_PACKET );

        pMsg->fDelete = TRUE;
        pMsg->Head.IsResponse = TRUE;

        status = Dns_SignMessageWithGssTsig(
                        hcontext,
                        DNS_HEADER_PTR(pMsg),
                        pMsg->pBufferEnd,
                        &pMsg->pCurrent );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "FAILURE: createResponseToSecureUpdate failed\n" ));
            statusFinal = DNS_ERROR_RCODE_SERVER_FAILURE;
            pszFailInfo = "Signing return message";
            goto Failed;
        }
        DNS_DEBUG( UPDATE2, (
            "Prepared successful secure-update response:\n" ));
    }

    //  drop to cleanup

Failed:

    //
    //  DEVNOTE: we have NEVER address issue of signed REFUSAL
    //      in those cases where able to authenticate, but get ACL
    //      failure writing to DS (or some SERVER_FAILURE) we should
    //      we able to give signed failure response
    //

    Ds_CloseServerAfterSecureUpdate( &pldap );

    if ( fimpersonatingClient )
    {
        Dns_SrvRevertToSelf( hcontext );
    }

    //
    //  return security context to queue
    //

    if ( hcontext )
    {
        Dns_CleanupSessionAndEnlistContext( hcontext );
    }

    //
    //  logging
    //      - log actual status failure
    //      - but return packet friendly status
    //

    if ( status == ERROR_SUCCESS )
    {
        UPDATE_STAT_INC( pUpdateList, SecureSuccess );
        PERF_INC( pcSecureUpdateReceived );      // PerfMon hook
    }
    else
    {
        if ( status == ERROR_ACCESS_DENIED )
        {
            statusFinal = DNS_RCODE_REFUSED;
        }
        else if ( statusFinal == ERROR_SUCCESS )
        {
            statusFinal = status;
        }

        UPDATE_STAT_INC( pUpdateList, SecureFailure );
        PERF_INC( pcSecureUpdateFailure );       // PerfMon hook
        PERF_INC( pcSecureUpdateReceived );      // PerfMon hook

        DNSLOG( DSWRITE, (
            "Update Error <%lu>: %s\r\n",
            status,
            pszFailInfo ? pszFailInfo : "<none>" ));
    }

    return statusFinal;
}



DNS_STATUS
processDsUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Process dynamic update message.

    This is the core routine that locks zone and database, calls parser
    do update (if necessary), logs update, unlocks, sends response.

Arguments:

    pZone       -- zone being updated

    pUpdateList -- parsed update list

Return Value:

    TRUE if update completed.
    FALSE if update requeued.

--*/
{
    DNS_STATUS      status;
    DNS_STATUS      statusFinal = ERROR_SUCCESS;
    PLDAP           pldap = NULL;
    PDB_NODE        pnode;
    LPSTR           pszFailInfo = NULL;

    DNS_DEBUG( UPDATE, ( "Enter processDsUpdate()\n" ));

    //
    //  detect, respond to empty updates
    //
    //  note, should log-to-stats (empty or duplicate)
    //

    if ( checkForEmptyUpdate(
                pUpdateList,
                pZone ) )
    {
        return ERROR_SUCCESS;
    }

    //
    //  build update
    //      0) bring nodes into sync with DS
    //      1) build temporary node\RR copies of target of updates
    //      2) execute update on these temporary nodes
    //

    status = prepareUpdateListForExecution( pZone, pUpdateList );
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( status == ERROR_INVALID_DATA );
        pszFailInfo = "DS update initialization";
        goto Failed;
    }

    status = Up_ApplyUpdatesToDatabase(
                pUpdateList,
                pZone,
                pUpdateList->Flag );
    if ( status != ERROR_SUCCESS )
    {
        pszFailInfo = "Executing update";
        goto Failed;
    }

    //
    //  determine if DS write is necessary
    //      - update changed RRs
    //      OR
    //      - some RRs need refresh
    //

    if ( !checkTempNodesForUpdateEffect(
                pZone,
                pUpdateList ) )
    {
        //  update is no-op

        //  DEVNOTE: separate these to update stats

        STAT_INC( DsStats.UpdateLists );
        STAT_INC( DsStats.UpdateNodes );
        STAT_INC( DsStats.UpdateSuppressed );
        STAT_INC( DsStats.DsWriteSuppressed );
        goto Failed;
    }

    //
    //  screen out dynamic updates to secure zones
    //
    //  we've allowed dynamic updates to secure zones to go down this
    //  path for performance reasons -- aging means precon updates are
    //  also generated which must be checked;  now if we must WRITE
    //  to database need to REFUSE and cause security negotiation
    //

#if 0
    if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE &&
        (pUpdateList->Flag & DNSUPDATE_NONSECURE_PACKET) &&
        !(pUpdateList->Flag & DNSUPDATE_LOCAL_SYSTEM) )
#else
    if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE &&
        (pUpdateList->Flag & DNSUPDATE_NONSECURE_PACKET) )
#endif
    {
        DNS_DEBUG( UPDATE, (
            "Non-secure update packet %p in secure zone -- returning REFUSED\n"
            "    zone update = %d, update flags = 0x%08X\n",
            pUpdateList->pMsg,
            pZone->fAllowUpdate,
            pUpdateList->Flag ));

        UPDATE_STAT_INC( pUpdateList, RefusedNonSecure );
        return DNS_RCODE_REFUSED;
    }

    //
    //  attempt to execute update in DS
    //      => if succeeds done
    //      => if fails we roll back DS update by rewriting REAL nodes to DS
    //
    //  -- note if exactly matches what is already in DS, then
    //      then we'll suppress write
    //
    //  If successful, caller will execute updates in memory but
    //  DS write is skipped.
    //

    status = Ds_WriteNonSecureUpdateToDs(
                NULL,
                pUpdateList,
                pZone );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "DS UPDATE failed on DS write:  status = %d\n",
            status ));

        //  DNS server should never fail because of security constraint

        ASSERT( status != LDAP_INSUFFICIENT_RIGHTS );

        //  roll back any-nodes already written

        rollBackFailedUpdateFromDs(
            NULL,
            pUpdateList,
            pZone );

        pszFailInfo = "Applying update to the DS";
        statusFinal = DNS_ERROR_RCODE_SERVER_FAILURE;
        UPDATE_STAT_INC( pUpdateList, DsWriteFailure );
        goto Failed;
    }

    DNS_DEBUG( UPDATE2, (
            "Prepared successful DS-update response\n" ));

    UPDATE_STAT_INC( pUpdateList, DsSuccess );

    //  drop to cleanup

Failed:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( UPDATE, (
            "Error <%lu>: processDsUpdateMessage failed\n" ,
            status ));

        DNSLOG( DSWRITE, (
            "Update Error <%lu>: %s\r\n",
            status,
            pszFailInfo ? pszFailInfo : "<none>" ));

        if ( statusFinal == ERROR_SUCCESS )
        {
            statusFinal = status;
        }
    }

    return statusFinal;
}



DNS_STATUS
processNonDsUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Process dynamic update message.

    This is the core routine that locks zone and database, calls parser
    do update (if necessary), logs update, unlocks, sends response.

Arguments:

    pZone       -- zone being updated

    pUpdateList -- parsed update list

Return Value:

    TRUE if update completed.
    FALSE if update requeued.

--*/
{
    DNS_STATUS      status;
    PDB_NODE        pnode;
    LPSTR           pszFailInfo = NULL;

    DNS_DEBUG( UPDATE, ( "Enter processNonDsUpdate()\n" ));

    //
    //  detect, respond to empty updates
    //
    //  note, should log-to-stats (empty or duplicate)
    //

    if ( checkForEmptyUpdate(
                pUpdateList,
                pZone ) )
    {
        return ERROR_SUCCESS;
    }

    //
    //  build update
    //      0) bring nodes into sync with DS
    //      1) build temporary node\RR copies of target of updates
    //      2) execute update on these temporary nodes
    //

    status = prepareUpdateListForExecution( pZone, pUpdateList );
    if ( status != ERROR_SUCCESS )
    {
        pszFailInfo = "update initialization";
        goto Failed;
    }

    status = Up_ApplyUpdatesToDatabase(
                pUpdateList,
                pZone,
                0 );
    if ( status != ERROR_SUCCESS )
    {
        pszFailInfo = "Executing update";
        goto Failed;
    }

    DNS_DEBUG( UPDATE, (
        "Successful non-DS update\n" ));

    status = ERROR_SUCCESS;

    //  drop to cleanup

Failed:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( UPDATE, (
            "Error <%lu>: processNonDsUpdateMessage failed\n" ,
            status ));

        DNSLOG( DSWRITE, (
            "Update Error <%lu>: %s\r\n",
            status,
            pszFailInfo ? pszFailInfo : "<none>" ));
    }

    return status;
}



BOOL
checkTempNodesForUpdateEffect(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Check temp nodes for effect of update.

    This involves determining whether update has changed the nodes
    RR list.  Whether or not DS write is necessary is based on this.

Arguments:

    pZone - zone to update

    pUpdateList - list with update

Return Value:

    TRUE if need write to DS.
    FALSE if no write required.

--*/
{
    PDB_NODE        pnodeReal;
    PDB_NODE        pnodeTemp;
    BOOL            fneedUpdate = FALSE;
    BOOL            fneedWrite = FALSE;

    DNS_DEBUG( UPDATE, (
        "checkTempNodesForUpdateEffect( %s )\n",
        pZone->pszZoneName ));

    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList(
            "Update list before checkTempNodesForUpdateEffect",
            pUpdateList );
    }

    //
    //  loop through temp nodes
    //
    //  check each to see if changed from temp node
    //  three possibilities:
    //
    //      - no change
    //      - no data change but aging change
    //      - RR data changed
    //
    //  for zone's with scavenging ON, any aging change
    //      requires DS write
    //  for zone's without scavenging, only change to turn OFF
    //      aging requires write
    //

    for ( pnodeTemp = pUpdateList->pTempNodeList;
          pnodeTemp != NULL;
          pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp) )
    {
        DWORD   writeResult;

        pnodeReal = TNODE_MATCHING_REAL_NODE(pnodeTemp);

        writeResult = RR_ListCheckIfNodeNeedsRefresh(
                            pnodeReal,
                            pnodeTemp->pRRList,
                            pZone->dwRefreshTime
                            );

        TNODE_WRITE_STATE(pnodeTemp) = writeResult;

        if ( writeResult != RRLIST_MATCH )
        {
            if ( writeResult == RRLIST_NO_MATCH )
            {
                fneedUpdate = TRUE;
                fneedWrite = TRUE;
                TNODE_SET_FOR_DS_WRITE(pnodeTemp);

                //  check for changing DNS host data
                //  may tag for DS-peer update

                if ( IS_THIS_HOST_NODE(pnodeReal) )
                {
                    checkDnsServerHostUpdate(
                        pZone,
                        pUpdateList,
                        pnodeReal,
                        pnodeTemp );
                }
            }
            else if ( pZone->bAging ||
                writeResult == RRLIST_AGING_OFF )
            {
                fneedWrite = TRUE;
                TNODE_SET_FOR_DS_WRITE(pnodeTemp);
            }
        }

        DNS_DEBUG( UPDATE, (
            "Temp node %s (%p) real=%p:  write state = %p;  do DS write = %d\n",
            pnodeTemp->szLabel,
            pnodeTemp,
            pnodeReal,
            writeResult,
            TNODE_NEEDS_DS_WRITE(pnodeTemp) ));
    }

    //
    //  complete no-op ?
    //

    if ( !fneedWrite )
    {
        DNS_DEBUG( UPDATE, (
            "Update %p for zone %s is complete no-op\n",
            pUpdateList,
            pZone->pszZoneName ));

        return FALSE;
    }

    //
    //  set update serial number
    //      - dwNewSerialNo serves as flag, if non-zero, DS writes are done
    //      with it's serial no
    //
    //      - only increment serial number if UPDATE is success and will have
    //      new zone serial;  if only aging refresh, then no increment
    //

    if ( fneedUpdate )
    {
        DWORD   serial = pZone->dwSerialNo + 1;
        if ( serial == 0 )
        {
            serial++;
        }
        pZone->dwNewSerialNo = serial;
    }
    else
    {
        pZone->dwNewSerialNo = pZone->dwSerialNo;
    }

    return TRUE;
}



VOID
resetAndSuppressTempUpdatesForCompletion(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Suppress updates which amount to no-ops.

Arguments:

    pZone - zone to update

    pUpdateList - list with update

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    PDB_NODE        pnode;
    PDB_NODE        pnodeReal;
    PDB_NODE        pnodeTemp;
    PUPDATE         pupdate;
    PUPDATE         pupdatePrevious;
    PDB_RECORD      poriginalRR;
    DNS_STATUS      status = ERROR_SUCCESS;

    DNS_DEBUG( UPDATE, (
        "resetAndSuppressTempUpdatesForCompletion( %s )\n",
        pZone->pszZoneName ));

    //
    //  non-DS determine if update changed RR data
    //
    //  DS zones already do this check prior to DS write and do not
    //  need to do it again
    //

    if ( !pZone->fDsIntegrated )
    {
        checkTempNodesForUpdateEffect(
            pZone,
            pUpdateList
            );
    }

    IF_DEBUG( UPDATE )
    {
        Dbg_UpdateList(
            "Update list before swap back suppression",
            pUpdateList );
    }

    //
    //  swap executed RR lists back onto real nodes
    //
    //  for DS
    //      - swap in ONLY when wrote back, keeping in ssync with DS
    //
    //  non-DS
    //      - skip swap on full match
    //      (simple and gives best data when convert)
    //
    //      the detailed approach would be
    //      - aging, skip swap on full match
    //      - non-aging, skip swap on anything but NO_MATCH
    //

    for ( pnodeTemp = pUpdateList->pTempNodeList;
          pnodeTemp != NULL;
          pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp) )
    {
        //
        //  this will allow for some non-swapped nodes and make sure that
        //      cleanup handles all paths
        //
        //  DEVNOTE: aging timestamp only updates (not in DS) kept in memory
        //      only problem is this keeps some AGING timestamp only updates that
        //      did NOT get written to DS
        //

        if ( TNODE_WRITE_STATE(pnodeTemp) == RRLIST_MATCH )
        {
            DNS_DEBUG( UPDATE2, (
                "Skipping swap-back for node %s\n"
                "    exactly matches real node, no DS write was done\n",
                pnodeTemp->szLabel ));
            continue;
        }

        //
        //  swap
        //      - get matching real node
        //      - swap RR lists
        //      - reset flags in real node
        //      - reset authority in real node
        //      - temp node will carry and ultimately free original RR list
        //

        pnodeReal = TNODE_MATCHING_REAL_NODE(pnodeTemp);
        ASSERT( pnodeReal );
        IF_DEBUG( UPDATE2 )
        {
            Dbg_DbaseNode( "Real node before swap:", pnodeReal );
        }

        LOCK_RR_LIST( pnodeReal );

        poriginalRR = pnodeReal->pRRList;
        pnodeReal->pRRList = pnodeTemp->pRRList;

        COPY_BACK_NODE_FLAGS( pnodeReal, pnodeTemp );
        pnodeReal->uchAuthority = pnodeTemp->uchAuthority;

        //  make absolutely sure zone root is marked dirty if swap root node's list

        if ( IS_AUTH_ZONE_ROOT(pnodeReal) )
        {
            pZone->fRootDirty = TRUE;
        }

        UNLOCK_RR_LIST( pnodeReal );

        pnodeTemp->pRRList = poriginalRR;

        IF_DEBUG( UPDATE2 )
        {
            Dbg_DbaseNode( "Real node after swap:", pnodeReal );
        }
    }

    IF_DEBUG( UPDATE )
    {
        Dbg_UpdateList(
            "Update list -- before no-op suppression",
            pUpdateList );
    }

    //
    //  loop through all updates in list
    //
    //      - reset node ptrs to real nodes
    //      - suppress net-no-op updates
    //
    //      if update corresponds to a node which did NOT require
    //      an update, then it can be thrown out
    //

    pupdate = (PUPDATE) pUpdateList;

    while ( pupdatePrevious = pupdate,  pupdate=pupdate->pNext )
    {
        pnodeTemp = pupdate->pNode;

        ASSERT( pnodeTemp );
        ASSERT( IS_TNODE(pnodeTemp) );

        if ( !pnodeTemp || !IS_TNODE(pnodeTemp) )
        {
            continue;
        }

        //
        //  reset node ptr to real node
        //      - need to do this BEFORE suppression, as deleting
        //      update does the deref, which MUST be done on real node
        //

        pupdate->pNode = TNODE_MATCHING_REAL_NODE(pnodeTemp);

        //
        //  node NOT changed in update --> delete update
        //
        //  note, "changed" is not a test for whether node written (DS)
        //  or whether new RR list copied (non-DS), but only the
        //  question of whether a real update was made
        //
        //  the theory is that aging changes are no wire protocol
        //  (hence irrelevant for IXFR), nor will we force datafile
        //  write simply for aging (next write picks them up)
        //

        if ( TNODE_WRITE_STATE(pnodeTemp) != RRLIST_NO_MATCH )
        {
            IF_DEBUG( UPDATE )
            {
                Dbg_Update(
                    "Suppressing update at no-op node:",
                    pupdate );
            }

            Up_DetachAndFreeUpdateGivenPrevious(
                    pUpdateList,
                    pupdatePrevious,
                    pupdate );

            //  reset pupdate for next pass

            pupdate = pupdatePrevious;
        }
    }

    VALIDATE_UPDATE_LIST( pUpdateList );

    IF_DEBUG( UPDATE )
    {
        Dbg_UpdateList(
            "Update list after no-op suppression -- read for completion",
            pUpdateList );
    }
}



DNS_STATUS
prepareUpdateListForExecution(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Creates temporary nodes to execute the updates on.
    These are used so we can execute updates and still
        roll back to previous state on failure.

    Temp nodes are created, then updates of existing data made
    from DS (reads).  Then updates can be executed on temp
    nodes.

Arguments:

    pZone - zone to update

    pUpdateList - list with update

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    PUPDATE         pupdate;
    PDB_NODE        pnodeReal;
    PDB_NODE        pnodeTemp;
    DNS_STATUS      status = ERROR_SUCCESS;

    DNS_DEBUG( UPDATE, (
        "prepareUpdateListForExecution( %s )\n",
        pZone->pszZoneName ));

    //
    //  loop through all updates in list
    //
    //      - find or create temporary node for real database node
    //      - if creating, create copy of node's RR list, to "execute" update on
    //      - update reset to point at temporary node
    //
    //  DEVNOTE: shouldn't have to make update list copy
    //      once verify we can do clean substitution after running update on
    //      temp node, THEN we can just do replace to real node and not execute
    //      update on real, THEN we can skip this step
    //

    pupdate = (PUPDATE) pUpdateList;

    while ( pupdate = pupdate->pNext )
    {
        pnodeReal = pupdate->pNode;

        //  for each real node, create temp node
        //      - search list so don't create duplicates

        for ( pnodeTemp = pUpdateList->pTempNodeList;
              pnodeTemp != NULL;
              pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp) )
        {
            if ( TNODE_MATCHING_REAL_NODE(pnodeTemp) == pnodeReal )
            {
                break;
            }
        }

        //  not in temp node list
        //      - read DS data to real node
        //      - create temp node copy, append to temp node list

        if ( !pnodeTemp )
        {
            pnodeTemp = NTree_CopyNode( pnodeReal );
            IF_NOMEM( !pnodeTemp )
            {
                return DNS_RCODE_SERVER_FAILURE;
            }
            TNODE_MATCHING_REAL_NODE(pnodeTemp) = pnodeReal;
            TNODE_FLAG(pnodeTemp) = TNODE_FLAG_NEW;
            TNODE_WRITE_STATE(pnodeTemp) = (DWORD) -1;

            TNODE_NEXT_TEMP_NODE(pnodeTemp) = pUpdateList->pTempNodeList;
            pUpdateList->pTempNodeList = pnodeTemp;
        }

        //  replace real node with temp node

        pupdate->pNode = pnodeTemp;
    }

    //
    //  read DS data for nodes being updated
    //      - if data is different, update in memory list
    //
    //  DEVNOTE: in the 99% case, this refresh is a no-op
    //      it would be cool if we could use the duplicate
    //      RR list generated as the RR list copy below
    //      we'd have to percolate back the duplicate we no-ops
    //      out;  note pretty small win
    //

    if ( pZone->fDsIntegrated )
    {
        status = Ds_UpdateNodeListFromDs(
                    pZone,
                    pUpdateList->pTempNodeList );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  updating update nodes from DS!\n"
                "    status = %d\n",
                status ));

            //return status;
        }
    }

    //
    //  copy (now refreshed from DS) data at update nodes
    //      need to refresh the node flags, because DS read may
    //      have picked up records (like CNAME, NS) that weren't
    //      present when copy made, changing flag
    //

    for ( pnodeTemp = pUpdateList->pTempNodeList;
          pnodeTemp != NULL;
          pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp) )
    {
        pnodeReal = TNODE_MATCHING_REAL_NODE(pnodeTemp);

        pnodeTemp->pRRList = RR_ListForNodeCopy(
                                pnodeReal,
                                RRCOPY_EXCLUDE_CACHED_DATA );

        pnodeTemp->dwNodeFlags = ( pnodeReal->dwNodeFlags & NODE_FLAGS_SAVED_ON_COPY );
    }

    DNS_DEBUG( UPDATE, ( "Leaving prepareUpdateListForExecution()\n" ));
    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList(
            "Update list after prepare:",
            pUpdateList );
    }

    return ERROR_SUCCESS;
}




BOOL
Up_IsDuplicateAdd(
    IN OUT  PUPDATE_LIST    pUpdateList,    OPTIONAL
    IN OUT  PUPDATE         pUpdate,
    IN OUT  PUPDATE         pUpdatePrev     OPTIONAL
    )
/*++

Routine Description:

    Determine if update is duplicate.

    Detect and eliminate duplicate adds.
    Note:  currently only detect and mark, no elimination yet possible.

Arguments:

    pUpdateList - list with update

    pUpdate - ptr to update

    pUpdatePrev - ptr to previous update

Return Value:

    TRUE if duplicate add.
    FALSE if not duplicate.

--*/
{
    PUPDATE     pup = pUpdate;
    PDB_NODE    pnode;
    WORD        addType;
    DWORD       count;

    DNS_DEBUG( UPDATE2, (
        "Up_IsDuplicateAdd( %p )\n",
        pUpdate ));

    //
    //  already marked duplicate
    //

    if ( IS_UPDATE_DUPLICATE_ADD(pup) )
    {
        DNS_DEBUG( UPDATE, (
            "Duplicate update add at %p\n",
            pup ));
        return TRUE;
    }

    //  must be add update
    //      - otherwise shouldn't even be called to check

    if ( !pup->wAddType )
    {
        ASSERT( FALSE );
        return TRUE;
    }

    if ( IS_UPDATE_NON_DUPLICATE_ADD(pup) )
    {
        DNS_DEBUG( UPDATE2, (
            "Non-Duplicate update add at %p\n",
            pup ));
        return FALSE;
    }

    //
    //  loop through all remaining updates in list
    //
    //      - if find add update for same RR set, then
    //      original update is duplicate of update further downstream
    //
    //  DEVNOTE: should find a way to save AddType while still marking as duplicate
    //      that way we can stop checking immediately;
    //      problem is that WINS screws up tagging high bits of AddType
    //      and DS updates are replace with delete type ALL, which prohibits
    //          overloading delete type
    //
    //      fortunately this is not a big problem
    //      - usually requests will be for later nodes -- rare to find and existing one
    //      - when we improve this we'll be deleting them anyway (except for DS replace
    //          which also have delete RRs)
    //
    //      - limit to 100 updates so don't get into order n**2
    //      this handles repetitive update case as generally requests will come in
    //      fairly regularly so that updates get marked early
    //
    //  DEVNOTE: should save "last update serial" at node
    //      so know if it is appropriate to look forward;
    //

    pnode = pup->pNode;
    addType = pup->wAddType;
    count = 100;                // sanity limit of 100 updates deep

    while ( pup = pup->pNext )
    {
        //  if checked far enough upstream -- give up
        //  and mark so don't check again

        if ( count-- == 0 )
        {
            pUpdate->wDeleteType = UPDATE_OP_NON_DUPLICATE_ADD;
            break;
        }

        if ( pup->pNode != pnode )
        {
            continue;
        }

        if ( pup->wAddType != addType &&
            pup->wAddType != DNS_TYPE_ALL )
        {
            continue;
        }

        //  pUpdate is duplicate of this update

        pUpdate->wAddType = UPDATE_OP_DUPLICATE_ADD;
#if 0
        //  can NOT free, as context of call (IXFR) is doing
        //  list traversal -- it must free after preserving ptr

        //  if no delete records -- pull it out

        if ( pUpdatePrev && !pUpdate->pDeleteRR )
        {
            pUpdatePrev->pNext = pUpdate->pNext;
            FREE_HEAP( pUpdate );
        }
#endif
        DNS_DEBUG( UPDATE, (
            "Found duplicate for update add at %p (node %s, type %d)\n"
            "    duplicate is at %p, (type = %d, version %d)\n",
            pUpdate,
            pnode,
            addType,
            pup,
            pup->wAddType,
            pup->dwVersion ));

        return TRUE;
    }

    //  duplicate not found

    return FALSE;
}



//
//  DS Peer updates
//  When DNS server host A records change, update DS peers
//

DNS_STATUS
Up_DsPeerThread(
    IN      PVOID           pvNode
    )
/*++

Routine Description:

    Updates DS peers when change made to host node.

Arguments:

    pvNode -- this machine's host node

Return Value:

    Status in win32 error space

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_RECORD      prrA;
    PDB_NODE        pnodeLocalHost = (PDB_NODE) pvNode;
    PDNS_RECORD     pupdateRR;
    PDNS_RECORD     pupdateRRSet = NULL;
    PDNS_RECORD     previousRR = NULL;

    DNS_DEBUG( UPDATE, (
        "\n\nEnter:  Update_DsPeerThread()\n"
        "    time      = %d\n",
        DNS_TIME() ));

    //
    //  DEVNOTE: multi-update issue?  zone context?
    //      currently we'll take updates from multiple sources,
    //      but updates are executed without any sort of zone context

    //
    //  DEVNOTE: perhaps more robust to lookup name here from SrvCfg_pszServerName
    //      but if want zone context -- essentially the right to fix delegations --
    //      then need to have independent updates, hence get nodes or at least zones
    //

    //
    //  create DNS_RECORD for each ip
    //      - note, using UTF8 name, so call UTF8 interface
    //      - update function handles section setting
    //

    prrA = NULL;

    while ( 1 )
    {
        prrA = RR_FindNextRecord(
                    pnodeLocalHost,
                    DNS_TYPE_A,
                    prrA,
                    0 );
        if ( !prrA )
        {
            break;
        }

        pupdateRR = Dns_AllocateRecord( sizeof(IP_ADDRESS) );
        IF_NOMEM( !pupdateRR )
        {
            goto Cleanup;
        }
        ASSERT( pupdateRR->pNext == NULL );

        pupdateRR->pName = (PWCHAR) SrvCfg_pszServerName;
        pupdateRR->dwTtl = htonl( prrA->dwTtlSeconds );
        pupdateRR->wType = DNS_TYPE_A;
        pupdateRR->Data.A.IpAddress = prrA->Data.A.ipAddress;

        if ( previousRR )
        {
            previousRR->pNext = pupdateRR;
            previousRR = pupdateRR;
        }
        else
        {
            pupdateRRSet = pupdateRR;
            previousRR = pupdateRR;
        }
    }

    //
    //  send updates to all other DS-primaries
    //

    status = DnsReplaceRecordSetUTF8(
                pupdateRRSet,
                DNS_UPDATE_TRY_ALL_MASTER_SERVERS,
                NULL,           // no context handle
                NULL,           // no specific servers to update
                NULL );

    //
    //  Log error or success, unless server is terminating.
    //
    
    if ( g_ServerState != DNS_STATE_TERMINATING )
    {
        if ( status == ERROR_SUCCESS )
        {
#if 0
        //
        //  This event is chatty - DHCP is giving us many bogus IP change
        //  notifications. This event really doesn't tell the admin anything
        //  all that useful, so gag it for .NET.
        //
        
            DNS_LOG_EVENT(
                DNS_EVENT_UPDATE_DS_PEERS_SUCCESS,
                0,
                NULL,
                NULL,
                0 );
#endif
        }
        else
        {
            DNS_LOG_EVENT(
                DNS_EVENT_UPDATE_DS_PEERS_FAILURE,
                0,
                NULL,
                NULL,
                status );
        }
    }

Cleanup:

    //  free record list
    //      - don't free owner it's our global

    Dns_RecordListFree( pupdateRRSet );

    DNS_DEBUG( UPDATE, (
        "Exit <%lu>: Update_DsPeerThread\n",
        status ));

    //  clear thread from list

    Thread_Close( FALSE );
    return status;
}



DNS_STATUS
initiateDsPeerUpdate(
    IN      PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Initiates update of DS peers, when IP address of this host changes and
    the host entry is in a DS zone.

Arguments:

    pUpdateList -- update list

Return Value:

    Status in win32 error space

--*/
{
    PDB_NODE    pnode = pUpdateList->pNodeFailed;

    DNS_DEBUG( UPDATE, (
        "initiateDsPeerUpdate( %s )\n",
        pnode->szLabel ));

    ASSERT( pnode );
    if ( !pnode )
    {
        return ERROR_INVALID_PARAMETER;
    }
    ASSERT( pnode->pZone && ((PZONE_INFO)pnode->pZone)->fDsIntegrated );

    //
    //  if not authoritative name -- don't bother
    //      - DS peers will get authoritative data to do update
    //
    //  JENHANCE:  if roll our own peer-update, then can update glue
    //

    if ( !IS_AUTH_NODE(pnode) )
    {
        DNS_DEBUG( UPDATE, (
            "Skipping DS-peer DNS host update -- not authoritative node in zone %s\n",
            pnode->pZone ? ((PZONE_INFO)pnode->pZone)->pszZoneName : NULL ));
        return ERROR_SUCCESS;
    }

    //
    //  have a flag to skip this
    //

    if ( SrvCfg_dwUpdateOptions & UPDATE_NO_DS_PEERS )
    {
        DNS_DEBUG( UPDATE, (
            "Skipping DS-peer DNS host update by policy\n" ));
        return ERROR_SUCCESS;
    }

    //
    //  create scavenge thread
    //

    if ( !Thread_Create(
                "UpdateDsPeerThread",
                Up_DsPeerThread,
                pnode,
                0 ) )
    {
        DNS_PRINT(( "ERROR:  Failed to create UpdateDsPeerThread thread!\n" ));
        return GetLastError();
    }

    DNS_DEBUG( UPDATE, (
        "Dispatched DS-peer update thread\n" ));

    return ERROR_SUCCESS;
}



DNS_STATUS
checkDnsServerHostUpdate(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNodeReal,
    IN      PDB_NODE        pNodeTemp
    )
/*++

Routine Description:

    Check on update to DNS server host node.

Arguments:

    pZone -- zone of update

    pUpdateList -- update list

    pNodeReal -- node of host

    pNodeTemp -- temp update node for host, contains new record list

Return Value:

    Status in win32 error space

--*/
{
    DNS_DEBUG( UPDATE, (
        "checkDnsServerHostUpdate()\n",
        "    zone = %s\n"
        "    host = %s\n",
        pZone->pszZoneName,
        pNodeReal->szLabel ));


    //
    //  "down to zero" delete?
    //
    //  if no A records
    //      - don't update peers -- useless
    //      - flat out refuse "down to zero" packet updates
    //

    if ( !RR_FindNextRecord(
                pNodeTemp,
                DNS_TYPE_A,
                NULL,
                0 ) )
    {
        DNS_DEBUG( UPDATE, (
            "WARNING:  No A records on DNS server host update!!!\n" ));

        ASSERT( !(pUpdateList->Flag & DNSUPDATE_PACKET) );
        return ERROR_SUCCESS;
    }

    //
    //  only need mark DS integrated zones
    //

    if ( !pZone->fDsIntegrated )
    {
        return ERROR_SUCCESS;
    }

    //
    //  check that change merits forcing update to peers
    //
    //  DEVNOTE: enhanced detection
    //
    //  generally updates that REMOVE an IP (which peers may be
    //  using to replicate with us) AND ADD another IP (which peers
    //  could use) are of interest;  other updates do little
    //

    if ( 0 )
    {
        //  should have intellignent code here
        DNS_DEBUG( UPDATE, (
            "IP change for host adapter not sufficient for peer update!\n" ));
        return ERROR_SUCCESS;
    }

    //  tag update as needing peer-update
    //  save node, overloading pNodeFailed field in update

    pUpdateList->Flag |= DNSUPDATE_DS_PEERS;
    pUpdateList->pNodeFailed = pNodeReal;

    DNS_DEBUG( UPDATE, (
        "Tagged update for DS-peer update\n" ));

    return ERROR_SUCCESS;
}

//
//  End of udpate.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\wins.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    wins.h

Abstract:

    Domain Name System (DNS) Server

    Definitions for WINS lookup.

Author:

    Jim Gilroy (jamesg)     August 2, 1995

Revision History:

--*/


#ifndef _DNS_WINS_INCLUDED_
#define _DNS_WINS_INCLUDED_


//
//  WINS definitions
//

#define WINS_REQUEST_PORT           (137)

#define NETBIOS_TYPE_GENERAL_NAME_SERVICE   (0x2000)    // 32
#define NETBIOS_TYPE_NODE_STATUS            (0x2100)    // 33

#define NETBIOS_ASCII_NAME_LENGTH   (16)
#define NETBIOS_PACKET_NAME_LENGTH  (32)

#define NETBIOS_WORKSTATION_BYTE    (0)
#define NETBIOS_SERVER_BYTE         (20)
#define BLANK_CHAR                  (' ')


#include <packon.h>


//
//  NetBIOS / WINS Name
//
//  If using scope, scope will start at NameEnd byte, and proceed in
//  standard length-byte followed by label format, until finally zero
//  termination byte.
//

typedef struct _WINS_NAME
{
    //  Name

    UCHAR   NameLength;
    BYTE    Name[ NETBIOS_PACKET_NAME_LENGTH ];   // 32 byte netBIOS name
    UCHAR   NameEndByte;

} WINS_NAME, *PWINS_NAME;

//
//  NetBIOS / WINS Question
//
//  This is valid for either WINS or NBT reverse adapter status lookup.
//

typedef struct _WINS_QUESTION
{
    WORD    QuestionType;
    WORD    QuestionClass;
}
WINS_QUESTION, *PWINS_QUESTION,
NBSTAT_QUESTION, *PNBSTAT_QUESTION;


//
//  NetBIOS / WINS Request
//
//  Use this as template for WINS lookup.
//

typedef struct _WINS_REQUEST_MESSAGE
{
    DNS_HEADER      Header;
    WINS_NAME       Name;
    WINS_QUESTION   Question;
}
WINS_REQUEST_MSG, *PWINS_REQUEST_MSG,
NBSTAT_REQUEST_MSG, *PNBSTAT_REQUEST_MSG;

#define SIZEOF_WINS_REQUEST     (sizeof(WINS_REQUEST_MSG))


//
//  WINS IP Address Resource Record Data
//
//  Flags presented in byte flipped order, so do NOT flip field
//  when doing compare.  Note our compiler works from low to high
//  bits in byte.
//

typedef struct _WINS_RR_DATA
{
    WORD        Reserved1   : 5;
    WORD        NodeType    : 2;    // bits 2+3 form group name
    WORD        GroupName   : 1;    // high bit set if group name
    WORD        Reserved2   : 8;
    IP_ADDRESS  IpAddress;

} WINS_RR_DATA, *PWINS_RR_DATA;

//
//  WINS IP Address Resource Record
//

typedef struct _WINS_RESOURCE_RECORD
{
    //  Resource record

    WORD    RecordType;
    WORD    RecordClass;
    DWORD   TimeToLive;
    WORD    ResourceDataLength;

    //  Data

    WINS_RR_DATA    aRData[1];

} WINS_RESOURCE_RECORD, *PWINS_RESOURCE_RECORD;


//
//  NetBIOS node status Resource Record Data
//
//  Each name in adapter status response has this format.
//

#include <packon.h>

typedef struct _NBSTAT_RR_DATA
{
    CHAR    achName[ NETBIOS_ASCII_NAME_LENGTH ];

    //  name flags

    WORD    Permanent       : 1;
    WORD    Active          : 1;
    WORD    Conflict        : 1;
    WORD    Deregistering   : 1;
    WORD    NodeType        : 2;
    WORD    Unique          : 1;
    WORD    Reserved        : 9;

} NBSTAT_RR_DATA, *PNBSTAT_RR_DATA;


//
//  NetBIOS node status Resource Record
//
//  Response to adapter status query has this format.
//

typedef struct _NBSTAT_RECORD
{
    //  Resource record

    WORD    RecordType;
    WORD    RecordClass;
    DWORD   TimeToLive;
    WORD    ResourceDataLength;

    //  Data

    UCHAR           NameCount;
    NBSTAT_RR_DATA  aRData[1];

    //  Statistics follow, but are not of interest.

} NBSTAT_RECORD, *PNBSTAT_RECORD;

#include <packoff.h>


//
//  Max name length can lookup in WINS
//

#define MAX_WINS_NAME_LENGTH    (15)

//
//  WINS globals
//

extern  PPACKET_QUEUE   g_pWinsQueue;

#define WINS_DEFAULT_LOOKUP_TIMEOUT     (1)     // move on after 1 second

//
//  NBSTAT globals
//

extern  BOOL            gbNbstatInitialized;
extern  PPACKET_QUEUE   pNbstatQueue;

#define NBSTAT_DEFAULT_LOOKUP_TIMEOUT     (5)   // give up after 5 seconds

//
//  Wins TTL
//
//  Cache lookups for 10 minutes.
//  Although machines can always release / renew more or less instananeously.
//  this is a pretty good estimate of time for a normal activity that would
//  change an address:
//      - replacing a net card
//      - moving machine to another network and rebooting
//

#define WINS_DEFAULT_TTL    (600)   // 10 minutes

//
//  WINS request templates
//
//  Keep template of standard WINS request and copy it and
//  overwrite name to make actual request.
//
//  Keep a copy of NetBIOS node status request and use it
//  each time.  Only the address we send to changes.
//

extern  BYTE    achWinsRequestTemplate[ SIZEOF_WINS_REQUEST ];

extern  BYTE    achNbstatRequestTemplate[ SIZEOF_WINS_REQUEST ];


//
//  WINS target sockaddr
//
//  Keep sockaddr for sending to WINS server.  On sends, copy it
//  and write in desired address.

struct sockaddr saWinsSockaddrTemplate;


//
//  WINS startup / cleanup functions (wins.c)
//

BOOL
Wins_Initialize(
    VOID
    );

VOID
Wins_Shutdown(
    VOID
    );

VOID
Wins_Cleanup(
    VOID
    );


//
//  WINS recv (winsrecv.c)
//


VOID
Wins_ProcessResponse(
    IN OUT  PDNS_MSGINFO    pQuery
    );

//
//  WINS Lookup (winslook.c)
//

BOOL
FASTCALL
Wins_MakeWinsRequest(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PZONE_INFO      pZone,
    IN      WORD            wOffsetName,
    IN      PDB_NODE        pnodeLookup
    );

VOID
Wins_ProcessTimedOutWinsQuery(
    IN OUT  PDNS_MSGINFO    pQuery
    );

//
//  Nbstat functions (nbstat.c)
//

VOID
Nbstat_StartupInitialize(
    VOID
    );

BOOL
Nbstat_Initialize(
    VOID
    );

VOID
Nbstat_Shutdown(
    VOID
    );

BOOL
FASTCALL
Nbstat_MakeRequest(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PZONE_INFO      pZone
    );

VOID
Nbstat_WriteDerivedStats(
    VOID
    );


//
//  WINS\WINSR installation in zone
//

DNS_STATUS
Wins_RecordCheck(
    IN OUT  PZONE_INFO      pZone,
    IN      PDB_NODE        pNodeOwner,
    IN OUT  PDB_RECORD      pRR
    );

VOID
Wins_StopZoneWinsLookup(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Wins_ResetZoneWinsLookup(
    IN OUT  PZONE_INFO      pZone
    );

#endif // _DNS_WINS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\wrappers.h ===
/*++

Copyright(c) 1995-2000 Microsoft Corporation

Module Name:

    ndnc.h

Abstract:

    Domain Name System (DNS) Server

    Definitions for symbols and globals related to directory partition 
    implementation.

Author:

    Jeff Westhead, June 2001

Revision History:

--*/


#ifndef _WRAPPERS_H_INCLUDED
#define _WRAPPERS_H_INCLUDED


//
//  Functions
//


DNS_STATUS
DnsInitializeCriticalSection(
    IN OUT  LPCRITICAL_SECTION  pCritSec
    );


//
//  Handy macros
//


#define sizeofarray( _ArrayName ) ( sizeof( _ArrayName ) / sizeof( ( _ArrayName ) [ 0 ] ) )

#ifdef _WIN64
#define DnsDebugBreak()     DebugBreak()
#else
#define DnsDebugBreak()     __asm int 3
#endif


#endif  // _WRAPPERS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\zone.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    zone.c

Abstract:

    Domain Name System (DNS) Server

    Zone routines.

Author:

    Jim Gilroy (jamesg)     July 3, 1995

Revision History:

--*/


#include "dnssrv.h"

#include "ds.h"

//
//  Reverse zone auto-create
//
//  Requires special flag for fDsIntegrated, to indicate creating
//  primary zone which DOES NOT require database file.
//

#define NO_DATABASE_PRIMARY (0xf)


#define MAX_AXFR_THROTTLE_INTERVAL     (600)   //  max 10 minutes


//
//  Private protos
//

VOID
Zone_SetSoaPrimaryToThisServer(
    IN      PZONE_INFO      pZone
    );

VOID
Zone_CheckAndFixDefaultRecordsOnLoad(
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
Zone_CreateLocalHostPtrRecord(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
setZoneName(
    IN OUT  PZONE_INFO      pZone,
    IN      LPCSTR          pszNewZoneName,
    IN      DWORD           dwNewZoneNameLen
    );




DWORD
Zone_ComputeSerialNumberIncrement(
    IN      PZONE_INFO                  pZone,                      OPTIONAL
    IN      DWORD                       dwCurrentSerialNumber       OPTIONAL
    )
/*++

Routine Description:

    Computes and optionally stores in a zone the incremented serial number.

Arguments:

    pZone -- optional zone to operate on, if not NULL then the
        new serial number will be stored in the zone
        
    dwCurrentSerialNumber -- serial number before increment, specify
        zero to use the zone's current serial number

Return Value:

    The new (imcremented) serial number.

--*/
{
    DBG_FN( "Zone_ComputeSerialNumberIncrement" )
    
    ASSERT( pZone || dwCurrentSerialNumber );

    ASSERT( !pZone || IS_ZONE_PRIMARY( pZone ) );
    ASSERT( !pZone || IS_ZONE_LOCKED_FOR_UPDATE( pZone ) );
    ASSERT( !pZone || pZone->pSoaRR );

    if ( pZone == NULL && dwCurrentSerialNumber == 0 )
    {
        //  Error - must specify zone or current serial!
        return 0;       
    }

    //
    //  If current serial not specified, use zone serial.
    //
    
    if ( dwCurrentSerialNumber == 0 )
    {
        dwCurrentSerialNumber = pZone->dwSerialNo;
    }
    
    //
    //  Increment serial. Zero is never valid.
    //
    
    if ( ++dwCurrentSerialNumber == 0 )
    {
        dwCurrentSerialNumber = 1;
    }
    
    //
    //  Save serial back to zone, if zone pointer is specified.
    //
    
    if ( pZone )
    {
        Zone_ResetVersion( pZone, dwCurrentSerialNumber );
    }

    DNS_DEBUG( UPDATE, (
        "%s: new serial %d for zone %s\n", fn,
        dwCurrentSerialNumber,
        pZone ? pZone->pszZoneName : "UNKNOWN" ));

    return dwCurrentSerialNumber;
}   //  Zone_ComputeSerialNumberIncrement



DNS_STATUS
Zone_Create(
    OUT     PZONE_INFO *                ppZone,
    IN      DWORD                       dwZoneType,
    IN      PCHAR                       pchZoneName,
    IN      DWORD                       cchZoneNameLen,     OPTIONAL
    IN      DWORD                       dwCreateFlags,
    IN      PDNS_ADDR_ARRAY             aipMasters,
    IN      BOOL                        fDsIntegrated,
    IN      PDNS_DP_INFO                pDpInfo,            OPTIONAL
    IN      PCHAR                       pchFileName,        OPTIONAL
    IN      DWORD                       cchFileNameLen,     OPTIONAL
    IN      PZONE_TYPE_SPECIFIC_INFO    pTypeSpecificInfo,  OPTIONAL
    OUT     PZONE_INFO *                ppExistingZone      OPTIONAL
    )
/*++

Routine Description:

    Create zone information.

    Note:  leaves zone locked.  Caller must unlock after all
    other processing (e.g. Zone_Load()) is completed.

    If the zone cannot be created because it already exists,
    ppExistingZone will be set to a ptr to the existing zone.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DBG_FN( "Zone_Create" )

    DNS_STATUS          status = ERROR_SUCCESS;
    PZONE_INFO          pzone = NULL;
    PZONE_INFO          pexistingZone = NULL;
    PDNS_ADDR_ARRAY     masterArray = NULL;
    PDB_NODE            pzoneNode;
    BOOL                bimpersonatingClient = dwCreateFlags & ZONE_CREATE_IMPERSONATING;
    DWORD               dwregFlags = bimpersonatingClient ? DNS_REG_IMPERSONATING : 0;

    DNS_DEBUG( INIT, (
        "%s: %.*s\n"
        "    zone type  %d\n", fn,
        cchZoneNameLen ? cchZoneNameLen : DNS_MAX_NAME_LENGTH,
        pchZoneName,
        dwZoneType ));

    *ppZone = NULL;

    if ( ppExistingZone )
    {
        *ppExistingZone = NULL;
    }

    if ( !cchZoneNameLen )
    {
        cchZoneNameLen = strlen( pchZoneName );
    }

    //
    //  validate type
    //

    if ( dwZoneType != DNS_ZONE_TYPE_PRIMARY &&
         dwZoneType != DNS_ZONE_TYPE_SECONDARY &&
         dwZoneType != DNS_ZONE_TYPE_CACHE &&
         dwZoneType != DNS_ZONE_TYPE_STUB &&
         dwZoneType != DNS_ZONE_TYPE_FORWARDER )
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto ErrorReturn;
    }

    //
    //  If we are creating the root zone, validate type.
    //

    if ( strncmp( pchZoneName, ".", cchZoneNameLen ) == 0 &&
        ( dwZoneType == DNS_ZONE_TYPE_STUB ||
            dwZoneType == DNS_ZONE_TYPE_FORWARDER ) )
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto ErrorReturn;
    }

    //
    //  Block zone creations that are not allowed on a root server.
    //

    if ( IS_ROOT_AUTHORITATIVE() && dwZoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        status = DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER;
        goto ErrorReturn;
    }

    //
    //  See if we currently have a zone for this name.
    //
    //  If we are creating a forwarder zone, make sure the server is
    //  not authoritative for the name. It is legal to create a
    //  domain forwarder under a delegation.
    //

    pzoneNode = Lookup_ZoneTreeNodeFromDottedName(
                        pchZoneName,
                        cchZoneNameLen,
                        LOOKUP_FIND | LOOKUP_NAME_FQDN |
                            ( dwZoneType == DNS_ZONE_TYPE_FORWARDER
                                    ? 0
                                    : LOOKUP_MATCH_ZONE ) );

    ASSERT( !pzoneNode || pzoneNode->pZone );

    if ( pzoneNode )
    {
        if ( dwZoneType == DNS_ZONE_TYPE_FORWARDER )
        {
            if ( !IS_ZONE_FORWARDER( ( PZONE_INFO ) pzoneNode->pZone ) )
            {
                PDB_NODE        pnodeClosest = NULL;
                PDB_NODE        pfwdNode = Lookup_ZoneNodeFromDotted(
                                                pzoneNode->pZone,
                                                pchZoneName,
                                                cchZoneNameLen,
                                                LOOKUP_FIND | LOOKUP_NAME_FQDN,
                                                &pnodeClosest,
                                                NULL );     // status pointer

                //
                //  Forwarder zone is only allowed at or under a delegation.
                //

                if ( !pfwdNode )
                {
                    pfwdNode = pnodeClosest;
                }
                if ( pfwdNode && !IS_DELEGATION_NODE( pfwdNode ) )
                {
                    status = DNS_ERROR_ZONE_CONFIGURATION_ERROR;
                    pexistingZone = pzoneNode->pZone;
                    goto ErrorReturn;
                }
            }
        }
        else
        {
            //
            //  Non-forwarder zone creation is allowed as long as the
            //  node we found does not correspond exactly to the proposed
            //  new zone name.
            //

            status = DNS_ERROR_ZONE_ALREADY_EXISTS;
            pexistingZone = pzoneNode->pZone;
            goto ErrorReturn;
        }
    }

    //
    //  Check and see if the zone registry key needs to be migrated. This
    //  can be removed if we know for certain that no server will ever have
    //  un-migrated zones under CurrentControlSet (leftover from a Win2000
    //  2195 installation).
    //

    if ( bimpersonatingClient )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
        if ( status != ERROR_SUCCESS )
        {
            goto ErrorReturn;
        }
    }

    Zone_ListMigrateZones();

    if ( bimpersonatingClient )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_CLIENT_CONTEXT );
        if ( status != ERROR_SUCCESS )
        {
            goto ErrorReturn;
        }
    }

    //
    //  allocate zone struct
    //

    pzone = ALLOC_TAGHEAP_ZERO( sizeof(ZONE_INFO), MEMTAG_ZONE );
    IF_NOMEM( !pzone )
    {
        DNS_DEBUG( INIT, (
            "Memory alloc failure for database ZONE_INFO struct\n" ));
        status = DNS_ERROR_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    //  set zone type
    //

    pzone->fZoneType = ( CHAR ) dwZoneType;

    //
    //  auto-create zone?
    //

    if ( fDsIntegrated == NO_DATABASE_PRIMARY )
    {
        ASSERT( IS_ZONE_PRIMARY(pzone) );
        pzone->fAutoCreated = TRUE;
    }

    //
    //  also set the USN to '0' so we always have something meaningful. setting
    //  szLastUsn[1] to '\0' is not needed because its a ALLOCATE_HEAP_ZERO
    //

    pzone->szLastUsn[ 0 ] = '0';

    //
    //  always start zone SHUTDOWN and locked
    //  when load file\DS, create default records or AXFR, then STARTUP zone
    //      and unlock

    SHUTDOWN_ZONE( pzone );
    if ( !Zone_LockForUpdate( pzone ) )
    {
        ASSERT( FALSE );
        goto ErrorReturn;
    }

    //
    //  cache "zone"
    //      - call cache zone ".", as this is label that will be
    //      enumerated and used by admin tool
    //      - use default file name if not DS and no file given
    //
    //  note, set cache zone name and allow name copy to be done, so that
    //      cache zone name is on heap and can be freed if cache zone deleted
    //

    if ( dwZoneType == DNS_ZONE_TYPE_CACHE )
    {
        pchZoneName = ".";
        cchZoneNameLen = 0;
        if ( !pchFileName && !fDsIntegrated )
        {
            pchFileName = (PCHAR) DNS_DEFAULT_CACHE_FILE_NAME_UTF8;
            cchFileNameLen = 0;
        }
    }

    //
    //  Set up the zone's name fields.
    //

    status = setZoneName( pzone, pchZoneName, cchZoneNameLen );
    if ( status != ERROR_SUCCESS )
    {
        goto ErrorReturn;
    }

    //
    //  Initialize zone event control. Do this after setting the zone name
    //  fields because the event control module might need the zone name.
    //

    pzone->pEventControl = Ec_CreateControlObject(
                                MEMTAG_ZONE,
                                pzone,
                                DNS_EC_ZONE_EVENTS );

    //
    //  cache "zone"
    //      -- create cache tree
    //      -- save global ptr
    //

    if ( dwZoneType == DNS_ZONE_TYPE_CACHE )
    {
        PDB_NODE    pnodeCacheRoot;

        pnodeCacheRoot = NTree_Initialize();
        if ( ! pnodeCacheRoot )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto ErrorReturn;
        }
        pzone->pZoneRoot = pnodeCacheRoot;
        pzone->pTreeRoot = pnodeCacheRoot;
        SET_ZONE_ROOT( pnodeCacheRoot );
    }

    //
    //  authoritative zones
    //      - setup zone in database
    //      - write to registry if appropriate
    //          - not autocreated
    //          - not loading from registry
    //

    else
    {
        status = Zone_RootCreate( pzone, ppExistingZone );
        if ( status != ERROR_SUCCESS )
        {
            goto ErrorReturn;
        }

        if ( g_bRegistryWriteBack && !pzone->fAutoCreated )
        {
            Reg_SetDwordValue(
                dwregFlags,
                NULL,
                pzone,
                DNS_REGKEY_ZONE_TYPE,
                dwZoneType );
        }
    }

    //
    //  secondary or stub
    //      - MUST have MASTER IP address
    //      - MUST init for secondary zone transfer
    //  fowarder
    //      - MUST have MASTER IP list, but no transfer
    //

    if ( ZONE_NEEDS_MASTERS( pzone ) )
    {
        status = Zone_SetMasters(
                    pzone,
                    aipMasters,
                    FALSE,          //  set global masters
                    dwregFlags );
        if ( status != ERROR_SUCCESS )
        {
            goto ErrorReturn;
        }
    }

    //
    //  Deal with type-specific parameters.
    //

    if ( pTypeSpecificInfo )
    {
        switch( pzone->fZoneType )
        {
            case DNS_ZONE_TYPE_FORWARDER:
                pzone->dwForwarderTimeout =
                    pTypeSpecificInfo->Forwarder.dwTimeout;
                pzone->fForwarderSlave =
                    pTypeSpecificInfo->Forwarder.fSlave;
                break;

            default:
                break;
        }
    }
    
    //
    //  Set default values.
    //
    
    if ( IS_ZONE_FORWARDER( pzone ) && !pzone->dwForwarderTimeout )
    {
        pzone->dwForwarderTimeout = DNS_DEFAULT_FORWARD_TIMEOUT;
    }

    //
    //  create zone database
    //      - if reverse auto-create zone, no need
    //

    if ( !pzone->fAutoCreated )
    {
        status = Zone_DatabaseSetup(
                    pzone,
                    fDsIntegrated,
                    pchFileName,
                    cchFileNameLen,
                    dwCreateFlags,
                    pDpInfo,
                    0,              //  DP flags
                    NULL );         //  DP FQDN

        if ( status != ERROR_SUCCESS )
        {
            goto ErrorReturn;
        }
    }

    //
    //  secondaries zone transfer setup
    //
    //  1) setup for no database (SHUTDOWN)
    //  startup with no file case or admin created secondary
    //
    //  2) start secondary zone control
    //  doing this last so insure we are setup in zone list with proper
    //  database file, before starting thread in case of admin created
    //  zone;   on service start thread thread will block until database
    //  load;
    //

    if ( IS_ZONE_SECONDARY(pzone) )
    {
        Xfr_InitializeSecondaryZoneTimeouts( pzone );
        Xfr_InitializeSecondaryZoneControl();
    }

    //  DS zones need control thread running for polling

    else if ( pzone->fDsIntegrated )
    {
        Xfr_InitializeSecondaryZoneControl();
    }

    //
    //  Debug stuff
    //
    //  DEVNOTE: once bug fixed creating lock history is debug only
    //      - note, since we create after zone locked, we always miss
    //      first lock
    //

    pzone->dwPrimaryMarker = ZONE_PRIMARY_MARKER;
    pzone->dwSecondaryMarker = ZONE_SECONDARY_MARKER;
    pzone->dwForwarderMarker = ZONE_FORWARDER_MARKER;
    pzone->dwFlagMarker = ZONE_FLAG_MARKER;

    //
    //  save global ptr to "cache" zone
    //
    //  root-hints -- always have default file name available for easy recovery
    //      from DS load failure
    //
    //  DEVNOTE: should "cache" zone get written to registry?
    //  DEVNOTE: does "cache" zone need pszZoneName and pszCountName?
    //      possible skip over a bunch prior test and go here with fain "cache" zone setup
    //

    if ( IS_ZONE_CACHE( pzone ) )
    {
        if ( !pzone->pwsDataFile )
        {
            pzone->pwsDataFile = Dns_StringCopyAllocate_W(
                                        DNS_DEFAULT_CACHE_FILE_NAME,
                                        0 );
            IF_NOMEM( !pzone->pwsDataFile )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto ErrorReturn;
            }
        }
        g_pCacheZone = pzone;
    }

    //
    //  regular zone - default zone properties
    //
    //  notify
    //      primary - all other NS
    //      DS primary or secondary - only explictly listed secondaries
    //
    //  secondary security
    //      primary - all other NS
    //      DS primary or secondary - only explictly listed secondaries

    else
    {
        pzone->fNotifyLevel = ZONE_NOTIFY_LIST_ONLY;
        if ( IS_ZONE_PRIMARY( pzone ) && !IS_ZONE_DSINTEGRATED( pzone ) )
        {
            pzone->fNotifyLevel = ZONE_NOTIFY_ALL_SECONDARIES;
        }

        //
        //  Set the default zone transfer flag - non-primary zones and
        //  ds-integrated zones default to no-transfer, non-ds primary
        //  zones default to NS-list-only.
        //
        
        if ( IS_ZONE_PRIMARY( pzone ) )
        {
            pzone->fSecureSecondaries =
                IS_ZONE_DSINTEGRATED( pzone ) ?
                    ZONE_SECSECURE_NO_XFR :
                    ZONE_SECSECURE_NS_ONLY;
        }
        else
        {
            pzone->fSecureSecondaries = ZONE_SECSECURE_NO_XFR;
        }

        //
        //  If new zone (i.e. not load), then force registry write
        //  note, there's backward compatibility issue that makes it
        //  imperative not to write;  we use ABSENCE of the SecureSecondaries
        //  key to indicate NT4 upgrade and hence more intelligent
        //  decision about value based on list
        //

        if ( SrvCfg_fStarted )
        {
            ASSERT( !pzone->fAutoCreated );

            Zone_SetSecondaries(
                pzone,
                pzone->fSecureSecondaries,
                NULL,                       // nothing in list
                pzone->fNotifyLevel,
                NULL,                       // no notify list
                dwregFlags );
        }
    }

    //
    //  aging init
    //

    if ( IS_ZONE_PRIMARY(pzone) )
    {
        Zone_SetAgingDefaults( pzone );
    }

    //
    //  snap zone into list
    //
    //  DEVNOTE: should "cache" zone even be in zone list?
    //      - already special cased for write back
    //      - doesn't need to be in list for zone control
    //      - RPC is only other issue
    //      - then can elminate for add\delete
    //
    //  currently cache zone is left in the list
    //      this eliminates need for special casing in RPC zone enumeration
    //
    
    Zone_ListInsertZone( pzone );

    //
    //  link zone into database (link into zone tree)
    //      - zone tree node points at zone
    //      - zone tree node marked as authoritative zone root
    //

    if ( !IS_ZONE_CACHE(pzone) )
    {
        PDB_NODE    pzoneRoot = pzone->pZoneTreeLink;

        Dbase_LockDatabase();
        pzoneRoot->pZone = pzone;

        SET_ZONE_ROOT(pzoneRoot);
        SET_AUTH_ZONE_ROOT(pzoneRoot);
        Dbase_UnlockDatabase();
    }

    IF_DEBUG( INIT )
    {
        Dbg_Zone(
            "Created new: ",
            pzone );
    }
    *ppZone = pzone;

    return ERROR_SUCCESS;

ErrorReturn:

    DNS_DEBUG( INIT, (
        "%s: failed error 0x%X\n", fn, status ));

    if ( pzone )
    {
        if ( pzone == g_pCacheZone )
        {
            g_pCacheZone = NULL;
            ASSERT( FALSE );
        }

        //
        //  If zone creation failed and we have a zone pointer we need
        //  to clean it up. Since this zone struct is bogus, set the
        //  zone deleted count high to circumvent the "smarts" in Zone_Free.
        //  This is not one of the cases where we need the zone to
        //  persist after delete.
        //

        pzone->cDeleted = 255;
        Zone_Free( pzone );
    }
    *ppZone = NULL;

    if ( ppExistingZone && !*ppExistingZone )
    {
        *ppExistingZone = pexistingZone;
    }

    return status;
}



DNS_STATUS
Zone_Create_W(
    OUT     PZONE_INFO *        ppZone,
    IN      DWORD               dwZoneType,
    IN      PWSTR               pwsZoneName,
    IN      PDNS_ADDR_ARRAY     aipMasters,
    IN      BOOL                fDsIntegrated,
    IN      PWSTR               pwsFileName
    )
/*++

Routine Description:

    Create zone information.

    Note:  all Zone_Create() info applies.

Arguments:

    (see Zone_Create())

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD   resultLength;
    DWORD   bufLength;
    CHAR    utf8Name[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR    utf8File[ MAX_PATH ];

    DNS_DEBUG( INIT, (
        "Zone_Create_W() %S\n"
        "    type %d\n"
        "    file %S\n",
        pwsZoneName,
        dwZoneType,
        pwsFileName ));

    //
    //  convert zone name
    //

    bufLength = DNS_MAX_NAME_BUFFER_LENGTH;

    resultLength = Dns_StringCopy(
                            utf8Name,
                            & bufLength,
                            (PCHAR) pwsZoneName,
                            0,
                            DnsCharSetUnicode,
                            DnsCharSetUtf8 );   // convert to UTF8
    if ( resultLength == 0 )
    {
        return DNS_ERROR_INVALID_NAME;
    }

    if ( pwsFileName )
    {
        bufLength = MAX_PATH;

        resultLength = Dns_StringCopy(
                                utf8File,
                                & bufLength,
                                (PCHAR) pwsFileName,
                                0,
                                DnsCharSetUnicode,
                                DnsCharSetUtf8 );   // convert to UTF8
        if ( resultLength == 0 )
        {
            return DNS_ERROR_INVALID_DATAFILE_NAME;
        }
    }

    return Zone_Create(
                ppZone,
                dwZoneType,
                utf8Name,
                0,
                0,                              //  flags
                aipMasters,
                fDsIntegrated,
                NULL,                           //  naming context
                pwsFileName ? utf8File : NULL,
                0,
                NULL,
                NULL );                         //  existing zone
}



VOID
Zone_Free(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Free zone info structure.

    Note, this does NOT delete zone from list, that must
    be done by Zone_Delete() function.

Arguments:

    pZone -- zone to free

Return Value:

    None

--*/
{
    if ( !pZone )
    {
        return;
    }

    DNS_DEBUG( ANY, (
        "Zone_Free( %s ) -- cycle %d\n",
        pZone->pszZoneName,
        pZone->cDeleted ));

    //
    //  don't free until have gone through several delayed free
    //      cycles;  this prevents longer operations, like some
    //      DS updates from exceeding delay (when under stress)
    //      and being active when zone actually deleted

    if ( pZone->cDeleted < 7 )
    {
        pZone->cDeleted++;
        Timeout_FreeWithFunction( pZone, Zone_Free );
        return;
    }


    //  should never be freeing with outstanding tree cleanup

    if ( pZone->pOldTree )
    {
        DNS_PRINT((
            "ERROR:  zone %s (%p) free with outstanding pOldTree ptr!\n",
            pZone->pszZoneName,
            pZone ));
        ASSERT( FALSE );
        return;
    }

    //  close update log -- if open

    if ( pZone->hfileUpdateLog )
    {
        CloseHandle( pZone->hfileUpdateLog );
    }

    Ec_DeleteControlObject( pZone->pEventControl );

    //  free substructures

    FREE_HEAP( pZone->pwsZoneName );
    FREE_HEAP( pZone->pszZoneName );
    FREE_HEAP( pZone->pCountName );

    FREE_HEAP( pZone->pwsDataFile );
    FREE_HEAP( pZone->pszDataFile );
    FREE_HEAP( pZone->pwsLogFile );
    FREE_HEAP( pZone->pwszZoneDN );
    FREE_HEAP( pZone->pZoneObjectGuid );

    DnsAddrArray_Free( pZone->aipMasters );
    DnsAddrArray_Free( pZone->aipSecondaries );
    DnsAddrArray_Free( pZone->aipAutoCreateNS );
    DnsAddrArray_Free( pZone->aipLocalMasters );

    FREE_HEAP( pZone->pSD );
    pZone->dwSdLen = 0;
    
    FREE_HEAP( pZone->pwsDeletedFromHost );

    FREE_HEAP( pZone->pszBreakOnUpdateName );

    //  deleting DS zone, drop DS zone count

    if ( pZone->fDsIntegrated )
    {
        SrvCfg_cDsZones--;
    }

    //  free zone structure itself

    FREE_HEAP( pZone );
}



VOID
Zone_DeleteZoneNodes(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Timeout free zone node trees.

Arguments:

    pZone -- zone to delete

Return Value:

    None

--*/
{
    if ( pZone->pTreeRoot )
    {
        DNS_DEBUG( INIT, (
            "Deleting zone %s database at %p\n",
            pZone->pszZoneName,
            pZone->pTreeRoot ));
        Timeout_FreeWithFunction( pZone->pTreeRoot, NTree_DeleteSubtree );
        pZone->pTreeRoot = NULL;
    }
    if ( pZone->pLoadTreeRoot )
    {
        DNS_DEBUG( INIT, (
            "Deleting zone %s loading database at %p\n",
            pZone->pszZoneName,
            pZone->pLoadTreeRoot ));
        Timeout_FreeWithFunction( pZone->pLoadTreeRoot, NTree_DeleteSubtree );
        pZone->pLoadTreeRoot = NULL;
    }
}   //  Zone_DeleteZoneNodes



VOID
Zone_Delete(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwCreateFlags
    )
/*++

Routine Description:

    Remove the zone from the zonelist and delete.

Arguments:

    pZone -- zone to delete
    
    dwCreateFlags -- used to specify impersonation

Return Value:

    None

--*/
{
    PDB_NODE    pzoneTreeZoneRoot;
    PZONE_INFO  prootZone = NULL;

    DNS_DEBUG( ANY, (
        "Zone_Delete( %s )\n",
        pZone->pszZoneName ));

    if ( dwCreateFlags & ZONE_CREATE_IMPERSONATING )
    {
        RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
    }

    //
    //  deleting cache zone -- ignore
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  attempt to delete cache zone!\n" ));
        goto Done;
    }

    //
    //  pause zone to stop lookups for new queries in zone
    //

    pZone->fPaused = TRUE;

    //
    //  lock out any update activity
    //      - wait for a long time to get lock (15m => 900s => 900000ms)
    //
    //  note, delete zone as LOCKED, that way during entire delete process
    //  through final memory timeout, no threads holding pZone ptr will be
    //  able to get through and party on zone
    //

    if ( !Zone_LockForWriteEx(
            pZone,
            DNSUPDATE_ADMIN,
            900000,
            __FILE__,
            __LINE__ ) )
    {
        DNS_PRINT((
            "ERROR:  Failed to lock zone %s before zone delete!\n",
            pZone->pszZoneName ));
        ASSERT( FALSE );
        goto Done;
    }

    //
    //  remove zone from list
    //  mark as deleted
    //

    Zone_ListRemoveZone( pZone );

    pZone->cDeleted = 1;

    //
    //  authoritative zone
    //
    //  => "uproot" zone root
    //  this eliminates pZone from being set in nodes in zone
    //
    //  => delete authoritative zone's registry key
    //      - so don't load zone on reboot
    //
    //  note:  not deleting registry key for cache zone, as cache ONLY
    //  deleted when overwritten by new authoritative zone;
    //  so if delete key, we'll destroy new root zone info
    //

    pzoneTreeZoneRoot = Lookup_ZoneTreeNodeFromDottedName(
                            pZone->pszZoneName,
                            0,
                            LOOKUP_MATCH_ZONE );        //  exact name match
    if ( !pzoneTreeZoneRoot )
    {
        DNS_PRINT((
            "ERROR:  Zone_Delete( %s ), does NOT have zone node in zone tree!\n",
            pZone->pszZoneName ));
    }
    else
    {
        //
        //  if deleting root zone, need cache up
        //

        if ( IS_ROOT_ZONE(pZone) )
        {
            prootZone = pZone;
        }

        //
        //  remove zone from zone tree
        //      - clear zone root flag
        //      - for non-root zone, clear zone root flag

        Dbase_LockDatabase();
        CLEAR_AUTH_ZONE_ROOT( pzoneTreeZoneRoot );
        if ( !prootZone )
        {
            CLEAR_ZONE_ROOT(pzoneTreeZoneRoot);
        }
        pzoneTreeZoneRoot->pZone = NULL;
        Dbase_UnlockDatabase();

        //
        //  if root zone deleted, cache "zone" becomes active
        //      - write back cache file before delete all NS and A info in zone
        //
        //  DEVNOTE: should patch in NS\glue info from existing root zone to build
        //      root-hints
        //
        //  DEVNOTE: delete root-zone, don't consider forwarders to be load success
        //      if forwarders and can't load, probably still should try write back;
        //      this may require another flag to Zone_LoadRootHints()
        //

        if ( prootZone )
        {
            DNS_STATUS  status;
            DWORD       zoneType;
            PWSTR       pfileTemp;

            status = Zone_LoadRootHints();
            if ( status == ERROR_SUCCESS )
            {
                goto RegDelete;
            }
            if ( status == DNS_ERROR_ZONE_LOCKED )
            {
                DNS_DEBUG( INIT, (
                    "Deleting root zone, and unable to load root hints\n"
                    "    zone is locked\n" ));
                goto RegDelete;
            }

            DNS_DEBUG( INIT, (
                "Deleting root zone, and unable to load root hints\n"
                "    Forcing root-hints write back\n" ));

            //
            //  DEVNOTE: can't plug in at present because of overload of cache zone
            //      once cache zone issue fixed, can plug in to g_pRootHintZone,
            //      write, then force reload and dump
            //

            //
            //  temporarily mimic root-hints zone for write back
            //      - save off file string, for later cleanup
            //      - if DS integrated, we'll write to DS, no action necessary
            //

            pfileTemp = pZone->pwsDataFile;
            pZone->pwsDataFile = L"cache.dns";

            zoneType = pZone->fZoneType;
            pZone->fZoneType = DNS_ZONE_TYPE_CACHE;

            //
            //  write back root-hints
            //      - if successful, then force root-hint reload
            //

            if ( File_WriteZoneToFile( pZone, NULL, dwCreateFlags ) )
            {
                DNS_DEBUG( INIT, (
                    "Successfully wrote root hints, from deleted root zone data\n" ));

                Zone_LoadRootHints();
            }
            ELSE_IF_DEBUG( ANY )
            {
                DNS_PRINT(( "ERROR:  writing root-hints from deleted root zone!\n" ));
            }

            //  restore root zone for delete

            pZone->pwsDataFile = pfileTemp;
            pZone->fZoneType = zoneType;
        }
    }

RegDelete:

    Reg_DeleteZone( 0, pZone->pwsZoneName );

    //
    //  close update log
    //

    if ( pZone->hfileUpdateLog )
    {
        CloseHandle( pZone->hfileUpdateLog );
        pZone->hfileUpdateLog = NULL;
    }

    //
    //  Set the zone DP to NULL so that we can track zone/DP association.
    //

    Ds_SetZoneDp( pZone, NULL, FALSE );

    //
    //  delete zone data
    //      - records in zone update list
    //          (delete records, add records are in zone data)
    //      - zone data
    //      - failed zone load (if any)
    //

    ASSERT( pZone->UpdateList.pListHead == NULL ||
            pZone->UpdateList.Flag & DNSUPDATE_EXECUTED );

    pZone->UpdateList.Flag |= DNSUPDATE_NO_DEREF;
    Up_FreeUpdatesInUpdateList( &pZone->UpdateList );

    Zone_DeleteZoneNodes( pZone );

    //
    //  timeout free zone in case query holds ptr to it
    //

    Timeout_FreeWithFunction( pZone, Zone_Free );
    
    Done:
    
    if ( dwCreateFlags & ZONE_CREATE_IMPERSONATING )
    {
        RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_CLIENT_CONTEXT );
    }

    return;
}



DNS_STATUS
Zone_Rename(
    IN OUT  PZONE_INFO      pZone,
    IN      LPCSTR          pszNewZoneName,
    IN      LPCSTR          pszNewZoneFile
    )
/*++

Routine Description:

    Rename a zone and optionally rename zone file (if file-backed)

Arguments:

    pZone -- zone to rename

    pszNewZoneName -- new name of the zone

    pszNewZoneFile -- new file name for zone file, may be NULL

Return Value:

    None

--*/
{
    DBG_FN( "Zone_Rename" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_NODE        pZoneNode = NULL;
    BOOLEAN         mustUnlockZone = FALSE;
    BOOLEAN         originalZonePauseValue = FALSE;
    BOOLEAN         zoneFileIsChanging = FALSE;
    BOOLEAN         repairingZone = FALSE;
    WCHAR           wsOriginalZoneFile[ MAX_PATH + 2 ] = L"";
    WCHAR           wsOriginalZoneName[ DNS_MAX_NAME_BUFFER_LENGTH + 2 ] = L"";
    CHAR            szOriginalZoneName[ DNS_MAX_NAME_BUFFER_LENGTH + 2 ] = "";

    ASSERT( pszNewZoneName );
    ASSERT( pZone );
    ASSERT( pZone->pszZoneName );
    ASSERT( pZone->pwsZoneName );
    ASSERT( pZone->pZoneRoot );

    DNS_DEBUG( ANY, (
        "%s( %s ) to %s file %s\n", fn,
        pZone->pszZoneName,
        pszNewZoneName,
        pszNewZoneFile ? pszNewZoneFile : "NULL" ));

    //
    //  Setup names and stuff.
    //

    strcpy( szOriginalZoneName, pZone->pszZoneName );
    wcscpy( wsOriginalZoneName, pZone->pwsZoneName );
    if ( pZone->pwsDataFile )
    {
        wcscpy( wsOriginalZoneFile, pZone->pwsDataFile );
    }

    //
    //  Rename cache or root zone is not allowed.
    //

    if ( IS_ZONE_CACHE( pZone ) || IS_ROOT_ZONE( pZone ) )
    {
        DNS_DEBUG( ANY, (
            "%s: ignoring attempt to rename cache or root zone\n", fn ));
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        ASSERT( FALSE );
        goto Failure;
    }

    //
    //  Check if we already have a zone matching the new name.
    //

    pZoneNode = Lookup_ZoneTreeNodeFromDottedName(
                    ( LPSTR ) pszNewZoneName,
                    0,
                    LOOKUP_MATCH_ZONE );
    if ( pZoneNode )
    {
        DNS_PRINT((
            "%s: cannot rename zone %s to %s (zone already exists)\n", fn,
            pZone->pszZoneName,
            pszNewZoneName ));
        status = DNS_ERROR_ZONE_ALREADY_EXISTS;
        goto Failure;
    }

    //
    //  Lock and pause the zone.
    //

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        status = DNS_ERROR_ZONE_LOCKED;
        goto Failure;
    }
    mustUnlockZone = TRUE;
    originalZonePauseValue = pZone->fPaused;
    pZone->fPaused = TRUE;

    //
    //  Remove from zone list. We will rename and add it back later.
    //

    Zone_ListRemoveZone( pZone );

    //
    //  Look up the existing zone in the zone tree.
    //

    pZoneNode = Lookup_ZoneTreeNodeFromDottedName(
                    pZone->pszZoneName,
                    0,
                    LOOKUP_MATCH_ZONE );
    if ( !pZoneNode )
    {
        DNS_PRINT((
            "%s: zone %s does not have zone node in zone tree\n", fn,
            pZone->pszZoneName ));
    }
    else
    {
        //
        //  Remove zone from zone tree.
        //

        Dbase_LockDatabase();
        CLEAR_AUTH_ZONE_ROOT( pZoneNode );
        CLEAR_ZONE_ROOT( pZoneNode );
        pZoneNode->pZone = NULL;
        Dbase_UnlockDatabase();
    }

    //
    //  Delete the zone from the registry. We will add it back later
    //  under it's new name.
    //

    Reg_DeleteZone( 0, pZone->pwsZoneName );

    //
    //  Close the update log. We will want to reopen a new log file with
    //  the new zone name in the file name.
    //

    if ( pZone->hfileUpdateLog )
    {
        CloseHandle( pZone->hfileUpdateLog );
        pZone->hfileUpdateLog = NULL;
    }

    //
    //  Delete the zone from the DS if necessary.
    //

    if ( IS_ZONE_DSINTEGRATED( pZone ) )
    {
        status = Ds_DeleteZone( pZone, 0 );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "%s: failed to delete zone %s from DS\n", fn,
                pZone->pszZoneName ));
            goto Failure;
        }
    }

    //
    //  We may jump to this label if the rename operation fails to try
    //  and undo all the changes made so far.
    //

    RepairOriginalZone:

    //
    //  Zone has now been removed from all server structures. Rename it.
    //

    status = setZoneName( pZone, pszNewZoneName, 0 );
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  Construct zone DN.
    //

    if ( IS_ZONE_DSINTEGRATED( pZone ) )
    {
        //
        //  WITH NC SUPPORT WE CAN'T JUST RECREATE BLINDLY - NEED TO RECREATE
        //  IN PROPER CONTAINER - FIX THIS BEFORE RENAME GOES LIVE!
        //
        ASSERT( FALSE );

        FREE_HEAP( pZone->pwszZoneDN );
        pZone->pwszZoneDN = DS_CreateZoneDsName( pZone );
        if ( pZone->pwszZoneDN == NULL )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failure;
        }
    }

    //
    //  Fix the zone's tree (pTreeRoot). Right now the tree will look
    //  something like this:
    //      oldzonename2 -> oldzonename1 -> children
    //  so we need to turn it into:
    //      newzonename3 -> newzonename2 -> newzonename2 -> children
    //  Note: the children are unaffected - they just need to get moved.
    //

    pZoneNode = Lookup_ZoneNodeFromDotted(
                    pZone,                  // zone
                    szOriginalZoneName,     // zone name
                    0,                      // name length
                    LOOKUP_NAME_FQDN,       // flags
                    NULL,                   // optional closest node
                    NULL );                 // optional status pointer
    if ( !pZoneNode )
    {
        DNS_PRINT((
            "%s: zone %s cannot be found in it's own tree\n", fn,
            pZone->pszZoneName ));
    }
    else
    {
        PVOID       pChildren;
        ULONG       cChildren;
        PDB_RECORD  pRRList;

        //
        //  Steal the pointer to the children of the zone's own node
        //  and delete the tree from the zone.
        //
        
        pChildren = pZoneNode->pChildren;
        cChildren = pZoneNode->cChildren;
        pRRList = pZoneNode->pRRList;
        pZoneNode->pChildren = NULL;
        pZoneNode->cChildren = 0;
        pZoneNode->pRRList = NULL;

        //
        //  Stick the children into the tree under the proper node.
        //

        pZoneNode = Lookup_ZoneNodeFromDotted(
                        pZone,                      // zone
                        ( LPSTR ) pszNewZoneName,   // zone name
                        0,                          // name length
                        LOOKUP_NAME_FQDN,           // flags
                        NULL,                       // optional closest node
                        NULL );                     // optional status pointer
        ASSERT( pZoneNode );
        ASSERT( pZoneNode->pChildren == NULL );
        SET_ZONE_ROOT( pZoneNode );
        SET_AUTH_ZONE_ROOT( pZoneNode );
        SET_AUTH_NODE( pZoneNode );
        pZoneNode->pChildren = pChildren;
        pZoneNode->cChildren = cChildren;
        pZoneNode->pRRList = pRRList;
        pZone->pZoneRoot = pZoneNode;
    }

    //
    //  Set up zone in database and registry.
    //

    status = Zone_RootCreate( pZone, NULL );
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    if ( g_bRegistryWriteBack )
    {
        Reg_SetDwordValue(
            0,                      //  flags
            NULL,
            pZone,
            DNS_REGKEY_ZONE_TYPE,
            pZone->fZoneType );
    }

    //
    //  If this zone has masters update them. This is a bit wasteful
    //  since the ZONE_INFO already has the masters set, but we need
    //  to call Zone_SetMasters() to set the masters in the registry.
    //

    if ( ZONE_NEEDS_MASTERS( pZone ) )
    {
        status = Zone_SetMasters(
                    pZone,
                    pZone->aipMasters,
                    FALSE,              //  set global masters
                    0 );                //  registry flags
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }
    }

    //
    //  Create zone database.
    //

    status = Zone_DatabaseSetup(
                pZone,
                pZone->fDsIntegrated,
                ( LPSTR ) pszNewZoneFile,
                0,              //  zone filename length
                0,              //  flags
                NULL,           //  DP pointer
                0,              //  DP flags
                NULL );         //  DP FQDN

    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  Check if zone file changed.
    //

    if ( !repairingZone
        && pZone->pwsDataFile
        && wsOriginalZoneFile[ 0 ] != '\0'
        && wcsicmp_ThatWorks( pZone->pwsDataFile, wsOriginalZoneFile ) != 0 )
    {
        zoneFileIsChanging = TRUE;
    }

    //
    //  Set secondaries. This writes the secondaries into the registry.
    //

    if ( SrvCfg_fStarted )
    {
        Zone_SetSecondaries(
            pZone,
            pZone->fSecureSecondaries,
            NULL,                       //  nothing in list
            pZone->fNotifyLevel,
            NULL,                       //  no notify list
            0 );                        //  registry flags
    }

    //
    //  Insert into zone list.
    //

    Zone_ListInsertZone( pZone );

    //
    //  Link zone into database (ie. link into zone tree).
    //

    pZoneNode = pZone->pZoneTreeLink;
    Dbase_LockDatabase();
    pZoneNode->pZone = pZone;
    SET_ZONE_ROOT( pZoneNode );
    SET_AUTH_ZONE_ROOT( pZoneNode );
    Dbase_UnlockDatabase();

    //
    //  Update zone in persistent storage.
    //

    if ( IS_ZONE_DSINTEGRATED( pZone ) )
    {
        status = Ds_WriteZoneToDs( pZone, 0 );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "%s: failed to write renamed zone %s to DS\n", fn,
                pZone->pszZoneName ));
            goto Failure;
        }
    }
    else
    {
        if ( File_WriteZoneToFile( pZone, NULL, 0 )
            && zoneFileIsChanging )
        {
            File_DeleteZoneFileW( wsOriginalZoneFile );
        }
    }

    //
    //  Reload zone from persistent storage. This is only required until
    //  I fix the zones tree (in pZoneRoot).
    //

    //  Zone_Load( pZone );

    //
    //  JJW: must reopen update log (but only if it was open!!)
    //

    status = ERROR_SUCCESS;

    DNS_DEBUG( ANY, (
        "%s: renamed zone to %s\n", fn,
        pZone->pszZoneName ));

    goto Cleanup;

    Failure:

    //
    //  This needs more thought. There could be a lot of work to do if
    //  the rename failed at some stage along the way. I'm not 100%
    //  certain that the logic below will recover us from any
    //  possible error condition.
    // 

    if ( !repairingZone )
    {
        pszNewZoneName = szOriginalZoneName;
        FREE_HEAP( pZone->pwsDataFile );
        pZone->pwsDataFile = Dns_StringCopyAllocate_W( wsOriginalZoneFile, 0 );
        repairingZone = TRUE;
        goto RepairOriginalZone;
    }

    DNS_DEBUG( ANY, (
        "%s: failed to rename zone %s (file %s)\n", fn,
        pszNewZoneName,
        pszNewZoneFile ? pszNewZoneFile : "NULL" ));

    Cleanup:

    //
    //  Unpause and unlock the zone.
    //

    pZone->fPaused = originalZonePauseValue;
    if ( mustUnlockZone )
    {
        Zone_UnlockAfterAdminUpdate( pZone );
    }

    return status;
}



DNS_STATUS
Zone_RootCreate(
    IN OUT  PZONE_INFO      pZone,
    OUT     PZONE_INFO *    ppExistingZone      OPTIONAL
    )
/*++

Routine Description:

    Create zone root, and associate with zone.

Arguments:

    pZone -- zone to create root for

    ppExistingZone -- set to existing zone if the zone already exists

Return Value:

    ERROR_SUCCESS if successful.
    Error code on error.

--*/
{
    PDB_NODE        pzoneRoot;
    DNS_STATUS      status;

    ASSERT( pZone );
    ASSERT( pZone->pszZoneName );

    if ( ppExistingZone )
    {
        *ppExistingZone = NULL;
    }

    //
    //  find / create domain node
    //      - save in zone information
    //

    pzoneRoot = Lookup_CreateZoneTreeNode( pZone->pszZoneName );
    if ( !pzoneRoot )
    {
        DNS_DEBUG( INIT, (
            "ERROR:  unable to create zone for name %s\n",
            pZone->pszZoneName ));
        return DNS_ERROR_ZONE_CREATION_FAILED;
    }

    if ( IS_AUTH_ZONE_ROOT(pzoneRoot) )
    {
        DNS_DEBUG( INIT, (
            "ERROR:  zone root creation failed for %s, zone block %p\n"
            "    This node is already an authoritative zone root\n"
            "    of zone block at %p\n"
            "    with zone name %s\n",
            pZone->pszZoneName,
            pZone,
            pzoneRoot->pZone,
            ((PZONE_INFO)pzoneRoot->pZone)->pszZoneName ));

        Dbg_DbaseNode(
            "Node already zone root",
            pzoneRoot );

        if ( ppExistingZone )
        {
            *ppExistingZone = pzoneRoot->pZone;
        }

        if ( ((PZONE_INFO)pzoneRoot->pZone)->fAutoCreated )
        {
            return DNS_ERROR_AUTOZONE_ALREADY_EXISTS;
        }
        else
        {
            return DNS_ERROR_ZONE_ALREADY_EXISTS;
        }
    }

    //
    //  set flag if reverse lookup zone, allows
    //      - fast filtering for producing admin zone list
    //      - fast determination of whether WINS \ WINSR is appropriate
    //
    //  DEVNOTE: WINSR broken at ARPA zone
    //      - this now includes ARPA as reverse for admin tool, but obviously
    //      WINSR doesn't operate correctly under it
    //
    //  DEVNOTE: should detect valid IP6.INT nodes
    //

    if ( Dbase_IsNodeInSubtree( pzoneRoot, DATABASE_ARPA_NODE ) )
    {
        pZone->fReverse = TRUE;

        if ( !Name_GetIpAddressForReverseNode(
                pzoneRoot,
                &pZone->ipReverse ) )
        {
            return DNS_ERROR_ZONE_CREATION_FAILED;
        }
    }

    //  detect IPv6 reverse lookup
    //      - note, do not start at "int" zone as this valid for forward lookup

    else if ( Dbase_IsNodeInSubtree( pzoneRoot, DATABASE_IP6_NODE ) )
    {
        pZone->fReverse = TRUE;
    }

    //
    //  get count of labels of zone root node,
    //  useful for WINS lookup
    //

    pZone->cZoneNameLabelCount = (UCHAR) pzoneRoot->cLabelCount;

    //
    //  save link to zone tree
    //  but DO NOT link zone into zone-tree until
    //      Zone_Create completes
    //

    pZone->pZoneTreeLink = pzoneRoot;

    return ERROR_SUCCESS;
}



DNS_STATUS
Zone_DatabaseSetup(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           fDsIntegrated,
    IN      PCHAR           pchFileName,    OPTIONAL
    IN      DWORD           cchFileNameLen, OPTIONAL
    IN      DWORD           dwCreateFlags,  OPTIONAL
    IN      PDNS_DP_INFO    pDpInfo,        OPTIONAL
    IN      DWORD           dwDpFlags,      OPTIONAL
    IN      LPSTR           pszDpFqdn       OPTIONAL
    )
/*++

Routine Description:

    Setup zone to use zone file or DS.

Arguments:

    pZone -- zone to setup file for

    fDsIntegrated -- use DS, instead of file

    pchFileName -- file name, if NULL use database

    cchFileNameLen -- file name length, if zero, assume pchFileName is
                        NULL terminated string

    pDpInfo -- pointer to directory partition where zone is stored

    dwDpFlags -- DP flags for specifying built-in DP as target
                 (pDpInfo must be NULL)

    pszDpFqdn -- DP FQDN for specifying custom DP as target
                 (pDpInfo must be NULL)

Return Value:

    ERROR_SUCCESS -- if successful
    Error code -- on failure

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PSTR            pnewUtf8 = NULL;
    PWSTR           pnewUnicode = NULL;
    BOOL            fupdateLock = FALSE;

    ASSERT( pZone );
    ASSERT( pZone->pwsZoneName );
    ASSERT( !pchFileName || !( dwDpFlags && pszDpFqdn ) );
    
    //
    //  If this thread is currently impersonating an RPC client, revert
    //  to the server context because registry writes are not protected
    //  by ACLs on a per-admin basis.
    //
    
    if ( dwCreateFlags & ZONE_CREATE_IMPERSONATING )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
        if ( status != ERROR_SUCCESS )
        {
            dwCreateFlags &= ~ZONE_CREATE_IMPERSONATING;
            goto Cleanup;
        }
    }

    DNS_DEBUG( INIT, (
        "Zone_DatabaseSetup( %S )\n"
        "    fDsIntegrated    = %d\n"
        "    pchFileName      = %.*s\n",
        pZone->pwsZoneName,
        fDsIntegrated,
        cchFileNameLen ? cchFileNameLen : MAX_PATH,
        pchFileName ));

    if ( fDsIntegrated && pchFileName )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    //  using DS
    //
    //  DEVNOTE: server global check on use of DS?
    //      at a minimum need to change default
    //
    //  if zone written to DS, then MUST switch to registry boot
    //

    if ( fDsIntegrated )
    {
        BOOL        oldDsIntegrated = pZone->fDsIntegrated;

        if ( !IS_ZONE_PRIMARY( pZone ) &&
             !IS_ZONE_FORWARDER( pZone ) &&
             !IS_ZONE_STUB( pZone ) &&
             !IS_ZONE_CACHE( pZone ) )
        {
            status = DNS_ERROR_INVALID_ZONE_TYPE;
            goto Cleanup;
        }

        //
        //  Find the directory partition that should host this zone.
        //  If the flags are zero and the FQDN is NULL, then use the
        //  legacy partition (NULL).
        //

        if ( !pDpInfo && ( dwDpFlags || pszDpFqdn ) )
        {
            status = Dp_FindPartitionForZone(
                        dwDpFlags,
                        pszDpFqdn,
                        FALSE,
                        &pDpInfo );
            if ( status != ERROR_SUCCESS )
            {
                goto Cleanup;
            }
        }

        //
        //  Set zone's partition membership.
        //

        pZone->fDsIntegrated = ( BOOL ) fDsIntegrated;

        status = Ds_SetZoneDp( pZone, pDpInfo, FALSE );
        if ( status != ERROR_SUCCESS )
        {
            pZone->fDsIntegrated = oldDsIntegrated;
            goto Cleanup;
        }

        //
        //  Reset boot method to directory.
        //

        if ( SrvCfg_fBootMethod == BOOT_METHOD_FILE ||
             SrvCfg_fBootMethod == BOOT_METHOD_UNINITIALIZED )
        {
            DNS_PROPERTY_VALUE prop = { REG_DWORD, BOOT_METHOD_DIRECTORY };

            Config_ResetProperty(
                0,
                DNS_REGKEY_BOOT_METHOD,
                &prop );
        }

        //
        //  if first zone switched to using DS, then must
        //  reset dependency on NTDS service
        //
        //  to do this maintain count of DS zones,
        //  all new DS zones are counted here
        //  zones deleted at counted in Zone_Delete()
        //

        if ( pZone->fDsIntegrated )
        {
            SrvCfg_cDsZones++;      // count new DS zones
        }

        //  start zone control thread, if not already running

        Xfr_InitializeSecondaryZoneControl();
        goto Finish;
    }

    //
    //  no data file specified
    //      - ok for secondary, but NOT primary or cache
    //      - if RPC call, then use default file name
    //

    if ( ! pchFileName )
    {
        if ( IS_ZONE_SECONDARY(pZone) || IS_ZONE_FORWARDER(pZone) )
        {
            goto Finish;
        }
        if ( SrvCfg_fStarted )
        {
            Zone_CreateDefaultZoneFileName( pZone );
        }
        if ( !pZone->pwsDataFile )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  no filename for non-secondary zone %S\n",
                pZone->pwsZoneName ));
            status = DNS_ERROR_PRIMARY_REQUIRES_DATAFILE;
            goto Cleanup;
        }

        //
        //  Reset directory fields.
        //

        pZone->pDpInfo = NULL;
        Timeout_Free( pZone->pwszZoneDN );
        pZone->pwszZoneDN = NULL;

        //  save ptr to new file name
        //  but NULL zone ptr, so it is not freed below
        //  then create UTF8 version

        pnewUnicode = pZone->pwsDataFile;
        pZone->pwsDataFile = NULL;

        pnewUtf8 = Dns_StringCopyAllocate(
                                (PCHAR) pnewUnicode,
                                0,
                                DnsCharSetUnicode,
                                DnsCharSetUtf8 );
        if ( !pnewUtf8 )
        {
            status = DNS_ERROR_INVALID_DATAFILE_NAME;
            goto Cleanup;
        }
    }

    //
    //  file specified
    //      - create unicode and UTF8 filenames
    //

    else
    {
        pnewUtf8 = Dns_StringCopyAllocate(
                                pchFileName,
                                cchFileNameLen,
                                DnsCharSetUtf8,
                                DnsCharSetUtf8 );
        if ( !pnewUtf8 )
        {
            status = DNS_ERROR_INVALID_DATAFILE_NAME;
            goto Cleanup;
        }

        //  replace forward slashes in UNIX filename with NT backslashes

        ConvertUnixFilenameToNt( pnewUtf8 );

        pnewUnicode = Dns_StringCopyAllocate(
                                pnewUtf8,
                                0,
                                DnsCharSetUtf8,
                                DnsCharSetUnicode );
        if ( !pnewUnicode )
        {
            status = DNS_ERROR_INVALID_DATAFILE_NAME;
            goto Cleanup;
        }
    }

    //
    //  check directory and path combination for length
    //

    if ( ! File_CheckDatabaseFilePath(
                pnewUnicode,
                0 ) )
    {
        status = DNS_ERROR_INVALID_DATAFILE_NAME;
        goto Cleanup;
    }


Finish:

    //
    //  reset database info
    //

    Zone_UpdateLock( pZone );
    fupdateLock = TRUE;

    Timeout_Free( pZone->pszDataFile );
    Timeout_Free( pZone->pwsDataFile );

    pZone->pszDataFile = pnewUtf8;
    pZone->pwsDataFile = pnewUnicode;
    pnewUtf8 = NULL;
    pnewUnicode = NULL;

    pZone->fDsIntegrated = ( BOOLEAN ) fDsIntegrated;

    //
    //  set registry values
    //
    //  for cache, only need file name if NOT default
    //  do NOT need DsIntegrated at all -- if no explicit cache file, we'll attempt
    //      open of DS
    //
    //  DEVNOTE: cache file overriding DS?
    //      this logic is problematic if we ever want to allow cache file to
    //      override DS;  this appears to whack default "cache.dns" name in
    //      registry which will, of course, default to DS
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        if ( !g_bRegistryWriteBack )
        {
            goto Cleanup;
        }

        if ( fDsIntegrated ||
             wcsicmp_ThatWorks( pZone->pwsDataFile, DNS_DEFAULT_CACHE_FILE_NAME ) == 0 )
        {
            Reg_DeleteValue(
                0,                      //  flags
                NULL,
                NULL,
                DNS_REGKEY_ROOT_HINTS_FILE );
        }
        else    // non standard cache file name
        {
            ASSERT( pZone->pwsDataFile && cchFileNameLen );
            DNS_DEBUG( INIT, (
                "Setting non-standard cache-file name %S\n",
                pZone->pwsDataFile ));

            Reg_SetValue(
                0,                      //  flags
                NULL,
                NULL,
                DNS_REGKEY_ROOT_HINTS_FILE_PRIVATE,
                DNS_REG_WSZ,
                pZone->pwsDataFile,
                0 );
        }
    }

    //
    //  for zone's, set DSIntegrated or DataFile value
    //

    else if ( g_bRegistryWriteBack )
    {
        if ( fDsIntegrated )
        {
            ASSERT( pZone->fDsIntegrated );

            Reg_SetDwordValue(
                0,                      //  flags
                NULL,
                pZone,
                DNS_REGKEY_ZONE_DS_INTEGRATED,
                fDsIntegrated );

            if ( ZONE_DP( pZone ) && !IS_DP_LEGACY( ZONE_DP( pZone ) ) )
            {
                Reg_SetValue(
                    0,                      //  flags
                    NULL,
                    pZone,
                    ( PSTR ) WIDE_TEXT( DNS_REGKEY_ZONE_DIRECTORY_PARTITION ),
                    DNS_REG_UTF8,
                    ZONE_DP( pZone )->pszDpFqdn,
                    0 );
            }
            else
            {
                Reg_DeleteValue(
                    0,                      //  flags
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_DIRECTORY_PARTITION );
            }

            Reg_DeleteValue(
                0,                      //  flags
                NULL,
                pZone,
                DNS_REGKEY_ZONE_FILE );
        }
        else    // zone file
        {
            if ( pZone->pszDataFile )
            {
                Reg_SetValue(
                    0,                      //  flags
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FILE_PRIVATE,
                    DNS_REG_WSZ,
                    pZone->pwsDataFile,
                    0 );
            }
            else
            {
                ASSERT( IS_ZONE_SECONDARY(pZone) || IS_ZONE_FORWARDER(pZone) );
                Reg_DeleteValue(
                    0,                      //  flags
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FILE );
            }

            Reg_DeleteValue(
                0,                      //  flags
                NULL,
                pZone,
                DNS_REGKEY_ZONE_DS_INTEGRATED );
            Reg_DeleteValue(
                0,                      //  flags
                NULL,
                pZone,
                DNS_REGKEY_ZONE_DIRECTORY_PARTITION );
        }

        //  delete obsolete key

        Reg_DeleteValue(
            0,                      //  flags
            NULL,
            pZone,
            DNS_REGKEY_ZONE_USE_DBASE );
    }

    Cleanup:

    if ( dwCreateFlags & ZONE_CREATE_IMPERSONATING )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_CLIENT_CONTEXT );
    }

    if ( fupdateLock )
    {
        Zone_UpdateUnlock( pZone );
    }

    FREE_HEAP( pnewUnicode );
    FREE_HEAP( pnewUtf8 );

    return status;
}



DNS_STATUS
Zone_DatabaseSetup_W(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           fDsIntegrated,
    IN      PWSTR           pwsFileName,
    IN      DWORD           dwCreateFlags,  OPTIONAL
    IN      PDNS_DP_INFO    pDpInfo,        OPTIONAL
    IN      DWORD           dwDpFlags,      OPTIONAL
    IN      LPSTR           pszDpFqdn       OPTIONAL
    )
/*++

Routine Description:

    Setup zone to use zone file or DS.

Arguments:

    (see Zone_DatabaseSetup)

Return Value:

    ERROR_SUCCESS -- if successful
    Error code -- on failure

--*/
{
    DWORD   resultLength;
    DWORD   bufLength;
    CHAR    utf8File[ MAX_PATH ];

    DNS_DEBUG( INIT, (
        "Zone_DatabaseSetup_W( %p, %S )\n",
        pZone,
        pwsFileName ));

    if ( pwsFileName )
    {
        bufLength = MAX_PATH;

        resultLength = Dns_StringCopy(
                                utf8File,
                                & bufLength,
                                (PCHAR) pwsFileName,
                                0,
                                DnsCharSetUnicode,
                                DnsCharSetUtf8 );       // convert to UTF8
        if ( resultLength == 0 )
        {
            return DNS_ERROR_INVALID_DATAFILE_NAME;
        }
    }

    return Zone_DatabaseSetup(
                pZone,
                fDsIntegrated,
                pwsFileName ? utf8File : NULL,
                0,
                dwCreateFlags,
                pDpInfo,
                dwDpFlags,
                pszDpFqdn );
}



DNS_STATUS
Zone_SetMasters(
    IN OUT  PZONE_INFO      pZone,
    IN      PDNS_ADDR_ARRAY aipMasters,
    IN      BOOL            fLocalMasters,
    IN      DWORD           dwRegFlags
    )
/*++

Routine Description:

    Set zone's master servers. Some zone types (currently only stub
    zones) may support local (registry) versus global (DS) master
    server lists.

Arguments:

    pZone -- zone

    aipMasters -- array of master servers IP addresses

    fLocalMasters -- setting local or DS-integrated master list
    
    dwRegFlags -- registry operation flags

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_ADDR_ARRAY     pipNewMasters = NULL;
    PDNS_ADDR_ARRAY *   ppipMasters = NULL;

    ASSERT( pZone );
    ASSERT( pZone->pszZoneName );

    //
    //  if primary -- MUST be clearing master info
    //

    if ( IS_ZONE_PRIMARY( pZone ) )
    {
        ASSERT( !aipMasters );
        pipNewMasters = NULL;
        goto Update;
    }

    //
    //  Secondary zone must have at least one master. This includes
    //  forwarder and stub zones. Nowever it is permissable to
    //  clear the local masters if the non-local masters for the
    //  zone is not empty.
    //

    if ( !IS_ZONE_SECONDARY( pZone ) && !IS_ZONE_FORWARDER( pZone ) )
    {
         return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    if ( ( !aipMasters ||
                !aipMasters->AddrCount ||
                !aipMasters->AddrArray ) &&
        ( !fLocalMasters ||
            ( fLocalMasters &&
                !pZone->aipMasters ||
                !pZone->aipMasters->AddrCount ) ) )
    {
        //
        //  The test above is a little complex, but what it comes down
        //  to is that setting an empty masters array is permissable
        //  only if the array being set is the local array and the
        //  zone has a non-empty set of non-local masters.
        //

        return DNS_ERROR_ZONE_REQUIRES_MASTER_IP;
    }

    //
    //  Validate masters. If clearing the list the input list will be NULL.
    //

    if ( aipMasters )
    {
        status = Zone_ValidateMasterIpList( aipMasters );
        if ( status != ERROR_SUCCESS )
        {
            return status;
        }
    }

    //
    //  Copy master addresses.
    //

    if ( aipMasters && aipMasters->AddrCount )
    {
        pipNewMasters = DnsAddrArray_CreateCopy( aipMasters );
        IF_NOMEM( !pipNewMasters )
        {
            return DNS_ERROR_NO_MEMORY;
        }
        DnsAddrArray_SetPort( pipNewMasters, DNS_PORT_NET_ORDER );
    }

Update:

    //
    //  reset master info
    //

    Zone_UpdateLock( pZone );
    ppipMasters = fLocalMasters ?
                    &pZone->aipLocalMasters :
                    &pZone->aipMasters;
    Timeout_FreeDnsAddrArray( *ppipMasters );
    *ppipMasters = pipNewMasters;

    //
    //  set registry values
    //

    if ( g_bRegistryWriteBack )
    {
        Reg_SetAddrArray(
            dwRegFlags,
            NULL,
            pZone,
            fLocalMasters ?
                DNS_REGKEY_ZONE_LOCAL_MASTERS :
                DNS_REGKEY_ZONE_MASTERS,
            pipNewMasters );
    }

    Zone_UpdateUnlock( pZone );
    return status;
}



DNS_STATUS
Zone_SetSecondaries(
    IN OUT  PZONE_INFO          pZone,
    IN      DWORD               fSecureSecondaries,
    IN      PDNS_ADDR_ARRAY     aipSecondaries,
    IN      DWORD               fNotifyLevel,
    IN      PDNS_ADDR_ARRAY     aipNotify,
    IN      DWORD               dwRegistryFlags
    )
/*++

Routine Description:

    Set zone's secondaries.

Arguments:

    pZone -- zone

    fSecureSecondaries -- only transfer to given secondaries

    fNotifyLevel -- level of notifies;  include all NS?

    aipSecondaries -- IP array of secondaries

    aipNotify -- IP array of secondaries to notify
    
    dwRegistryFlags -- flag value to be passed to registry functions

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_ADDR_ARRAY     pnewSecondaries = NULL;
    PDNS_ADDR_ARRAY     pnewNotify = NULL;

    ASSERT( pZone );
    ASSERT( pZone->pszZoneName );
    ASSERT( !IS_ZONE_CACHE(pZone) );

    DNS_DEBUG( RPC, (
        "Zone_SetSecondaries( %s )\n",
        pZone->pszZoneName ));
    IF_DEBUG( RPC )
    {
        DnsDbg_DnsAddrArray( "Secondaries:\n", NULL, aipSecondaries );
        DnsDbg_DnsAddrArray( "Notify list:\n", NULL, aipNotify );
    }

    //
    //  Screen IP addresses
    //

    if ( aipSecondaries &&
         RpcUtil_ScreenIps( 
                aipSecondaries,
                DNS_IP_ALLOW_SELF,
                NULL ) != ERROR_SUCCESS )
    {
        return DNS_ERROR_INVALID_IP_ADDRESS;
    }
    if ( aipNotify &&
         RpcUtil_ScreenIps( 
                aipNotify,
                0,
                NULL ) != ERROR_SUCCESS )
    {
        return DNS_ERROR_INVALID_IP_ADDRESS;
    }

    //
    //  validate \ copy secondary and notify addresses
    //
    //      - secondaries can include local IP
    //      - screen local IP from notify to avoid self-send
    //          (will return error, but continue)
    //

    pnewSecondaries = aipSecondaries;
    if ( pnewSecondaries )
    {
        pnewSecondaries = DnsAddrArray_CreateCopy( aipSecondaries );
        DnsAddrArray_SetPort( pnewSecondaries, DNS_PORT_NET_ORDER );
        if ( ! pnewSecondaries )
        {
            return DNS_ERROR_INVALID_IP_ADDRESS;
        }
    }
    pnewNotify = aipNotify;
    if ( pnewNotify )
    {
        DWORD   dwOrigAddrCount = pnewNotify->AddrCount;

        pnewNotify = Config_ValidateAndCopyNonLocalIpArray( pnewNotify );
        DnsAddrArray_SetPort( pnewNotify, DNS_PORT_NET_ORDER );
        if ( ! pnewNotify )
        {
            DnsAddrArray_Free( pnewSecondaries );
            return DNS_ERROR_INVALID_IP_ADDRESS;
        }
        if ( dwOrigAddrCount != pnewNotify->AddrCount )
        {
            DNS_DEBUG( RPC, (
                "notify list had invalid address (probably local)\n" ));
            DnsAddrArray_Free( pnewSecondaries );
            DnsAddrArray_Free( pnewNotify );
            return DNS_ERROR_INVALID_IP_ADDRESS;
        }
    }

    //
    //  reset secondary info
    //

    Zone_UpdateLock( pZone );

    pZone->fSecureSecondaries = (UCHAR) fSecureSecondaries;
    pZone->fNotifyLevel = (UCHAR) fNotifyLevel;

    Timeout_FreeDnsAddrArray( pZone->aipSecondaries );
    Timeout_FreeDnsAddrArray( pZone->aipNotify );

    pZone->aipSecondaries = pnewSecondaries;
    pZone->aipNotify = pnewNotify;

    //
    //  set registry values
    //

    if ( g_bRegistryWriteBack )
    {
        Reg_SetDwordValue(
            dwRegistryFlags,
            NULL,
            pZone,
            DNS_REGKEY_ZONE_SECURE_SECONDARIES,
            ( DWORD ) fSecureSecondaries );
        Reg_SetDwordValue(
            dwRegistryFlags,
            NULL,
            pZone,
            DNS_REGKEY_ZONE_NOTIFY_LEVEL,
            ( DWORD ) fNotifyLevel );
        Reg_SetAddrArray(
            dwRegistryFlags,
            NULL,
            pZone,
            DNS_REGKEY_ZONE_NOTIFY_LIST,
            pnewNotify );
        Reg_SetAddrArray(
            dwRegistryFlags,
            NULL,
            pZone,
            DNS_REGKEY_ZONE_SECONDARIES,
            pnewSecondaries );
    }

    Zone_UpdateUnlock( pZone );

    return status;
}



DNS_STATUS
Zone_ResetType(
    IN OUT  PZONE_INFO          pZone,
    IN      DWORD               dwZoneType,
    IN      PDNS_ADDR_ARRAY     aipMasters
    )
/*++

Routine Description:

    Change zone type.

Arguments:

    pZone           --  zone
    dwZoneType      --  new zone type
    cMasters        --  count of master servers
    aipMasters      --  array of IP addresses of zone's masters

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       dwOldZoneType;

    //
    //  save old type -- can't be cache
    //

    dwOldZoneType = pZone->fZoneType;
    if ( dwOldZoneType == DNS_ZONE_TYPE_CACHE ||
         dwZoneType == DNS_ZONE_TYPE_CACHE )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //
    //  Implementation note:
    //  for DS we now must make changes and verify they'll work
    //  before calling this routine which writes to registry
    //
    //  hence we may have changed type even though types match, so
    //  do NOT want to special case type change\no-change
    //

    //  lock
    //      -- avoid getting caught in XFR or admin update

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        return DNS_ERROR_ZONE_LOCKED;
    }

    //
    //  Primary zone -- promoting secondary
    //      => MUST have SOA
    //      => MUST have file or DS
    //

    if ( dwZoneType == DNS_ZONE_TYPE_PRIMARY )
    {
        if ( !pZone->pszDataFile && !pZone->fDsIntegrated )
        {
            status = DNS_ERROR_PRIMARY_REQUIRES_DATAFILE;
            goto Done;
        }
        status = Zone_GetZoneInfoFromResourceRecords( pZone );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }

        //  write new type to registry

        status = Reg_SetDwordValue(
                    0,                      //  flags
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_TYPE,
                    dwZoneType );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
        pZone->fZoneType = (CHAR) dwZoneType;

        //  clear master list

        status = Zone_SetMasters(
                    pZone,
                    NULL,
                    FALSE,          //  set global masters
                    0 );            //  flags
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( FALSE );
            goto Done;
        }

        //  update again as primary, then send NOTIFY
        //  point primary field in SOA to this box

        Zone_GetZoneInfoFromResourceRecords( pZone );
        Zone_SetSoaPrimaryToThisServer( pZone );
        Xfr_SendNotify( pZone );
    }

    //
    //  Secondary zone
    //      - reset masters first (secondary must have masters, let
    //      (master reset routine do check)
    //      - reset type
    //      - start secondary thread, if first secondary
    //
    //  secondary MUST have masters;  letting set master routine do checks,
    //  but restore previous zone type on error
    //

    else if ( dwZoneType == DNS_ZONE_TYPE_SECONDARY
                || dwZoneType == DNS_ZONE_TYPE_STUB
                || dwZoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        pZone->fZoneType = (CHAR) dwZoneType;

        status = Zone_SetMasters(
                    pZone,
                    aipMasters,
                    FALSE,          //  set global masters
                    0 );            //  flags

        if ( status != ERROR_SUCCESS )
        {
            pZone->fZoneType = (CHAR) dwOldZoneType;
            goto Done;
        }

        //  write new type to registry

        status = Reg_SetDwordValue(
                    0,                      //  flags
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_TYPE,
                    dwZoneType );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }

        //
        //  changing to secondary
        //      - must init secondary for transfer checks
        //      - must make sure secondary zone control running
        //      - if forwarder, do not init secondary zone stuff
        //

        if ( !IS_ZONE_FORWARDER( pZone ) )
        {
            Xfr_InitializeSecondaryZoneTimeouts( pZone );
            Xfr_InitializeSecondaryZoneControl();
        }
    }
    else
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Done;
    }

    //
    //  type change requires boot file update
    //

    Config_UpdateBootInfo();
    status = ERROR_SUCCESS;

Done:

    Zone_UnlockAfterAdminUpdate( pZone );
    return status;
}



VOID
Zone_SetAgingDefaults(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Set or reset aging defaults for zone.

Arguments:

    pZone --  ptr to zone

Return Value:

    None

--*/
{
    BOOL    bnewAging;

    if ( !IS_ZONE_PRIMARY(pZone) )
    {
        pZone->bAging = FALSE;
        return;
    }

    //
    //  for primary zones, will always set refresh intervals
    //  set aging based on zone type
    //

    pZone->dwNoRefreshInterval = SrvCfg_dwDefaultNoRefreshInterval;
    pZone->dwRefreshInterval = SrvCfg_dwDefaultRefreshInterval;

    if ( pZone->fDsIntegrated )
    {
        bnewAging = !!(SrvCfg_fDefaultAgingState & DNS_AGING_DS_ZONES);
    }
    else
    {
        bnewAging = !!(SrvCfg_fDefaultAgingState & DNS_AGING_NON_DS_ZONES);
    }

    if ( bnewAging && !pZone->bAging )
    {
        pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();
    }

    pZone->bAging = bnewAging;
}



//
//  Public server zone run-time utilities
//

DNS_STATUS
Zone_ValidateMasterIpList(
    IN      PDNS_ADDR_ARRAY     aipMasters
    )
/*++

Routine Description:

    Validate master IP list.
    This validation is
        -- entries exist
        -- IPs are valid (not broadcast)
        -- not self-send

Arguments:

    pZone -- zone

    aipMasters -- list of zone masters

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_ADDR_ARRAY     pintersectionAddrs = NULL;
    PDNS_ADDR_ARRAY     pmachineAddrs = g_ServerIp4Addrs;
    DNS_STATUS          status = ERROR_SUCCESS;

    //  must have at least one master IP

    if ( !aipMasters )
    {
        return DNS_ERROR_ZONE_REQUIRES_MASTER_IP;
    }

    //
    //  Screen IP addresses
    //

    if ( RpcUtil_ScreenIps( 
                aipMasters,
                0,
                NULL ) != ERROR_SUCCESS )
    {
        status = DNS_ERROR_INVALID_IP_ADDRESS;
        goto Done;
    }

    //  must be valid IP (not loopback, broadcast, zero, etc.)

    if ( !Dns_ValidateDnsAddrArray( aipMasters, 0 ) )
    {
        status = DNS_ERROR_INVALID_IP_ADDRESS;
        goto Done;
    }

    //  verify that there is NO intersection between master list and
    //  the addresses for this machine
    //  (i.e. do not allow self-send)

    if ( pmachineAddrs != NULL )
    {
        status = DnsAddrArray_Diff(
                    aipMasters,
                    pmachineAddrs,
                    DNSADDR_MATCH_IP,
                    NULL, NULL,
                    &pintersectionAddrs );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
        if ( pintersectionAddrs->AddrCount != 0 )
        {
            status = DNS_ERROR_INVALID_IP_ADDRESS;
        }
    }

Done:

    DnsAddrArray_Free( pintersectionAddrs );
    return status;
}



INT
Zone_SerialNoCompare(
    IN      DWORD           dwSerial1,
    IN      DWORD           dwSerial2
    )
/*++

Routine Description:

    Determine if Serial1 greater than Serial2.

Arguments:

Return Value:

    Version difference in wrapped DWORD sense:
        > 0 if dwSerial1 is greater than dwSerial2.
        0   if dwSerial1 == dwSerial2
        < 0 if dwSerial2 is greater than dwSerial1.

    A difference > 0x80000000 is considered to negative (serial2 > serial1)

    //  DEVNOTE: serial number compare
    //  The macro below is not correct.  The idea is to DO a DWORD compare inorder
    //  to handle wrapping and switch into high numbers (>0x80000000)
    //  appropriately, but interpret the result as integer to get less\greater
    //  comparison correct.
    //
    //
    // Alternative approch:
    // #define ZONE_SERIALNOCOMPARE(s1, s2) (s2 > s1: -1: s1 == s2: 0: 1 )
    // don't have to deal w/ type truncation & skipping a func call compensate
    // for the extra comparison. post Beta.
    //
--*/
{
    INT   serialDiff;

    serialDiff = ( INT ) ( dwSerial1 - dwSerial2 );
    return serialDiff;
}



BOOL
Zone_IsIxfrCapable(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Determine if IXFR capable zone.

    This used to determine if necessary to keep around zone update list.

Arguments:

    pZone -- zone to check

Return Value:

    TRUE if zone can do IXFR.
    FALSE otherwise.

--*/
{
    //  no XFR period

    if ( pZone->fSecureSecondaries == ZONE_SECSECURE_NO_XFR )
    {
        return FALSE;
    }

    //  XFR allowed
    //      - if non-DS, then IXFR always ok
    //      - if DS, then must have done XFR since load before allow IXFR

    if ( !pZone->fDsIntegrated )
    {
        return TRUE;
    }

    return pZone->dwLastXfrSerialNo != 0;
}



VOID
Zone_ResetVersion(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwNewSerial
    )
/*++

Routine Description:

    Reset zone version to given value.

Arguments:

    pZone -- zone to increment version

    dwNewSerial -- new serial number to set

Return Value:

    None

--*/
{
    DWORD   serialNo = pZone->dwSerialNo;

    ASSERT( IS_ZONE_LOCKED_FOR_UPDATE( pZone ) );
    ASSERT( pZone->pSoaRR || IS_ZONE_CACHE( pZone ) || IS_ZONE_NOTAUTH( pZone ) );
    ASSERT( Zone_SerialNoCompare( dwNewSerial, pZone->dwSerialNo ) >= 0 );

    if ( !pZone->pSoaRR )
    {
        return;
    }

    pZone->fDirty = TRUE;

    if ( pZone->dwSerialNo != dwNewSerial && !IS_ZONE_CACHE ( pZone ) )
    {
        INLINE_DWORD_FLIP( pZone->pSoaRR->Data.SOA.dwSerialNo, dwNewSerial );
        pZone->dwSerialNo = dwNewSerial;
    }
}   //  Zone_ResetVersion



VOID
Zone_IncrementVersion(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Update zone version.

    Use when admin adds, changes or deletes records in zone.

Arguments:

    pZone -- zone to increment version

    fForce -- TRUE to force increment even if not required

Return Value:

    None

--*/
{
    DWORD   serialNo = pZone->dwSerialNo;

    DNS_DEBUG( UPDATE2, (
        "Zone_IncrementVersion( %s ) serial %d\n",
        pZone->pszZoneName,
        serialNo ));

    ASSERT( IS_ZONE_PRIMARY(pZone) );
    ASSERT( IS_ZONE_LOCKED_FOR_UPDATE(pZone) );
    ASSERT( pZone->pSoaRR );

    Zone_ComputeSerialNumberIncrement( pZone, 0 );
}   //  Zone_IncrementVersion



VOID
Zone_UpdateVersionAfterDsRead(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwVersionRead,
    IN      BOOL            fLoad,
    IN      DWORD           dwPreviousSerial
    )
/*++

Routine Description:

    Update zone version after the zone has been read from the DS.

Arguments:

    pZone -- zone written to file

    dwVersionRead -- highest version read from DS

    fLoad -- TRUE if at initial load, FALSE otherwise

    dwPreviousSerial -- if reload, last serial of previous load

Return Value:

    None

--*/
{
    DWORD   serialNo;
    BOOL    bforcedIncrement = FALSE;
    DWORD   dwsyncLevel = ZONE_SERIAL_SYNC_READ;

    DNS_DEBUG( UPDATE, (
        "Zone_UpdateVersionAfterDsRead( %s )\n"
        "    dwVersionRead        = %d\n"
        "    fLoad,               = %d\n"
        "    dwPreviousSerial     = %d\n",
        pZone->pszZoneName,
        dwVersionRead,
        fLoad,
        dwPreviousSerial ));

    //
    //  if zone load, just use highest serial number read
    //
    //  note:  on serial and secondaries
    //      on reload we have no guarantee that were going to get back to
    //      the previous IN-MEMORY serial number we gave out in XFR, as we
    //      don't know if our IN-MEMORY serial number had been driven above
    //      the max DS serial number;  there is no way to fix this here
    //      (barring stable storage like registry read);  the solution is
    //      to write back last serial number we gave out in XFR PLUS one
    //      to the DS on shutdown or before reload (see ds.c)
    //
    //  however if we do a rebootless reload, we can at least make sure we
    //  get back to something greater than the the previous serial number we
    //

    if ( fLoad )
    {
        serialNo = dwVersionRead;

        //  rebootless reload
        //  if reloading zone, then MUST make sure serial is at least as
        //      large as previous version or secondary can be confused

        if ( dwPreviousSerial &&
             pZone->fSecureSecondaries != ZONE_SECSECURE_NO_XFR &&
             Zone_SerialNoCompare( dwPreviousSerial, serialNo ) >= 0 )
        {
            serialNo = Zone_ComputeSerialNumberIncrement( NULL, dwPreviousSerial );
            bforcedIncrement = TRUE;
        }
        else if ( pZone->dwSerialNo != 0 &&
                  Zone_SerialNoCompare( pZone->dwSerialNo, serialNo ) >= 0 )
        {
            serialNo = pZone->dwSerialNo;
        }
        pZone->dwLoadSerialNo = serialNo;
    }

    //
    //  DS update
    //      -- serial read is larger than current => use it
    //      -- otherwise
    //          -- if supporting secondaries, increment when required
    //          -- otherwise keep at current
    //
    //  "supporting secondaries" then increment if
    //      - XFR NOT disabled
    //      - have sent an XFR on this serial or at load serial
    //
    //  In pure DS installation, there's no need to ever "push" in memory serial
    //  above highest serial in DS.  Serial in DS will be >= highest of last serial read
    //  or written to DS.  Hence serial's on all machines will converge after replication
    //  and poll, and will be preserved across reboot.
    //
    //  Note, even if have secondaries, it is wise to SUPPRESS pushing in memory serial
    //  up when possible.  That way a zone doesn't "walk" away from DS serial very far
    //  and hence the zone will not recover to it's previous in memory value, more
    //  quickly after a reboot, and the secondary will be in ssync faster.
    //

    else
    {
        ASSERT( IS_ZONE_LOCKED_FOR_UPDATE(pZone) );

        serialNo = pZone->dwSerialNo;
        if ( dwVersionRead
             && Zone_SerialNoCompare( dwVersionRead, serialNo ) > 0 )
        {
            serialNo = dwVersionRead;
        }
        else if ( pZone->fSecureSecondaries != ZONE_SECSECURE_NO_XFR &&
                  ( HAS_ZONE_VERSION_BEEN_XFRD( pZone ) ||
                    serialNo == pZone->dwLoadSerialNo ) )
        {
            serialNo = Zone_ComputeSerialNumberIncrement( NULL, serialNo );
            
            //
            //  Because we cannot write to the DS on shutdown force the SOA
            //  to be rewritten back to DS immediately. This prevents serial 
            //  rollback on reload.
            //
            
            bforcedIncrement = TRUE;
            dwsyncLevel = ZONE_SERIAL_SYNC_SHUTDOWN;
        }
        else
        {
            DNS_DEBUG( DS, (
                "Suppressing version update (no secondaries) on zone %s after DS read\n"
                "    new serial           = %d\n"
                "    current              = %d\n"
                "    sent XFR serial      = %d\n",
                pZone->pszZoneName,
                dwVersionRead,
                serialNo,
                pZone->dwLastXfrSerialNo ));
            return;
        }
    }

    DNS_DEBUG( DS, (
        "Updating version to %d after DS read\n",
        serialNo ));

    Zone_ResetVersion( pZone, serialNo );

    //
    //  if necessary, push serial back to DS
    //

    if ( bforcedIncrement )
    {
        Ds_CheckForAndForceSerialWrite( pZone, dwsyncLevel, FALSE );
    }
}



VOID
updateZoneSoa(
    IN OUT  PZONE_INFO      pZone,
    IN      PDB_RECORD      pSoaRR
    )
/*++

Routine Description:

    Update zone's information for new SOA record.
    Should be called whenever zone SOA record is read in or
    updated.

    Save a ptr to SOA in zone block, and host byte order
    version of serial number to speed access.

Arguments:

    pZone - zone to update

    pSoaRR - new SOA RR

Return Value:

    None.

--*/
{
    DWORD   serialNo;
    BOOL    floading;

    ASSERT( pZone );

    //
    //  save ptr to SOA
    //  get SOA's serial
    //

    pZone->pSoaRR = pSoaRR;

    INLINE_DWORD_FLIP( serialNo, pSoaRR->Data.SOA.dwSerialNo );

    //
    //  refuse to move SOA serial forward
    //
    //  for DS zones, we do not continually advance SOA in DS to avoid
    //  unnecessary replication traffic
    //
    //  however we still keep in-memory serial advancing, to allow XFR to
    //  non-DS zones;
    //  hence, pick up SOA serial only if higher than current serial
    //
    //  will also do this on non-DS zones to handle case where someone
    //  sends in record from admin with non-refreshed SOA, while zone
    //  serial has changed underneath
    //

    //  use zone's current serial, if it is higher than new value

    if ( pZone->dwLoadSerialNo  &&
        Zone_SerialNoCompare(pZone->dwSerialNo, serialNo) > 0 )
    {
        serialNo = pZone->dwSerialNo;
        INLINE_DWORD_FLIP( pSoaRR->Data.SOA.dwSerialNo, serialNo );
    }

    //
    //  save version in host byte order for fast compares
    //

    pZone->dwSerialNo = serialNo;

    //
    //  loading?
    //
    //  if this is first version of zone loaded, then set load version
    //  to this current version;  load version is limit on secondary
    //  versions we can handle with incremental transfer
    //

    floading = FALSE;
    if ( pZone->dwLoadSerialNo == 0 )
    {
        floading = TRUE;
        pZone->dwLoadSerialNo = serialNo;
    }

    //
    //  save default TTL for setting NEW records below
    //

    pZone->dwDefaultTtl = pSoaRR->Data.SOA.dwMinimumTtl;
    pZone->dwDefaultTtlHostOrder = ntohl( pZone->dwDefaultTtl );

    //
    //  for DS, set SOA primary to be THIS server
    //  since every DS-integrated zone is primary, we need to do this
    //  for DS primaries, as SOA in DS may have different server as primary
    //
    //  also do any primary zone on DNS boot, to catch possible name change
    //      messing up server boot
    //

    if ( pZone->fDsIntegrated )
    {
        Zone_SetSoaPrimaryToThisServer( pZone );
    }

    //
    //  on load, check all default records on primary
    //      - server name change
    //      - IP change
    //
    //  DEVNOTE: do we need to be more intelligent here for reloads?
    //

    if ( floading && IS_ZONE_PRIMARY(pZone) )
    {
        Zone_CheckAndFixDefaultRecordsOnLoad( pZone );
    }

    IF_DEBUG( READ2 )
    {
        Dbg_DbaseRecord(
            "SOA RR after read into zone:",
            pZone->pSoaRR );
    }
}



VOID
Zone_UpdateInfoAfterPrimaryTransfer(
    IN OUT  PZONE_INFO  pZone,
    IN      DWORD       dwStartTime
    )
/*++

Routine Description:

    Update next available transfer time after doing AXFR.

Arguments:

    pZone -- zone that was transferred

Return Value:

    None

--*/
{
    DWORD   endTime;
    DWORD   chokeTime;

    ASSERT( pZone );
    ASSERT( IS_ZONE_PRIMARY(pZone) );
    ASSERT( IS_ZONE_LOCKED_FOR_READ(pZone) );
    ASSERT( pZone->pSoaRR );

    //
    //  for updateable zones need to limit AXFRs from holding lock too long
    //
    //  calculate transfer interval and throttle AXFR for some time interval based
    //  on length of transfer just completed
    //

    endTime = DNS_TIME();

    chokeTime = ( endTime - dwStartTime ) * SrvCfg_dwXfrThrottleMultiplier;
    if ( chokeTime > MAX_AXFR_THROTTLE_INTERVAL )
    {
        chokeTime = MAX_AXFR_THROTTLE_INTERVAL;
    }
    pZone->dwNextTransferTime = endTime + chokeTime;

    DNS_DEBUG( AXFR, (
        "Zone transfer of %s completed\n",
        "    version          = %d\n"
        "    start            = %d\n"
        "    end              = %d\n"
        "    choke interval   = %d\n"
        "    reopen time      = %d\n"
        "    RR count         = %d\n",
        pZone->pszZoneName,
        pZone->dwSerialNo,
        dwStartTime,
        endTime,
        chokeTime,
        pZone->dwNextTransferTime,
        pZone->iRRCount ));
}



DNS_STATUS
Zone_GetZoneInfoFromResourceRecords(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Extract info from RR that is used in ZONE_INFO structure.

Arguments:

    pZone -- zone update zone info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_RECORD      prr;

    ASSERT( pZone );

    if ( IS_ZONE_CACHE(pZone) )
    {
        return ERROR_SUCCESS;
    }
    ASSERT( pZone->pZoneRoot );
    ASSERT( IS_ZONE_PRIMARY(pZone) ||
            IS_ZONE_SECONDARY(pZone) ||
            IS_ZONE_FORWARDER(pZone) );

    //
    //  should already have zone update lock
    //      - either loading zone
    //      - XFR zone
    //      - updating zone
    //
    //  DEVNOTE: temporarily taking lock again;  should
    //      switch to ASSERTing ownership of zone write lock
    //

    ASSERT( IS_ZONE_LOCKED_FOR_WRITE_BY_THREAD(pZone) );

    if ( !Zone_LockForUpdate( pZone ) )
    {
        ASSERT( FALSE );
    }

    DNS_DEBUG( UPDATE, (
        "Zone_GetZoneInfoFromResourceRecords() for zone %s\n"
        "    fRootDirty = %d\n",
        pZone->pszZoneName,
        pZone->fRootDirty ));

    //
    //  find SOA
    //      - if not found on primary zone, create one
    //      this can happen if read corrupted SOA from DS
    //

    prr = RR_FindNextRecord(
                pZone->pZoneRoot,
                DNS_TYPE_SOA,
                NULL,
                0 );
    if ( !prr )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Zone %s has no SOA record\n",
            pZone->pszZoneName ));

        if ( !IS_ZONE_PRIMARY(pZone) )
        {
            status = DNS_ERROR_ZONE_HAS_NO_SOA_RECORD;
            goto ZoneError;
        }

        status = Zone_CreateDefaultSoa(
                    pZone,
                    NULL );     //  default admin name
        if ( status != ERROR_SUCCESS )
        {
            status = DNS_ERROR_ZONE_HAS_NO_SOA_RECORD;
            goto ZoneError;
        }
        prr = RR_FindNextRecord(
                    pZone->pZoneRoot,
                    DNS_TYPE_SOA,
                    NULL,
                    0 );
        if ( !prr )
        {
            status = DNS_ERROR_ZONE_HAS_NO_SOA_RECORD;
            ASSERT( FALSE );
            goto ZoneError;
        }
    }

    updateZoneSoa( pZone, prr );

    //
    //  Set\reset zone WINS\WINSR lookup
    //      - load
    //      - admin update
    //      - XFR recv
    //  may all change WINS record to be used
    //

    Wins_ResetZoneWinsLookup( pZone );

    //
    //  NS list for notify \ secure secondaries
    //
    //  DEVNOTE: NS isn't necessarily dirty when root is dirty
    //      should set in update
    //

    MARK_ZONE_NS_DIRTY( pZone );

    //  reset flag indicating zone root has outstanding update

    pZone->fRootDirty = FALSE;

    DNS_DEBUG( UPDATE, (
        "Leaving Zone_GetZoneInfoFromResourceRecords( %s )\n",
        pZone->pszZoneName ));

    Zone_UnlockAfterAdminUpdate( pZone );
    return ERROR_SUCCESS;

ZoneError:

    DNS_DEBUG( ANY, (
        "ERROR:  Zone_GetZoneInfoFromResourceRecords( %s ) failed!\n",
        pZone->pszZoneName ));

    Zone_UnlockAfterAdminUpdate( pZone );
    return status;
}



VOID
Zone_WriteBack(
    IN      PZONE_INFO      pZone,
    IN      BOOL            fShutdown
    )
/*++

Routine Description:

    Write the zone back to DS or file, depending on the zone configuration.

    Write only if:
        - cache zone (because updates not tracked)
        - dirty
        - not locked OR shutdown flag FALSE

Arguments:

    pZone - zone to write back

    fShutdown - TRUE if the server is shutting down, some behavior is
        slightly different (ie. zone locks ignored and DS zones forced)

Return Value:

    None.

--*/
{
    if ( !pZone )
    {
        return;
    }

    DNS_DEBUG( INIT, (
        "Zone_WriteBack( %S, fShutdown=%d )\n"
        "    type     = %d\n"
        "    file     = %S\n"
        "    dirty    = %d\n",
        pZone->pwsZoneName,
        ( int ) fShutdown,
        pZone->fZoneType,
        pZone->pwsDataFile,
        pZone->fDirty ));

    IF_DEBUG( OFF )
    {
        Dbg_Zone(
            "Zone_WriteBack: ",
            pZone );
    }

    //
    //  do NOT have "updates" for cache zone, so (unlike regular zones)
    //      when root-hints dirty must write to DS as well as file
    //
    //  note:  AutoCacheUpdate, currently unsupported, if later
    //      supported then must write shutdown when it's on
    //

    if ( IS_ZONE_CACHE( pZone ) )
    {
        Zone_WriteBackRootHints(
            FALSE );                // don't write if not dirty
    }
    else
    {
        //
        //  DS zones. DS updates are made during update no write needed.
        //

        if ( pZone->fDsIntegrated )
        {
            if ( fShutdown )
            {
                Ds_CheckForAndForceSerialWrite(
                    pZone,
                    ZONE_SERIAL_SYNC_SHUTDOWN,
                    FALSE );
            }
        }

        //
        //  non-DS authoriative zones
        //      -- write back and notify if dirty
        //
        //  note, write back first, so that zone is NOT LOCKED when
        //  AXFR request comes in in response to NOTIFY
        //

        else if ( pZone->fDirty )
        {
            if ( fShutdown || !IS_ZONE_LOCKED( pZone ) )
            {
                File_WriteZoneToFile(
                    pZone,
                    NULL,
                    0 );
            }
            if ( !fShutdown )
            {
                Xfr_SendNotify( pZone );
            }
        }
    }
}   //  Zone_WriteBack



VOID
Zone_WriteBackDirtyZones(
    IN      BOOL            fShutdown
    )
/*++

Routine Description:

    Write dirty zones back to file. Also performs zone sanity checking.

    Called on shutdown or by timeout thread.

Arguments:

    fShutdown - TRUE if the server is shutting down

Return Value:

    None

--*/
{
    PZONE_INFO pzone = NULL;

    DNS_DEBUG( INIT, (
        "Zone_WriteBackDirtyZones( fShutdown=%d )\n",
        ( int ) fShutdown ));

    while ( pzone = Zone_ListGetNextZone( pzone ) )
    {
        Zone_WriteBack( pzone, fShutdown );

        //
        //  Sanity check zone if not shutting down. Intuitively, this is
        //  a bad place to be doing this, but this function is called on the
        //  timeout thread and we don't want to sanity check anything until
        //  the server has loaded everything and had time to settle.
        //

        if ( !fShutdown &&
             !pzone->fSelfTested &&
             SrvCfg_dwSelfTestFlag )
        {
            Zone_SelfTestCheck( pzone );
        }
    }
}   //  Zone_WriteBackDirtyZones



DNS_STATUS
Zone_WriteZoneToRegistry(
    PZONE_INFO      pZone
    )
/*++

Routine Description:

    Writes all parameters for the zone to the registry.

Arguments:

    pZone -- zone to rewrite to registry

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DNS_STATUS      rc = ERROR_SUCCESS;

    #define CHECK_STATUS( rcode ) if ( rcode != ERROR_SUCCESS ) goto Done

    //
    //  Do nothing for auto-created zones.
    //

    if ( pZone->fAutoCreated )
    {
        goto Done;
    }

    DNS_DEBUG( REGISTRY, (
        "Rewriting zone %S (type %d) to registry\n",
        pZone->pwsZoneName,
        pZone->fZoneType ));

    //
    //  Cache zone.
    //

    if ( IS_ZONE_CACHE( pZone ) )
    {
        if ( IS_ZONE_DSINTEGRATED( pZone ) ||
            wcsicmp_ThatWorks( pZone->pwsDataFile,
                DNS_DEFAULT_CACHE_FILE_NAME ) == 0 )
        {
            rc = Reg_DeleteValue(
                    0,                      //  flags
                    NULL,
                    NULL,
                    DNS_REGKEY_ROOT_HINTS_FILE );
            CHECK_STATUS( rc );
        }
        else
        {
            rc = Reg_SetValue(
                    0,                      //  flags
                    NULL,
                    NULL,
                    DNS_REGKEY_ROOT_HINTS_FILE_PRIVATE,
                    DNS_REG_WSZ,
                    pZone->pwsDataFile,
                    0 );
            CHECK_STATUS( rc );
        }
        goto Done;
    }
    
    //
    //  Regular zone (not cache zone).
    //

    rc = Reg_SetDwordValue(
            0,                      //  flags
            NULL,
            pZone,
            DNS_REGKEY_ZONE_TYPE,
            pZone->fZoneType );
    CHECK_STATUS( rc );

    if ( IS_ZONE_DSINTEGRATED( pZone ) )
    {
        rc = Reg_SetDwordValue(
                0,                      //  flags
                NULL,
                pZone,
                DNS_REGKEY_ZONE_DS_INTEGRATED,
                pZone->fDsIntegrated );
        CHECK_STATUS( rc );

        if ( ZONE_DP( pZone ) && !IS_DP_LEGACY( ZONE_DP( pZone ) ) )
        {
            rc = Reg_SetValue(
                    0,                      //  flags
                    NULL,
                    pZone,
                    ( PSTR ) WIDE_TEXT( DNS_REGKEY_ZONE_DIRECTORY_PARTITION ),
                    DNS_REG_UTF8,
                    ZONE_DP( pZone )->pszDpFqdn,
                    0 );
            CHECK_STATUS( rc );
        }
        else
        {
            Reg_DeleteValue(
                    0,                      //  flags
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_DIRECTORY_PARTITION );
        }

        Reg_DeleteValue(
                0,                      //  flags
                NULL,
                pZone,
                DNS_REGKEY_ZONE_FILE );
    }
    else
    {
        if ( pZone->pszDataFile )
        {
            rc = Reg_SetValue(
                    0,                      //  flags
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FILE_PRIVATE,
                    DNS_REG_WSZ,
                    pZone->pwsDataFile,
                    0 );
            CHECK_STATUS( rc );
        }
        else
        {
            Reg_DeleteValue(
                    0,                      //  flags
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FILE );
        }
        if ( IS_ZONE_FORWARDER( pZone ) )
        {
            rc = Reg_SetDwordValue(
                    0,                      //  flags
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FWD_TIMEOUT,
                    pZone->dwForwarderTimeout );
            CHECK_STATUS( rc );
            rc = Reg_SetDwordValue(
                    0,                      //  flags
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FWD_SLAVE,
                    pZone->fForwarderSlave );
            CHECK_STATUS( rc );
        }
        rc = Reg_DeleteValue(
                0,                      //  flags
                NULL,
                pZone,
                DNS_REGKEY_ZONE_DS_INTEGRATED );

        rc = Reg_DeleteValue(
                0,                      //  flags
                NULL,
                pZone,
                DNS_REGKEY_ZONE_DIRECTORY_PARTITION );
    }

    //
    //  Secondary parameters.
    //

    rc = Reg_SetDwordValue(
            0,                      //  flags
            NULL,
            pZone,
            DNS_REGKEY_ZONE_SECURE_SECONDARIES,
            ( DWORD ) pZone->fSecureSecondaries );
    CHECK_STATUS( rc );
    rc = Reg_SetDwordValue(
            0,                      //  flags
            NULL,
            pZone,
            DNS_REGKEY_ZONE_NOTIFY_LEVEL,
            ( DWORD ) pZone->fNotifyLevel );
    CHECK_STATUS( rc );
    rc = Reg_SetAddrArray(
            0,                      //  flags
            NULL,
            pZone,
            DNS_REGKEY_ZONE_NOTIFY_LIST,
            pZone->aipNotify );
    CHECK_STATUS( rc );
    rc = Reg_SetAddrArray(
            0,                      //  flags
            NULL,
            pZone,
            DNS_REGKEY_ZONE_SECONDARIES,
            pZone->aipSecondaries );
    CHECK_STATUS( rc );

    //
    //  Master IP array.
    //

    if ( ZONE_NEEDS_MASTERS( pZone ) )
    {
        rc = Reg_SetAddrArray(
                0,                      //  flags
                NULL,
                pZone,
                DNS_REGKEY_ZONE_MASTERS,
                pZone->aipMasters );
        CHECK_STATUS( rc );
        rc = Reg_SetAddrArray(
                0,                      //  flags
                NULL,
                pZone,
                DNS_REGKEY_ZONE_LOCAL_MASTERS,
                pZone->aipLocalMasters );
        CHECK_STATUS( rc );
    }

    if ( IS_ZONE_FORWARDER( pZone ) )
    {
        rc = Reg_SetDwordValue(
                0,                      //  flags
                NULL,
                pZone,
                DNS_REGKEY_ZONE_FWD_TIMEOUT,
                pZone->dwForwarderTimeout );
        CHECK_STATUS( rc );
        rc = Reg_SetDwordValue(
                0,                      //  flags
                NULL,
                pZone,
                DNS_REGKEY_ZONE_FWD_SLAVE,
                pZone->fForwarderSlave );
        CHECK_STATUS( rc );
    }

    Done:

    if ( rc != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR: failed registry write of zone %s (rc=%d)\n",
            pZone->pszZoneName,
            rc ));
    }
    return rc;
}   //  Zone_WriteZoneToRegistry



DNS_STATUS
Zone_CreateNewPrimary(
    OUT     PZONE_INFO *    ppZone,
    IN      LPSTR           pszZoneName,
    IN      LPSTR           pszAdminEmailName,
    IN      LPSTR           pszFileName,
    IN      DWORD           dwDsIntegrated,
    IN      PDNS_DP_INFO    pDpInfo,            OPTIONAL
    IN      DWORD           dwCreateFlags
    )
/*++

Routine Description:

    Create new primary zone, including
        - zone info (optional)
        - SOA (default values)
        - NS (for this server)

    For use by admin tool or auto-create reverse zone.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PZONE_INFO      pzone = NULL;

    DNS_DEBUG( INIT, (
        "Zone_CreateNewPrimary()\n"
        "    pszZoneName      = %s\n"
        "    pszAdminEmail    = %s\n"
        "    dwDsIntegrated   = %d\n"
        "    pszDataFile      = %s\n"
        "    dwCreateFlags    = %lx\n",
        pszZoneName,
        pszAdminEmailName,
        dwDsIntegrated,
        pszFileName,
        dwCreateFlags ));

    //
    //  DEVNOTE: delete zone, on primary creation failures?
    //      need zone successfully written back to file to reboot
    //      should delete zone to clear structure from registry
    //      (and memory) if can't reboot
    //

    //
    //  create zone info
    //

    status = Zone_Create(
                &pzone,
                DNS_ZONE_TYPE_PRIMARY,
                pszZoneName,
                0,
                dwCreateFlags,      //  flags
                NULL,               //  no masters
                dwDsIntegrated,
                pDpInfo,
                pszFileName,
                0,
                NULL,
                NULL );             //  existing zone
    if ( status != ERROR_SUCCESS || !pzone )
    {
        DNS_PRINT((
            "ERROR:  Failed create of new primary zone at %s\n"
            "    status = %d\n",
            pszZoneName,
            status ));
        *ppZone = NULL;
        return status;
    }

    ASSERT( pzone && IS_ZONE_SHUTDOWN( pzone ) );

    //
    //  try to load zone from given file or DS
    //      - if fail to find it -- fine
    //      - if failure to parse it return error
    //

    if ( dwCreateFlags & ZONE_CREATE_LOAD_EXISTING )
    {
        status = Zone_Load( pzone );
        if ( status == ERROR_SUCCESS )
        {
            DNS_PRINT((
                "Successfully loaded new zone %s from %s\n",
                pszZoneName,
                dwDsIntegrated ? "directory" : pszFileName ));
            goto Done;
        }

        //
        //  DEVNOTE: add the error for directory not found?
        //      and make sure test the correct one for each case
        //      perhaps make them the return from Zone_Load()
        //

        else if ( pzone->pszDataFile )
        {
            if ( status != ERROR_FILE_NOT_FOUND )
            {
                DNS_PRINT((
                    "ERROR:  Failure parsing file %s for new primary zone %s\n",
                    pszFileName,
                    pszZoneName ));
                goto Failed;
            }
        }
        else    // DS integrated
        {
            if ( status != LDAP_NO_SUCH_OBJECT )
            {
                DNS_PRINT((
                    "ERROR:  Reading zone %s from DS\n",
                    pszFileName,
                    pszZoneName ));
                goto Failed;
            }
        }

        //  for NT4 compatibility allow drop down to default create
        //  even after load failure

        if ( ! (dwCreateFlags & ZONE_CREATE_DEFAULT_RECORDS) )
        {
            DNS_PRINT((
                "ERROR:  Failed loading zone %s.  File or directory not found\n",
                pszZoneName ));
            goto Failed;
        }
    }

    //
    //  setup zone for load
    //      - can fail on bogus zone name
    //

    status = Zone_PrepareForLoad( pzone );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    //
    //  Set zone flag to disable auto RR creation before we call any
    //  of the auto RR creation functions.
    //

    Zone_SetAutoCreateLocalNS( pzone );

    //
    //  Auto-create zone root records. If we are impersonating RPC client,
    //  switch to server context for these operations.
    //
    //  both SOA and NS, will require server name
    //      - must insure FQDN, or will end up with zone name appended
    //

    if ( dwCreateFlags & ZONE_CREATE_IMPERSONATING )
    {
        status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
        if ( status != ERROR_SUCCESS )
        {
            goto Failed;
        }
    }

    status = Zone_CreateDefaultSoa(
                pzone,
                pszAdminEmailName );
    if ( status == ERROR_SUCCESS )
    {
        status = Zone_CreateDefaultNs( pzone );
    }

    if ( dwCreateFlags & ZONE_CREATE_IMPERSONATING )
    {
        DNS_STATUS  tempstatus;
        
        tempstatus = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_CLIENT_CONTEXT );
        if ( status == ERROR_SUCCESS )
        {
            status = tempstatus;
        }
    }

    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    //
    //  for loopback zone, create loopback record
    //      => 127.0.0.1 pointing to "localhost"
    //

    if ( !_stricmp( pszZoneName, "127.in-addr.arpa" ) )
    {
        status = Zone_CreateLocalHostPtrRecord( pzone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "ERROR:  Failed loopback create!\n" ));
            ASSERT( FALSE );
        }
    }

    //  successful default zone creation
    //  start zone up and unlock

    status = Zone_ActivateLoadedZone( pzone );
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        goto Failed;
    }

    //
    //  if NOT auto-reverse
    //
    //  setup zone info from SOA
    //      - ptr to SOA
    //      - version number
    //
    //  write zone to file or DS
    //      - do this here, so NO matter what, if admin has created
    //      zone we have written a file\DS and can successfully reboot
    //

    //
    //  DEVNOTE: no recovery on file write problem with new primary
    //

    if ( !pzone->fAutoCreated )
    {
        if ( pzone->fDsIntegrated )
        {
            status = Ds_WriteZoneToDs( pzone, 0 );
            if ( status != ERROR_SUCCESS )
            {
                DNS_PRINT((
                    "ERROR:  failed to write zone %s to DS\n"
                    "    zone create fails, deleting zone\n",
                    pzone->pszZoneName ));
                goto Failed;
            }
        }
        else
        {
            if ( !File_WriteZoneToFile( pzone, NULL, dwCreateFlags ) )
            {
                //  should never have problem with auto-created records
                //  filename has been tested during zone create
                //  but possible problem with locked file, full disk, etc.

                TEST_ASSERT( FALSE );

                DNS_PRINT((
                    "ERROR:  Writing new primary zone to datafile %s\n",
                    pzone->pszDataFile ));
                status = DNS_ERROR_FILE_WRITEBACK_FAILED;
                goto Failed;
            }
        }
    }

Done:


    STARTUP_ZONE( pzone );

    //  unlock lock taken in Zone_Create()

    Zone_UnlockAfterAdminUpdate( pzone );

    *ppZone = pzone;
    return ERROR_SUCCESS;

Failed:

    //  delete zone unless able to completely create
    //      -> wrote SOA
    //      -> wrote back to file or DS (except for non-auto reverse zones)

    DNS_DEBUG( ALL, (
        "ERROR:  Failed to create new primary zone %s\n"
        "    status = %d (%p)\n",
        pzone->pszZoneName,
        status, status ));

    Zone_Delete( pzone, dwCreateFlags );
    
    *ppZone = NULL;

    return status;
}



VOID
Zone_CreateDefaultZoneFileName(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Creates default file name for zone, unless this is a forwarder zone.
    Filename is directly added to zone info block.

Arguments:

    pZone -- zone to create file name for

Return Value:

    None.

--*/
{
    WCHAR  wsfileName[ MAX_PATH+2 ];

    ASSERT( pZone );

    wcscpy( wsfileName, pZone->pwsZoneName );
    wcscat( wsfileName, L".dns" );

    pZone->pwsDataFile = Dns_StringCopyAllocate_W(
                            (PCHAR) wsfileName,
                            0 );
}



//
//  Zone lookup
//

PZONE_INFO
Zone_FindZoneByName(
    IN      LPSTR           pszZoneName
    )
/*++

Routine Description:

    Find zone matching name.

Arguments:

    pszZoneName -- name of desired zone

Return Value:

    Ptr to zone info block, if successful.
    NULL if handle invalid.

--*/
{
    PDB_NODE    pzoneRoot;

    if ( !pszZoneName )
    {
        return NULL;
    }

    //
    //  find zone name in zone tree
    //      - must have exact match to existing zone
    //

    pzoneRoot = Lookup_ZoneTreeNodeFromDottedName(
                    pszZoneName,
                    0,
                    LOOKUP_MATCH_ZONE
                    );
    if ( !pzoneRoot )
    {
        return NULL;
    }

    ASSERT( pzoneRoot->pZone );

    return (PZONE_INFO)pzoneRoot->pZone;
}



//
//  Reverse zone auto-creation routines
//

DNS_STATUS
Zone_CreateAutomaticReverseZones(
    VOID
    )
/*++

Routine Description:

    Create standard reverse zones automatically.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status;

    //
    //  even if no reverse zones desired create reverse lookup nodes
    //

    //(DATABASE_REVERSE_ROOT)->pRRList = REVERSE_COMBINED_DATA;

    if ( SrvCfg_fNoAutoReverseZones )
    {
        return ERROR_SUCCESS;
    }

    //
    //  three auto-create zones
    //      0     => NAME_ERROR 0.0.0.0 requests
    //      127   => response to 127.0.0.1 requests (as "localhost")
    //      255   => NAME_ERROR 255.255.255.255 requests
    //
    //  these keep any of these (common) requests from being referred
    //      to root name servers
    //

    status = Zone_CreateAutomaticReverseZone( "0.in-addr.arpa" );
    status = Zone_CreateAutomaticReverseZone( "127.in-addr.arpa" );
    status = Zone_CreateAutomaticReverseZone( "255.in-addr.arpa" );
    return ERROR_SUCCESS;
}



DNS_STATUS
Zone_CreateAutomaticReverseZone(
    IN      LPSTR           pszZoneName
    )
/*++

Routine Description:

    If zone doesn't exist, create automatic zone.

Arguments:


Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PZONE_INFO      pzone;

    //
    //  does desired zone already exist?
    //
    //  if exists, we're done
    //
    //  note:  for reverse lookup node, node should NEVER exist
    //      unless it is in AUTHORITATIVE zone
    //      - no reference to PTR nodes
    //      - no glue PTR
    //      - no caching
    //

    pzone = Zone_FindZoneByName( pszZoneName );
    if ( pzone )
    {
        DNS_DEBUG( INIT, (
            "Zone %s already exists,\n"
            "    no auto-create of %s zone\n"
            "%s\n",
            pszZoneName,
            pszZoneName ));
        return ERROR_SUCCESS;
    }

    //
    //  create zone and default records
    //

    status = Zone_CreateNewPrimary(
                & pzone,
                pszZoneName,
                NULL,
                NULL,
                NO_DATABASE_PRIMARY,
                NULL,                   //  naming context
                FALSE );

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR: creating auto-create zone %s\n"
            "    status = %d\n",
            pszZoneName,
            status ));
    }
    return status;
}



//
//  Zone load\unload
//

DNS_STATUS
Zone_PrepareForLoad(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Prepare for load of zone.

Arguments:

    pZone - zone to load

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure

--*/
{
    PDB_NODE    pnodeTreeRoot;
    PDB_NODE    pnodeZoneRoot;

    DNS_DEBUG( INIT, (
        "Zone_PrepareForLoad( %s )\n",
        pZone->pszZoneName ));

    //
    //  may NOT load if already loading zone
    //      OR
    //  if have not deleted previous zone load
    //

    if ( pZone->pLoadTreeRoot || pZone->pOldTree )
    {
        DNS_DEBUG( INIT, (
            "WARNING:  Unable to init zone %s for load!\n"
            "    pOldTree         = %p\n"
            "    pLoadTreeRoot    = %p\n",
            pZone->pszZoneName,
            pZone->pOldTree,
            pZone->pLoadTreeRoot ));
        return DNS_ERROR_ZONE_LOCKED;
    }
    ASSERT( !pZone->pLoadZoneRoot );

    //  zone must be locked to bring loaded database on-line

    ASSERT( IS_ZONE_LOCKED_FOR_WRITE(pZone) );


    //  create zone tree

    pnodeTreeRoot = NTree_Initialize();
    pZone->pLoadTreeRoot = pnodeTreeRoot;

    //  cache zone
    //      - ZoneRoot ptr also points at tree root

    if ( IS_ZONE_CACHE(pZone) )
    {
        pZone->pLoadZoneRoot = pnodeTreeRoot;
        pZone->pLoadOrigin   = pnodeTreeRoot;

        SET_ZONE_ROOT( pnodeTreeRoot );
    }

    //  authoritative zone
    //      - start tree root with outside authority (overwritten for root zone)
    //      - seed tree root with zone ptr (inheirited)
    //      - get zone root
    //      - mark as auth zone root
    //      - set zone authority
    //      - load starts with origin at root
    //
    //  note:  NameCheckFlag can cause root creation to fail even when created zone
    //      (bogus but true);  so we bail

    else
    {
        pnodeTreeRoot->pZone = pZone;
        SET_OUTSIDE_ZONE_NODE( pnodeTreeRoot );

        pnodeZoneRoot = Lookup_ZoneNode(
                            pZone,
                            pZone->pCountName->RawName,
                            NULL,                               // no packet
                            NULL,                               // no lookup name
                            LOOKUP_NAME_FQDN | LOOKUP_LOAD,
                            NULL,                               // create
                            NULL );                             // following node
        if ( !pnodeZoneRoot )
        {
            DNS_STATUS status = GetLastError();
            if ( status == ERROR_SUCCESS )
            {
                ASSERT( FALSE );
                status = ERROR_INVALID_NAME;
            }
            return status;
        }

        SET_ZONE_ROOT( pnodeZoneRoot );
        SET_AUTH_ZONE_ROOT( pnodeZoneRoot );
        SET_AUTH_NODE( pnodeZoneRoot );

        //  should inherit zone from parents
        ASSERT( pnodeZoneRoot->pZone == pZone );

        pZone->pLoadZoneRoot = pnodeZoneRoot;
        pZone->pLoadOrigin = pnodeZoneRoot;
    }

    STAT_INC( PrivateStats.ZoneLoadInit );

    return ERROR_SUCCESS;
}



VOID
cleanupOldZoneTree(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Cleanup old zone tree.

    This covers direct call to NTree_SubtreeDelete().
    It's purpose is to provide a timeout entry point which will delete
    the old zone tree AND clear a ptr to the old tree in the zone block.
    That pointer then serves to block new load attempts until the memory
    from the previous tree is cleaned up.

Arguments:

    pZone - zone

Return Value:

    None.

--*/
{
    DNS_DEBUG( TIMEOUT, (
        "cleanupOldZoneTree(%s)\n",
        pZone->pszZoneName ));

    //  can't load while old zone tree exists

    ASSERT( !pZone->pLoadTreeRoot && !pZone->pLoadZoneRoot );

    //
    //  delete zone's old tree
    //

    if ( !pZone->pOldTree )
    {
        DNS_PRINT(( "ERROR:  expected old zone tree!!!\n" ));
        ASSERT( FALSE );
        return;
    }
    NTree_DeleteSubtree( pZone->pOldTree );

    //  clearing pointer, re-enables new zone loads

    pZone->pOldTree = NULL;
}



DNS_STATUS
Zone_ActivateLoadedZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Activate a loaded zone.
    Zone may have been loaded through several means:
        - file load
        - DS load
        - zone transfer

    This routine simply brings the loaded zone on-line.

    Note, caller must do any zone locking required.

Arguments:

    pZone - zone to load

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure

--*/
{
    DNS_STATUS      status;
    PDB_NODE        poldZoneTree;
    UPDATE_LIST     oldUpdateList;

    DNS_DEBUG( INIT, (
        "Zone_ActivateLoadedZone( %s )\n",
        pZone->pszZoneName ));

    IF_DEBUG( INIT )
    {
        Dbg_Zone(
            "Zone being activated: ",
            pZone );
    }

    //  zone must be locked to bring loaded database on-line

    ASSERT( IS_ZONE_LOCKED_FOR_WRITE(pZone) );

    //
    //  must have loaded zone -- or kind of pointless
    //

    if ( !pZone->pLoadTreeRoot )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  ActivateLoadedZone(%s) failed, no load database!!!\n",
            pZone->pszZoneName ));
        return DNS_ERROR_ZONE_CREATION_FAILED;
    }

    ASSERT( pZone->pLoadZoneRoot && pZone->pLoadTreeRoot && !pZone->pOldTree );

    //
    //  rebalance zone
    //      - only bother traversing zone section
    //          (not enough data in the rest to matter)
    //      - no locked required, as tree is off-line
    //
    //  DEVNOTE: make sure that this routine doesn't lock on its own
    //

    NTree_RebalanceSubtreeChildLists(
        pZone->pLoadZoneRoot,
        pZone );

    IF_DEBUG( DATABASE2 )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Zone %s tree after load, before activation:\n",
            pZone->pszZoneName ));
        Dbg_DnsTree(
            "New loaded zone tree",
            pZone->pLoadTreeRoot );
        DnsDebugUnlock();
    }

    //
    //  save current data for later delete
    //

    poldZoneTree = pZone->pTreeRoot;

    RtlCopyMemory(
        & oldUpdateList,
        & pZone->UpdateList,
        sizeof(UPDATE_LIST) );

    //
    //  reset zone's update list
    //      - EXECUTED flag makes sure any future cleanup is limited to
    //      delete RRs (add RRs being in zone data)

    Up_InitUpdateList( &pZone->UpdateList );
    pZone->UpdateList.Flag |= DNSUPDATE_EXECUTED;

    //
    //  swap in loaded tree as working copy of database
    //
    //      - read zone info from database root
    //      - clear dwLoadedVersion so this treated as fresh load
    //          for serial and doing default record fixup
    //
    //  note:  we get ZoneInfo AFTER swapping in new database -- otherwise
    //      default creations, building NS lists, etc. is more complicated
    //
    //  DEVNOTE: however should have back out, if reading zone info fails
    //

    Dbase_LockDatabase();

    pZone->pOldTree = poldZoneTree;

    pZone->pTreeRoot = pZone->pLoadTreeRoot;
    pZone->pZoneRoot = pZone->pLoadZoneRoot;

    pZone->dwSerialNo = 0;
    pZone->dwLoadSerialNo = 0;
    pZone->dwLastXfrSerialNo = 0;

    pZone->pLoadTreeRoot = NULL;
    pZone->pLoadZoneRoot = NULL;
    pZone->pLoadOrigin = NULL;

    if ( IS_ZONE_CACHE(pZone) )
    {
        g_pCacheLocalNode = Lookup_ZoneNodeFromDotted(
                                NULL,
                                "local",
                                0,                      // no length
                                LOOKUP_NAME_FQDN,
                                NULL,                   // create
                                NULL                    // no status return
                                );
        ASSERT( g_pCacheLocalNode );
    }
    else
    {
        Zone_GetZoneInfoFromResourceRecords( pZone );
    }
    Dbase_UnlockDatabase();

    //
    //  if load detected a required update -- execute it
    //      - updates are required if changed Primary name or IP
    //

    if ( pZone->pDelayedUpdateList )
    {
        ASSERT( IS_ZONE_PRIMARY(pZone) );

        status = Up_ExecuteUpdate(
                        pZone,
                        pZone->pDelayedUpdateList,
                        DNSUPDATE_LOCAL_SYSTEM | DNSUPDATE_AUTO_CONFIG );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "ERROR:  processing self-generated update!!!\n" ));
            ASSERT( FALSE );
        }

        //  free update list -- updates themselves are incorporated in update list

        FREE_TAGHEAP( pZone->pDelayedUpdateList, sizeof(UPDATE_LIST), MEMTAG_UPDATE_LIST );
        pZone->pDelayedUpdateList = NULL;


        //  auto update always suppressed because zone is NEVER IXFR capable on
        //      startup;   this prevents this update from allowing bogus IXFR
        //      with bad serial to secondary

        ASSERT( !pZone->fDsIntegrated || pZone->UpdateList.pListHead == NULL );
    }

    //
    //  if primary zone send NOTIFYs
    //
    //  DEVNOTE: probably should not notify this early on initial load
    //      especially for DS zone
    //

    if ( IS_ZONE_PRIMARY(pZone) )
    {
        Xfr_SendNotify( pZone );
    }

    //
    //  For secondary with file at startup, initialize timeouts
    //  For primary just fire up zone.
    //  If successfully loaded, unlock zone.
    //

    if ( IS_ZONE_SECONDARY(pZone) )
    {
        Xfr_InitializeSecondaryZoneTimeouts( pZone );
    }
    else
    {
        STARTUP_ZONE(pZone);
    }

    //
    //  cleanup old database (if any)
    //      - queue as timeout free, so zone can be brought on-line
    //      and to protect against queries with outstanding zone nodes
    //

    if ( poldZoneTree )
    {
        DNS_DEBUG( INIT, (
            "Queuing zone %s old database at %p for delete\n",
            pZone->pszZoneName,
            poldZoneTree ));

        //  flush existing update list
        //      executed flag set so only delete pDeleteRR lists,
        //      pAddRR list are in zone and are deleted in tree

        ASSERT( IS_EMPTY_UPDATE_LIST(&oldUpdateList) ||
                oldUpdateList.Flag & DNSUPDATE_EXECUTED );

        oldUpdateList.Flag |= DNSUPDATE_NO_DEREF;

        Up_FreeUpdatesInUpdateList( &oldUpdateList );

        //
        //  queue timeout delete of previous zone tree
        //
        //  - zone delete is queued to specific function which deletes tree
        //      pZone->pOldTree;  this serves as flag to avoid zone reload until
        //      previous memory freed
        //
        //  - directly queue cache delete, as otherwise cache is blocked from
        //      reload during timeout, and several quick zone loads (which first dump cache)
        //      would be blocked
        //      (since root-hint reads are small data, there really is not memory
        //      issue here that merits blocking cache reloads)
        //

        if ( IS_ZONE_CACHE(pZone) )
        {
            pZone->pOldTree = NULL;
            Timeout_FreeWithFunction( poldZoneTree, NTree_DeleteSubtree );
        }
        else
        {
            Timeout_FreeWithFunction( pZone, cleanupOldZoneTree );
        }
    }
    ELSE_ASSERT( oldUpdateList.pListHead == NULL );

    //
    //  verify crosslink to zone tree
    //

    if ( !IS_ZONE_CACHE(pZone) )
    {
        Dbg_DbaseNode( "ZoneTree node for activated zone", pZone->pZoneTreeLink );
        ASSERT( pZone->pZoneTreeLink );
        ASSERT( pZone->pZoneTreeLink->pZone == pZone );
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
Zone_CleanupFailedLoad(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Cleanup database of failed load.
    May be called safely after successful load (once load has been activated!)

Arguments:

    pZone - zone

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure

--*/
{
    PDB_NODE    pfailedTree;

    DNS_DEBUG( INIT, (
        "Zone_CleanupFailedLoad(%s)\n",
        pZone->pszZoneName ));

    //  zone must be locked to bring loaded database on-line

    ASSERT( IS_ZONE_LOCKED_FOR_WRITE(pZone) );
    ASSERT( pZone->pLoadTreeRoot || !pZone->pLoadZoneRoot );

    //
    //  save load tree, delete load info
    //

    pfailedTree = pZone->pLoadTreeRoot;
    pZone->pLoadTreeRoot = NULL;
    pZone->pLoadZoneRoot = NULL;
    pZone->pLoadOrigin   = NULL;

    //
    //  cleanup load tree
    //      - since failure, delete in-line no references outstanding
    //      this eliminates the possiblity of multiple failures queuing
    //      up lots of failed loads
    //

    if ( pfailedTree )
    {
        DNS_DEBUG( INIT, (
            "Deleting failed zone %s load database at %p\n",
            pZone->pszZoneName,
            pfailedTree ));

        NTree_DeleteSubtree( pfailedTree );
    }
    ELSE_IF_DEBUG( ANY )
    {
        DNS_PRINT((
            "WARNING:  Zone_CleanupFailedLoad( %s ) with no pLoadTreeRoot!\n",
            pZone->pszZoneName ));
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
Zone_Load(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Load a zone file into in memory database.

    This loads either from either DS or file.
    This function exists to do all post-load zone initialization
    for either type of load.

Arguments:

    pZone - zone to load

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;

    //
    //  save zone domain name as orgin
    //      - don't just use pZone lookup name, as may reset with ORIGIN
    //      directive
    //

    DNS_DEBUG( INIT, (
        "\n\nZone_Load(%s)\n",
        pZone->pszZoneName ));

    IF_DEBUG( INIT )
    {
        Dbg_Zone(
            "Loading zone: ",
            pZone );
    }

    //
    //  lock zone while loading
    //
    //  note, already locked in Zone_Create(), but for RPC action
    //  generating a reload, best to have consistent lock-unlock in this
    //  function
    //

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Zone_Load() %s lock failure\n",
            pZone->pszZoneName ));
        return DNS_ERROR_ZONE_LOCKED;
    }

    //
    //  Initialize zone version control for secondary
    //
    //  For secondaries without database file, we're done.
    //      - mark the zone as shutdown, until first zone transfer
    //        can be completed
    //

    if ( IS_ZONE_SECONDARY(pZone) &&
         !pZone->fDsIntegrated )
    {
        if ( !pZone->pszDataFile )
        {
            ASSERT( IS_ZONE_SHUTDOWN(pZone) );

            DNS_DEBUG( INIT, (
                "No database file for secondary zone %s\n",
                pZone->pszZoneName ));

            status = ERROR_FILE_NOT_FOUND;
            goto Exit;
        }
        ASSERT ( pZone->fDsIntegrated == FALSE ) ;
    }

    //
    //  init temporary database for file load
    //
    //  DEVNOTE: this function can fail, when have not yet cleaned up old zone dbase
    //      if want admin to always succeed in doing zone reload, then need some
    //      sort of force flag
    //

    status = Zone_PrepareForLoad( pZone );
    if ( status != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    //  Load from DS or file, if necessary.
    //

    if ( pZone->fDsIntegrated )
    {
        status = Ds_LoadZoneFromDs( pZone, 0 );
    }
    else if ( IS_ZONE_FORWARDER( pZone ) )
    {
        //
        //  File-backed forward zones require no additional processing.
        //

        status = ERROR_SUCCESS;
    }
    else
    {

        ASSERT( pZone->pszDataFile );

        status = File_LoadDatabaseFile(
                    pZone,
                    NULL,
                    NULL,       //  no parent parsing context
                    NULL );     //  default to zone origin
    }

    //  load failed, note do NOT unlock zone
    //  if creating from admin then default zone creation may
    //      take place here

    if ( status != ERROR_SUCCESS )
    {
        Zone_CleanupFailedLoad( pZone );
        goto Exit;
    }

    //
    //  bring loaded zone on-line
    //      - note, DS-integrated is brought on-line inside load function
    //      (see function for explanation)
    //

    if ( !pZone->fDsIntegrated &&
        ( IS_ZONE_AUTHORITATIVE( pZone ) ||
            IS_ZONE_STUB( pZone ) ||
            IS_ZONE_FORWARDER( pZone )  ))
    {
        Zone_ActivateLoadedZone( pZone );
    }

Exit:

    DNS_DEBUG( INIT, (
        "Exit  Zone_Load( %s ), status = %d (%p)\n\n",
        pZone->pszZoneName,
        status, status ));

    Zone_UnlockAfterAdminUpdate( pZone );
    return status;
}



DNS_STATUS
Zone_DumpData(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Dump zone's data. The caller must have the zone locked.

Arguments:

    pZone - zone to dump

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure

--*/
{
    DNS_STATUS      status;
    PDB_NODE        poldZoneTree;
    UPDATE_LIST     oldUpdateList;

    DNS_DEBUG( INIT, (
        "Zone_DumpData(%s)\n",
        pZone->pszZoneName ));
    IF_DEBUG( INIT )
    {
        Dbg_Zone(
            "Zone having data dumped: ",
            pZone );
    }

    SHUTDOWN_ZONE( pZone );

    //
    //  save current data for later delete
    //

    poldZoneTree = pZone->pTreeRoot;

    RtlCopyMemory(
        & oldUpdateList,
        & pZone->UpdateList,
        sizeof(UPDATE_LIST) );

    //
    //  reset zone's update list
    //      - EXECUTED flag makes sure any future cleanup is limited to
    //      delete RRs (add RRs being in zone data)

    Up_InitUpdateList( &pZone->UpdateList );
    pZone->UpdateList.Flag |= DNSUPDATE_EXECUTED;

    //
    //  swap in loaded tree as working copy of database
    //  read zone info from database root
    //
    //  note:  we get ZoneInfo AFTER swapping in new database -- otherwise
    //      default creations, building NS lists, etc. is more complicated
    //  DEVNOTE: however should have back out, if reading zone info fails
    //

    Dbase_LockDatabase();

    pZone->pTreeRoot = NULL;
    pZone->pZoneRoot = NULL;

    //  if cache, rebuild functioning cache tree

    if ( pZone == g_pCacheZone )
    {
        PDB_NODE        proot = NTree_Initialize();

        pZone->pTreeRoot = proot;
        pZone->pZoneRoot = proot;
        STARTUP_ZONE( pZone );
    }

    Dbase_UnlockDatabase();

    //
    //  cleanup old database (if any)
    //      - queue as timeout free, so zone can be brought on-line
    //      and to protect against queries with outstanding zone nodes
    //

    if ( poldZoneTree )
    {
        DNS_DEBUG( INIT, (
            "Queuing zone %s old database at %p for delete\n",
            pZone->pszZoneName,
            poldZoneTree ));

        //  flush existing update list
        //      executed flag set so only delete pDeleteRR lists,
        //      pAddRR list are in zone and are deleted in tree

        //      set EXECUTED flag -- cache "zone" doesn't have it set
        //ASSERT( oldUpdateList.Flag & DNSUPDATE_EXECUTED );

        oldUpdateList.Flag |= DNSUPDATE_EXECUTED;
        Up_FreeUpdatesInUpdateList( &oldUpdateList );

        Timeout_FreeWithFunction( poldZoneTree, NTree_DeleteSubtree );
    }
    ELSE_ASSERT( oldUpdateList.pListHead == NULL );

    return ERROR_SUCCESS;
}



DNS_STATUS
Zone_ClearCache(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Dump cache data for new zone.

    Note:  actual cache dump is done by Zone_LoadRootHints().

Arguments:

    pZone -- new zone

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    //
    //  if startup, then no need, as cache empty
    //

    if ( !SrvCfg_fStarted )
    {
        return ERROR_SUCCESS;
    }

    DNS_DEBUG( RPC, (
        "Zone_ClearCache()\n"
        "    for new zone info at %p\n",
        pZone ));

    //
    //  dump cache for new zone
    //      - if root zone, dump whole cache
    //
    //  DEVNOTE: new non-root zone does not require full cache dump,
    //          should be able to limit to subtree
    //

    if ( !Zone_LockForAdminUpdate( g_pCacheZone ) )
    {
        return DNS_ERROR_ZONE_LOCKED;
    }
    Zone_LoadRootHints();

    return ERROR_SUCCESS;
}


DNS_STATUS
Zone_LoadRootHints(
    VOID
    )
/*++

Routine Description:

    Read (or reread) root-hints (cache file) into database.

    Note, that this dumps cache.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PZONE_INFO  pzone;
    DNS_STATUS  status;
    BOOL        fdsRead = FALSE;
    BOOL        fileRead = FALSE;
    BOOL        bTmp;
    DWORD       dsZoneWriteFlags = 0;
    PDB_NODE    pnode;

    DNS_DEBUG( INIT, ( "Zone_LoadRootHints()\n" ));

    //
    //  if not yet created cache zone -- create
    //

    pzone = g_pRootHintsZone;
    if ( !pzone )
    {
        ASSERT( FALSE );
        status = Zone_Create(
                    & pzone,
                    DNS_ZONE_TYPE_CACHE,
                    ".",
                    0,
                    0,          //  flags
                    NULL,       //  no masters
                    FALSE,      //  file not database
                    NULL,       //  naming context
                    NULL,       //  default file name
                    0,
                    NULL,
                    NULL );     //  existing zone
        if ( status != ERROR_SUCCESS )
        {
            return status;
        }
        ASSERT( g_pRootHintsZone == pzone );
    }

    //
    //  if zone already exists
    //      - may be locked by this thread (loading after create case)
    //      - or lock it now
    //

    else if ( ! IS_ZONE_LOCKED_FOR_WRITE_BY_THREAD(pzone) )
    {
        if ( !Zone_LockForAdminUpdate( pzone ) )
        {
            DNS_DEBUG( INIT, (
                "WARNING:  unable to load root hints!\n"
                "    Root-hints zone locked by another thread\n" ));
            return DNS_ERROR_ZONE_LOCKED;
        }
    }

    ASSERT( IS_ZONE_CACHE(pzone) );

    //  zone must be locked to bring loaded database on-line

    ASSERT( IS_ZONE_LOCKED_FOR_WRITE(pzone) );

    //
    //  create cache tree
    //      - need "local" domain to check nodes for no-recursion
    //

    pzone->pLoadTreeRoot = NTree_Initialize();
    pzone->pLoadZoneRoot = pzone->pLoadTreeRoot;

    //
    //  if root authoritative -- don't need root hints
    //      - skip to tree swap\dump
    //

    if ( IS_ROOT_AUTHORITATIVE() )
    {
        DNS_DEBUG( INIT, ( "Root authoritative not loading root hints\n" ));
        status = ERROR_SUCCESS;
        goto Activate;
    }

    //
    //  load from DS or file -- make every effort
    //
    //  try DS first if DS integrated
    //      cache file first if not
    //  but in either case always try the other method
    //

    //
    //  DEVNOTE: not complete function
    //      i don't really see what this function has accomplished
    //      versus previous version;  it reorders the attempts (slightly)
    //      based on BootMethod (which can easily be done without case)
    //      but it fails to nail down the specific issues, and makes
    //      a couple of them worse
    //          -- does file override in DIRECTORY mode
    //              (apparently no way to do this now, even with explict file
    //              set in registry)
    //          -- file overrides in REGISTRY mode, do we ever write back
    //              (used to, but not now)
    //          -- on DC file override, push data into EMPTY DS zone,
    //              but do not push into full one
    //

    //
    // Load Root Hints based on current boot method
    //

    switch( SrvCfg_fBootMethod )
    {
        case BOOT_METHOD_UNINITIALIZED:
        case BOOT_METHOD_DIRECTORY:

            //
            //  Load DS zone
            //  If we loaded 0 records from the DS, that means that it may
            //  be that we just created it in our boot sequence (see srvcfgSetBootMethod).
            //  Thus, we still want to attempt loading from a file (for the first time).
            //

            status = Ds_LoadZoneFromDs( pzone, 0 );
            if ( status == ERROR_SUCCESS &&
                 pzone->iRRCount != 0 )
            {
                fdsRead = TRUE;
                break;
            }


            //
            //  Fail over to registry, but when we write back to the DS, we
            //  want to force overwrite - the zone may exist in the DS with
            //  no RRs (no children).
            //

            dsZoneWriteFlags = DNS_ZONE_LOAD_OVERWRITE_DS;
  
        case BOOT_METHOD_REGISTRY:
        case BOOT_METHOD_FILE:

            //
            // Fix file name
            //

            bTmp = FALSE;
            if ( !pzone->pszDataFile )
            {
                pzone->pwsDataFile = DNS_DEFAULT_CACHE_FILE_NAME;
                bTmp = TRUE;
            }

            //
            // Attempt file load
            //

            status = File_LoadDatabaseFile(
                        pzone,
                        NULL,       //  default file name
                        NULL,       //  no parent parsing context
                        NULL        //  default to zone origin
                        );
            if ( status == ERROR_SUCCESS )
            {
#if 0
                //
                //  DEVNOTE: you just clobbered the pszDataFile name if it
                //      wasn't the default, (which it's never going to be
                //      until Zone_Create() fixed) you end up with the file
                //      loaded under one name but using another (plus, of
                //      course, the minor mem leak)
                //
                //      the proper way to handle these situations is a local
                //      variable.  just set it to the file, if it doesn't
                //      exist, reset it -- simple
                //

                pzone->pwsDataFile = Dns_StringCopyAllocate_W(
                                        DNS_DEFAULT_CACHE_FILE_NAME,
                                        0 );
#endif
                if ( bTmp )
                {
                    pzone->pwsDataFile = Dns_StringCopyAllocate_W(
                                            DNS_DEFAULT_CACHE_FILE_NAME,
                                            0 );
                }

                fileRead = TRUE;
                break;
            }

            if ( bTmp )
            {
                //
                // Used default name.
                //

                pzone->pwsDataFile = NULL;
            }

            status = GetLastError() ? GetLastError() : status;

            if ( SrvCfg_fBootMethod == BOOT_METHOD_REGISTRY )
            {
                //
                // Not from fail over & not FILE. Thus attempt DS.
                //
                // Load DS zone
                // If we loaded 0 records from the DS, that means that it may
                // be that we just created it in our boot sequence (see srvcfgSetBootMethod).
                // Thus, we still want to attempt loading from a file (for the first time).
                //

                status = Ds_LoadZoneFromDs( pzone, 0 );
                if ( status == ERROR_SUCCESS &&
                     pzone->iRRCount != 0 )
                {
                    //
                    // Successfull load of DS zone w/ more then 0 records
                    //

                    fdsRead = TRUE;
                    break;
                }
            }
            break;

        default:

            DNS_DEBUG( DS, (
               "ERROR: INVALID Boot Method. Logic Error\n" ));
            ASSERT( FALSE );
            status =  ERROR_INVALID_PARAMETER;
            break;
    }

    //
    //  load failure -- log if appropriate
    //

    if ( status != ERROR_SUCCESS )
    {
        if ( SrvCfg_fNoRecursion ||
            ( SrvCfg_aipForwarders && SrvCfg_aipForwarders->AddrCount ) ||
            SrvCfg_fStarted )
        {
            DNS_DEBUG( INIT, (
                "Skipping load failure on cache\n"
                "    Either have forwarders or NOT recursing or post-startup\n"
                "    (example:  load attempt after root-zone delete.)\n" ));
            status = ERROR_SUCCESS;
        }
        else
        {
            DNS_PRINT((
                "ERROR:  Not root authoritative and no forwarders and no cache file specified\n" ));
            DNS_LOG_EVENT(
                DNS_EVENT_NO_CACHE_FILE_SPECIFIED,
                0,
                NULL,
                NULL,
                status );
        }

        goto Activate;
    }

    //
    //  DEVNOTE: on reload failure, could copy root-hints from activated cache tree
    //


Activate:

    //
    //  bring on-line
    //

    Dbase_LockDatabase();
    Zone_ActivateLoadedZone( pzone );
    Dbase_UnlockDatabase();

    //
    //  If the DNS server is DS-integrated, boots from DS and there were
    //  no root hints in the directory we need to write the roots hints to
    //  the DS. However, this should only be done if the root hints are
    //  dirty. If this DC has been promoted but not fully synced, we must
    //  be careful not to stamp default root hints in the directory.
    //

    if ( SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY &&
         !fdsRead &&
         fileRead &&
         Ds_IsDsServer() &&
         Zone_VerifyRootHintsBeforeWrite( pzone ) &&
         ( IS_ZONE_DIRTY( pzone ) ||
           IS_ZONE_NS_DIRTY( pzone ) ) )
    {
        DNS_STATUS tempStatus;

        DNS_DEBUG( INIT, (
            "Attempt to write back root-hints to DS\n" ));

        //  write is overwrite, since we just failed to load from DS
        //  overwrite causes delete, so isn't necessarily safe

        tempStatus = Ds_WriteZoneToDs(
                        g_pRootHintsZone,
                        dsZoneWriteFlags );

        if ( tempStatus == ERROR_SUCCESS )
        {
            g_pRootHintsZone->fDsIntegrated = TRUE;
            g_pRootHintsZone->fDirty = FALSE;
            CLEAR_ROOTHINTS_DS_DIRTY( g_pRootHintsZone );
        }
        ELSE
        {
            DNS_DEBUG ( DS, (
                "Error <%lu,%lu>: Failed to write RootHints to the DS\n",
                tempStatus, status ));
            ASSERT ( FALSE );
        }
    }
    
    //
    //  Pre-populate fixed cache records.
    //

    pnode = Lookup_ZoneNodeFromDotted(
                        pzone,
                        "localhost",
                        0,
                        LOOKUP_FQDN | LOOKUP_CREATE,
                        NULL,       //  closest node
                        NULL );     //  status
    ASSERT( pnode );
    if ( pnode )
    {
        PDB_RECORD      prr;
        
        prr = RR_CreateARecord( NET_ORDER_LOOPBACK, 0, MEMTAG_RECORD_AUTO );
        DNS_DEBUG( INIT, ( "Unable to add localhost RR to cache node\n" ));
        if ( prr )
        {
            DNS_STATUS  st;
            
            st = RR_AddToNode( pzone, pnode, prr );
            ASSERT( st == ERROR_SUCCESS );
            if ( st == ERROR_SUCCESS )
            {
                SET_FIXED_TTL_RR( prr );
                SET_RR_RANK( prr, RANK_CACHE_A_ANSWER );
                prr->dwTtlSeconds = htonl( 600 );
                SET_NODE_FORCE_AUTH( pnode );
            }
            else
            {
                DNS_DEBUG( INIT, ( "Unable to add localhost RR to cache node\n" ));
                RR_Free( prr );
            }
        }
        else
        {
            DNS_DEBUG( INIT, ( "Unable to create localhost cache resource record\n" ));
        }
    }
    else
    {
        DNS_DEBUG( INIT, ( "Unable to create localhost cache node\n" ));
    }

    //  unlock root-hints "zone"

    Zone_UnlockAfterAdminUpdate( pzone );

    return status;
}



BOOL
Zone_VerifyRootHintsBeforeWrite(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Verify can do cache write back.
    Note this entails:
        1) Cache auto-update supported.
        2) Root name servers with writable A records exist.

Arguments:

    pZone -- ptr to zone;  we have this parameter so may write
        root hints out of a root zone that's being deleted

Return Value:

    TRUE if cache update should proceed.
    FALSE otherwise.

--*/
{
    PDB_NODE    pnodeRoot;  // root node
    PDB_RECORD  prrNS;      // NS resource record
    PDB_NODE    pnodeNS;    // name server node

    //
    //  verify at least one root NS with A available
    //

    pnodeRoot = pZone->pTreeRoot;
    if ( !pnodeRoot )
    {
        return FALSE;
    }

    Dbase_LockDatabase();
    prrNS = NULL;

    while ( 1 )
    {
        //  get next NS

        prrNS = RR_FindNextRecord(
                    pnodeRoot,
                    DNS_TYPE_NS,
                    prrNS,
                    0 );
        if ( !prrNS )
        {
            DNS_PRINT(( "ERROR:  no root NS with A records available\n" ));
            Dbase_UnlockDatabase();
            return FALSE;
        }

        //  find A record for this NS
        //  if no A records, loop back and try next NS

        pnodeNS = Lookup_FindGlueNodeForDbaseName(
                        NULL,       // cache zone
                        & prrNS->Data.NS.nameTarget );
        if ( !pnodeNS )
        {
            continue;
        }

        if ( ! RR_FindNextRecord(
                    pnodeNS,
                    DNS_TYPE_A,
                    NULL,
                    0 ) )
        {
            Dbg_DbaseNode(
                "WARNING:  no A records for root NS node",
                pnodeNS );
            continue;
        }
        break;
    }

    //  found at least one NS, with at least one A record

    DNS_DEBUG( SHUTDOWN, ( "Verified cache update is allowed\n" ));
    Dbase_UnlockDatabase();
    return TRUE;
}



DNS_STATUS
Zone_WriteBackRootHints(
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Write back root hints to file or DS.

Arguments:

    fForce -- write even if not dirty

Return Value:

    ERROR_SUCCESS if root-hints written or not dirty.
    ErrorCode on failure.

--*/
{
    PZONE_INFO pzone = NULL;
    DNS_STATUS status = ERROR_SUCCESS;

    DNS_DEBUG( RPC, ( "Zone_WriteBackRootHints( fForce=%d )\n", fForce ));

    //
    //  find zone
    //
    //  could write root hints from authoritative zone
    //  however, DS partners should just host auth root zone
    //

    pzone = g_pRootHintsZone;
    if ( !pzone || IS_ROOT_AUTHORITATIVE() )
    {
        DNS_DEBUG( INIT, (
            "No root-hints to write\n"
            "    Server is %s root authoritative\n",
            IS_ROOT_AUTHORITATIVE() ? "" : "NOT"
            ));
        return ERROR_CANTWRITE;
    }

    //
    //  DS-integrated root hints: if the root hints were loaded from
    //  the legacy partition but the domain mode is Whistler and there
    //  is a built-in domain partition we should write them back to
    //  the built-in domain partition.
    //

    if ( IS_ZONE_DSINTEGRATED( pzone ) &&
         IS_WHISTLER_DOMAIN() &&
         g_pDomainDp &&
         IS_DP_LEGACY( ZONE_DP( pzone ) ) &&
         pzone->pDpInfo != g_pDomainDp )
    {
        //  Switch root hints to the built-in domain directory partition.

        Ds_SetZoneDp( pzone, g_pDomainDp, FALSE );
        fForce = TRUE;

        //
        //  DEVNOTE: currently this leaves the original root hints
        //  orphaned. My thinking is we should leave them in place as
        //  a backup for any DNS server that does not have access to
        //  the built-in domain partition, but that is a little weak.
        //
    }

    if ( !pzone->fDirty && !fForce )
    {
        DNS_DEBUG( INIT, (
            "Root-hints not dirty, and force-write not set\n"
            "    Skipping root-hint write\n" ));
        return ERROR_SUCCESS;
    }

    //
    //  never write empty root hints
    //      - always better to live with what we've got
    //      - clear dirty flag so not repetitively making this test
    //

    if ( ! Zone_VerifyRootHintsBeforeWrite( pzone ) )
    {
        DNS_DEBUG( INIT, (
            "No Root-hints to write back!\n"
            "    Skipping write\n" ));
        pzone->fDirty = FALSE;
        return ERROR_SUCCESS;
    }

    //
    //  choose DS or file write based on boot method
    //
    //  DEVNOTE: write root-hints to file even in DS case?
    //      if loaded originally from file and converted, nice
    //      to write back to file
    //
    //  DEVNOTE: some way of introducing whole new root-hints file
    //

    switch ( SrvCfg_fBootMethod )
    {
        case BOOT_METHOD_UNINITIALIZED:
        case BOOT_METHOD_DIRECTORY:

            //  Write to DS
            //      - must be "DS-dirty" as regular dirty flag
            //      can be set by update FROM DS
            //      - take update lock, to lock out DS-poll while write

            if ( !fForce && !IS_ROOTHINTS_DS_DIRTY(pzone) )
            {
                DNS_DEBUG( INIT, (
                    "RootHints not DS dirty, skipping write!\n" ));
                break;
            }
            if ( ! Zone_LockForDsUpdate(pzone) )
            {
                DNS_DEBUG( INIT, (
                    "Unable to lock RootHints for DS write -- skipping write!\n" ));
                break;
            }

            status = Ds_WriteZoneToDs(
                        pzone,
                        DNS_ZONE_LOAD_OVERWRITE_DS      // write current in memory copy
                        );

            if ( status == ERROR_SUCCESS )
            {
                // Succeeded-- we're ds integrated.
                pzone->fDsIntegrated = TRUE;
                pzone->fDirty = FALSE;
                CLEAR_ROOTHINTS_DS_DIRTY( pzone );
                Zone_UnlockAfterDsUpdate(pzone);
                break;
            }

            Zone_UnlockAfterDsUpdate(pzone);

            //
            //  Fail over to file write
            //

        case BOOT_METHOD_REGISTRY:
        case BOOT_METHOD_FILE:

            if ( !pzone->pwsDataFile )
            {
                pzone->pwsDataFile = DNS_DEFAULT_CACHE_FILE_NAME;
            }
            if ( !File_WriteZoneToFile( pzone, NULL, 0 ) )
            {
                status = ERROR_CANTWRITE;
            }
            else
            {
                //
                // Commit file name to zone & set error code to success
                //

                status = ERROR_SUCCESS;
                pzone->pwsDataFile = Dns_StringCopyAllocate_W(
                                        DNS_DEFAULT_CACHE_FILE_NAME,
                                        0 );
            }
            break;

        default:
            DNS_DEBUG( DS, (
               "ERROR: INVALID Boot Method. Logic Error\n" ));
            ASSERT ( FALSE );
            status =  ERROR_INVALID_PARAMETER;
            break;
    }

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG ( DS, (
           "Error <%lu>: Failed to write back root hints\n",
           status ));
    }

    return status;
}



DNS_STATUS
Zone_SelfTestCheck(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Perform checks on the basic sanity of a zone. Call this function
    after the zone has been loaded and activated.

Arguments:

    pZone - zone to check

Return Value:

    ERROR_SUCCESS if successful
    Error code if problem found

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_RECORD      prr;

    if ( !pZone || IS_ZONE_INACTIVE( pZone ) || pZone->fSelfTested )
    {
        goto Done;
    }

    //
    //  Check that the master server in the zone's SOA is a DNS name
    //  that is present locally on this server. If the master server
    //  fails to resolve, DNS clients will have problems finding a
    //  target server for updates.
    //

    if ( SrvCfg_dwSelfTestFlag & DNS_SELFTEST_ZONE_SOA &&
         IS_ZONE_PRIMARY( pZone ) &&
         !pZone->fAutoCreated &&
         pZone->fAllowUpdate &&
         ( prr = pZone->pSoaRR ) != NULL )
    {
        PDB_NODE    pnode;
        PDB_NODE    pnodeDelegation = NULL;
        
        pnode = Lookup_NsHostNode(
                    &prr->Data.SOA.namePrimaryServer,
                    0,
                    NULL,
                    &pnodeDelegation );

        //
        //  DEVNOTE: IPv6 - check for any A type here.
        //

        if ( !pnode ||
             !RR_FindNextRecord( pnode, DNS_TYPE_A, NULL, 0 ) )
        {
            PVOID   parg = pZone->pwsZoneName;

            DNS_LOG_EVENT(
                DNS_EVENT_ZONE_BAD_PRIMARY_SERVER,
                1,
                &parg,
                EVENTARG_ALL_UNICODE,
                0 );
        }
    }

    Done:

    if ( pZone )
    {
        pZone->fSelfTested = TRUE;
    }

    return status;
}   //  Zone_SelfTestCheck



//
//  Create default zone records
//
//  These are used extensively with CreateNewPrimary
//  Shouldn't need special code.
//

PDB_RECORD
buildLocalHostARecords(
    IN      DWORD           dwTtl
    )
/*++

Routine Description:

    Build list of A records for this host.

    Only build records corresponding to listening IPs.

Arguments:

    dwTtl -- default TTL for zone.

Return Value:

    A record list for this DNS server.
    NULL on error.

--*/
{
    PDB_RECORD      prr;
    DWORD           i;
    PDNS_ADDR_ARRAY parrayIp;
    DNS_LIST        rrList;


    DNS_DEBUG( INIT, (
        "buildLocalHostARecords()\n" ));

    //
    //  if specific publish list use it
    //
    //  DEVNOTE: should we cross check against bound addrs?
    //
    //  note, copy pointer so have list even if list changes
    //      during run time
    //

    parrayIp = SrvCfg_aipPublishAddrs;
    if ( !parrayIp )
    {
        parrayIp = g_BoundAddrs;
        if ( !parrayIp )
        {
            return NULL;
        }
    }

    //
    //  create host A records
    //
    //  server's IP address is data
    //  if listen addresses use those, otherwise use all server addresses
    //

    DNS_LIST_INIT( &rrList );

    for ( i = 0; i < parrayIp->AddrCount; i++ )
    {
        PDNS_ADDR   pdnsaddr = &parrayIp->AddrArray[ i ];
        IP_ADDRESS  ip;
        
        if ( !DnsAddr_IsIp4( pdnsaddr ) )
        {
            continue;   //  FIXIPV6
        }
        
        ip = DnsAddr_GetIp4( pdnsaddr );

        if ( !SrvCfg_fPublishAutonet && DNS_IS_AUTONET_IP( ip ) )
        {
            continue;
        }

        prr = RR_CreateARecord(
                    ip,
                    dwTtl,
                    MEMTAG_RECORD_AUTO );
        IF_NOMEM( !prr )
        {
            CHAR    szaddr[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

            DnsAddr_WriteIpString_A( szaddr, pdnsaddr );
            DNS_PRINT((
                "ERROR:  Unable to create A record for local IP %s\n",
                szaddr ));
            break;
        }
        SET_ZONE_TTL_RR(prr);

        DNS_LIST_ADD( &rrList, prr );
    }

    return ( PDB_RECORD ) rrList.pFirst;
}



DNS_STATUS
createDefaultNsHostARecords(
    IN OUT  PZONE_INFO      pZone,
    IN      PDB_NAME        pHostName
    )
/*++

Routine Description:

    Create default host A records for this machine.

    Note, assumes pHostNode is valid ptr to a domain node, that
    corresponds to this servers host name.  No checking is done.

    This routine exists to service the default SOA and NS creation
    routines.

Arguments:

    pZone -- zone to create NS record for

    pHostNode -- ptr to domain node for this server

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_RPC_RECORD     precord;
    PDB_RECORD          prr;
    PDB_NODE            pnodeHost;
    DWORD               i;
    DWORD               lookupFlag;
    PDNS_ADDR_ARRAY     parrayIp;

    DNS_DEBUG( INIT, (
        "createDefaultNsHostARecords()\n"
        "    zone = %s\n",
        pZone->pszZoneName ));

    IF_DEBUG( INIT )
    {
        Dbg_DbaseName(
            "NsHost name to be created:",
            pHostName,
            "\n" );
    }

    //
    //  find or create if within zone
    //
    //      - if loading, try in load zone, otherwise in current zone
    //

    lookupFlag = LOOKUP_NAME_FQDN | LOOKUP_WITHIN_ZONE;

    if ( IS_ZONE_LOADING(pZone) )
    {
        lookupFlag |= LOOKUP_LOAD;
    }

    pnodeHost = Lookup_ZoneNode(
                    pZone,
                    pHostName->RawName,
                    NULL,               // no message
                    NULL,               // no lookup name
                    lookupFlag,
                    NULL,               // create but only WITHIN zone
                    NULL );             // following node ptr

    if ( !pnodeHost )
    {
        DNS_DEBUG( INIT, (
            "Skipping NS host A record create -- node outside zone\n" ));
        return ERROR_SUCCESS;
    }

    //
    //  if the NS host lies WITHIN the zone being created
    //      AND
    //  no A records already exist for the host, then create A
    //
    //  DEVNOTE: do we need to do outside zone, or underneath zone glue?
    //      it is very nice to have default records even if outside zone
    //      underneath is even more useful as if delegated zone on another
    //      server, really does require recursion to reach
    //

    if ( RR_FindNextRecord(
                pnodeHost,
                DNS_TYPE_A,
                NULL,
                0 ) )
    {
        return ERROR_SUCCESS;
    }

    parrayIp = g_BoundAddrs;
    if ( !parrayIp )
    {
        return ERROR_SUCCESS;
    }

    //
    //  create host A records
    //
    //  server's IP address is data
    //  if listen addresses use those, otherwise use all server addresses
    //

    for ( i=0; i < parrayIp->AddrCount; i++ )
    {
        PDNS_ADDR   pdnsaddr = &parrayIp->AddrArray[ i ];
        IP_ADDRESS  ip;
        
        if ( !DnsAddr_IsIp4( pdnsaddr ) )
        {
            continue;       //  FIXIPV6
        }
        ip = DnsAddr_GetIp4( pdnsaddr );
        
        prr = RR_CreateARecord(
                    ip,
                    pZone->dwDefaultTtl,
                    MEMTAG_RECORD_AUTO );
        IF_NOMEM( !prr )
        {
            DNS_PRINT((
                "ERROR:  Unable to create A record for %s,\n"
                "    while auto-creating records for zone %s\n",
                DNSADDR_STRING( pdnsaddr ),
                pZone ));
            status = DNS_ERROR_NO_MEMORY;
            break;
        }

        SET_ZONE_TTL_RR(prr);

        status = RR_AddToNode(
                    pZone,
                    pnodeHost,
                    prr );
        if ( status != ERROR_SUCCESS )
        {
            RR_Free( prr );
        }
    }

    return status;
}



DNS_STATUS
Zone_CreateDefaultSoa(
    OUT     PZONE_INFO      pZone,
    IN      LPSTR           pszAdminEmailName
    )
/*++

Routine Description:

    Create new primary zone, including
        - zone info (optional)
        - SOA (default values)
        - NS (for this server)

    For use by admin tool or auto-create reverse zone.

Arguments:

    ppZone -- addr of zone ptr;  if zone ptr NULL zone is created
        if zone ptr MUST be existing zone
        or

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_RECORD      prr;

    DNS_DEBUG( INIT, (
        "Zone_CreateDefaultSoa()\n"
        "    pszZoneName      = %s\n"
        "    pszAdminEmail    = %s\n",
        pZone->pszZoneName,
        pszAdminEmailName ));

    //
    //  create SOA, no existing SOA, so default fixed fields
    //

    prr = RR_CreateSoa(
                NULL,               // no existing SOA
                NULL,               // no admin name in dbase form
                pszAdminEmailName );
    if ( !prr )
    {
        ASSERT( FALSE );
        status = DNS_ERROR_INVALID_DATA;
        goto Failed;
    }

    //
    //  save default TTL for setting NEW default records
    //

    pZone->dwDefaultTtl = prr->Data.SOA.dwMinimumTtl;
    pZone->dwDefaultTtlHostOrder = ntohl( pZone->dwDefaultTtl );

    //
    //  enlist SOA
    //

    status = RR_AddToNode(
                pZone,
                pZone->pZoneRoot ? pZone->pZoneRoot : pZone->pLoadZoneRoot,
                prr );
    if ( status != ERROR_SUCCESS )
    {
        RR_Free( prr );
    }

    //
    //  make sure have A records at server's hostname
    //

    status = createDefaultNsHostARecords(
                pZone,
                & prr->Data.SOA.namePrimaryServer );
Failed:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Failed to create default SOA record (and host A) for zone!\n"
            "    zone = %s\n",
            pZone->pszZoneName ));
    }
    return status;
}



DNS_STATUS
Zone_CreateDefaultNs(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Create default NS record and NS host A record for zone.

Arguments:

    pZone -- zone to create NS record for

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PCHAR           pszserverName;
    PDB_RECORD      prr = NULL;
    CHAR            chSrvNameBuf[ DNS_MAX_NAME_LENGTH ];

    DNS_DEBUG( INIT, (
        "Zone_CreateDefaultNs()\n"
        "    pszZoneName  = %s\n",
        pZone->pszZoneName ));

    //
    //  Do nothing if auto NS creation is turned off for this zone.
    //

    if ( pZone->fDisableAutoCreateLocalNS )
    {
        DNS_DEBUG( INIT, (
            "Zone_CreateDefaultNs: doing nothing for zone %s\n",
            pZone->pszZoneName ));
        return ERROR_SUCCESS;
    }

    //
    //  create NS record for server name
    //

    prr = RR_CreatePtr(
                NULL,                   // no dbase name
                SrvCfg_pszServerName,
                DNS_TYPE_NS,
                pZone->dwDefaultTtl,
                MEMTAG_RECORD_AUTO );
    if ( !prr )
    {
        ASSERT( FALSE );
        status = DNS_ERROR_INVALID_DATA;
        goto Failed;
    }

    //
    //  enlist NS
    //

    status = RR_AddToNode(
                pZone,
                pZone->pZoneRoot ? pZone->pZoneRoot : pZone->pLoadZoneRoot,
                prr );
    if ( status != ERROR_SUCCESS )
    {
        RR_Free( prr );
        goto Failed;
    }

    //
    //  make sure have A records at server's hostname
    //

    status = createDefaultNsHostARecords(
                pZone,
                & prr->Data.NS.nameTarget );

Failed:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Failed to create default NS record (and host A) for zone!\n"
            "    zone = %s\n",
            pZone->pszZoneName ));
    }
    return status;
}



DNS_STATUS
Zone_CreateLocalHostPtrRecord(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Create local host PTR record.
    This is used for default creation of 127.in-addr.arpa zone.

Arguments:

    pZone -- zone to create NS record for

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_NODE        pnodeLoopback;
    PDB_RECORD      prr;

    DNS_DEBUG( INIT, (
        "Zone_CreateLocalHostPtrRecord()\n"
        "    pszZoneName  = %s\n",
        pZone->pszZoneName ));


    //
    //  for loopback zone, create loopback record
    //      => 127.0.0.1 pointing to "localhost"
    //

    if ( _stricmp( pZone->pszZoneName, "127.in-addr.arpa" ) )
    {
        ASSERT( FALSE );
        status = DNS_ERROR_INVALID_DATA;
        goto Failed;
    }

    //
    //  create loopback name
    //

    pnodeLoopback = Lookup_ZoneNodeFromDotted(
                        pZone,
                        "1.0.0",    // 1.0.0.127.in-addr.arpa, relative to zone name
                        0,
                        LOOKUP_NAME_RELATIVE | LOOKUP_LOAD,
                        NULL,       // create node
                        & status );
    if ( !pnodeLoopback )
    {
        DNS_PRINT((
            "ERROR: failed to create loopback address node\n"
            "    status = %p\n",
            status ));
        goto Failed;
    }

    //  create PTR record

    prr = RR_CreatePtr(
                NULL,           // no dbase name
                "localhost.",
                DNS_TYPE_PTR,
                pZone->dwDefaultTtl,
                MEMTAG_RECORD_AUTO );
    IF_NOMEM( !prr )
    {
        ASSERT( FALSE );
        return DNS_ERROR_NO_MEMORY;
    }

    //
    //  enlist PTR
    //

    status = RR_AddToNode(
                pZone,
                pnodeLoopback,
                prr
                );
    if ( status != ERROR_SUCCESS )
    {
        RR_Free( prr );
        ASSERT( FALSE );
        goto Failed;
    }

Failed:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Failed to create default \"localhost\" record!\n"
            "    zone = %s\n",
            pZone->pszZoneName ));
    }
    return status;
}



BOOL
isSoaPrimaryGivenServer(
    IN      LPSTR           pszServer,
    IN      PZONE_INFO      pZone,
    IN      PDB_RECORD      pSoaRR
    )
/*++

Routine Description:

    Checks if SOA primary is given name.

Arguments:

    pszServer -- server name to match

    pZone -- zone to check

    pSoaRR -- SOA to check if not (yet) zone SOA

Return Value:

    TRUE if SOA primary name is given name.
    FALSE otherwise.

--*/
{
    PDB_RECORD  prrSoa = pSoaRR;
    DB_NAME     namePrimary;
    DNS_STATUS  status;

    //
    //  zone SOA if not given SOA
    //

    if ( !prrSoa )
    {
        prrSoa = pZone->pSoaRR;
        ASSERT( prrSoa );
    }

    //
    //  read given name into dbase name format
    //

    status = Name_ConvertFileNameToCountName(
                & namePrimary,
                pszServer,
                0 );
    if ( status == DNS_ERROR_INVALID_NAME )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    //
    //  compare names
    //

    return Name_IsEqualCountNames(
                & namePrimary,
                & prrSoa->Data.SOA.namePrimaryServer );
}



VOID
Zone_SetSoaPrimaryToThisServer(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Sets the primary in SOA to this server.

    Note:  this does NOT do an update, but directly
        munges the database.

Arguments:

    pZone -- zone to make primary on this server

Return Value:

    None.

--*/
{
    PDB_RECORD  prr;
    DNS_STATUS  status;
    UPDATE      update;

    DNS_DEBUG( INIT, (
        "setSoaPrimaryToThisServer( %s )\n",
        pZone->pszZoneName ));

    //
    //  this is only interesting for PRIMARY, non-auto-created zones
    //
    //  DEVNOTE: if allow PnP server name change
    //      then this would be interesting for AutoCreated zones too
    //

    if ( !IS_ZONE_PRIMARY(pZone) || pZone->fAutoCreated )
    {
        DNS_PRINT((
            "ERROR:  setSoaPrimaryToThisServer() for zone (%s)\n",
            pZone->pszZoneName ));
        return;
    }

    //
    //  if SOA primary already pointing at this server -- done
    //

    if ( isSoaPrimaryGivenServer(
            SrvCfg_pszServerName,
            pZone,
            NULL ) )
    {
        return;
    }

    //
    //  create SOA defaulting primary name
    //

    prr = RR_CreateSoa(
                pZone->pSoaRR,
                NULL,       //  default primary
                NULL        //  default admin
                );
    if ( !prr )
    {
        //  log failure?
        ASSERT( FALSE );
        return;
    }

    //
    //  put new SOA in RR list
    //      - note if already exists, record cleanup done in RR_UpdateAdd()
    //
    //  note:  this is NOT done as formal update so that DS primaries
    //  do not repeatedly ping-pong the SOA record data
    //

    update.pDeleteRR = NULL;

    status = RR_UpdateAdd(
                pZone,
                pZone->pZoneRoot,
                prr,        // new SOA
                & update,   // dummy to recv deleted SOA record
                0           // no flag
                );
    if ( status != ERROR_SUCCESS )
    {
        if ( status != DNS_ERROR_RECORD_ALREADY_EXISTS )
        {
            DNS_PRINT((
                "ERROR:  SOA replace at zone %s failed\n"
                "    pZone = %p\n"
                "    pZoneRoot = %p\n",
                pZone->pszZoneName,
                pZone,
                pZone->pZoneRoot ));
            ASSERT( FALSE );
        }
        return;
    }

    //
    //  attach new SOA to zone
    //  free previous SOA -- with timeout
    //

    DNS_DEBUG( UPDATE, (
        "Replacing zone %s SOA with one at %p using local primary\n",
        pZone->pszZoneName,
        prr ));

    if ( update.pAddRR != prr )
    {
        ASSERT( FALSE );
        return;
    }
    ASSERT( update.pDeleteRR );

    pZone->pSoaRR = prr;

    RR_Free( update.pDeleteRR );

    pZone->fDirty = TRUE;
}



VOID
setDefaultSoaValues(
    IN      PZONE_INFO      pZone,
    IN      PDB_RECORD      pSoaRR      OPTIONAL
    )
/*++

Routine Description:

    Set default SOA values.

Arguments:

    pZone -- zone to check

    pSoaRR -- SOA record;  if NULL use current zone SOA

Return Value:

    None

--*/
{
    DWORD   serialNo = 0;

    DNS_DEBUG( INIT, (
        "setDefaultSoaValues( %s )\n",
        pZone->pszZoneName ));

    ASSERT( IS_ZONE_PRIMARY(pZone) );

    if ( !pSoaRR )
    {
        pSoaRR = pZone->pSoaRR;
        if ( !pSoaRR )
        {
            ASSERT( FALSE );
            return;
        }
    }

    //
    //  check if have default to force
    //

    if ( SrvCfg_dwForceSoaSerial     ||
         SrvCfg_dwForceSoaRefresh    ||
         SrvCfg_dwForceSoaRetry      ||
         SrvCfg_dwForceSoaExpire     ||
         SrvCfg_dwForceSoaMinimumTtl )
    {
        if ( SrvCfg_dwForceSoaSerial )
        {
            serialNo = SrvCfg_dwForceSoaSerial;
            INLINE_DWORD_FLIP( pSoaRR->Data.SOA.dwSerialNo, serialNo );
        }
        if ( SrvCfg_dwForceSoaRefresh )
        {
            INLINE_DWORD_FLIP( pSoaRR->Data.SOA.dwRefresh, SrvCfg_dwForceSoaRefresh );
        }
        if ( SrvCfg_dwForceSoaRetry )
        {
            INLINE_DWORD_FLIP( pSoaRR->Data.SOA.dwRetry, SrvCfg_dwForceSoaRetry );
        }
        if ( SrvCfg_dwForceSoaExpire )
        {
            INLINE_DWORD_FLIP( pSoaRR->Data.SOA.dwExpire, SrvCfg_dwForceSoaExpire );
        }
        if ( SrvCfg_dwForceSoaMinimumTtl )
        {
            INLINE_DWORD_FLIP( pSoaRR->Data.SOA.dwMinimumTtl, SrvCfg_dwForceSoaMinimumTtl );
        }
        pZone->fDirty = TRUE;
        pZone->fRootDirty = TRUE;

        if ( serialNo )
        {
            pZone->dwSerialNo = serialNo;
            pZone->dwLoadSerialNo = serialNo;
        }
    }
}



BOOLEAN
Zone_SetAutoCreateLocalNS(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    This routine decides if the local server name should be automagically 
    added to the NS list for a particular zone.

    The decision is made like this:

    Inputs:
        DisableAutoNS - server level flag disabling auto NS RR creation
        AllowNSList - zone level list of server IPs allowed to auto NS create

    If DisableAutoNS is TRUE, no NS RR will ever be auto created.

    If the zone's AllowNSList is empty, any server can add themselves to
    the NS list, otherwise there must be an intersection between the server's
    IP address list and the AllowNSList for the zone.

Arguments:

    pZone -- zone to check

Return Value:

    TRUE if we desire the local server name to be added as an NS for the zone,
    note that the zone's flag is set as well.

--*/
{
    BOOLEAN     fAddLocalServerAsNS = FALSE;

    ASSERT( pZone );

    if ( !IS_ZONE_DSINTEGRATED( pZone ) ||
        !SrvCfg_fNoAutoNSRecords &&
        ( !pZone->aipAutoCreateNS ||
            pZone->aipAutoCreateNS->AddrCount == 0 ||
            DnsAddrArray_IsIntersection(
                        pZone->aipAutoCreateNS,
                        g_ServerIp4Addrs,
                        DNSADDR_MATCH_IP ) ) )
    {
        fAddLocalServerAsNS = TRUE;
    }
    DNS_DEBUG( INIT, (
        "Zone_SetAutoCreateLocalNS( %s ) = %d\n",
        pZone->pszZoneName,
        fAddLocalServerAsNS ));

    pZone->fDisableAutoCreateLocalNS = !fAddLocalServerAsNS;
    
    return fAddLocalServerAsNS;
}   //  Zone_SetAutoCreateLocalNS



PUPDATE_LIST
checkAndFixDefaultZoneRecords(
    IN      PZONE_INFO      pZone,
    IN      BOOL            fPnP
    )
/*++

Routine Description:

    Check for and fix up default zone records.

Arguments:

    pZone -- zone to check

    fPnP -- called as a result of PnP

Return Value:

    Ptr to update list to execute, if updates exist.
    NULL if no updates necessary, or error.

--*/
{
    PDB_RECORD      prr;
    PDB_NODE        pnodeNewHostname;
    PDB_NODE        pnodeOldHostname;
    UPDATE_LIST     updateList;
    PUPDATE_LIST    pupdateList = NULL;
    PDB_NODE        pzoneRoot = pZone->pZoneRoot;

    DNS_DEBUG( INIT, (
        "checkAndFixDefaultZoneRecords( %s )\n",
        pZone->pszZoneName ));

    if ( !pzoneRoot )
    {
        return NULL;
    }

    //
    //  if bogus server name -- no auto-config desirable
    //

    if ( g_ServerDbaseName.LabelCount <= 1 )
    {
        DNS_DEBUG( INIT, (
            "Skipping auto-config on zone %S -- bogus server name %s\n",
            pZone->pwsZoneName,
            SrvCfg_pszServerName ));
    }

    //
    //  If the zone is file-backed and the AutoConfigFileZones
    //  key allows it, update the SOA with default values.
    //

    if ( !IS_ZONE_PRIMARY( pZone ) )
    {
        ASSERT( FALSE );
        return NULL;
    }

    if ( !pZone->fDsIntegrated && !pZone->dwDcPromoConvert )
    {
        if ( ( pZone->fAllowUpdate ?
                    ZONE_AUTO_CONFIG_UPDATE :
                    ZONE_AUTO_CONFIG_STATIC ) &
                SrvCfg_fAutoConfigFileZones )
        {
            DNS_DEBUG( INIT, (
                "Auto-config zone %S\n",
                pZone->pwsZoneName ));

            //  Drop through and do actual update work below.
        }
        else
        {
            //
            //  Skip auto-config but if this is not a PnP event set SOA 
            //  defaults (numeric fields only) even though update is turned 
            //  off.
            //

            DNS_DEBUG( INIT, (
                "Skip auto-config on zone %s\n",
                pZone->pszZoneName ));

            if ( !fPnP )
            {
                setDefaultSoaValues( pZone, NULL );
            }
            return NULL;
        }
    }

    //  init update list
    //  will allocate a copy, only if build updates

    pupdateList = &updateList;

    Up_InitUpdateList( pupdateList );

    //
    //  two main call paths
    //      - zone load
    //      - PnP change
    //
    //  three scenarios
    //  on zone load:
    //
    //      1) primary server NAME change
    //          - fix SOA
    //          - fix NS, delete old, add new
    //          - tear down old NS host
    //          - create new NS with current listen IPs
    //
    //      2) replica record creation
    //          - build NS
    //          - create new NS with current listen IPs
    //
    //  on PnP:
    //
    //      3) IP change
    //          - modify A records at host to reflect current listen list
    //

    if ( fPnP )
    {
        goto IpChange;
    }

    //
    //  Create NS record if this server is supposed to publish itself
    //  as an NS for this zone. If not, delete NS record for this server.
    //
    //  DEVNOTE: should optimize by testing that not already there
    //  DEVNOTE: doing for all zones?
    //  DEVNOTE: could have some sort of agressive configuration key
    //

    //  if ( pZone->fDsIntegrated || SrvCfg_pszPreviousServerName )

    prr = RR_CreatePtr(
                NULL,                   // no dbase name
                SrvCfg_pszServerName,
                DNS_TYPE_NS,
                pZone->dwDefaultTtl,
                MEMTAG_RECORD_AUTO );
    if ( !prr )
    {
        goto Failed;
    }

    Up_CreateAppendUpdate(
        pupdateList,
        pzoneRoot,
        pZone->fDisableAutoCreateLocalNS ? NULL : prr,      //  add RR
        0,                                                  //  delete type
        pZone->fDisableAutoCreateLocalNS ? prr: NULL );     //  delete RR

    //
    //  have old name, clean up any remaining old info
    //

    if ( SrvCfg_pszPreviousServerName )
    {
        //
        //  if SOA primary pointing at previous hostname?
        //      - if not, no SOA edit for this zone
        //      - if yes, change SOA to point at new hostname
        //

        if ( isSoaPrimaryGivenServer(
                    SrvCfg_pszPreviousServerName,
                    pZone,
                    NULL ) )
        {
            //  build new SOA RR
            //      - default primary name to this server

            prr = RR_CreateSoa(
                        pZone->pSoaRR,
                        NULL,       //  default primary
                        NULL        //  default admin
                        );
            if ( !prr )
            {
                goto Failed;
            }

            //  if forcing specific SOA values -- set them up on new record

            setDefaultSoaValues( pZone, prr );

            Up_CreateAppendUpdate(
                pupdateList,
                pzoneRoot,
                prr,                // add SOA rr
                0,                  // no delete type
                NULL );             // no delete RRs
        }

        //
        //  delete old NS record
        //      - note already built new one above
        //

        prr = RR_CreatePtr(
                    NULL,                   // no dbase name
                    SrvCfg_pszPreviousServerName,
                    DNS_TYPE_NS,
                    pZone->dwDefaultTtl,
                    MEMTAG_RECORD_AUTO );
        if ( !prr )
        {
            goto Failed;
        }

        Up_CreateAppendUpdate(
            pupdateList,
            pzoneRoot,
            NULL,               // no add RR
            0,                  // no delete type
            prr                 // delete NS with old name
            );

        //
        //  build root update
        //
        //  DEVNOTE: should be able to do multi-record update at name
        //          then just build IP list here, rather than updates
        //          but currently not supported
#if 0
        Up_CreateAppendUpdate(
            pupdateList,
            pzoneRoot,
            rrList.pFirst,      // add RRs
            0,                  // no delete type
            NULL                // no delete RRs
            );
#endif

#if 0
        //
        //  I am disabling this code for W2K3. In the offical rename
        //  scenario the old host name may be maintained for a period
        //  of time to mitigate negative effects of the rename. This
        //  code stomps on the old host name immediately. For Blackcomb,
        //  we need to figure out if we want to put this back with some
        //  conditions.
        //

        //
        //  delete A records at old hostname -- if in zone
        //      AAAA records also?
        //

        pnodeOldHostname = Lookup_FindZoneNodeFromDotted(
                                pZone,
                                SrvCfg_pszPreviousServerName,
                                NULL,       // no closest
                                NULL        // no status
                                );

        if ( !pnodeOldHostname  ||  IS_OUTSIDE_ZONE_NODE(pnodeOldHostname) )
        {
            DNS_DEBUG( INIT, (
                "Old server hostname %s, not within zone %s\n",
                SrvCfg_pszPreviousServerName,
                pZone ));
            goto IpChange;
        }
        Up_CreateAppendUpdate(
            pupdateList,
            pnodeOldHostname,
            NULL,
            DNS_TYPE_A,         // delete all A records
            NULL                // no delete records
            );
#endif
    }

    //
    //  even if no name change, if forcing SOA values set them up
    //      - SOA record is current zone SOA

    else
    {
        setDefaultSoaValues( pZone, NULL );
    }


IpChange:

    //
    //  if server's hostname in this zone
    //      => write its A records
    //      - optimize reverse lookup case, skip call
    //
    //  note:  this call does creation in subzone, as for dynamic update having
    //      records for SOA additional data is quite useful
    //

    if ( pZone->fReverse )
    {
        goto Done;
    }
    pnodeNewHostname = Lookup_CreateNodeForDbaseNameIfInZone(
                                pZone,
                                &g_ServerDbaseName );

    if ( !pnodeNewHostname  ||  IS_OUTSIDE_ZONE_NODE(pnodeNewHostname) )
    {
        DNS_DEBUG( INIT, (
            "Server hostname %s, not within zone %s\n",
            SrvCfg_pszServerName,
            pZone ));
        goto Done;
    }

    //
    //  mark this node as server's hostname
    //  this allows us to track updates to this node
    //

    SET_THIS_HOST_NODE( pnodeNewHostname );

    //
    //  build "replace" update of this server's A records
    //
    //  DEVNOTE: optimize so no-update if records already match
    //      currently update is replace and zone ticks forward
    //

    prr = buildLocalHostARecords( pZone->dwDefaultTtl );
    if ( !prr )
    {
        goto Done;
    }

    Up_CreateAppendUpdateMultiRRAdd(
        pupdateList,
        pnodeNewHostname,
        prr,                // add A records for this server
        DNS_TYPE_A,         // signal replace operation
        NULL );             // no delete records

Done:

    //
    //  no aging on self registration
    //
    //  DEVNOTE: aging on self-registrations
    //      cool to have this cleaned up as move DNS servers?
    //      however to do that we'd need to get periodic refresh
    //      (server could do it), otherwise have to rely on DNS client
    //

    //  pupdateList->Flag |= DNSUPDATE_AGING_OFF;

    //
    //  if have actual updates, then allocate copy for execution
    //

    if ( IS_EMPTY_UPDATE_LIST( pupdateList ) )
    {
        pupdateList = NULL;
    }
    else
    {
        pupdateList = Up_CreateUpdateList( pupdateList );
    }

    DNS_DEBUG( INIT, (
        "Leaving checkAndFixDefaultZoneRecords( %s )\n"
        "    update list = %p\n",
        pZone->pszZoneName,
        pupdateList ));

    return pupdateList;


Failed:

    ASSERT( FALSE );
    Up_FreeUpdatesInUpdateList( pupdateList );

    return NULL;
}



VOID
Zone_CheckAndFixDefaultRecordsOnLoad(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Check for and fix up default records.

    Different from above function in that it is looking to match SOA primary
    with PREVIOUS server name from registry.

Arguments:

    pZone -- zone to check

Return Value:

    None.

--*/
{
    PUPDATE_LIST pupdateList;

    DNS_DEBUG( INIT, (
        "Zone_CheckAndFixDefaultRecordsOnLoad( %s )\n",
        pZone->pszZoneName ));

    //
    //  build update list of zone changes
    //      - server name change
    //      - IP change
    //
    //  if update exists, set for delayed execution
    //

    pupdateList = checkAndFixDefaultZoneRecords(
                    pZone,
                    FALSE );                //  not PnP

    DNS_DEBUG( INIT, (
        "Leaving Zone_CheckAndFixDefaultRecordsOnLoad( %s )\n"
        "    delayed update list = %p\n",
        pZone->pszZoneName,
        pupdateList ));

    pZone->pDelayedUpdateList = pupdateList;
}



VOID
zoneUpdateOwnRecords(
    IN      PZONE_INFO      pZone,
    IN      BOOL            fIpAddressChange
    )
/*++

Routine Description:

    Guts of Zone_UpdateOwnRecords - build and execute the
    update list required to refresh the server's own records
    in one particular zone.

Arguments:

    pZone -- zone to update records in

    fIpAddressChange -- called as result of an IP address change?

Return Value:

    None

--*/
{
    PUPDATE_LIST    pupdateList = NULL;
    DNS_STATUS      status;

    if ( !pZone ||
         IS_ZONE_SHUTDOWN( pZone ) ||
         !IS_ZONE_PRIMARY( pZone ) ||
         !pZone->pZoneRoot )
    {
        goto Done;
    }

    //  Build update.

    pupdateList = checkAndFixDefaultZoneRecords(
                    pZone,
                    fIpAddressChange );
    if ( !pupdateList )
    {
        DNS_DEBUG( UPDATE, (
            "No update list generated by PnP for zone %s\n",
            pZone->pszZoneName ));
        goto Done;
    }

    DNS_DEBUG( PNP, (
        "Update list %p for own records for zone %s\n",
        pupdateList,
        pZone->pszZoneName ));

    //  Attempt to execute update.

    status = Up_ExecuteUpdate(
                pZone,
                pupdateList,
                DNSUPDATE_AUTO_CONFIG | DNSUPDATE_LOCAL_SYSTEM );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( PNP, (
            "ERROR:  PnP update (%p) for zone %s failed!\n"
            "    status = %d (%p)\n",
            pupdateList,
            pZone->pszZoneName,
            status, status ));
    }

    Done:

    FREE_HEAP( pupdateList );

    return;
}   //  zoneUpdateOwnRecords



VOID
Zone_UpdateOwnRecords(
    IN      BOOL            fIpAddressChange
    )
/*++

Routine Description:

    Update default zone records. This function should be called
    periodically and when the server's IP address changes.

    If the server's IP address (or some other net param ) is changing
    then we need to walk the zone list and update all zones. If this
    is just a periodic update we only need to refresh the zone which
    is authoritative for the server's own hostname.

Arguments:

    fIpAddressChange -- called as result of an IP address change?

Return Value:

    None

--*/
{
    PZONE_INFO      pzone = NULL;

    DNS_DEBUG( PNP, ( "Zone_UpdateOwnRecords()\n" ));

    if ( fIpAddressChange )
    {
        //
        //  Refresh all primary non-reverse zones.
        //

        while ( pzone = Zone_ListGetNextZone( pzone ) )
        {
            if ( !IS_ZONE_PRIMARY( pzone ) || IS_ZONE_REVERSE( pzone ) )
            {
                continue;
            }

            zoneUpdateOwnRecords( pzone, fIpAddressChange );
        }
    }
    else
    {
        //
        //  Refresh the zone authoritative for the server's hostname.
        //

        PDB_NODE    pZoneNode;

        pZoneNode = Lookup_ZoneTreeNodeFromDottedName( 
                        SrvCfg_pszServerName,
                        0,      //  name length
                        0 );    //  flags
        if ( pZoneNode )
        {
            zoneUpdateOwnRecords( pZoneNode->pZone, fIpAddressChange );
        }
    }
}   //  Zone_UpdateOwnRecords



VOID
Zone_CreateDelegationInParentZone(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Create delegation in parent zone.

    Call on new zone create. This function respects the value
    of SrvCfg_dwAutoCreateDelegations and may not actually
    create the delegation depending on this value.

Arguments:

    pZone -- zone to check

Return Value:

    None.

--*/
{
    PDB_RECORD      prr;
    PZONE_INFO      pzoneParent = NULL;
    PDB_NODE        pnodeDelegation;
    UPDATE_LIST     updateList;
    DNS_STATUS      status;
    PSTR            pszptrname;
    PSTR            psztempPtrTarget = NULL;

    DNS_DEBUG( RPC, (
        "Zone_CreateDelegationInParentZone( %s )\n",
        pZone->pszZoneName ));

    if ( SrvCfg_dwAutoCreateDelegations == DNS_ACD_DONT_CREATE )
    {
        return;
    }

    //
    //  root zone -- no parent
    //

    if ( IS_ROOT_ZONE( pZone ) )
    {
        return;
    }

    //
    //  find\create delegation in parent zone
    //
    //  DEVNOTE: log errors for unupdateable zones
    //      - off machine (no parent)
    //      - secondary
    //      - below another delegation
    //
    //  DEVNOTE: handle these conditions with dynamic update attempt
    //

    pnodeDelegation = Lookup_CreateParentZoneDelegation(
                            pZone,
                            SrvCfg_dwAutoCreateDelegations ==
                                DNS_ACD_ONLY_IF_NO_DELEGATION_IN_PARENT ?
                                LOOKUP_CREATE_DEL_ONLY_IF_NONE :
                                0,
                            &pzoneParent );
    if ( !pzoneParent )
    {
        return;
    }
    if ( IS_ZONE_SECONDARY( pzoneParent ) || IS_ZONE_FORWARDER( pzoneParent ) )
    {
        return;
    }
    if ( !pnodeDelegation )
    {
        return;
    }
    if ( !EMPTY_RR_LIST( pnodeDelegation ) &&
         SrvCfg_dwAutoCreateDelegations ==
            DNS_ACD_ONLY_IF_NO_DELEGATION_IN_PARENT )
    {
        //  The delegation node has RRs so it is not new. We do not want
        //  to add a delegation to the local server in this case.
        return;
    }

    //
    //  delegation on parent primary
    //

    //  init update list
    //  will allocate a copy, only if build updates

    Up_InitUpdateList( &updateList );

    //
    //  Build NS pointing at this server.
    //
    //  Special case: if this is an _msdcs zone and the server name
    //  is single-label then we are going through a dcpromo. Do not
    //  use the single-lable host name as the NS target. Instead,
    //  fabricate the FQDN of the server as it will most likely look
    //  after dcpromo is complete. This prevents us from having a
    //  bogus NS target after dcpromo.
    //
    
    pszptrname = SrvCfg_pszServerName;      //  Default.

    if ( _strnicmp( pZone->pszZoneName, "_msdcs.", 7 ) == 0 &&
         strchr( SrvCfg_pszServerName, '.' ) == NULL )
    {
        DWORD   cbstr = strlen( pZone->pszZoneName ) +
                        strlen( SrvCfg_pszServerName );
        
        psztempPtrTarget = ALLOCATE_HEAP( cbstr );
        if ( psztempPtrTarget )
        {
            DWORD st;
            
            st = StringCbPrintfA(
                    psztempPtrTarget,
                    cbstr,
                    "%s.%s",
                    SrvCfg_pszServerName,
                    strchr( pZone->pszZoneName, '.' ) + 1 );
            if ( SUCCEEDED( st ) )
            {
                pszptrname = psztempPtrTarget;
            }
        }
    }

    prr = RR_CreatePtr(
                NULL,                   // no dbase name
                pszptrname,
                DNS_TYPE_NS,
                pZone->dwDefaultTtl,
                MEMTAG_RECORD_AUTO );
    if ( !prr )
    {
        return;
    }
    Up_CreateAppendUpdate(
        &updateList,
        pnodeDelegation,
        prr,                //  add NS with new name
        0,                  //  no delete type
        NULL );             //  no delete RRs

    //
    //  execute update on parent zone
    //

    status = Up_ExecuteUpdate(
                pzoneParent,
                &updateList,
                DNSUPDATE_AUTO_CONFIG | DNSUPDATE_LOCAL_SYSTEM );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "WARNING:  Failed parent-delegation update in zone %s!\n"
            "    new zone %s\n"
            "    status = %d (%p)\n",
            pzoneParent->pszZoneName,
            pZone->pszZoneName,
            status, status ));
    }

    FREE_HEAP( psztempPtrTarget );

    return;
}


//
//  End zone.c
//



//
//  Zone locking routines
//
//  Need to avoid simultaneous access to zone records for
//      - zone transfer send
//      - zone transfer recv
//      - admin changes
//      - dynamic updates
//
//  Allow multiple transfer sends, which don't change zone, at one time,
//  but avoid any changes during send.
//
//  Implementation:
//      - hold critical section ONLY during test and set of lock bit
//      - lock byte itself indicates zone is locked
//      - individual flags for locking operations
//
//  Lock byte indicates lock type
//      == 0    =>      zone is not locked
//      > 0     =>      count of outstanding read locks
//      < 0     =>      count of outstanding write locks (may be recursive)
//


//
//  Flag to indicate write lock is assumable by XFR thread
//  Use in place of ThreadId
//  This keeps vending thread from reentering lock, before
//      XFR thread starts
//

#define ZONE_LOCK_ASSUMABLE_ID      ( ( DWORD ) 0xaaaaaaaa )


//
//  Waitable locks globals.
//  Wait array will contain shutdown event also.
//

HANDLE  g_hZoneUnlockEvent = NULL;

HANDLE  g_hLockWaitArray[ 2 ];

LONG    g_LockWaitCount = 0;


//
//  Wait polling interval
//  See in code comment about inability to handle all zones
//  effectively with one event
//

#define ZONE_LOCK_WAIT_POLL_INTERVAL        (33)        // 33 ms, 30 cycles a second


//
//  DEVNOTE: zone lock implementation
//
//  More globally should switch to independent lock for forward
//  zones (some sort of combined for reverse).  This lock would
//  then be used for database AND for protecting zone lock flags.
//
//  Even more globally, want to use my fast read\write locks to
//  handle all these issues.  Key focus here just to keep
//  interface opaque enough to change implementation later.
//



BOOL
zoneLockForWritePrivate(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Lock zone for write operation, update or zone transfer recv.

Arguments:

    pZone   -- zone to lock

    dwFlag  -- flag for lock

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    TRUE -- if admin update owns zone and may proceed
    FALSE -- zone is locked

--*/
{
    BOOL    retval;
    DWORD   threadId;

    //  handle no zone case, as admin may be deleting cached records

    if ( !pZone )
    {
        return TRUE;
    }

    threadId = GetCurrentThreadId();

    //
    //  fast failure path
    //

    if ( pZone->fLocked != 0  &&
        pZone->dwLockingThreadId != threadId )
    {
        return FALSE;
    }

    //
    //  grab lock CS
    //

    retval = FALSE;

    Zone_UpdateLock( pZone );

    DNS_DEBUG ( LOCK2, (
        "ZONE_LOCK: zone %s; thread 0x%X; fLocked=%d\n\t(%s!%ld)\n",
        pZone->pszZoneName,
        threadId,
        pZone->fLocked,
        pszFile,
        dwLine
        ));

    //  if zone unlocked, grab lock
    //  set thread id, so we can do detect when lock held by this thread
    //  this allows us to do file write with either Read or Write lock

    if ( pZone->fLocked == 0 )
    {
        pZone->fLocked--;
        pZone->dwLockingThreadId = threadId;
        retval = TRUE;
    }

    //  allow multiple levels of update lock
    //  simply dec lock count and continue

    else if ( pZone->dwLockingThreadId == threadId )
    {
        ASSERT( pZone->fLocked < 0 );
        pZone->fLocked--;
        retval = TRUE;
    }

    //  update lock table

    if ( retval )
    {
        if ( dwFlag & LOCK_FLAG_UPDATE )
        {
            pZone->fUpdateLock++;
        }
        if ( dwFlag & LOCK_FLAG_XFR_RECV )
        {
            pZone->fXfrRecvLock++;
        }
    }

    DNS_DEBUG ( LOCK2, (
        "    ZONE_LOCK(2): fLocked=%d\n", pZone->fLocked ));

    Zone_UpdateUnlock( pZone );

    IF_DEBUG( LOCK )
    {
        if ( !retval )
        {
            DnsDebugLock();
            DNS_PRINT((
                "Failure to acquire write lock for thread %d (%p)\n",
                threadId ));
            Dbg_ZoneLock(
                "Failure to acquire write lock\n",
                pZone );
            DnsDebugUnlock();
        }
    }
    return retval;
}



BOOL
zoneLockForReadPrivate(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Lock zone for read.

Arguments:

    pZone -- zone to lock

    dwFlag -- lock flags
        LOCK_FLAG_FILE_WRITE if locking for file write

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    TRUE -- zone available for read operation (XFR or file write)
    FALSE -- zone is locked

--*/
{
    BOOL breturn = FALSE;

    //
    //  fast failure path
    //

    if ( pZone->fLocked < 0 )
    {
        return breturn;
    }

    //
    //  attempt to lock
    //

    Zone_UpdateLock( pZone );

    if ( pZone->fLocked >= 0 )
    {
        //  special case file write, limit to one at a time
        //  and if one going no point in having another go at all
        //  (i.e. no point in waiting)

        if ( dwFlag & LOCK_FLAG_FILE_WRITE )
        {
            if ( pZone->fFileWriteLock )
            {
                goto Done;
            }
            pZone->fFileWriteLock = TRUE;
        }

        //  have reader lock
        //      - bump lock count
        //      - log lock
        //      - set TRUE return

        pZone->fLocked++;

        breturn = TRUE;
        goto Done;
    }

    //  failed to get lock
    //      - if no wait, done

Done:

    Zone_UpdateUnlock( pZone );

    return breturn;
}



BOOL
waitForZoneLock(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      DWORD           dwMaxWait,
    IN      BOOL            bWrite,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Wait on lock.

    Routine avoids duplicate code for read\write lock waits.

Arguments:

    pZone       -- zone to lock

    dwFlags     -- lock flags

    dwMaxWait   -- wait on lock call

    bWrite      -- TRUE if write, FALSE if read

    pszFile     -- source file (for lock tracking)

    dwLine      -- source line (for lock tracking)

Return Value:

    TRUE -- successfully locked zone
    FALSE -- failed lock

--*/
{
    BOOL    breturn = FALSE;
    DWORD   timeout;
    DWORD   endWaitTime;
    DWORD   retry;
    DWORD   status;

    //
    //  init
    //

    endWaitTime = GetCurrentTime() + dwMaxWait;
    timeout = dwMaxWait;
    retry = 0;

    InterlockedIncrement( &g_LockWaitCount );

    DNS_DEBUG( LOCK2, (
        "Starting %dms waiting on zone %s lock\n"
        "    End time = %d\n",
        dwMaxWait,
        pZone->pszZoneName,
        endWaitTime ));

    //
    //  wait lock
    //      - if already end of wait, done
    //

    while ( 1 )
    {
        if ( (LONG)timeout < 0 )
        {
            DNS_DEBUG( LOCK, (
                "WARNING:  Lock wait on zone %s expired while checking!\n",
                pZone->pszZoneName ));
            break;
        }

        //  wakeup every few ms to protect against missed unlocks
        //      (see note below)

        status = WaitForMultipleObjects(
                    2,
                    g_hLockWaitArray,
                    FALSE,                // either event
                    ZONE_LOCK_WAIT_POLL_INTERVAL );

        //  check for shutdown or pause

        if ( fDnsServiceExit  &&  ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, (
                "Blowing out of lock-wait for shutdown\n" ));
            break;
        }

#if 0
        //  do not currently have any decent way to handle the interval
        //  from last test to entering WaitFMO()
        //  as a result can't use PulseEvent and be done
        //  can't use SetEvent, because do not have a good paradigm for Reset
        //  since event is distributed across multiple zones;  natural place
        //  is Reset on lock failure, but that may starve some other Waiting
        //  thread which wants a different zone, which has come free, but
        //  the thread was not woken from the wait or never entered it before
        //  the ResetEvent()
        //
        //  the simple approach we take is to couple the event with polling
        //  every few ms -- see below
        //

        //  exhausted wait -- done

        if ( status == WAIT_TIMEOUT )
        {
            DNS_DEBUG( LOCK, (
                "Lock wait for zone %s, ends with timeout failure after %d tries\n",
                pZone->pszZoneName,
                tryCount ));
            break;
        }

        //  retry lock

        ASSERT( status == WAIT_OBJECT_0 );
#endif
        ASSERT( status == WAIT_OBJECT_0 || status == WAIT_TIMEOUT );

        //
        //  try desired lock, but ONLY if "potentially" available
        //      write => unlocked
        //      read  => unlocked or read locked
        //
        //  note:  do NOT need to test recursive lock features as we
        //      are only in WAIT, if first lock attempt failed, so
        //      can't already have zone lock
        //

        if ( bWrite )
        {
            if ( pZone->fLocked == 0 )
            {
                breturn = zoneLockForWritePrivate(
                            pZone,
                            dwFlag,
                            pszFile,
                            dwLine );
                retry++;
            }
        }
        else    // read
        {
            if ( pZone->fLocked > 0 )
            {
                breturn = zoneLockForReadPrivate(
                            pZone,
                            dwFlag,
                            pszFile,
                            dwLine );
                retry++;
            }
        }

        if ( breturn )
        {
            break;
        }

        //  reset timeout for another wait

        timeout = endWaitTime - GetCurrentTime();
    }


    InterlockedDecrement( &g_LockWaitCount );

    IF_DEBUG( LOCK )
    {
        if ( breturn )
        {
            DNS_DEBUG( LOCK2, (
                "Succesful %s wait-lock on zone %s, after %d (ms) wait\n"
                "    retry = %d\n",
                bWrite ? "write" : "read",
                pZone->pszZoneName,
                dwMaxWait - timeout,
                retry ));
        }
        else
        {
            DNS_DEBUG( LOCK, (
                "FAILED %s wait-lock on zone %s, after %d (ms) wait\n"
                "    retry = %d\n",
                bWrite ? "write" : "read",
                pZone->pszZoneName,
                dwMaxWait - timeout,
                retry ));
        }
    }

    return breturn;
}



VOID
signalZoneUnlocked(
    VOID
    )
/*++

Routine Description:

    Signal that zone may be unlocked.

    Note, we don't currently have zone specific signal.
    This is strictly an alert to recheck.

Arguments:

    None.

Return Value:

    None

--*/
{
    //  set event to wake up waiting threads
    //      but only bother if someone waiting
    //
    //  DEVNOTE: need signal suppression
    //     two approaches
    //      waiting count -- only problem is keeping current
    //      keep last wait time --
    //          folks keep signalling for a while after complete
    //          BUT easier to keep valid, perhaps with interlock
    //          certainly with CS  BUT requires timer op here
    //
    //  DEVNOTE: pulse is incorrect
    //      because it only effects threads in wait, not those
    //      "about" to be in wait
    //
    //      once we have some idea how to handle this issue, can
    //      switch to intelligent Set\Reset
    //      ideally we'd signal when CS comes free and reset when
    //      taken
    //

    if ( g_LockWaitCount )
    {
        PulseEvent( g_hZoneUnlockEvent );
    }
}



//
//  Public zone lock routines
//

BOOL
Zone_LockInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize zone locking.

    Basically this inits the lock-wait stuff.

Arguments:

    None.

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    //  init zone locking

    g_hZoneUnlockEvent = CreateEvent(
                            NULL,       // no security attributes
                            TRUE,       // create Manual-Reset event
                            FALSE,      // start unsignalled
                            NULL        // no event name
                            );
    if ( !g_hZoneUnlockEvent )
    {
        return FALSE;
    }

    //  setup wait handle array
    //      - saves doing it each time through wait lock

    g_hLockWaitArray[ 0 ] = g_hZoneUnlockEvent;
    g_hLockWaitArray[ 1 ] = hDnsShutdownEvent;

    return TRUE;
}



BOOL
Zone_LockForWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      DWORD           dwMaxWait,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Lock zone for write operation, update or zone transfer recv.

Arguments:

    pZone       -- zone to lock

    dwFlag      -- flags for lock

    dwMaxWait   -- wait on lock call

    pszFile     -- source file (for lock tracking)

    dwLine      -- source line (for lock tracking)

Return Value:

    TRUE -- if admin update owns zone and may proceed
    FALSE -- zone is locked

--*/
{
    BOOL    breturn;

    //
    //  wait or no wait, try immediately
    //  if successful OR if not waiting -- done
    //

    breturn = zoneLockForWritePrivate( pZone, dwFlag, pszFile, dwLine );

    if ( breturn || dwMaxWait == 0 )
    {
        return breturn;
    }

    //
    //  failed -- doing wait
    //

    return waitForZoneLock(
                pZone,
                dwFlag,
                dwMaxWait,
                TRUE,           // write lock
                pszFile,
                dwLine );
}



VOID
Zone_UnlockAfterWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Unlock zone after admin update.

Arguments:

    pZone -- zone to lock

    dwFlag  -- lock flags

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    None

--*/
{
    //  handle no zone case, as admin may be deleting cached records

    if ( !pZone )
    {
        return;
    }

    Zone_UpdateLock( pZone );

    DNS_DEBUG ( LOCK2, (
        "ZONE_UNLOCK: zone %s; thread 0x%X; fLocked=%d\n\t(%s!%ld)\n",
        pZone->pszZoneName,
        GetCurrentThreadId(),
        pZone->fLocked,
        pszFile,
        dwLine ));

    //
    //  verify valid write lock
    //

    if ( pZone->fLocked >= 0  ||
            pZone->dwLockingThreadId != GetCurrentThreadId() )
    {
        Dbg_ZoneLock( "ERROR:  bad zone write unlock:", pZone );

#if DBG
        if ( !(dwFlag & LOCK_FLAG_IGNORE_THREAD) )
        {
            ASSERT( pZone->dwLockingThreadId == GetCurrentThreadId() );
        }
#endif
        ASSERT( pZone->fLocked < 0 );
        pZone->fLocked = 0;
        pZone->dwLockingThreadId = 0;
        goto Unlock;
    }

    //  drop writers recursion count

    pZone->fLocked++;

    //  drop update lock -- if set

    if ( dwFlag & LOCK_FLAG_UPDATE )
    {
        ASSERT( pZone->fUpdateLock );
        pZone->fUpdateLock--;
    }

    //  drop XFR flag

    else if ( dwFlag & LOCK_FLAG_XFR_RECV )
    {
        ASSERT( pZone->fXfrRecvLock );
        pZone->fXfrRecvLock--;
    }

    //  final unlock? -- clear locking thread id

    if ( pZone->fLocked == 0 )
    {
        pZone->dwLockingThreadId = 0;
    }

Unlock:

    DNS_DEBUG ( LOCK2, (
        "    ZONE_LOCK(2): fLocked=%d\n", pZone->fLocked ));

    Zone_UpdateUnlock( pZone );

    //  if final unlock -- signal that zone may be available

    if ( pZone->fLocked == 0 )
    {
        signalZoneUnlocked();
    }
    return;
}



VOID
Zone_TransferWriteLockEx(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Transfers zone write lock.
    This is to allow zone transfer recv thread to grab lock for secondary
    control thread.

Arguments:

    pZone -- zone to lock

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    None

--*/
{
    IF_DEBUG( XFR )
    {
        Dbg_ZoneLock(
            "Transferring write lock",
            pZone );
    }
    ASSERT( pZone && IS_ZONE_LOCKED_FOR_WRITE(pZone) && pZone->fXfrRecvLock );

    Zone_UpdateLock( pZone );
    pZone->dwLockingThreadId = ZONE_LOCK_ASSUMABLE_ID;

    Zone_UpdateUnlock( pZone );
}



BOOL
Zone_AssumeWriteLockEx(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Assumes zone write lock.
    This is to allow zone transfer recv thread to grab lock for secondary
    control thread.

Arguments:

    pZone -- zone to lock

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    TRUE -- if lock successfully assumed, and thread may proceed
    FALSE -- if some other thread owns lock

--*/
{
    BOOL    retBool;

    IF_DEBUG( XFR )
    {
        Dbg_ZoneLock(
            "Assuming zone write lock",
            pZone );
    }
    ASSERT( pZone && IS_ZONE_LOCKED_FOR_WRITE(pZone) && pZone->fXfrRecvLock );

    Zone_UpdateLock( pZone );

    if ( pZone->dwLockingThreadId != ZONE_LOCK_ASSUMABLE_ID )
    {
        DNS_PRINT((
            "ERROR:  unable to assume write lock for zone %s!\n",
            pZone->pszZoneName ));

        retBool = FALSE;
    }
    else
    {
        pZone->dwLockingThreadId = GetCurrentThreadId();
        retBool = TRUE;
    }

    Zone_UpdateUnlock( pZone );

    return retBool;
}



BOOL
Zone_LockForReadEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      DWORD           dwMaxWait,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Lock zone for read.

Arguments:

    pZone -- zone to lock

    dwFlag -- lock flags
        LOCK_FLAG_FILE_WRITE if locking for file write

    dwWaitMs -- max wait in milliseconds

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    TRUE -- zone available for read operation (XFR or file write)
    FALSE -- zone is locked

--*/
{
    BOOL    breturn;

    //
    //  wait or no wait, try immediately
    //  if successful OR if not waiting -- done
    //

    breturn = zoneLockForReadPrivate( pZone, dwFlag, pszFile, dwLine );

    if ( breturn || dwMaxWait == 0 )
    {
        return breturn;
    }

    //
    //  failed -- doing wait
    //

    return waitForZoneLock(
                pZone,
                dwFlag,
                dwMaxWait,
                FALSE,      // read lock
                pszFile,
                dwLine );
}



VOID
Zone_UnlockAfterReadEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Unlock zone after complete read operation (zone transfer or file write).

Arguments:

    pZone -- zone to lock

    dwFlag -- lock flags
        LOCK_FLAG_FILE_WRITE if unlocking after a file write

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    None

--*/
{
    ASSERT( pZone  &&  IS_ZONE_LOCKED_FOR_READ(pZone) );

    Zone_UpdateLock( pZone );

    //  verify read lock

    if ( ! IS_ZONE_LOCKED_FOR_READ(pZone) )
    {
        ASSERT( FALSE );
        goto Unlock;
    }

    //  clear file write lock, if file writer

    if ( dwFlag & LOCK_FLAG_FILE_WRITE )
    {
        ASSERT( pZone->fFileWriteLock );
        pZone->fFileWriteLock = FALSE;
    }

    //  decrement readers count

    pZone->fLocked--;
    ASSERT( pZone->fLocked >= 0 );
    ASSERT( pZone->dwLockingThreadId == 0 );

Unlock:

    Zone_UpdateUnlock( pZone );

    //  if final unlock -- signal that zone may be available

    if ( pZone->fLocked == 0 )
    {
        signalZoneUnlocked();
    }
    return;
}



BOOL
Zone_LockForFileWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwMaxWait,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Lock zone for file write.

Arguments:

    pZone       -- zone to lock

    dwMaxWait   -- max wait for lock in ms

    pszFile     -- source file (for lock tracking)

    dwLine      -- source line (for lock tracking)

Return Value:

    TRUE -- if zone transfer owns zone and may proceed
    FALSE -- zone is locked

--*/
{
    //  if thread holds write lock, that's good enough

    Zone_UpdateLock( pZone );

    if ( pZone->dwLockingThreadId )
    {
        if ( pZone->dwLockingThreadId == GetCurrentThreadId() )
        {
            pZone->fFileWriteLock = TRUE;

            Zone_UpdateUnlock( pZone );
            return TRUE;
        }
    }

    Zone_UpdateUnlock( pZone );

    //  otherwise get readers lock
    //  always willing to wait up to 5 seconds

    return Zone_LockForReadEx(
                pZone,
                LOCK_FLAG_FILE_WRITE,
                dwMaxWait,
                pszFile,
                dwLine );
}



VOID
Zone_UnlockAfterFileWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Unlock zone after file write.

Arguments:

    pZone -- zone to lock

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    None

--*/
{
    ASSERT( pZone );
    ASSERT( pZone->fLocked && pZone->fFileWriteLock );

    //  if thread holds write lock, just clear file write flag

    if ( pZone->dwLockingThreadId )
    {
        ASSERT( pZone->dwLockingThreadId == GetCurrentThreadId() );
        pZone->fFileWriteLock = FALSE;
        return;
    }

    //  otherwise clear readers lock

    Zone_UnlockAfterReadEx(
        pZone,
        LOCK_FLAG_FILE_WRITE,
        pszFile,
        dwLine );
}



VOID
Dbg_ZoneLock(
    IN      LPSTR           pszHeader,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Debug print zone lock info.

Arguments:

    pszHeader -- header to print

    pZone -- zone to lock

Return Value:

    None

--*/
{
    DWORD   threadId = GetCurrentThreadId();

    ASSERT( pZone );

    //
    //  this function is sometimes called within DebugPrintLock()
    //  to avoid possible deadlock, can't use Thread_DescriptionMatchingId()
    //      as this will wait on Thread list CS, and there are some
    //      debug prints within certain thread list operations
    //

    DnsPrintf(
        "%s"
        "Lock for zone %s:\n"
        "    Locked           = %d\n"
        "    LockingThreadId  = %d (%p)\n"
        "    UpdateLock       = %d\n"
        "    XfrRecvLock      = %d\n"
        "    FileWriteLock    = %d\n"
        "CurrentThreadId    = %d (%p)\n",
        pszHeader ? pszHeader : "",
        pZone->pszZoneName,
        pZone->fLocked,
        pZone->dwLockingThreadId, pZone->dwLockingThreadId,
        pZone->fUpdateLock,
        pZone->fXfrRecvLock,
        pZone->fFileWriteLock,
        threadId, threadId );
}



DNS_STATUS
setZoneName(
    IN OUT  PZONE_INFO      pZone,
    IN      LPCSTR          pszNewZoneName,
    IN      DWORD           dwNewZoneNameLen
    )
/*++

Routine Description:

    Frees existing zone names (if they exist) and sets up the various
    zone name fields with copies of the new zone name.

    Note: currently if one of the name functions fails the zone will
    be in a totally foobared state. We should save the old names and
    restore on failure?

Arguments:

    pZone -- zone to get new name

    pszNewZoneName -- new name

    dwNewZoneNameLen  -- length of pszNewZoneName or zero if
        pszNewZoneName should be assumed to be NULL-terminated

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           i;

    FREE_HEAP( pZone->pCountName );

    pZone->pCountName = Name_CreateCountNameFromDottedName(
                            ( LPSTR ) pszNewZoneName,
                            dwNewZoneNameLen );
    if ( !pZone->pCountName )
    {
        status = DNS_ERROR_INVALID_NAME;
        goto Failure;
    }

    FREE_HEAP( pZone->pszZoneName );

    pZone->pszZoneName = Dns_StringCopyAllocate_A(
                            ( LPSTR ) pszNewZoneName,
                            dwNewZoneNameLen );
    if ( !pZone->pszZoneName )
    {
        status = DNS_ERROR_INVALID_NAME;
        goto Failure;
    }

    //
    //  Remove trailing dot from zone name. Note that the zone
    //  name "." is a special case which should not be molested
    //  by this code.
    //
    
    i = dwNewZoneNameLen;
    while ( i > 1 && pZone->pszZoneName[ i - 1 ] == '.' )
    {
        pZone->pszZoneName[ --i ] = '\0';
    }

    FREE_HEAP( pZone->pwsZoneName );

    pZone->pwsZoneName = Dns_StringCopyAllocate(
                            pZone->pszZoneName,
                            dwNewZoneNameLen,
                            DnsCharSetUtf8,
                            DnsCharSetUnicode );    // create unicode
    if ( !pZone->pwsZoneName )
    {
        status = DNS_ERROR_INVALID_NAME;
        goto Failure;
    }
    
    DNS_DEBUG( INIT, (
        "setZoneName: UTF8=%s unicode=%S\n",
        pZone->pszZoneName,
        pZone->pwsZoneName ));
    return ERROR_SUCCESS;

    Failure:

    DNS_DEBUG( INIT, (
        "setZoneName: on zone %p failed to set new name %s (%d)\n",
        pZone,
        pszNewZoneName,
        dwNewZoneNameLen ));
    return status;
}   //  setZoneName


//
//  End zone.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\wins.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    wins.c

Abstract:

    Domain Name System (DNS) Server

    Code for initializing WINS lookup and handling WINS requests.

Author:

    Jim Gilroy (jamesg)     August 2, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  WINS globals
//

PPACKET_QUEUE   g_pWinsQueue;

//
//  WINS request packet
//
//  Keep template of standard WINS request and copy it and
//  overwrite name to make actual request.
//

BYTE    achWinsRequestTemplate[ SIZEOF_WINS_REQUEST ];

//
//  NBSTAT request packet
//
//  Keep a copy of NetBIOS node status request and use it
//  each time.  Only the address we send to changes.
//

#define SZ_NBSTAT_REQUEST_NAME ( "CKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" )

BYTE    achNbstatRequestTemplate[ SIZEOF_WINS_REQUEST ];


//
//  WINS target sockaddr
//

struct sockaddr saWinsSockaddrTemplate;



//
//  Private prototypes
//

VOID
createWinsRequestTemplates(
    VOID
    );

UCHAR
createWinsName(
    OUT     PCHAR   pchResult,
    IN      PCHAR   pchLabel,
    IN      UCHAR   cchLabel
    );


BOOL
Wins_Initialize(
    VOID
    )
/*++

Routine Description:

    Initializes DNS to use WINS lookup.

    Currently WINS queue is initialized all the time in dnsdata.c,
    so only issue is starting a WINS thread.  But use this routine
    so no need to hide details, in case this changes.

Arguments:

    None

Globals:

    SrvCfg_fWinsInitialized - set on first initialization

Return Value:

    TRUE, if successful
    FALSE otherwise, unable to create threads

--*/
{
    //
    //  test for previous initialization
    //

    if ( SrvCfg_fWinsInitialized )
    {
        return TRUE;
    }

    //
    //  create WINS queue
    //

    g_pWinsQueue = PQ_CreatePacketQueue(
                    "WINS",
                    0,                              //  flags
                    WINS_DEFAULT_LOOKUP_TIMEOUT,    //  default timeout
                    0 );                            //  maximum elements
    if ( !g_pWinsQueue )
    {
        goto WinsInitFailure;
    }

    //
    //  build WINS request
    //      - request packet template
    //      - request sockaddr template
    //

    createWinsRequestTemplates();

    //
    //  indicate successful initialization
    //
    //  no protection is required on setting this as it is done
    //  only during startup database parsing
    //

    SrvCfg_fWinsInitialized = TRUE;
    return TRUE;

WinsInitFailure:

    DNS_LOG_EVENT(
        DNS_EVENT_WINS_INIT_FAILED,
        0,
        NULL,
        NULL,
        GetLastError() );

    return FALSE;
}   //  Wins_Initialize



VOID
createWinsRequestTemplates(
    VOID
    )
/*++

Routine Description:

    Create template for WINS request and WINS sockaddr.

    This is done to simplify working code path.

Arguments:

    None

Return Value:

    None

--*/
{
    PCHAR           pch;
    CHAR            ch;
    INT             i;
    PWINS_NAME      pWinsName;
    PWINS_QUESTION  pWinsQuestion;
    PWINS_QUESTION  pNbstatQuestion;

    //
    //  WINS sockaddr template
    //      - set family and port
    //      - address set in call
    //

    RtlZeroMemory(
        &saWinsSockaddrTemplate,
        sizeof( saWinsSockaddrTemplate ) );

    saWinsSockaddrTemplate.sa_family = AF_INET;
    ((PSOCKADDR_IN) &saWinsSockaddrTemplate)->sin_port
                                        = htons( WINS_REQUEST_PORT );

    //
    //  build WINS request packet template
    //
    //      - zero memory
    //      - set header
    //      - write NetBIOS name
    //      - set question type, class
    //

    RtlZeroMemory(
        achWinsRequestTemplate,
        SIZEOF_WINS_REQUEST );

    //
    //  header
    //      - zero (request, query, no broadcast)
    //      - set recursion desired flag
    //      - set question count
    //      - set XID when packet queued
    //

    ((PDNS_HEADER)achWinsRequestTemplate)->RecursionDesired = 1;
    ((PDNS_HEADER)achWinsRequestTemplate)->QuestionCount = htons(1);

    //
    //  setup name buffer with max size blank name
    //      - size byte at begining (always 32)
    //      - 15 spaces and <00> workstation byte, converted
    //          to netBIOS name
    //      - zero byte to terminate name
    //
    //  actual requests will overwrite their portion of the name only
    //

    pWinsName = (PWINS_NAME) (achWinsRequestTemplate + sizeof(DNS_HEADER) );
    pWinsName->NameLength = NETBIOS_PACKET_NAME_LENGTH;

    pch = pWinsName->Name;

    for ( i=1; i<NETBIOS_ASCII_NAME_LENGTH; i++ )
    {
        ch = ' ';
        *pch++ = 'A' + (ch >> 4);       // write high nibble
        *pch++ = 'A' + (ch & 0x0F );    // write low nibble
    }
    //  workstation <00> byte

    *pch++ = 'A';       // write high nibble
    *pch++ = 'A';       // write low nibble

    ASSERT ( pch == (PCHAR)& pWinsName->NameEndByte && *pch == 0 );

    //
    //  write standard question type and class
    //      - general name service type
    //      - internet class
    //      - write both in with nmenonics in net byte order
    //

    pWinsQuestion = (PWINS_QUESTION) ++pch;
    pWinsQuestion->QuestionType = NETBIOS_TYPE_GENERAL_NAME_SERVICE;
    pWinsQuestion->QuestionClass = DNS_RCLASS_INTERNET;
}   // createWinsRequestTemplates



VOID
Wins_Shutdown(
    VOID
    )
/*++

Routine Description:

    Shuts down WINS receive thread.

Arguments:

    None

Return Value:

    None.

--*/
{
    DNS_DEBUG( INIT, ( "Wins_Shutdown()\n" ));

    //
    //  only need cleanup if initialized
    //

    if ( SrvCfg_fWinsInitialized )
    {
        SrvCfg_fWinsInitialized = FALSE;

        //  cleanup event in packet queue

        PQ_CleanupPacketQueueHandles( g_pWinsQueue );
    }

    //
    //  clear WINS flag -- for situation when we become dynamic
    //

    SrvCfg_fWinsInitialized = FALSE;

    DNS_DEBUG( INIT, ( "Finished Wins_Shutdown()\n" ));
}   //  Wins_Shutdown




#if 0
//
//  Now as process, memory cleanup unnecesary
//

VOID
Wins_Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleans up queued WINS queries and deletes WINS queue.

    Note, this does NOT protect threads from attempting to
    queue queries to WINS or the WINS recv threads from accessing
    WINS.

    Use this ONLY when all other threads have been shutdown.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    //  cleanup WINS queue
    //

    PQ_DeletePacketQueue( g_pWinsQueue );
}
#endif




BOOL
FASTCALL
Wins_MakeWinsRequest(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      WORD            wOffsetName,    OPTIONAL
    IN      PDB_NODE        pnodeLookup     OPTIONAL
    )
/*++

Routine Description:

    Send request to WINS server.

Arguments:

    pQuery -- request to send to WINS

    pZone -- zone name to lookup is in

    wOffsetName -- offset to name in packet, if NOT lookup up name
        of question in packet

    pnodeLookup -- domain node to lookup, if NOT looking up name
        of question in packet

Return Value:

    TRUE -- if successfully sent request to WINS
    FALSE -- if failed

--*/
{
    PCHAR           pch;            //  ptr to name char in packet
    CHAR            ch;             //  current char being converted
    PDB_RECORD      pWinsRR;        //  WINS RR for zone
    LONG            nSendLength = SIZEOF_WINS_REQUEST;
    SOCKADDR_IN     saWinsSockaddr;
    INT             err;
    PCHAR           pchlabel;
    UCHAR           cchlabel;
    DWORD           nForwarder;
    WORD            wXid;
    BOOLEAN         funicode = FALSE;

    //  allocate space in packet buffer for request including scope

    BYTE    achWinsRequest[ SIZEOF_WINS_REQUEST+DNS_MAX_NAME_LENGTH ];


    DNS_DEBUG( WINS, (
        "Wins_MakeWinsRequest( %p ), z=%p, off=%d, node=%p.\n",
        pQuery,
        pZone,
        wOffsetName,
        pnodeLookup ));

    //  should NOT already be on queue

    MSG_ASSERT( pQuery, !IS_MSG_QUEUED(pQuery) );
    ASSERT( IS_DWORD_ALIGNED(pQuery) );

    //
    //  if already referred
    //      - get relevant required info from packet
    //      - verify another WINS server in list
    //

    if ( pQuery->fQuestionRecursed )
    {
        MSG_ASSERT( pQuery, pQuery->fQuestionCompleted == FALSE );
        MSG_ASSERT( pQuery, pQuery->fWins );
        MSG_ASSERT( pQuery, pQuery->wTypeCurrent == DNS_TYPE_A );
        MSG_ASSERT( pQuery, pQuery->nForwarder );

        pWinsRR = pQuery->U.Wins.pWinsRR;
        pZone = pQuery->pzoneCurrent;
        pnodeLookup = pQuery->pnodeCurrent;
        wOffsetName = pQuery->wOffsetCurrent;
        cchlabel = pQuery->U.Wins.cchWinsName;

        MSG_ASSERT( pQuery, pWinsRR );
        MSG_ASSERT( pQuery, cchlabel );
        ASSERT( pZone );
    }

    //
    //  if first WINS lookup
    //      - clear queuing XID, let queue assign new one
    //      - clear count of WINS server we're on
    //

    else
    {
        pQuery->wQueuingXid = 0;
        pQuery->nForwarder = 0;

        //
        //  verify valid lookup
        //
        //  1) name is immediate child of zone root
        //  do NOT lookup queries for all names in zone as resolvers will
        //  generate queries with client's domain or search suffixes appended
        //  to query name
        //  example:
        //      www.msn.com.microsoft.com.
        //
        //  2) name label, MUST be convertible to netBIOS name
        //  need name label < 15 characters, as we use up one character to
        //  indicate the netBIOS service type;  (we query for workstation name)

        //
        //  lookup given node
        //      - node must be immediate child of zone root
        //      - MUST have set offset

        if ( pnodeLookup )
        {
            if ( pnodeLookup->pParent != pZone->pZoneRoot )
            {
                DNS_DEBUG( WINS, (
                    "Rejecting WINS lookup for query at %p.\n"
                    "    node %p (%s) is not parent of zone root.\n",
                    pQuery,
                    pnodeLookup,
                    pnodeLookup->szLabel ));
                return FALSE;
            }
            pchlabel = pnodeLookup->szLabel;
            cchlabel = pnodeLookup->cchLabelLength;
        }

        //
        //  lookup question name
        //
        //  - verify question name child of zone root, by checking if it has
        //      only one more label in lookupname
        //  - question starts immediately after header
        //  - note, should be NO compression in question
        //

        else
        {
            if ( pQuery->pLooknameQuestion->cLabelCount
                    != pZone->cZoneNameLabelCount + 1 )
            {
                DNS_DEBUG( WINS, (
                    "Rejecting WINS lookup for query at %p.\n"
                    "    %d labels in question, %d labels in zone.\n",
                    pQuery,
                    pQuery->pLooknameQuestion->cLabelCount,
                    pZone->cZoneNameLabelCount ));
                return FALSE;
            }
            ASSERT( wOffsetName == DNS_OFFSET_TO_QUESTION_NAME );
            pchlabel = pQuery->MessageBody;
            cchlabel = *pchlabel++;
        }

#if DBG
        ASSERT( cchlabel < 64 && cchlabel >= 0 );
        wXid = cchlabel;
#endif
        cchlabel = createWinsName(
                        pQuery->U.Wins.WinsNameBuffer,
                        pchlabel,
                        cchlabel );
        if ( !cchlabel )
        {
            DNS_DEBUG( WINS, (
                "Label in %*s invalid or too long for WINS lookup\n"
                "    sending name error\n",
                wXid,
                pchlabel ));
            return FALSE;
        }

        //
        //  get WINS info for this zone
        //      - possible WINS turned off for this zone

        pWinsRR = pZone->pWinsRR;

        if ( !pWinsRR )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  WINS lookup for zone %s without WINS RR\n"
                "    Should only happen if WINS record just removed\n"
                "    by admin or zone transfer\n",
                pZone->pszZoneName ));
            return FALSE;
        }
        ASSERT( pWinsRR->Data.WINS.cWinsServerCount );
        ASSERT( pWinsRR->Data.WINS.dwLookupTimeout );

        //  save WINS lookup info to message info

        pQuery->fQuestionRecursed = TRUE;
        pQuery->fQuestionCompleted = FALSE;
        pQuery->fWins = TRUE;
        pQuery->U.Wins.cchWinsName = cchlabel;
        pQuery->U.Wins.pWinsRR = pWinsRR;
        pQuery->pzoneCurrent = pZone;
        pQuery->pnodeCurrent = pnodeLookup;
        pQuery->wOffsetCurrent = wOffsetName;
        pQuery->wTypeCurrent = DNS_TYPE_A;
    }

    //
    //  verify unvisited WINS servers exist
    //

    nForwarder = pQuery->nForwarder++;

    if ( (DWORD)nForwarder >= pWinsRR->Data.WINS.cWinsServerCount )
    {
        DNS_DEBUG( WINS, (
            "WARNING:  Failed WINS lookup after trying %d servers\n"
            "    %d servers in WINS RR list\n",
            --pQuery->nForwarder,
            pWinsRR->Data.WINS.cWinsServerCount ));

        TEST_ASSERT( pWinsRR->Data.WINS.cWinsServerCount );
        TEST_ASSERT( pQuery->fQuestionRecursed );
        return FALSE;
    }

    //
    //  copy WINS request template
    //

    RtlCopyMemory(
        achWinsRequest,
        achWinsRequestTemplate,
        SIZEOF_WINS_REQUEST );

    //
    //  write netBIOS name into packet
    //      - as we go check if high bit
    //

    pchlabel = pQuery->U.Wins.WinsNameBuffer;
    pch = (PCHAR) &((PWINS_REQUEST_MSG)achWinsRequest)->Name.Name;

    while( cchlabel-- )
    {
        ch = *pchlabel++;
        *pch++ = 'A' + (ch >> 4);       // write high nibble
        *pch++ = 'A' + (ch & 0x0F );    // write low nibble
    }

    //
    //  Place the request on WINS queue.
    //
    //  MUST do this before send, so packet is guaranteed to be in
    //  queue when server responds.
    //
    //  After we queue DO NOT TOUCH pQuery, a response from a previous
    //  send may come in and dequeue pQuery.
    //
    //  Queuing
    //      - set queuing time and query time, if query time not yet set
    //      - converts expire timeout to actual expire time.
    //      - sets XID
    //

    pQuery->dwExpireTime = pWinsRR->Data.WINS.dwLookupTimeout;

    wXid = PQ_QueuePacketWithXid(
                g_pWinsQueue,
                pQuery );

    //
    //  set WINS XID to net order for send
    //
    //  To operate on the same server as the WINS server, the packets
    //  MUST have XIDs that netBT, which recevies the packets, considers
    //  to be in the WINS range -- the high bit set (in host order).
    //
    //  Flip to net order for send.
    //

    ((PDNS_HEADER)achWinsRequest)->Xid = htons( wXid );

#if 0
    //
    //  DEVNOTE: this bit may be useful to allow B-nodes to directly
    //      response, but stops WINS servers from responding
    //
    //  set for broadcast?
    //

    if ( pZone->aipWinsServers[0] == 0xffffffff )
    {
        ((PDNS_HEADER)achWinsRequest)->Broadcast = 1;
    }
#endif

    //
    //  create WINS target sockaddr
    //

    RtlCopyMemory(
        &saWinsSockaddr,
        &saWinsSockaddrTemplate,
        sizeof( SOCKADDR ) );

    //
    //  send to next WINS server in RR list
    //

    saWinsSockaddr.sin_addr.s_addr
                        = pWinsRR->Data.WINS.aipWinsServers[ nForwarder ];
    DNS_DEBUG( WINS, (
        "Sending request to WINS for original query at %p\n"
        "    to WINS server (#%d in list) at %s\n"
        "    WINS name = %.*s\n",
        pQuery,
        nForwarder,
        inet_ntoa( saWinsSockaddr.sin_addr ),
        pQuery->U.Wins.cchWinsName,
        pQuery->U.Wins.WinsNameBuffer ));

    err = sendto(
                g_UdpSendSocket,
                achWinsRequest,
                nSendLength,
                0,
                (struct sockaddr *) &saWinsSockaddr,
                sizeof( struct sockaddr ) );

    if ( err != nSendLength )
    {
        ASSERT( err == SOCKET_ERROR );
        err = WSAGetLastError();

        //  check for shutdown

        if ( fDnsServiceExit )
        {
            DNS_DEBUG( SHUTDOWN, (
                "SHUTDOWN detected during WINS lookup\n" ));
            return TRUE;
        }

        //
        //  don't bother to pull packet out of queue
        //
        //  send failures, VERY rare, and with multiple WINS servers
        //      this lets us make the next sends() and possibly get
        //      name resolution -- only benefit to quiting is
        //      speedier NAME_ERROR return
        //
        //  DEVNOTE:  choices on WINS send
        //
        //          - retry send with next server
        //          - return FALSE
        //          - SERVER_FAILURE entire packet
        //          - return TRUE and let timeout, force retry
        //

        DNS_LOG_EVENT(
            DNS_EVENT_SENDTO_CALL_FAILED,
            0,
            NULL,
            NULL,
            WSAGetLastError() );

        DNS_DEBUG( ANY, (
            "ERROR:  WINS UDP sendto() failed, for query at %p\n"
            "    GetLastError() = 0x%08lx\n",
            pQuery,
            WSAGetLastError() ));
        return TRUE;
    }

    STAT_INC( WinsStats.WinsLookups );
    PERF_INC( pcWinsLookupReceived );        // PerfMon hook

    return TRUE;
}



VOID
Wins_ProcessResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process WINS response, sending corresponding packet.

    Note:  caller frees WINS response message.

Arguments:

    pMsg -- message info that is WINS response

Return Value:

    None.

--*/
{
    PWINS_NAME              pWinsName;      //  answer netBIOS name
    PWINS_RESOURCE_RECORD   presponseRR;        //  answer RR
    BOOL            fAnswer;
    INT             err;
    PCHAR           pch;            // current position in packet
    PCHAR           pchEnd;         //  end of packet
    WORD            cDataLength;
    INT             irespRR;
    BOOL            fRecordWritten = FALSE;
    DWORD           ttl;
    IP_ADDRESS      ipAddress;
    PDNS_MSGINFO    pQuery;         //  original client query
    PDB_RECORD      prr;            //  new host A RR
    PDB_NODE        pnode;          //  node of WINS query
    DNS_LIST        listRR;

    //
    //  verify doing WINS lookup
    //

    if ( !g_pWinsQueue )
    {
        Dbg_DnsMessage(
            "BOGUS response packet with WINS XID\n",
            pMsg );
        //ASSERT( FALSE );
        return;
    }

    STAT_INC( WinsStats.WinsResponses );
    PERF_INC( pcWinsResponseSent );      // PerfMon hook

    //
    //  locate and dequeue DNS query matching WINS response
    //
    //      - match based on XID of WINS request
    //      - timeout any deadwood
    //

    pQuery = PQ_DequeuePacketWithMatchingXid(
                g_pWinsQueue,
                pMsg->Head.Xid );
    if ( !pQuery )
    {
        DNS_DEBUG( WINS, (
            "No matching query for response from WINS server %s\n",
            MSG_IP_STRING( pMsg ) ));
        return;
    }
    DNS_DEBUG( WINS, (
        "Found query at %p matching WINS response at %p\n",
        pQuery,
        pMsg ));

    MSG_ASSERT( pQuery, pQuery->fWins );
    MSG_ASSERT( pQuery, pQuery->fQuestionRecursed );
    MSG_ASSERT( pQuery, pQuery->nForwarder );
    MSG_ASSERT( pQuery, pQuery->pzoneCurrent );
    MSG_ASSERT( pQuery, pQuery->wOffsetCurrent );
    MSG_ASSERT( pQuery, pQuery->dwQueryTime );

    //
    //  check if have answer
    //      - response code == success
    //      - have at least one answer RR
    //
    //  no answer or error
    //
    //      => try lookup with next WINS server
    //
    //      => if out of servers, drop to Done section
    //          - return NAME_ERROR if original question
    //          - continue type ALL query
    //          - move on to next lookup if additional record
    //
    //  DEVNOTE: should accept WINS NXDOMAIN response
    //

    if ( pMsg->Head.AnswerCount == 0 || pMsg->Head.ResponseCode != 0 )
    {
#if DBG
        //  shouldn't have error response code, if have answer

        if ( pMsg->Head.AnswerCount > 0 && pMsg->Head.ResponseCode != 0 )
        {
            DNS_PRINT((
                "ERROR:  WINS response %p, with answer count %d, with error =%d\n"
                "    I think this may happen when query directed to non-WINS server\n",
                pMsg,
                pMsg->Head.AnswerCount,
                pMsg->Head.ResponseCode ));
        }
#endif
        DNS_DEBUG( WINS, ( "WINS response empty or error\n" ));
        if ( Wins_MakeWinsRequest(
                pQuery,
                NULL,
                0,
                NULL ) )
        {
            return;
        }
        goto Done;
    }

    //
    //  packet verification
    //
    //      - skip question, if given
    //      - RR within packet
    //      - RR type and class
    //      - RR data within packet
    //

    pchEnd = DNSMSG_END( pMsg );

    pWinsName = (PWINS_NAME) pMsg->MessageBody;

    if ( pMsg->Head.QuestionCount )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Question count %d in WINS packet for query at %p\n",
            pMsg->Head.QuestionCount,
            pQuery ));

        if ( pMsg->Head.QuestionCount > 1 )
        {
            goto ServerFailure;
        }
        pWinsName = (PWINS_NAME)( (PCHAR)pWinsName + sizeof(WINS_QUESTION) );

        //
        //  DEVNOTE: assuming WINS sends zero question count
        //  DEVNOTE: not testing for name compression in WINS packets
        //

        goto ServerFailure;
    }

    //
    //  verify WINS name
    //      - falls within packet
    //      - matches query name
    //
    //  note:  WINS server queuing is broken and can end up queuing up
    //      queries for a long time;  this allows us to have two queries
    //      with the same XID on the WINS server (one of which we gave up on
    //      long ago) and the WINS server will toss the second and respond
    //      to the first, giving us a resposne with desired XID but NOT
    //      matching name
    //

    if ( (PCHAR)(pWinsName + 1)  >  pchEnd )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Following WINS answer count past end of packet\n"
            "    End of packet            = %p\n"
            "    Current RR ptr           = %p\n"
            "    End of RR ptr            = %p\n",
            pchEnd,
            pWinsName,
            (PCHAR)(pWinsName+1)
            ));
        goto ServerFailure;
    }
    if ( pWinsName->NameLength != NETBIOS_PACKET_NAME_LENGTH )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  WINS response has incorrect name format\n" ));
        goto ServerFailure;
    }

#if 0
    if ( !RtlEqualMemory(
            pWinsName->Name,
            pQuery->U.Wins.WinsNameBuffer,
            NETBIOS_PACKET_NAME_LENGTH ) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  WINS response name does not match query name!!!\n"
            "    response name    = %.*s\n"
            "    query name       = %.*s\n"
            "    Note this can result from DNS server reusing XID within short\n"
            "    enough time interval that WINS (which queues up too long) sent\n"
            "    a response for the first query\n",
            NETBIOS_PACKET_NAME_LENGTH,
            pWinsName->Name,
            NETBIOS_PACKET_NAME_LENGTH,
            pQuery->U.Wins.WinsNameBuffer ));
        goto ServerFailure;
    }
#endif

    //
    //  skip scope
    //      - unterminated name, indicates scope,
    //          skip through scope to find

    pch = (PCHAR) &pWinsName->NameEndByte;

    while ( *pch != 0 )
    {
        //  have scope, skip through labels in scope

        pch += *pch + 1;

        if ( pch >= pchEnd )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  WINS response has incorrect name termination\n" ));
            goto ServerFailure;
        }
    }

    //
    //  verify RR parameters
    //

    presponseRR = (PWINS_RESOURCE_RECORD) ++pch;

    if ( (PCHAR)(presponseRR + 1) > pchEnd )
    {
        DNS_DEBUG( ANY, ( "ERROR:  WINS packet error, RR beyond packet end\n" ));
        goto ServerFailure;
    }

    if ( presponseRR->RecordType != NETBIOS_TYPE_GENERAL_NAME_SERVICE
            ||
        presponseRR->RecordClass != DNS_RCLASS_INTERNET )
    {
        DNS_DEBUG( WINS, (
            "ERROR:  WINS response record type or class error\n" ));
        goto ServerFailure;
    }

    //
    //  verify proper RR data length
    //
    //      - must be a multiple of RData length
    //      - must be inside packet
    //

    cDataLength = ntohs( presponseRR->ResourceDataLength );

    if ( cDataLength % sizeof(WINS_RR_DATA)
            ||
         (PCHAR) &presponseRR->aRData + cDataLength > pchEnd )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  WINS response bad RR data length = %d\n",
            cDataLength ));
        goto ServerFailure;
    }

    //
    //  if owner node not given, find or create it
    //      - if fails assume unacceptable as DNS name
    //
    //  DEVNOTE: packet lookup name
    //  DEVNOTE: also best to do lookup relative to zone root
    //

    pnode = pQuery->pnodeCurrent;
    if ( ! pnode )
    {
        pnode = Lookup_ZoneNode(
                    pQuery->pzoneCurrent,
                    NULL,       // using lookup, not packet name
                    NULL,
                    pQuery->pLooknameQuestion,
                    LOOKUP_FQDN,
                    NULL,       // create
                    NULL        // following node ptr
                    );
        if ( ! pnode )
        {
            //ASSERT( FALSE );
            goto ServerFailure;
        }
    }
    IF_DEBUG( WINS )
    {
        Dbg_NodeName(
            "WINS lookup to write RR to node ",
            pnode,
            "\n" );
    }

    //
    //  set TTL for RR
    //
    //  WINS responses are cached, cache data has RR TTL given as
    //      timeout time in host order
    //

    DNS_DEBUG( WINS, (
        "WINS ttl: dwCacheTimeout %lu dwQueryTime %lu\n",
        ((PDB_RECORD)pQuery->U.Wins.pWinsRR)->Data.WINS.dwCacheTimeout,
        pQuery->dwQueryTime ));
    #define WINS_SANE_TTL   ( 24*60*60*7 )  //  one week
    ASSERT( ((PDB_RECORD)pQuery->U.Wins.pWinsRR)->Data.WINS.dwCacheTimeout < WINS_SANE_TTL );
    ASSERT( abs( ( int ) DNS_TIME()  - ( int ) pQuery->dwQueryTime ) < 60 );

    ttl = ((PDB_RECORD)pQuery->U.Wins.pWinsRR)->Data.WINS.dwCacheTimeout
                + pQuery->dwQueryTime;

    //
    //  read all address data from WINS packet -- write to DNS packet
    //

    DNS_LIST_STRUCT_INIT( listRR );

    irespRR = (-1);

    while ( cDataLength )
    {
        BOOL    bcached;

        cDataLength -= sizeof(WINS_RR_DATA);
        irespRR++;

        //
        //  copy address
        //      - not DWORD aligned
        //

        ipAddress = *(UNALIGNED DWORD *) &presponseRR->aRData[ irespRR ].IpAddress;

        //
        //  if group name, ignore
        //      - will often return 255.255.255.255 address
        //

        if ( presponseRR->aRData[ irespRR ].GroupName
                ||
            ipAddress == (IP_ADDRESS)(-1) )
        {
            DNS_DEBUG( WINS, (
                "WINS response for query at %p, "
                "contained group name or broadcase IP\n"
                "    Flags    = 0x%x\n"
                "    IP Addr  = %p\n",
                pQuery,
                * (UNALIGNED WORD *) &presponseRR->aRData[ irespRR ],
                ipAddress ));

            //  shouldn't be getting all ones on anything but group names

            ASSERT( presponseRR->aRData[irespRR].GroupName );
            continue;
        }

        //
        //  build A record
        //      - fill in IP and TTL
        //        (caching function does overwrite TTL, but need it set to
        //          write records to packet)
        //      - rank as AUTHORITATIVE answer
        //

        prr = RR_CreateARecord(
                    ipAddress,
                    ttl,
                    MEMTAG_RECORD_WINS );
        IF_NOMEM( !prr )
        {
            goto ServerFailure;
        }

        SET_RR_RANK( prr, RANK_CACHE_A_ANSWER );

        DNS_LIST_STRUCT_ADD( listRR, prr );

        //
        //  write RR to packet
        //      - always use compressed name
        //

        if ( Wire_AddResourceRecordToMessage(
                    pQuery,
                    NULL,
                    pQuery->wOffsetCurrent,     // offset to name in packet
                    prr,
                    0 ) )
        {
            fRecordWritten = TRUE;
            CURRENT_RR_SECTION_COUNT( pQuery )++;
        }

        //  note, even if out of space and unable to write
        //  continue building records so have a complete RRset to cache

        continue;
    }

    //
    //  cache the A records from response
    //      - caching time from WINS record
    //

    if ( ! IS_DNS_LIST_STRUCT_EMPTY(listRR) )
    {
        DNS_DEBUG( WINS, (
            "WINS ttl: adding to cache with dwCacheTimeout %lu dwQueryTime %lu\n",
            ((PDB_RECORD)pQuery->U.Wins.pWinsRR)->Data.WINS.dwCacheTimeout,
            pQuery->dwQueryTime ));
        ASSERT( ((PDB_RECORD)pQuery->U.Wins.pWinsRR)->Data.WINS.dwCacheTimeout < WINS_SANE_TTL );
        ASSERT( abs( ( int ) DNS_TIME()  - ( int ) pQuery->dwQueryTime ) < 60 );

        RR_CacheSetAtNode(
            pnode,
            listRR.pFirst,
            listRR.pLast,
            ((PDB_RECORD)pQuery->U.Wins.pWinsRR)->Data.WINS.dwCacheTimeout,
            pQuery->dwQueryTime );
    }

Done:

    //
    //  no records written?
    //
    //  assume this means we got group name back and hence wrote no records
    //  hence we don't have to wait for other servers to come back
    //
    //  DEVNOTE: wildcard after WINS lookup?
    //
    //  note, type ALL is special case;  if fail to locate records continue
    //  lookup to pick up possible wildcard records
    //  (some mail programs query with type all don't ask me why)
    //

#if DBG
    if ( ! fRecordWritten )
    {
        DNS_DEBUG( WINS, (
            "No records written from WINS repsonse to query at %p\n"
            "    -- possible group name, handling as NAME_ERROR.\n",
            pQuery ));
    }
    ELSE_IF_DEBUG( WINS2 )
    {
        Dbg_DbaseNode(
            "Domain node with added WINS RR ",
            pnode );
    }
#endif

    //
    //  answer question or continue if additional records
    //

    MSG_ASSERT( pQuery, !IS_MSG_QUEUED(pQuery) );
    Answer_ContinueNextLookupForQuery( pQuery );
    return;


ServerFailure:

    //
    //  DEVNOTE-LOG: log bad responses from WINS server?
    //
    //      that might be a good way to catch parsing problems from setups
    //      in the field that we do not see

    DNS_DEBUG( ANY, (
        "ERROR:  WINS response parsing error "
        "-- sending server failure for query at %p.\n",
        pQuery ));

    //
    //  if exists, use next WINS server
    //

    if ( Wins_MakeWinsRequest(
            pQuery,
            NULL,
            0,
            NULL ) )
    {
        MSG_ASSERT( pQuery, IS_MSG_QUEUED(pQuery) );
        return;
    }

    //
    //  if have some written information, don't SERVER_FAILURE
    //

    MSG_ASSERT( pQuery, !IS_MSG_QUEUED(pQuery) );

    if ( pQuery->Head.AnswerCount )
    {
        Answer_ContinueNextLookupForQuery( pQuery );
        return;
    }

    Reject_Request(
        pQuery,
        DNS_RCODE_SERVER_FAILURE, 0 );

    return;
}



UCHAR
createWinsName(
    OUT     PCHAR   pchResult,
    IN      PCHAR   pchLabel,
    IN      UCHAR   cchLabel
    )
/*++

Routine Description:

    Create valid WINS (netBIOS) name from UTF8.

Arguments:

    pchResult -- resulting netBIOS name

    pchLabel -- ptr to UTF8 label

    cchLabel -- count of bytes in label

Return Value:

    Length in bytes of resulting WINS name.
    Zero on error.

--*/
{
    PUCHAR      pch = pchResult;
    DWORD       i;
    DWORD       count;
    DWORD       unicodeCount;
    UCHAR       ch;
    BOOLEAN     funicode = FALSE;
    WCHAR       wch;
    WCHAR       unicodeBuffer[ MAX_WINS_NAME_LENGTH+1 ];
    DNS_STATUS  status;

    //
    //  if > 45, even best case
    //      (UTF8 multi-byte to single OEM chars) won't fit
    //

    if ( cchLabel > 45 )
    {
        return 0;
    }

    //
    //  verify length
    //      - no more than 15 characters so on non-extended name stop at 15
    //      - optimize for non-extended < 15 name (typical case), by
    //          converting in one pass
    //

    for ( i=0; i<cchLabel; i++ )
    {
        ch = pchLabel[i];
        if ( ch > 0x80 )
        {
            funicode = TRUE;
            break;
        }
        if ( i >= 15 )
        {
            return 0;
        }
        if ( ch <= 'z' && ch >= 'a' )
        {
            ch -= 0x20;
        }
        *pch++ = ch;
    }

    //  if not extended, we're done

    if ( !funicode )
    {
        DNS_DEBUG( WINS2, (
            "WINS lookup on pure ANSI name convert to %.*s\n",
            cchLabel,
            pchResult ));
        return cchLabel;
    }

    //
    //  multi-byte UTF8
    //      - bring name to unicode and upcase
    //

    unicodeCount = DnsUtf8ToUnicode(
                        pchLabel,
                        cchLabel,
                        unicodeBuffer,
                        MAX_WINS_NAME_LENGTH+1 );
    if ( unicodeCount == 0 )
    {
        ASSERT( GetLastError() == ERROR_INSUFFICIENT_BUFFER );

        DNS_DEBUG( WINS, (
            "ERROR:  WINS attempted on invalid\too long UTF8 extended name %.*s.\n",
            cchLabel,
            pchLabel ));
        return 0;
    }
    if ( unicodeCount > MAX_WINS_NAME_LENGTH )
    {
        ASSERT( unicodeCount <= MAX_WINS_NAME_LENGTH );
        return 0;
    }

    //
    //  DEVNOTE: don't need to do this if OEM call handles it
    //

    i = CharUpperBuffW( unicodeBuffer, unicodeCount );
    if ( i != unicodeCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    IF_DEBUG( WINS2 )
    {
        DnsDbg_Utf8StringBytes(
            "WINS lookup string:",
            pchLabel,
            cchLabel );

        DnsDbg_UnicodeStringBytes(
            "WINS lookup string",
            unicodeBuffer,
            unicodeCount );
    }

    //
    //  go to OEM -- WINS uses OEM on wire
    //

    status = RtlUpcaseUnicodeToOemN(
                pchResult,
                MAX_WINS_NAME_LENGTH,
                & count,
                unicodeBuffer,
                unicodeCount*2 );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Unable to convert unicode name %.*S to OEM for WINS lookup!\n",
            unicodeCount,
            unicodeBuffer ));
        return 0;
    }
    ASSERT( count <= MAX_WINS_NAME_LENGTH );

    IF_DEBUG( WINS2 )
    {
        DnsDbg_Utf8StringBytes(
            "WINS lookup string:",
            pchLabel,
            cchLabel );

        DnsDbg_UnicodeStringBytes(
            "WINS lookup string",
            unicodeBuffer,
            unicodeCount );

        DnsDbg_Utf8StringBytes(
            "WINS OEM lookup string:",
            pchResult,
            count );
    }

    return (UCHAR)count;
}



//
//  WINS\WINSR installation and removal from zone
//
//  There are probably two reasonable approaches:
//  1) Treat as directive
//      - mimic record for dispatch
//      - but otherwise keep ptr's out of database
//      - requires WINS hook in all RR routines
//      - special case XFR to include WINS to MS
//      - special case IXFR to send WINS when appropriate
//          (MS and WINS change in version interval sent)
//      - RPC WINS at ALL or root
//
//  2) Treat as record
//      - dispatch as record
//      - WINS hook in add routines to protect local WINS adds
//      - get WINS in IXFR list for free
//      - special casing on XFR (MS for WINS, no LOCAL)
//      - special casing in IXFR (WINS for MS only, no LOCAL)
//      - RPC special casing to get correct record for secondary LOCAL
//
//  Pretty much going with #2.
//  On primary treated as just another record, except transfer restrictions.
//

DNS_STATUS
Wins_RecordCheck(
    IN OUT  PZONE_INFO      pZone,
    IN      PDB_NODE        pNodeOwner,
    IN OUT  PDB_RECORD      pRR
    )
/*++

Routine Description:

    Setup WINS / WINS-R records in zone.

Arguments:

    pRR - new WINS record

    pNodeOwner  -- RR owner node

    pZone -- zone to install in

Return Value:

    ERROR_SUCCESS -- if successful adding regular (non-LOCAL) RR
    DNS_INFO_ADDED_LOCAL_WINS -- if successfully added local record
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_RECORD      poldDbase_Wins;

    //
    //  WINS record only supported in authoritative zone, at zone root
    //
    //  hack for SAM server can have us calling this through RPC with no zone;
    //  extract zone from owner node, and if valid zone root proceed
    //

    if ( !pZone || !IS_AUTH_ZONE_ROOT(pNodeOwner) )
    {
        DNS_DEBUG( INIT, (
            "ERROR:  WINS RR not at zone root\n" ));
        return DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT;
    }

    //
    //  WINS \ WINS-R specific
    //  WINS:
    //      - at least one server
    //      - forward lookup
    //      - init WINS lookup
    //  WINS-R:
    //      - reverse lookup
    //      - init NBSTAT lookup
    //

    if ( pRR->wType == DNS_TYPE_WINS )
    {
        if ( pRR->Data.WINS.cWinsServerCount == 0 )
        {
            return DNS_ERROR_NEED_WINS_SERVERS;
        }
        if ( pZone->fReverse )
        {
            return DNS_ERROR_INVALID_ZONE_TYPE;
        }
        if ( ! Wins_Initialize() )
        {
            return DNS_ERROR_WINS_INIT_FAILED;
        }
    }
    else
    {
        ASSERT( pRR->wType == DNS_TYPE_WINSR );
        if ( !pZone->fReverse )
        {
            return DNS_ERROR_INVALID_ZONE_TYPE;
        }
        if ( ! Nbstat_Initialize() )
        {
            return DNS_ERROR_NBSTAT_INIT_FAILED;
        }
    }

    //
    //  set defaults if zero timeouts
    //

    if ( pRR->Data.WINS.dwLookupTimeout == 0 )
    {
        pRR->Data.WINS.dwLookupTimeout = WINS_DEFAULT_LOOKUP_TIMEOUT;
    }
    if ( pRR->Data.WINS.dwCacheTimeout == 0 )
    {
        pRR->Data.WINS.dwCacheTimeout = WINS_DEFAULT_TTL;
    }

    IF_DEBUG( INIT )
    {
        Dbg_DbaseRecord(
            "New WINS or WINS-R record",
            pRR );
    }

    //
    //  on file load, verify no existing WINS record
    //
    //  DEVNOTE: note, this doesn't handle case of file load well, really need
    //              a separate zone flag for that
    //

    if ( !SrvCfg_fStarted && pZone->pWinsRR )
    {
        return DNS_ERROR_RECORD_ALREADY_EXISTS;
    }

    //  set flags
    //      - set zone rank
    //      - set zero TTL to avoid remote caching

    pRR->dwTtlSeconds = 0;
    pRR->dwTimeStamp = 0;
    SET_RANK_ZONE(pRR);

    //
    //  WINS setup in zone:
    //
    //  primary
    //      - handled EXACTLY like SOA, resides in list, ptr kept in zone block
    //
    //  secondary
    //      - database stays in list
    //      - local loaded into pLocalWins in zone block
    //          which is cleared after install
    //      - active WINS is pWinsRR ptr in zone block
    //      - if both exist this is LOCAL record
    //

    DNS_DEBUG( ANY, (
        "WINSTRACK:  check new %s WINS RR (%p) for zone %s\n",
        IS_WINS_RR_LOCAL(pRR) ? "LOCAL" : "",
        pRR,
        pZone->pszZoneName ));

    if ( IS_ZONE_SECONDARY(pZone) )
    {
        if ( IS_WINS_RR_LOCAL(pRR) )
        {
            pZone->pLocalWinsRR = pRR;
            return DNS_INFO_ADDED_LOCAL_WINS;
        }
    }

    return ERROR_SUCCESS;
}



VOID
Wins_StopZoneWinsLookup(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Stop WINS or NBSTAT lookup on a zone.

Arguments:

    pZone -- ptr to zone

    fRemote -- stop WINS lookup caused by XFR'd record

Return Value:

    None

--*/
{
    PDB_RECORD  prr;
    BOOL        flocal;

    ASSERT( pZone );
    ASSERT( IS_ZONE_LOCKED(pZone) );

    //
    //  primary -- remove database record if exists
    //
    //  secondary -- eliminate only REFERENCE to any database record
    //
    //  in both cases -- free any LOCAL record
    //
    //
    //  DEVNOTE: primary WINS turnoff should be generate an UPDATE blob
    //

    prr = pZone->pWinsRR;
    pZone->pWinsRR = NULL;
    flocal = pZone->fLocalWins;
    pZone->fLocalWins = FALSE;

    if ( prr )
    {
        DNS_DEBUG( ANY, (
            "WINSTRACK:  stopping WINS lookup (cur RR = %p) on zone %s\n",
            prr,
            pZone->pszZoneName ));

        //
        //  primary
        //      - both LOCAL and standard WINS are currently stored in RR list
        //

        if ( IS_ZONE_PRIMARY(pZone) )
        {
            RR_DeleteMatchingRecordFromNode(
                pZone->pZoneRoot,
                prr );
        }

        //
        //  secondary zone
        //      - even after stopping WINS lookup by deleting LOCAL
        //      WINS, may still have WINS from primary

        else
        {
            if ( flocal )
            {
                RR_Free( prr );
            }
            Wins_ResetZoneWinsLookup( pZone );
        }
    }
}



VOID
Wins_ResetZoneWinsLookup(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Set\reset zone WINS\WINSR lookup.

    Called after load, update, XFR to reset lookup to use proper (new\old)
    WINS record

Arguments:

    pZone -- ptr to zone

Return Value:

    None

--*/
{
    PDB_RECORD  prrNew = NULL;
    PDB_RECORD  prrExisting;
    //PDB_RECORD  prrDelete = NULL;
    WORD        type = pZone->fReverse ? DNS_TYPE_WINSR : DNS_TYPE_WINS;


    DNS_DEBUG( WINS, (
        "Wins_ResetZoneWinsLookup() on zone %s\n"
        "    pWinsRR      = %p\n"
        "    pLocalWinsRR = %p\n",
        pZone->pszZoneName,
        pZone->pWinsRR,
        pZone->pLocalWinsRR ));

    prrExisting = pZone->pWinsRR;

    //
    //  primary zone, treat just like SOA
    //      - optimize the no-change scenario
    //
    //  keeping both LOCAL\non in RR list;  this gives us standard update
    //  behavior;  only difference is must screen these records out of XFR
    //
    //  maybe a problem here on zone conversion,
    //  especially worrisome is demoting primary which has local WINS;  if record
    //  is NOT extracted from database
    //
    //  but advantages to keeping this all in the database for primary are clear
    //  no special casing for update deletes, get standard replace semantics
    //

    if ( IS_ZONE_PRIMARY(pZone) )
    {
        prrNew = RR_FindNextRecord(
                    pZone->pZoneRoot,
                    type,
                    NULL,
                    0 );
        if ( prrNew == prrExisting )
        {
            //  this could hit on zone conversion
            //  but should be blocked (zone locked) while this set
            ASSERT( pZone->pLocalWinsRR == NULL );
            return;
        }
    }

    //
    //  Secondary
    //      - new local => set, and delete old if local
    //      - existing local => leave it
    //      - otherwise => read from database
    //          - if found set
    //          - otherwise clear
    //      note, that do NOT clear old database WINS
    //
    //  DEVNOTE: local WINS in database?
    //          if decide that file load (or even RPC) should add to database,
    //          then first read database, and if local cut out record set
    //          it as incoming local and apply steps below
    //

    else if ( !IS_ZONE_FORWARDER( pZone ) )
    {
        BOOL  fexistingLocal;

        ASSERT( IS_ZONE_SECONDARY(pZone) );

        fexistingLocal = ( prrExisting &&
                            (prrExisting->Data.WINS.dwMappingFlag & DNS_WINS_FLAG_LOCAL) );

        ASSERT( pZone->fLocalWins == fexistingLocal );

        //  new local WINS, takes precedence

        if ( pZone->pLocalWinsRR )
        {
            DNS_DEBUG( WINS, (
                "Setting new local WINS RR at %p\n",
                pZone->pLocalWinsRR ));

            prrNew = pZone->pLocalWinsRR;
            if ( fexistingLocal )
            {
                //Timeout_FreeWithFunction( prrExisting, RR_Free );
                RR_Free( prrExisting );
            }
            goto SetWins;
        }

#if 0
        //  if PRIMARY zone's store local WINS in database, then can not
        //  do special casing for existing local UNTIL extract record
        //  and verify it is NOT LOCAL (local would need extraction)

        else if ( fexistingLocal )
        {
            DNS_DEBUG( WINS, (
                "Existing LOCAL WINS at %p -- no changes.\n",
                prrExisting ));
            return;
        }
#endif

        //
        //  if RR list has no record or non-LOCAL
        //      - existing local, takes precedence
        //      - otherwise install database RR, if any
        //

        prrNew = RR_FindNextRecord(
                    pZone->pZoneRoot,
                    type,
                    NULL,
                    0 );

        if ( !prrNew || !IS_WINS_RR_LOCAL(prrNew) )
        {
            if ( fexistingLocal )
            {
                DNS_DEBUG( WINS, (
                    "Existing LOCAL WINS at %p -- no changes.\n",
                    prrExisting ));
                return;
            }
            goto SetWins;
        }

        //
        //  database record is local -- from primary conversion
        //      - hack it from database
        //      - install it (it should usually match existing local)
        //

        ASSERT( prrNew == prrExisting );

        prrNew = RR_UpdateDeleteMatchingRecord(
                        pZone->pZoneRoot,
                        prrNew );
        ASSERT( prrNew );

        DNS_DEBUG( ANY, (
            "WARNING:  cut LOCAL WINS RR from zone %s RR list!\n"
            "    error if not on zone conversion!\n",
            pZone->pszZoneName ));

        if ( prrNew == prrExisting )
        {
            return;
            //goto SetWins;
        }
        else if ( fexistingLocal )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  LOCAL WINS RR in secondary zone %s RR list,\n"
                "    did NOT match existing RR at %p\n",
                pZone->pszZoneName,
                prrExisting ));
            RR_Free( prrExisting );
        }
    }

SetWins:

    //  always clear local load field

    pZone->pLocalWinsRR = NULL;

    //  if no WINS, done

    if ( !prrNew )
    {
        goto Failed;
    }

    //  if not existing, initialize

    if ( !prrExisting && prrNew )
    {
        if ( pZone->fReverse )
        {
            if ( !Nbstat_Initialize() )
            {
                DNS_PRINT((
                    "ERROR:  NBSTAT init failed updating zone NBSTAT record\n"
                    "    for zone %s.\n",
                    pZone->pszZoneName ));
                goto Failed;
            }
        }
        else if ( !Wins_Initialize() )
        {
            DNS_PRINT((
                "ERROR:  WINS init failed updating zone WINS record\n"
                "    for zone %s.\n",
                pZone->pszZoneName ));
            goto Failed;
        }
    }

    //  installed desired new WINS RR
    //  keep a flag indicating LOCAL WINS
    //      the purpose of this is simply to be able to test "locality"
    //      without holding zone lock and withoug having to get local (stack)
    //      copy of ptr to WINS to do check

    pZone->pWinsRR = prrNew;
    pZone->fLocalWins = IS_WINS_RR_LOCAL(prrNew);

    DNS_DEBUG( ANY, (
        "WINSTRACK:  Installed %s WINS(R) %p in zone %s\n",
        pZone->fLocalWins ? "LOCAL" : "",
        prrNew,
        pZone->pszZoneName ));
    return;

Failed:

    DNS_DEBUG( ANY, (
        "WINSTRACK:  ResetZoneWinsLookup() for zone %s is STOPPING WINS lookup\n"
        "    existing RR was %p\n",
        pZone->pszZoneName,
        prrExisting ));

    pZone->pWinsRR = NULL;
    pZone->fLocalWins = FALSE;
    return;
}

//
//  End of wins.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\zone.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    zone.h

Abstract:

    Domain Name System (DNS) Server

    Zone list definitions and declarations.

Author:

    Jim Gilroy (jamesg)     June 22, 1995

Revision History:

--*/


#ifndef _DNS_ZONE_INCLUDED_
#define _DNS_ZONE_INCLUDED_


//
//  DEVNOTE: ideally we'd have primary\secondary union
//      to avoid wasting memory
//

//
//  Zone secondary info
//

typedef struct
{
    PDNS_ADDR_ARRAY     aipMasters;
    PDNS_ADDR_ARRAY     MasterInfoArray;

    LPSTR               pszMasterIpString;

    DNS_ADDR            ipPrimary;
    DNS_ADDR            ipLastAxfrMaster;

    DWORD               dwLastSoaCheckTime;
    DWORD               dwNextSoaCheckTime;
    DWORD               dwExpireTime;

    DNS_ADDR            ipXfrBind;
    DNS_ADDR            ipNotifier;
    DNS_ADDR            ipFreshMaster;

    DWORD               dwZoneRecvStartTime;
    DWORD               dwBadMasterCount;

    //  flags

    BOOLEAN             fStale;
    BOOLEAN             fNeedAxfr;
    BOOLEAN             fSkipIxfr;
    CHAR                cIxfrAttempts;
    BOOLEAN             fSlowRetry;

}
ZONE_SECONDARY_INFO, *PZONE_SECONDARY_INFO;


//
//  Zone primary info
//

typedef struct
{
    PWSTR               pwsLogFile;

    //  Scavenging info

    BOOL                bAging;
    DWORD               dwAgingEnabledTime;         //  scavenging enabled on zone time
    DWORD               dwRefreshTime;              //  current refresh time (good during update)
    DWORD               dwNoRefreshInterval;        //  no-refresh interval in hours
    DWORD               dwRefreshInterval;          //  refresh interval in hours
    PDNS_ADDR_ARRAY     aipScavengeServers;

    //  DS info

    PWSTR               pwszZoneDN;

    LONGLONG            llSecureUpdateTime;

    BOOLEAN             fDsReload;
    BOOLEAN             fInDsWrite;

    CHAR                szLastUsn[ MAX_USN_LENGTH ];
}
ZONE_PRIMARY_INFO, *PZONE_PRIMARY_INFO;


//
//  Constants for zones that were created by dcpromo. These zones will
//  initially be migrated to the legacy partition but once the appropriate
//  built-in directory partition comes on-line the zone should be moved
//  again.
//

#define  DCPROMO_CONVERT_NONE       0
#define  DCPROMO_CONVERT_DOMAIN     1
#define  DCPROMO_CONVERT_FOREST     2


//
//  Zone information type
//
//  Win64 -- try to keep ptrs on 64-bit boundaries to save space
//

typedef struct
{
    LIST_ENTRY      ListEntry;
    LPSTR           pszZoneName;
    LPWSTR          pwsZoneName;

    //  Current database

    PCOUNT_NAME     pCountName;
    PDB_NODE        pZoneRoot;
    PDB_NODE        pTreeRoot;
    PDB_NODE        pZoneTreeLink;

    //  Load \ cleanup database

    PDB_NODE        pLoadZoneRoot;
    PDB_NODE        pLoadTreeRoot;
    PDB_NODE        pLoadOrigin;
    PDB_NODE        pOldTree;

    //  Database file

    LPSTR           pszDataFile;
    PWSTR           pwsDataFile;

    //  Self generated updates

    PUPDATE_LIST    pDelayedUpdateList;

    //  Current database records

    PDB_RECORD      pSoaRR;
    PDB_RECORD      pWinsRR;
    PDB_RECORD      pLocalWinsRR;

    //  Security descriptor -- DS only, others use default

    PSECURITY_DESCRIPTOR    pSD;
    DWORD                   dwSdLen;        //  length of SD blob

    //
    //  High usage properties -- put in their own DWORDs for efficiency
    //

    DWORD           fZoneType;
    BOOL            fDsIntegrated;
    DWORD           fAllowUpdate;

    //  RR count

    LONG            iRRCount;

    //
    //  Reverse lookup zone info
    //

    DNS_ADDR        ipReverse;      //  SubnetLength member will be set

    //
    //  Zone versions
    //      - current
    //      - loaded version from file, AXFR or DS, may not do incremental
    //          transfer beyond this
    //      - last transfered

    DWORD           dwSerialNo;
    DWORD           dwLoadSerialNo;
    DWORD           dwLastXfrSerialNo;

    //
    //  Adding new RR
    //      - file load, admin tool, zone transfer
    //

    DWORD           dwNewSerialNo;
    DWORD           dwDefaultTtl;
    DWORD           dwDefaultTtlHostOrder;

    //
    //  Master transfer info
    //

    PDNS_ADDR_ARRAY     aipNotify;
    PDNS_ADDR_ARRAY     aipSecondaries;
    PDNS_ADDR_ARRAY     aipNameServers;
    DWORD               dwNextTransferTime;

    //
    //  DS only info
    //

    PWSTR           pwszZoneDN;
    PVOID           pDpInfo;            //  PDNS_DP_INFO - naming context
    PGUID           pZoneObjectGuid; 

    //
    //  Primary only info
    //

    DWORD           dwPrimaryMarker;

        PWSTR           pwsLogFile;
        HANDLE          hfileUpdateLog;
        LONG            iUpdateLogCount;

        //  Scavenging info

        BOOL            bAging;
        DWORD           dwRefreshTime;              //  current refresh time (good during update)
        DWORD           dwNoRefreshInterval;        //  no-refresh interval in hours
        DWORD           dwRefreshInterval;          //  refresh interval in hours
        DWORD           dwAgingEnabledTime;         //  scavenging enabled on zone time
        PDNS_ADDR_ARRAY aipScavengeServers;

        LONGLONG        llSecureUpdateTime;

        DWORD           dwHighDsSerialNo;

        BOOLEAN         fDsReload;
        BOOLEAN         fInDsWrite;
        UCHAR           ucDsRecordVersion;
        BOOLEAN         fLogUpdates;                //  standard primary also

        CHAR            szLastUsn[ MAX_USN_LENGTH ];

        PDNS_ADDR_ARRAY aipAutoCreateNS;            //  servers who may autocreate

    //  End primary only info

    //
    //  Secondary transfer info
    //

    DWORD           dwSecondaryMarker;

        PDNS_ADDR_ARRAY     aipMasters;
        PDNS_ADDR_ARRAY     aipLocalMasters;

        LPSTR               pszMasterIpString;

        DNS_ADDR            ipPrimary;
        DNS_ADDR            ipNotifier;
        DNS_ADDR            ipFreshMaster;
        DNS_ADDR            ipXfrBind;
        DNS_ADDR            ipLastAxfrMaster;

        DWORD           dwNextDsPollTime;               //  from DNS_TIME()
        DWORD           dwLastSoaCheckTime;             //  from DNS_TIME()
        DWORD           dwNextSoaCheckTime;             //  from DNS_TIME()
        DWORD           dwLastSuccessfulSoaCheckTime;   //  from time()
        DWORD           dwLastSuccessfulXfrTime;        //  from time()
        DWORD           dwExpireTime;
        DWORD           dwZoneRecvStartTime;
        DWORD           dwBadMasterCount;
        DWORD           dwFastSoaChecks;

        //  secondary flags

        BOOLEAN         fStale;
        BOOLEAN         fNotified;
        BOOLEAN         fNeedAxfr;
        BOOLEAN         fSkipIxfr;
        CHAR            cIxfrAttempts;
        BOOLEAN         fSlowRetry;

    //  End secondary only info

    //
    //  Forwarder only info - forwarders also use secondary info
    //

    DWORD           dwForwarderMarker;

    DWORD           dwForwarderTimeout;
    BOOLEAN         fForwarderSlave;
    UCHAR           unused1;
    UCHAR           unused2;
    UCHAR           unused3;

    //  End forwarder info

    //
    //  Flags -- static \ properties
    //

    DWORD           dwFlagMarker;
    DWORD           dwDcPromoConvert;

    UCHAR           cZoneNameLabelCount;
    BOOLEAN         fReverse;
    BOOLEAN         fAutoCreated;
    BOOLEAN         fLocalWins;

    BOOLEAN         fSecureSecondaries;
    UCHAR           fNotifyLevel;
    BOOLEAN         bContainsDnsSecRecords;

    //
    //  Flags -- dynamic
    //

    DWORD           dwLockingThreadId;
    CHAR            fLocked;
    BOOLEAN         fUpdateLock;
    BOOLEAN         fXfrRecvLock;
    BOOLEAN         fFileWriteLock;

    BOOLEAN         fDirty;
    BOOLEAN         fRootDirty;
    BOOLEAN         bNsDirty;
    UCHAR           cDeleted;

    BOOLEAN         fPaused;
    BOOLEAN         fShutdown;
    BOOLEAN         fEmpty;
    BOOLEAN         fDisableAutoCreateLocalNS;

    BOOLEAN         fSelfTested;

    DWORD           dwDeleteDetectedCount;  //  # times zone missing from DP
    DWORD           dwLastDpVisitTime;      //  visit time for DP enumeration

    //
    //  Update list, keep permanent in zone block
    //

    UPDATE_LIST     UpdateList;

    //
    //  for deleted zones
    //

    LPWSTR          pwsDeletedFromHost;

    //
    //  Debugging aids
    //

    LPSTR           pszBreakOnUpdateName;

    //
    //  Event control
    //
    
    PDNS_EVENTCTRL  pEventControl;

#if 0
    //
    //  union of primary and secondary info
    //

    union   _TypeUnion
    {
        ZONE_SECONDARY_INFO     Sec;
        ZONE_PRIMARY_INFO       Pri;
    }
    U;
#endif

}
ZONE_INFO, * PZONE_INFO;


//
//  Markers to make it easier to debug zone struct
//

#define ZONE_PRIMARY_MARKER         (0x11111111)
#define ZONE_SECONDARY_MARKER       (0x22222222)
#define ZONE_FORWARDER_MARKER       (0x33333333)
#define ZONE_FLAG_MARKER            (0xf1abf1ab)


//
//  DS Primaries overlay some of the secondary zone fields
//
//  Note the choice of NextSoaCheckTime is REQUIRED to calculate
//  the correct timeout on the Wait in the zone control thread.
//  Do NOT change it to another value.
//

#define ZONE_NEXT_DS_POLL_TIME(pZone)       ((pZone)->dwNextDsPollTime)

//
//  Reuse some secondary fields for primary
//

#define LAST_SEND_TIME( pzone )     ((pzone)->dwZoneRecvStartTime)


//
//  Zone type queries
//

#define IS_ZONE_CACHE(pZone)            \
                ((pZone)->fZoneType == DNS_ZONE_TYPE_CACHE)
#define IS_ZONE_PRIMARY(pZone)          \
                ((pZone)->fZoneType == DNS_ZONE_TYPE_PRIMARY)
#define IS_ZONE_SECONDARY(pZone)        \
                ((pZone)->fZoneType == DNS_ZONE_TYPE_SECONDARY  \
              || (pZone)->fZoneType == DNS_ZONE_TYPE_STUB)
#define IS_ZONE_STUB(pZone)             \
                ((pZone)->fZoneType == DNS_ZONE_TYPE_STUB)
#define IS_ZONE_FORWARDER(pZone)        \
                ((pZone)->fZoneType == DNS_ZONE_TYPE_FORWARDER)

#define IS_ZONE_AUTHORITATIVE(pZone)    \
                ((pZone)->fZoneType != DNS_ZONE_TYPE_CACHE              \
                    && (pZone)->fZoneType != DNS_ZONE_TYPE_FORWARDER    \
                    && (pZone)->fZoneType != DNS_ZONE_TYPE_STUB)

//  NOTAUTH zones are special zone types that are not truly authoritative.
//  The cache zone is not a NOTAUTH zone.

#define IS_ZONE_NOTAUTH(pZone)                                      \
                ( (pZone)->fZoneType == DNS_ZONE_TYPE_FORWARDER     \
                    || (pZone)->fZoneType == DNS_ZONE_TYPE_STUB )

#define ZONE_NEEDS_MASTERS(pZone)       \
                ( (pZone)->fZoneType == DNS_ZONE_TYPE_SECONDARY         \
                    || (pZone)->fZoneType == DNS_ZONE_TYPE_STUB         \
                    || (pZone)->fZoneType == DNS_ZONE_TYPE_FORWARDER )

//  ZONE_MASTERS returns a PDNS_ADDR_ARRAY ptr to the zone's master IP list.
//      DS-integrated stub zones may have a local masters list which 
//      overrides the list stored in the DS.

#define ZONE_MASTERS( pZone )                                               \
                ( ( IS_ZONE_STUB( pZone ) && ( pZone )->aipLocalMasters ) ? \
                    ( pZone )->aipLocalMasters :                            \
                    ( pZone )->aipMasters )

#define IS_ZONE_REVERSE(pZone)      ( (pZone)->fReverse )
#define IS_ZONE_WINS(pZone)         ( !(pZone)->fReverse && (pZone)->pWinsRR )
#define IS_ZONE_NBSTAT(pZone)       ( (pZone)->fReverse && (pZone)->pWinsRR )

#define IS_ROOT_ZONE(pZone)         ( (DATABASE_ROOT_NODE)->pZone == (PVOID)pZone )

#define IS_ZONE_DSINTEGRATED(pZone) ( (pZone)->fDsIntegrated )

#define IS_ZONE_DNSSEC(pZone)       ( (pZone)->bContainsDnsSecRecords )


//
//  Zone status checks
//

#define IS_ZONE_DELETED(pZone)          ( (pZone)->cDeleted )
#define IS_ZONE_PAUSED(pZone)           ( (pZone)->fPaused )
#define IS_ZONE_SHUTDOWN(pZone)         ( (pZone)->fShutdown )
#define IS_ZONE_INACTIVE(pZone)         ( (pZone)->fPaused || (pZone)->fShutdown )

#define IS_ZONE_EMPTY(pZone)            ( (pZone)->fEmpty )
#define IS_ZONE_STALE(pZone)            ( (pZone)->fStale )
#define IS_ZONE_DIRTY(pZone)            ( (pZone)->fDirty )
#define IS_ZONE_ROOT_DIRTY(pZone)       ( (pZone)->fDirty )
#define IS_ZONE_NS_DIRTY(pZone)         ( (pZone)->bNsDirty )
#define IS_ZONE_DSRELOAD(pZone)         ( (pZone)->fDsReload )

#define IS_ZONE_LOADING(pZone)          ( (pZone)->pLoadTreeRoot )

#define IS_ZONE_LOCKED(pZone)           ( (pZone)->fLocked )
#define IS_ZONE_LOCKED_FOR_WRITE(pZone) ( (pZone)->fLocked < 0 )
#define IS_ZONE_LOCKED_FOR_READ(pZone)  ( (pZone)->fLocked > 0 )

#define IS_ZONE_LOCKED_FOR_UPDATE(pZone)    \
            ( IS_ZONE_LOCKED_FOR_WRITE(pZone) && (pZone)->fUpdateLock )

#define IS_ZONE_LOCKED_FOR_WRITE_BY_THREAD(pZone)   \
            ( IS_ZONE_LOCKED_FOR_WRITE(pZone) &&    \
              (pZone)->dwLockingThreadId == GetCurrentThreadId() )

#define HAS_ZONE_VERSION_BEEN_XFRD(pZone) \
            ( (pZone)->dwLastXfrSerialNo == (pZone)->dwSerialNo )


//
//  Zone status set
//

#define RESUME_ZONE(pZone)          ( (pZone)->fPaused = FALSE )
#define PAUSE_ZONE(pZone)           ( (pZone)->fPaused = TRUE )

#define SHUTDOWN_ZONE(pZone)        ( (pZone)->fShutdown = TRUE )
#define STARTUP_ZONE(pZone)         ( (pZone)->fShutdown = FALSE )

#define SET_EMPTY_ZONE(pZone)       ( (pZone)->fEmpty = TRUE )
#define MARK_DIRTY_ZONE(pZone)      ( (pZone)->fDirty = TRUE )
#define MARK_ZONE_NS_DIRTY(pZone)   ( (pZone)->bNsDirty = TRUE )

#define CLEAR_EMPTY_ZONE(pZone)     ( (pZone)->fEmpty = TRUE )
#define CLEAR_DIRTY_ZONE(pZone)     ( (pZone)->fDirty = TRUE )
#define CLEAR_ZONE_NS_DIRTY(pZone)  ( (pZone)->bNsDirty = FALSE )


//
//  Root-Hints uses bNsDirty flag to handle issue of needing DS write
//
//  This is a hack, until RootHints updates are handled as in
//  ordinary zone, rather than written atomically to DS
//

#define IS_ROOTHINTS_DS_DIRTY(pZone)        ( (pZone)->bNsDirty )
#define MARK_ROOTHINTS_DS_DIRTY(pZone)      ( (pZone)->bNsDirty = TRUE )
#define CLEAR_ROOTHINTS_DS_DIRTY(pZone)     ( (pZone)->bNsDirty = FALSE )


//
//  Zone refresh
//

#define REFRESH_ZONE( pZone )                           \
        {                                               \
            (pZone)->fEmpty     = FALSE;                \
            (pZone)->fShutdown  = FALSE;                \
            (pZone)->fStale     = FALSE;                \
            (pZone)->fNotified  = FALSE;                \
            DnsAddr_Clear( &( pZone )->ipNotifier );    \
            (pZone)->cIxfrAttempts = 0;                 \
        }

#define SET_DSRELOAD_ZONE(pZone)     ( (pZone)->fDsReload = TRUE )
#define CLEAR_DSRELOAD_ZONE(pZone)   ( (pZone)->fDsReload = FALSE )

#define SET_ZONE_VISIT_TIMESTAMP( pZone, dwTimeStamp )      \
        ( pZone )->dwLastDpVisitTime = dwVisitStamp;        \
        ( pZone )->dwDeleteDetectedCount = 0;

//
//  Zone list critical section
//

extern CRITICAL_SECTION    csZoneList;


//
//  Zone creation options
//

#define ZONE_CREATE_LOAD_EXISTING       0x00000001  //  primary only
#define ZONE_CREATE_DEFAULT_RECORDS     0x00000002  //  primary only
#define ZONE_CREATE_IMPERSONATING       0x10000000  //  thread in client context
#define ZONE_DELETE_IMPERSONATING       ZONE_CREATE_IMPERSONATING

#define DNS_ZONE_LOAD_IMPERSONATING     0x10000000


//
//  Per server Master flags
//

#define MASTER_NO_IXFR          (0x10000000)

#define MASTER_SENT             (0x00000001)
#define MASTER_RESPONDED        (0x00000002)
#define MASTER_NOTIFY           (0x00000004)

#define MASTER_SAME_VERSION     (0x00000010)
#define MASTER_NEW_VERSION      (0x00000020)



//
//  Zone list routines (zonelist.c)
//

BOOL
Zone_ListInitialize(
    VOID
    );

VOID
Zone_ListShutdown(
    VOID
    );

VOID
Zone_ListMigrateZones(
    VOID
    );

VOID
Zone_ListInsertZone(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Zone_ListRemoveZone(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_Rename(
    IN OUT  PZONE_INFO      pZone,
    IN      LPCSTR          pszNewZoneName,
    IN      LPCSTR          pszNewZoneFile
    );

VOID
Zone_ListDelete(
    VOID
    );

PZONE_INFO
Zone_ListGetNextZoneEx(
    IN      PZONE_INFO      pZone,
    IN      BOOL            fAlreadyLocked
    );

#define Zone_ListGetNextZone( pZone )   Zone_ListGetNextZoneEx( pZone, FALSE )

BOOL
Zone_DoesDsIntegratedZoneExist(
    VOID
    );


//
//  Zone filtering and multizone technology (zonelist.c)
//

DWORD
Zone_GetFilterForMultiZoneName(
    IN      LPSTR           pszZoneName
    );

BOOL
FASTCALL
Zone_CheckZoneFilter(
    IN      PZONE_INFO                  pZone,
    IN      PDNS_RPC_ENUM_ZONES_FILTER  pFilter
    );

PZONE_INFO
Zone_ListGetNextZoneMatchingFilter(
    IN      PZONE_INFO                  pLastZone,
    IN      PDNS_RPC_ENUM_ZONES_FILTER  pFilter
    );


//
//  Special zone type conversion (zonerpc.c)
//

DNS_STATUS
Zone_DcPromoConvert(
    IN OUT  PZONE_INFO      pZone
    );


//
//  Zone routines
//


typedef struct
{
    union
    {
        struct
        {
            DWORD           dwTimeout;
            BOOLEAN         fSlave;
        } Forwarder;
    };
} ZONE_TYPE_SPECIFIC_INFO, * PZONE_TYPE_SPECIFIC_INFO;


DNS_STATUS
Zone_Create(
    OUT     PZONE_INFO *                ppZone,
    IN      DWORD                       dwZoneType,
    IN      PCHAR                       pchZoneName,
    IN      DWORD                       cchZoneNameLen,     OPTIONAL
    IN      DWORD                       dwCreateFlags,
    IN      PDNS_ADDR_ARRAY             aipMasters,
    IN      BOOL                        fUseDatabase,
    IN      PDNS_DP_INFO                pDpInfo,            OPTIONAL
    IN      PCHAR                       pchFileName,        OPTIONAL
    IN      DWORD                       cchFileNameLen,     OPTIONAL
    IN      PZONE_TYPE_SPECIFIC_INFO    pTypeSpecificInfo,  OPTIONAL
    OUT     PZONE_INFO *                ppExistingZone      OPTIONAL
    );

DNS_STATUS
Zone_Create_W(
    OUT     PZONE_INFO *        ppZone,
    IN      DWORD               dwZoneType,
    IN      PWSTR               pwsZoneName,
    IN      PDNS_ADDR_ARRAY     aipMasters,
    IN      BOOL                fDsIntegrated,
    IN      PWSTR               pwsFileName
    );

VOID
Zone_DeleteZoneNodes(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Zone_Delete(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwCreateFlags
    );

VOID
Zone_Free(
    IN OUT  PZONE_INFO      pZone
    );

PZONE_INFO
Zone_FindZoneByName(
    IN      LPSTR           pszZoneName
    );

DNS_STATUS
Zone_RootCreate(
    IN OUT  PZONE_INFO      pZone,
    OUT     PZONE_INFO *    ppExistingZone      OPTIONAL
    );

DNS_STATUS
Zone_ResetType(
    IN OUT  PZONE_INFO          pZone,
    IN      DWORD               dwZoneType,
    IN      PDNS_ADDR_ARRAY     aipMasters
    );

DNS_STATUS
Zone_ResetRegistryType(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_SetMasters(
    IN OUT  PZONE_INFO      pZone,
    IN      PDNS_ADDR_ARRAY aipMasters,
    IN      BOOL            fLocalMasters,
    IN      DWORD           dwRegFlags
    );

DNS_STATUS
Zone_DatabaseSetup(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           fDsIntegrated,
    IN      PCHAR           pchFileName,    OPTIONAL
    IN      DWORD           cchFileNameLen, OPTIONAL
    IN      DWORD           dwCreateFlags,  OPTIONAL
    IN      PDNS_DP_INFO    pDpInfo,        OPTIONAL
    IN      DWORD           dwDpFlags,      OPTIONAL
    IN      LPSTR           pszDpFqdn       OPTIONAL
    );

DNS_STATUS
Zone_DatabaseSetup_W(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           fDsIntegrated,
    IN      PWSTR           pwsFileName,
    IN      DWORD           dwCreateFlags,  OPTIONAL
    IN      PDNS_DP_INFO    pDpInfo,        OPTIONAL
    IN      DWORD           dwDpFlags,      OPTIONAL
    IN      LPSTR           pszDpFqdn       OPTIONAL
    );

DNS_STATUS
Zone_SetSecondaries(
    IN OUT  PZONE_INFO          pZone,
    IN      DWORD               fSecureSecondaries,
    IN      PDNS_ADDR_ARRAY     aipSecondaries,
    IN      DWORD               fNotifyLevel,
    IN      PDNS_ADDR_ARRAY     aipNotify,
    IN      DWORD               dwRegistryFlags
    );

VOID
Zone_SetAgingDefaults(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_WinsSetup(
    IN OUT  PZONE_INFO      pZone,
    IN      BOOL            fWins,
    IN      DWORD           cWinsServers,
    IN      PDNS_ADDR       pipWinsServers
    );

DNS_STATUS
Zone_NbstatSetup(
    IN OUT  PZONE_INFO      pZone,
    IN      BOOL            fUseNbstat,
    IN      PCHAR           pchNbstatDomain,    OPTIONAL
    IN      DWORD           cchNbstatDomain     OPTIONAL
    );

DNS_STATUS
Zone_WriteZoneToRegistry(
    PZONE_INFO      pZone
    );


//
//  Utils to keep zone info current
//

DNS_STATUS
Zone_ValidateMasterIpList(
    IN      PDNS_ADDR_ARRAY     aipMasters
    );

INT
Zone_SerialNoCompare(
    IN      DWORD           dwSerial1,
    IN      DWORD           dwSerial2
    );

BOOL
Zone_IsIxfrCapable(
    IN      PZONE_INFO      pZone
    );

VOID
Zone_ResetVersion(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwNewSerial
    );

VOID
Zone_UpdateSoa(
    IN OUT  PZONE_INFO      pZone,
    IN      PDB_RECORD      pSoaRR
    );

VOID
Zone_IncrementVersion(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Zone_UpdateVersionAfterDsRead(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwVersionRead,
    IN      BOOL            fLoad,
    IN      DWORD           dwPreviousLoadSerial
    );

VOID
Zone_UpdateInfoAfterPrimaryTransfer(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwStartTime
    );

#if 0
PDB_NODE
Zone_GetNSInfo(
    IN      PDB_NAME        pName,
    IN      PZONE_INFO      pZone,
    IN      struct _DNS_MSGINFO *   pSuspendMsg     OPTIONAL
    );
#endif

DNS_STATUS
Zone_GetZoneInfoFromResourceRecords(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Zone_WriteBack(
    IN      PZONE_INFO      pZone,
    IN      BOOL            fShutdown
    );

VOID
Zone_WriteBackDirtyZones(
    IN      BOOL            fShutdown
    );


//
//  Auto reverse zone creation
//

DNS_STATUS
Zone_CreateAutomaticReverseZones(
    VOID
    );

DNS_STATUS
Zone_CreateAutomaticReverseZone(
    IN      LPSTR           pszZoneName
    );


//
//  Admin action zone create / delete utils
//

BOOL
Zone_DeleteCacheZone(
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
Zone_CreateNewPrimary(
    OUT     PZONE_INFO *    ppZone,
    IN      LPSTR           pszZoneName,
    IN      LPSTR           pszAdminEmailName,
    IN      LPSTR           pszFileName,
    IN      DWORD           dwDsIntegrated,
    IN      PDNS_DP_INFO    pDpInfo,            OPTIONAL
    IN      DWORD           dwCreateFlags
    );


//
//  Default zone record management
//

BOOLEAN
Zone_SetAutoCreateLocalNS(
    IN      PZONE_INFO      pZone
    );

VOID
Zone_CreateDefaultZoneFileName(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_CreateDefaultSoa(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszAdminEmailName
    );

DNS_STATUS
Zone_CreateDefaultNs(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Zone_UpdateOwnRecords(
    IN      BOOL            fIpAddressChange
    );

VOID
Zone_CreateDelegationInParentZone(
    IN      PZONE_INFO      pZone
    );

//
//  Zone load\unload
//

DNS_STATUS
Zone_ActivateLoadedZone(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_CleanupFailedLoad(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_PrepareForLoad(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_Load(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_DumpData(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_ClearCache(
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
Zone_LoadRootHints(
    VOID
    );

DNS_STATUS
Zone_WriteBackRootHints(
    IN      BOOL            fForce
    );

BOOL
Zone_VerifyRootHintsBeforeWrite(
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
Zone_SelfTestCheck(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Rpc_ZoneResetToDsPrimary(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwLoadOptions,
    IN      DWORD           dwDpFlags,
    IN      LPSTR           pszDpFqdn
    );


//
//  Zone locking
//
//  Lock zones during read and write for info that is read or written
//  by threads other than RPC thread.
//
//  If can make read and write access completely unitary then this
//  isn't necessary, but currently have some info, that contains both a
//  count and an array.
//
//  Note:  currently overloading zone list CS, but no particular reason
//          not to as zone list access is rare, and is usually done in
//          RPC thread as is most of this zone update stuff

#define Zone_UpdateLock(pZone)    EnterCriticalSection( &csZoneList );
#define Zone_UpdateUnlock(pZone)  LeaveCriticalSection( &csZoneList );

//
//  Zone lock flags
//

#define LOCK_FLAG_UPDATE            0x00000001

#define LOCK_FLAG_XFR_RECV          0x00000100

#define LOCK_FLAG_FILE_WRITE        0x00001000

#define LOCK_FLAG_IGNORE_THREAD     0x01000000


//
//  Zone locking routines
//
//  Need to avoid simultaneous access to zone records for
//      - zone transfer send
//      - zone transfer recv
//      - admin changes
//
//  Allow multiple transfer sends, which don't change zone, at one time,
//  but avoid any changes during send.
//
//  Implementation:
//      - hold critical section ONLY during test and set of lock bit
//      - lock bit itself indicates zone is locked
//      - individual flags for locking operations
//

BOOL
Zone_LockInitialize(
    VOID
    );

BOOL
Zone_LockForWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      DWORD           dwMaxWait,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Zone_UnlockAfterWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Zone_TransferWriteLockEx(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

BOOL
Zone_AssumeWriteLockEx(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

BOOL
Zone_LockForReadEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      DWORD           dwMaxWait,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Zone_UnlockAfterReadEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

BOOL
Zone_LockForFileWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwMaxWait,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Zone_UnlockAfterFileWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Dbg_ZoneLock(
    IN      LPSTR           pszHeader,
    IN      PZONE_INFO      pZone
    );


//
//  Macros (real functions are Zone_...Ex()
//

#define Zone_TransferWriteLock(pZone) \
        Zone_TransferWriteLockEx( (pZone), __FILE__, __LINE__)

#define Zone_AssumeWriteLock(pZone) \
        Zone_AssumeWriteLockEx( (pZone), __FILE__, __LINE__)

//  Admin updates will get default of 10s wait

#define Zone_LockForAdminUpdate(pZone) \
        Zone_LockForWriteEx( (pZone), LOCK_FLAG_UPDATE, 10000, __FILE__, __LINE__)

#define Zone_UnlockAfterAdminUpdate(pZone) \
        Zone_UnlockAfterWriteEx( (pZone), LOCK_FLAG_UPDATE, __FILE__, __LINE__)

//  Non-admin updates get no wait

#define Zone_LockForUpdate(pZone) \
        Zone_LockForWriteEx( (pZone), LOCK_FLAG_UPDATE, 0, __FILE__, __LINE__)

#define Zone_UnlockAfterUpdate(pZone) \
        Zone_UnlockAfterWriteEx( (pZone), LOCK_FLAG_UPDATE, __FILE__, __LINE__)

//  DS read gets small wait, to give preference for getting it done now

#define Zone_LockForDsUpdate(pZone) \
        Zone_LockForWriteEx( (pZone), LOCK_FLAG_UPDATE, 5000, __FILE__, __LINE__)

#define Zone_UnlockAfterDsUpdate(pZone) \
        Zone_UnlockAfterWriteEx( (pZone), LOCK_FLAG_UPDATE, __FILE__, __LINE__)


//  XFR recv will get default of 1s wait
//      as it may be in worker thread

#define Zone_LockForXfrRecv(pZone) \
        Zone_LockForWriteEx( (pZone), LOCK_FLAG_XFR_RECV, 1000, __FILE__, __LINE__)

#define Zone_UnlockAfterXfrRecv(pZone) \
        Zone_UnlockAfterWriteEx( (pZone), LOCK_FLAG_XFR_RECV, __FILE__, __LINE__)

//  File write gets 3s default wait

#define Zone_LockForFileWrite(pZone) \
        Zone_LockForFileWriteEx( (pZone), 3000 , __FILE__, __LINE__)

#define Zone_UnlockAfterFileWrite(pZone) \
        Zone_UnlockAfterFileWriteEx( (pZone), __FILE__, __LINE__)


//  XFR send gets 50ms read lock
//      this is enough time to clear an existing DS update
//      but allows us to take the wait within recv thread

#define Zone_LockForXfrSend(pZone) \
        Zone_LockForReadEx( (pZone), 0, 50, __FILE__, __LINE__)

#define Zone_UnlockAfterXfrSend(pZone) \
        Zone_UnlockAfterReadEx( (pZone), 0, __FILE__, __LINE__)


//
//  Zone debug macros
//

#if DBG
#define DNS_DEBUG_ZONEFLAGS( dwDbgLevel, pZone, pszContext )                \
    DNS_DEBUG( dwDbgLevel, (                                                \
        "zone flags for %s (%p) - %s\n"                                     \
        "\tpaused=%d shutdown=%d empty=%d dirty=%d locked=%d deleted=%d\n", \
        pZone->pszZoneName,                                                 \
        pZone,                                                              \
        pszContext ? pszContext : "",                                       \
        ( int ) pZone->fPaused,                                             \
        ( int ) pZone->fShutdown,                                           \
        ( int ) pZone->fEmpty,                                              \
        ( int ) pZone->fDirty,                                              \
        ( int ) pZone->fLocked,                                             \
        ( int ) pZone->cDeleted ));
#else
#define DNS_DEBUG_ZONEFLAGS( dwDbgLevel, pZone, pszContext )
#endif


#endif  //  _DNS_ZONE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\wrappers.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    wrappers.c

Abstract:

    Domain Name System (DNS) Server

    Short utility wrapper routines

Author:

    Jeff Westhead (jwesth)  June, 2000

Revision History:

    jwesth      June 2001       file creation

--*/


//
//  Includes
//


#include "dnssrv.h"


//
//  Functions
//



DNS_STATUS
DnsInitializeCriticalSection(
    IN OUT  LPCRITICAL_SECTION  pCritSec
    )
/*++

Routine Description:

    Attempt to initialize a critical section. This can throw an exception
    if the system is out of memory. In this case, retry several times then
    return DNS_ERROR_NO_MEMORY.

Arguments:

    pCritSec -- critical section to initialize

Return Value:

    ERROR_SUCCESS or DNS_ERROR_NO_MEMORY

--*/
{
    DNS_STATUS      status = DNS_ERROR_NO_MEMORY;
    int             retryCount;

    for ( retryCount = 0;
          status != ERROR_SUCCESS && retryCount < 10;
          ++retryCount )
    {
        //
        //  If this is a retry, execute a short sleep to give the system
        //  time to recover some free memory. This is wishful thinking
        //  but we really don't have anything else to try at this point.
        //

        if ( retryCount )
        {
            Sleep( 500 );
        }

        //
        //  Assume any exception thrown means out of memory. Currently
        //  this is the only exception that InitializeCriticalSection
        //  will throw.
        //

        __try
        {
            ASSERT( g_ProcessorCount > 0 );
            
            if ( InitializeCriticalSectionAndSpinCount(
                    pCritSec,
                    g_ProcessorCount < 12
                        ? ( g_ProcessorCount + 1 ) * 1000
                        : 12000 ) )
            {
                status = ERROR_SUCCESS;
            }
            else
            {
                status = DNS_ERROR_NO_MEMORY;
            }
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            status = DNS_ERROR_NO_MEMORY;
        }
    }

    if ( retryCount != 1 )
    {
        DNS_DEBUG( INIT, (
            "DnsInitializeCriticalSection retry count = %d\n",
            retryCount ));
        ASSERT( retryCount == 1 );
    }

    return status;
}   //  DnsInitializeCriticalSection


//
//  End dpart.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\zonelist.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    zonelist.c

Abstract:

    Domain Name System (DNS) Server

    Zone list routines.

Author:

    Jim Gilroy (jamesg)     July 3, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Zone list globals
//
//  Zones kept in sorted (alphabetical) double linked list.
//  Forward through the list corresponds to higher alphabetical
//  entry.
//

LIST_ENTRY  listheadZone;

DWORD   g_ZoneCount;

CRITICAL_SECTION    csZoneList;



BOOL
Zone_ListInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize the DNS zonelist.

Arguments:

    None.

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    g_ZoneCount = 0;

    InitializeListHead( ( PLIST_ENTRY ) &listheadZone );

    if ( DnsInitializeCriticalSection( &csZoneList ) != ERROR_SUCCESS )
    {
        return FALSE;
    }

    return TRUE;
}



VOID
Zone_ListShutdown(
    VOID
    )
/*++

Routine Description:

    Cleanup zone list for restart.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DeleteCriticalSection( &csZoneList );
}



VOID
Zone_ListInsertZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Insert zone in list

Arguments:

    pZone -- ptr to zone to insert

Return Value:

    None.

--*/
{
    PZONE_INFO  pZoneNext;

    ASSERT( pZone->pszZoneName );

    //
    //  keep zones alphabetized to aid admin tool
    //      - forward through list is higher alpha value
    //      - keeps cache or root at front
    //

    EnterCriticalSection( &csZoneList );
    pZoneNext = NULL;

    while ( 1 )
    {
        pZoneNext = Zone_ListGetNextZoneEx( pZoneNext, TRUE );
        if ( ! pZoneNext )
        {
            pZoneNext = (PZONE_INFO)&listheadZone;
            break;
        }
        if ( 0 > wcsicmp_ThatWorks( pZone->pwsZoneName, pZoneNext->pwsZoneName) )
        {
            break;
        }
    }

    InsertTailList( (PLIST_ENTRY)pZoneNext, (PLIST_ENTRY)pZone );
    g_ZoneCount++;

    LeaveCriticalSection( &csZoneList );

    IF_DEBUG( OFF )
    {
        Dbg_ZoneList( "Zone list after insert.\n" );
    }
}



VOID
Zone_ListRemoveZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Remove zone from zone list

Arguments:

    pZone -- ptr to zone to remove from list

Return Value:

    None.

--*/
{
    PZONE_INFO  pzoneCurrent;

    //
    //  walk zone list, until match zone
    //

    EnterCriticalSection( &csZoneList );
    pzoneCurrent = NULL;

    while ( pzoneCurrent = Zone_ListGetNextZone(pzoneCurrent) )
    {
        if ( pzoneCurrent == pZone )
        {
            RemoveEntryList( (PLIST_ENTRY)pZone );
            g_ZoneCount--;
            ASSERT( (INT)g_ZoneCount >= 0 );
            break;
        }
    }
    ASSERT( pzoneCurrent == pZone );
    LeaveCriticalSection( &csZoneList );
}



PZONE_INFO
Zone_ListGetNextZoneEx(
    IN      PZONE_INFO      pZone,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Get next zone in zone list.

    This function allows simple walk of zone list.

Arguments:

    pZone - current zone in list, or NULL to start at beggining of list

    fAlreadyLocked - pass TRUE if the caller already owns the 
                     csZoneList critical section

Return Value:

    Ptr to next zone in list.
    NULL when reach end of zone list.

--*/
{
    //  if no zone specified, start at begining of list?

    if ( !pZone )
    {
        pZone = (PZONE_INFO) &listheadZone;
    }

    //  get next zone

    if ( !fAlreadyLocked )
    {
        EnterCriticalSection( &csZoneList );
    }

    pZone = (PZONE_INFO) pZone->ListEntry.Flink;

    if ( !fAlreadyLocked )
    {
        LeaveCriticalSection( &csZoneList );
    }

    //  return NULL at end of list

    if ( pZone == (PZONE_INFO)&listheadZone )
    {
        return NULL;
    }
    return pZone;
}



BOOL
Zone_DoesDsIntegratedZoneExist(
    VOID
    )
/*++

Routine Description:

    Determine if any DS integrated zones exist.

    Note, this does not include root-hints "zone".
    Since the purpose of the function is to determine if it is
    safe to revert to booting from file, a DS backed root-hints
    zone should not be blocking.  It can be converted separately.

Arguments:

    None

Return Value:

    TRUE is DS integrated zone exists.
    FALSE otherwise.

--*/
{
    PZONE_INFO  pzone;
    BOOL        haveDs = FALSE;

    //
    //  walk zone list, until find DS zone or reach end
    //

    EnterCriticalSection( &csZoneList );
    pzone = NULL;

    while ( pzone = Zone_ListGetNextZone( pzone ) )
    {
        if ( pzone->fDsIntegrated && IS_ZONE_PRIMARY( pzone ) )
        {
            haveDs = TRUE;
            break;
        }
    }
    LeaveCriticalSection( &csZoneList );
    return haveDs;
}



VOID
Zone_ListMigrateZones(
    VOID
    )
/*++

Routine Description:

    This function should be called during zone creation to determine
    if the zones should be migrated from the under the CCS regkey to
    the Software regkey.

    This function is located in the zonelist module because it needs
    access to zonelist internals: ie. the current zone count and the
    critsec used to grab access to the zone list.

    Background: originally the DNS server stored all zone information
    under the CCS regkey, but CCS in the system hive, which has a
    hard limit of 16 MB. At 7000 or so zones you will hit this limit and
    render the server unbootable. So as a Service Pack fix, when the
    number of zones reaches an arbitrary number, we automagically
    migrate all zones in the registry from CCS to Software. The migration
    is not controllable by the administrator. It is also not reversible.

    For Whistler:  we take this a step further. If you create a zone 
    after server startup, we immediately migrate all zones to the
    SW key if they are currently in the CCS key. This will take care
    of upgrades from W2K to Whistler. Pure Whistler installs will start
    using the Software key from day one, and so will never migrate.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "Zone_ListMigrateZones" )

    PZONE_INFO  pZone = NULL;
    DNS_STATUS  rc;

    //
    //  Determine if a migration is necessary. Migration is not allowed 
    //  until all zones have been loaded out of the registry.
    //

    if ( g_ServerState != DNS_STATE_RUNNING ||
        Reg_GetZonesSource() == DNS_REGSOURCE_SW )
    {
        goto Done;
    }

    //
    //  Force write-back of all zones to the Software registry key
    //  and then delete zones from the CurrentControlSet key.
    //

    DNS_DEBUG( REGISTRY, (
        "%s: migrating zones from CurrentControlSet to Software\n", fn ));

    EnterCriticalSection( &csZoneList );

    Reg_SetZonesSource( DNS_REGSOURCE_SW );

    while ( pZone = Zone_ListGetNextZone( pZone ) )
    {
        rc = Zone_WriteZoneToRegistry( pZone );
        if ( rc != ERROR_SUCCESS )
        {
            DNS_DEBUG( REGISTRY, (
                "%s: error %d rewriting zone %s - aborting migration\n", fn,
                rc,
                pZone->pszZoneName ));

            //
            //  Clean up any zones copied into Software, and continue using
            //  the zones from CCS.
            //

            Reg_DeleteAllZones();
            Reg_SetZonesSource( DNS_REGSOURCE_CCS );
            goto Unlock;
        }
    }

    Reg_SetZonesSource( DNS_REGSOURCE_CCS );

    Reg_DeleteAllZones();

    Reg_SetZonesSource( DNS_REGSOURCE_SW );

    Reg_WriteZonesMovedMarker();

    //
    //  Cleanup and exit.
    //

    Unlock:

    LeaveCriticalSection( &csZoneList );

    Done:

    return;
}   //  Zone_ListMigrateZones



//
//  Multizone and Zone filtering technology
//
//  To allow multizone admin operations, we allow admin to send
//  dummy zone names:
//      "..AllZones"
//      "..AllPrimaryZones"
//      "..AllSecondaryZones"
//      etc.
//
//  These can then be mapped into a zone request filter, specifying
//  which properties a matching zone must have.


typedef struct _MultizoneEntry
{
    LPSTR       pszName;        // Multizone name (defined in dnsrpc.h)
    DWORD       Filter;
}
MULTIZONE;

MULTIZONE   MultiZoneTable[] =
{
    DNS_ZONE_ALL                        ,   ZONE_REQUEST_ALL_ZONES              ,
    DNS_ZONE_ALL_AND_CACHE              ,   ZONE_REQUEST_ALL_ZONES_AND_CACHE    ,

    DNS_ZONE_ALL_PRIMARY                ,   ZONE_REQUEST_PRIMARY                ,
    DNS_ZONE_ALL_SECONDARY              ,   ZONE_REQUEST_SECONDARY              ,

    DNS_ZONE_ALL_FORWARD                ,   ZONE_REQUEST_FORWARD                ,
    DNS_ZONE_ALL_REVERSE                ,   ZONE_REQUEST_REVERSE                ,

    DNS_ZONE_ALL_DS                     ,   ZONE_REQUEST_DS                     ,
    DNS_ZONE_ALL_NON_DS                 ,   ZONE_REQUEST_NON_DS                 ,

    //  a common combined properties

    DNS_ZONE_ALL_PRIMARY_REVERSE        ,   ZONE_REQUEST_REVERSE | ZONE_REQUEST_PRIMARY ,
    DNS_ZONE_ALL_PRIMARY_FORWARD        ,   ZONE_REQUEST_FORWARD | ZONE_REQUEST_PRIMARY ,

    DNS_ZONE_ALL_SECONDARY_REVERSE      ,   ZONE_REQUEST_REVERSE | ZONE_REQUEST_SECONDARY ,
    DNS_ZONE_ALL_SECONDARY_FORWARD      ,   ZONE_REQUEST_FORWARD | ZONE_REQUEST_SECONDARY ,

    NULL, 0,
};



DWORD
Zone_GetFilterForMultiZoneName(
    IN      LPSTR           pszZoneName
    )
/*++

Routine Description:

    Check and get multizone handle for zone name.

Arguments:

    pszZoneName -- zone name

Return Value:

    Ptr to dummy multizone handle.
    NULL if handle invalid.

--*/
{
    DWORD   nameLength;
    DWORD   i;
    LPSTR   pmultiName;

    //
    //  quickly eliminate non-multizones
    //

    nameLength = strlen( pszZoneName );

    if ( nameLength < 5 )
    {
        return 0;
    }
    if ( strncmp( "..All", pszZoneName, 5 ) != 0 )
    {
        return 0;
    }

    //
    //  have a multizone name
    //

    i = 0;

    while ( pmultiName = MultiZoneTable[i].pszName )
    {
        if ( strcmp( pmultiName, pszZoneName ) != 0 )
        {
            i++;
            continue;
        }

        DNS_DEBUG( RPC, (
            "Matched multizone %s to zone filter %p\n",
            pszZoneName,
            MultiZoneTable[i].Filter ));

        return( MultiZoneTable[i].Filter );
    }

    DNS_DEBUG( ANY, (
        "ERROR:  Multizone name <%s> was not in multizone table!\n",
        pszZoneName ));

    return 0;
}



PZONE_INFO
Zone_ListGetNextZoneMatchingFilter(
    IN      PZONE_INFO                  pLastZone,
    IN      PDNS_RPC_ENUM_ZONES_FILTER  pFilter
    )
/*++

Routine Description:

    Get next zone matching filter.

Arguments:

    pLastZone -- previous zone ptr;  NULL to start enum

Return Value:

    Ptr to next zone matching filter.
    NULL when enum complete.

--*/
{
    PZONE_INFO  pzone = pLastZone;

    //
    //  walk zone list, until match zone
    //

    EnterCriticalSection( &csZoneList );

    while ( ( pzone = Zone_ListGetNextZone( pzone ) ) != NULL )
    {
        if ( Zone_CheckZoneFilter( pzone, pFilter ) )
        {
            break;
        }
    }

    LeaveCriticalSection( &csZoneList );

    return pzone;
}   //  Zone_ListGetNextZoneMatchingFilter



BOOL
FASTCALL
Zone_CheckZoneFilter(
    IN      PZONE_INFO                  pZone,
    IN      PDNS_RPC_ENUM_ZONES_FILTER  pFilter
    )
/*++

Routine Description:

    Check if zone passes filter.

Arguments:

    pZone -- zone to check

    pFilter -- zone filter from dnsrpc.h

Return Value:

    TRUE if zone passes through filter
    FALSE if zone screened out

--*/
{
    DWORD   dwfilter = pFilter->dwFilter;
    BOOL    zonePassesFilter = TRUE;

    #define ZoneFailsFilter()  zonePassesFilter = FALSE; break;
    #define FilterIsInvalid()  zonePassesFilter = FALSE; goto Done;

    do
    {
        //  catch bogus "no-filter" condition

        if ( dwfilter == 0 &&
                  !pFilter->pszPartitionFqdn &&
                  !pFilter->pszQueryString )
        {
            DNS_DEBUG( RPC, (
                "ERROR:  filtering with no zone filter!\n" ));
            FilterIsInvalid();
        }

        //
        //  If there is a partition filter make sure DS zones will match.
        //

        if ( pFilter->pszPartitionFqdn )
        {
            dwfilter |= ZONE_REQUEST_DS;
        }
        
        if ( dwfilter & ZONE_REQUEST_ANY_DP )
        {
            dwfilter |= ZONE_REQUEST_DS;
        }

        if ( dwfilter == 0 )
        {
            ZoneFailsFilter();  //  No DWORD filter so skip to other filters.
        }

        //
        //  note, for all filters, check for "none-selected" condition
        //      and treat this as "don't filter";
        //      this eliminates the need to always set flags for properties
        //      you don't care about AND preserves backward compatibility with
        //      old admin, when add new filter properties
        //

        //
        //  forward \ reverse filter
        //

        if ( dwfilter & ZONE_REQUEST_ANY_DIRECTION )
        {
            if ( IS_ZONE_REVERSE( pZone ) )
            {
                if ( !( dwfilter & ZONE_REQUEST_REVERSE ) )
                {
                    ZoneFailsFilter();
                }
            }
            else
            {
                if ( !( dwfilter & ZONE_REQUEST_FORWARD ) )
                {
                    ZoneFailsFilter();
                }
            }
        }

        //
        //  type filter
        //

        if ( dwfilter & ZONE_REQUEST_ANY_TYPE )
        {
            if ( IS_ZONE_PRIMARY( pZone ) )
            {
                if ( !( dwfilter & ZONE_REQUEST_PRIMARY ) )
                {
                    ZoneFailsFilter();
                }
            }
            else if ( IS_ZONE_STUB( pZone ) )
            {
                //
                //  Stub test must go before secondary test because currently
                //  stub zones are also secondary zones.
                //

                if ( !( dwfilter & ZONE_REQUEST_STUB ) )
                {
                    ZoneFailsFilter();
                }
            }
            else if ( IS_ZONE_SECONDARY( pZone ) )
            {
                if ( !( dwfilter & ZONE_REQUEST_SECONDARY ) )
                {
                    ZoneFailsFilter();
                }
            }
            else if ( IS_ZONE_FORWARDER( pZone ) )
            {
                if ( !( dwfilter & ZONE_REQUEST_FORWARDER ) )
                {
                    ZoneFailsFilter();
                }
            }
            else
            {
                if ( !( dwfilter & ZONE_REQUEST_CACHE ) )
                {
                    ZoneFailsFilter();
                }
            }
        }

        //  auto-created filter

        if ( pZone->fAutoCreated && !( dwfilter & ZONE_REQUEST_AUTO ) )
        {
            ZoneFailsFilter();
        }

        //
        //  DS \ non-DS filter
        //

        if ( dwfilter & ZONE_REQUEST_ANY_DATABASE )
        {
            if ( IS_ZONE_DSINTEGRATED( pZone ) )
            {
                if ( !( dwfilter & ZONE_REQUEST_DS ) )
                {
                    ZoneFailsFilter();
                }
            }
            else
            {
                if ( !( dwfilter & ZONE_REQUEST_NON_DS ) )
                {
                    ZoneFailsFilter();
                }
            }
        }

        //
        //  Simple directory partition filters.
        //

        if ( dwfilter & ZONE_REQUEST_ANY_DP )
        {
            if ( IS_DP_DOMAIN_DEFAULT( ZONE_DP( pZone ) ) )
            {
                if ( !( dwfilter & ZONE_REQUEST_DOMAIN_DP ) )
                {
                    ZoneFailsFilter();
                }
            }
            else if ( IS_DP_FOREST_DEFAULT( ZONE_DP( pZone ) ) )
            {
                if ( !( dwfilter & ZONE_REQUEST_FOREST_DP ) )
                {
                    ZoneFailsFilter();
                }
            }
            else if ( IS_DP_LEGACY( ZONE_DP( pZone ) ) )
            {
                if ( !( dwfilter & ZONE_REQUEST_LEGACY_DP ) )
                {
                    ZoneFailsFilter();
                }
            }
            else
            {
                if ( !( dwfilter & ZONE_REQUEST_CUSTOM_DP ) )
                {
                    ZoneFailsFilter();
                }
            }
        }
    }
    while ( 0 );

    //
    //  Apply the directory partition FQDN filter. 
    //

    while ( zonePassesFilter )
    {
        if ( pFilter->pszPartitionFqdn )
        {
            if ( !IS_ZONE_DSINTEGRATED( pZone ) )
            {
                ZoneFailsFilter();
            }

            zonePassesFilter = ZONE_DP( pZone ) != NULL &&
                               _stricmp(
                                    ZONE_DP( pZone )->pszDpFqdn,
                                    pFilter->pszPartitionFqdn ) == 0;
        }
        break;
    }

    //
    //  Apply query string here - not yet implemented.
    //

    ASSERT( !pFilter->pszQueryString );

    Done:
    
    DNS_DEBUG( RPC, (
        "Zone_CheckZoneFilter: %s zonetype=%d %s\n"
        "    filter = %d : %s : %s\n",
        zonePassesFilter ? "PASSES" : "FAILS ",
        pZone->fZoneType,
        pZone->pszZoneName,
        pFilter->dwFilter,
        pFilter->pszPartitionFqdn,
        pFilter->pszQueryString ));

    return zonePassesFilter;
}

//
//  End of zonelist.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\zonepri.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    zonepri.c

Abstract:

    Domain Name System (DNS) Server

    Routines to handle zone transfer for primary.

Author:

    Jim Gilroy (jamesg)     April 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Max name servers possible in zone
//      - to allocate temporary array

#define MAX_NAME_SERVERS    (400)


//
//  Private protos
//

DWORD
zoneTransferSendThread(
    IN      LPVOID  pvMsg
    );

BOOL
transferZoneRoot(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PDB_NODE        pNode
    );

BOOL
traverseZoneAndTransferRecords(
    IN OUT  PDB_NODE        pNode,
    IN      PDNS_MSGINFO    pMsg
    );

BOOL
writeZoneNodeToMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wRRType,
    IN      WORD            wNameOffset
    );

DNS_STATUS
sendIxfrResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    );

BOOL
checkIfIpIsZoneNameServer(
    IN OUT  PZONE_INFO      pZone,
    IN      PDNS_ADDR       IpAddress
    );

DNS_STATUS
buildZoneNsList(
    IN OUT  PZONE_INFO      pZone
    );



//
//  XFR write utilities
//

DNS_STATUS
writeXfrRecord(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wOffset,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write record for zone transfer.

    This is for IXFR query where it is assumed that zone name
    is the question name of the packet.

    For TCP transfer, this routine sends message when buffer is full,
    then continues writing records for node.

Arguments:

    pMsg - message to write to

Return Value:

    ERROR_SUCCESS if successful.
    DNSSRV_STATUS_NEED_AXFR on overfilling UDP packet.
    ErrorCode on other failure.

--*/
{
    BOOL    fspin = FALSE;

    //  offsets other than to question are unuseable, as they
    //      are broken when wrap to new message

    ASSERT( pNode || wOffset==DNS_OFFSET_TO_QUESTION_NAME );

    DNS_DEBUG( ZONEXFR, (
        "writeXfrRecord( pMsg=%p, pRR=%p )\n",
        pMsg,
        pRR ));

    //
    //  write in loop, so can send and continue if hit truncation
    //
    //  if hit truncation
    //      - if UDP => FAILED -- return
    //      - if TCP
    //          - send and reset packet
    //          - retry write
    //

    while ( ! Wire_AddResourceRecordToMessage(
                    pMsg,
                    pNode,
                    wOffset,
                    pRR,
                    0 ) )
    {
        DNS_DEBUG( ZONEXFR, (
            "XFR transfer msg %p full writing RR at %p\n",
            pMsg,
            pRR ));

        DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

        ASSERT( pMsg->Head.Truncation );
        pMsg->Head.Truncation = FALSE;

        //
        //  packet is full
        //      - if UDP (or spinning), fail
        //      - if TCP, send it, reset for reuse
        //

        if ( !pMsg->fTcp || fspin )
        {
            ASSERT( !pMsg->fTcp );      // shouldn't spin TCP packet
            goto Failed;
        }
        fspin = TRUE;

        if ( Send_ResponseAndReset(
                    pMsg,
                    DNS_SENDMSG_TCP_ENLISTED ) != ERROR_SUCCESS )
        {
            DNS_DEBUG( ZONEXFR, (
                "ERROR sending zone transfer message at %p\n",
                pMsg ));
            goto Failed;
        }
    }

    //  wrote RR - inc answer count

    pMsg->Head.AnswerCount++;

    return ERROR_SUCCESS;

Failed:

    //
    //  most common error will be over-filling UDP packet
    //

    DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

    if ( !pMsg->fTcp )
    {
        DNS_DEBUG( ZONEXFR, (
            "Too many IXFR records for UDP packet %p\n",
            pMsg ));
        return DNSSRV_STATUS_NEED_TCP_XFR;
    }
    else
    {
        DNS_DEBUG( ZONEXFR, (
            "ERROR:  writeUpdateVersionToIxfrResponse() failed\n",
            pMsg ));
        return DNS_RCODE_SERVER_FAILURE;
    }
}



DNS_STATUS
Xfr_WriteZoneSoaWithVersion(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_RECORD      pSoaRR,
    IN      DWORD           dwVersion   OPTIONAL
    )
/*++

Routine Description:

    Write zone SOA with version.

    This is for IXFR query where it is assumed that zone name
    is the question name of the packet.

Arguments:

    pMsg - message to write to

    pZone - info structure for zone

    dwVersion - desired zone version;  OPTIONAL, if zero then ignore
        and use current version

Return Value:

    TRUE if successful.
    FALSE on error (out of space in packet).

--*/
{
    DNS_STATUS  status;

    ASSERT( pSoaRR && pSoaRR->wType == DNS_TYPE_SOA );
    ASSERT( !pMsg->fDoAdditional  &&  pMsg->Head.QuestionCount==1 );

    DNS_DEBUG( ZONEXFR, (
        "Xfr_WriteZoneSoaWithVersion( msg=%p, psoa=%p, v=%d )\n",
        pMsg,
        pSoaRR,
        dwVersion ));

    //
    //  write SOA record, name is always offset to question name
    //
    //  since SOA record is written repeatedly in IXFR, allow it's
    //      names to be compressed
    //

    pMsg->fNoCompressionWrite = FALSE;

    status = writeXfrRecord(
                    pMsg,
                    NULL,
                    DNS_OFFSET_TO_QUESTION_NAME,
                    pSoaRR );

    pMsg->fNoCompressionWrite = TRUE;

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ZONEXFR, (
            "Unable to write SOA to IXFR packet %p\n",
            pMsg ));
        return status;
    }

    //
    //  backtrack from pCurrent to version and set to desired value
    //

    if ( dwVersion )
    {
        PCHAR pch;
        pch = pMsg->pCurrent - SIZEOF_SOA_FIXED_DATA;
        WRITE_PACKET_HOST_DWORD( pch, dwVersion );
    }
    return status;
}


//
//  Private utils
//


DNS_STATUS
parseIxfrClientRequest(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Parse IXFR request packet retrieving current client version.

    Note, starting packet state, is normal parsing of query question.
    pCurrent may be assumed to be immediately after question.

Arguments:

    pMsg - IXFR request packet.

Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    register PCHAR      pch;
    PCHAR               pchpacketEnd;
    PDNS_WIRE_RECORD    pwireRR;
    PZONE_INFO          pzone;
    WORD                type;
    WORD                dataLength;
    DWORD               version;

    DNS_DEBUG( XFR2, (
        "parseIxfrClientRequest( %p )\n",
        pMsg ));

    //
    //  packet verification
    //      1 question, 1 authority SOA, no answers, no additional
    //

    if ( pMsg->Head.QuestionCount != 1 ||
        pMsg->Head.NameServerCount != 1 ||
        pMsg->Head.AnswerCount != 0 ||
        pMsg->Head.AdditionalCount != 0 )
    {
        goto FormError;
    }

    //
    //  read authority SOA record
    //      - must be for zone in question
    //      - save current ptr (position after question)
    //      as response is written from this location
    //

    pchpacketEnd = DNSMSG_END(pMsg);
    pch = pMsg->pCurrent;

    if ( pch >= pchpacketEnd )
    {
        goto FormError;
    }
    pzone = Lookup_ZoneForPacketName(
                (PCHAR) pMsg->MessageBody,
                pMsg );
    if ( pzone != pMsg->pzoneCurrent )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  bad IXFR packet %p, zone name mismatch\n", pMsg ));
        goto FormError;
    }

    pch = Wire_SkipPacketName( pMsg, pch );
    if ( !pch )
    {
        goto FormError;
    }
    pwireRR = (PDNS_WIRE_RECORD) pch;
    pch += sizeof(DNS_WIRE_RECORD);
    if ( pch > pchpacketEnd )
    {
        DNS_PRINT(( "ERROR:  bad RR struct out of packet\n" ));
        goto FormError;
    }
    type = FlipUnalignedWord( &pwireRR->RecordType );
    if ( type != DNS_TYPE_SOA )
    {
        DNS_PRINT(( "ERROR:  non-SOA record in IXFR request\n" ));
        goto FormError;
    }

    //  get version number from SOA data

    dataLength = FlipUnalignedWord( &pwireRR->DataLength );
    pch += dataLength;
    if ( pch > pchpacketEnd )
    {
        DNS_DEBUG( ANY, ( "ERROR:  bad RR data out of packet\n" ));
        goto FormError;
    }
    version = FlipUnalignedDword( pch - SIZEOF_SOA_FIXED_DATA );

    //  check for MS tag
    //  BIND flag always false, new IXFR aware servers should AXFR correctly

    XFR_MS_CLIENT(pMsg) = FALSE;
    XFR_BIND_CLIENT(pMsg) = FALSE;

    if ( pch != pchpacketEnd )
    {
        if ( pch+sizeof(WORD) == pchpacketEnd  &&
            *(UNALIGNED WORD *) pch == (WORD)DNS_FAST_AXFR_TAG )
        {
            XFR_MS_CLIENT(pMsg) = TRUE;
        }
        else
        {
            CLIENT_ASSERT( FALSE );
        }
    }

    //  set version

    IXFR_CLIENT_VERSION(pMsg) = version;

    DNS_DEBUG( XFR2, (
        "Leaving parseIxfrClientRequest( %p )\n"
        "    client version   = %d\n"
        "    BIND flag        = %d\n",
        pMsg,
        version,
        XFR_BIND_CLIENT(pMsg) ));

    return ERROR_SUCCESS;

FormError:

    DNS_DEBUG( ANY, (
        "ERROR:  bogus IXFR request packet %p\n",
        pMsg ));

    pMsg->pCurrent = DNSMSG_END( pMsg );

    return DNS_ERROR_RCODE_FORMAT_ERROR;
}



VOID
Xfr_SendNotify(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Send notify message to all slave servers for this zone.

Arguments:

    pZone -- zone being notified

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    PDNS_MSGINFO        pmsg;
    PDNS_ADDR_ARRAY     pnotifyArray;

    //
    //  Ignore forwarder zones and zones that are not active.
    //

    if ( IS_ZONE_FORWARDER( pZone ) || IS_ZONE_SHUTDOWN( pZone ) )
    {
        return;
    }

    ASSERT( pZone );
    ASSERT( IS_ZONE_PRIMARY(pZone) || IS_ZONE_SECONDARY(pZone) ||
            (IS_ZONE_CACHE(pZone) && pZone->fNotifyLevel == ZONE_NOTIFY_OFF) );
    ASSERT( pZone->pZoneRoot );

    DNS_DEBUG( ZONEXFR, (
        "Xfr_SendNotify() for zone %S\n",
        pZone->pwsZoneName ));

    //
    //  screen auto-created out here
    //

    if ( pZone->fAutoCreated )
    {
        return;
    }

    //
    //  determine servers (if any) to notify
    //
    //      OFF     -- no notify
    //      LIST    -- only servers explicitly in notify list
    //      ALL     -- all secondaries, either from all zone NS or
    //                  from explicit list
    //

    if ( pZone->fNotifyLevel == ZONE_NOTIFY_OFF )
    {
        DNS_DEBUG( XFR, (
            "NOTIFY OFF on zone %S\n",
            pZone->pwsZoneName ));
        return;
    }

    else if ( pZone->fNotifyLevel == ZONE_NOTIFY_LIST_ONLY )
    {
        pnotifyArray = pZone->aipNotify;
        if ( !pnotifyArray )
        {
            //  DEVNOTE: perhaps should have admin or server reject this state
            //      so only get here if forced into registry
            DNS_DEBUG( XFR, (
                "NOTIFY LIST on zone %S, but no notify list\n",
                pZone->pwsZoneName ));
            return;
        }
    }

    else    // NOTIFY_ALL secondaries
    {
        //  obviously can hack registry to get here, otherwise should never happen
        ASSERT( pZone->fNotifyLevel == ZONE_NOTIFY_ALL_SECONDARIES );

        if ( pZone->aipSecondaries )
        {
            pnotifyArray = pZone->aipSecondaries;
        }
        else
        {
            if ( IS_ZONE_NS_DIRTY(pZone) || !pZone->aipNameServers )
            {
                buildZoneNsList( pZone );
            }
            pnotifyArray = pZone->aipNameServers;
        }
    }

    if ( !pnotifyArray )
    {
        DNS_DEBUG( XFR, (
            "NOTIFY ALL secondaries, but no secondaries for zone %S\n",
            pZone->pwsZoneName ));
        return;
    }

    //
    //  build SOA-NOTIFY query
    //      - create SOA question
    //      - set Opcode to NOTIFY
    //      - set Authoritative bit
    //

    pmsg = Msg_CreateSendMessage( 0 );
    IF_NOMEM( !pmsg )
    {
        DNS_PRINT(( "ERROR:  unable to allocate memory for NOTIFY\n" ));
        return;
    }
    if ( !Msg_WriteQuestion(
                pmsg,
                pZone->pZoneRoot,
                DNS_TYPE_SOA ) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Unable to write NOTIFY for zone %S\n",
            pZone->pwsZoneName ));
        ASSERT( FALSE );
        goto Done;
    }
    pmsg->Head.Opcode = DNS_OPCODE_NOTIFY;
    pmsg->Head.Authoritative = TRUE;

    //  write current SOA to answer section

    pmsg->fDoAdditional = FALSE;

    SET_TO_WRITE_ANSWER_RECORDS(pmsg);

    if ( 1 != Wire_WriteRecordsAtNodeToMessage(
                    pmsg,
                    pZone->pZoneRoot,
                    DNS_TYPE_SOA,
                    DNS_OFFSET_TO_QUESTION_NAME,
                    0 ) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Unable to write SOA to Notify packet %S\n",
            pZone->pwsZoneName ));
        ASSERT( FALSE );
    }

    //
    //  send NOTIFY to secondaries in notify list
    //
    //  note:  all notify lists, are atomic and subject to timeout delete, so
    //      no need to protect
    //

    pmsg->fDelete = FALSE;

    Send_Multiple(
        pmsg,
        pnotifyArray,
        &MasterStats.NotifySent );

    PERF_SET( pcNotifySent, MasterStats.NotifySent );    // PerfMon hook

    //
    //  DEVNOTE: keep some sort of NOTIFY record to record ACKs?
    //      be able to resend
    //

Done:

    Packet_Free( pmsg );
}



VOID
Xfr_TransferZone(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Check zone transfer request, and transfer the zone if valid.

Arguments:

    pMsg -- request for zone transfer

Return Value:

    None.

--*/
{
    PZONE_INFO      pzone;
    PDB_NODE        pnode;
    PDB_NODE        pnodeClosest;
    HANDLE          hThread;
    DNS_STATUS      status;

    ASSERT( pMsg->fDelete );

    STAT_INC( MasterStats.Request );
    PERF_INC( pcZoneTransferRequestReceived );   // PerfMon hook

    //
    //  lookup desired zone name
    //
    //  verify:
    //      - is zone root node
    //      - we are authoritative for it
    //

    pzone = Lookup_ZoneForPacketName(
                pMsg->MessageBody,
                pMsg );
    if ( !pzone )
    {
        PVOID   argArray[2];
        BYTE    typeArray[2];

        typeArray[0] = EVENTARG_IP_ADDRESS;
        typeArray[1] = EVENTARG_LOOKUP_NAME;

        argArray[0] = &pMsg->RemoteAddr;
        argArray[1] = (PVOID) pMsg->pLooknameQuestion;

        DNS_LOG_EVENT(
            DNS_EVENT_BAD_ZONE_TRANSFER_REQUEST,
            2,
            argArray,
            typeArray,
            0 );

        DNS_DEBUG( ZONEXFR, (
            "Received zone transfer request at %p for name which\n"
            "    is not a zone root, or for which we are not authoritative\n",
            pMsg ));

        STAT_INC( MasterStats.NameError );
        Reject_RequestIntact(
            pMsg,
            DNS_RCODE_NAME_ERROR,
            0 );
        return;
    }

    //
    //  check that transfer ok
    //
    //  don't transfer if
    //      - shutdown
    //      - paused
    //      - receiving zone transfer
    //      - sending another transfer
    //      - secondary NOT in secure secondaries list
    //
    //  DEVNOTE: allow multiple transfers at once
    //      - need multi-thread
    //      - need count of outstanding transfers (or semaphore), so don't
    //      start allowing updates too soon
    //

    pMsg->pzoneCurrent = pzone;

    if ( IS_ZONE_SHUTDOWN(pzone) )
    {
        STAT_INC( MasterStats.RefuseShutdown );
        goto Refused;
    }

    //
    //  stub zone - no transfers allowed
    //

    if ( IS_ZONE_STUB( pzone ) )
    {
        goto Refused;
    }

    //
    //  secondary security
    //      - no security   => accept any IP, wide open
    //      - no XFR        => stop
    //      - only zone NS  => check against NS list
    //      - only list     => check against list
    //

    if ( pzone->fSecureSecondaries )
    {
        if ( pzone->fSecureSecondaries == ZONE_SECSECURE_NO_XFR )
        {
            STAT_INC( MasterStats.RefuseSecurity );
            goto Refused;
        }
        else if ( pzone->fSecureSecondaries == ZONE_SECSECURE_NS_ONLY )
        {
            if ( !checkIfIpIsZoneNameServer(
                        pzone,
                        &pMsg->RemoteAddr ) )
            {
                STAT_INC( MasterStats.RefuseSecurity );
                goto Refused;
            }
        }
        else    // secondary list
        {
            ASSERT( pzone->fSecureSecondaries == ZONE_SECSECURE_LIST_ONLY );

            if ( !DnsAddrArray_ContainsAddr(
                        pzone->aipSecondaries,
                        &pMsg->RemoteAddr,
                        DNSADDR_MATCH_IP ) )
            {
                STAT_INC( MasterStats.RefuseSecurity );
                goto Refused;
            }
        }
    }

    //
    //  AXFR
    //      - must be TCP
    //      - limit full AXFR on update zones
    //      - determine transfer format
    //

    if ( pMsg->wQuestionType == DNS_TYPE_AXFR )
    {
        STAT_INC( MasterStats.AxfrRequest );
        PERF_INC ( pcAxfrRequestReceived );          //Perf hook

        //  full zone transfer MUST be TCP

        if ( !pMsg->fTcp )
        {
            PVOID   parg = &pMsg->RemoteAddr;

            DNS_LOG_EVENT(
                DNS_EVENT_UDP_ZONE_TRANSFER,
                1,
                & parg,
                EVENTARG_ALL_IP_ADDRESS,
                0 );

            DNS_DEBUG( ANY, (
                "Received UDP Zone Transfer request from %s\n",
                DNSADDR_STRING( &pMsg->RemoteAddr ) ));

            STAT_INC( MasterStats.FormError );
            Reject_RequestIntact( pMsg, DNS_RCODE_FORMAT_ERROR, 0 );
            return;
        }

        //
        //  for update zones, avoid full transfers all the time
        //      - if inside of choke interval
        //      - limit transfers to no more than 1/10 of total time
        //
        //  DEVNOTE: may want to apply this to IXFR also that needs full XFR

        if ( pzone->fAllowUpdate
                &&  IS_ZONE_PRIMARY(pzone)
                &&  DNS_TIME() < pzone->dwNextTransferTime )
        {
            DNS_DEBUG( AXFR, (
                "WARNING:  Refusing AXFR of %S from %s due to AXFR choke interval\n"
                "    choke interval ends  = %d\n",
                pzone->pwsZoneName,
                MSG_IP_STRING( pMsg ),
                pzone->dwNextTransferTime ));

            STAT_INC( MasterStats.AxfrLimit );
            goto Refused;
        }

        //
        //  check if MS secondary
        //      - length two bytes longer than necessary
        //      - two bytes are FAST AXFR tag
        //
        //  otherwise, AXFR format from global flag

        if ( (INT)(pMsg->MessageLength - sizeof(WORD)) == DNSMSG_CURRENT_OFFSET(pMsg)
                &&
            *(UNALIGNED WORD *) pMsg->pCurrent == (WORD)DNS_FAST_AXFR_TAG )
        {
            XFR_BIND_CLIENT(pMsg) = FALSE;
            XFR_MS_CLIENT(pMsg) = TRUE;
        }
        else
        {
            XFR_BIND_CLIENT(pMsg) = (BOOLEAN) SrvCfg_fBindSecondaries;
            XFR_MS_CLIENT(pMsg) = FALSE;
        }
    }

    //
    //  IXFR
    //      - allows either TCP or UDP
    //      - pull out secondary's version
    //      - determine if MS secondary

    else
    {
        DNS_STATUS  ixfrstatus;

        ASSERT( pMsg->wQuestionType == DNS_TYPE_IXFR );

        ixfrstatus = parseIxfrClientRequest(pMsg);
        if ( ixfrstatus != ERROR_SUCCESS )
        {
            ASSERT( ixfrstatus == DNS_ERROR_RCODE_FORMAT_ERROR );

            STAT_INC( MasterStats.FormError );

            Reject_RequestIntact(
                pMsg,
                DNS_RCODE_FORMAT_ERROR,
                0 );
            return;
        }
    }

    //
    //  lock for transfer
    //
    //  this locks out admin updates, and additional transfers
    //
    //  note:  if switch to locking with CS held during transfer
    //          then test should move to recv thread
    //

    if ( !Zone_LockForXfrSend( pzone ) )
    {
        DNS_PRINT((
            "Zone %S, locked -- unable to transfer\n",
            pzone->pwsZoneName ));
        STAT_INC( MasterStats.RefuseZoneLocked );
        goto Refused;
    }

    //
    //  prepare message for transfer
    //      - do this rather than in transfer thread so can include
    //      UDP zone transfer
    //
    //  leave question in buffer
    //
    //  use offset to zone name to compress records in buffer, do NOT
    //  write offsets of names -- would just fill compression buffer
    //
    //  note default TCP buffer is 16K which is maximum size of compression
    //  so this is the most efficient transfer siz
    //

    ASSERT( pMsg->Head.QuestionCount == 1 );

    pMsg->Head.IsResponse = TRUE;

    pMsg->pNodeQuestion = pzone->pZoneRoot;

    Name_SaveCompressionWithNode( pMsg, pMsg->MessageBody, pzone->pZoneRoot );

    pMsg->fNoCompressionWrite = TRUE;

    //  no additional records processing

    pMsg->fDoAdditional = FALSE;

    //  clear IXFR authority (if any)

    pMsg->Head.AnswerCount = 0;
    pMsg->Head.NameServerCount = 0;
    pMsg->Head.AdditionalCount = 0;
    SET_TO_WRITE_ANSWER_RECORDS(pMsg);

    DNS_MSG_ASSERT_BUFF_INTACT( pMsg );
    
    //
    //  UDP IXFR?
    //      - note must free message, sendIxfrResponse never frees

    if ( !pMsg->fTcp )
    {
        ASSERT( pMsg->wQuestionType == DNS_TYPE_IXFR );
        STAT_INC( MasterStats.IxfrUdpRequest );
        sendIxfrResponse( pMsg );
        Zone_UnlockAfterXfrSend( pzone );
        Packet_FreeUdpMessage( pMsg );
        return;
    }

    //
    //  DEVNOTE: cut AXFR socket from connection list
    //      or need to lengthen timeout substaintially
    //      or make sure it is touched repeatedly

    //
    //  DEVNOTE: someway to reel AXFR thread back in if hangs
    //
    //      one way is connection list timeout
    //      BUT need to be careful
    //          - new messages on connection not a problem
    //
    //          - possiblity that client sends another AXFR???, if takes
    //          a while to get going
    //
    //          - could set some sort of disable flag on connection
    //

    //
    //  spawn zone transfer thread
    //

    hThread = Thread_Create(
                    "Zone Transfer Send",
                    zoneTransferSendThread,
                    (PVOID) pMsg,
                    0 );
    if ( !hThread )
    {
        //  release zone lock

        Zone_UnlockAfterXfrSend( pzone );

        DNS_DEBUG( ZONEXFR, (
            "ERROR:  unable to create thread to send zone %S\n"
            "    to %s\n",
            pzone->pwsZoneName,
            DNSADDR_STRING( &pMsg->RemoteAddr ) ));
        STAT_INC( MasterStats.RefuseServerFailure );
        goto Refused;
    }
    return;

Refused:

    STAT_INC( MasterStats.Refused );
    Reject_RequestIntact(
        pMsg,
        DNS_RCODE_REFUSED,
        0 );
    return;
}



DWORD
zoneTransferSendThread(
    IN      LPVOID  pvMsg
    )
/*++

Routine Description:

    Zone transfer reception thread routine.

Arguments:

    pvMsg - ptr to message requesting zone transfer

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    PDNS_MSGINFO    pMsg = (PDNS_MSGINFO) pvMsg;
    PDB_NODE        pnode;
    PZONE_INFO      pzone;
    DWORD           nonBlocking;
    DWORD           startTime;
    PVOID           argArray[ 3 ];
    BYTE            argTypeArray[ 3 ];
    CHAR            szaddr[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

    //  recover zone and zone root

    pzone = pMsg->pzoneCurrent;
    pnode = pzone->pZoneRoot;

    ASSERT( IS_ZONE_LOCKED_FOR_READ(pzone) );

    //  set zone transfer logging params
    //      - only log start for debug builds

    DnsAddr_WriteIpString_A( szaddr, &pMsg->RemoteAddr );
    
    argArray[ 0 ] = ( PVOID ) ( DWORD_PTR ) pzone->dwSerialNo;
    argArray[ 1 ] = pzone->pwsZoneName;
    argArray[ 2 ] = szaddr;

    argTypeArray[ 0 ] = EVENTARG_DWORD;
    argTypeArray[ 1 ] = EVENTARG_UNICODE;
    argTypeArray[ 2 ] = EVENTARG_UTF8;
    
    //
    //  Set TCP packet usable buffer to max compression length.
    //  We don't want to send any zone transfer packets longer
    //  that this length so that as many DNS names as possible
    //  can be compressed.
    //
    
    pMsg->BufferLength = DNSSRV_MAX_COMPRESSION_OFFSET;
    pMsg->pBufferEnd = DNSMSG_PTR_FOR_OFFSET( pMsg, pMsg->BufferLength );

    //
    //  set socket BLOCKING
    //
    //  this allows us to send freely, without worrying about
    //  WSAEWOULDBLOCK return
    //

    nonBlocking = FALSE;
    nonBlocking = ioctlsocket( pMsg->Socket, FIONBIO, &nonBlocking );
    if ( nonBlocking != 0 )
    {
        DWORD   err = WSAGetLastError();
        DNS_PRINT((
            "ERROR:  Unable to set socket %d to non-blocking to send"
            " zone transfer\n"
            "    err = %d\n",
            pMsg->Socket,
            err ));
        //
        // Failure path:
        // It is possible that the connection blob was timed out & the
        // socket closed if, for instance, it took us long time to
        // lock the zone. Then, this op would fail w/ invalid socket.
        // Thus, we don't need to assert here.
        // NOTE: if we could, the proper solution would be to prevent
        // the connection blob from ever timing out, yet ensuring that
        // any code path will clean it up.
        //
        // ASSERT( FALSE );

        goto TransferFailed;
    }

    //
    //  IXFR
    //      - if requires full AXFR, then fall through to AXFR
    //      - note must free message, sendIxfrResponse never frees
    //

    if ( pMsg->wQuestionType == DNS_TYPE_IXFR )
    {
        DNS_STATUS  ixfrstatus;

        ixfrstatus = sendIxfrResponse( pMsg );
        if ( ixfrstatus != DNSSRV_STATUS_NEED_AXFR )
        {
            goto Cleanup;
        }
        DNS_DEBUG( XFR, (
            "Need full AXFR on IXFR request in packet %p\n",
            pMsg ));
    }

    IF_DEBUG( ANY )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_ZONEXFR_START,
            3,
            argArray,
            argTypeArray,
            0 );
    }
    startTime = DNS_TIME();

    DNS_DEBUG( ZONEXFR, (
        "Initiating zone transfer\n"
        "    SOA version        %d\n"
        "    zone               %S\n"
        "    remote IP          %s\n"
        "    start time         %d\n"
        "    BIND flag          %d\n",
        argArray[ 0 ],
        argArray[ 1 ],
        argArray[ 2 ],
        startTime,
        XFR_BIND_CLIENT( pMsg ) ));

    //
    //  send zone root
    //      - SOA record first
    //      - rest of zone root node's records
    //

    if ( !writeZoneNodeToMessage(
                pMsg,
                pnode,
                DNS_TYPE_SOA,       // SOA record only
                0 ) )               // no excluded type
    {
        goto TransferFailed;
    }

#if 0
    //  failed attempt to separate WINS from RR list
    //  enforce these conditions in BIND\non-BIND write routines below

    //
    //  WINS record?
    //  include if
    //      - to MS server
    //      - WINS exists
    //      - WINS is non-LOCAL
    //
    //  note, no can just write to message without send wrapping, as
    //  message buffer is always big enough for SOA + WINS
    //

    if ( XFR_MS_CLIENT(pMsg)  &&  pzone->pXfrWinsRR )
    {
        if ( !Wire_AddResourceRecordToMessage(
                        pMsg,
                        pnode,
                        DNSMSG_QUESTION_NAME_OFFSET,
                        pzone->pXfrWinsRR,
                        0 ) )
        {
            goto TransferFailed;
        }
    }
#endif

    if ( !writeZoneNodeToMessage(
                pMsg,
                pnode,
                DNS_TYPE_ALL,           //  all except
                DNS_TYPE_SOA ) )        //  exclude SOA
    {
        goto TransferFailed;
    }

    //
    //  transfer all RR for other nodes in zone
    //
    //      - send offset to question name for zone name
    //      - set flag to indicate this is top of zone
    //

    if ( pnode->pChildren )
    {
        PDB_NODE pchild = NTree_FirstChild( pnode );

        while ( pchild )
        {
            if ( !traverseZoneAndTransferRecords(
                        pchild,
                        pMsg ) )
            {
                goto TransferFailed;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }

    //
    //  send zone SOA to mark end of transfer
    //

    if ( !writeZoneNodeToMessage(
                pMsg,
                pnode,
                DNS_TYPE_SOA,       // SOA record only
                0 ) )               // no excluded type
    {
        goto TransferFailed;
    }

    //
    //  send any remaining messages
    //

    if ( pMsg->Head.AnswerCount )
    {
        if ( Send_ResponseAndReset(
                    pMsg,
                    DNS_SENDMSG_TCP_ENLISTED ) != ERROR_SUCCESS )
        {
            goto TransferFailed;
        }
    }
    STAT_INC( MasterStats.AxfrSuccess );
    PERF_INC( pcAxfrSuccessSent );           // PerfMon hook
    PERF_INC( pcZoneTransferSuccess );       // PerfMon hook

    DNS_LOG_EVENT(
        DNS_EVENT_ZONEXFR_SUCCESSFUL,
        3,
        argArray,
        argTypeArray,
        0 );

    //
    //  reset zone info after transfer
    //      - move new updates to new version
    //      - if dynamic update, choke zone transfers
    //

    if ( IS_ZONE_PRIMARY(pzone) )
    {
        Zone_UpdateInfoAfterPrimaryTransfer( pzone, startTime );
    }
    goto Cleanup;

TransferFailed:

    //
    //  transfer failed, usually because secondary aborted
    //

    STAT_INC( MasterStats.Failure );
    PERF_INC( pcZoneTransferFailure );       // PerfMon hook

    DNS_LOG_EVENT(
        DNS_EVENT_ZONEXFR_ABORTED,
        3,
        argArray,
        argTypeArray,
        0 );

Cleanup:

    //
    //  cleanup
    //      - free message
    //      - release read lock on zone
    //      - if necessary push current serial back to DS
    //      - clear this thread from global array
    //

    Packet_FreeTcpMessage( pMsg );

    pzone->dwLastXfrSerialNo = pzone->dwSerialNo;

    Zone_UnlockAfterXfrSend( pzone );

    if ( pzone->fDsIntegrated )
    {
        Ds_CheckForAndForceSerialWrite(
            pzone,
            ZONE_SERIAL_SYNC_XFR,
            FALSE );
    }

    Thread_Close( FALSE );

    return 0;
}



BOOL
writeZoneNodeToMessageForBind(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wRRType,
    IN      WORD            wExcludeRRType
    )
/*++

Routine Description:

    Write RR at node to packet and send.

    This implementation is specifically for sending to BIND secondaries.
    BIND chokes when it gets more than one RR in the packet.

    The correct implementation, making full use of the message concept,
    is below.

Arguments:

    pMsg -- ptr to message info for zone transfer

    pNode -- ptr to node to write

    wRRType -- RR type

    wExcludeRRType -- excluded RR type, send all but this type

Return Value:

    TRUE if successful.
    FALSE if error.

--*/
{
    PDB_RECORD      prr;

    DNS_DEBUG( ZONEXFR, (
        "Writing AXFR node with label %s for send to BIND\n",
        pNode->szLabel ));

    //
    //  write all RR in node to packet
    //
    //  note we do NOT hold lock during send(), in case pipe backs up
    //  (this should not be necessary as this is a non-blocking socket, but
    //  the winsock folks seem to have broken this)
    //  hence we must drop and reacquire lock and always find NEXT record based
    //  on previous
    //

    LOCK_RR_LIST( pNode );
    prr = NULL;

    while ( prr = RR_FindNextRecord(
                    pNode,
                    wRRType,
                    prr,
                    0 ) )
    {
        //  do not transfer and cached data or root hints

        if ( IS_CACHE_RR(prr) || IS_ROOT_HINT_RR(prr) )
        {
            continue;
        }

        //  if excluding a type, check here
        //
        //  since WINS\WINSR only at zone root, and we are excluding SOA at root
        //      enforce WINS prohbition right here (to save a few instructions)
        //

        if ( wExcludeRRType )
        {
            if ( prr->wType == wExcludeRRType )
            {
                continue;
            }
            if ( IS_WINS_TYPE( prr->wType ) )
            {
                ASSERT( ! (prr->Data.WINS.dwMappingFlag & DNS_WINS_FLAG_LOCAL) );
                continue;
            }
        }

        //  no WINS record should ever get transferred to BIND

        ASSERT( !IS_WINS_TYPE(prr->wType) );

        //  add RR to packet

        if ( !Wire_AddResourceRecordToMessage(
                    pMsg,
                    pNode,
                    0,
                    prr,
                    0 ) )
        {
            //
            //  some sort of error writing packet?
            //

            DNS_DEBUG( ANY, ( "ERROR writing RR to AXFR packet\n" ));
            DNS_MSG_ASSERT_BUFF_INTACT( pMsg );
            UNLOCK_RR_LIST( pNode );
            ASSERT( FALSE );
            return FALSE;
        }

        DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

        UNLOCK_RR_LIST( pNode );
        pMsg->Head.AnswerCount++;

        //
        //  send the RR
        //

        if ( Send_ResponseAndReset(
                    pMsg,
                    DNS_SENDMSG_TCP_ENLISTED ) != ERROR_SUCCESS )
        {
            DNS_DEBUG( ZONEXFR, (
                "ERROR sending zone transfer message at %p\n",
                pMsg ));
            return FALSE;
        }
        LOCK_RR_LIST( pNode );
    }

    //
    //  drops here on no more RRs
    //

    UNLOCK_RR_LIST( pNode );
    return TRUE;
}



BOOL
writeZoneNodeToMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wRRType,
    IN      WORD            wExcludeRRType
    )
/*++

Routine Description:

    Write all RR in zone to packet.
    Send packet if, if full and start writing next packet.

Arguments:

    pMsg -- ptr to message info for zone transfer

    pNode -- ptr to node to write

    wRRType -- RR type

    wExcludeRRType -- excluded RR type, send all but this type

Return Value:

    TRUE if successful.
    FALSE if error.

--*/
{
    PDB_RECORD          prr;
    PDB_RECORD          prrPrevFailure = NULL;

    DNS_DEBUG( ZONEXFR, (
        "Writing AXFR node with label %s\n"
        "    pMsg             = %p\n"
        "    pCurrent         = %p\n"
        "    RR Type          = 0x%04hx\n"
        "    Exclude RR Type  = 0x%04hx\n",
        pNode->szLabel,
        (WORD) pMsg,
        (WORD) pMsg->pCurrent,
        (WORD) wRRType,
        (WORD) wExcludeRRType ));

    if ( IS_SELECT_NODE(pNode) )
    {
        return TRUE;
    }

    //
    //  if transfer to old BIND secondary
    //

    if ( XFR_BIND_CLIENT(pMsg) )
    {
        return  writeZoneNodeToMessageForBind(
                    pMsg,
                    pNode,
                    wRRType,
                    wExcludeRRType );
    }

    //
    //  write all RR in node to packet
    //
    //      - start write using pNode and offset to zone name
    //
    //      - save position where node name will be written, so can
    //          use offset to it for rest of records in node
    //
    //  note we do NOT hold lock during send(), in case pipe backs up
    //  (this should not be necessary as this is a non-blocking socket, but
    //  the winsock folks seem to have broken this)
    //  hence we must drop and reacquire lock and always find NEXT record based
    //  on previous
    //

    prr = NULL;

    LOCK_RR_LIST( pNode );

    while ( prr = RR_FindNextRecord(
                    pNode,
                    wRRType,
                    prr,
                    0 ) )
    {
        //  do not transfer and cached data or root hints

        if ( IS_CACHE_RR(prr) || IS_ROOT_HINT_RR(prr) )
        {
            continue;
        }

        //  if excluding a type, check here
        //  since WINS are at zone root, can optimize by doing
        //      LOCAL WINS exclusion here

        if ( wExcludeRRType )
        {
            if ( prr->wType == wExcludeRRType )
            {
                continue;
            }
            if ( IS_WINS_RR_AND_LOCAL( prr ) )
            {
                continue;
            }
        }

        //  LOCAL WINS should never hit the wire
        //
        //  note:  non-BIND is not necessarily MS, but assume that these folks
        //      running mixed servers are smart enough to set WINS to LOCAL to
        //      avoid writing to write
        //
        //  DEVNOTE: should have flag to indicate MS transfer OR
        //      fBindTransfer should become state flag
        //          0 -- bind
        //          1 -- fast
        //          2 -- MS
        //

        ASSERT( !IS_WINS_TYPE( prr->wType ) ||
                !(prr->Data.WINS.dwMappingFlag & DNS_WINS_FLAG_LOCAL) );

        //
        //  valid RR -- add to packet
        //
        //  first time through send
        //      - offsetForNodeName offset to zone root name
        //      - pNode to add this node's label
        //
        //  subsequent times through only send
        //      - offsetForNodeName now compressed name for node
        //      - NULL node ptr
        //  this writes ONLY compression bytes for name of RR
        //

        while ( !Wire_AddResourceRecordToMessage(
                        pMsg,
                        pNode,
                        0,
                        prr,
                        0 ) )
        {
            DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

            DNS_DEBUG( ZONEXFR, (
                "Zone transfer msg %p full writing RR at %p\n",
                pMsg,
                prr ));

            //
            //  packet is full
            //      - if UDP (or spinning), fail
            //      - if TCP, send it, reset for reuse
            //

            UNLOCK_RR_LIST( pNode );

            if ( !pMsg->fTcp )
            {
                DNS_DEBUG( ZONEXFR, (
                    "Filled UDP IXFR packet at %p\n"
                    "    require TCP transfer\n",
                    pMsg ));
                return FALSE;
            }

            //  catch spinning on RR, by saving previous RR written

            if ( prr == prrPrevFailure )
            {
                DNS_DEBUG( ZONEXFR, (
                    "ERROR writing pRR at %p to AXFR msg %p\n",
                    prr,
                    pMsg ));
                ASSERT( FALSE );
                return FALSE;
            }
            prrPrevFailure = prr;

            //
            //  The wire-write routines probably set the TC bit but for AXFR
            //  we don't want that so clear it before send.
            //

            pMsg->Head.Truncation = FALSE;

            //  send and reset

            if ( Send_ResponseAndReset(
                        pMsg,
                        DNS_SENDMSG_TCP_ENLISTED ) != ERROR_SUCCESS )
            {
                DNS_DEBUG( ZONEXFR, (
                    "ERROR sending zone transfer message at %p\n",
                    pMsg ));
                return FALSE;
            }

            LOCK_RR_LIST( pNode );
        }

        //  wrote RR - inc answer count

        pMsg->Head.AnswerCount++;
    }

    //
    //  drops here on no more RRs
    //

    UNLOCK_RR_LIST( pNode );
    return TRUE;
}



BOOL
traverseZoneAndTransferRecords(
    IN OUT  PDB_NODE        pNode,
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Send all RR in zone.

Arguments:

    pNode -- ptr to zone root node

    pMsg -- ptr to message info for zone transfer

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    DNS_DEBUG( ZONEXFR, (
        "Zone transfer for node with label %s\n",
        pNode->szLabel ));

    //
    //  entering new zone?
    //
    //      - write NS records to delineate zone
    //      - write glue records so secondary can recurse or refer to
    //          sub-zone NS
    //      - stop recursion
    //

    if ( IS_ZONE_ROOT(pNode) )
    {
        PDB_NODE        pnodeNS;
        PDB_RECORD      prr;

        //
        //  write sub-zone NS records
        //

        if ( !writeZoneNodeToMessage(
                    pMsg,
                    pNode,
                    DNS_TYPE_NS,
                    0 ) )               // no exclusion
        {
            return FALSE;
        }

        //
        //  write glue records
        //      - get NS RR
        //      - outside zone, write its A records
        //
        //  lock RR list only while using NS RR
        //

        prr = NULL;
        LOCK_RR_LIST( pNode );

        while ( prr = RR_FindNextRecord(
                        pNode,
                        DNS_TYPE_NS,
                        prr,
                        0 ) )
        {
            pnodeNS = Lookup_FindGlueNodeForDbaseName(
                            pMsg->pzoneCurrent,
                            & prr->Data.NS.nameTarget );
            if ( !pnodeNS )
            {
                continue;
            }
            if ( IS_AUTH_NODE(pnodeNS) )
            {
                // NS host within zone, no need for glue
                continue;
            }
            UNLOCK_RR_LIST( pNode );

            if ( !writeZoneNodeToMessage(
                        pMsg,
                        pnodeNS,
                        DNS_TYPE_A,
                        0 ) )           // no exclusion
            {
                return FALSE;
            }
            LOCK_RR_LIST( pNode );
        }
        UNLOCK_RR_LIST( pNode );
        return TRUE;
    }

    //
    //  transfer all authoritative RRs for this node
    //
    //  write all RR in node to message
    //
    //  offsetForNodeName will have offset to name for this node
    //      or be zero causing next write to be FQDN
    //

    if ( !writeZoneNodeToMessage(
                pMsg,
                pNode,
                DNS_TYPE_ALL,
                0 ) )           // no exclusion
    {
        return FALSE;
    }

    //
    //  recursion, to handle child nodes
    //

    if ( pNode->pChildren )
    {
        PDB_NODE pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            if ( !traverseZoneAndTransferRecords(
                        pchild,
                        pMsg ) )
            {
                return FALSE;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }
    return TRUE;
}




//
//  IXFR routines
//

DNS_STATUS
writeStandardIxfrResponse(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PUPDATE         pUpdateStart,
    IN      DWORD           dwVersion
    )
/*++

Routine Description:

    Write version to IXFR response.

Arguments:

    pMsg -- ptr to message info for zone transfer

    pup -- ptr to first update for this version in update list

Return Value:

    Ptr to next update in update list -- if successful.
    NULL if last or error.

--*/
{
    PDB_RECORD  prr;
    PUPDATE     pup;
    BOOL        fadd;
    PDB_RECORD  psoaRR;
    DNS_STATUS  status;

    DNS_DEBUG( ZONEXFR, (
        "writeStandardIxfrResponse()\n"
        "    pmsg = %p, version = %d, pupdate = %p\n",
        pMsg,
        dwVersion,
        pUpdateStart ));

    ASSERT( pUpdateStart );

    //  caller must free message

    pMsg->fDelete = FALSE;

    //
    //  write SOAs
    //      - current
    //      - client's current
    //
    //  save compression info when writing first SOA;  this saves the primary
    //  and admin data fields, allowing them to be compressed in later SOAs
    //  and we'll end up writing a bunch of them
    //
    //  DEVNOTE: must work out compression RESET on packet write for TCP
    //              then can turn compression back on
    //      - reset compression count back to zone count
    //      - allow compression write around SOA
    //          could do all the time, or just when compression count indicates
    //          it's the first SOA in packet (or explicit flag)
    //

    psoaRR = pMsg->pzoneCurrent->pSoaRR;

    status = Xfr_WriteZoneSoaWithVersion(
                pMsg,
                psoaRR,
                0 );

    DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

    if ( status != ERROR_SUCCESS )
    {
        return status;
    }
    status = Xfr_WriteZoneSoaWithVersion(
                pMsg,
                psoaRR,
                dwVersion );

    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    //
    //  write all updates up to current version
    //
    //  this is done in two passes
    //      - deletes, followed by version SOA
    //      - adds, followed by version SOA
    //

    pup = pUpdateStart;
    fadd = FALSE;

    while ( 1 )
    {
        //
        //  loop through all updates for both add and delete passes
        //

        do
        {
            DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

            //
            //  add pass
            //      - write CURRENT version of record set
            //      - exclude SOA
            //      - attempt to suppress duplicate RR set writes
            //

            if ( fadd )
            {
                if ( !pup->wAddType )
                {
                    continue;
                }
                if ( Up_IsDuplicateAdd( NULL, pup, NULL ) )
                {
                    continue;
                }

                if ( !writeZoneNodeToMessage(
                            pMsg,
                            pup->pNode,
                            pup->wAddType,          //  add RR type
                            DNS_TYPE_SOA ) )        //  exclude SOA
                {
                    if ( !pMsg->fTcp )
                    {
                        return DNSSRV_STATUS_NEED_TCP_XFR;
                    }
                    else
                    {
                        DNS_DEBUG( ANY, (
                            "Failed writing or sending IXFR add!\n"
                            "    node %p (%s) type %d\n"
                            "    pMsg = %p\n",
                            pup->pNode,
                            pup->pNode->szLabel,
                            pup->wAddType,
                            pMsg ));
                        return DNS_RCODE_SERVER_FAILURE;
                    }
                }
            }

            //
            //  delete pass, write each deleted record
            //
            //      - do NOT write SOA as this obviously confuses the issue and
            //      latest SOA is always delivered
            //

            else
            {
                prr = pup->pDeleteRR;
                if ( !prr )
                {
                    continue;
                }

                do
                {
                    if ( prr->wType == DNS_TYPE_SOA )
                    {
                        continue;
                    }
                    status = writeXfrRecord(
                                    pMsg,
                                    pup->pNode,
                                    0,
                                    prr );

                    if ( status != ERROR_SUCCESS )
                    {
                        return status;
                    }
                }
                while ( prr = prr->pRRNext );

            }   // end delete pass
        }
        while ( pup = pup->pNext );

        //
        //  write SOA to terminate add\delete section
        //      - zero serial to write current version
        //      - note write SOA function increments RR AnswerCount
        //

        DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

        status = Xfr_WriteZoneSoaWithVersion(
                    pMsg,
                    psoaRR,
                    0 );

        if ( status != ERROR_SUCCESS )
        {
            return status;
        }

        //
        //  end of delete pass => setup for add pass
        //  end of add pass => done
        //

        if ( !fadd )
        {
            fadd = TRUE;
            pup = pUpdateStart;
            continue;
        }
        break;
    }

    //
    //  send any remaining records
    //  note for TCP, XFR thread cleanup deletes message and closes connection
    //  note use Send_ResponseAndReset, instead of Send_Msg as
    //      Send_ResponseAndReset has WOULDBLOCK retry code for backed up
    //      connection
    //

    if ( pMsg->Head.AnswerCount )
    {
        Send_ResponseAndReset( pMsg, DNS_SENDMSG_TCP_ENLISTED );
    }

    //
    //  successful IXFR
    //

    DNS_DEBUG( ZONEXFR, (
        "Successful standard IXFR response to msg = %p\n",
        pMsg ));

    return ERROR_SUCCESS;
}



DNS_STATUS
sendIxfrResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Send IXFR response.

Arguments:

    pMsg -- ptr to message info for zone transfer

    Note:  caller must free the message.
           Event UDP sends not freed in this function.

Return Value:

    ERROR_SUCCESS if successful.
    DNSSRV_STATUS_NEED_AXFR if need full zone transfer

--*/
{
    PZONE_INFO  pzone = pMsg->pzoneCurrent;
    DWORD       version = IXFR_CLIENT_VERSION(pMsg);
    PUPDATE     pup;
    DNS_STATUS  status;

    ASSERT( !pMsg->fDoAdditional );
    ASSERT( IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) );

    DNS_DEBUG( ZONEXFR, (
        "Sending IXFR response for zone %s\n"
        "    client version = %d\n",
        pzone->pszZoneName,
        version ));

    STAT_INC( MasterStats.IxfrRequest );
    PERF_INC ( pcIxfrRequestReceived );          //Perf hook

    ( pMsg->fTcp )
        ?   STAT_INC( MasterStats.IxfrTcpRequest )
        :   STAT_INC( MasterStats.IxfrUdpRequest );

    //
    //  caller frees message
    //
    //  because some TCP sends can fail over to AXFR and hence can not
    //  be freed on send, we take a simple approach here and do not
    //  free ANY packets on send;  caller, whether TCP or UDP must free
    //

    pMsg->fDelete = FALSE;

    //
    //  verify that this zone is up and functioning
    //

    if ( !pzone->pSoaRR || IS_ZONE_SHUTDOWN(pzone) )
    {
        Reject_RequestIntact( pMsg, DNS_RCODE_SERVER_FAILURE, 0 );
        return ERROR_SUCCESS;
    }

    //
    //  verify that IXFR transfer possible
    //
    //  note:  updates contain version that they update the zone to
    //
    //  note can do incremental if first update in list is one more than
    //  client's version -- at a min, every update updates (version-1)
    //  important to include this case as if both primary and secondary
    //  start with a given version, first notify would happen with this case
    //

    pup = pzone->UpdateList.pListHead;

    if ( !pup || pup->dwVersion-1 > version || version >= pzone->dwSerialNo )
    {
        DNS_DEBUG( ZONEXFR, (
            "IXFR not possible for zone %s -- need full AXFR\n"
            "    current version %d\n"
            "    earliest version %d (zero indicates NO update list)\n"
            "    client version %d\n",
            pzone->pszZoneName,
            pzone->dwSerialNo,
            pup ? pup->dwVersion : 0,
            version ));
        goto NoVersion;
    }

    //
    //  find starting update
    //

    while ( pup && pup->dwVersion <= version )
    {
        pup = pup->pNext;
    }

    //  no starting update?

    if ( !pup )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  no update to get to requested IXFR version %d!\n"
            "    and zone version does not match!\n",
            version,
            pzone->dwSerialNo ));
        // ASSERT( FALSE );
        goto NoVersion;
    }

    //
    //  write standard IXFR
    //

    status = writeStandardIxfrResponse(
                pMsg,
                pup,
                version );

    if ( status != ERROR_SUCCESS )
    {
        if ( status == DNSSRV_STATUS_NEED_TCP_XFR )
        {
            ASSERT( !pMsg->fTcp );
            STAT_INC( MasterStats.IxfrUdpForceTcp );
            goto NeedTcp;
        }

        //  can also fail, if pipe backs up

        if ( !pMsg->fTcp )
        {
            RESET_MESSAGE_TO_ORIGINAL_QUERY( pMsg );
            Reject_Request( pMsg, DNS_RCODE_SERVER_FAILURE, 0 );
        }
        return status;
    }

    //
    //  DEVNOTE-LOG: some sort of success logging
    //      if not to eventlog, at least to log
    //

#if 0
    {
        DNS_LOG_EVENT(
            DNS_EVENT_ZONEXFR_SUCCESSFUL,
            3,
            pszArgs,
            NULL,
            0 );
    }
#endif

    DNS_DEBUG( ZONEXFR, (
        "Completed sendIxfrResponse for msg=%p, zone=%s from version=%d\n",
        pMsg,
        pzone->pszZoneName,
        version ));

    //  track IXFR success and free UDP response message

    STAT_INC( MasterStats.IxfrUpdateSuccess );
    PERF_INC( pcIxfrSuccessSent );       // PerfMon hook
    PERF_INC( pcZoneTransferSuccess );   // PerfMon hook

    if ( pMsg->fTcp )
    {
        STAT_INC( MasterStats.IxfrTcpSuccess );
    }
    else
    {
        STAT_INC( MasterStats.IxfrUdpSuccess );
    }

    pzone->dwLastXfrSerialNo = pzone->dwSerialNo;

#if 0
    //  NOT forcing DS write here as we're in main worker thread
    //
    //  DEVNOTE: no forced DS write for UDP IXFR
    //
    //  check if need to write serial to DS

    if ( pzone->fDsIntegrated )
    {
        Ds_CheckForAndForceSerialWrite(
            pZone,
            ZONE_SERIAL_SYNC_XFR );
    }
#endif

    return ERROR_SUCCESS;


NoVersion:

    //
    //  no version to do IXFR
    //      - if client at or above current version, then give single SOA response
    //          same a UDP "NeedTcp" case below
    //      - for UDP send "need full AXFR" packet, single SOA response
    //      - for TCP just return error, and calling function drops into
    //          full AXFR
    //

    STAT_INC( MasterStats.IxfrNoVersion );
    if ( version >= pzone->dwSerialNo )
    {
        goto NeedTcp;
    }
    if ( !pMsg->fTcp )
    {
        STAT_INC( MasterStats.IxfrUdpForceAxfr );
        goto NeedTcp;
    }
    STAT_INC( MasterStats.IxfrAxfr );
    return DNSSRV_STATUS_NEED_AXFR;


NeedTcp:

    //
    //  send need-full-AXFR packet OR client at or above current version
    //      - reset to immediately after question
    //      - send single answer of current SOA version
    //

    ASSERT( !pMsg->fTcp || version>=pzone->dwSerialNo );

    RESET_MESSAGE_TO_ORIGINAL_QUERY( pMsg );

    status = Xfr_WriteZoneSoaWithVersion(
                pMsg,
                pzone->pSoaRR,
                0 );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ZONEXFR, (
            "ERROR:  unable to write need-AXFR msg %p\n",
            pMsg ));

        //  unless really have names too big for packet -- can't get here
        ASSERT( FALSE );
        Reject_RequestIntact( pMsg, DNS_RCODE_FORMAT_ERROR, 0 );
        return ERROR_SUCCESS;
    }

    DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

    Send_Msg( pMsg, DNS_SENDMSG_TCP_ENLISTED );
    return ERROR_SUCCESS;
}



//
//  NS list utilities
//

BOOL
checkIfIpIsZoneNameServer(
    IN OUT  PZONE_INFO      pZone,
    IN      PDNS_ADDR       IpAddress
    )
/*++

Routine Description:

    Check if IP is a zone name server.

    Note, this means a remote NS, not a local machine address.

Arguments:

    pZone -- zone ptr, may be updated with new zone NS list

    IpAddress -- IP to check if remote NS

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    BOOL    bresult;

    DNS_DEBUG( XFR, (
        "checkIfIpIsZoneNameServer( %S, %s )\n",
        pZone->pwsZoneName,
        DNSADDR_STRING( IpAddress ) ));

    //
    //  if have existing NS list, check if IP in it
    //
    //  idea here is save cycles, even if list not current the
    //  worst we do is allow access to some IP that at least used to
    //  be zone NS (since this server's boot)
    //

    if ( pZone->aipNameServers &&
         DnsAddrArray_ContainsAddr(
            pZone->aipNameServers,
            IpAddress,
            DNSADDR_MATCH_IP ) )
    {
        DNS_DEBUG( XFR, (
            "Found IP %s in existing zone (%S) NS list\n",
            DNSADDR_STRING( IpAddress ),
            pZone->pwsZoneName ));
        return TRUE;
    }

    //
    //  IP not found, try rebuilding zone NS list
    //
    //  DEVNOTE: should have validity flag on NS list to skip rebuild
    //      skip rebuilding when list is relatively current
    //      and not suspected of being stale;
    //      still can live with this as this is NOT default option
    //

    buildZoneNsList( pZone );

    //  check again after rebuild

    if ( pZone->aipNameServers &&
         DnsAddrArray_ContainsAddr(
            pZone->aipNameServers,
            IpAddress,
            DNSADDR_MATCH_IP ) )
    {
        DNS_DEBUG( XFR, (
            "Found IP %s in zone %S NS list -- after rebuild\n",
            DNSADDR_STRING( IpAddress ),
            pZone->pwsZoneName ));
        return TRUE;
    }

    DNS_DEBUG( XFR, (
        "IP %s NOT found in zone %S NS list\n",
        DNSADDR_STRING( IpAddress ),
        pZone->pwsZoneName ));

    return FALSE;
}



DNS_STATUS
buildZoneNsList(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Rebuild NS list for zone.

Arguments:

    pZone -- zone ptr

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_NODE            pnodeNS;
    PDB_NODE            pnodeHost;
    PDB_RECORD          prrNS;
    PDB_RECORD          prrAddress;
    DWORD               countNs = 0;
    IP_ADDRESS          ipNs;
    PDNS_ADDR_ARRAY     pnameServerArray = NULL;
    DNS_STATUS          status = ERROR_SUCCESS;
    BOOL                endLoop = FALSE;

    DNS_DEBUG( XFR, (
        "buildZoneNsList( %S )\n"
        "    NS Dirty = %d\n"
        "    NS List  = %p\n",
        pZone->pwsZoneName,
        pZone->bNsDirty,
        pZone->aipNameServers ));

    //
    //  For stub zones we don't need to keep the NS list member current.
    //

    if ( IS_ZONE_STUB( pZone ) )
    {
        return ERROR_SUCCESS;
    }

    ASSERT( IS_ZONE_PRIMARY( pZone ) );
    ASSERT( !pZone->fAutoCreated );
    ASSERT( pZone->fSecureSecondaries == ZONE_SECSECURE_NS_ONLY ||
            pZone->fNotifyLevel == ZONE_NOTIFY_ALL_SECONDARIES );

    pnameServerArray = DnsAddrArray_Create( MAX_NAME_SERVERS );
    if ( !pnameServerArray )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    //
    //  if primary, we need to build list of all public name server
    //      addresses for sending NOTIFY packets
    //
    //  since just using for NOTIFY, just collect every address, no need
    //  to attempt anything fancy
    //
    //  DEVNOTE: building notify list for DS?
    //      could just limit notify to explicitly configured secondary servers
    //      ideally, save primary server IPs somewhere in DS to recognize
    //      those IPs, then don't build them
    //
    //  DEVNOTE: note:  won't find IPs until other zones loaded, so maybe
    //      on initial boot should just set "notify-not-built-yet" flag, and
    //      rebuild when everyone up
    //      note:  this problem is especially prevalent on reverse lookup zones
    //      which load before forward lookup that contain A records for servers
    //

    //
    //  loop through all name servers
    //

    prrNS = NULL;

    while ( !endLoop &&
            ( prrNS = RR_FindNextRecord(
                        pZone->pZoneRoot,
                        DNS_TYPE_NS,
                        prrNS,
                        0 ) ) != NULL )
    {
        countNs++;

        pnodeNS = Lookup_NsHostNode(
                        &prrNS->Data.NS.nameTarget,
                        0,              //  take best\any data
                        pZone,          //  use OUTSIDE zone glue if necessary
                        NULL );         //  don't care about delegation
        if ( !pnodeNS )
        {
            DNS_DEBUG( UPDATE, (
                "No host node found for zone NS\n" ));
            continue;
        }

        //
        //  get all address records for name server
        //  however, don't include addresses for THIS server, as
        //      there is no point in NOTIFYing ourselves
        //

        prrAddress = NULL;

        while ( prrAddress = RR_FindNextRecord(
                                    pnodeNS,
                                    DNS_TYPE_A,
                                    prrAddress,
                                    0 ) )
        {
            ipNs = prrAddress->Data.A.ipAddress;
            if ( DnsAddrArray_ContainsIp4( g_ServerIp4Addrs, ipNs ) )
            {
                break;
            }
            if ( !DnsAddrArray_AddIp4(
                        pnameServerArray,
                        ipNs,
                        DNSADDR_MATCH_IP ) )
            {
                //  The name server array is probably full.
                endLoop = TRUE;
                break;
            }
        }
    }

    //
    //  Set DNS port on all addresses in the new master list.
    //
    
    if ( pnameServerArray )
    {
        DnsAddrArray_SetPort( pnameServerArray, DNS_PORT_NET_ORDER );
    }

    //  we goofed if this static array isn't sufficient

    ASSERT( pnameServerArray->AddrCount < MAX_NAME_SERVERS );

    //
    //  should have some NS records to even be a zone
    //  however the 0, 127 and 255 reverse lookup zones may not
    //      as they are not primary on all servers, and hence aren't
    //      referred to so don't need to give out NS records
    //
    //  note:  may NOT insist on finding NS A records
    //      many zones (e.g. all reverse lookup)
    //      won't contain NS host A records within zone, and
    //      those records may not be loaded when this call made
    //      in fact we may NEVER have those authoritative records
    //      on this server
    //

    if ( !countNs )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Zone %s has no NS records\n",
            pZone->pszZoneName ));
        status = DNS_ERROR_ZONE_HAS_NO_NS_RECORDS;
    }

    //  DEVNOTE: with delayed free, i'm not sure this level of lock is
    //      required;  obviously two folks shouldn't timeout free
    //      but zone's update lock covering this whole blob should
    //      take care of that

    Zone_UpdateLock( pZone );

    Timeout_FreeDnsAddrArray( pZone->aipNameServers );
    pZone->aipNameServers = pnameServerArray;
    pnameServerArray = NULL;
    CLEAR_ZONE_NS_DIRTY( pZone );

    Zone_UpdateUnlock( pZone );

    //  Done:

    DnsAddrArray_Free( pnameServerArray );

    return status;
}


//
//  End of zonepri.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\zonesec.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    zonesec.c

Abstract:

    Domain Name System (DNS) Server

    Routines to handle zone transfer for secondary.

Author:

    Jim Gilroy (jamesg)     May 1995

Revision History:

    jamesg      Oct 1997    -- IXFR support

--*/


#include "dnssrv.h"


//
//  Globals
//

BOOL    g_fUsingSecondary;


//  Notifies and SOA check responses queued by recv() threads
//  DEVNOTE: it might simply things if we had a separate queue
//      for notifies/SOA check responses/etc instead of sticking
//      them all in the same queue.

#define DNS_SECONDARY_QUEUE_DEFAULT_TIMEOUT     (5*60)

PPACKET_QUEUE   g_SecondaryQueue;


//  Zone transfer completion event
//  Allows us to wake secondary control thread when transfer completes

HANDLE  g_hWakeSecondaryEvent;


//
//  Do SOA check on empty zone every minute.
//
//  Bracket zone check loop timeouts to reasonable values, so we
//  neither "lose control" and fail to check regularly, nor waste
//  cycles spinning.
//

#define FAST_ZONE_RETRY_INTERVAL        (60)
#define DEFAULT_ZONE_RETRY_INTERVAL     (60*15)
#define IXFR_RETRY_INTERVAL             (60)
#define MIN_SOA_RETRY_TIME              (15)
#define MAX_FAST_SOA_CHECKS             (5)

#define MIN_SECONDARY_ZONE_CHECK_LOOP_TIME   (60)
#define MAX_SECONDARY_ZONE_CHECK_LOOP_TIME   (1200)

//  Backoff to avoid spinning in AXFR attempts to failing master

#define MAX_BAD_MASTER_SUPPRESS_INTERVAL    (10)    //  10 seconds

//  Timeout on non-responding primary

#define ZONE_TRANSFER_SELECT_TIMEOUT        (30)    //  give up after 30 seconds

//  Bogus type to indicate stub transfer

#define DNS_TYPE_STUBXFR                    240

//  Stub zone transfers are controlled by a simple state machine. Start an
//  index at zero and iterate through the table below.

struct
{
    WORD                type;
    BYTE                recursionDesired : 1;   //  type matches DNS_HEADER for simplicity
}
g_stubXfrData[] =
{
    { DNS_TYPE_SOA,     0 },
    { DNS_TYPE_NS,      1 },
    { DNS_TYPE_ZERO,    0 }       //    terminatator
};


//
//  Private protos
//

PZONE_INFO
readZoneFromSoaAnswer(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            wType,
    OUT     PDWORD          pdwMasterVersion,
    OUT     PDB_RECORD *    ppSoaRR
    );

VOID
processNotify(
    IN OUT  PDNS_MSGINFO    pMsg
    );

BOOL
processSoaCheckResponse(
    IN OUT  PDNS_MSGINFO    pResponse
    );

VOID
processIxfrUdpResponse(
    IN OUT  PDNS_MSGINFO    pResponse
    );

BOOL
startTcpXfr(
    IN OUT  PZONE_INFO      pZone,
    IN      PDNS_ADDR       ipMaster,
    IN      DWORD           dwMasterVersion,
    IN      SOCKET          Socket
    );



//
//  Public secondary utilities.
//
//  These are used by both secondary control thread and
//      zone transfer reception threads.
//

BOOL
Xfr_RefreshZone(
    IN OUT  PZONE_INFO  pZone
    )
/*++

Routine Description:

    Reset zone properties for successful refresh of zone.
    May be called after matching SOA check, or transfer of zone.

Arguments:

    pZone -- zone that has been refreshed

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PDB_RECORD  prrSoa = NULL;
    DWORD       currentTime;

    ASSERT( pZone );

    //
    //  Find SOA RR for new zone
    //      - save direct ptr to it
    //      - save serial number in host order for faster compares
    //
    //  DEVNOTE: should NOT need to find SOA unless
    //          - load
    //          - AXFR
    //          - IXFR
    //      in these cases should already have been loaded by standard "UpdateRoot"
    //      before this is called
    //      that processing also set serialNo
    //

    if ( pZone->pZoneRoot )
    {
        prrSoa = RR_FindNextRecord(
                    pZone->pZoneRoot,
                    DNS_TYPE_SOA,
                    NULL,
                    0 );
    }
    if ( !prrSoa )
    {
        DNS_PRINT(( "ERROR:  No SOA RR at new zone root\n" ));
        ASSERT( FALSE );
        pZone->pSoaRR = NULL;
        pZone->fEmpty = TRUE;
        pZone->fStale = TRUE;
        SHUTDOWN_ZONE( pZone );
        return FALSE;
    }

    pZone->pSoaRR = prrSoa;
    pZone->dwSerialNo = ntohl( prrSoa->Data.SOA.dwSerialNo );

    //
    //  Reset refresh and expire timeouts
    //      - set zone expiration time
    //      - attempt next SOA check after refresh interval
    //          (or at expire if sooner)
    //

    currentTime = DNS_TIME();

    pZone->dwExpireTime = ntohl( prrSoa->Data.SOA.dwExpire ) + currentTime;

    pZone->dwNextSoaCheckTime = ntohl( prrSoa->Data.SOA.dwRefresh ) + currentTime;

    if ( pZone->dwNextSoaCheckTime > pZone->dwExpireTime )
    {
        pZone->dwNextSoaCheckTime = pZone->dwExpireTime;
    }

    //
    //  Clear zone secondary state info
    //
    //  Note this does not include TRANSFER flags.
    //  Send may be in progress during check, and RECV flag serves
    //  as ownership flag for zone during transfer.
    //

    REFRESH_ZONE( pZone );

    return TRUE;
}



VOID
Xfr_RetryZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Reset zone to retry SOA check.

    May be called after failure to receive SOA check, or failure
    during zone transfer attempt.

Arguments:

    pZone -- zone that must retry

Return Value:

    None.

--*/
{
    DWORD   currentTime = DNS_TIME();
    DWORD   nextTime;
    DWORD   dwRetryInterval;

    ASSERT( pZone );

    //
    //  We use UDP queries for SOA checks, which means that we need some
    //  limited fast retry. If a number of UDP SOA checks fail, assume that
    //  the connectivity problem is serious and drop back to the slow retry
    //  specified in the SOA for the zone.
    //

    if ( pZone->fSlowRetry || pZone->dwFastSoaChecks > MAX_FAST_SOA_CHECKS )
    {
        DNS_DEBUG( XFR, (
            "Xfr_RetryZone( %s ): using slow interval from SOA RR %p\n",
            pZone->pszZoneName,
            pZone->pSoaRR ));

        //
        //  If we have a zone SOA, use the zone's retry interval. There will
        //  be times were we have no zone SOA, such as if the zone has never
        //  successfully transferred. In this case use a reasonable default.
        //
        
        dwRetryInterval =
            pZone->pSoaRR
                ? ntohl( pZone->pSoaRR->Data.SOA.dwRetry )
                : DEFAULT_ZONE_RETRY_INTERVAL;
        pZone->fSlowRetry = FALSE;
        pZone->dwFastSoaChecks = 0;
    }
    else
    {
        ++pZone->dwFastSoaChecks;
        dwRetryInterval = FAST_ZONE_RETRY_INTERVAL;
    }


    DNS_DEBUG( XFR, (
        "Xfr_RetryZone( %s ): interval=%d fSlow=%d dwChecks=%d\n",
        pZone->pszZoneName,
        dwRetryInterval,
        ( int ) pZone->fSlowRetry,
        pZone->dwFastSoaChecks ));

    //
    //  set next SOA check time at retry time
    //
    //  but if expire time is closer, send next SOA at expiration
    //

    nextTime = dwRetryInterval + currentTime;

    if ( pZone->dwExpireTime < nextTime &&
         pZone->dwExpireTime > currentTime )
    {
        ASSERT( !IS_ZONE_SHUTDOWN( pZone ) );
        pZone->dwNextSoaCheckTime = pZone->dwExpireTime;
    }
    else
    {
        pZone->dwNextSoaCheckTime = nextTime;
    }
}



VOID
Xfr_ForceZoneExpiration(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Force expiration of zone.
    This can be called from admin RPC thread and forces ZoneControlThread
    to expire the zone.

Arguments:

    pZone -- zone to expire

Return Value:

    None.

--*/
{
    DNS_DEBUG( XFR, (
        "Xfr_ForceZoneExpiration( %s )\n",
        pZone->pszZoneName ));

    //  set expire time to NOW
    //  then wake up zone control thread to force expiration

    pZone->dwExpireTime = DNS_TIME();

    SetEvent( g_hWakeSecondaryEvent );
}



VOID
Xfr_ForceZoneRefresh(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Force immediate refresh on zone.
    This can be called from admin RPC thread and forces ZoneControlThread
    to send SOA query for the zone.

Arguments:

    pZone -- zone to refresh

Return Value:

    None.

--*/
{
    DNS_DEBUG( XFR, (
        "Xfr_ForceZoneRefresh( %s )\n",
        pZone->pszZoneName ));

    //  set expire time to NOW
    //  then wake up zone control thread to force expiration

    pZone->dwNextSoaCheckTime = DNS_TIME();

    SetEvent( g_hWakeSecondaryEvent );
}




//
//  Secondary control, public functions
//
//  These routines are called by the main thread, or by
//  main UDP reception threads.
//

BOOL
Xfr_InitializeSecondaryZoneControl(
    VOID
    )
/*++

Routine Description:

    Initializes DNS to keep secondaries current with primary
    using zone transfer.

Arguments:

    None

Globals:

    g_fUsingSecondary
    g_SecondaryQueue

Return Value:

    TRUE, if successful
    FALSE otherwise, unable to create threads

--*/
{
    //
    //  if previous initialization
    //      - wakeup secondary control thread to initiate transfer
    //      - but skip initialization
    //

    if ( g_fUsingSecondary )
    {
        SetEvent( g_hWakeSecondaryEvent );
        return TRUE;
    }

    //
    //  create packet queue for SOA check responses and notifications
    //      - set event on queuing
    //      - discard expired packets on queuing, so don't back
    //      up queue (and bloat memory) if someone launches NOTIFY
    //      attack
    //

    g_SecondaryQueue = PQ_CreatePacketQueue(
                            "Secondary",
                            QUEUE_SET_EVENT |
                                QUEUE_DISCARD_EXPIRED,
                            DNS_SECONDARY_QUEUE_DEFAULT_TIMEOUT,
                            0 );                    //  maximum elements
    if ( !g_SecondaryQueue )
    {
        goto Failed;
    }

    //
    //  create zone transfer completion event
    //

    g_hWakeSecondaryEvent = CreateEvent(
                                NULL,       //  no security attributes
                                FALSE,      //  auto-reset
                                FALSE,      //  start non-signalled
                                NULL );     //  no name

    //
    //  create secondary version checking thread
    //

    if ( ! Thread_Create(
                "Secondary Control",
                Xfr_ZoneControlThread,
                NULL,
                DNS_EVENT_AXFR_INIT_FAILED ) )
    {
        goto Failed;
    }

    //
    //  indicate successful initialization
    //
    //  no protection is required on setting this as it is done
    //  only during startup database parsing
    //

    g_fUsingSecondary = TRUE;
    return TRUE;

Failed:

    DNS_DEBUG( INIT, ( "Xfr_InitializeSecondaryZoneControl() failed\n" ));
    return FALSE;
}   //  Xfr_InitializeSecondaryZoneControl



VOID
Xfr_CleanupSecondaryZoneControl(
    VOID
    )
/*++

Routine Description:

    Cleanup secondary control handles for restart.

Arguments:

    None

Return Value:

    None

--*/
{
    //  cleanup secondary packet queue

    PQ_CleanupPacketQueueHandles( g_SecondaryQueue );

    //  cleanup secondary thread wakeup event

    CloseHandle( g_hWakeSecondaryEvent );
    g_hWakeSecondaryEvent = NULL;
}   //  Xfr_CleanupSecondaryZoneControl



VOID
Xfr_InitializeSecondaryZoneTimeouts(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Setup initial timeouts for secondary zone.

    Note, this routine is called on creating secondary zone, giving
    EVERY secondary zone the NO SOA initialization below.  After file
    load initialization may be reset to the have SOA version.

Arguments:

    pZone - info structure for zone

Return Value:

    None.

--*/
{
    PDB_RECORD  prrSoa = NULL;
    DWORD       currentTime;

    //
    //  DEVNOTE: should pick use RefreshZone for most of this and just
    //      add LoadVersion
    //

    //
    //  DEVNOTE: this should be called after zone loaded, to reset values
    //

    pZone->dwFastSoaChecks = 0;

    //
    //  get ptr to SOA -- if available
    //

    if ( pZone->pZoneRoot )
    {
        prrSoa = RR_FindNextRecord(
                    pZone->pZoneRoot,
                    DNS_TYPE_SOA,
                    NULL,
                    0 );
    }

    pZone->pSoaRR = prrSoa;

    currentTime = GetCurrentTimeInSeconds();


    //
    //  SOA exists -- set timeouts from SOA
    //
    //      - load version, is THIS version
    //      - set to do IMMEDIATE SOA check
    //      - clear shutdown and stale flags set on zone creation
    //

    if ( prrSoa )
    {
        pZone->dwSerialNo = ntohl( prrSoa->Data.SOA.dwSerialNo );
        pZone->dwLoadSerialNo = pZone->dwSerialNo;

        pZone->dwExpireTime = ntohl(prrSoa->Data.SOA.dwExpire) + currentTime;

        pZone->dwNextSoaCheckTime = 0;

        pZone->fEmpty = FALSE;
        STARTUP_ZONE( pZone );
        pZone->fStale = FALSE;

        IF_DEBUG( ZONEXFR )
        {
            Dbg_Zone(
                "Startup of active secondary zone:\n",
                pZone );
        }
    }

    //
    //  NO SOA -- setup for zone starting shutdown
    //      - set shutdown and stale flags
    //      - check immediately
    //
    //  note, this is the default initialization for ALL secondary zones
    //  on creation;  effectively covers the case of loading secondary
    //  without datafile OR admin created zone;  for normal file load
    //  this routine is called again after data load to read SOA above
    //

    else
    {
        pZone->fEmpty = TRUE;
        SHUTDOWN_ZONE( pZone );
        pZone->fStale = TRUE;
        pZone->dwExpireTime = 0;
        pZone->dwNextSoaCheckTime = 0;

        IF_DEBUG( ZONEXFR )
        {
            Dbg_Zone(
                "Startup of shutdown secondary zone:\n",
                pZone );
        }
    }

}   //  Xfr_InitializeSecondaryZoneTimeouts



VOID
Xfr_QueueSoaCheckResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Queue SOA check response to secondary packet queue.
    This routine is called by UDP receive thread.

    Secondary zone control thread will dequeue and process.

Arguments:

    pMsg - ptr to message info

Return Value:

    None.

--*/
{
    //
    //  DEVNOTE: prevent security attack on secondary queue
    //  DEVNOTE: validation before queuing to secondary queue
    //      - is valid zone
    //      - already NOTIFIED?
    //      - packet queue that screens for duplicates (same remote IP and zone)
    //

    if ( g_fUsingSecondary )
    {
        PQ_QueuePacketEx( g_SecondaryQueue, pMsg, FALSE );
        DNS_DEBUG( ZONEXFR2, (
            "Xfr_QueueSoaCheckResponse queued %p, new queue length %d\n",
            pMsg,
            g_SecondaryQueue->cLength ));
        return;
    }

    //
    //  DEVNOTE-LOG: log warning to admin for bogus NOTIFY
    //
    //   may get NOTIFIES from server that thinks this server secondary
    //      for one of its zones
    //

    IF_DEBUG( ANY )
    {
        Dbg_DnsMessage(
            "WARNING:  Notify or SOA response while NOT secondary",
            pMsg );
    }
    Packet_Free( pMsg );
}   //  Xfr_QueueSoaCheckResponse




//
//  Secondary (and DS) control thread
//

DNS_STATUS
Xfr_ZoneControlThread(
    IN      LPVOID  pvDummy
    )
/*++

Routine Description:

    Thread to do version checking of all secondary zones.
    Initiates zone transfer when necessary.

Arguments:

    pvDummy - unused

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    DBG_FN( "Xfr_ZoneControlThread" )

    PZONE_INFO      pzone;              // zone info with nearest timeout
    PDNS_MSGINFO    pmsg;               // SOA response or notify message
    DNS_STATUS      status;
    DWORD           timeout;            // next timeout
    DWORD           currentTime;        // current time in seconds
    HANDLE          waitHandleArray[3];
    PCHAR           pszeventArgs[2];    // logging strings
    PPACKET_QUEUE   ptempQueue;

    //
    //  Create and lock temp queue. It will be held locked by this thread
    //  all the time since no other thread will need to use it.
    //

    ptempQueue = PQ_CreatePacketQueue( "ZoneXfrControl", 0, 0, 0 );
    if ( ptempQueue )
    {
        LOCK_QUEUE( ptempQueue );
    }
    else
    {
        DNS_DEBUG( ZONEXFR, (
            "%s: unable to create temp queue\n"
            "    will not requeue unhandled soa checks!", fn ));
    }

    //
    //  initialize array of objects to wait on
    //      - shutdown
    //      - received SOA or notify packet
    //      - transfer completed

    waitHandleArray[0] = hDnsShutdownEvent;
    waitHandleArray[1] = g_SecondaryQueue->hEvent;
    waitHandleArray[2] = g_hWakeSecondaryEvent;

    //
    //  Initial sleep. This thread usually starts up before all zones have 
    //  been created. Give the server some time to populate the zone list
    //  so that the first pass through the zone list takes all (or at 
    //  least more) zones into account.
    //

    status = WaitForSingleObject( hDnsShutdownEvent, 15 * 1000 );
    if ( status == WAIT_OBJECT_0 )
    {
        goto Cleanup;
    }

    //
    //  loop until service exit
    //
    //  This loop is executed essentially everytime we receive
    //  an SOA check response or notify packet OR when a timeout
    //  expires.
    //
    //  On each loop we send any SOA checks that are due (changing next
    //  timeout to retry interval), then wait for response or next timeout.
    //  On SOA response, timeouts reset for refresh, or zone transfer is
    //  initiated.
    //

    while ( TRUE )
    {
        DWORD       dwTimeSlept;

        //
        //  Check and possibly wait on service status
        //
        //  Note, we MUST do this check BEFORE any processing to make
        //  sure all zones are loaded before we begin checks.
        //

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( ZONEXFR, (
                "Terminating secondary zone control thread\n" ));
            goto Cleanup;
        }

        //
        //  calculate next zone transfer timeout
        //
        //      - loop through all secondary zones
        //      - get lowest "next time"
        //      - find offset from current time
        //        if a timeout has already elapsed, use zero
        //

        currentTime = UPDATE_DNS_TIME();
        DNS_DEBUG( ZONEXFR, (
            "Timeout check current time = %lu (s)\n",
            currentTime ));

        //
        //  loop through secondaries
        //      - inititate needed SOA checks or zone transfer
        //      - determine timeout to next check
        //
        //  note:  set no timeout at no less than a few second
        //      minimum, so don't loop pointlessly before any SOA
        //      responses come back
        //
        //  DEVNOTE: may need a timeout max value to avoid
        //              long timeout locking things up while a
        //              zone is out for transfer
        //

        pzone = NULL;
        timeout = MAXULONG;

        while ( ( pzone = Zone_ListGetNextZone( pzone ) ) != NULL )
        {
            //  ignore cache

            if ( IS_ZONE_CACHE( pzone ) )
            {
                continue;
            }

            //
            // ignore primaries and forwarding zones
            //
            else if ( IS_ZONE_PRIMARY( pzone ) || IS_ZONE_FORWARDER( pzone ) )
            {
                continue;
            }

            //
            //  secondary
            //
            //  transfer in progress -- no SOA check
            //
            //  - add master to outstanding list
            //  - include zone in timeout check below, so that
            //      we don't forget its next timeout
            //

            else if ( pzone->fXfrRecvLock )
            {
                DNS_DEBUG( XFR, (
                    "%s: zone %s still transfering from %s\n", fn,
                    pzone->pszZoneName,
                    DNSADDR_STRING( &pzone->ipFreshMaster ) ));
            }

            //
            //  zone expiring -- shut it down
            //
            //  note:  to avoid continuous sends, while master is offline,
            //  send SOA query on expiration, then only at retry intervals
            //

            else if ( pzone->dwExpireTime <= currentTime &&
                      !IS_ZONE_SHUTDOWN( pzone ) )
            {
                IF_DEBUG( XFR )
                {
                    Dbg_Zone(
                        "Expiring zone ",
                        pzone );
                }
                SHUTDOWN_ZONE( pzone );

                if ( pzone->dwLastSuccessfulXfrTime )
                {
                    //
                    //  Only log event if the zone has been successfully 
                    //  transferred since server startup. Otherwise (esp. for 
                    //  DS stub zones) this event may be logged on server
                    //  startup.
                    //

                    DNS_LOG_EVENT(
                        DNS_EVENT_ZONE_EXPIRATION,
                        1,
                        & pzone->pwsZoneName,
                        NULL,
                        0 );
                }

                //  make immediate XFR attempt

                pzone->dwNextSoaCheckTime = currentTime;
                Xfr_SendSoaQuery( pzone );
            }

            //
            //  notified / refresh / retry => send SOA
            //
            //  send SOA check when zone
            //      - at refresh
            //      - or in retry from NOTIFY (SOA or IXFR attempt)
            //          or failed refresh SOA query
            //
            //  note:  processNotify() sends immediately, so no need to
            //          check it's flag here;  retries handled through timeout
            //

            else if ( pzone->dwNextSoaCheckTime < currentTime )
            {
                Xfr_SendSoaQuery( pzone );
            }
            ELSE_IF_DEBUG( ZONEXFR )
            {
                DNS_PRINT((
                    "%s: zone %s waiting for next timeout\n", fn,
                    pzone->pszZoneName ));
            }

            //
            //  find shortest timeout in zone list
            //

            if ( pzone->dwNextSoaCheckTime < timeout )
            {
                timeout = pzone->dwNextSoaCheckTime;
            }
        }

        //
        //  time to next retry/refresh time
        //
        //  a zone's next timeout may fall behind current time while
        //  zone is "owned" by transfer thread, producing a negative
        //  timeout interval;
        //
        //  hence use a small minimum loop interval
        //      - allows reception of SOA check packets
        //      - prompt check when transfer reception thread returns
        //          zone to our control
        //      - prevent spinning and wasted cycles is zone improperly
        //          configured with zero retry
        //
        //  for safety, fire up loop every hour or so to check things out
        //  convert to milliseconds for use in WaitForMultipleObjects()
        //

        timeout -= currentTime;
        DNS_DEBUG( ZONEXFR2, (
            "Min timeout found = %lu (s)\n",
             timeout ));

        if ( (LONG)timeout < MIN_SECONDARY_ZONE_CHECK_LOOP_TIME )
        {
            timeout = MIN_SECONDARY_ZONE_CHECK_LOOP_TIME;
        }
        else if ( timeout > (DWORD)MAX_SECONDARY_ZONE_CHECK_LOOP_TIME )
        {
            timeout = MAX_SECONDARY_ZONE_CHECK_LOOP_TIME;
        }

        //
        //  Wait for
        //      - SOA packet queued event
        //      - termination event
        //  with timeout to next zone SOA check.
        //

        WaitForTimeout:

        dwTimeSlept = UPDATE_DNS_TIME();

        DNS_DEBUG( ZONEXFR, (
            "%s: sleeping for %lu seconds at %lu\n", fn,
            timeout, 
            dwTimeSlept ));

        status = WaitForMultipleObjects(
                    3,
                    waitHandleArray,
                    FALSE,                      //  either event
                    ( timeout * 1000 ) );       //  timeout in ms

        dwTimeSlept = UPDATE_DNS_TIME() - dwTimeSlept;

        #if 0

        //
        //  Adjust timeout by the amount of time we slept. Set it to
        //  zero to indicate that we slept as long as we need to.
        //

        if ( status != WAIT_OBJECT_0 + 2 || dwTimeSlept >= timeout )
        {
            //
            //  This event doesn't require us to go back to sleep or
            //  the time slept didn't make sense (could have wrapped).
            //

            timeout = 0;
        }
        else
        {
            timeout = timeout - dwTimeSlept;
        }

        #else

        //
        //  There seems to be some confusion about event usage. For now
        //  always set timeout to zero. This forces us to jump back up to
        //  top of loop and perform SOA checks as necessary after processing
        //  any outstanding received packets.
        //

        timeout = 0;

        #endif

        DNS_DEBUG( ZONEXFR2, (
            "%s: slept for %d seconds, timeout remaining %d, queue len %d\n", fn,
            dwTimeSlept,
            timeout,
            g_SecondaryQueue->cLength ));

        //
        //  Check and possibly wait on service status
        //

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( ZONEXFR, ( "%s: terminating\n", fn ));
            goto Cleanup;
        }

        //
        //  Read queued SOA check responses and NOTIFY messages
        //
        //  When indicated spawn the zone transfer threads
        //

        while ( pmsg = PQ_DequeueNextPacket( g_SecondaryQueue, FALSE ) )
        {
            DNS_DEBUG( ZONEXFR2, (
                "%s: deqeued %p length now %d\n", fn,
                 pmsg,
                 g_SecondaryQueue->cLength ));

            if ( pmsg->Head.Opcode == DNS_OPCODE_NOTIFY )
            {
                processNotify( pmsg );
            }
            else if ( IS_SOA_CHECK_XID( pmsg->Head.Xid ) )
            {
                if ( !processSoaCheckResponse( pmsg ) && ptempQueue )
                {
                    DNS_DEBUG( ZONEXFR2, (
                        "%s: SOA check resp %p not handled so requeue for later\n", fn,
                        pmsg ));
                    PQ_QueuePacketEx( ptempQueue, pmsg, TRUE );
                    pmsg = NULL;
                }
            }
            else
            {
                ASSERT( IS_IXFR_XID(pmsg->Head.Xid) );
                processIxfrUdpResponse( pmsg );
            }

            Packet_Free( pmsg );
        }

        //
        //  Requeue any messages not handled.
        //

        if ( ptempQueue && ptempQueue->cLength )
        {
            LOCK_QUEUE( g_SecondaryQueue );
            while ( pmsg = PQ_DequeueNextPacket( ptempQueue, TRUE ) )
            {
                PQ_QueuePacketEx( g_SecondaryQueue, pmsg, TRUE );
            }
            UNLOCK_QUEUE( g_SecondaryQueue );
        }

        //
        //  If there is more time left to sleep, just back up to the wait
        //  otherwise continue to the top of the loop for zone expiry checks.
        //

        if ( timeout > 0 )
        {
            goto WaitForTimeout;
        }
    }

    Cleanup:

    if ( ptempQueue )
    {
        UNLOCK_QUEUE( ptempQueue );
        PQ_DeletePacketQueue( ptempQueue );
    }

    return 1;
}   // Xfr_ZoneControlThread



//
//  SOA\IXFR request routines
//

PDNS_MSGINFO
Xfr_BuildXfrRequest(
    IN OUT  PZONE_INFO      pZone,
    IN      WORD            wType,
    IN      BOOL            fTcp
    )
/*++

Routine Description:

    Build IXFR query.

Arguments:

    pZone - info structure for zone

Return Value:

    Ptr to IXFR message buffer.

--*/
{
    PDNS_MSGINFO    pmsg;
    DWORD           length;

    //  verify secondary

    ASSERT( pZone );
    ASSERT( IS_ZONE_SECONDARY(pZone) );

    DNS_DEBUG( ZONEXFR, (
        "Xfr_BuildXfrRequest() for zone %s\n",
        pZone->pszZoneName ));

    //
    //  if on startup with no file, may not have SOA
    //  then can't do IXFR
    //

    if ( !pZone->pSoaRR && wType == DNS_TYPE_IXFR )
    {
        DNS_DEBUG( ZONEXFR, (
            "Skipping IXFR, no SOA in zone %s\n",
            pZone->pszZoneName ));
        return FALSE;
    }

    //
    //  create message info structure
    //

    length = 0;
    if ( fTcp )
    {
        length = DNS_TCP_MAXIMUM_RECEIVE_LENGTH;
    }
    pmsg = Msg_CreateSendMessage( length );
    IF_NOMEM( !pmsg )
    {
        return NULL;
    }

    //
    //  write zone name question
    //

    if ( ! Msg_WriteQuestion(
                pmsg,
                pZone->pZoneTreeLink,
                wType ) )
    {
        DNS_DEBUG( ANY, (
            "ERROR: unable to write type=%d query for zone %s\n",
            wType,
            pZone->pszZoneName ));
        ASSERT( FALSE );
        goto Failed;
    }

    //
    //  for IXFR
    //      - current SOA in authority section
    //      - set XID to indicate IXFR check
    //

    if ( wType == DNS_TYPE_IXFR )
    {
        ASSERT( pZone->pZoneRoot && pZone->pSoaRR );

        pmsg->Head.Xid = MAKE_IXFR_XID( pmsg->Head.Xid );

        //  write current SOA

        pmsg->fDoAdditional = FALSE;

        SET_TO_WRITE_AUTHORITY_RECORDS( pmsg );

        if ( 1 != Wire_WriteRecordsAtNodeToMessage(
                        pmsg,
                        pZone->pZoneRoot,
                        DNS_TYPE_SOA,
                        DNS_OFFSET_TO_QUESTION_NAME,
                        0 ) )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Unable to write SOA to IXFR packet %s\n",
                pZone->pszZoneName ));
            ASSERT( FALSE );
            goto Failed;
        }
    }

    //  write MS transfer tag

    APPEND_MS_TRANSFER_TAG( pmsg );

    return( pmsg );

Failed:

    if ( pmsg )
    {
        Packet_Free( pmsg );
    }
    ASSERT( FALSE );
    return NULL;
}



BOOL
Xfr_SendUdpIxfrQuery(
    IN OUT  PZONE_INFO      pZone,
    IN      PDNS_ADDR       ipAddress
    )
/*++

Routine Description:

    Send IXFR query to master.

Arguments:

    pZone - info structure for zone

    ipMaster - IP of master to send IXFR to

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    pmsg;

    //  verify secondary

    ASSERT( pZone );
    ASSERT( IS_ZONE_SECONDARY( pZone ) );
    ASSERT( ZONE_MASTERS( pZone ) );

    DNS_DEBUG( ZONEXFR, (
        "Xfr_SendUdpIxfrQuery() for zone %s\n",
        pZone->pszZoneName ));

    //
    //  if zone has no SOA -- can't IXFR
    //

    if ( !pZone->pSoaRR )
    {
        ASSERT( IS_ZONE_EMPTY(pZone) );
        return FALSE;
    }
    ASSERT( pZone->pZoneRoot );

    //
    //  create IXFR query
    //  - may be impossible if "fileless" zone on startup as no SOA to send
    //  - also possible to overrun UDP packet size with really long SOA name fields
    //

    pmsg = Xfr_BuildXfrRequest(
                pZone,
                DNS_TYPE_IXFR,
                FALSE );            //  use UDP
    if( !pmsg )
    {
        return FALSE;
    }

    //
    //  since UDP may lose query or non-IXFR-aware master may eat query
    //      or mangle response, set flag indicating IXFR tried and
    //      do short retry
    //

    pZone->dwNextSoaCheckTime = DNS_TIME() + IXFR_RETRY_INTERVAL;
    pZone->cIxfrAttempts++;

    pmsg->fDelete = TRUE;
    DnsAddr_Copy( &pmsg->RemoteAddr, ipAddress );
    STAT_INC( SecondaryStats.IxfrUdpRequest );
    Send_Msg( pmsg, 0 );

    return TRUE;
}



VOID
Xfr_SendSoaQuery(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Send SOA question to primary.

Arguments:

    pZone - info structure for zone

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    pmsg;
    DWORD           i;

    //  verify secondary

    ASSERT( pZone );
    ASSERT( IS_ZONE_SECONDARY(pZone) );
    ASSERT( ZONE_MASTERS( pZone ) );

    DNS_DEBUG( ZONEXFR, (
        "Xfr_SendSoaQuery() to masters for zone %s\n",
        pZone->pszZoneName ));

    //
    //  if zone is in transfer then don't send
    //
    //  generally should NOT be locked to process SOA or IXFR response as
    //  these should occur along with SoaQuery in zone control thread)
    //

    if ( IS_ZONE_LOCKED_FOR_WRITE(pZone) )
    {
        DNS_DEBUG( XFR, (
            "Zone %s is write-locked, skipping SOA query!\n",
            pZone->pszZoneName ));
        return;
    }

    //
    //  if NOT required SOA send, avoid spin
    //
    //  DEVNOTE: may be issue here with SOA query lockout
    //      - SOA, IXFR attempt (possibly lost other SOA responses), SOA rejected
    //

    if ( pZone->dwLastSoaCheckTime + MIN_SOA_RETRY_TIME > DNS_TIME() )
    {
        DNS_DEBUG( XFR, (
            "Skipping SOA resend on zone %s\n"
            "    Last SOA send within last %d(s)\n"
            "    last send at %d\n"
            "    current time %d\n",
            pZone->pszZoneName,
            MIN_SOA_RETRY_TIME,
            pZone->dwLastSoaCheckTime,
            DNS_TIME() ));
        return;
    }

    //
    //  create message info structure
    //

    pmsg = Msg_CreateSendMessage( 0 );
    IF_NOMEM( !pmsg )
    {
        Xfr_RetryZone( pZone );
        return;
    }

    //
    //  build SOA query
    //      - set XID to indicate SOA check

    if ( ! Msg_WriteQuestion(
                pmsg,
                pZone->pZoneTreeLink,
                DNS_TYPE_SOA ) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Unable to write SOA query for zone %s\n",
            pZone->pszZoneName ));
        Packet_Free( pmsg );
        ASSERT( FALSE );
        return;
    }
    pmsg->Head.Xid = MAKE_SOA_CHECK_XID( pmsg->Head.Xid );

    //
    //  send query to each master in list
    //      - no need to lock, atomic creation\deletion of master list
    //

    ASSERT( !pmsg->fDelete );

    pmsg->fDelete = TRUE;

    Send_Multiple(
        pmsg,
        ZONE_MASTERS( pZone ),
        & SecondaryStats.SoaRequest );

    pZone->dwLastSuccessfulSoaCheckTime = ( DWORD ) time( NULL );
    pZone->dwLastSoaCheckTime= DNS_TIME();

    //
    //  reset timeouts for retry
    //

    Xfr_RetryZone( pZone );

    //
    //  DEVNOTE: zone expiration\stale issues
    //  DEVNOTE: when IXFR fails, should be doing direct connect for AXFR
    //
    //  DEVNOTE: need flags for each server in master list
    //      - sent SOA
    //      - sent IXFR
    //      - got response
    //      - has inferior version (if all masters hit this, REBUILD!)
    //      - has superior version (or reverse, "no-help" flag)
    //      - needs AXFR resposne to IXFR
    //      - invalid IXFR (primaryServer not valid)
    //      - refused IXFR (bad candidate for AXFR)
    //      - refused AXFR
    //
    //      Permanent flags:
    //      - doesn't understand IXFR
    //
    //  then can push through list trying IXFR until
    //      - success IXFR
    //      - known in ssync (all back are in ssync at least one at current)
    //      - need AXFR
    //      - can't get response from anyone, fall to default timeouts
    //

}   //  Xfr_SendSoaQuery



//
//  SOA\IXFR response routines
//

BOOL
matchMessageToMaster(
    IN      PDNS_MSGINFO    pMsg,
    IN      PZONE_INFO      pZone,
    OUT     PDNS_ADDR       pAddrMaster
    )
/*++

Routine Description:

    Matches message sender to a zone master.

Arguments:

    pMsg -- message received

    pZone -- zone to find master in
    
    pAddrMaster -- set to addr of matching master

Return Value:

    TRUE if matching master found, else FALSE

--*/
{
    ASSERT( pAddrMaster );
    
    if ( DnsAddrArray_ContainsAddr(
            ZONE_MASTERS( pZone ),
            &pMsg->RemoteAddr,
            DNSADDR_MATCH_IP ) )
    {
        if ( pAddrMaster )
        {
            DnsAddr_Copy( pAddrMaster, &pMsg->RemoteAddr );
        }
        return TRUE;
    }
    return FALSE;
}



PZONE_INFO
readZoneFromSoaAnswer(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            wType,
    OUT     PDWORD          pdwVersion,
    OUT     PDB_RECORD *    ppSoaRR
    )
/*++

Routine Description:

    Read zone info from SOA response.

Arguments:

    pMsg - ptr to response info

Return Value:

    None.

--*/
{
    register PCHAR  pch;
    PZONE_INFO      pzone;
    PDB_RECORD      psoaRR = NULL;


    DNS_DEBUG( ZONEXFR, ( "readZoneFromSoaAnswer(%p)\n", pMsg ));

    //
    //  validate as response packet
    //      - also points pCurrent at response
    //
    //  DEVNOTE: may want to handle no-answer case to catch authority empty
    //      responses from BIND servers that are not IXFR aware
    //

    if ( !Msg_ValidateResponse( pMsg, NULL, wType, 0 ) )
    {
        goto PacketError;
    }

    //
    //  find the zone
    //      - answer for node in database
    //      - must be zone root
    //      - zone must be secondary in list
    //      - sender IP, should be zone master
    //

    pzone = Lookup_ZoneForPacketName(
                pMsg->MessageBody,
                pMsg );
    if ( ! pzone )
    {
        Dbg_MessageName(
            "ERROR:  received SOA\\IXFR\\NOTIFY for non-authoritative zone ",
            pMsg->pCurrent,
            pMsg );
        //CLIENT_ASSERT( FALSE );
        goto PacketError;
    }
    pMsg->pzoneCurrent = pzone;

    //
    //  must be secondary (though may get NOTIFY to primary for DS-integrated)
    //

    if ( !IS_ZONE_SECONDARY(pzone) )
    {
        if ( pMsg->Head.Opcode == DNS_OPCODE_NOTIFY )
        {
            return( pzone );
        }
        //  CLIENT_ASSERT( FALSE );
        goto PacketError;
    }

    //
    //  if notify, may not have SOA
    //

    if ( pMsg->Head.AnswerCount == 0 )
    {
        if ( pMsg->Head.Opcode == DNS_OPCODE_NOTIFY )
        {
            return( pzone );
        }
        //  CLIENT_ASSERT( FALSE );       // no SOA in response
        goto PacketError;
    }

    //
    //  parse SOA record
    //      - pull out master's version
    //

    pch = Wire_SkipPacketName( pMsg, pMsg->pCurrent );
    if ( ! pch )
    {
        goto PacketError;
    }

    //
    //  build SOA
    //      - will always need to check version
    //      - sometimes will need to check primary server
    //

    psoaRR = Wire_CreateRecordFromWire(
                pMsg,
                NULL,       //  haven't parsed RR header
                pch,
                MEMTAG_RECORD_AXFR );

    if ( !psoaRR )
    {
        goto PacketError;
    }
    if ( psoaRR->wType != DNS_TYPE_SOA )
    {
        goto PacketError;
    }

    *pdwVersion = ntohl( psoaRR->Data.SOA.dwSerialNo );

    if ( ppSoaRR )
    {
        *ppSoaRR = psoaRR;
    }
    else
    {
        RR_Free( psoaRR );
    }
    return pzone;


PacketError:

    DNS_PRINT((
        "ERROR:  bogus SOA\\IXFR\\NOTIFY packet at %p from master %s\n",
        pMsg,
        MSG_IP_STRING( pMsg ) ));

    if ( ppSoaRR )
    {
        *ppSoaRR = NULL;
    }
    if ( psoaRR )
    {
        RR_Free( psoaRR );
    }
    return NULL;
}



BOOL
doesMasterHaveFreshVersion(
    IN OUT  PZONE_INFO      pZone,
    IN      PDNS_ADDR       ipMaster,
    IN      DWORD           dwMasterVersion,
    IN      BOOL            fIxfr
    )
/*++

Routine Description:

    Check if response is fresh version.
    If master has fresh version, return.
    If master has older version reset zone timeouts.

    This exists simply to share code between IXFR and SOA query
    responses.

Arguments:

    pZone -- zone to transfer

    ipMaster -- master IP address

    dwMasterVersion -- master version

    fIxfr -- TRUE if response from IXFR

Return Value:

    TRUE if master has fresh (higher) version.
    FALSE otherwise.

--*/
{
    INT         versionDiff;

    ASSERT( !IS_ZONE_SHUTDOWN( pZone ) );
    
    //
    //  compare versions, if fresh return
    //

    versionDiff = Zone_SerialNoCompare( dwMasterVersion, pZone->dwSerialNo );
    if ( versionDiff > 0 )
    {
        return TRUE;
    }

    //
    //  DEVNOTE: need IN_SYNC_VERSION and LOWER_VERSION master flags
    //      then
    //          => refresh immediately if notifier
    //      otherwise
    //          -- all IN_SYNC => refresh
    //          -- all higher => log error
    //

    if ( versionDiff == 0 )
    {
#if 0
        //
        //  DEVNOTE: log to log, not event log
        //
        pszeventArgs[0] = pZone->pszZoneName;
        pszeventArgs[1] = szdwMasterVersion;
        pszeventArgs[2] = pszipMaster;

        DNS_LOG_EVENT(
            DNS_EVENT_ZONE_IN_SYNC,
            3,
            pszeventArgs,
            EVENTARG_ALL_UTF8,
            0 );
#endif
        DNS_DEBUG( ZONEXFR, (
            "Zone %s in sync with master, refresh timeouts\n",
            pZone->pszZoneName ));

        if ( DnsAddr_IsClear( &pZone->ipNotifier ) ||
             DnsAddr_IsEqual(
                &pZone->ipNotifier,
                ipMaster,
                DNSADDR_MATCH_IP ) )
        {
            Xfr_RefreshZone( pZone );
        }
        else
        {
            pZone->fSlowRetry = TRUE;
            Xfr_RetryZone( pZone );
        }
    }

    //
    //  newer version than current?
    //
    //  if contacting another secondary rather than primary, then
    //  might have a version that is actually older than our own
    //
    //  test if difference < 0, this should not be true in any reasonable
    //  case IF not at startup of no file secondary
    //
    //  instead test if difference is greater than half a DWORD,
    //  then the "New" version is actually older
    //
    //  example:
    //      sNew = 5            sOld = 10           => transfer
    //      sNew = 0            sOld = 0xffffffff   => transfer
    //      sNew = 0xffffffff   sOld = 5            => hold onto old
    //

    else
    {
       ASSERT( (LONG)versionDiff < 0 );
#if 0
       argArray[0]  = pZone->pszZoneName;
       argArray[1]  = (PCHAR) pZone->dwSerialNo;
       argArray[2]  = (PCHAR) dwMasterVersion;
       argArray[3]  = (PCHAR) ipMaster;

       typeArray[0] = EVENTARG_UTF8;
       typeArray[1] = EVENTARG_DWORD;
       typeArray[2] = EVENTARG_DWORD;
       typeArray[3] = EVENTARG_IP_ADDRESS;

       DNS_LOG_EVENT(
           DNS_EVENT_ZONE_NEWER_THAN_SERVER_VERSION,
           4,
           argArray,
           typeArray,
           0 );
#endif

       DNS_DEBUG( XFR, (
           "WARNING:  Secondary zone %s newer than master (%s) -- no transfer\n"
           "    new version      = %08lx\n"
           "    current version  = %08lx\n",
           pZone->pszZoneName,
           DNSADDR_STRING( ipMaster ),
           dwMasterVersion,
           pZone->dwSerialNo ));

       if ( DnsAddr_IsClear( &pZone->ipNotifier ) ||
            DnsAddr_IsEqual(
                &pZone->ipNotifier,
                ipMaster,
                DNSADDR_MATCH_IP ) )
       {
           Xfr_RefreshZone( pZone );
       }
       else
       {
           pZone->fSlowRetry = TRUE;
           Xfr_RetryZone( pZone );
       }
    }
    return FALSE;
}



VOID
processNotify(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process NOTIFY packet.

    Find zone for notify, and setup zone for SOA check.
    Note:  Does NOT free NOTIFY packet -- callers responsibility.

Arguments:

    pMsg -- NOTIFY packet

Return Value:

    None.

--*/
{
    PZONE_INFO      pzone;
    PDNS_ADDR       ipnotifier;
    DWORD           masterVersion = 0;
    INT             versionDiff;

    ASSERT( pMsg->Head.Opcode == DNS_OPCODE_NOTIFY );

    DNS_DEBUG( ZONEXFR, ( "processNotify( %p )\n", pMsg ));

    STAT_INC( SecondaryStats.NotifyReceived );

    //
    //  verify we have SOA notify, ignore other types
    //

    ipnotifier = &pMsg->RemoteAddr;

    if ( pMsg->wQuestionType != DNS_TYPE_SOA )
    {
        DNS_PRINT(( "WARNING:  message at %p, non-SOA NOTIFY\n", pMsg ));
        STAT_INC( SecondaryStats.NotifyInvalid );
        return;
    }

    //
    //  verify packet
    //      - set to response since readZoneFromSoaAnswer will use ValidateResponse()
    //      - will extract SOA in notify if available
    //

    pMsg->Head.IsResponse = TRUE;

    pzone = readZoneFromSoaAnswer(
                pMsg,
                DNS_TYPE_SOA,
                &masterVersion,
                NULL );
    if ( !pzone )
    {
        Dbg_MessageName(
            "ERROR:  received notify for non-existent or non-root node\n",
            pMsg->MessageBody,
            pMsg );
        STAT_INC( SecondaryStats.NotifyInvalid );
        return;
    }
    pMsg->Head.IsResponse = FALSE;

    DNS_DEBUG( XFR, (
        "Received notify for zone %s, at version %d\n"
        "    current version = %d\n",
        pzone->pszZoneName,
        masterVersion,
        pzone->dwSerialNo ));

    //
    //  check if primary zone
    //
    //  DEVNOTE: should log non-DS primary partner
    //  DEVNOTE: should we ACK notifies even if bogus?
    //

    if ( IS_ZONE_PRIMARY(pzone) )
    {
        //STAT_INC( PrivateStats.PrimaryNotifies );

        if ( pzone->fDsIntegrated )
        {
            DNS_DEBUG( XFR, (
                "Notify to primary-DS zone (presumably from partner)\n",
                pzone->pszZoneName ));
        }

        //
        //  DEVNOTE-LOG: log someone sending NOTIFYs to primary
        //

        Dbg_MessageName(
            "ERROR:  received notify for PRIMARY zone\n",
            pMsg->MessageBody,
            pMsg );
        STAT_INC( SecondaryStats.NotifyPrimary );
        return;
    }

    //
    //  Check if other zone type that does not want notifies.
    //

    if ( IS_ZONE_STUB( pzone ) || IS_ZONE_FORWARDER( pzone ) )
    {
        DNS_DEBUG( XFR, (
            "Notify to non-primary zone %s zone type %d\n",
            pzone->pszZoneName,
            pzone->fZoneType ));
        Dbg_MessageName(
            "ERROR: received notify for non-primary zone\n",
            pMsg->MessageBody,
            pMsg );
        STAT_INC( SecondaryStats.NotifyNonPrimary );
        return;
    }

    //
    //  ACK notify packet
    //      - reset pCurrent to message length
    //      (readZoneFromSoaAnswer() leaves pCurrent at end of Question)
    //      - simply flip on IsResponse bit and send back
    //      - clear fDelete as message freed in main thread routine
    //

    pMsg->pCurrent = DNSMSG_END( pMsg );
    pMsg->Head.IsResponse = TRUE;
    pMsg->fDelete = FALSE;
    Send_Msg( pMsg, 0 );

    //
    //  no current version -- must send
    //

    if ( !pzone->pSoaRR )
    {
        STAT_INC( SecondaryStats.NotifyNoVersion );
        goto Send;
    }

    //
    //  check serial
    //      - notify only interesting if larger serial
    //

    if ( masterVersion )
    {
        versionDiff = Zone_SerialNoCompare( masterVersion, pzone->dwSerialNo );
        if ( versionDiff == 0 )
        {
            DNS_DEBUG( XFR, (
                "Notified by %s at same as current zone version %d\n",
                DNSADDR_STRING( ipnotifier ),
                pzone->dwSerialNo ));
            STAT_INC( SecondaryStats.NotifyCurrentVersion );
            return;
        }
        else if ( versionDiff < 0 )
        {
            DNS_DEBUG( XFR, (
                "Notified by %s at version %d less than current version %d\n",
                DNSADDR_STRING( ipnotifier ),
                masterVersion,
                pzone->dwSerialNo ));
            STAT_INC( SecondaryStats.NotifyOldVersion );
            return;
        }
        else
        {
            DNS_DEBUG( XFR, (
                "Notified by %s at version %d greater than current version %d\n",
                DNSADDR_STRING( ipnotifier ),
                masterVersion,
                pzone->dwSerialNo ));
            STAT_INC( SecondaryStats.NotifyNewVersion );
        }
    }

Send:

    //
    //  DEVNOTE: pick best notifier (highest version), if already notified
    //
    //  DEVNOTE: log complaint, if ONLY one master and it is behind in count
    //
    //  DEVNOTE: notified, same version, different primary???
    //
    //  DEVNOTE: fNotified flag is currently doing anything
    //

    //
    //  check if notifier is in zone's master list
    //  not necessarily a problem, as primary master may notify everyone
    //

    DnsAddr_Reset( &pzone->ipNotifier );
    pzone->fNotified = TRUE;
    ipnotifier = &pMsg->RemoteAddr;

    if ( DnsAddrArray_ContainsAddr(
            ZONE_MASTERS( pzone ),
            ipnotifier,
            DNSADDR_MATCH_IP ) )
    {
        DnsAddr_Copy( &pzone->ipNotifier, ipnotifier );

        if ( Xfr_SendUdpIxfrQuery(
                pzone,
                ipnotifier ) )
        {
            return;
        }
    }

    STAT_INC( SecondaryStats.NotifyMasterUnknown );

    //
    //  notifier not in master list OR we can't build IXFR
    //

    DNS_DEBUG( ZONEXFR, (
        "WARNING:  Notify packet (%p), for zone %s, from %s\n"
        "    NOT a specified master for this secondary zone\n",
        pMsg,
        pzone->pszZoneName,
        DNSADDR_STRING( ipnotifier ) ));

    Xfr_SendSoaQuery( pzone );

    //
    //  set NOTIFIED flag on zone -- forces SOA check request
    //
    //  DEVNOTE: save notified version, keep trying until get IT
    //
    //  DEVNOTE: save notify recv() socket
    //      this lets us send XFR on socket bound to this address
    //      either
    //      1) send SOA query on this socket, so get SOA response on it
    //      and hence have existing code to XFR with SOA response socket binding
    //      2) save notify recv socket binding IP, then can use it in XFR
    //      problem here is to know that notify binding() is correct
    //          - multiple notifies, second overwrites first
    //          - final responding server not original notifier
    //

}   //  processNotify



BOOL
processSoaCheckResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process response to SOA query from primary.

    Check that response is valid or determine whether serial number is
    new for its zone.

    Then refresh zone or initiate zone transfer.

Arguments:

    pMsg - ptr to response info

Return Value:

    Returns FALSE if no action was taken for this packet, for example if
    a zone transfer thread was not created because too many threads are
    already outstanding. The caller may will to requeue the msg and handle
    it later.

--*/
{
    DBG_FN( "processSoaCheckResponse" )

    BOOL        bmessageHandled = TRUE;
    PZONE_INFO  pzone = NULL;
    PDB_NODE    pnode = NULL;
    DWORD       i;
    BOOL        fzoneLocked = FALSE;
    DWORD       masterVersion = 0;      // serial number in SOA response
    DWORD       currentVersion;         // current serial number
    DWORD       versionDiff;
    PDNS_ADDR   masterIp;
    PCHAR       argArray[4];            // logging args
    BYTE        typeArray[4];

    DNS_DEBUG( ZONEXFR, ( "%s: pMsg %p\n", fn,  pMsg ));

    STAT_INC( SecondaryStats.SoaResponse );

    //
    //  Verify valid SOA response and extract zone. Note that AnswerCount
    //  can be greater than 1 because of SIGs.
    //

    if ( pMsg->Head.AnswerCount == 0 ||
        pMsg->Head.ResponseCode != DNS_RCODE_NO_ERROR )
    {
        goto SoaPacketError;
    }
    pzone = readZoneFromSoaAnswer(
                pMsg,
                DNS_TYPE_SOA,
                & masterVersion,
                NULL );
    if ( !pzone )
    {
        goto SoaPacketError;
    }

    ASSERT( IS_ZONE_SECONDARY( pzone ) );

    //
    //  match SOA sender to a zone master server
    //
    //  don't do XID match, as may get caught always receiving
    //  and ignoring responses to previous SOA queries
    //
    //
    //  DEVNOTE: can not count on getting response from same master IP as sent
    //
    //  DEVNOTE: needs protection from admin or else master list structure
    //              must be atomic update
    //

    masterIp = &pMsg->RemoteAddr;

    if ( !DnsAddrArray_ContainsAddr(
            ZONE_MASTERS( pzone ),
            masterIp,
            DNSADDR_MATCH_IP ) )
    {
        DNS_DEBUG( ZONEXFR, (
            "ERROR: SOA response (%p), for zone %s, from %s\n"
            "    NOT from specified master for this secondary\n",
            pMsg,
            pzone->pszZoneName,
            DNSADDR_STRING( masterIp ) ));
        goto SoaPacketError;
    }

    //
    //  lock zone
    //

    if ( !Zone_LockForXfrRecv( pzone ) )
    {
        DNS_DEBUG( XFR, (
            "%s: zone %s is locked ignoring SOA response\n", fn,
            pzone->pszZoneName ));
        goto Cleanup;
    }
    fzoneLocked = TRUE;


    //
    //  get current serial number for zone
    //      - make string representation for logging
    //
    //  If zone has no serial (i.e. no SOA) it is new unloaded zone
    //  (or broken somehow) and needs immediate transfer. Also if the
    //  zone is shutdown it was probably expired or has been manually
    //  reloaded and so requires immediate transfer.
    //

    if ( IS_ZONE_EMPTY( pzone ) || IS_ZONE_SHUTDOWN( pzone ) )
    {
        pzone->fNeedAxfr = TRUE;
        goto TransferZone;
    }

    //
    //  compare versions
    //      - if unchanged or lower, reset timeouts and we're done
    //      - if higher then transfer
    //

    if ( ! doesMasterHaveFreshVersion(
                pzone,
                masterIp,
                masterVersion,
                FALSE ) )               //  not IXFR response
    {
        goto Cleanup;
    }

    //
    //  disable IXFR for stub zones - always use "customized" zone
    //  transfer (overridden in AXFR code).
    //

    if ( IS_ZONE_STUB( pzone ) )
    {
        pzone->fNeedAxfr = TRUE;
    }

TransferZone:

    DNS_DEBUG( XFR, (
        "%s: attempting to start xfer for zone %s\n", fn,
        pzone->pszZoneName ));
    
    //
    //  indicate new version on master
    //      - if unable to transfer, we'll know to keep trying
    //

    pzone->fStale = TRUE;

    //
    //  if haven't done IXFR, try it (if possible)
    //  otherwise do AXFR
    //
    //  DEVNOTE: consider SOA response master to be different from notifier
    //      a notifier definitely WILL XFR with you;  this one may not
    //
    //  DEVNOTE: need to check if THIS server has failed IXFR
    //

    if ( !pzone->fNeedAxfr  &&
            !pzone->fSkipIxfr &&
            pzone->cIxfrAttempts < 5 &&
            (DWORD)pzone->cIxfrAttempts < ZONE_MASTERS( pzone )->AddrCount  )
    {
        ASSERT( !IS_ZONE_EMPTY(pzone) );
        if ( Xfr_SendUdpIxfrQuery( pzone, masterIp ) )
        {
            goto Cleanup;
        }
    }

    pzone->fNeedAxfr = TRUE;    // force AXFR

    //
    //  If we could not start a TCP zone transfer, discard the SOA check
    //  response and try again later.
    //
    
    if ( !startTcpXfr(
                pzone,
                masterIp,
                masterVersion,
                pMsg->Socket ) )
    {
        bmessageHandled = FALSE;
    }
    
    //
    //  startTcpXfr assumed ownership of the lock and has unlocked or passed
    //  control to the zone transfer thread as required.
    //
    
    fzoneLocked = FALSE;
    
    goto Cleanup;

SoaPacketError:

    //
    //  bad response, problem with other server
    //      or
    //  server doesn't have zone (NAME_ERROR)
    //

    STAT_INC( SecondaryStats.SoaResponseInvalid );
#if 0
    pszeventArgs[0] = pzone->pszZoneName;
    pszeventArgs[1] = pszmasterIp;

    DNS_LOG_EVENT(
        DNS_EVENT_ZONE_SERVER_BAD_RESPONSE,
        2,
        pszeventArgs,
        EVENTARG_ALL_UTF8,
        GetLastError() );
#endif

    IF_DEBUG( ZONEXFR )
    {
        Dbg_DnsMessage(
            "ERROR:  Bad SOA check response",
            pMsg );
    }

Cleanup:

    //
    //  Increment or reset fast SOA check count.
    //
    
    if ( pzone )
    {
        if ( bmessageHandled )
        {
            pzone->dwFastSoaChecks = 0;
        }
        else
        {
            ++pzone->dwFastSoaChecks;
        }
        
        //
        //  If we have done too many fast checks on this zone,
        //  mark it as handled and reset the zone counters for
        //  the next retry.
        //
        
        if ( !bmessageHandled &&
             pzone->dwFastSoaChecks > MAX_FAST_SOA_CHECKS )
        {
            bmessageHandled = TRUE;
            Xfr_RetryZone( pzone );
        }
    }

    if ( fzoneLocked )
    {
        Zone_UnlockAfterXfrRecv( pzone );
    }
    return bmessageHandled;
}   //  processSoaCheckResponse



VOID
processIxfrUdpResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process IXFR response.

Arguments:

    pMsg - ptr to response info

Return Value:

    None.

--*/
{
    PZONE_INFO  pzone = NULL;
    PDB_RECORD  psoaRR = NULL;
    DNS_STATUS  status;
    DWORD       masterVersion = 0;      //  serial number in SOA response
    DWORD       currentVersion;
    DWORD       versionDiff;
    PDNS_ADDR   masterIp;
    BOOL        fzoneLocked = FALSE;
    UPDATE_LIST ixfrUpdateList;
    UPDATE_LIST passUpdateList;
    DWORD       eventId;
    PVOID       argArray[4];            // logging args
    BYTE        typeArray[4];


    DNS_DEBUG( ZONEXFR, (
        "processIxfrUdpMsg(%p)\n"
        "    from master %s\n",
        pMsg,
        MSG_IP_STRING( pMsg ) ));
    IF_DEBUG( ZONEXFR2 )
    {
        Dbg_DnsMessage(
            "IXFR response\n",
            pMsg );
    }

    STAT_INC( SecondaryStats.IxfrUdpResponse );

    //  init update lists here, so we can call free routine in all cases
    //  both success and failure during parsing require free to avoid leak

    Up_InitUpdateList( &ixfrUpdateList );
    Up_InitUpdateList( &passUpdateList );

    //
    //  verify packet
    //

    pzone = readZoneFromSoaAnswer(
                pMsg,
                DNS_TYPE_IXFR,
                & masterVersion,
                & psoaRR );
    if ( !pzone )
    {
        //  DEVNOTE: check for authoritative empty response here
        //      non-ixfr MS-DNS would FORMERR IXFR, but a BIND server might
        //      accept as and simply indicate no "IXFR records"
        //  when stop generally going to AXFR on packet errors, need to
        //  make sure this particular case gets handled that way

        //  also should set SkipIxfr flag if clearly detect valid master with
        //      IXFR support problem

        DNS_DEBUG( ANY, (
            "ERROR:  IXFR response not for secondary zone!\n" ));
        status = DNS_ERROR_ZONE_NOT_SECONDARY;
        STAT_INC( SecondaryStats.IxfrUdpInvalid );
        goto Cleanup;
    }

    ASSERT( IS_ZONE_SECONDARY(pzone) );

#if 0
    //
    //  DEVNOTE: nice to do IXFR parsing outside of lock, but DOES NOT
    //              have much impact as really only affects locking out primary
    //              XFR;  other secondary action (outside AXFR) is on this thread
    //
    //  zone transfer lock to another server?
    //      - if so, dangerous to munge flags
    //
    //  note:  once verify zone not locked, then we can munge with
    //      impunity since ONLY zone control thread calls this function
    //      and starts transfers
    //      might lock zone on another thread to service an XFR as master
    //      but that wouldn't affect these secondary flags
    //

    if ( IS_ZONE_LOCKED(pzone) )
    {
        DNS_DEBUG( XFR, (
            "IXFR response from %s, for currently LOCKED zone %s\n"
            "    ignoring IXFR response\n",
            DNSADDR_STRING( masterIp ),
            pzone->pszZoneName ));
        goto Cleanup;
    }
#endif

    //
    //  lock zone
    //

    if ( !Zone_LockForXfrRecv(pzone) )
    {
        DNS_DEBUG( XFR, (
            "Secondary Zone %s, locked -- unable to process UDP IXFR response\n"
            "    ipFreshMaster    = %s\n"
            "    IXFR master      = %s\n",
            pzone->pszZoneName,
            DNSADDR_STRING( &pzone->ipFreshMaster ),
            MSG_IP_STRING( pMsg ) ));
        goto Cleanup;
    }
    fzoneLocked = TRUE;

    //
    //  match IXFR sender to a zone master server
    //
    //  DEVNOTE: can not count on getting response from same master IP as sent
    //
    //  DEVNOTE: needs protection from admin or else master list structure
    //              must be atomic update
    //
    //  DEVNOTE: use IXFR version info on IXFR from other server
    //      issues:
    //          - need to verify in list, or use just to force SOA requery
    //          - if in list, and higher than expected, try to get IXFR?
    //
    //  DEVNOTE: can not count on getting response from same master IP as sent
    //
    //  DEVNOTE: needs protection from admin or else master list structure
    //              must be atomic update
    //

    masterIp = &pMsg->RemoteAddr;

    if ( !DnsAddrArray_ContainsAddr(
            ZONE_MASTERS( pzone ),
            masterIp,
            DNSADDR_MATCH_IP ) )
    {
        DNS_DEBUG( ZONEXFR, (
            "ERROR:  IXFR response (%p), for zone %s, from %s\n"
            "    NOT from specified master for this secondary\n",
            pMsg,
            pzone->pszZoneName,
            DNSADDR_STRING( masterIp ) ));
        STAT_INC( SecondaryStats.IxfrUdpWrongServer );
        goto Cleanup;
    }

#if 0
    //
    //  if do SOA query first and designate "fresh master" then this is correct
    //      approach.  currently sending IXFR instead
    //
    //  if not master IP we just sent to
    //      - then assume this is stale, toss away
    //

    masterIp = pMsg->RemoteAddress.sin_addr.s_addr;

    if ( masterIp != pzone->ipFreshMaster && pzone->ipFreshMaster )
    {
        DNS_DEBUG( ZONEXFR, (
            "WARNING:  IXFR response (%p), for zone %s, version = %d, from %s\n"
            "    NOT from specified master %p for this secondary\n",
            pMsg,
            pzone->pszZoneName,
            DNSADDR_STRING( masterIp ),
            pzone->ipFreshMaster ));

        STAT_INC( SecondaryStats.IxfrUdpWrongServer );
        goto Cleanup;
    }
#endif

    //
    //  need AXFR
    //      - now sending IXFR requests sometimes like SOA requests
    //

    if ( !pzone->pSoaRR )
    {
        DNS_PRINT((
            "ERROR:  IXFR response to zone %s, with no SOA\n"
            "    should have never sent IXFR!!!\n",
            pzone->pszZoneName ));
        goto TryAxfr;
    }

    //
    //  compare versions
    //      - if unchanged or lower, reset timeouts and we're done
    //      - if higher then continue to process IXFR
    //

    if ( ! doesMasterHaveFreshVersion(
                pzone,
                masterIp,
                masterVersion,
                TRUE ) )            //  IXFR
    {
        STAT_INC( SecondaryStats.IxfrUdpNoUpdate );
        goto Cleanup;
    }

    //
    //  protect against bad IXFR to multi-DS-primary
    //  IXFR must satisfy one of two conditions
    //      - be from IP of last AXFR
    //      - have the same PrimaryServer field in the SOA
    //          indicating ultimate source is the same
    //
    //  DEVNOTE: should keep trying last AXFR master until sure it's dead
    //              before pulling whole AXFR
    //

    if ( !DnsAddr_IsEqual(
            masterIp,
            &pzone->ipLastAxfrMaster,
            DNSADDR_MATCH_IP ) )
    {
        if ( !Name_IsEqualDbaseNames(
                    &psoaRR->Data.SOA.namePrimaryServer,
                    &pzone->pSoaRR->Data.SOA.namePrimaryServer ) )
        {
            DNS_DEBUG( XFR, (
                "WARNING:  IXFR response with new primary, forcing AXFR!\n"
                "    IXFR master      = %s\n"
                "    last AXFR master = %s\n",
                DNSADDR_STRING( masterIp ),
                DNSADDR_STRING( &pzone->ipLastAxfrMaster ) ));
            STAT_INC( SecondaryStats.IxfrUdpNewPrimary );
            goto TryAxfr;
        }
    }

    //
    //  parse IXFR packet
    //      - init update lists
    //      - init packet context
    //      - parse packet
    //

    XFR_MESSAGE_NUMBER( pMsg ) = 1;
    IXFR_CLIENT_VERSION( pMsg ) = pzone->dwSerialNo;

    IXFR_MASTER_VERSION( pMsg ) = 0;
    RECEIVED_XFR_STARTUP_SOA( pMsg ) = FALSE;

    pMsg->pzoneCurrent = pzone;

    status =  Xfr_ParseIxfrResponse(
                    pMsg,
                    &ixfrUpdateList,        //  full update list for transfer
                    &passUpdateList );      //  update list for this pass

    switch ( status )
    {

    case DNSSRV_STATUS_AXFR_COMPLETE:
        DNS_DEBUG( ZONEXFR, (
            "Recv'd valid UDP IXFR %p, from %s\n",
            pMsg,
            DNSADDR_STRING( masterIp ) ));
        goto Done;

    case DNSSRV_STATUS_NEED_AXFR:

        //  the server has sent a single response SOA with its version
        //  this can be because
        //      - TCP necessary (IXFR does not fit in UDP message)
        //      - or AXFR required

        DNS_DEBUG( ZONEXFR, (
            "IXFR msg at %p indicates need TCP\n",
            pMsg ));

        STAT_INC( SecondaryStats.IxfrUdpUseTcp );
        goto TryTcp;

    case DNSSRV_STATUS_IXFR_UNSUPPORTED:

        //  master doesn't support IXFR
        //  set flag so always skipped

        pzone->fSkipIxfr = TRUE;

        DNS_DEBUG( ZONEXFR, (
            "WARNING:  IXFR msg at %p confused server %s, try AXFR\n",
            pMsg ));

        STAT_INC( SecondaryStats.IxfrUdpFormerr );
        goto TryAxfr;

    case DNS_ERROR_RCODE:
    {
        DNS_DEBUG( ZONEXFR, (
            "IXFR msg at %p with RCODE %d\n",
            pMsg,
            pMsg->Head.ResponseCode ));

        goto MasterFailure;
    }

#if 0
    case ERROR_SUCCESS:

        //  log this error -- malfunctioning IXFR implementation

        DNS_DEBUG( ANY, (
            "DNS server at %s, sent incomplete UDP IXFR %p\n",
            DNSADDR_STRING( masterIp ),
            pMsg ));
        CLIENT_ASSERT( FALSE );
        goto MasterFailure;

    case DNSSRV_STATUS_AXFR_IN_IXFR:

        //  log this error -- malfunctioning IXFR implementation

        DNS_DEBUG( ANY, (
            "ERROR:  Recving AXFR in UDP IXFR message at %p\n",
            pMsg ));
        CLIENT_ASSERT( FALSE );
        goto MasterFailure;
#endif

    default:

        DNS_DEBUG( ANY, (
            "ERROR:  Unknown status %p (%d) from ParseIxfrResponse() on packet %p\n",
            status, status,
            pMsg ));

        //ASSERT( FALSE );
        goto MasterFailure;
    }

Done:

#if 0
    //  currently locking up above, before parsing message
    //
    //  valid IXFR message, read records into zone
    //

    if ( !Zone_LockForXfrRecv(pzone) )
    {
        DNS_PRINT((
            "ERROR:  Zone %s, locked -- unable to read in UDP IXFR transfer\n",
            pzone->pszZoneName ));
        goto ServerFailure;
    }
    fzoneLocked = TRUE;
#endif


    //
    //  execute IXFR updates
    //      - leave zone locked until zone XFR flags reset
    //      - reinit update list to no-op global update list cleanup below
    //

    status = Up_ApplyUpdatesToDatabase(
                & ixfrUpdateList,
                pzone,
                DNSUPDATE_IXFR |
                    DNSUPDATE_COMPLETE |
                    DNSUPDATE_NO_UNLOCK |
                    DNSUPDATE_NO_NOTIFY
                );
    if ( status != ERROR_SUCCESS )
    {
        goto ServerFailure;
    }
    Up_InitUpdateList( &ixfrUpdateList );

    ASSERT( passUpdateList.pListHead == NULL );
    ASSERT( ixfrUpdateList.pListHead == NULL );

    //
    //  turn zone back on, reset its timeouts, reset failure count
    //
    //  save this version as base version -- may not do incrementals to
    //  secondaries with lower versions
    //

    STAT_INC( SecondaryStats.IxfrUdpSuccess );
    pzone->dwBadMasterCount = 0;
    Xfr_RefreshZone( pzone );
    pzone->dwLoadSerialNo = pzone->dwSerialNo;

    //
    //  write zone back to file -- if any
    //  notify any secondaries
    //
    //  DEVNOTE: push IXFR updates to disk
    //

    //File_WriteZoneToFile( pzone );

    Xfr_SendNotify( pzone );

    ASSERT( !pzone->fSkipIxfr );
    ASSERT( !pzone->fNeedAxfr );
    goto Cleanup;


MasterFailure:

    if ( pMsg->Head.ResponseCode == DNS_RCODE_REFUSED )
    {
        STAT_INC( SecondaryStats.IxfrUdpRefused );
        eventId = DNS_EVENT_AXFR_REFUSED;
    }
    else if ( pMsg->Head.ResponseCode == DNS_RCODE_FORMERR )
    {
        STAT_INC( SecondaryStats.IxfrUdpFormerr );
        eventId = DNS_EVENT_IXFR_UNSUPPORTED;
    }
    else
    {
        STAT_INC( SecondaryStats.IxfrUdpInvalid );

        DNS_DEBUG( ANY, (
            "ERROR:  %p (%d) parsing IXFR message %p\n",
            status, status,
            pMsg ));
        IF_DEBUG( ZONEXFR )
        {
            Dbg_DnsMessage(
                "ERROR:  Bad UDP IXFR response",
                pMsg );
        }
        eventId = DNS_EVENT_AXFR_BAD_RESPONSE;
        CLIENT_ASSERT( FALSE );
    }

    //
    //  log master failure -- but avoid log spinning
    //

    if ( pzone->dwBadMasterCount < 3 )
    {
        argArray[0]  = pzone->pwsZoneName;
        argArray[1]  = ( PCHAR ) ( DWORD_PTR ) masterIp;

        typeArray[0] = EVENTARG_UNICODE;
        typeArray[1] = EVENTARG_IP_ADDRESS;

        DNS_LOG_EVENT(
            eventId,
            2,
            argArray,
            typeArray,
            0 );
    }

    //  Count successive failures so we can back off and avoid spinning
    //  when server(s) are off-line, broken or refusing AXFR

    pzone->dwBadMasterCount++;

    //
    //  DEVNOTE: separate bad server, from broken IXFR -> go to AXFR
    //      => wrong zone, misbehaving => try different server
    //      => broken IXFR -> goto AXFR
    //

    if ( pMsg->Head.ResponseCode == DNS_RCODE_REFUSED )
    {
        goto Cleanup;
    }
    goto TryAxfr;


TryAxfr:

    DNS_DEBUG( XFR, (
        "Recv() unuseable UDP IXFR (%p) from %s, forcing AXFR\n",
        pMsg,
        DNSADDR_STRING( masterIp ) ));

    STAT_INC( SecondaryStats.IxfrUdpUseAxfr );
    pzone->fNeedAxfr = TRUE;    // force AXFR

    fzoneLocked = FALSE;
    startTcpXfr( pzone, masterIp, masterVersion, pMsg->Socket );
    goto Cleanup;


TryTcp:

    ASSERT( !pzone->fSkipIxfr );
    STAT_INC( SecondaryStats.IxfrUdpUseTcp );
    pzone->fNeedAxfr = FALSE;   // try IXFR first

    startTcpXfr( pzone, masterIp, masterVersion, pMsg->Socket );
    fzoneLocked = FALSE;
    goto Cleanup;


ServerFailure:

    //
    //  Retry on transfer errors:
    //      - failure to contact server
    //      - bad packet
    //      - connection aborted or packets stop coming
    //

    STAT_INC( SecondaryStats.IxfrUdpInvalid );
    DNS_DEBUG( ANY, (
        "ERROR:  Server failure %p (%d) during transfer\n",
        status, status ));
    Xfr_RetryZone( pzone );

    //  fall through to thread exit


Cleanup:

    //
    //  cleanup
    //      - release lock on zone
    //      - free update lists
    //      - free copy of master SOA from packet
    //

    if ( fzoneLocked )
    {
        Zone_UnlockAfterXfrRecv( pzone );
    }

    if ( psoaRR )
    {
        RR_Free( psoaRR );
    }

    Up_FreeUpdatesInUpdateList( &ixfrUpdateList );
    Up_FreeUpdatesInUpdateList( &passUpdateList );

    return;

}   //  processIxfrResponse



BOOL
startTcpXfr(
    IN OUT  PZONE_INFO      pZone,
    IN      PDNS_ADDR       ipMaster,
    IN      DWORD           dwMasterVersion,
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Start up AXFR transfer.

Arguments:

    pZone -- zone to transfer

    ipMaster -- master IP address

    dwMasterVersion -- master version

    Socket -- socket of previous contact (SOA query, IXFR query) to master

Return Value:

    Return TRUE if transfer started, FALSE if not started.

--*/
{
    HANDLE  hthread;
    DWORD   waitTime;

    DNS_DEBUG( ZONEXFR, ( "startTcpXfr( %s )\n", pZone->pszZoneName ));

    ASSERT( IS_ZONE_LOCKED_FOR_WRITE( pZone ) );

    //
    //  if no master given, use current fresh master
    //

    if ( !ipMaster )
    {
        ASSERT( ipMaster );
        goto Failed;
    }

    //
    //  make sure we don't spin attempting transfer from master
    //      -- bogus misbehaving master
    //      -- master refusing this secondary
    //
    //  if master is the same as previous attempt then will refuse retry
    //  for an interval that grows with each failed attempt
    //
    //  if master is different then last attempt we based on count,
    //      no suppression for first 5 attempts so retries to other
    //      possible masters may succeeds, then limit all retries to
    //      a minute
    //

    if ( pZone->dwBadMasterCount )
    {
        waitTime = 0;

        if ( DnsAddr_IsEqual(
                &pZone->ipFreshMaster,
                ipMaster,
                DNSADDR_MATCH_IP ) )
        {
            waitTime = 60 + (pZone->dwBadMasterCount * 10);
            if ( waitTime > MAX_BAD_MASTER_SUPPRESS_INTERVAL )
            {
                waitTime = MAX_BAD_MASTER_SUPPRESS_INTERVAL;
            }
        }
        else if ( pZone->dwBadMasterCount > 5 )
        {
            waitTime = 60;
        }

        if ( pZone->dwZoneRecvStartTime + waitTime > DNS_TIME() )
        {
            DNS_DEBUG( XFR, (
                "WARNING:  Suppressing AXFR attempt on zone %s\n"
                "    to master        = %s\n"
                "    previous master  = %p\n"
                "    bad master count = %d\n"
                "    last recv() start time   %d\n"
                "    current time             %d\n"
                "    suppression lasts until  %d\n",
                pZone->pszZoneName,
                DNSADDR_STRING( ipMaster ),
                pZone->ipFreshMaster,
                pZone->dwBadMasterCount,
                pZone->dwZoneRecvStartTime,
                DNS_TIME(),
                pZone->dwZoneRecvStartTime + waitTime ));
            goto Failed;
        }
    }

    //
    //  save master address
    //

    DnsAddr_Copy( &pZone->ipFreshMaster, ipMaster );
    //pZone->dwMasterSerialNo = masterVersion;

    //
    //  get binding address from previous contact with master
    //
    //  in multi-homed case where not listening on all sockets
    //  we may be in a situation where INADDR_ANY binding would
    //  give us an non-DNS interface;  this is ok, except that
    //  master may have secondary security set and only be listing
    //  addresses that secondary is configured to run DNS on;
    //  safest course is simply to bind() to IP address corresponding
    //  to UDP socket that we just reached the master with;  obviously
    //  we can reach master from this address
    //

    DnsAddr_Reset( &pZone->ipXfrBind );

    if ( Socket )
    {
        if ( !Sock_GetAssociatedIpAddr( Socket, &pZone->ipXfrBind ) )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  UDP IXFR-SOA recv socket %d (%p), not found!\n"
                "    Binding TCP XFR INADDR_ANY\n",
                Socket, Socket ));
        }
    }

    //
    //  log zone transfer attempt
    //
    //  DEVNOTE: log file for this, regular log for completion
    //      with dynamic update may not want even completion to be logged
    //
    //  avoid spining when transfers are failing, by only logging first
    //  attempt

    if ( !pZone->dwBadMasterCount )
    {
        PVOID   argArray[ 3 ];
        BYTE    typeArray[ 3 ];

        argArray[ 0 ]  = ( PVOID ) ( DWORD_PTR ) dwMasterVersion;
        argArray[ 1 ]  = pZone->pwsZoneName;
        argArray[ 2 ]  = ( PVOID ) ipMaster;

        typeArray[ 0 ] = EVENTARG_DWORD;
        typeArray[ 1 ] = EVENTARG_UNICODE;
        typeArray[ 2 ] = EVENTARG_IP_ADDRESS;

        DNS_LOG_EVENT(
            DNS_EVENT_ZONE_TRANSFER_IN_PROGRESS,
            3,
            argArray,
            typeArray,
            0 );
    }

    //
    //  setup to transfer write lock to XFR thread
    //

    Zone_TransferWriteLock( pZone );

    //
    //  spawn zone transfer receptions thread
    //

    hthread = Thread_Create(
                  "Zone Transfer Receive",
                  Xfr_ReceiveThread,
                  (PVOID) pZone,
                  0 );
    if ( hthread )
    {
        DNS_DEBUG( ZONEXFR, (
            "Created XFR thread %p to recv zone %s\n",
            hthread,
            pZone->pszZoneName ));
        return TRUE;
    }

    //
    //  failed to create thread
    //
    //  - may well be unable to create thread, if many zones out
    //    for transfer at once
    //  - if can not start thread, then assume write lock ourselves
    //      to unlock before quit
    //
    //  DEVNOTE-LOG:  need logging for this error
    //

    DNS_DEBUG( ZONEXFR, (
        "ERROR:  unable to create thread to recv zone %s\n"
        "    from %s\n",
        pZone->pszZoneName,
        DNSADDR_STRING( ipMaster ) ));

    Zone_AssumeWriteLock( pZone );

Failed:

    //  unlock and quit

    Zone_UnlockAfterXfrRecv( pZone );
    return FALSE;
}   //  startTcpXfr



//
//  XFR recv thread
//

DWORD
Xfr_ReceiveThread(
    IN      LPVOID  pvZone
    )
/*++

Routine Description:

    Zone transfer reception thread routine.

Arguments:

    pvZone - ptr to zone info for zone being transfered

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    DBG_FN( "Xfr_ReceiveThread" )

    PZONE_INFO          pzone = (PZONE_INFO) pvZone;
    PDNS_MSGINFO        pmsg = NULL;
    PDB_NODE            pzoneRoot = NULL;
    DWORD               currentTime;
    DWORD               eventId = 0;
    DNS_STATUS          status;
    INT                 count;
    WORD                type = DNS_TYPE_IXFR;
    WORD                requestType;
    BOOL                fparseIxfr = TRUE;
    BOOL                finitialized = FALSE;
    BOOL                fnewStubQuestion = TRUE;
    BOOL                fupdateLists = FALSE;
    FD_SET              recvFdset;
    struct timeval      timeval;
    UPDATE_LIST         ixfrUpdateList;
    UPDATE_LIST         passUpdateList;
    INT                 stubZoneXfrState = 0;
    PDNS_ADDR_ARRAY     pipMasters;
    CHAR                szmasterAddr[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

    //  verify secondary

    ASSERT( pzone );
    ASSERT( IS_ZONE_SECONDARY(pzone) );
    ASSERT( pzone->fLocked && pzone->fXfrRecvLock );
    ASSERT( !DnsAddr_IsClear( &pzone->ipFreshMaster ) );

    //  assume the zone write lock

    Zone_AssumeWriteLock( pzone );

    //  save master IP string

    DnsAddr_WriteIpString_A( szmasterAddr, &pzone->ipFreshMaster );

    DNS_DEBUG( ZONEXFR, (
        "%s starting for zone %s\n"
        "    Receive transfer from master at %s\n", fn,
        pzone->pszZoneName,
        szmasterAddr ));

    //  force STUBXFR or AXFR

    if ( IS_ZONE_STUB( pzone ) )
    {
        fparseIxfr = FALSE;
        type = DNS_TYPE_STUBXFR;
    }
    else if ( pzone->fNeedAxfr || pzone->fSkipIxfr || !pzone->pSoaRR )
    {
        fparseIxfr = FALSE;
        type = DNS_TYPE_AXFR;
    }

    //
    //  loop to receive zone transfer messages
    //      - build new zone outside database
    //
    //  continue until
    //      - receive entire new zone
    //      - connection dies
    //      - service termination
    //

    while ( TRUE )
    {
        //
        //  if this is a stub zone check if we're done
        //

        if ( IS_ZONE_STUB( pzone ) &&
             g_stubXfrData[ stubZoneXfrState ].type == DNS_TYPE_ZERO )
        {
            break;
        }

        //
        //  For stub zones:
        //      Send a query for the next type in the global state table.
        //          - after initial SOA query
        //          - only if finished recv\processing of previous question
        //
        //  For other zones:
        //      Do init (we do this inside the loop, so we can retry server 
        //          that fails IXFR with AXFR)
        //

        if ( type == DNS_TYPE_STUBXFR &&
             finitialized   &&
             fnewStubQuestion )
        {
            //
            //  Format and send next STUBAXR request message.
            //  We already have a pmsg, so just clear the data in it
            //  and write a new question.
            //

            //  Clear current pmsg contents.

            RtlZeroMemory(
                ( PCHAR ) DNS_HEADER_PTR( pmsg ),
                sizeof( DNS_HEADER ) );
            pmsg->pCurrent = pmsg->MessageBody;

            //
            //  Write new question to pmsg.
            //

            if ( IS_ZONE_STUB( pzone ) )
            {
                requestType = g_stubXfrData[ stubZoneXfrState ].type;
                pmsg->Head.RecursionDesired =
                    g_stubXfrData[ stubZoneXfrState ].recursionDesired;
            }
            else
            {
                requestType = type;
            }

            if ( ! Msg_WriteQuestion(
                        pmsg,
                        pzone->pZoneTreeLink,
                        requestType ) )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  Unable to write type=%d query for stub zone %s\n",
                    requestType,
                    pzone->pszZoneName ));
                ASSERT( FALSE );
                goto ServerFailure;
            }

            //  Send pmsg to zone master server.
            Send_Query( pmsg, 0 );
            pmsg->fMessageComplete = TRUE;
            pmsg->pzoneCurrent = pzone;
            fnewStubQuestion = FALSE;
        } 
        else if ( !finitialized )
        {
            finitialized = TRUE;

            //
            //  create temp record store
            //      AXFR:  database to hold new zone during transfer
            //      IXFR:  update lists
            //
            //  then build IXFR or AXFR request
            //

            if ( IS_ZONE_STUB( pzone ) )
            {
                status = Zone_PrepareForLoad( pzone );
                if ( status != ERROR_SUCCESS )
                {
                    DNS_DEBUG( XFR, (
                        "WARNING:  Unable to init zone for STUBXFR for zone %s\n"
                        "    This should only happen when have copy of zone in cleanup queue\n",
                        pzone->pszZoneName ));
                    ASSERT( pzone->pOldTree );
                    goto ServerFailure;
                }
                STAT_INC( SecondaryStats.StubAxfrRequest );
                PERF_INC( pcAxfrRequestSent );               // PerfMon hook JJW
            } 
            else if ( fparseIxfr )
            {
                Up_InitUpdateList( &ixfrUpdateList );
                Up_InitUpdateList( &passUpdateList );
                fupdateLists = TRUE;
                STAT_INC( SecondaryStats.IxfrTcpRequest );
                PERF_INC( pcIxfrRequestSent );       // PerfMon hook
            }
            else
            {
                status = Zone_PrepareForLoad( pzone );
                if ( status != ERROR_SUCCESS )
                {
                    DNS_DEBUG( XFR, (
                        "WARNING:  Unable to init zone for AXFR in TCP-IXFR for zone %s\n"
                        "    This should only happen when have copy of zone in cleanup queue\n",
                        pzone->pszZoneName ));
                    ASSERT( pzone->pOldTree );
                    goto ServerFailure;
                }
                STAT_INC( SecondaryStats.AxfrRequest );
                PERF_INC( pcAxfrRequestSent );               // PerfMon hook
            }

            //  flag indicates we are in transfer

            pzone->fNeedAxfr = TRUE;

            //
            //  create XFR request message
            //

            requestType = IS_ZONE_STUB( pzone ) ?
                g_stubXfrData[ stubZoneXfrState ].type :
                type;
            pmsg = Xfr_BuildXfrRequest(
                        pzone,
                        requestType,
                        TRUE );         // TCP message buffer
            if ( !pmsg )
            {
                goto ServerFailure;
            }

            //
            //  connect to primary and send
            //  use select to protect against hanging attempting to connect
            //

            pzone->dwZoneRecvStartTime = DNS_TIME();

            if ( ! Msg_MakeTcpConnection(
                        pmsg,
                        &pzone->ipFreshMaster,
                        &pzone->ipXfrBind,      //  bind() address
                        0 ) )                   //  no flags, non-blocking socket
            {
                DNS_DEBUG( ZONEXFR, (
                    "Zone transfer for %s failed connection to master at %s\n",
                    pzone->pszZoneName,
                    szmasterAddr ));

                eventId = DNS_EVENT_XFR_MASTER_UNAVAILABLE;
                goto MasterFailure;
            }

            FD_ZERO( &recvFdset );
            FD_SET( pmsg->Socket, &recvFdset );

            timeval.tv_sec = SrvCfg_dwXfrConnectTimeout;
            timeval.tv_usec = 0;

            count = select( 0, NULL, &recvFdset, NULL, &timeval );

            if ( count != 1 )
            {
                DNS_DEBUG( ZONEXFR, (
                    "Zone transfer for %s timed out connecting to master at %s\n",
                    pzone->pszZoneName,
                    szmasterAddr ));

                eventId = DNS_EVENT_XFR_MASTER_UNAVAILABLE;
                goto MasterFailure;
            }

            Send_Query( pmsg, 0 );

            //
            //  receive setup
            //      - mark message complete so Tcp_ReceiveMessage() will know
            //        that need to receive message length
            //

            pmsg->fMessageComplete = TRUE;
            pmsg->pzoneCurrent = pzone;

            XFR_MESSAGE_NUMBER( pmsg ) = 0;
            IXFR_CLIENT_VERSION( pmsg ) = pzone->dwSerialNo;
            IXFR_MASTER_VERSION( pmsg ) = 0;
            RECEIVED_XFR_STARTUP_SOA( pmsg ) = FALSE;
        }

        //
        //  wait for indication
        //
        //  DEVNOTE: better to have some hosed AXFR thread detection mechanism
        //      - could detect hosed thread and kill socket waking us up
        //        (detect by timeout on transfer or since last send, when go
        //        through secondaryControlThread and find zone locked for transfer)
        //

        count = select( 0, &recvFdset, NULL, NULL, &timeval );

        if ( count != 1 )
        {
            DnsDebugLock();
            DNS_DEBUG( ANY, (
                "ERROR:  timeout on select() receiving AXFR for zone %s (%p)\n"
                "    attempting transfer from %s\n",
                pzone->pszZoneName,
                pzone,
                szmasterAddr ));

            Dbg_DnsMessage(
                "Current message of AXFR recv",
                pmsg );

            Dbg_Zone(
                "Zone hanging in AXFR recv:",
                pzone );
            DnsDebugUnlock();

            eventId = DNS_EVENT_XFR_ABORTED_BY_MASTER;
            goto MasterFailure;
        }

        //
        //  Receive the packet
        //

        DNS_DEBUG( ZONEXFR, (
            "Recv()ing zone transfer:  time = %lu\n",
            pzone->dwZoneRecvStartTime ));

        pmsg = Tcp_ReceiveMessage( pmsg );

        //
        //  Check and possibly wait on service status
        //
        //  Check before recv() error check, as shutdown will cause
        //  recv() failure.
        //

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( ZONEXFR, (
                "Terminating zone transfer thread on service exit\n" ));
            goto ThreadExit;
        }

        //
        //  No message received indicates error -- abort zone transfer
        //  Message not complete, loop back for more
        //

        if ( !pmsg )
        {
            goto ServerFailure;
        }
        if ( !pmsg->fMessageComplete )
        {
            continue;
        }

        if ( XFR_MESSAGE_NUMBER( pmsg ) == 0 )
        {
            if ( fparseIxfr )
            {
                STAT_INC( SecondaryStats.IxfrTcpResponse );
                PERF_INC( pcIxfrResponseReceived );      //PerfMon hook
            }
            else if ( IS_ZONE_STUB( pzone ) )
            {
                STAT_INC( SecondaryStats.StubAxfrResponse );
                PERF_INC( pcAxfrResponseReceived );      //PerfMon hook JJW
            }
            else
            {
                STAT_INC( SecondaryStats.AxfrResponse );
                PERF_INC( pcAxfrResponseReceived );      //PerfMon hook
            }
        }
        XFR_MESSAGE_NUMBER( pmsg )++;

        IF_DEBUG( ZONEXFR )
        {
            Dbg_DnsMessage(
                "Response from master:",
                pmsg );
        }

        //
        //  Validate packet
        //

        requestType = IS_ZONE_STUB( pzone ) ?
            g_stubXfrData[ stubZoneXfrState ].type :
            type;
        if ( ! Msg_ValidateResponse(
                    pmsg,
                    NULL,
                    requestType,
                    DNS_OPCODE_QUERY ) )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Invalid response from primary\n" ));
            goto MasterFailure;
        }

        //
        //  read IXFR packet
        //

        if ( fparseIxfr )
        {
            status =  Xfr_ParseIxfrResponse(
                            pmsg,
                            &ixfrUpdateList,        //  full update list for transfer
                            &passUpdateList );      //  update list for this pass
            if ( status == ERROR_SUCCESS )
            {
                continue;
            }
            else if ( status == DNSSRV_STATUS_AXFR_COMPLETE )
            {
                DNS_DEBUG( ZONEXFR, ( "Recv'd last message zone transfer\n" ));
                break;
            }
            else if ( status == DNSSRV_STATUS_AXFR_IN_IXFR )
            {
                DNS_DEBUG( ZONEXFR, (
                    "Recving AXFR in TCP IXFR message at %p\n",
                    pmsg ));

                //  drops through to AXFR recv
                //  note type stays IXFR, but parse remaining messages AXFR

                status = Zone_PrepareForLoad( pzone );
                if ( status != ERROR_SUCCESS )
                {
                    DNS_DEBUG( XFR, (
                        "WARNING:  Unable to init zone for AXFR in TCP-IXFR for zone %s\n"
                        "    This should only happen when have copy of zone in cleanup queue\n",
                        pzone->pszZoneName ));
                    ASSERT( pzone->pOldTree );
                    goto ServerFailure;
                }
                fparseIxfr = FALSE;
                STAT_INC( SecondaryStats.IxfrTcpAxfr );
            }
            else if ( status == DNSSRV_STATUS_IXFR_UNSUPPORTED )
            {
                DNS_DEBUG( ZONEXFR, (
                    "WARNING:  IXFR msg at %p confused server, try AXFR\n",
                    pmsg ));

                shutdown( pmsg->Socket, 2 );
                Sock_CloseSocket( pmsg->Socket );
                Packet_FreeTcpMessage( pmsg );

                //  we reinitialize and try AXFR

                fparseIxfr = FALSE;
                type = DNS_TYPE_AXFR;
                finitialized = FALSE;
                STAT_INC( SecondaryStats.IxfrTcpFormerr );
                continue;
            }
            else
            {
                DNS_DEBUG( ZONEXFR, (
                    "ERROR:  ParseIxfrResponse() failure %p (%d)\n",
                    status, status ));
                goto MasterFailure;
            }
        }

        //
        //  read AXFR packet
        //      - not in else block as drop here if receiving AXFR in IXFR
        //

        status = Xfr_ReadXfrMesssageToDatabase(
                        pzone,
                        pmsg );
        if ( status == ERROR_SUCCESS )
        {
            if ( IS_ZONE_STUB( pzone ) )
            {
                ++stubZoneXfrState; // Advance the stub state machine.
                fnewStubQuestion = TRUE;
            }
            continue;
        }
        else if ( status == DNSSRV_STATUS_AXFR_COMPLETE )
        {
            DNS_DEBUG( ZONEXFR, ( "Recv'd last message zone transfer\n" ));
            break;
        }

        DNS_DEBUG( ZONEXFR, ( "Error <%lu>: Xfr_ReadXfrMessageToDatabase() failed\n" \
                              "    Terminating zone xfr processing\n",
                              status ));

        goto MasterFailure;
    }

    //
    //  IXFR transfer done, execute IXFR updates
    //      - leave zone locked until zone XFR flags reset
    //      - reinit update list to no-op global update list cleanup below
    //

    if ( fparseIxfr )
    {
        status = Up_ApplyUpdatesToDatabase(
                    & ixfrUpdateList,
                    pzone,
                    DNSUPDATE_IXFR |
                        DNSUPDATE_COMPLETE |
                        DNSUPDATE_NO_UNLOCK |
                        DNSUPDATE_NO_NOTIFY );
        if ( status != ERROR_SUCCESS )
        {
            goto ServerFailure;
        }
        Up_InitUpdateList( &ixfrUpdateList );

        ASSERT( passUpdateList.pListHead == NULL );
        ASSERT( ixfrUpdateList.pListHead == NULL );
        STAT_INC( SecondaryStats.IxfrTcpSuccess );
        PERF_INC( pcIxfrTcpSuccessReceived );        // PerfMon hook
        PERF_INC( pcIxfrSuccessReceived );           // PerfMon hook
    }

    //
    //  AXFR transfer done
    //      - splice zone into database
    //      - delete temp database
    //

    else
    {
        status = Zone_ActivateLoadedZone( pzone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Failed writing in new zone information for zone %s\n",
                pzone->pszZoneName ));
            ASSERT( FALSE );
            goto ServerFailure;
        }

        //  save last AXFR master, can not do incrementals from differing DS primaries//      as given version does NOT mean indentical data across all DS primaries

        pzone->ipLastAxfrMaster = pzone->ipFreshMaster;
        if ( IS_ZONE_STUB( pzone ) )
        {
            STAT_INC( SecondaryStats.StubAxfrSuccess );
            PERF_INC( pcAxfrSuccessReceived );       // PerfMon hook JJW
        }
        else
        {
            STAT_INC( SecondaryStats.AxfrSuccess );
            PERF_INC( pcAxfrSuccessReceived );       // PerfMon hook
        }
    }

    //
    //  refresh zone XFR info
    //

    pzone->dwBadMasterCount = 0;
    DnsAddr_Reset( &pzone->ipFreshMaster );
    DnsAddr_Reset( &pzone->ipNotifier );

    Xfr_RefreshZone( pzone );
    pzone->dwLoadSerialNo = pzone->dwSerialNo;

    //
    //  write zone back to file -- if any
    //  notify any secondaries
    //

    File_WriteZoneToFile( pzone, NULL, 0 );
    Xfr_SendNotify( pzone );

    pzone->dwLastSuccessfulXfrTime = ( DWORD ) time( NULL );

    DNS_DEBUG( ZONEXFR, (
        "%s: success on zone %s at %lu\n", fn,
        pzone->pszZoneName,
        pzone->dwLastSuccessfulXfrTime ));

    goto ThreadExit;


MasterFailure:

    if ( eventId == 0 )
    {
        if ( pmsg->Head.ResponseCode == DNS_RCODE_REFUSED )
        {
            if ( type == DNS_TYPE_IXFR )
            {
                STAT_INC( SecondaryStats.IxfrTcpRefused );
            }
            else if ( IS_ZONE_STUB( pzone ) )
            {
                STAT_INC( SecondaryStats.StubAxfrRefused );
            }
            else
            {
                STAT_INC( SecondaryStats.AxfrRefused );
            }
            eventId = DNS_EVENT_AXFR_REFUSED;
        }
        else
        {
            DNS_DEBUG( ANY, (
                "ERROR:  %p (%d) parsing XFR message\n",
                status, status,
                pmsg ));

            IF_DEBUG( ANY )
            {
                Dbg_DnsMessage(
                    "Bogus XFR message:\n",
                    pmsg );
            }
            eventId = DNS_EVENT_AXFR_BAD_RESPONSE;
            if ( type == DNS_TYPE_IXFR )
            {
                STAT_INC( SecondaryStats.IxfrTcpInvalid );
            }
            else if ( IS_ZONE_STUB( pzone ) )
            {
                STAT_INC( SecondaryStats.StubAxfrInvalid );
            }
            else
            {
                STAT_INC( SecondaryStats.AxfrInvalid );
            }
            CLIENT_ASSERT( FALSE );
        }
    }

    //
    //  log master failure -- but avoid log spinning
    //

    if ( pzone->dwBadMasterCount < 3 )
    {
        PVOID   argArray[2];
        BYTE    typeArray[2];

        argArray[0] = pzone->pwsZoneName;
        argArray[1] = szmasterAddr;

        typeArray[0] = EVENTARG_UNICODE;
        typeArray[1] = EVENTARG_UTF8;

        DNS_LOG_EVENT(
            eventId,
            2,
            argArray,
            typeArray,
            GetLastError() );
    }

    //  Count successive failures so we can back off and avoid spinning
    //  when server(s) are off-line, broken or refusing AXFR
    //
    //  DEVNOTE: track bad masters and avoid (with long retry) using them

    DnsAddr_Reset( &pzone->ipFreshMaster );
    pzone->dwBadMasterCount++;
    goto ThreadExit;

ServerFailure:

    //
    //  Retry on transfer errors:
    //      - failure to contact server
    //      - bad packet
    //      - connection aborted or packets stop coming
    //

    DNS_DEBUG( ANY, (
        "ERROR:  Server failure %p (%d) during transfer\n",
        status, status ));
    Xfr_RetryZone( pzone );

    //  fall through to thread exit

ThreadExit:

    //
    //  shut connection
    //

    if ( pmsg )
    {
        //  close transfer socket

        if ( pmsg->Socket && pmsg->Socket != INVALID_SOCKET )
        {
            shutdown( pmsg->Socket, 2 );
            Sock_CloseSocket( pmsg->Socket );
        }
        Packet_FreeTcpMessage( pmsg );
    }

    //
    //  reset zone flags
    //
    //  always reset cIxfrAttempts, as can have failed IXFR because lost packet
    //
    //  however don't reset fSkipIxfr unless multiple masters;
    //  if have just single non-IXFR aware master, then flag prevents
    //  unnecessary IXFR queries;  with multiple masters
    //  if multiple masters, reset force AXFR flag as other masters
    //  might be IXFR aware
    //

    pzone->fNeedAxfr = FALSE;
    pzone->cIxfrAttempts = 0;
    pipMasters = ZONE_MASTERS( pzone );
    if ( pipMasters && pipMasters->AddrCount > 1 )
    {
        pzone->fSkipIxfr = FALSE;
    }

    //
    //  cleanup
    //      - free temp database
    //      - free update lists
    //      - release lock on zone
    //      - signal transfer completion
    //      - clear this thread from global array
    //

    Zone_CleanupFailedLoad( pzone );

    Zone_UnlockAfterXfrRecv( pzone );

    if ( fupdateLists )
    {
        Up_FreeUpdatesInUpdateList( &ixfrUpdateList );
        Up_FreeUpdatesInUpdateList( &passUpdateList );
    }

#if 0
    //
    //  JJW: Disabling this because for a multi-mastered zone taking 
    //  frequent updates the answer will always give different serial
    //  numbers and the server will get locked into a transfer loop.
    //

    //
    //  requery SOA if multiple masters
    //  this ensures we get the latest zone available
    //
    //  DEVNOTE: better would be to save best SOA response
    //      then make sure we update from that version (or better)
    //
    //  DEVNOTE: should probably eliminate this in favor of notify
    //

    ASSERT( ZONE_MASTERS( pzone ) );
    if ( ZONE_MASTERS( pzone ) &&
        ZONE_MASTERS( pzone )->AddrCount > 1 )
    {
        Xfr_SendSoaQuery( pzone );
    }
#endif

    //
    //  Signal the zone transfer master thread so that if other zones
    //  are ready to be transferred they can be started immediately.
    //  DEVNOTE: it would be cool to reuse this thread, but that would
    //  require getting the zone pointer from here. That would require
    //  some locking since two threads would be dequeuing responses,
    //  plus some responses are not supposed to be handled by this thread.
    //  So let's not bother with that for now.
    //

    if ( g_SecondaryQueue->cLength )
    {
        DNS_DEBUG( ZONEXFR2, (
            "%s: setting event to wake secondary thread (%d queued)\n", fn,
            g_SecondaryQueue->cLength ));
        SetEvent( g_hWakeSecondaryEvent );
    }

    Thread_Close( TRUE );
    return 0;
}



//
//  End zonesec.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\inc\ntrkcomm.h ===
#ifndef __provider_lib__
#define __provider_lib__

#if _MSC_VER > 1000
#pragma once
#endif 

#include <wbemprov.h>
#include <objbase.h>


typedef LPVOID * PPVOID;

class CWbemServices
{
protected:
	IWbemServices* m_pWbemServices;
public:
	CWbemServices(IWbemServices* );
	virtual ~CWbemServices();
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ BSTR QueryLanguage,
        /* [in] */ BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ BSTR QueryLanguage,
        /* [in] */ BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE ExecMethod( 
		BSTR, 
		BSTR, 
		long, 
		IWbemContext*,
        IWbemClassObject*,
		IWbemClassObject**, 
		IWbemCallResult**) ;
		

};


class CImpersonatedProvider : public IWbemServices, public IWbemProviderInit 
{
protected:
    ULONG              m_cRef;         //Object reference count
    CWbemServices*  m_pNamespace;
 
public:
	CImpersonatedProvider(BSTR =NULL, BSTR =NULL , BSTR =NULL, IWbemContext* =NULL);
	virtual ~CImpersonatedProvider();

	//Non-delegating object IUnknown

	STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

            //IWbemProviderInit

    HRESULT STDMETHODCALLTYPE Initialize(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink
                    );

     //IWbemServices  

	  HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};

    
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecMethod( 
		const BSTR, 
		const BSTR, 
		long, 
		IWbemContext*,
        IWbemClassObject*,
		IWbemClassObject**, 
		IWbemCallResult**) 
		{return WBEM_E_NOT_SUPPORTED;}

    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync(
		const BSTR,
		const BSTR, 
		long, 
        IWbemContext*,
		IWbemClassObject*,
		IWbemObjectSink*);
protected:
	virtual HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
		/* [in] */ BSTR,	// Class,
		/* [in] */ long,	// lFlags,
		/* [in] */ IWbemContext __RPC_FAR *,	//pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *	//pResponseHandler
		)=0;

    virtual HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
        /* [in] */ BSTR ,	//ObjectPath,
        /* [in] */ long,	// lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,	//pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *	//pResponseHandler
		) =0;

	virtual HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
		BSTR,
		BSTR, 
		long, 
        IWbemContext*,
		IWbemClassObject*,
		IWbemObjectSink*
		)=0;

    virtual HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
        /* [in] */ BSTR, // QueryLanguage,
        /* [in] */ BSTR, // Query,
        /* [in] */ long, // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,   // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR * //pResponseHandler
		) =0;
	virtual HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
		/* [in] */ BSTR ObjectPath,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
		)=0;


	virtual HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
		/* [in] */ IWbemClassObject __RPC_FAR *,	//pInst,
		/* [in] */ long	,	// lFlags,
		/* [in] */ IWbemContext __RPC_FAR *,	//pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *	//pResponseHandler
		) =0;



};

class CWbemInstanceMgr
{
	
protected:
	IWbemObjectSink* m_pSink;
	IWbemClassObject **m_ppInst;
	DWORD m_dwThreshHold;
	DWORD m_dwIndex;
public:

	CWbemInstanceMgr(
		IWbemObjectSink*,
		DWORD =50);
	virtual ~CWbemInstanceMgr();
	void Indicate(IWbemClassObject*);
	void SetStatus(
		LONG,
		HRESULT,
		BSTR, 
		IWbemClassObject*);
};



#endif // end of provlib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\inc\sqllex.h ===
//**************************