was pressed
                //pAVTapi->USBMakeCall();
                break;
            case PHSS_ONHOOK:
                pAVTapi->USBCancellCall( );
                break;
            default:
                break;
            }
        }
        break;
    case PE_BUTTON:
        {
            // Get Key event
            long lButton = 0;
            hr = pPhoneEvent->get_ButtonLampId(&lButton);
            if( FAILED(hr) )
            {
                break;
            }

            // Get the button state
            PHONE_BUTTON_STATE ButtonState;
            hr = pPhoneEvent->get_ButtonState(&ButtonState);
            if( FAILED(hr) )
            {
                break;
            }

            switch( ButtonState )
            {
            case PBS_DOWN:
                //
                // We should popup the Dial Dialogbox
                //

                if( (0 <= lButton) && (lButton <= 10 ) )
                {
                    // Just if the user pressed a digit key
                    // In USBMakeCall() method will check to see
                    // if there is no 'Placecall' dialog
                    // We allow also * key
                    pAVTapi->USBMakeCall();
                }

                break;
            case PBS_UP:
                //
                // If the Dial dialog is opened, show the digit
                // If the Phone is selected on a call
                // send the digit
                //
                pAVTapi->USBKeyPress( lButton );

                break;
            default:
                break;
            }
        }
        break;
    case PE_NUMBERGATHERED:
        {
            //
            // We read the phone number from the
            // 'PlaceCall' dialog box
            //

            pAVTapi->USBKeyPress( (long)PT_KEYPADPOUND );

        }
        break;
    default:
        break;
    }

    // Clean-up
    pPhoneEvent->Release();

    return S_OK;
}

HRESULT CTapiNotification::TapiObject_Event( 
    IN  CAVTapi *pAVTapi, 
    IN  IDispatch *pEvent
    )
{
    //
    // Validates the event interface
    // 
    if( NULL == pEvent)
    {
        return S_OK;
    }

    //
    // Get ITTAPIObjectEvent interface
    //
    ITTAPIObjectEvent* pTapiEvent = NULL;
    HRESULT hr = pEvent->QueryInterface(
        IID_ITTAPIObjectEvent,
        (void**)&pTapiEvent);

    if( FAILED(hr) )
    {
        //
        // We cannot get ITTAPIObjectEvent interface
        //
        return S_OK;
    }

    //
    // Get the TAPIOBJECT_EVENT
    //

    TAPIOBJECT_EVENT toEvent = TE_ADDRESSCREATE;
    hr = pTapiEvent->get_Event( &toEvent );

    if( SUCCEEDED(hr) )
    {
        switch( toEvent )
        {
        case TE_PHONECREATE:
            //
            // A phone was added
            //
            if( pAVTapi)
            {
                //
                // Get the ITTAPIObjectEvent2
                //
                ITTAPIObjectEvent2* pTapiEvent2 = NULL;
                hr = pTapiEvent->QueryInterface(
                    IID_ITTAPIObjectEvent2, (void**)&pTapiEvent2);

                if( SUCCEEDED(hr) )
                {
                    //
                    // Get the phone object
                    //
                    ITPhone* pPhone = NULL;
                    hr = pTapiEvent2->get_Phone(&pPhone);

                    //
                    // Clean-up ITTAPIObjectEvent2
                    //

                    pTapiEvent2->Release();

                    //
                    // Initialize the new phone
                    //

                    if( SUCCEEDED(hr) )
                    {
                        pAVTapi->USBNewPhone(
                            pPhone);

                        //
                        // Clean-up phone
                        //
                        pPhone->Release();
                    }
                }
            }
            break;
        case TE_PHONEREMOVE:
            //
            // A phone was removed
            //
            if( pAVTapi)
            {
                //
                // Get the ITTAPIObjectEvent2
                //
                ITTAPIObjectEvent2* pTapiEvent2 = NULL;
                hr = pTapiEvent->QueryInterface(
                    IID_ITTAPIObjectEvent2, (void**)&pTapiEvent2);

                if( SUCCEEDED(hr) )
                {
                    //
                    // Get the phone object
                    //
                    ITPhone* pPhone = NULL;
                    hr = pTapiEvent2->get_Phone(&pPhone);

                    //
                    // Clean-up ITTAPIObjectEvent2
                    //

                    pTapiEvent2->Release();

                    //
                    // Initialize the new phone
                    //

                    if( SUCCEEDED(hr) )
                    {
                        pAVTapi->USBRemovePhone(
                            pPhone);

                        //
                        // Clean-up phone
                        //
                        pPhone->Release();
                    }
                }
            }
            break;
        default:
            break;
        }
    }


    //
    // Clen-up ITTAPIObjectEvent interface
    //

    pTapiEvent->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\stdafx.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__FB2FF4E1_337E_11D1_9B37_00C04FB9514E__INCLUDED_)
#define AFX_STDAFX_H__FB2FF4E1_337E_11D1_9B37_00C04FB9514E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif 
//#define _ATL_APARTMENT_THREADED
#define _ATL_FREE_THREADED

#include <atlbase.h>
#include <commctrl.h>
#include <rend.h>
#include <control.h>
#include <limits.h>

EXTERN_C const CLSID CLSID_TAPI;

#include "Atomics.h"
#include "TransBmp.h"
#include "ErrorInfo.h"

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
#include "TapiModule.h"
extern CTapiModule _Module;

#include <atlcom.h>
#include <shellapi.h>
#include <atlwin.h>
#include <atlctl.h>

// OLE Automation true and false as required by DirectShow stuff
#ifndef OATRUE
#define OATRUE -1
#endif

#ifndef OAFALSE
#define OAFALSE 0
#endif

// Helper macros
//
#define STRING_FROM_IID(_IID_, _STR_)   StringFromIID( _IID_, &psz ); _STR_ = SysAllocString( psz ); CoTaskMemFree( psz );
#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)

#define RELEASE(_P_)        { if (_P_) { (_P_)->Release(); _P_ = NULL; } }
#define RELEASE_UNK(_P_)    { if (_P_) { ((IUnknown *) (_P_))->Release(); _P_ = NULL; } }
#define ARRAYSIZE(_AR_)     (sizeof(_AR_) / sizeof(_AR_[0]))
#define CLOSEHANDLE(_H_)    { if (_H_) { CloseHandle(_H_); _H_ = NULL; } }
#define SAFE_DELETE(_P_)    { if (_P_) { delete _P_; (_P_) = NULL; } }

#ifdef _DEBUG
#define REFSET(_P_)         DWORD dwRefSet##_P_ = ((IUnknown *) _P_)->AddRef() - 1;
#define REFCHECK(_P_)       DWORD dwRefCheck##_P_ = ((IUnknown *) _P_)->Release();      \
                            _ASSERT( dwRefSet##_P_ == dwRefCheck##_P_ );
#else
#define REFSET(_P_)
#define REFCHECK(_P_)
#endif


#ifdef _DEBUG
#define RELEASE_LIST(_LST_)     \
while ( !(_LST_).empty() )      \
{                               \
    ATLTRACE(_T("Releasing ") _T(#_LST_) _T(" %p @ %ld.\n"), (_LST_).front(), (_LST_).front()->Release());  \
    (_LST_).pop_front();        \
}
#else
#define RELEASE_LIST(_LST_)     \
while ( !(_LST_).empty() )      \
{                               \
    (_LST_).front()->Release(); \
    (_LST_).pop_front();        \
}
#endif

#define DELETE_LIST(_LST_)      \
while ( !(_LST_).empty() )      \
{                               \
    delete (_LST_).front();     \
    (_LST_).pop_front();        \
}

#define EMPTY_LIST(_LST_)       \
while ( !(_LST_).empty() )      \
    (_LST_).pop_front();        \


#define DELETE_CRITLIST(_LST_, _CRIT_)  \
(_CRIT_).Lock();                        \
DELETE_LIST(_LST_)                      \
(_CRIT_).Unlock();

#define EMPTY_CRITLIST(_LST_, _CRIT_)   \
(_CRIT_).Lock();                        \
EMPTY_LIST(_LST_)                       \
(_CRIT_).Unlock();

#define RELEASE_CRITLIST(_LST_, _CRIT_) \
(_CRIT_).Lock();                        \
RELEASE_LIST(_LST_)                     \
(_CRIT_).Unlock();

#define RELEASE_CRITLIST_TRACE(_LST_, _CRIT_)                                       \
(_CRIT_).Lock();                                                                    \
ATLTRACE(_T(".emptying ") _T(#_LST_) _T(" list size = %d.\n"), (_LST_).size() );    \
RELEASE_LIST(_LST_)                                                                 \
(_CRIT_).Unlock();

#define FIRE_VECTOR( _FNX_ )                                    \
    IConnectionPointImpl<VECT_CLS, &VECT_IID>* p = this;        \
    Lock();                                                     \
    HRESULT hr = E_FAIL;                                        \
    IUnknown **pp = p->m_vec.begin();                           \
    while ( pp < p->m_vec.end() )                               \
    {                                                           \
        if ( *pp )                                              \
            hr = ((VECT_IPTR *) *pp)->_FNX_;                    \
        pp++;                                                   \
    }                                                           \
    Unlock();                                                   \
    return hr;



// Helper functions
void GetToken( int nInd, LPCTSTR szDelim, LPTSTR szText, LPTSTR szToken );

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__FB2FF4E1_337E_11D1_9B37_00C04FB9514E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\tapimodule.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// TapiModule.CPP

#include "stdafx.h"
#include "TapiDialer.h"
#include "TapiModule.h"
#include "AVTapi.h"
#include "AVGenNtfy.h"
#include "ThreadRend.h"


CTapiModule::CTapiModule()
{
	m_pAVTapi = NULL;
	m_pAVGenNot = NULL;

	m_hWndParent = NULL;

	m_lInit = 0;
	m_lNumThreads = 0;

	m_hEventThread = NULL;
	m_hEventThreadWakeUp = NULL;
}

CTapiModule::~CTapiModule()
{
	EMPTY_LIST( m_lstThreadIDs );
}

void CTapiModule::Init( _ATL_OBJMAP_ENTRY* p, HINSTANCE h )
{
	// Initialize the common controls
	INITCOMMONCONTROLSEX ccs = { sizeof(INITCOMMONCONTROLSEX), ICC_WIN95_CLASSES };
	InitCommonControlsEx( &ccs );

	// Initialize my home grown atomic operators
	AtomicInit();

	CComModule::Init( p, h );
}

void CTapiModule::Term()
{
	RELEASE_UNK( m_pAVTapi );
	RELEASE_UNK( m_pAVGenNot );

	// Release atomic operations
	AtomicTerm();

	CComModule::Term();
}

bool CTapiModule::StartupThreads()
{
	if ( AtomicSeizeToken(m_lInit) )
	{
		ATLTRACE(_T(".enter.CTapiModule::StartupThreads().\n") );
		m_hEventThread = CreateEvent( NULL, FALSE, FALSE, NULL );
		m_hEventThreadWakeUp = CreateEvent( NULL, FALSE, FALSE, NULL);

		DWORD dwID;
		HANDLE hThread = CreateThread( NULL, 0, ThreadRendezvousProc, (void *) NULL, NULL, &dwID );
		if ( hThread ) CloseHandle( hThread );

		if ( m_hEventThread && m_hEventThreadWakeUp )
			return true;
	}

	// Clear out handles and exit
	CLOSEHANDLE( m_hEventThread );
	CLOSEHANDLE( m_hEventThreadWakeUp );
	return false;
}

void CTapiModule::ShutdownThreads()
{
	ATLTRACE(_T(".enter.CTapiModule::ShutdownThreads().\n"));
	if ( AtomicReleaseToken(m_lInit) )
	{
		BOOL bReset = ResetEvent( m_hEventThread );
		while ( m_lNumThreads )
		{
			ATLTRACE(_T(".1.CTapiModule::ShutdownThreads() -- thread count = %ld\n"), m_lNumThreads );
			SetEvent( m_hEventThreadWakeUp );

			if ( WaitForSingleObject(m_hEventThread, 5000) == WAIT_TIMEOUT )
			{
				ATLTRACE(_T(".error.CTapiModule::ShutdownThreads() -- timed out waiting for threads.\n") );
				KillThreads();
				break;
			}
		}

		Sleep(0);

		CLOSEHANDLE( m_hEventThread );
		CLOSEHANDLE( m_hEventThreadWakeUp );
		ATLTRACE(_T(".1.CTapiModule::ShutdownThreads() -- SUCCESSFUL shutdown.\n") );
	}
}

HRESULT	CTapiModule::get_AVGenNot( IAVGeneralNotification **pp )
{
	HRESULT hr = E_FAIL;
	Lock();
	if ( m_pAVGenNot )
		hr = (dynamic_cast<IUnknown *> (m_pAVGenNot))->QueryInterface(IID_IAVGeneralNotification, (void **) pp );
	Unlock();

	return hr;
}

void CTapiModule::SetAVGenNot( CAVGeneralNotification *p )
{
	Lock();
	RELEASE_UNK( m_pAVGenNot );

	if ( p )
	{
		m_pAVGenNot = p;
		(dynamic_cast<IUnknown *> (m_pAVGenNot))->AddRef();
	}
	Unlock();
}

void CTapiModule::SetAVTapi( CAVTapi *p )
{
	Lock();
	
	RELEASE_UNK( m_pAVTapi );

	if ( p )
	{
		m_pAVTapi = p;
		(dynamic_cast<IUnknown *> (m_pAVTapi))->AddRef();
	}
	Unlock();
}

HRESULT	CTapiModule::get_AVTapi( IAVTapi **pp )
{
	HRESULT hr = E_FAIL;
	Lock();
	if ( m_pAVTapi )
		hr = (dynamic_cast<IUnknown *> (m_pAVTapi))->QueryInterface(IID_IAVTapi, (void **) pp );
	Unlock();

	return hr;
}

HRESULT	CTapiModule::GetAVTapi( CAVTapi **pp )
{
	HRESULT hr = E_FAIL;

	Lock();
	if ( m_pAVTapi )
	{
		*pp = m_pAVTapi;
		(dynamic_cast<IUnknown *> (m_pAVTapi))->AddRef();
		hr = S_OK;
	}
	Unlock();

	return hr;
}


int CTapiModule::DoMessageBox( UINT nIDS, UINT nType, bool bUseActiveWnd )
{
	TCHAR szText[255];
	LoadString( GetResourceInstance(), nIDS, szText, ARRAYSIZE(szText) );

	return DoMessageBox( szText, nType, bUseActiveWnd );
}

int CTapiModule::DoMessageBox( const TCHAR *pszText, UINT nType, bool bUseActiveWnd )
{
	TCHAR szTitle[50];
	LoadString( GetResourceInstance(), IDS_PROJNAME, szTitle, ARRAYSIZE(szTitle) );

	return ::MessageBox( (bUseActiveWnd) ? GetActiveWindow() : GetParentWnd(), pszText, szTitle, nType );
}

DWORD CTapiModule::GuessAddressType( LPCTSTR pszText )
{
	DWORD dwRet = LINEADDRESSTYPE_DOMAINNAME;

	int nLen = _tcslen( pszText );
	if ( pszText && nLen )
	{
		if ( IsPhoneNumber(nLen, pszText) )			dwRet = LINEADDRESSTYPE_PHONENUMBER;
		else if ( IsMachineName(nLen, pszText) )	dwRet = LINEADDRESSTYPE_DOMAINNAME;
		else if ( IsIPAddress(nLen, pszText) )		dwRet = LINEADDRESSTYPE_IPADDRESS;
		else if ( IsEmailAddress(nLen, pszText) )	dwRet = LINEADDRESSTYPE_EMAILNAME;
	}

//	ATLTRACE(".1.CTapiModule::GuessAddressType() returning %lx.\n", dwRet);
	return dwRet;
}

bool CTapiModule::IsMachineName( int nLen, LPCTSTR pszText )
{
	// Double backslash is all it takes
	TCHAR szText[50];
	LoadString( _Module.GetResourceInstance(), IDS_STR_MACHINENAME_PARTS, szText, ARRAYSIZE(szText) );
	return (bool) ((nLen > 2) && !_tcsncmp(pszText, szText, 2));
}

bool CTapiModule::IsIPAddress( int nLen, LPCTSTR pszText )
{
	// All numbers and .'s
	TCHAR szText[50];
	LoadString( _Module.GetResourceInstance(), IDS_STR_TCPIP_PARTS, szText, ARRAYSIZE(szText) );
	return (bool) (_tcsspn(pszText, szText) == nLen);
}

bool CTapiModule::IsEmailAddress( int nLen, LPCTSTR pszText )
{
	TCHAR szText[50];
	LoadString( _Module.GetResourceInstance(), IDS_STR_EMAIL_PARTS, szText, ARRAYSIZE(szText) );
	return (bool) (_tcscspn(pszText, szText) < nLen);
}

bool CTapiModule::IsPhoneNumber( int nLen, LPCTSTR pszText )
{
	_ASSERT( pszText );
	TCHAR szText[50];
	LoadString( _Module.GetResourceInstance(), IDS_STR_PHONE_PARTS, szText, ARRAYSIZE(szText) );

	if ( (pszText[0] == _T('x')) || (pszText[0] == _T('X')) )
		return (bool) (_tcsspn((LPCTSTR) (pszText + 1), szText) == (nLen - 1) );

	return (bool) (_tcsspn(pszText, szText) == nLen);
}


void CTapiModule::AddThread( HANDLE hThread )
{
	m_critThreadIDs.Lock();
	m_lstThreadIDs.push_back( hThread );
	::InterlockedIncrement( &m_lNumThreads );
	m_critThreadIDs.Unlock();
}

void CTapiModule::RemoveThread( HANDLE hThread )
{
	m_critThreadIDs.Lock();
	THREADIDLIST::iterator i, iEnd = m_lstThreadIDs.end();
	for ( i = m_lstThreadIDs.begin(); i != iEnd; i++ )
	{
		if ( *i == hThread )
		{
			m_lstThreadIDs.erase( i );
			::InterlockedDecrement( &m_lNumThreads );
			CloseHandle( hThread );
			break;
		}
	}
	m_critThreadIDs.Unlock();
}

void CTapiModule::KillThreads()
{
	m_critThreadIDs.Lock();
	THREADIDLIST::iterator i, iEnd = m_lstThreadIDs.end();
	for ( i = m_lstThreadIDs.begin(); i != iEnd; i++ )
	{
		ATLTRACE( _T(".error.CTapiModule::KillThreads() -- killing thread %d!!!!!!!\n"), *i );
		TerminateThread( *i, -1 );
		CloseHandle( *i );
	}

	EMPTY_LIST( m_lstThreadIDs );
	m_critThreadIDs.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\tapimodule.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// TapiModule.h

#ifndef __TAPIMODULE_H__
#define __TAPIMODULE_H__

#include <list>
using namespace std;
typedef list<HANDLE> THREADIDLIST;

class CAVTapi;
struct IAVTapi;

class CAVGeneralNotification;
struct IAVGeneralNotification;

class CTapiModule : public CComModule
{
// Construction
public:
	CTapiModule();
	virtual ~CTapiModule();

// Members
public:
	HANDLE		m_hEventThread;
	HANDLE		m_hEventThreadWakeUp;
	long		m_lNumThreads;

protected:
	long					m_lInit;
	CAVTapi					*m_pAVTapi;
	CAVGeneralNotification	*m_pAVGenNot;
	HWND					m_hWndParent;

	CComAutoCriticalSection m_critThreadIDs;
	THREADIDLIST			m_lstThreadIDs;

// Attributes
public:
	HRESULT			get_AVTapi( IAVTapi **pp );
	HRESULT			GetAVTapi( CAVTapi **pp );
	void			SetAVTapi( CAVTapi *p );

	HRESULT			get_AVGenNot( IAVGeneralNotification **pp );
	void			SetAVGenNot( CAVGeneralNotification *p );

	HWND			GetParentWnd() const		{ if ( m_hWndParent ) return m_hWndParent; else return GetActiveWindow(); }
	void			SetParentWnd( HWND hWnd )	{ m_hWndParent = hWnd; }

	bool			IsMachineName( int nLen, LPCTSTR pszText );
	bool			IsIPAddress( int nLen, LPCTSTR pszText );
	bool			IsEmailAddress( int nLen, LPCTSTR pszText );
	bool			IsPhoneNumber( int nLen, LPCTSTR pszText );

// Operations
public:
	void			ShutdownThreads();
	bool			StartupThreads();
	void			AddThread( HANDLE hThread );
	void			RemoveThread( HANDLE hThread );
	void			KillThreads();

	int				DoMessageBox( UINT nIDS, UINT nType, bool bUseActiveWnd );
	int				DoMessageBox( const TCHAR *lpszText, UINT nType, bool bUseActiveWnd );

	DWORD			GuessAddressType( LPCTSTR pszText );

// Overrides
public:
	virtual void Init( _ATL_OBJMAP_ENTRY* p, HINSTANCE h );
	virtual void Term();
};

#endif // __TAPIMODULE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\threadds.h ===
//////////////////////////////////////////////////////////////////
// ThreadDS.h
//

#ifndef __THREADDS_H__
#define __THREADDS_H__

DWORD WINAPI ThreadDSProc( LPVOID lpInfo );

#endif //__THREADDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\threaddial.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
// ThreadDialing.h
//

#ifndef __THREADDIALING_H__
#define __THREADDIALING_H__

DWORD WINAPI ThreadDialingProc( LPVOID lpInfo );

class CThreadDialingInfo
{
// Construction
public:
	CThreadDialingInfo();
	virtual ~CThreadDialingInfo();

// Members
public:
	ITAddress			*m_pITAddress;

	BSTR				m_bstrName;						// Name of party being called
	BSTR				m_bstrAddress;					// Dialable address of party
	BSTR				m_bstrDisplayableAddress;		// Human readable address
	BSTR				m_bstrOriginalAddress;			// Original address used to dial with (address that's logged)
	BSTR				m_bstrUser1;					// Generic user info... used for Assisted Telephony
	BSTR				m_bstrUser2;					// Generic user info... used for Assisted Telephony
	DWORD				m_dwAddressType;				// Service provider to use (Phone, IP, MC Conf)
	bool				m_bResolved;					// Was the name resolved via the WAB?

	AVCallType			m_nCallType;					// Is the call a data-only call
	long				m_lCallID;
	HGLOBAL				m_hMem;

// Attributes
public:
	HRESULT				set_ITAddress( ITAddress *pITAddress );
	HRESULT				TranslateAddress();
	HRESULT				PutAllInfo( IAVTapiCall *pAVCall );
	void				FixupAddress();
};

#endif // __THREADDIALING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\threadans.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////
// ThreadAnswer.h
//

#ifndef __THREADANSWER_H__
#define __THREADANSWER_H__

DWORD WINAPI ThreadAnswerProc( LPVOID lpInfo );

class CThreadAnswerInfo
{
// Construction
public:
	CThreadAnswerInfo();
	virtual ~CThreadAnswerInfo();

// Members
public:
	IAVTapiCall				*m_pAVCall;
	ITCallInfo				*m_pITCall;
	ITBasicCallControl		*m_pITControl;
    BOOL                    m_bUSBAnswer;
protected:
	LPSTREAM				m_pStreamCall;
	LPSTREAM				m_pStreamControl;

// Attributes
public:
	HRESULT set_AVTapiCall( IAVTapiCall *pAVCall );
	HRESULT set_ITCallInfo( ITCallInfo *pInfo );
	HRESULT set_ITBasicCallControl( ITBasicCallControl *pControl );
};

#endif //__THREADANSWER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\threadds.cpp ===
/////////////////////////////////////////////////////
// ThreadDS.cpp
//

#include "stdafx.h"
#include "TapiDialer.h"
#include "resource.h"
#include "ThreadDS.h"

#ifndef RENDBIND_AUTHENTICATE
#define RENDBIND_AUTHENTICATE	TRUE
#endif

#define MAX_ENUMLISTSIZE	500

// Predeclares...
HRESULT GetDirectory( ITRendezvous *pRend, ITDirectory **ppDir );
HRESULT GetUsers( ITRendezvous *pRend );


DWORD WINAPI ThreadDSProc( LPVOID lpInfo )
{
   //Until rend.dll can support retreiving all users a little better we will just do nothing
   //with the DS right now.  We probably will never want to show all users anyways.  The 
   //bandwidth is not available and the UI cannot handle it.  We should only show users
   //that are of particular importance to us.  We need to build up buddy lists of people
   //that we are interested in.  
   return 0;

	USES_CONVERSION;
	HANDLE hThread = NULL;
	BOOL bDup = DuplicateHandle( GetCurrentProcess(),
								 GetCurrentThread(),
								 GetCurrentProcess(),
								 &hThread,
								 THREAD_ALL_ACCESS,
								 TRUE,
								 0 );


	_ASSERT( bDup );
	_Module.AddThread( hThread );

	// Error info information
	CErrorInfo er;
	er.set_Operation( IDS_ER_ENUMERATEDS );
	er.set_Details( IDS_ER_COINITIALIZE );
	HRESULT hr = er.set_hr( CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY) );
	if ( SUCCEEDED(hr) )
	{
		ATLTRACE(_T(".1.ThreadDSProc() -- thread up and running.\n") );

		ITRendezvous *pRend;

		hr = CoCreateInstance( CLSID_Rendezvous,
							   NULL,
							   CLSCTX_INPROC_SERVER,
							   IID_ITRendezvous,
							   (void **) &pRend );
		if ( SUCCEEDED(hr) )
		{
			hr = GetUsers( pRend ); 
			pRend->Release();
		}

		// Clean-up
		CoUninitialize();
	}

	// Notify module of shutdown
	InterlockedDecrement( (long *) lpInfo );
	_Module.RemoveThread( hThread );
	SetEvent( _Module.m_hEventThread );
	ATLTRACE(_T(".exit.ThreadDSProc(0x%08lx).\n"), hr );
	return hr;
}

HRESULT GetDirectory( ITRendezvous *pRend, ITDirectory **ppDir )
{
	HRESULT hr;
	*ppDir = NULL;

	// Use default ILS server?
	IEnumDirectory *pEnum;
	if ( SUCCEEDED(hr = pRend->EnumerateDefaultDirectories(&pEnum)) )
	{
		// Default is we don't find a server
		hr = E_FAIL;
		ITDirectory *pDir;

		while ( pEnum->Next(1, &pDir, NULL) == S_OK )
		{
			// Look for an ILS server
			DIRECTORY_TYPE nType;
			pDir->get_DirectoryType( &nType );
			if ( nType == DT_NTDS )
			{
				// Try to connect and bind
				*ppDir = pDir;
				hr = S_OK;
				break;
			}

			// Clear out variables for next round
			pDir->Release();
		}
		
		pEnum->Release();
	}

	// If we have a valid Directory object, connect and bind to it
	if ( *ppDir )
	{
		if ( SUCCEEDED(hr = (*ppDir)->Connect(FALSE)) )
		{
			// Bind to the server
			hr = (*ppDir)->Bind( NULL, NULL, NULL, RENDBIND_AUTHENTICATE );
		}
		else
		{
			(*ppDir)->Release();
			*ppDir = NULL;
		}
	}

	return hr;
}

HRESULT GetUsers( ITRendezvous *pRend )
{
	USES_CONVERSION;
	HRESULT hr;
	CComPtr<IAVGeneralNotification> pAVGen;

	if ( SUCCEEDED(hr = _Module.get_AVGenNot(&pAVGen)) )
	{
		// Clear out the existing user list
		pAVGen->fire_ClearUserList();

		ITDirectory *pDir;

		if ( SUCCEEDED(hr = GetDirectory(pRend, &pDir)) )
		{
			// Enumerate through conferences adding them as we go along
			IEnumDirectoryObject *pEnumUser;
			if ( SUCCEEDED(hr = pDir->EnumerateDirectoryObjects(OT_USER, A2BSTR("*"), &pEnumUser)) )
			{
				long nCount = 0;
				ITDirectoryObject *pITDirObject;
				while ( (nCount++ < MAX_ENUMLISTSIZE) && ((hr = pEnumUser->Next(1, &pITDirObject, NULL)) == S_OK) )
				{
					_ASSERT( pITDirObject );
					BSTR bstrName = NULL;
					BSTR bstrPhoneNumber = NULL;

					// Get Name of user
					pITDirObject->get_Name( &bstrName );

					// Get Phone Number for contact
					IEnumDialableAddrs *pEnum = NULL;
					if ( SUCCEEDED(pITDirObject->EnumerateDialableAddrs(LINEADDRESSTYPE_PHONENUMBER, &pEnum)) && pEnum )
					{
						pEnum->Next( 1, &bstrPhoneNumber, NULL );
						pEnum->Release();
					}

					ITDirectoryObjectUser *pUser;
					if ( SUCCEEDED(pITDirObject->QueryInterface(IID_ITDirectoryObjectUser, (void **) &pUser)) )
					{
						BSTR bstrAddress = NULL;

						// Get primary IP Phone Number
						pUser->get_IPPhonePrimary( &bstrAddress );

						// Add user to the list...
						ATLTRACE(_T(".1.GetUsers() -- adding user %s, %s %s.\n"), OLE2CT(bstrName), OLE2CT(bstrAddress), OLE2CT(bstrPhoneNumber) );
						pAVGen->fire_AddUser( bstrName, bstrAddress, bstrPhoneNumber );

						pUser->Release();
						SysFreeString( bstrAddress );
					}

					pITDirObject->Release();
					SysFreeString( bstrName );
					SysFreeString( bstrPhoneNumber );
				}
				pEnumUser->Release();
			}
			pDir->Release();
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\threadans.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
// ThreadAnswer.cpp
//

#include "stdafx.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "AVTapiCall.h"
#include "ThreadAns.h"

CThreadAnswerInfo::CThreadAnswerInfo()
{
	m_pITCall = NULL;
	m_pITControl = NULL;
	m_pAVCall = NULL;

	m_pStreamCall = NULL;
	m_pStreamControl = NULL;

    m_bUSBAnswer = FALSE;
}

CThreadAnswerInfo::~CThreadAnswerInfo()
{
	RELEASE( m_pAVCall );
	RELEASE( m_pITCall );
	RELEASE( m_pITControl );
}

HRESULT CThreadAnswerInfo::set_AVTapiCall( IAVTapiCall *pAVCall )
{
	RELEASE( m_pAVCall );
	if ( pAVCall )
		return pAVCall->QueryInterface( IID_IAVTapiCall, (void **) &m_pAVCall );

	return E_POINTER;
}

HRESULT CThreadAnswerInfo::set_ITCallInfo( ITCallInfo *pInfo )
{
	RELEASE( m_pITCall );
	if ( pInfo )
		return pInfo->QueryInterface( IID_ITCallInfo, (void **) &m_pITCall );

	return E_POINTER;
}

HRESULT CThreadAnswerInfo::set_ITBasicCallControl( ITBasicCallControl *pControl )
{
	RELEASE( m_pITControl );
	if ( pControl )
		return pControl->QueryInterface( IID_ITBasicCallControl, (void **) &m_pITControl );

	return E_POINTER;
}

/////////////////////////////////////////////////////////////////////////////////
// ThreadAnswerProc
//
DWORD WINAPI ThreadAnswerProc( LPVOID lpInfo )
{
#undef FETCH_STRING
#define FETCH_STRING( _CMS_, _IDS_ )		\
	LoadString( _Module.GetResourceInstance(), _IDS_, szText, ARRAYSIZE(szText) );	\
	SysReAllocString( &bstrText, T2COLE(szText) );									\
	pAVTapi->fire_SetCallState_CMS( lCallID, _CMS_, bstrText );

	ATLTRACE(_T(".enter.ThreadAnswerProc().\n") );

	HANDLE hThread = NULL;
	BOOL bDup = DuplicateHandle( GetCurrentProcess(),
								 GetCurrentThread(),
								 GetCurrentProcess(),
								 &hThread,
								 THREAD_ALL_ACCESS,
								 TRUE,
								 0 );


	_ASSERT( bDup );
	_Module.AddThread( hThread );

	_ASSERT( lpInfo );
	CThreadAnswerInfo *pAnswerInfo = (CThreadAnswerInfo *) lpInfo;

	// Error info information
	CErrorInfo er;
	er.set_Operation( IDS_ER_ANSWER_CALL );
	er.set_Details( IDS_ER_COINITIALIZE );
	HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY );
	if ( SUCCEEDED(hr) )
	{
		ATLTRACE(_T(".1.ThreadAnswerProc() -- thread up and running.\n") );

		// Setting up media terminals
		CAVTapi *pAVTapi;
		if ( SUCCEEDED(hr = _Module.GetAVTapi(&pAVTapi)) )
		{
			AVCallType nCallType;
			long lCallID;
			pAnswerInfo->m_pAVCall->get_nCallType( &nCallType );
			pAnswerInfo->m_pAVCall->get_lCallID( &lCallID );
			pAnswerInfo->m_pAVCall->put_dwThreadID( GetCurrentThreadId() );

            // Get the mark, if the answer was a 'Take Call' answer (FALSE) or
            // a USB phone answer (TRUE)
            BOOL bUSBAnswer = pAnswerInfo->m_bUSBAnswer;

			USES_CONVERSION;
			TCHAR szText[255];
			BSTR bstrText = NULL;

			pAVTapi->fire_ClearCurrentActions( lCallID );
			pAVTapi->fire_AddCurrentAction( lCallID, CM_ACTIONS_DISCONNECT, NULL );
			FETCH_STRING( CM_STATES_RINGING, IDS_PLACECALL_FETCH_ADDRESS );
		
			// Setup media types and answer
			ITAddress *pITAddress = NULL;
			if ( SUCCEEDED(hr = pAnswerInfo->m_pITCall->get_Address(&pITAddress)) && pITAddress )
			{
				// Select a set of media terminals to use on the call
				if ( nCallType != AV_DATA_CALL )
				{
					er.set_Details( IDS_ER_CREATETERMINALS );
					hr = er.set_hr( pAVTapi->CreateTerminalArray(pITAddress, pAnswerInfo->m_pAVCall, pAnswerInfo->m_pITCall) );
				}

				// Set state to "attempting to answer"
				if ( SUCCEEDED(hr) && SUCCEEDED(hr = pAnswerInfo->m_pAVCall->CheckKillMe()) )
				{
					FETCH_STRING( CM_STATES_CONNECTING, IDS_PLACECALL_OFFERING_ANSWER );

					// Answer the call
					if ( SUCCEEDED(hr) && SUCCEEDED(hr = pAnswerInfo->m_pAVCall->CheckKillMe()) )
					{
						if ( nCallType != AV_DATA_CALL )
						{
							pAVTapi->ShowMedia( lCallID, NULL, false );		// initially hide video
							pAVTapi->ShowMediaPreview( lCallID, NULL, false );
						}

                        // If the anwser was a 'Take Call' answer then we have to answer to
                        // the call. If the answer was a USB answer, we don't answer to the call
                        // because the USB phone already did for us.

                        if( !bUSBAnswer )
                        {
						    er.set_Details( IDS_ER_TAPI_ANSWER_CALL );
						    hr = er.set_hr(pAnswerInfo->m_pITControl->Answer());
                        }
					}
				}

				pITAddress->Release();
			}

			// Failed to answer the call, update the call control window
			if ( FAILED(hr) )
			{
				pAVTapi->fire_ClearCurrentActions( lCallID );
				pAVTapi->fire_AddCurrentAction( lCallID, CM_ACTIONS_CLOSE, NULL );
				pAVTapi->fire_SetCallState_CMS( lCallID, CM_STATES_DISCONNECTED, NULL );
			}

			// Clean up
			SAFE_DELETE( pAnswerInfo );
			SysFreeString( bstrText );

			if ( SUCCEEDED(hr) )
				CAVTapiCall::WaitWithMessageLoop();

			(dynamic_cast<IUnknown *> (pAVTapi))->Release();
		}
		
		// Uninitialize com
		CoUninitialize();
	}

	// Clean-up
	SAFE_DELETE( pAnswerInfo );

	// Notify module of shutdown
	_Module.RemoveThread( hThread );
	SetEvent( _Module.m_hEventThread );
	ATLTRACE(_T(".exit.ThreadAnswerProc(0x%08lx).\n"), hr );
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\threaddial.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
// ThreadDialing.cpp
//

#include "stdafx.h"
#include "TapiDialer.h"
#include "ThreadDial.h"
#include "AVTapi.h"
#include "AVTapiCall.h"
#include "ConfExp.h"
#include "ThreadPub.h"

CThreadDialingInfo::CThreadDialingInfo()
{
    m_pITAddress = NULL;

    m_bstrName = NULL;
    m_bstrAddress = NULL;
    m_bstrOriginalAddress = NULL;
    m_bstrDisplayableAddress = NULL;
    m_bstrUser1 = NULL;
    m_bstrUser2 = NULL;
    m_dwAddressType = 0;

    m_bResolved = false;
    m_nCallType = AV_VOICE_CALL;
    m_lCallID = 0;

    m_hMem = NULL;
}

CThreadDialingInfo::~CThreadDialingInfo()
{
    SysFreeString( m_bstrName );
    SysFreeString( m_bstrAddress );
    SysFreeString( m_bstrOriginalAddress );
    SysFreeString( m_bstrDisplayableAddress );
    SysFreeString( m_bstrUser1 );
    SysFreeString( m_bstrUser2 );

    if ( m_hMem ) GlobalFree( m_hMem );

    RELEASE( m_pITAddress );
}

HRESULT CThreadDialingInfo::set_ITAddress( ITAddress *pITAddress )
{
    RELEASE( m_pITAddress );
    if ( pITAddress )
        return pITAddress->QueryInterface( IID_ITAddress, (void **) &m_pITAddress );

    return E_POINTER;
}

HRESULT    CThreadDialingInfo::TranslateAddress()
{
    // Only valid for dialing POTS, with a valid string that doesn't start with "x"
    if ( !m_pITAddress ||
         (m_dwAddressType != LINEADDRESSTYPE_PHONENUMBER) ||
         !m_bstrAddress ||
         (SysStringLen(m_bstrAddress) == 0) )
    {
        return S_OK;
    }

    
    ITAddressTranslation *pXlat;
    CErrorInfo er( IDS_ER_TRANSLATE_ADDRESS, IDS_ER_CREATE_TAPI_OBJECT );

    if ( SUCCEEDED(er.set_hr(m_pITAddress->QueryInterface(IID_ITAddressTranslation, (void **) &pXlat))) )
    {
        er.set_Details( IDS_ER_TRANSLATING_ADDRESS );
        ITAddressTranslationInfo *pXlatInfo = NULL;

        // Translate the address
        int nTryCount = 0;
        while ( SUCCEEDED(er.m_hr) && (nTryCount < 2) )
        {
            if ( SUCCEEDED(er.set_hr( pXlat->TranslateAddress( m_bstrAddress, 0, 0, &pXlatInfo) )) && pXlatInfo )
            {
                BSTR bstrTemp = NULL;

                pXlatInfo->get_DialableString( &bstrTemp );
                if ( bstrTemp && SysStringLen(bstrTemp) )
                {
#ifdef _DEBUG
                    USES_CONVERSION;
                    ATLTRACE(_T(".1.CThreadDialingProc::TranslateAddress() -- from %s to %s.\n"), OLE2CT(m_bstrAddress), OLE2CT(bstrTemp) );
#endif
                    SysReAllocString( &m_bstrAddress, bstrTemp );
                }
                SysFreeString( bstrTemp );
                bstrTemp = NULL;

                // Displayable address as well
                pXlatInfo->get_DisplayableString( &bstrTemp );
                if ( bstrTemp && SysStringLen(bstrTemp) )
                    SysReAllocString( &m_bstrDisplayableAddress, bstrTemp );
                SysFreeString( bstrTemp );

                // Clean up
                RELEASE( pXlatInfo );
                break;
            }
            else if ( er.m_hr == TAPI_E_REGISTRY_SETTING_CORRUPT )
            {
                HWND hWndParent = NULL;
                CComPtr<IAVTapi> pAVTapi;
                if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
                    pAVTapi->get_hWndParent( &hWndParent );
                
                // Show translate address dialog
                pXlat->TranslateDialog( (TAPIHWND)hWndParent, m_bstrAddress );
                er.set_hr( S_OK );
            }
            nTryCount++;
        }

        pXlat->Release();
    }

    return er.m_hr;
}

HRESULT    CThreadDialingInfo::PutAllInfo( IAVTapiCall *pAVCall )
{
    _ASSERT( pAVCall );

    pAVCall->put_dwAddressType( m_dwAddressType );
    pAVCall->put_bstrOriginalAddress( m_bstrOriginalAddress );
    pAVCall->put_bstrDisplayableAddress( m_bstrDisplayableAddress );
    pAVCall->put_bstrName( m_bstrName );
    pAVCall->put_dwThreadID( GetCurrentThreadId() );
    pAVCall->put_bstrUser( 0, m_bstrUser1 );
    pAVCall->put_bstrUser( 1, m_bstrUser2 );
    pAVCall->put_bResolved( m_bResolved );

    return S_OK;
}

void CThreadDialingInfo::FixupAddress()
{
    if ( m_dwAddressType == LINEADDRESSTYPE_DOMAINNAME )
    {
        if ( (SysStringLen(m_bstrAddress) > 2) && !wcsncmp(m_bstrAddress, L"\\\\", 2) )
        {
            BSTR bstrTemp = SysAllocString( &m_bstrAddress[2] );

            //
            // We have to verify the string allocation
            //

            if( IsBadStringPtr( bstrTemp, (UINT)-1) )
            {
                return;
            }

            SysReAllocString( &m_bstrAddress, bstrTemp );
            SysFreeString( bstrTemp );
        }
    }
}


/////////////////////////////////////////////////////////////////////////////////
// ThreadDialingProc
//
DWORD WINAPI ThreadDialingProc( LPVOID lpInfo )
{
#define FETCH_STRING( _CMS_, _IDS_ )        \
    if ( bSliders )    {                        \
        if ( LoadString(_Module.GetResourceInstance(), _IDS_, szText, ARRAYSIZE(szText)) > 0 )    { \
            if ( SUCCEEDED(SysReAllocString(&bstrText, T2COLE(szText))) )        \
                pAVTapi->fire_SetCallState_CMS( lCallID, _CMS_, bstrText );        \
        }                                                                        \
    }

    ATLTRACE(_T(".enter.ThreadDialingProc().\n") );

    HANDLE hThread = NULL;
    BOOL bDup = DuplicateHandle( GetCurrentProcess(),
                                 GetCurrentThread(),
                                 GetCurrentProcess(),
                                 &hThread,
                                 THREAD_ALL_ACCESS,
                                 TRUE,
                                 0 );


    _ASSERT( bDup );
    _Module.AddThread( hThread );

    // Data passed into thread
    USES_CONVERSION;
    _ASSERT( lpInfo );
    CThreadDialingInfo *pInfo = (CThreadDialingInfo *) lpInfo;
    long lCallID;

    // Error info information
    CErrorInfo er;
    er.set_Operation( IDS_ER_PLACECALL );
    er.set_Details( IDS_ER_COINITIALIZE );
    HRESULT hr = er.set_hr( CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY) );
    if ( SUCCEEDED(hr) )
    {
        ATLTRACE(_T(".1.ThreadDialingProc() -- thread up and running.\n") );

        
        CAVTapi *pAVTapi = NULL;
        IConfRoom *pConfRoom = NULL;
        IAVTapiCall *pAVCall = NULL;
        bool bSliders = (bool) (pInfo->m_dwAddressType != LINEADDRESSTYPE_SDP);

        if ( SUCCEEDED(hr = er.set_hr(_Module.GetAVTapi(&pAVTapi))) &&
             SUCCEEDED(hr = er.set_hr(pAVTapi->get_ConfRoom(&pConfRoom))) )
        {
            TCHAR szText[255];
            BSTR bstrText = NULL;
            er.set_Details( IDS_ER_FIRE_NEW_CALL );

            if ( bSliders )
            {
                if ( SUCCEEDED(hr = er.set_hr(pAVTapi->fire_NewCall(pInfo->m_pITAddress, pInfo->m_dwAddressType, pInfo->m_lCallID, NULL, pInfo->m_nCallType, &pAVCall))) )
                {
                    // Retrieve call ID for convienence and set up called address info
                    pAVCall->get_lCallID( &lCallID );
                    pInfo->PutAllInfo( pAVCall );

                    // Set the caller ID for the call
                    pAVCall->ResolveAddress();
                    pAVCall->ForceCallerIDUpdate();

                    // Setting up media terminals
                    pAVTapi->fire_ClearCurrentActions( lCallID );
                    pAVTapi->fire_AddCurrentAction( lCallID, CM_ACTIONS_DISCONNECT, NULL );
                    FETCH_STRING( CM_STATES_DIALING, IDS_PLACECALL_FETCH_ADDRESS );
                }
            }
            else
            {
                // Joining a conference...
                hr = er.set_hr(pAVTapi->CreateNewCall(pInfo->m_pITAddress, &pAVCall) );
                if ( SUCCEEDED(hr) )
                {
                    pInfo->PutAllInfo( pAVCall );
                    pAVTapi->fire_ActionSelected( CC_ACTIONS_SHOWCONFROOM );
                    hr = pConfRoom->EnterConfRoom( pAVCall );
                }
            }

            if ( SUCCEEDED(hr) )
            {
                // Did we make the address okay (in the case of a conference )
                if ( SUCCEEDED(hr) && SUCCEEDED(hr = pAVCall->CheckKillMe()) )
                {            
                    // Create the call and then dial
                    ITBasicCallControl *pITControl = NULL;
                    er.set_Details( IDS_ER_CREATE_CALL );
                    pInfo->FixupAddress();
                    
                    // What kind of media types does the address support?
                    long lSupportedMediaModes = 0;
                    ITMediaSupport *pITMediaSupport;
                    if ( SUCCEEDED(pInfo->m_pITAddress->QueryInterface(IID_ITMediaSupport, (void **) &pITMediaSupport)) )
                    {
                        pITMediaSupport->get_MediaTypes( &lSupportedMediaModes );
                        pITMediaSupport->Release();
                    }
                    lSupportedMediaModes &= (TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO);

                    ////////////////////////
                    // Create the call object
                    //
                    if ( SUCCEEDED(hr = er.set_hr(pInfo->m_pITAddress->
                         CreateCall( pInfo->m_bstrAddress,
                                     pInfo->m_dwAddressType,
                                     lSupportedMediaModes,
                                     &pITControl))) )
                    {
                        // Set more call parameters
                        pAVCall->put_ITBasicCallControl( pITControl );

                        ///////////////////////////////////
                        // Set caller/calling ID
                        // Set the terminals up for the call
                        //
                        ITCallInfo *pCallInfo;
                        if ( SUCCEEDED(pITControl->QueryInterface(IID_ITCallInfo, (void **) &pCallInfo)) )
                        {
                            // Set user user info if requested
                            if ( pInfo->m_hMem )
                            {
                                void *pbUU = GlobalLock( pInfo->m_hMem );
                                if ( pbUU )
                                {
                                    pCallInfo->SetCallInfoBuffer( CIB_USERUSERINFO, GlobalSize(pInfo->m_hMem), (BYTE *) pbUU );
                                    GlobalUnlock( pInfo->m_hMem );
                                }
                            }


                            // Identify who it is that's calling!
                            CComBSTR bstrName;
                            MyGetUserName( &bstrName );

                            if ( bstrName )
                            {
                                // Add the computer name to the end
                                BSTR bstrIP = NULL, bstrComputer = NULL;
                                GetIPAddress( &bstrIP, &bstrComputer );
                                if ( bstrComputer && SysStringLen(bstrComputer) )
                                {
                                    bstrName.Append( _T("\n") );
                                    bstrName.Append( bstrComputer );
                                }
                                SysFreeString( bstrIP );
                                SysFreeString( bstrComputer );

                                pCallInfo->put_CallInfoString( CIS_CALLINGPARTYID, bstrName );
                            }

                            // Identify who it is that we think we're calling
                            if ( pInfo->m_bstrName && (SysStringLen(pInfo->m_bstrName) > 0) )
                                pCallInfo->put_CallInfoString( CIS_CALLEDPARTYFRIENDLYNAME, pInfo->m_bstrName );
                            else
                                pCallInfo->put_CallInfoString( CIS_CALLEDPARTYFRIENDLYNAME, pInfo->m_bstrAddress );

                            ///////////////////////////////////
                            // Setting up media terminals
                            //
                            pAVTapi->fire_ClearCurrentActions( lCallID );
                            pAVTapi->fire_AddCurrentAction( lCallID, CM_ACTIONS_DISCONNECT, NULL );
                            FETCH_STRING( CM_STATES_DIALING, IDS_PLACECALL_FETCH_ADDRESS );

                            // Don't create terminals for data calls
                            if ( pInfo->m_nCallType != AV_DATA_CALL )
                            {
                                er.set_Details( IDS_ER_CREATETERMINALS );
                                hr = er.set_hr( pAVTapi->CreateTerminalArray(pInfo->m_pITAddress, pAVCall, pCallInfo) );
                            }

                            pCallInfo->Release();
                        }

                        ////////////////////////////////
                        // Do the dialing
                        //
                        if ( SUCCEEDED(hr) && SUCCEEDED(hr = pAVCall->CheckKillMe()) )
                        {
                            FETCH_STRING( CM_STATES_DIALING, IDS_PLACECALL_DIALING );

                            // Register the callback object and connect call
                            if ( SUCCEEDED(hr) && SUCCEEDED(hr = pAVCall->CheckKillMe()) )
                            {
                                er.set_Details( IDS_ER_CONNECT_CALL );
                                if ( bSliders  && (pInfo->m_nCallType != AV_DATA_CALL) )
                                {
                                    pAVTapi->ShowMedia( lCallID, NULL, FALSE );
                                    pAVTapi->ShowMediaPreview( lCallID, NULL, FALSE );
                                }
                                
                                hr = er.set_hr( pITControl->Connect(false) );
                            }
                            else if ( bSliders )
                            {
                                pConfRoom->Cancel();
                            }
                        }
                        else if ( bSliders )
                        {
                            pConfRoom->Cancel();
                        }

                        SAFE_DELETE( pInfo )
                        RELEASE( pAVCall );
                        pITControl->Release();

                        // Spin
                        if ( SUCCEEDED(hr) )
                            CAVTapiCall::WaitWithMessageLoop();
                    }
                }

                // Failed to make the call, update the call control window
                if ( FAILED(hr) )
                {
                    if ( bSliders )
                    {
                        pAVTapi->fire_ClearCurrentActions( lCallID );
                        pAVTapi->fire_AddCurrentAction( lCallID, CM_ACTIONS_CLOSE, NULL );
                    }
                    else
                    {
                        pConfRoom->Cancel();
                    }

                    // what was the problem?
                    switch ( hr )
                    {
                        case LINEERR_OPERATIONUNAVAIL:
                            FETCH_STRING( CM_STATES_UNAVAILABLE, IDS_PLACECALL_DISCONNECT_UNAVAIL );
                            hr = er.set_hr( S_OK );
                            break;

                        case LINEERR_INVALADDRESS:
                            FETCH_STRING( CM_STATES_UNAVAILABLE, IDS_PLACECALL_DISCONNECT_BADADDRESS);
                            hr = er.set_hr( S_OK );
                            break;

                        default:
                            if ( bSliders )
                                pAVTapi->fire_SetCallState_CMS( lCallID, CM_STATES_DISCONNECTED, NULL );
                            break;
                    }
                }
            }

            // Release the string
            SysFreeString( bstrText );
        }

        // Clean-up
        RELEASE( pConfRoom );
        if ( pAVTapi )
            (dynamic_cast<IUnknown *> (pAVTapi))->Release();

        CoUninitialize();
    }

    SAFE_DELETE( pInfo );

    // Notify module of shutdown
    _Module.RemoveThread( hThread );
    SetEvent( _Module.m_hEventThread );
    ATLTRACE(_T(".exit.ThreadDialingProc(0x%08lx).\n"), hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\threadpub.h ===
///////////////////////////////////////////////////////////////////
// ThreadPub.h
//

#ifndef __THREADPUB_H__
#define __THREADPUB_H__

#include <list>
using namespace std;
typedef list<BSTR> BSTRLIST;

#define DEFAULT_USER_TTL	3600

// Information used when publishing the user on the ILS
class CPublishUserInfo
{
// Construction
public:
	CPublishUserInfo();
	virtual ~CPublishUserInfo();

// Members:
public:
	BSTRLIST	m_lstServers;
	bool		m_bCreateUser;

// Operators
public:
	CPublishUserInfo&	operator=( const CPublishUserInfo &src );
	void EmptyList();
};

DWORD WINAPI	ThreadPublishUserProc( LPVOID lpInfo );
void			LoadDefaultServers( CPublishUserInfo *pInfo );

bool			MyGetUserName( BSTR *pbstrName );
void			GetIPAddress( BSTR *pbstrText, BSTR *pbstrComputerName );


#endif //__THREADPUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\threadpub.cpp ===
/////////////////////////////////////////////////////////////////////
// ThreadPub.cpp
//

#include "stdafx.h"
#include <winsock.h>
#include "TapiDialer.h"
#include "AVTapi.h"
#include "ThreadPub.h"
#include "CETreeView.h"

#define MAX_USER_NAME_SIZE    1000

HRESULT  GetDirectoryObject(ITDirectory* pITDir,BSTR bstrName,ITDirectoryObject **ppDirObj );
void     GetDirObjectChangedStatus(ITDirectoryObject* pOldUser, ITDirectoryObject* pNewUser, bool& bChanged, bool& bSameIPAddress );

///////////////////////////////////////////////////////////////
// class CPublishUserInfo
//
CPublishUserInfo::CPublishUserInfo()
{
    m_bCreateUser = true;
}

CPublishUserInfo::~CPublishUserInfo()
{
    // Empty list
    EmptyList();
}

void CPublishUserInfo::EmptyList()
{
    while ( !m_lstServers.empty() )
    {
        if ( m_lstServers.front() ) SysFreeString( m_lstServers.front() );
        m_lstServers.pop_front();
    }
}

CPublishUserInfo& CPublishUserInfo::operator=( const CPublishUserInfo &src )
{
    // First clear out old list
    EmptyList();

    // Copy over everything
    m_bCreateUser = src.m_bCreateUser;
    BSTRLIST::iterator i, iEnd = src.m_lstServers.end();
    for ( i = src.m_lstServers.begin(); i != iEnd; i++ )
    {
        BSTR bstrNew = SysAllocString( *i );
        if ( bstrNew )    m_lstServers.push_back( bstrNew );
    }

    return *this;
}

void GetIPAddress( BSTR *pbstrText, BSTR *pbstrComputerName )
{
    USES_CONVERSION;
    _ASSERT( pbstrText );
    *pbstrText = NULL;

    WSADATA WsaData;
    if ( WSAStartup(MAKEWORD(2, 0), &WsaData) == NOERROR )
    {
        char szName[_MAX_PATH + 1];
        if ( gethostname(szName, _MAX_PATH) == 0 )
        {
            HOSTENT *phEnt = gethostbyname( szName );
            if ( phEnt )
            {
                // Store computer name
                if ( phEnt->h_name )
                    SysReAllocString( pbstrComputerName, A2COLE(phEnt->h_name) );
    
                // Convert the IPAddress
                char *pszInet = inet_ntoa( *((in_addr *) phEnt->h_addr_list[0]) );
                SysReAllocString( pbstrText, A2COLE(pszInet) );
            }
        }
        WSACleanup();
    }
}


HRESULT CreateUserObject( ITRendezvous *pRend, ITDirectoryObject **ppUser, BSTR *pbstrIPAddress )
{
    USES_CONVERSION;
    HRESULT hr = E_UNEXPECTED;

    BSTR bstrName = NULL;
    if ( MyGetUserName(&bstrName) )
    {
        BSTR bstrComputerName = NULL;
        GetIPAddress( pbstrIPAddress, &bstrComputerName );

        // Create the user object
        if ( SUCCEEDED(hr = pRend->CreateDirectoryObject(OT_USER, bstrName, ppUser)) )
        {
            ITDirectoryObjectUser *pTempUser;
            if ( SUCCEEDED(hr = (*ppUser)->QueryInterface(IID_ITDirectoryObjectUser, (void **) &pTempUser)) )
            {
                // Set the IP address here 
                if ( *pbstrIPAddress )
                    pTempUser->put_IPPhonePrimary( *pbstrIPAddress );

                pTempUser->Release();
            }
        }
        // Clean up
        SysFreeString( bstrComputerName );
    }

    SysFreeString( bstrName );
    return hr;
}

HRESULT OpenServer( ITRendezvous *pRend, BSTR bstrServer, ITDirectory **ppDir )
{
    _ASSERT( pRend && bstrServer && ppDir );
    *ppDir = NULL;
    HRESULT hr = pRend->CreateDirectory(DT_ILS, bstrServer, ppDir );
    if ( SUCCEEDED(hr) )
    {
        if ( SUCCEEDED(hr = (*ppDir)->Connect(FALSE)) )
        {
//            (*ppDir)->put_DefaultObjectTTL( DEFAULT_USER_TTL );
            (*ppDir)->Bind(NULL, NULL, NULL, 1);
            (*ppDir)->EnableAutoRefresh( TRUE );
        }

        // Clean up
        if ( FAILED(hr) ) (*ppDir)->Release();
    }
    
    return hr;
}


BOOL IsIPPhoneUpTodate( ITDirectory *pDirectory, BSTR bUserName, BSTR bstrHostName )
{
    BOOL fOK = FALSE;

    CComPtr<IEnumDirectoryObject> pEnum;
    HRESULT hr = pDirectory->EnumerateDirectoryObjects(
        OT_USER,
        bUserName,
        &pEnum
        );

    if (FAILED(hr))
    {
        return fOK;
    }

    for (;;)
    {
        CComPtr <ITDirectoryObject> pObject;

        if ((hr = pEnum->Next(1, &pObject, NULL)) != S_OK)
        {
            break;
        }

        BSTR bObjectName;

        hr = pObject->get_Name(&bObjectName);
        if (FAILED(hr))
        {
            // try the next one.
            continue;
        }

        if (lstrcmpW(bObjectName, bUserName) != 0)
        {
            SysFreeString(bObjectName);

            // try the next one.
            continue;
        }
        SysFreeString(bObjectName);


        CComPtr <ITDirectoryObjectUser> pObjectUser;
        BSTR bstrIpPhonePrimary;

        hr = pObject->QueryInterface(IID_ITDirectoryObjectUser,
                                     (void **) &pObjectUser);

        if (FAILED(hr))
        {
            continue;
        }


        hr = pObjectUser->get_IPPhonePrimary(&bstrIpPhonePrimary);

        if (FAILED(hr))
        {
            continue;
        }

        // see if the IPPhone attribute is up to date.
        if (lstrcmpW(bstrIpPhonePrimary, bstrHostName) == 0)
        {
            fOK = TRUE;
            SysFreeString(bstrIpPhonePrimary);

            break;
        }
        SysFreeString(bstrIpPhonePrimary);
    }

    return fOK;
}


HRESULT PublishToNTDS( ITRendezvous *pRend )
{
    _ASSERT( pRend );
    CComPtr<ITDirectory> pDir;

    // find the NTDS directory.
    HRESULT hr = pRend->CreateDirectory(DT_NTDS, NULL, &pDir );
    if ( FAILED(hr) )
    {
        return hr;
    }

    // connect to the server.
    if ( FAILED(hr = pDir->Connect(FALSE)) )
    {
        return hr;
    }

    // bind to the server so that we can update later.
    if ( FAILED(hr = pDir->Bind(NULL, NULL, NULL, RENDBIND_AUTHENTICATE)))
    {
        return hr;
    }

    // create a user object that can be published.
    hr = E_FAIL;
    BSTR bstrName = NULL;
    if ( MyGetUserName(&bstrName) )
    {
        BSTR bstrHostName = NULL;
        BSTR bstrIPAddress = NULL;

        GetIPAddress( &bstrIPAddress, &bstrHostName );
        if ( bstrHostName )
        {
            // Create the user object
            CComPtr<ITDirectoryObject> pUser;
            if ( SUCCEEDED(hr = pRend->CreateDirectoryObject(OT_USER, bstrName, &pUser)) )
            {
                ITDirectoryObjectUser *pTempUser;
                if ( SUCCEEDED(hr = pUser->QueryInterface(IID_ITDirectoryObjectUser, (void **) &pTempUser)) )
                {
                    // Set the host name here 
                    if ( bstrHostName )
                        pTempUser->put_IPPhonePrimary( bstrHostName );

                    pTempUser->Release();
                }
            }

            BOOL fOK = IsIPPhoneUpTodate(pDir, bstrName, bstrHostName);
            if (!fOK)
            {
                // update the user object.
                hr = pDir->AddDirectoryObject(pUser);
            }
            else
            {
                hr = S_OK;
            }
        }

        SysFreeString(bstrHostName);
        SysFreeString(bstrIPAddress);
    }
    SysFreeString( bstrName );

    return hr;
}


void LoadDefaultServers( CPublishUserInfo *pInfo )
{
    USES_CONVERSION;
    _ASSERT( pInfo );

    bool bFirst = true;

    // Load the default servers into the dialog
    CComPtr<IAVTapi> pAVTapi;
    if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
    {
        IConfExplorer *pIConfExplorer;
        if ( SUCCEEDED(pAVTapi->get_ConfExplorer(&pIConfExplorer)) )
        {
            ITRendezvous *pITRend;
            if ( SUCCEEDED(pIConfExplorer->get_ITRendezvous((IUnknown **) &pITRend)) )
            {
                IEnumDirectory *pEnum = NULL;
                if ( SUCCEEDED(pITRend->EnumerateDefaultDirectories(&pEnum)) && pEnum )
                {
                    ITDirectory *pDir = NULL;
                    while ( (pEnum->Next(1, &pDir, NULL) == S_OK) && pDir )
                    {
                        // Look for ILS servers
                        DIRECTORY_TYPE nDirType;
                        if ( SUCCEEDED(pDir->get_DirectoryType(&nDirType)) && (nDirType == DT_ILS) )
                        {
                            BSTR bstrName = NULL;
                            pDir->get_DisplayName( &bstrName );
                            if ( bstrName && SysStringLen(bstrName) )
                            {
                                // First server on list; want to compare with default server
                                if ( bFirst )
                                {
                                    bFirst = false;
                                    if ( pIConfExplorer->IsDefaultServer(bstrName) != S_OK )
                                    {
                                        IConfExplorerTreeView *pTreeView;
                                        if ( SUCCEEDED(pIConfExplorer->get_TreeView(&pTreeView)) )
                                        {
                                            pAVTapi->put_bstrDefaultServer( bstrName );
                                            
                                            // Loop trying to force Enum on server
                                            int nTries = 0;
                                            ATLTRACE(_T(".1.LoadDefaultServers() forcing conf server enumeration.\n"));
                                            while ( FAILED(pTreeView->ForceConfServerForEnum(NULL)) )
                                            {    
                                                ATLTRACE(_T(".1.LoadDefaultServers() re-trying to force conf server enumeration.\n"));
                                                Sleep( 3000 );
                                                if ( ++nTries > 20 )
                                                {
                                                    ATLTRACE(_T(".1.LoadDefaultServers() -- failed to force enum.\n"));
                                                    break;
                                                }
                                            }
                                            ATLTRACE(_T(".1.LoadDefaultServers() -- safely out of spin loop.\n"));

                                            pTreeView->Release();
                                        }
                                        
                                    }
                                }

                                pInfo->m_lstServers.push_back( bstrName );
                            }
                        }

                        pDir->Release();
                        pDir = NULL;
                    }
                    pEnum->Release();
                }
                pITRend->Release();
            }
            pIConfExplorer->Release();
        }
    }

    // Add the servers stored in the registry
    CRegKey regKey;
    TCHAR szReg[MAX_SERVER_SIZE + 100], szSubKey[50], szText[MAX_SERVER_SIZE];
    LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_KEY, szReg, ARRAYSIZE(szReg) );
    if ( regKey.Open(HKEY_CURRENT_USER, szReg, KEY_READ) == ERROR_SUCCESS )
    {
        // Load up info from registry
        int nCount = 0, nLevel = 1, iImage;
        UINT state;
        DWORD dwSize;

        do
        {
            // Read registry entry
            LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_ENTRY, szReg, ARRAYSIZE(szReg) );
            _sntprintf( szSubKey, ARRAYSIZE(szSubKey), szReg, nCount );
            dwSize = ARRAYSIZE(szReg) - 1;
            if ( (regKey.QueryValue(szReg, szSubKey, &dwSize) != ERROR_SUCCESS) || !dwSize ) break;

            // Parse registry entry
            GetToken( 1, _T("\","), szReg, szText ); nLevel = min(MAX_TREE_DEPTH - 1, max(1,_ttoi(szText)));
            GetToken( 2, _T("\","), szReg, szText ); iImage = _ttoi( szText );
            GetToken( 3, _T("\","), szReg, szText ); state = (UINT) _ttoi( szText );
            GetToken( 4, _T("\","), szReg, szText );

            // Notify host app of server being added.
            if ( iImage == CConfExplorerTreeView::IMAGE_SERVER )
            {
                BSTR bstrServer = SysAllocString( T2COLE(szText) );
                if ( bstrServer )
                    pInfo->m_lstServers.push_back( bstrServer );
            }
        } while  ( ++nCount );
    }
}


///////////////////////////////////////////////////////////////
// Processing thread

DWORD WINAPI ThreadPublishUserProc( LPVOID lpInfo )
{
    CPublishUserInfo *pInfo = (CPublishUserInfo *) lpInfo;

    USES_CONVERSION;
    HANDLE hThread = NULL;
    BOOL bDup = DuplicateHandle( GetCurrentProcess(),
                                 GetCurrentThread(),
                                 GetCurrentProcess(),
                                 &hThread,
                                 THREAD_ALL_ACCESS,
                                 TRUE,
                                 0 );

    _ASSERT( bDup );
    _Module.AddThread( hThread );

    // Error info information
    CErrorInfo er;
    er.set_Operation( IDS_ER_PLACECALL );
    er.set_Details( IDS_ER_COINITIALIZE );
    HRESULT hr = er.set_hr( CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY) );
    if ( SUCCEEDED(hr) )
    {
        ATLTRACE(_T(".1.ThreadPublishUserProc() -- thread up and running.\n") );

        // Make sure we have server information to publish
        if ( !pInfo )
        {
            pInfo = new CPublishUserInfo();
            if ( pInfo )
            {
                LoadDefaultServers( pInfo );
                pInfo->m_bCreateUser = true;
            }
        }

        // Do we have something to publish?
        CComPtr<IAVTapi> pAVTapi;
        if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
        {    
            IConfExplorer *pConfExp;
            if ( SUCCEEDED(pAVTapi->get_ConfExplorer(&pConfExp)) )
            {
                ITRendezvous *pRend;
                if ( SUCCEEDED(pConfExp->get_ITRendezvous((IUnknown **) &pRend)) )
                {
                    // try to publish to NTDS
                    PublishToNTDS(pRend);

                    if ( pInfo && !pInfo->m_lstServers.empty() )
                    {
                        // Create the user that will be added or removed
                        ITDirectoryObject *pUser;
                        BSTR bstrIPAddress = NULL;
                        if ( SUCCEEDED(CreateUserObject(pRend, &pUser, &bstrIPAddress)) )
                        {
                            // Add the directory object to all the servers
                            BSTRLIST::iterator i, iEnd = pInfo->m_lstServers.end();
                            for ( i = pInfo->m_lstServers.begin(); i != iEnd; i++ )
                            {
                                CErrorInfo er( IDS_ER_ADD_ACCESS_ILS_SERVER, 0 );
                                er.set_Details( 0 );
                                SysReAllocString( &er.m_bstrDetails, *i );

                                ITDirectory *pITDir;
                                if ( SUCCEEDED(hr = er.set_hr(OpenServer(pRend, *i, &pITDir))) )
                                {
                                    er.set_Operation( IDS_ER_ADD_ILS_USER );

                                    // Either add or remove the user
                                    if ( pInfo->m_bCreateUser )
                                    {
                                        bool bChanged, bSameIPAddress = false;

                                        ITDirectoryObject* pDirObject = NULL;
                                        if ( (SUCCEEDED(GetDirectoryObject(pITDir, bstrIPAddress, &pDirObject))) && pDirObject )
                                        {
                                            GetDirObjectChangedStatus( pUser, pDirObject, bChanged, bSameIPAddress );

                                            // Same IP address, modify or refresh
                                            if ( bSameIPAddress )
                                            {
                                                if ( bChanged )
                                                {
                                                    ATLTRACE(_T(".1.Deleting user on %s.\n"), OLE2CT(*i));
                                                    pITDir->DeleteDirectoryObject( pDirObject );
                                                    bSameIPAddress = false;
                                                }
                                                else
                                                {
                                                    ATLTRACE(_T(".1.Refreshing user on %s.\n"), OLE2CT(*i));
                                                    pITDir->RefreshDirectoryObject( pDirObject );
                                                }
                                            }
                                            pDirObject->Release();
                                        }

                                        // Different IP address, add user
                                        if ( !bSameIPAddress )
                                        {
                                            ATLTRACE(_T(".1.Adding user on %s.\n"), OLE2CT(*i));
                                            pITDir->AddDirectoryObject( pUser );

                                            IConfExplorerTreeView *pTreeView;
                                            if ( SUCCEEDED(pConfExp->get_TreeView(&pTreeView)) )
                                            {    
                                                if ( pConfExp->IsDefaultServer(*i) == S_OK )
                                                    pTreeView->AddPerson( NULL, pUser );
                                                else
                                                    pTreeView->AddPerson( *i, pUser );

                                                pTreeView->Release();
                                            }
                                        }
                                    }
                                    else
                                    {
                                        pITDir->DeleteDirectoryObject(pUser);
                                    }

                                    pITDir->Release();
                                }
                                else if ( hr == 0x8007003a )
                                {
                                    // Ignore in the case that the server is down.
                                    er.set_hr( S_OK );
                                }

                                // Ignore errors when trying to remove the user
                                if ( !pInfo->m_bCreateUser ) er.set_hr( S_OK );
                            }
                            pUser->Release();
                        }
                        SysFreeString( bstrIPAddress );
                    }
                    pRend->Release();
                }
                pConfExp->Release();
            }
            // AVTapi automatically released
        }

        // Clean-up
        CoUninitialize();
    }

    // Clean up allocated memory passed in
    if ( pInfo )
        delete pInfo;

    // Notify module of shutdown
    _Module.RemoveThread( hThread );
    SetEvent( _Module.m_hEventThread );
    ATLTRACE(_T(".exit.ThreadPublishUserProc(0x%08lx).\n"), hr );
    return hr;
}

HRESULT GetDirectoryObject(ITDirectory* pITDir, BSTR bstrIPAddress, ITDirectoryObject **ppDirObj )
{
    USES_CONVERSION;
    HRESULT hr;
    IEnumDirectoryObject *pEnumUser = NULL;
    if ( SUCCEEDED(hr = pITDir->EnumerateDirectoryObjects(OT_USER, A2BSTR("*"), &pEnumUser)) && pEnumUser )
    {
        hr = E_FAIL;

        ITDirectoryObject *pITDirObject = NULL;
        while ( FAILED(hr) && (pEnumUser->Next(1, &pITDirObject, NULL) == S_OK) && pITDirObject )
        {
            // Get an IP Address
            BSTR bstrIPPrimary = NULL;
            IEnumDialableAddrs *pEnum = NULL;
            if ( SUCCEEDED(pITDirObject->EnumerateDialableAddrs(LINEADDRESSTYPE_IPADDRESS, &pEnum)) && pEnum )
            {
                pEnum->Next(1, &bstrIPPrimary, NULL );
                pEnum->Release();
            }

            //
            // We have to verify the bstrIPPrimary allocation
            //

            if( (bstrIPPrimary != NULL) && 
                (!IsBadStringPtr( bstrIPPrimary, (UINT)-1)) )
            {
                if ( !wcscmp(bstrIPPrimary, bstrIPAddress) )
                {
                    *ppDirObj = pITDirObject;
                    (*ppDirObj)->AddRef();
                    hr = S_OK;
                }

                SysFreeString( bstrIPPrimary );
            }

            pITDirObject->Release();
            pITDirObject = NULL;
        }
        pEnumUser->Release();
    }
    return hr;
}

void GetDirObjectChangedStatus( ITDirectoryObject* pOldUser, ITDirectoryObject* pNewUser, bool &bChanged, bool &bSameIPAddress )
{
    bChanged = false;
    bSameIPAddress = false;

    /////////////////////////////////////////////////////////////
    // First check addresses and make sure they're the same
    //
    BSTR bstrAddressOld = NULL, bstrAddressNew = NULL;

    IEnumDialableAddrs *pEnum = NULL;
    // Old user IP Address
    if ( SUCCEEDED(pOldUser->EnumerateDialableAddrs(LINEADDRESSTYPE_IPADDRESS, &pEnum)) && pEnum )
    {
        pEnum->Next(1, &bstrAddressOld, NULL );
        pEnum->Release();
    }
    // New user IP Address
    if ( SUCCEEDED(pNewUser->EnumerateDialableAddrs(LINEADDRESSTYPE_IPADDRESS, &pEnum)) && pEnum )
    {
        pEnum->Next(1, &bstrAddressNew, NULL );
        pEnum->Release();
    }

    //if change in primary IP Phone number
    if ( bstrAddressOld && bstrAddressNew && (wcsicmp(bstrAddressOld, bstrAddressNew) == 0) )
        bSameIPAddress = true;

    SysFreeString( bstrAddressOld );
    SysFreeString( bstrAddressNew );

    // Check if name has changed
    if ( bSameIPAddress )
    {
        BSTR bstrOldUser = NULL;
        BSTR bstrNewUser = NULL;

        pOldUser->get_Name(&bstrOldUser);
        pNewUser->get_Name(&bstrNewUser);

        // different names?
        if ( bstrOldUser && bstrNewUser && wcsicmp(bstrOldUser, bstrNewUser) )
            bChanged = true;

        SysFreeString( bstrOldUser );
        SysFreeString( bstrNewUser );
    }
}

bool MyGetUserName( BSTR *pbstrName )
{
    _ASSERT( pbstrName );
    *pbstrName = NULL;

    USES_CONVERSION;
    bool bRet = false;

    TCHAR szText[MAX_USER_NAME_SIZE + 1];
    DWORD dwSize = MAX_USER_NAME_SIZE;    
    if ( GetUserName(szText, &dwSize) && (dwSize > 0) )
    {
        // Make the name -- it's a combination of user@machine
        if ( SUCCEEDED(SysReAllocString(pbstrName, T2COLE(szText))) )
            bRet = true;
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\videofeed.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// VideoFeed.h : Declaration of the CVideoFeed

#ifndef __VIDEOFEED_H_
#define __VIDEOFEED_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CVideoFeed
class ATL_NO_VTABLE CVideoFeed : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CVideoFeed, &CLSID_VideoFeed>,
	public IVideoFeed
{
// Construction
public:
	CVideoFeed();
	void FinalRelease();

// Members
public:
	IVideoWindow	*m_pVideo;
	RECT			m_rc;
	VARIANT_BOOL	m_bPreview;
	VARIANT_BOOL	m_bRequestQOS;
	BSTR			m_bstrName;

protected:
	ITParticipant	*m_pITParticipant;

DECLARE_NOT_AGGREGATABLE(CVideoFeed)

BEGIN_COM_MAP(CVideoFeed)
	COM_INTERFACE_ENTRY(IVideoFeed)
END_COM_MAP()

// Operations
public:
	static HRESULT	GetNameFromParticipant(ITParticipant *pParticipant, BSTR * pbstrName, BSTR *pbstrInfo );
	
// IVideoFeed
public:
	STDMETHOD(MapToParticipant)(ITParticipant *pParticipant);
	STDMETHOD(get_ITSubStream)(/*[out, retval]*/ ITSubStream * *pVal);
	STDMETHOD(GetNameFromVideo)(IUnknown *pVideo, BSTR *pbstrName, BSTR *pbstrInfo, VARIANT_BOOL bAllowNull, VARIANT_BOOL bPreview);
	STDMETHOD(IsVideoStreaming)(VARIANT_BOOL bIncludePreview);
	STDMETHOD(UpdateName)();
	STDMETHOD(get_bRequestQOS)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_bRequestQOS)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_bPreview)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_bPreview)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ITParticipant)(/*[out, retval]*/ ITParticipant **ppVal);
	STDMETHOD(put_ITParticipant)(/*[in]*/ ITParticipant *pVal);
	STDMETHOD(get_rc)(/*[out, retval]*/ RECT *pVal);
	STDMETHOD(put_rc)(/*[in]*/ RECT newVal);
	STDMETHOD(Paint)(ULONG_PTR hDC, HWND hWndSource);
	STDMETHOD(get_IVideoWindow)(/*[out, retval]*/ IUnknown * *pVal);
	STDMETHOD(put_IVideoWindow)(/*[in]*/ IUnknown * newVal);
	STDMETHOD(get_bstrName)(/*[out, retval]*/ BSTR *pVal);
};

#endif //__VIDEOFEED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\threadrend.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////
// ThreadRend.h
//

#ifndef __THREADREND_H__
#define __THREADREND_H__

DWORD WINAPI ThreadRendezvousProc( LPVOID lpInfo );

#endif // __THREADREND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\acmthunk.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  acmthunk.c
//
//  Description:
//      This is a thunk layer to the Audio Compression Manager. It's 
//      purpose is to allow an application to use the ACM only if it is
//      available (like under Win 3.1 and NT where the ACM may or may not
//      be installed).
//
//      There are two requirements for using this module:
//
//      1.  Compile and link with this module before linking to MMSYSTEM.LIB.
//          Do *NOT* link with MSACM.LIB.
//
//      2.  Before calling any other functions in ACM function set, call
//          acmThunkInitialize(). This will cause all dyna-linking to occur.
//
//      3.  Before exiting your application, call acmThunkTerminate().
//          This will unlink to the ACM and free allocated resources.
//
//      NOTE! this could be written more efficiently in Assembly by doing
//      a jump to the correct API in the ACM, but this would not be
//      portable (easily) on NT. So the arguments will be repushed on the
//      stack.. such is life.
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

//
//
//
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif


//==========================================================================;
//
//  Prototypes and String Defines for Dyna-Linking to the ACM
//
//
//==========================================================================;

#define ACMINST_NOT_PRESENT     NULL
#define ACMINST_TRY_LINKING     (HINSTANCE)(UINT)-1

static HINSTANCE    ghinstAcm   = ACMINST_TRY_LINKING;

#ifdef WIN32
TCHAR BCODE gszAcmModuleName[]  = TEXT("MSACM32.DLL");
#else
char BCODE  gszAcmModuleName[]  = "MSACM.DLL";
#endif

FARPROC    *gpafnAcmFunctions;

PSTR BCODE  gapszAcmFunctions[] =
{
    "acmGetVersion",
    "acmMetrics",

    "acmDriverEnum",
#ifdef WIN32
    "acmDriverDetailsW",
    "acmDriverDetailsA",
#else
    "acmDriverDetails",
#endif
#ifdef WIN32
    "acmDriverAddW",
    "acmDriverAddA",
#else
    "acmDriverAdd",
#endif
    "acmDriverRemove",
    "acmDriverOpen",
    "acmDriverClose",
    "acmDriverMessage",
    "acmDriverID",
    "acmDriverPriority",

#ifdef WIN32
    "acmFormatTagDetailsW",
    "acmFormatTagDetailsA",
#else
    "acmFormatTagDetails",
#endif
#ifdef WIN32
    "acmFormatTagEnumW",
    "acmFormatTagEnumA",
#else
    "acmFormatTagEnum",
#endif
#ifdef WIN32
    "acmFormatChooseW",
    "acmFormatChooseA",
#else
    "acmFormatChoose",
#endif
#ifdef WIN32
    "acmFormatDetailsW",
    "acmFormatDetailsA",
#else
    "acmFormatDetails",
#endif
#ifdef WIN32
    "acmFormatEnumW",
    "acmFormatEnumA",
#else
    "acmFormatEnum",
#endif
    "acmFormatSuggest",

#ifdef WIN32
    "acmFilterTagDetailsW",
    "acmFilterTagDetailsA",
#else
    "acmFilterTagDetails",
#endif
#ifdef WIN32
    "acmFilterTagEnumW",
    "acmFilterTagEnumA",
#else
    "acmFilterTagEnum",
#endif
#ifdef WIN32
    "acmFilterChooseW",
    "acmFilterChooseA",
#else
    "acmFilterChoose",
#endif
#ifdef WIN32
    "acmFilterDetailsW",
    "acmFilterDetailsA",
#else
    "acmFilterDetails",
#endif
#ifdef WIN32
    "acmFilterEnumW",
    "acmFilterEnumA",
#else
    "acmFilterEnum",
#endif

    "acmStreamOpen",
    "acmStreamClose",
    "acmStreamSize",
    "acmStreamConvert",
    "acmStreamReset",
    "acmStreamPrepareHeader",
    "acmStreamUnprepareHeader"
};

#ifdef WIN32    
//
//  For Win32
//
enum
{
     ACMTHUNK_GETVERSION = 0,
     ACMTHUNK_METRICS,
     ACMTHUNK_DRIVERENUM,
     ACMTHUNK_DRIVERDETAILSW,
     ACMTHUNK_DRIVERDETAILSA,
     ACMTHUNK_DRIVERADDW,
     ACMTHUNK_DRIVERADDA,
     ACMTHUNK_DRIVERREMOVE,
     ACMTHUNK_DRIVEROPEN,
     ACMTHUNK_DRIVERCLOSE,
     ACMTHUNK_DRIVERMESSAGE,
     ACMTHUNK_DRIVERID,
     ACMTHUNK_DRIVERPRIORITY,
     ACMTHUNK_FORMATTAGDETAILSW,
     ACMTHUNK_FORMATTAGDETAILSA,
     ACMTHUNK_FORMATTAGENUMW,
     ACMTHUNK_FORMATTAGENUMA,
     ACMTHUNK_FORMATCHOOSEW,
     ACMTHUNK_FORMATCHOOSEA,
     ACMTHUNK_FORMATDETAILSW,
     ACMTHUNK_FORMATDETAILSA,
     ACMTHUNK_FORMATENUMW,
     ACMTHUNK_FORMATENUMA,
     ACMTHUNK_FORMATSUGGEST,
     ACMTHUNK_FILTERTAGDETAILSW,
     ACMTHUNK_FILTERTAGDETAILSA,
     ACMTHUNK_FILTERTAGENUMW,
     ACMTHUNK_FILTERTAGENUMA,
     ACMTHUNK_FILTERCHOOSEW,
     ACMTHUNK_FILTERCHOOSEA,
     ACMTHUNK_FILTERDETAILSW,
     ACMTHUNK_FILTERDETAILSA,
     ACMTHUNK_FILTERENUMW,
     ACMTHUNK_FILTERENUMA,
     ACMTHUNK_STREAMOPEN,
     ACMTHUNK_STREAMCLOSE,
     ACMTHUNK_STREAMSIZE,
     ACMTHUNK_STREAMCONVERT,
     ACMTHUNK_STREAMRESET,
     ACMTHUNK_STREAMPREPAREHEADER,
     ACMTHUNK_STREAMUNPREPAREHEADER,

     ACMTHUNK_MAX_FUNCTIONS
};
     
	#ifdef _UNICODE
	#define ACMTHUNK_DRIVERDETAILS	    ACMTHUNK_DRIVERDETAILSW
	#define ACMTHUNK_DRIVERADD	    ACMTHUNK_DRIVERADDW
	#define ACMTHUNK_FORMATTAGDETAILS   ACMTHUNK_FORMATTAGDETAILSW
	#define ACMTHUNK_FORMATTAGENUM	    ACMTHUNK_FORMATTAGENUMW
	#define ACMTHUNK_FORMATCHOOSE	    ACMTHUNK_FORMATCHOOSEW
	#define ACMTHUNK_FORMATDETAILS	    ACMTHUNK_FORMATDETAILSW
	#define ACMTHUNK_FORMATENUM	    ACMTHUNK_FORMATENUMW
	#define ACMTHUNK_FILTERTAGDETAILS   ACMTHUNK_FILTERTAGDETAILSW
	#define ACMTHUNK_FILTERTAGENUM	    ACMTHUNK_FILTERTAGENUMW
	#define ACMTHUNK_FILTERCHOOSE	    ACMTHUNK_FILTERCHOOSEW
	#define ACMTHUNK_FILTERDETAILS	    ACMTHUNK_FILTERDETAILSW
	#define ACMTHUNK_FILTERENUM	    ACMTHUNK_FILTERENUMW

	#else
	#define ACMTHUNK_DRIVERDETAILS	    ACMTHUNK_DRIVERDETAILSA
	#define ACMTHUNK_DRIVERADD	    ACMTHUNK_DRIVERADDA
	#define ACMTHUNK_FORMATTAGDETAILS   ACMTHUNK_FORMATTAGDETAILSA
	#define ACMTHUNK_FORMATTAGENUM	    ACMTHUNK_FORMATTAGENUMA
	#define ACMTHUNK_FORMATCHOOSE	    ACMTHUNK_FORMATCHOOSEA
	#define ACMTHUNK_FORMATDETAILS	    ACMTHUNK_FORMATDETAILSA
	#define ACMTHUNK_FORMATENUM	    ACMTHUNK_FORMATENUMA
	#define ACMTHUNK_FILTERTAGDETAILS   ACMTHUNK_FILTERTAGDETAILSA
	#define ACMTHUNK_FILTERTAGENUM	    ACMTHUNK_FILTERTAGENUMA
	#define ACMTHUNK_FILTERCHOOSE	    ACMTHUNK_FILTERCHOOSEA
	#define ACMTHUNK_FILTERDETAILS	    ACMTHUNK_FILTERDETAILSA
	#define ACMTHUNK_FILTERENUM	    ACMTHUNK_FILTERENUMA

	#endif

#else     // if Win32
//
//  For Win16
//
enum
{
     ACMTHUNK_GETVERSION = 0,
     ACMTHUNK_METRICS,
     ACMTHUNK_DRIVERENUM,
     ACMTHUNK_DRIVERDETAILS,
     ACMTHUNK_DRIVERADD,
     ACMTHUNK_DRIVERREMOVE,
     ACMTHUNK_DRIVEROPEN,
     ACMTHUNK_DRIVERCLOSE,
     ACMTHUNK_DRIVERMESSAGE,
     ACMTHUNK_DRIVERID,
     ACMTHUNK_DRIVERPRIORITY,
     ACMTHUNK_FORMATTAGDETAILS,
     ACMTHUNK_FORMATTAGENUM,
     ACMTHUNK_FORMATCHOOSE,
     ACMTHUNK_FORMATDETAILS,
     ACMTHUNK_FORMATENUM,
     ACMTHUNK_FORMATSUGGEST,
     ACMTHUNK_FILTERTAGDETAILS,
     ACMTHUNK_FILTERTAGENUM,
     ACMTHUNK_FILTERCHOOSE,
     ACMTHUNK_FILTERDETAILS,
     ACMTHUNK_FILTERENUM,
     ACMTHUNK_STREAMOPEN,
     ACMTHUNK_STREAMCLOSE,
     ACMTHUNK_STREAMSIZE,
     ACMTHUNK_STREAMCONVERT,
     ACMTHUNK_STREAMRESET,
     ACMTHUNK_STREAMPREPAREHEADER,
     ACMTHUNK_STREAMUNPREPAREHEADER,

     ACMTHUNK_MAX_FUNCTIONS
};

#endif	// if WIN32 else

#define ACMTHUNK_SIZE_TABLE_BYTES   (ACMTHUNK_MAX_FUNCTIONS * sizeof(FARPROC))


//==========================================================================;
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL acmThunkInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

BOOL FAR PASCAL acmThunkInitialize
(
    void
)
{
    DWORD (ACMAPI *pfnAcmGetVersion)
    (
        void
    );

    UINT            fuErrorMode;
    DWORD           dwVersion;
    UINT            u;

    //
    //  if we have already linked to the API's, then just succeed...
    //
    if (NULL != gpafnAcmFunctions)
    {
        //
        //  someone isn't satisfied with calling this API only once?
        //
        return (TRUE);
    }


    //
    //  if we have already tried to link to the ACM, then fail this
    //  call--it isn't present.
    //
    if (ACMINST_TRY_LINKING != ghinstAcm)
        return (FALSE);


    //
    //  try to get a handle on the ACM--if we cannot do this, then fail
    //
    fuErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    ghinstAcm = LoadLibrary(gszAcmModuleName);
    SetErrorMode(fuErrorMode);
    if (ghinstAcm < (HINSTANCE)HINSTANCE_ERROR)
    {
        ghinstAcm = ACMINST_NOT_PRESENT;
        return (FALSE);
    }

    (FARPROC)pfnAcmGetVersion = GetProcAddress(ghinstAcm, gapszAcmFunctions[ACMTHUNK_GETVERSION]);
    if (NULL == pfnAcmGetVersion)
    {
        FreeLibrary(ghinstAcm);
        ghinstAcm = ACMINST_NOT_PRESENT;

        return (FALSE);
    }


    //
    //  allocate our array of function pointers to the ACM... note that
    //  this is dynamically allocated so if the ACM is _not_ present,
    //  then this code and data takes up very little space.
    //
    gpafnAcmFunctions = (FARPROC *)LocalAlloc(LPTR, ACMTHUNK_SIZE_TABLE_BYTES);
    if (NULL == gpafnAcmFunctions)
    {
        FreeLibrary(ghinstAcm);
        ghinstAcm = ACMINST_NOT_PRESENT;

        return (FALSE);
    }

    gpafnAcmFunctions[ACMTHUNK_GETVERSION] = (FARPROC)pfnAcmGetVersion;

    //
    //  if the version of the ACM is *NOT* V2.00 or greater, then
    //  all other API's are unavailable--so don't waste time trying
    //  to link to them.
    //
    dwVersion = (* pfnAcmGetVersion)();
    if (0x0200 > HIWORD(dwVersion))
    {
        return (TRUE);
    }


    //
    //  yipee! the ACM V2.00 or greater appears to be installed and
    //  happy with us--so link to the rest of the nifty cool API's.
    //
    //  start at index 1 since we already linked to acmGetVersion above
    //
    for (u = 1; u < ACMTHUNK_MAX_FUNCTIONS; u++)
    {
        gpafnAcmFunctions[u] = GetProcAddress(ghinstAcm, gapszAcmFunctions[u]);
    }


    //
    //  finally, return success
    //
    return (TRUE);
} // acmThunkInitialize()


//--------------------------------------------------------------------------;
//  
//  BOOL acmThunkTerminate
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

BOOL FAR PASCAL acmThunkTerminate
(
    void
)
{
    //
    //
    //
    if (NULL != gpafnAcmFunctions)
    {
        LocalFree((HLOCAL)gpafnAcmFunctions);

        gpafnAcmFunctions = NULL;

        FreeLibrary(ghinstAcm);
        ghinstAcm = ACMINST_TRY_LINKING;
    }

    return (TRUE);
} // acmThunkTerminate()


//==========================================================================;
//
//  General Information API's
//
//
//==========================================================================;

DWORD ACMAPI acmGetVersion
(
    void
)
{
    DWORD (ACMAPI *pfnAcmGetVersion)
    (
        void
    );

    DWORD           dwVersion;

    if (NULL == gpafnAcmFunctions)
        return (0L);

    (FARPROC)pfnAcmGetVersion = gpafnAcmFunctions[ACMTHUNK_GETVERSION];
    if (NULL == pfnAcmGetVersion)
        return (0L);

    dwVersion = (* pfnAcmGetVersion)();

    return (dwVersion);
} // acmGetVersion()


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmMetrics
(
    HACMOBJ                 hao,
    UINT                    uMetric,
    LPVOID                  pMetric
)
{
    MMRESULT (ACMAPI *pfnAcmMetrics)
    (
        HACMOBJ                 hao,
        UINT                    uMetric,
        LPVOID                  pMetric
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmMetrics = gpafnAcmFunctions[ACMTHUNK_METRICS];
    if (NULL == pfnAcmMetrics)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmMetrics)(hao, uMetric, pMetric);

    return (mmr);
} // acmMetrics()


//==========================================================================;
//
//  ACM Driver Management API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverEnum
(
    ACMDRIVERENUMCB         fnCallback,
    DWORD                   dwInstance,
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmDriverEnum)
    (
        ACMDRIVERENUMCB         fnCallback,
        DWORD                   dwInstance,
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverEnum = gpafnAcmFunctions[ACMTHUNK_DRIVERENUM];
    if (NULL == pfnAcmDriverEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverEnum)(fnCallback, dwInstance, fdwEnum);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverDetails
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILS      padd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmDriverDetails)
    (
        HACMDRIVERID            hadid,
        LPACMDRIVERDETAILS      padd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverDetails = gpafnAcmFunctions[ACMTHUNK_DRIVERDETAILS];
    if (NULL == pfnAcmDriverDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverDetails)(hadid, padd, fdwDetails);

    return (mmr);
}

#ifdef _UNICODE
MMRESULT ACMAPI acmDriverDetailsA
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSA     padd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmDriverDetails)
    (
        HACMDRIVERID            hadid,
        LPACMDRIVERDETAILSA     padd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverDetails = gpafnAcmFunctions[ACMTHUNK_DRIVERDETAILSA];
    if (NULL == pfnAcmDriverDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverDetails)(hadid, padd, fdwDetails);

    return (mmr);
}
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverAdd
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
)
{
    MMRESULT (ACMAPI *pfnAcmDriverAdd)
    (
        LPHACMDRIVERID          phadid,
        HINSTANCE               hinstModule,
        LPARAM                  lParam, 
        DWORD                   dwPriority,
        DWORD                   fdwAdd
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverAdd = gpafnAcmFunctions[ACMTHUNK_DRIVERADD];
    if (NULL == pfnAcmDriverAdd)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverAdd)(phadid, hinstModule, lParam, dwPriority, fdwAdd);

    return (mmr);
}

#ifdef _UNICODE
MMRESULT ACMAPI acmDriverAddA
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
)
{
    MMRESULT (ACMAPI *pfnAcmDriverAdd)
    (
        LPHACMDRIVERID          phadid,
        HINSTANCE               hinstModule,
        LPARAM                  lParam, 
        DWORD                   dwPriority,
        DWORD                   fdwAdd
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverAdd = gpafnAcmFunctions[ACMTHUNK_DRIVERADDA];
    if (NULL == pfnAcmDriverAdd)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverAdd)(phadid, hinstModule, lParam, dwPriority, fdwAdd);

    return (mmr);
}
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverRemove
(
    HACMDRIVERID            hadid,
    DWORD                   fdwRemove
)
{
    MMRESULT (ACMAPI *pfnAcmDriverRemove)
    (
        HACMDRIVERID            hadid,
        DWORD                   fdwRemove
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverRemove = gpafnAcmFunctions[ACMTHUNK_DRIVERREMOVE];
    if (NULL == pfnAcmDriverRemove)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverRemove)(hadid, fdwRemove);

    return (mmr);
}

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverOpen
(
    LPHACMDRIVER            phad, 
    HACMDRIVERID            hadid,
    DWORD                   fdwOpen
)
{
    MMRESULT (ACMAPI *pfnAcmDriverOpen)
    (
        LPHACMDRIVER            phad, 
        HACMDRIVERID            hadid,
        DWORD                   fdwOpen
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverOpen = gpafnAcmFunctions[ACMTHUNK_DRIVEROPEN];
    if (NULL == pfnAcmDriverOpen)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverOpen)(phad, hadid, fdwOpen);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverClose
(
    HACMDRIVER              had,
    DWORD                   fdwClose
)
{
    MMRESULT (ACMAPI *pfnAcmDriverClose)
    (
        HACMDRIVER              had,
        DWORD                   fdwClose
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverClose = gpafnAcmFunctions[ACMTHUNK_DRIVERCLOSE];
    if (NULL == pfnAcmDriverClose)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverClose)(had, fdwClose);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

LRESULT ACMAPI acmDriverMessage
(
    HACMDRIVER              had,
    UINT                    uMsg, 
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT (ACMAPI *pfnAcmDriverMessage)
    (
        HACMDRIVER              had,
        UINT                    uMsg, 
        LPARAM                  lParam1,
        LPARAM                  lParam2
    );

    LRESULT         lr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverMessage = gpafnAcmFunctions[ACMTHUNK_DRIVERMESSAGE];
    if (NULL == pfnAcmDriverMessage)
        return (MMSYSERR_ERROR);

    lr = (* pfnAcmDriverMessage)(had, uMsg, lParam1, lParam2);

    return (lr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverID
(
    HACMOBJ                 hao,
    LPHACMDRIVERID          phadid,
    DWORD                   fdwDriverId
)
{
    MMRESULT (ACMAPI *pfnAcmDriverId)
    (
        HACMOBJ                 hao,
        LPHACMDRIVERID          phadid,
        DWORD                   fdwDriverId
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverId = gpafnAcmFunctions[ACMTHUNK_DRIVERID];
    if (NULL == pfnAcmDriverId)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverId)(hao, phadid, fdwDriverId);

    return (mmr);
}

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverPriority
(
    HACMDRIVERID            hadid,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
)
{
    MMRESULT (ACMAPI *pfnAcmDriverPriority)
    (
        HACMDRIVERID            hadid,
        DWORD                   dwPriority,
        DWORD                   fdwPriority
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverPriority = gpafnAcmFunctions[ACMTHUNK_DRIVERPRIORITY];
    if (NULL == pfnAcmDriverPriority)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverPriority)(hadid, dwPriority, fdwPriority);

    return (mmr);
}


//==========================================================================;
//
//  Format Tag Information API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFormatTagDetails
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFormatTagDetails)
    (
        HACMDRIVER              had,
        LPACMFORMATTAGDETAILS   paftd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatTagDetails = gpafnAcmFunctions[ACMTHUNK_FORMATTAGDETAILS];
    if (NULL == pfnAcmFormatTagDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatTagDetails)(had, paftd, fdwDetails);

    return (mmr);
} // acmFormatTagDetails()

#ifdef _UNICODE
MMRESULT ACMAPI acmFormatTagDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFormatTagDetails)
    (
        HACMDRIVER              had,
        LPACMFORMATTAGDETAILSA  paftd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatTagDetails = gpafnAcmFunctions[ACMTHUNK_FORMATTAGDETAILSA];
    if (NULL == pfnAcmFormatTagDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatTagDetails)(had, paftd, fdwDetails);

    return (mmr);
} // acmFormatTagDetails()
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFormatTagEnum
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    ACMFORMATTAGENUMCB      fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFormatTagEnum)
    (
        HACMDRIVER              had,
        LPACMFORMATTAGDETAILS   paftd,
        ACMFORMATTAGENUMCB      fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatTagEnum = gpafnAcmFunctions[ACMTHUNK_FORMATTAGENUM];
    if (NULL == pfnAcmFormatTagEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatTagEnum)(had, paftd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
} // acmFormatTagEnum()

#ifdef _UNICODE
MMRESULT ACMAPI acmFormatTagEnumA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    ACMFORMATTAGENUMCBA     fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFormatTagEnum)
    (
        HACMDRIVER              had,
        LPACMFORMATTAGDETAILSA  paftd,
        ACMFORMATTAGENUMCBA     fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatTagEnum = gpafnAcmFunctions[ACMTHUNK_FORMATTAGENUMA];
    if (NULL == pfnAcmFormatTagEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatTagEnum)(had, paftd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
} // acmFormatTagEnum()
#endif

//==========================================================================;
//
//  Format Information API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFormatChoose
(
    LPACMFORMATCHOOSE       pafmtc
)
{
    MMRESULT (ACMAPI *pfnAcmFormatChoose)
    (
        LPACMFORMATCHOOSE       pafmtc
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatChoose = gpafnAcmFunctions[ACMTHUNK_FORMATCHOOSE];
    if (NULL == pfnAcmFormatChoose)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatChoose)(pafmtc);

    return (mmr);
}

#ifdef _UNICODE
MMRESULT ACMAPI acmFormatChooseA
(
    LPACMFORMATCHOOSEA      pafmtc
)
{
    MMRESULT (ACMAPI *pfnAcmFormatChoose)
    (
        LPACMFORMATCHOOSEA      pafmtc
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatChoose = gpafnAcmFunctions[ACMTHUNK_FORMATCHOOSEA];
    if (NULL == pfnAcmFormatChoose)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatChoose)(pafmtc);

    return (mmr);
}
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFormatDetails
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFormatDetails)
    (
        HACMDRIVER              had,
        LPACMFORMATDETAILS      pafd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatDetails = gpafnAcmFunctions[ACMTHUNK_FORMATDETAILS];
    if (NULL == pfnAcmFormatDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatDetails)(had, pafd, fdwDetails);

    return (mmr);
} // acmFormatDetails()

#ifdef _UNICODE
MMRESULT ACMAPI acmFormatDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFormatDetails)
    (
        HACMDRIVER              had,
        LPACMFORMATDETAILSA     pafd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatDetails = gpafnAcmFunctions[ACMTHUNK_FORMATDETAILSA];
    if (NULL == pfnAcmFormatDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatDetails)(had, pafd, fdwDetails);

    return (mmr);
} // acmFormatDetails()
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFormatEnum
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFormatEnum)
    (
        HACMDRIVER              had,
        LPACMFORMATDETAILS      pafd,
        ACMFORMATENUMCB         fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatEnum = gpafnAcmFunctions[ACMTHUNK_FORMATENUM];
    if (NULL == pfnAcmFormatEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatEnum)(had, pafd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
}

#ifdef _UNICODE
MMRESULT ACMAPI acmFormatEnumA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    ACMFORMATENUMCBA        fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFormatEnum)
    (
        HACMDRIVER              had,
        LPACMFORMATDETAILSA     pafd,
        ACMFORMATENUMCBA        fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatEnum = gpafnAcmFunctions[ACMTHUNK_FORMATENUMA];
    if (NULL == pfnAcmFormatEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatEnum)(had, pafd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
}
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFormatSuggest
(
    HACMDRIVER          had,
    LPWAVEFORMATEX      pwfxSrc,
    LPWAVEFORMATEX      pwfxDst,
    DWORD               cbwfxDst,
    DWORD               fdwSuggest
)
{
    MMRESULT (ACMAPI *pfnAcmFormatSuggest)
    (
        HACMDRIVER          had,
        LPWAVEFORMATEX      pwfxSrc,
        LPWAVEFORMATEX      pwfxDst,
        DWORD               cbwfxDst,
        DWORD               fdwSuggest
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatSuggest = gpafnAcmFunctions[ACMTHUNK_FORMATSUGGEST];
    if (NULL == pfnAcmFormatSuggest)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatSuggest)(had, pwfxSrc, pwfxDst, cbwfxDst, fdwSuggest);

    return (mmr);
}


//==========================================================================;
//
//  Filter Tag Information API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFilterTagDetails
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFilterTagDetails)
    (
        HACMDRIVER              had,
        LPACMFILTERTAGDETAILS   paftd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterTagDetails = gpafnAcmFunctions[ACMTHUNK_FILTERTAGDETAILS];
    if (NULL == pfnAcmFilterTagDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterTagDetails)(had, paftd, fdwDetails);

    return (mmr);
} // acmFilterTagDetails()

#ifdef _UNICODE
MMRESULT ACMAPI acmFilterTagDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFilterTagDetails)
    (
        HACMDRIVER              had,
        LPACMFILTERTAGDETAILSA  paftd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterTagDetails = gpafnAcmFunctions[ACMTHUNK_FILTERTAGDETAILSA];
    if (NULL == pfnAcmFilterTagDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterTagDetails)(had, paftd, fdwDetails);

    return (mmr);
} // acmFilterTagDetails()
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFilterTagEnum
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    ACMFILTERTAGENUMCB      fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFilterTagEnum)
    (
        HACMDRIVER              had,
        LPACMFILTERTAGDETAILS   paftd,
        ACMFILTERTAGENUMCB      fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterTagEnum = gpafnAcmFunctions[ACMTHUNK_FILTERTAGENUM];
    if (NULL == pfnAcmFilterTagEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterTagEnum)(had, paftd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
} // acmFilterTagEnum()

#ifdef _UNICODE
MMRESULT ACMAPI acmFilterTagEnumA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    ACMFILTERTAGENUMCBA     fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFilterTagEnum)
    (
        HACMDRIVER              had,
        LPACMFILTERTAGDETAILSA  paftd,
        ACMFILTERTAGENUMCBA     fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterTagEnum = gpafnAcmFunctions[ACMTHUNK_FILTERTAGENUMA];
    if (NULL == pfnAcmFilterTagEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterTagEnum)(had, paftd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
} // acmFilterTagEnum()
#endif

//==========================================================================;
//
//  Filter Information API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFilterChoose
(
    LPACMFILTERCHOOSE       pafltrc
)
{
    MMRESULT (ACMAPI *pfnAcmFilterChoose)
    (
        LPACMFILTERCHOOSE       pafltrc
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterChoose = gpafnAcmFunctions[ACMTHUNK_FILTERCHOOSE];
    if (NULL == pfnAcmFilterChoose)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterChoose)(pafltrc);

    return (mmr);
}

#ifdef _UNICODE
MMRESULT ACMAPI acmFilterChooseA
(
    LPACMFILTERCHOOSEA      pafltrc
)
{
    MMRESULT (ACMAPI *pfnAcmFilterChoose)
    (
        LPACMFILTERCHOOSEA      pafltrc
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterChoose = gpafnAcmFunctions[ACMTHUNK_FILTERCHOOSEA];
    if (NULL == pfnAcmFilterChoose)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterChoose)(pafltrc);

    return (mmr);
}
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFilterDetails
(
    HACMDRIVER              had,
    LPACMFILTERDETAILS      pafd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFilterDetails)
    (
        HACMDRIVER              had,
        LPACMFILTERDETAILS      pafd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterDetails = gpafnAcmFunctions[ACMTHUNK_FILTERDETAILS];
    if (NULL == pfnAcmFilterDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterDetails)(had, pafd, fdwDetails);

    return (mmr);
} // acmFilterDetails()

#ifdef _UNICODE
MMRESULT ACMAPI acmFilterDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFilterDetails)
    (
        HACMDRIVER              had,
        LPACMFILTERDETAILSA     pafd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterDetails = gpafnAcmFunctions[ACMTHUNK_FILTERDETAILSA];
    if (NULL == pfnAcmFilterDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterDetails)(had, pafd, fdwDetails);

    return (mmr);
} // acmFilterDetails()
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFilterEnum
(
    HACMDRIVER              had,
    LPACMFILTERDETAILS      pafd,
    ACMFILTERENUMCB         fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFilterEnum)
    (
        HACMDRIVER              had,
        LPACMFILTERDETAILS      pafd,
        ACMFILTERENUMCB         fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterEnum = gpafnAcmFunctions[ACMTHUNK_FILTERENUM];
    if (NULL == pfnAcmFilterEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterEnum)(had, pafd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
}

#ifdef _UNICODE
MMRESULT ACMAPI acmFilterEnumA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    ACMFILTERENUMCBA        fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFilterEnum)
    (
        HACMDRIVER              had,
        LPACMFILTERDETAILSA     pafd,
        ACMFILTERENUMCBA        fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterEnum = gpafnAcmFunctions[ACMTHUNK_FILTERENUMA];
    if (NULL == pfnAcmFilterEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterEnum)(had, pafd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
}
#endif

//==========================================================================;
//
//  ACM Stream Management API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamOpen
(
    LPHACMSTREAM            phas,
    HACMDRIVER              had,
    LPWAVEFORMATEX          pwfxSrc,
    LPWAVEFORMATEX          pwfxDst,
    LPWAVEFILTER            pwfltr,
    DWORD                   dwCallback,
    DWORD                   dwInstance,
    DWORD                   fdwOpen
)
{
    MMRESULT (ACMAPI *pfnAcmStreamOpen)
    (
        LPHACMSTREAM            phas,
        HACMDRIVER              had,
        LPWAVEFORMATEX          pwfxSrc,
        LPWAVEFORMATEX          pwfxDst,
        LPWAVEFILTER            pwfltr,
        DWORD                   dwCallback,
        DWORD                   dwInstance,
        DWORD                   fdwOpen
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamOpen = gpafnAcmFunctions[ACMTHUNK_STREAMOPEN];
    if (NULL == pfnAcmStreamOpen)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamOpen)(phas, had, pwfxSrc, pwfxDst, pwfltr, dwCallback, dwInstance, fdwOpen);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamClose
(
    HACMSTREAM              has,
    DWORD                   fdwClose
)
{
    MMRESULT (ACMAPI *pfnAcmStreamClose)
    (
        HACMSTREAM              has,
        DWORD                   fdwClose
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamClose = gpafnAcmFunctions[ACMTHUNK_STREAMCLOSE];
    if (NULL == pfnAcmStreamClose)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamClose)(has, fdwClose);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamSize
(
    HACMSTREAM              has,
    DWORD                   cbInput,
    LPDWORD                 pdwOutputBytes,
    DWORD                   fdwSize
)
{
    MMRESULT (ACMAPI *pfnAcmStreamSize)
    (
        HACMSTREAM              has,
        DWORD                   cbInput,
        LPDWORD                 pdwOutputBytes,
        DWORD                   fdwSize
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamSize = gpafnAcmFunctions[ACMTHUNK_STREAMSIZE];
    if (NULL == pfnAcmStreamSize)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamSize)(has, cbInput, pdwOutputBytes, fdwSize);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamConvert
(
    HACMSTREAM              has, 
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwConvert
)
{
    MMRESULT (ACMAPI *pfnAcmStreamConvert)
    (
        HACMSTREAM              has, 
        LPACMSTREAMHEADER       pash,
        DWORD                   fdwConvert
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamConvert = gpafnAcmFunctions[ACMTHUNK_STREAMCONVERT];
    if (NULL == pfnAcmStreamConvert)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamConvert)(has, pash, fdwConvert);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamReset
(
    HACMSTREAM              has, 
    DWORD                   fdwReset
)
{
    MMRESULT (ACMAPI *pfnAcmStreamReset)
    (
        HACMSTREAM              has, 
        DWORD                   fdwReset
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamReset = gpafnAcmFunctions[ACMTHUNK_STREAMRESET];
    if (NULL == pfnAcmStreamReset)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamReset)(has, fdwReset);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamPrepareHeader
(
    HACMSTREAM              has, 
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwPrepare
)
{
    MMRESULT (ACMAPI *pfnAcmStreamPrepareHeader)
    (
        HACMSTREAM              has, 
        LPACMSTREAMHEADER       pash,
        DWORD                   fdwPrepare
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamPrepareHeader = gpafnAcmFunctions[ACMTHUNK_STREAMPREPAREHEADER];
    if (NULL == pfnAcmStreamPrepareHeader)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamPrepareHeader)(has, pash, fdwPrepare);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamUnprepareHeader
(
    HACMSTREAM              has, 
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwUnprepare
)
{
    MMRESULT (ACMAPI *pfnAcmStreamUnprepareHeader)
    (
        HACMSTREAM              has, 
        LPACMSTREAMHEADER       pash,
        DWORD                   fdwUnprepare
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamUnprepareHeader = gpafnAcmFunctions[ACMTHUNK_STREAMUNPREPAREHEADER];
    if (NULL == pfnAcmStreamUnprepareHeader)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamUnprepareHeader)(has, pash, fdwUnprepare);

    return (mmr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\acm.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// acm.h - interface for acm functions in acm.c
////

#ifndef __ACM_H__
#define __ACM_H__

#include "winlocal.h"

#include "wavfmt.h"

#define ACM_VERSION 0x00000106

// <dwFlags> values in AcmInit
//
#define ACM_NOACM			0x00000001

// <dwFlags> values in AcmFormatChoose
//
#define ACM_FORMATPLAY		0x00001000
#define ACM_FORMATRECORD	0x00002000

// <dwFlags> values in AcmConvertInit
//
#define ACM_NONREALTIME		0x00000010
#define ACM_QUERY			0x00000020

// handle to acm engine returned from AcmInit
//
DECLARE_HANDLE32(HACM);

// handle to acm driver returned from AcmDriverLoad
//
DECLARE_HANDLE32(HACMDRV);

#ifdef __cplusplus
extern "C" {
#endif

// AcmInit - initialize audio compression manager engine
//		<dwVersion>			(i) must be ACM_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
#ifdef AVPCM
//			ACM_NOACM			use internal pcm engine rather than acm
#endif
// return handle (NULL if error)
//
HACM DLLEXPORT WINAPI AcmInit(DWORD dwVersion, HINSTANCE hInst,	DWORD dwFlags);

// AcmTerm - shut down audio compression manager engine
//		<hAcm>				(i) handle returned from AcmInit
// return 0 if success
//
int DLLEXPORT WINAPI AcmTerm(HACM hAcm);

// AcmFormatGetSizeMax - get size of largest acm WAVEFORMATEX struct
//		<hAcm>				(i) handle returned from AcmInit
//
// return size of largest format struct, -1 if error
//
int DLLEXPORT WINAPI AcmFormatGetSizeMax(HACM hAcm);

// AcmFormatChoose - choose audio format from dialog box
//		<hAcm>				(i) handle returned from AcmInit
//		<hwndOwner>			(i) owner of dialog box
//			NULL				no owner
//		<lpszTitle>			(i) title of the dialog box
//			NULL				use default title ("Sound Selection")
//		<lpwfx>				(i) initialize dialog with this format
//			NULL				no initial format
//		<dwFlags>			(i)	control flags
//			ACM_FORMATPLAY		restrict choices to playback formats
//			ACM_FORMATRECORD	restrict choices to recording formats
// return pointer to chosen format, NULL if error or none chosen
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
#define AcmFormatChoose(hAcm, hwndOwner, lpszTitle, lpwfx, dwFlags) \
	AcmFormatChooseEx(hAcm, hwndOwner, lpszTitle, lpwfx, dwFlags)
LPWAVEFORMATEX DLLEXPORT WINAPI AcmFormatChooseEx(HACM hAcm,
	HWND hwndOwner, LPCTSTR lpszTitle, LPWAVEFORMATEX lpwfx, DWORD dwFlags);

// AcmFormatSuggest - suggest a new format
//		<hAcm>				(i) handle returned from AcmInit
//		<lpwfxSrc>			(i) source format
//		<nFormatTag>		(i) suggested format must match this format tag
//			-1					suggestion need not match
//		<nSamplesPerSec>	(i) suggested format must match this sample rate
//			-1					suggestion need not match
//		<nBitsPerSample>	(i) suggested format must match this sample size
//			-1					suggestion need not match
//		<nChannels>			(i) suggested format must match this channels
//			-1					suggestion need not match
//		<dwFlags>			(i)	control flags
//			0					reserved; must be zero
// return pointer to suggested format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
#define AcmFormatSuggest(hAcm, lpwfxSrc, nFormatTag, nSamplesPerSec, \
	nBitsPerSample, nChannels, dwFlags) \
	AcmFormatSuggestEx(hAcm, lpwfxSrc, nFormatTag, nSamplesPerSec, \
	nBitsPerSample, nChannels, dwFlags)
LPWAVEFORMATEX DLLEXPORT WINAPI AcmFormatSuggestEx(HACM hAcm,
	LPWAVEFORMATEX lpwfxSrc, long nFormatTag, long nSamplesPerSec,
	int nBitsPerSample, int nChannels, DWORD dwFlags);

// AcmFormatGetText - get text describing the specified format
//		<hAcm>				(i) handle returned from AcmInit
//		<lpwfx>				(i) format
//		<lpszText>			(o) buffer to hold text
//		<sizText>			(i) size of buffer, in characters
//		<dwFlags>			(i)	control flags
//			0					reserved; must be zero
// return 0 if success
//
int DLLEXPORT WINAPI AcmFormatGetText(HACM hAcm, LPWAVEFORMATEX lpwfx,
	LPTSTR lpszText, int sizText, DWORD dwFlags);

// AcmConvertInit - initialize acm conversion engine
//		<hAcm>				(i) handle returned from AcmInit
//		<lpwfxSrc>			(i) pointer to source WAVEFORMATEX struct
//		<lpwfxDst>			(i) pointer to destination WAVEFORMATEX struct
//		<lpwfltr>			(i) pointer to WAVEFILTER struct
//			NULL				reserved; must be NULL
//		<dwFlags>			(i) control flags
//			ACM_NONREALTIME		realtime conversion conversion not required
//			ACM_QUERY			return 0 if conversion would be supported
// return 0 if success
//
int DLLEXPORT WINAPI AcmConvertInit(HACM hAcm, LPWAVEFORMATEX lpwfxSrc,
	LPWAVEFORMATEX lpwfxDst, LPWAVEFILTER lpwfltr, DWORD dwFlags);

// AcmConvertTerm - shut down acm conversion engine
//		<hAcm>				(i) handle returned from AcmInit
// return 0 if success
//
int DLLEXPORT WINAPI AcmConvertTerm(HACM hAcm);

// AcmConvertGetSizeSrc - calculate source buffer size
//		<hAcm>				(i) handle returned from AcmInit
//		<sizBufDst>			(i) size of destination buffer in bytes
// return source buffer size, -1 if error
//
long DLLEXPORT WINAPI AcmConvertGetSizeSrc(HACM hAcm, long sizBufDst);

// AcmConvertGetSizeDst - calculate destination buffer size
//		<hAcm>				(i) handle returned from AcmInit
//		<sizBufSrc>			(i) size of source buffer in bytes
// return destination buffer size, -1 if error
//
long DLLEXPORT WINAPI AcmConvertGetSizeDst(HACM hAcm, long sizBufSrc);

// AcmConvert - convert wav data from one format to another
//		<hAcm>				(i) handle returned from AcmInit
//		<hpBufSrc> 			(i) buffer containing bytes to reformat
//		<sizBufSrc>			(i) size of buffer in bytes
//		<hpBufDst> 			(o) buffer to contain new format
//		<sizBufDst>			(i) size of buffer in bytes
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return count of bytes in destination buffer (-1 if error)
//
// NOTE: the destination buffer must be large enough to hold the result
//
long DLLEXPORT WINAPI AcmConvert(HACM hAcm,
	void _huge *hpBufSrc, long sizBufSrc,
	void _huge *hpBufDst, long sizBufDst,
	DWORD dwFlags);

// AcmDriverLoad - load an acm driver for use by this process
//		<hAcm>				(i) handle returned from AcmInit
//		<wMid>				(i) manufacturer id
//		<wPid>				(i) product id
//		<lpszDriver>		(i) name of driver module
//		<lpszDriverProc>	(i) name of driver proc function
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return handle (NULL if error)
//
HACMDRV DLLEXPORT WINAPI AcmDriverLoad(HACM hAcm, WORD wMid, WORD wPid,
	LPTSTR lpszDriver, LPSTR lpszDriverProc, DWORD dwFlags);

// AcmDriverUnload - unload an acm driver
//		<hAcm>				(i) handle returned from AcmInit
//		<hAcmDrv>			(i) handle returned from AcmDriverLoad
// return 0 if success
//
int DLLEXPORT WINAPI AcmDriverUnload(HACM hAcm, HACMDRV hAcmDrv);

#ifdef __cplusplus
}
#endif

#endif // __ACM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\threadrend.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////
// ThreadRend.cpp
//

#include "stdafx.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "ConfExp.h"
#include "CETreeView.h"
#include "CEDetailsVw.h"
#include "ThreadRend.h"
#include "ThreadPub.h"

#define REND_SLEEP_NORMAL    2000
#define REND_SLEEP_FAST        1

static bool            UpdateRendevousInfo( ITRendezvous *pRend );
static HRESULT        GetConferencesAndPersons( ITRendezvous *pRend, BSTR bstrServer, CONFDETAILSLIST& lstConfs, PERSONDETAILSLIST& lstPersons );

/////////////////////////////////////////////////////////////////////////////
// Background thread for enumerating conferences
//

DWORD WINAPI ThreadRendezvousProc( LPVOID lpInfo )
{
    USES_CONVERSION;
    HANDLE hThread = NULL;
    BOOL bDup = DuplicateHandle( GetCurrentProcess(),
                                 GetCurrentThread(),
                                 GetCurrentProcess(),
                                 &hThread,
                                 THREAD_ALL_ACCESS,
                                 TRUE,
                                 0 );


    //
    // We have to verify bDup
    //

    if( !bDup )
    {
        return 0;
    }

    _Module.AddThread( hThread );

    // Error info information
    CErrorInfo er;
    er.set_Operation( IDS_ER_PLACECALL );
    er.set_Details( IDS_ER_COINITIALIZE );
    HRESULT hr = er.set_hr( CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY) );
    if ( SUCCEEDED(hr) )
    {
        ATLTRACE(_T(".1.ThreadRendezvousProc() -- thread up and running.\n") );
        ITRendezvous *pRend;
        HRESULT hr = CoCreateInstance( CLSID_Rendezvous,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_ITRendezvous,
                                       (void **) &pRend );
        if ( SUCCEEDED(hr) )
        {
            DWORD dwSleep = REND_SLEEP_FAST;
            bool bContinue = true;
            bool bStartEnum = false;

            while ( bContinue )
            {
                switch ( WaitForSingleObject(_Module.m_hEventThreadWakeUp, dwSleep) )
                {
                    // Event Wake up! -- thread should exit
                    case WAIT_OBJECT_0:
                            bContinue = false;
                            break;

                    case WAIT_TIMEOUT:
                        // Go out and see if there's any new rendezvous stuff to check up on
                        if ( UpdateRendevousInfo(pRend) )
                        {
                            bStartEnum = true;
                            dwSleep = REND_SLEEP_FAST;
                        }
                        else if ( bStartEnum )
                        {
                            dwSleep = REND_SLEEP_NORMAL;
                        }
                        break;

                    // WaitForMultiples went "KOOK-KOO" time to bail
                    default:
                        bContinue = false;
                        break;
                }
            }

            pRend->Release();
        }

        // Clean-up
        CoUninitialize();
    }

    // Notify module of shutdown
    _Module.RemoveThread( hThread );
    SetEvent( _Module.m_hEventThread );

    ATLTRACE(_T(".exit.ThreadRendezvousProc(0x%08lx).\n"), hr );
    return hr;
}


bool UpdateRendevousInfo( ITRendezvous *pRend )
{
    bool bRet = false;

    // Update rendevous info
    CComPtr<IAVTapi> pAVTapi;
    if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
    {
        IConfExplorer *pIConfExplorer;
        if ( SUCCEEDED(pAVTapi->get_ConfExplorer(&pIConfExplorer)) )
        {
            IConfExplorerTreeView *pITreeView;
            if ( SUCCEEDED(pIConfExplorer->get_TreeView(&pITreeView)) )
            {
                BSTR bstrServer = NULL;
                
                if ( SUCCEEDED(pITreeView->GetConfServerForEnum(&bstrServer)) )
                {
                    // Enumerate confs
                    CONFDETAILSLIST lstConfs;
                    PERSONDETAILSLIST lstPersons;
                    DWORD dwTickCount = GetTickCount();
                    HRESULT hr = GetConferencesAndPersons( pRend, bstrServer, lstConfs, lstPersons );

                    // Store information with address
                    if ( SUCCEEDED(hr) )
                    {
                        pITreeView->SetConfServerForEnum( bstrServer, (long *) &lstConfs, (long *) &lstPersons, dwTickCount, TRUE );

                        //
                        // Deallocate just if is something there
                        //

                        DELETE_LIST( lstConfs );
                        DELETE_LIST( lstPersons );
                    }
                    else
                        pITreeView->SetConfServerForEnum( bstrServer, NULL, NULL, dwTickCount, TRUE );

                    // Clean up
                    SysFreeString( bstrServer );
                    bRet = true;
                }
                pITreeView->Release();
            }
            pIConfExplorer->Release();
        }
    }

    return bRet;
}

HRESULT GetConferencesAndPersons( ITRendezvous *pRend, BSTR bstrServer, CONFDETAILSLIST& lstConfs, PERSONDETAILSLIST& lstPersons )
{
    USES_CONVERSION;
    HRESULT hr;
    ITDirectory *pDir;

    if ( SUCCEEDED(hr = CConfExplorer::GetDirectory(pRend, bstrServer, &pDir)) )
    {
        // Enumerate through people, adding them as we go along
        IEnumDirectoryObject *pEnum;
        if ( SUCCEEDED(hr = pDir->EnumerateDirectoryObjects(OT_USER, A2BSTR("*"), &pEnum)) )
        {
            long nCount = 0;
            ITDirectoryObject *pITDirObject;
            while ( (nCount++ < MAX_ENUMLISTSIZE) && ((hr = pEnum->Next(1, &pITDirObject, NULL)) == S_OK) )
            {
                _ASSERT( pITDirObject );
                CConfExplorerDetailsView::AddListItemPerson( bstrServer, pITDirObject, lstPersons );
                pITDirObject->Release();
            }

            pEnum->Release();
        }

        // Enumerate through conferences adding them as we go along
        if ( SUCCEEDED(hr = pDir->EnumerateDirectoryObjects(OT_CONFERENCE, A2BSTR("*"), &pEnum)) )
        {
            long nCount = 0;
            ITDirectoryObject *pITDirObject;
            while ( (nCount++ < MAX_ENUMLISTSIZE) && ((hr = pEnum->Next(1, &pITDirObject, NULL)) == S_OK) )
            {
                _ASSERT( pITDirObject );
                CConfExplorerDetailsView::AddListItem( bstrServer, pITDirObject, lstConfs );
                pITDirObject->Release();
            }

            pEnum->Release();
        }

        pDir->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\videofeed.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// VideoFeed.cpp : Implementation of CVideoFeed
#include "stdafx.h"
#include "TapiDialer.h"
#include "ConfRoom.h"
#include "VideoFeed.h"
#include "Particip.h"
#include "strmif.h"


// Assorted helper functions

void GetParticipantInfoHelper( ITParticipant *pParticipant, PARTICIPANT_TYPED_INFO nType, CComBSTR &bstrInfo )
{
    BSTR bstrTemp = NULL;
    pParticipant->get_ParticipantTypedInfo( nType, &bstrTemp );
    if ( bstrTemp && SysStringLen(bstrTemp) )
    {
        if ( bstrInfo.Length() )
            bstrInfo.Append( L"\n" );

        bstrInfo.Append( bstrTemp );
    }

    SysFreeString( bstrTemp );
}


void GetParticipantInfo( ITParticipant *pParticipant, BSTR *pbstrInfo )
{
    //_ASSERT( pParticipant && pbstrInfo );
    //
    // We have to verify the pbstrInfo is a valid pointer
    //

    if( NULL == pbstrInfo )
    {
        return;
    }

    CComBSTR bstrInfo;
    GetParticipantInfoHelper( pParticipant, PTI_CANONICALNAME, bstrInfo );
    GetParticipantInfoHelper( pParticipant, PTI_EMAILADDRESS, bstrInfo );
    GetParticipantInfoHelper( pParticipant, PTI_PHONENUMBER, bstrInfo );
    GetParticipantInfoHelper( pParticipant, PTI_LOCATION, bstrInfo );
    GetParticipantInfoHelper( pParticipant, PTI_TOOL, bstrInfo );
    GetParticipantInfoHelper( pParticipant, PTI_NOTES, bstrInfo );

    *pbstrInfo = SysAllocString( bstrInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CVideoFeed

CVideoFeed::CVideoFeed()
{
    SetRectEmpty(&m_rc);
    m_pVideo = NULL;
    m_bPreview = false;
    m_bRequestQOS = false;
    m_bstrName = NULL;
    m_pITParticipant = NULL;

    // Default name for video
    GetNameFromVideo( NULL, &m_bstrName, NULL, false, false );
}

void CVideoFeed::FinalRelease()
{
    ATLTRACE(_T(".enter.CVideoFeed::FinalRelease().\n") );
    SysFreeString( m_bstrName );

#ifdef _DEBUG
    if ( m_pVideo )
    {
        m_pVideo->AddRef();
        ATLTRACE(_T("\tm_pVideo ref count @ %ld.\n"), m_pVideo->Release() );
    }

    if ( m_pITParticipant )
    {
        m_pITParticipant->AddRef();
        ATLTRACE(_T("\tm_pITParticipant ref count @ %ld.\n"), m_pITParticipant->Release() );
    }
#endif

    RELEASE( m_pVideo );
    RELEASE( m_pITParticipant );
}

STDMETHODIMP CVideoFeed::get_bstrName(BSTR *ppVal)
{
    HRESULT hr;

    Lock();
    if ( m_bPreview )
        hr = GetNameFromVideo( NULL, ppVal, NULL, false, true );
    else
        hr = SysReAllocString( ppVal, m_bstrName );
    Unlock();

    return hr;
}

STDMETHODIMP CVideoFeed::UpdateName()
{
    Lock();
    // Clean up first 
    SysFreeString( m_bstrName );
    m_bstrName = NULL;

    // Retrieve appropriate information
    HRESULT hr = GetNameFromVideo( m_pVideo, &m_bstrName, NULL, false, (bool) (m_bPreview != 0) );
    Unlock();

    return hr;
}


STDMETHODIMP CVideoFeed::get_IVideoWindow(IUnknown **ppVal)
{
    HRESULT hr = E_FAIL;
    Lock();
    if ( m_pVideo )
    {
        hr = m_pVideo->QueryInterface( IID_IVideoWindow, (void **) ppVal );
    }
    Unlock();

    return hr;
}

STDMETHODIMP CVideoFeed::put_IVideoWindow(IUnknown * newVal)
{
    HRESULT hr = S_OK;

    Lock();
    RELEASE( m_pVideo );
    if ( newVal )
        hr = newVal->QueryInterface( IID_IVideoWindow, (void **) &m_pVideo );
    Unlock();

    return hr;
}

STDMETHODIMP CVideoFeed::Paint(ULONG_PTR hDC, HWND hWndSource)
{
    Lock();
    _ASSERT( m_pVideo && hDC );

    // Verify we have a video feed
    if ( !m_pVideo )
    {
        Unlock();
        return E_PENDING;
    }
    Unlock();

    // Verify that the window and DC are ok
    if ( !hDC || !IsWindow((HWND) hWndSource) )    return E_INVALIDARG;

    HRESULT hr;
    IDrawVideoImage *pDraw;
    if ( SUCCEEDED(hr = m_pVideo->QueryInterface(IID_IDrawVideoImage, (void **) &pDraw)) )
    {
        RECT rc;
        get_rc( &rc );

        SetStretchBltMode((HDC) hDC, COLORONCOLOR);
        pDraw->DrawVideoImageDraw( (HDC) hDC, NULL, &rc );
        pDraw->Release();

        // Draw border around feed
        InflateRect( &rc, SEL_DX, SEL_DY );
        rc.right++;
        Draw3dBox( (HDC) hDC, rc, false );
    }

    return hr;
}

HRESULT CVideoFeed::GetNameFromParticipant(ITParticipant *pParticipant, BSTR * pbstrName, BSTR *pbstrInfo )
{
    _ASSERT( pbstrName );
    *pbstrName = NULL;
    if ( pbstrInfo ) *pbstrInfo = NULL;

    // Grab name from participant info
    if ( pParticipant )
    {
        pParticipant->get_ParticipantTypedInfo( PTI_NAME, pbstrName );

        // Fetch all other participant information
        if ( pbstrInfo )
            GetParticipantInfo( pParticipant, pbstrInfo );
    }

    return S_OK;
}


STDMETHODIMP CVideoFeed::GetNameFromVideo(IUnknown * pVideo, BSTR * pbstrName, BSTR * pbstrInfo, VARIANT_BOOL bAllowNull, VARIANT_BOOL bPreview)
{
    _ASSERT( pbstrName );

    UINT nIDSParticipant = IDS_PARTICIPANT;
    *pbstrName = NULL;
    if ( pbstrInfo ) *pbstrInfo = NULL;

    // Grab name from participant info
    if ( !bPreview && pVideo )
    {
        nIDSParticipant = IDS_NO_PARTICIPANT;

        ITTerminal *pITTerminal;
        if ( SUCCEEDED(pVideo->QueryInterface(IID_ITTerminal, (void **) &pITTerminal)) )
        {
            // Is this terminal showing preview video?
            TERMINAL_DIRECTION nDir;
            pITTerminal->get_Direction( &nDir );
            if ( nDir == TD_CAPTURE )
            {
                bPreview = true;
            }
            else
            {
                bPreview = false;
                ITParticipant *pParticipant;
                if ( SUCCEEDED(get_ITParticipant(&pParticipant)) )
                {
                    GetNameFromParticipant( pParticipant, pbstrName, pbstrInfo );
                    pParticipant->Release();
                }
            }
            pITTerminal->Release();
        }
    }

    // Use stock name from resources
    if ( ((!bAllowNull || bPreview) && (*pbstrName == NULL)) || (*pbstrName && !SysStringLen(*pbstrName)) )
    {
        USES_CONVERSION;
        TCHAR szText[255];
        UINT nIDS = (bPreview) ? IDS_VIDEOPREVIEW : nIDSParticipant;

        LoadString( _Module.GetResourceInstance(), nIDS, szText, ARRAYSIZE(szText) );
        SysReAllocString( pbstrName, T2COLE(szText) );
    }

    return S_OK;
}


STDMETHODIMP CVideoFeed::get_rc(RECT * pVal)
{
    Lock();
    *pVal = m_rc;
    Unlock();
    return S_OK;
}

STDMETHODIMP CVideoFeed::put_rc(RECT newVal)
{
    Lock();
    m_rc = newVal;
    Unlock();
    return S_OK;
}

STDMETHODIMP CVideoFeed::put_ITParticipant(ITParticipant *newVal)
{
    HRESULT hr = S_OK;

    Lock();
    RELEASE( m_pITParticipant );
    if ( newVal )
        hr = newVal->QueryInterface( IID_ITParticipant, (void **) &m_pITParticipant );
    Unlock();

    return hr;
}

STDMETHODIMP CVideoFeed::get_ITParticipant(ITParticipant **ppVal)
{
    HRESULT hr = E_FAIL;
    Lock();
    if ( m_pITParticipant )
        hr = m_pITParticipant->QueryInterface( IID_ITParticipant, (void **) ppVal );
    Unlock();

    return hr;
}

STDMETHODIMP CVideoFeed::get_bPreview(VARIANT_BOOL * pVal)
{
    Lock();
    *pVal = m_bPreview;
    Unlock();

    return S_OK;
}

STDMETHODIMP CVideoFeed::put_bPreview(VARIANT_BOOL newVal)
{
    ATLTRACE(_T(".enter.CVideoFeed::put_bPreview(%p, %d).\n"), this, newVal );
    Lock();
    m_bPreview = newVal;
    Unlock();

    return S_OK;
}


STDMETHODIMP CVideoFeed::get_bRequestQOS(VARIANT_BOOL * pVal)
{
    Lock();
    *pVal = m_bRequestQOS;
    Unlock();

    return S_OK;
}

STDMETHODIMP CVideoFeed::put_bRequestQOS(VARIANT_BOOL newVal)
{
    Lock();
    m_bRequestQOS = newVal;
    Unlock();

    // Set the color of the video window's border to match the state of the video feed
    IVideoWindow *pVideo;
    if ( SUCCEEDED(get_IVideoWindow((IUnknown **) &pVideo)) )
    {
        pVideo->put_BorderColor( GetSysColor((newVal) ? COLOR_HIGHLIGHT : COLOR_WINDOWFRAME) );
        pVideo->Release();
    }

    return S_OK;
}

STDMETHODIMP CVideoFeed::IsVideoStreaming( VARIANT_BOOL bIncludePreview )
{
    Lock();
    HRESULT hr = ((bIncludePreview && m_bPreview) || (m_pITParticipant != NULL)) ? S_OK : S_FALSE;
    Unlock();

    return hr;
}


STDMETHODIMP CVideoFeed::get_ITSubStream(ITSubStream **ppVal)
{
    HRESULT hr = E_FAIL;

    ITParticipant *pParticipant;
    if ( SUCCEEDED(hr = get_ITParticipant(&pParticipant)) )
    {
        IEnumStream *pEnum;
        if ( SUCCEEDED(hr = pParticipant->EnumerateStreams(&pEnum)) )
        {
            ITStream *pStream;
            while ( (hr = pEnum->Next(1, &pStream, NULL)) == S_OK )
            {
                long nMediaType;
                TERMINAL_DIRECTION nDir;

                pStream->get_MediaType( &nMediaType );
                if ( nMediaType == TAPIMEDIATYPE_VIDEO )
                {
                    pStream->get_Direction( &nDir );
                    if ( nDir == TD_RENDER )
                    {
                        // This stream is going the right direction
                        ITParticipantSubStreamControl *pControl;
                        if ( SUCCEEDED(hr = pStream->QueryInterface(IID_ITParticipantSubStreamControl, (void **) &pControl)) )
                        {
                            hr = pControl->get_SubStreamFromParticipant( pParticipant, ppVal );
                            pControl->Release();
                        }
                    }
                }
                pStream->Release();
            }
            
            pEnum->Release();
        }
        pParticipant->Release();
    }

    return S_OK;
}

STDMETHODIMP CVideoFeed::MapToParticipant(ITParticipant * pNewParticipant)
{
    bool bContinue = true;
    HRESULT hr = E_FAIL;

    ITStream *pStream;
    if ( SUCCEEDED(StreamFromParticipant(pNewParticipant, TAPIMEDIATYPE_VIDEO, TD_RENDER, &pStream)) )
    {
        // This stream is going the right direction
        ITParticipantSubStreamControl *pControl;
        if ( SUCCEEDED(hr = pStream->QueryInterface(IID_ITParticipantSubStreamControl, (void **) &pControl)) )
        {
            ITSubStream *pSubStream;
            if ( SUCCEEDED(hr = pControl->get_SubStreamFromParticipant(pNewParticipant, &pSubStream)) )
            {
                IVideoWindow *pVideo;
                if ( SUCCEEDED(hr = get_IVideoWindow((IUnknown **) &pVideo)) )
                {
                    ITTerminal *pTerminal;
                    if ( SUCCEEDED(hr = pVideo->QueryInterface(IID_ITTerminal, (void **) &pTerminal)) )
                    {
                        hr = pControl->SwitchTerminalToSubStream( pTerminal, pSubStream );
                        if ( SUCCEEDED(hr) )
                            put_ITParticipant( pNewParticipant );

                        pTerminal->Release();
                    }
                    pVideo->Release();
                }

                bContinue = false;
                pSubStream->Release();
            }
            pControl->Release();
        }
        pStream->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\acm.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	acm.c - audio compression manager functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "acm.h"
#include <msacm.h>

#include "loadlib.h"

// On some Win31 and WinNT systems,	the audio compresion manager
// is not installed.  Therefore, we use a thunking layer to more
// gracefully handle this situation.  See acmthunk.c for details
//
#ifdef ACMTHUNK
#include "acmthunk.h"
#endif

#ifdef AVPCM
#include "pcm.h"
#endif
#include "mem.h"
#include "str.h"
#include "trace.h"

////
//	private definitions
////

// acm control struct
//
typedef struct ACM
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	DWORD dwFlags;
	UINT nLastError;
#ifdef AVPCM
	HPCM hPcm;
#endif
	LPWAVEFORMATEX lpwfxSrc;
	LPWAVEFORMATEX lpwfxInterm1;
	LPWAVEFORMATEX lpwfxInterm2;
	LPWAVEFORMATEX lpwfxDst;
	HACMSTREAM hAcmStream1;
	HACMSTREAM hAcmStream2;
	HACMSTREAM hAcmStream3;
#ifdef ACMTHUNK
	BOOL fAcmThunkInitialized;
#endif
} ACM, FAR *LPACM;

// acm driver control struct
//
typedef struct ACMDRV
{
	HACM hAcm;
	HINSTANCE hInstLib;
	HACMDRIVERID hadid;
	WORD wMid;
	WORD wPid;
	UINT nLastError;
	DWORD dwFlags;
} ACMDRV, FAR *LPACMDRV;

// <dwFlags> values in ACMDRV
//
#define ACMDRV_REMOVEDRIVER		0x00001000

#ifdef _WIN32
#define ACM_VERSION_MIN			0x03320000
#else
#define ACM_VERSION_MIN			0x02000000
#endif

// <dwFlags> values in AcmStreamSize
//
#define ACM_SOURCE				0x00010000
#define ACM_DESTINATION			0x00020000

// helper functions
//
static LPACM AcmGetPtr(HACM hAcm);
static HACM AcmGetHandle(LPACM lpAcm);
static LPACMDRV AcmDrvGetPtr(HACMDRV hAcmDrv);
static HACMDRV AcmDrvGetHandle(LPACMDRV lpAcmDrv);
static HACMSTREAM WINAPI AcmStreamOpen(HACM hAcm, LPWAVEFORMATEX lpwfxSrc,
	LPWAVEFORMATEX lpwfxDst, LPWAVEFILTER lpwfltr, DWORD dwFlags);
static int WINAPI AcmStreamClose(HACM hAcm, HACMSTREAM hAcmStream);
static long WINAPI AcmStreamSize(HACM hAcm, HACMSTREAM hAcmStream, long sizBuf, DWORD dwFlags);
static long WINAPI AcmStreamConvert(HACM hAcm, HACMSTREAM hAcmStream,
	void _huge *hpBufSrc, long sizBufSrc,
	void _huge *hpBufDst, long sizBufDst,
	DWORD dwFlags);
BOOL CALLBACK AcmDriverLoadEnumCallback(HACMDRIVERID hadid,
	DWORD dwInstance, DWORD fdwSupport);

////
//	public functions
////

// AcmInit - initialize audio compression manager engine
//		<dwVersion>			(i) must be ACM_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
#ifdef AVPCM
//			ACM_NOACM			use internal pcm engine rather than acm
#endif
// return handle (NULL if error)
//
HACM DLLEXPORT WINAPI AcmInit(DWORD dwVersion, HINSTANCE hInst,	DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm = NULL;

#ifndef AVPCM
	// turn off ACM_NOACM flag if not allowed
	//
	dwFlags &= ~ACM_NOACM;
#endif

	if (dwVersion != ACM_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpAcm = (LPACM) MemAlloc(NULL, sizeof(ACM), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpAcm->dwVersion = dwVersion;
		lpAcm->hInst = hInst;
		lpAcm->hTask = GetCurrentTask();
		lpAcm->dwFlags = dwFlags;
		lpAcm->nLastError = 0;
#ifdef AVPCM
		lpAcm->hPcm = NULL;
#endif
		lpAcm->lpwfxSrc = NULL;
		lpAcm->lpwfxInterm1 = NULL;
		lpAcm->lpwfxInterm2 = NULL;
		lpAcm->lpwfxDst = NULL;
		lpAcm->hAcmStream1 = NULL;
		lpAcm->hAcmStream2 = NULL;
		lpAcm->hAcmStream3 = NULL;
#ifdef ACMTHUNK
		lpAcm->fAcmThunkInitialized = FALSE;

		if (!(lpAcm->dwFlags & ACM_NOACM))
		{
			// initialize acm thunking layer
			//
			if (!acmThunkInitialize())
			{
#ifdef AVPCM
				fSuccess = TraceFALSE(NULL);
#else
				// NOTE: this is not considered an error
				//
				fSuccess = TraceTRUE(NULL);

				// failure means we cannot call any acm functions
				//
				lpAcm->dwFlags |= ACM_NOACM;
#endif
			}
			else
			{
				// remember so we can shut down later
				//
				lpAcm->fAcmThunkInitialized = TRUE;
			}
		}
#endif

#if 0 // for testing
		lpAcm->dwFlags |= ACM_NOACM;
#endif
		if (!(lpAcm->dwFlags & ACM_NOACM))
		{
			// verify minimum acm version
			//
			if (acmGetVersion() < ACM_VERSION_MIN)
				fSuccess = TraceFALSE(NULL);
		}
#ifdef AVPCM
		else if (lpAcm->dwFlags & ACM_NOACM)
		{
			// initialize PCM engine
			//
			if ((lpAcm->hPcm = PcmInit(PCM_VERSION, hInst, 0)) == NULL)
				fSuccess = TraceFALSE(NULL);
		}
#endif
	}

	if (!fSuccess || (dwFlags & ACM_QUERY))
	{
		if (lpAcm != NULL && AcmTerm(AcmGetHandle(lpAcm)) != 0)
			fSuccess = TraceFALSE(NULL);
		else
			lpAcm = NULL;
	}

	return fSuccess ? AcmGetHandle(lpAcm) : NULL;
}

// AcmTerm - shut down audio compression manager engine
//		<hAcm>				(i) handle returned from AcmInit
// return 0 if success
//
int DLLEXPORT WINAPI AcmTerm(HACM hAcm)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (AcmConvertTerm(hAcm) != 0)
		fSuccess = TraceFALSE(NULL);

// $FIXUP - call to acmThunkTerminate is disabled so that AcmInit/AcmTerm
// can be called mutltiple times.  This means the array of acm function
// pointers is not freed and FreeLibrary is not called on msacm.dll
//
#if 0
#ifdef ACMTHUNK
	// shut down acm thunking layer
	//
	else if (lpAcm->fAcmThunkInitialized && !acmThunkTerminate())
		fSuccess = TraceFALSE(NULL);

	else if (lpAcm->fAcmThunkInitialized = FALSE, FALSE)
		;
#endif
#endif

#ifdef AVPCM
	// shut down pcm engine
	//
	else if (lpAcm->hPcm != NULL && PcmTerm(lpAcm->hPcm) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (lpAcm->hPcm = NULL, FALSE)
		;
#endif
	else if ((lpAcm = MemFree(NULL, lpAcm)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// AcmFormatGetSizeMax - get size of largest acm WAVEFORMATEX struct
//		<hAcm>				(i) handle returned from AcmInit
//
// return size of largest format struct, -1 if error
//
int DLLEXPORT WINAPI AcmFormatGetSizeMax(HACM hAcm)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm = NULL;
	DWORD dwSizeMax = 0;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);
#ifdef AVPCM
	else if (lpAcm->dwFlags & ACM_NOACM)
		dwSizeMax = sizeof(WAVEFORMATEX);
#endif
	// query largest format size
	//
	else if ((lpAcm->nLastError = acmMetrics(NULL,
		ACM_METRIC_MAX_SIZE_FORMAT, (LPVOID) &dwSizeMax)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("acmMetrics failed (%u)\n"),
			(unsigned) lpAcm->nLastError);
	}

	return fSuccess ? (int) dwSizeMax : -1;
}

// AcmFormatChoose - choose audio format from dialog box
//		<hAcm>				(i) handle returned from AcmInit
//		<hwndOwner>			(i) owner of dialog box
//			NULL				no owner
//		<lpszTitle>			(i) title of the dialog box
//			NULL				use default title ("Sound Selection")
//		<lpwfx>				(i) initialize dialog with this format
//			NULL				no initial format
//		<dwFlags>			(i)	control flags
//			ACM_FORMATPLAY		restrict choices to playback formats
//			ACM_FORMATRECORD	restrict choices to recording formats
// return pointer to chosen format, NULL if error or none chosen
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI AcmFormatChooseEx(HACM hAcm,
	HWND hwndOwner, LPCTSTR lpszTitle, LPWAVEFORMATEX lpwfx, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;
	ACMFORMATCHOOSE afc;
	int nFormatSize = 0;
	int nFormatSizeMax;
	LPWAVEFORMATEX lpwfxNew = NULL;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure current format is valid
	//
	else if (lpwfx != NULL && !WavFormatIsValid(lpwfx))
		fSuccess = TraceFALSE(NULL);

	// calc how big is the initial format struct
	//
	else if (lpwfx != NULL && (nFormatSize = WavFormatGetSize(lpwfx)) <= 0)
		fSuccess = TraceFALSE(NULL);

	// calc how big is the largest format struct in the acm
	//
	else if ((nFormatSizeMax = AcmFormatGetSizeMax(hAcm)) <= 0)
		fSuccess = TraceFALSE(NULL);

	// alloc a new format struct that is sure to be big enough
	//
	else if ((lpwfxNew = WavFormatAlloc((WORD)
		max(nFormatSize, nFormatSizeMax))) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#ifdef AVPCM
	else if (lpAcm->dwFlags & ACM_NOACM)
	{
		// no standard dialog available; just return a valid format
		//
		if (lpwfx == NULL && WavFormatPcm(-1, -1, -1, lpwfxNew) == NULL)
	 		fSuccess = TraceFALSE(NULL);
		else if (lpwfx != NULL && WavFormatCopy(lpwfxNew, lpwfx) != 0)
	 		fSuccess = TraceFALSE(NULL);
	}
#endif
	else
	{
		// initialize the format struct
		//
		MemSet(&afc, 0, sizeof(afc));

		afc.cbStruct = sizeof(afc);
		afc.fdwStyle = 0;
		afc.hwndOwner = hwndOwner;
		afc.pwfx = lpwfxNew;
		afc.cbwfx = WavFormatGetSize(lpwfxNew);
		afc.pszTitle = lpszTitle;
		afc.szFormatTag[0] = '\0';
		afc.szFormat[0] = '\0';
		afc.pszName = NULL;
		afc.cchName = 0;
		afc.fdwEnum = 0;
		afc.pwfxEnum = NULL;
		afc.hInstance = NULL;
		afc.pszTemplateName = NULL;
		afc.lCustData = 0L;
		afc.pfnHook = NULL;

		if (lpwfx != NULL)
		{
			// supply initial format to dialog if possible
			//
			afc.fdwStyle |= ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT;

			if (WavFormatCopy(lpwfxNew, lpwfx) != 0)
				fSuccess = TraceFALSE(NULL);
		}

		// restrict choices if necessary
		//
		if (dwFlags & ACM_FORMATPLAY)
			afc.fdwEnum |= ACM_FORMATENUMF_OUTPUT;
		if (dwFlags & ACM_FORMATRECORD)
			afc.fdwEnum |= ACM_FORMATENUMF_INPUT;

		// do the dialog box, fill in lpwfxNew with chosen format
		//
		if ((lpAcm->nLastError = acmFormatChoose(&afc)) != 0)
		{
			if (lpAcm->nLastError == ACMERR_CANCELED)
			{
				fSuccess = FALSE;
			}
			else
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("acmFormatChoose failed (%u)\n"),
					(unsigned) lpAcm->nLastError);
			}
		}
	}

	if (!fSuccess && lpwfxNew != NULL)
	{
		if (WavFormatFree(lpwfxNew) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? lpwfxNew : NULL;
}

// AcmFormatSuggest - suggest a new format
//		<hAcm>				(i) handle returned from AcmInit
//		<lpwfxSrc>			(i) source format
//		<nFormatTag>		(i) suggested format must match this format tag
//			-1					suggestion need not match
//		<nSamplesPerSec>	(i) suggested format must match this sample rate
//			-1					suggestion need not match
//		<nBitsPerSample>	(i) suggested format must match this sample size
//			-1					suggestion need not match
//		<nChannels>			(i) suggested format must match this channels
//			-1					suggestion need not match
//		<dwFlags>			(i)	control flags
//			0					reserved; must be zero
// return pointer to suggested format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI AcmFormatSuggestEx(HACM hAcm,
	LPWAVEFORMATEX lpwfxSrc, long nFormatTag, long nSamplesPerSec,
	int nBitsPerSample, int nChannels, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;
	int nFormatSize = 0;
	int nFormatSizeMax;
	LPWAVEFORMATEX lpwfxNew = NULL;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure source format is valid
	//
	else if (!WavFormatIsValid(lpwfxSrc))
		fSuccess = TraceFALSE(NULL);

	// calc how big is the source format struct
	//
	else if ((nFormatSize = WavFormatGetSize(lpwfxSrc)) <= 0)
		fSuccess = TraceFALSE(NULL);

	// calc how big is the largest format struct in the acm
	//
	else if ((nFormatSizeMax = AcmFormatGetSizeMax(hAcm)) <= 0)
		fSuccess = TraceFALSE(NULL);

	// alloc a new format struct that is sure to be big enough
	//
	else if ((lpwfxNew = WavFormatAlloc((WORD)
		max(nFormatSize, nFormatSizeMax))) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// copy source format to new format
	//
	else if (WavFormatCopy(lpwfxNew, lpwfxSrc) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (!(lpAcm->dwFlags & ACM_NOACM))
	{
		DWORD dwFlagsSuggest = 0;

		// restrict suggestions if necessary
		//
		if (nFormatTag != -1)
		{
			lpwfxNew->wFormatTag = (WORD) nFormatTag;
			dwFlagsSuggest |= ACM_FORMATSUGGESTF_WFORMATTAG;
		}

		if (nSamplesPerSec != -1)
		{
			lpwfxNew->nSamplesPerSec = (DWORD) nSamplesPerSec;
			dwFlagsSuggest |= ACM_FORMATSUGGESTF_NSAMPLESPERSEC;
		}

		if (nBitsPerSample != -1)
		{
			lpwfxNew->wBitsPerSample = (WORD) nBitsPerSample;
			dwFlagsSuggest |= ACM_FORMATSUGGESTF_WBITSPERSAMPLE;
		}

		if (nChannels != -1)
		{
			lpwfxNew->nChannels = (WORD) nChannels;
			dwFlagsSuggest |= ACM_FORMATSUGGESTF_NCHANNELS;
		}

		if ((lpAcm->nLastError = acmFormatSuggest(NULL, lpwfxSrc,
			lpwfxNew, max(nFormatSize, nFormatSizeMax), dwFlagsSuggest)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("acmFormatSuggest failed (%u)\n"),
				(unsigned) lpAcm->nLastError);
		}
	}
#ifdef AVPCM
	else if (lpAcm->dwFlags & ACM_NOACM)
	{
		// make a suggested format based on source
		// $FIXUP - this code should be in pcm.c
		//
		if (nFormatTag != -1)
			lpwfxNew->wFormatTag = (WORD) nFormatTag;
		else
			lpwfxNew->wFormatTag = WAVE_FORMAT_PCM;

		if (nSamplesPerSec != -1)
			lpwfxNew->nSamplesPerSec = (DWORD) nSamplesPerSec;
		else if (lpwfxNew->nSamplesPerSec < 8000)
			lpwfxNew->nSamplesPerSec = 6000;
		else if (lpwfxNew->nSamplesPerSec < 11025)
			lpwfxNew->nSamplesPerSec = 8000;
		else if (lpwfxNew->nSamplesPerSec < 22050)
			lpwfxNew->nSamplesPerSec = 11025;
		else if (lpwfxNew->nSamplesPerSec < 44100)
			lpwfxNew->nSamplesPerSec = 22050;
		else
			lpwfxNew->nSamplesPerSec = 44100;

		if (nBitsPerSample != -1)
			lpwfxNew->wBitsPerSample = (WORD) nBitsPerSample;
		else if (lpwfxNew->wBitsPerSample < 16)
			lpwfxNew->wBitsPerSample = 8;
		else
			lpwfxNew->wBitsPerSample = 16;

		if (nChannels != -1)
			lpwfxNew->nChannels = (WORD) nChannels;
		else
			lpwfxNew->nChannels = 1;

		// recalculate nBlockAlign and nAvgBytesPerSec
		//
		if (WavFormatPcm(lpwfxNew->nSamplesPerSec,
			lpwfxNew->wBitsPerSample,
			lpwfxNew->nChannels, lpwfxNew) == NULL)
			fSuccess = TraceFALSE(NULL);
	}
#endif
	if (!fSuccess && lpwfxNew != NULL)
	{
		if (WavFormatFree(lpwfxNew) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? lpwfxNew : NULL;
}

// AcmFormatGetText - get text describing the specified format
//		<hAcm>				(i) handle returned from AcmInit
//		<lpwfx>				(i) format
//		<lpszText>			(o) buffer to hold text
//		<sizText>			(i) size of buffer, in characters
//		<dwFlags>			(i)	control flags
//			0					reserved; must be zero
// return 0 if success
//
int DLLEXPORT WINAPI AcmFormatGetText(HACM hAcm, LPWAVEFORMATEX lpwfx,
	LPTSTR lpszText, int sizText, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;
	TCHAR szFormat[ACMFORMATDETAILS_FORMAT_CHARS];
	TCHAR szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];

    //
    // We have to initialize szFormatTag
    //
    _tcscpy( szFormatTag, _T("") );

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure format is valid
	//
	else if (!WavFormatIsValid(lpwfx))
		fSuccess = TraceFALSE(NULL);

	else if (lpszText == NULL)
		fSuccess = TraceFALSE(NULL);

	if (fSuccess && !(lpAcm->dwFlags & ACM_NOACM))
	{
		ACMFORMATTAGDETAILS atd;

		// initialize the details struct
		//
		MemSet(&atd, 0, sizeof(atd));

		atd.cbStruct = sizeof(atd);
		atd.dwFormatTagIndex = 0;
		atd.dwFormatTag = lpwfx->wFormatTag;
		atd.cbFormatSize = WavFormatGetSize(lpwfx);
		atd.fdwSupport = 0;
		atd.cStandardFormats = 0;
		atd.szFormatTag[0] = '\0';

		// get format tag details
		//
		if ((lpAcm->nLastError = acmFormatTagDetails(NULL,
			&atd, ACM_FORMATTAGDETAILSF_FORMATTAG)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("acmFormatTagDetails failed (%u)\n"),
				(unsigned) lpAcm->nLastError);
		}

		else
			StrNCpy(szFormatTag, atd.szFormatTag, SIZEOFARRAY(szFormatTag));
	}
#ifdef AVPCM
	if (fSuccess && (lpAcm->dwFlags & ACM_NOACM))
	{
		if (lpwfx->wFormatTag != WAVE_FORMAT_PCM)
			StrNCpy(szFormatTag, TEXT("*** Non-PCM ***"), SIZEOFARRAY(szFormatTag));
		else
			StrNCpy(szFormatTag, TEXT("PCM"), SIZEOFARRAY(szFormatTag));
	}
#endif
	if (fSuccess && !(lpAcm->dwFlags & ACM_NOACM))
	{
		ACMFORMATDETAILS afd;

		// initialize the details struct
		//
		MemSet(&afd, 0, sizeof(afd));

		afd.cbStruct = sizeof(afd);
		afd.dwFormatIndex = 0;
		afd.dwFormatTag = lpwfx->wFormatTag;
		afd.fdwSupport = 0;
		afd.pwfx = lpwfx;
		afd.cbwfx = WavFormatGetSize(lpwfx);
		afd.szFormat[0] = '\0';

		// get format details
		//
		if ((lpAcm->nLastError = acmFormatDetails(NULL,
			&afd, ACM_FORMATDETAILSF_FORMAT)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("acmFormatDetails failed (%u)\n"),
				(unsigned) lpAcm->nLastError);
		}

		else
			StrNCpy(szFormat, afd.szFormat, SIZEOFARRAY(szFormat));
	}
#ifdef AVPCM
	if (fSuccess && (lpAcm->dwFlags & ACM_NOACM))
	{
		TCHAR szTemp[64];

		wsprintf(szTemp, TEXT("%d.%03d kHz, %d Bit, %s"),
			(int) lpwfx->nSamplesPerSec / 1000,
			(int) lpwfx->nSamplesPerSec % 1000,
			(int) lpwfx->wBitsPerSample,
			(LPTSTR) (lpwfx->nChannels == 1 ? TEXT("Mono") : TEXT("Stereo")));

		StrNCpy(szFormat, szTemp, SIZEOFARRAY(szFormat));
	}
#endif
	// fill output buffer with results
	//
	if (fSuccess)
	{
		StrNCpy(lpszText, szFormatTag, sizText);
		StrNCat(lpszText, TEXT("\t"), sizText);
		StrNCat(lpszText, szFormat, sizText);
	}

	return fSuccess ? 0 : -1;
}

// AcmConvertInit - initialize acm conversion engine
//		<hAcm>				(i) handle returned from AcmInit
//		<lpwfxSrc>			(i) pointer to source WAVEFORMATEX struct
//		<lpwfxDst>			(i) pointer to destination WAVEFORMATEX struct
//		<lpwfltr>			(i) pointer to WAVEFILTER struct
//			NULL				reserved; must be NULL
//		<dwFlags>			(i) control flags
//			ACM_NONREALTIME		realtime conversion conversion not required
//			ACM_QUERY			return 0 if conversion would be supported
// return 0 if success
//
int DLLEXPORT WINAPI AcmConvertInit(HACM hAcm, LPWAVEFORMATEX lpwfxSrc,
	LPWAVEFORMATEX lpwfxDst, LPWAVEFILTER lpwfltr, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (AcmConvertTerm(hAcm) != 0)
		fSuccess = TraceFALSE(NULL);

	// make sure formats are valid
	//
	else if (!WavFormatIsValid(lpwfxSrc))
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfxDst))
		fSuccess = TraceFALSE(NULL);

	// save a copy of source and destination formats
	//
	else if ((lpAcm->lpwfxSrc = WavFormatDup(lpwfxSrc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpAcm->lpwfxDst = WavFormatDup(lpwfxDst)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (!(lpAcm->dwFlags & ACM_NOACM))
		{
			// PCM source --> PCM destination
			//
			if (lpwfxSrc->wFormatTag == WAVE_FORMAT_PCM &&
				lpwfxDst->wFormatTag == WAVE_FORMAT_PCM)
			{
				// open the acm conversion stream
				//
				if ((lpAcm->hAcmStream1 = AcmStreamOpen(AcmGetHandle(lpAcm),
					lpwfxSrc, lpwfxDst, NULL, dwFlags)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}
			}

			// non-PCM source --> non-PCM destination
			//
			else if (lpwfxSrc->wFormatTag != WAVE_FORMAT_PCM &&
				lpwfxDst->wFormatTag != WAVE_FORMAT_PCM)
			{
				// find a suitable intermediate PCM source format
				//
				if ((lpAcm->lpwfxInterm1 = AcmFormatSuggest(hAcm,
					lpwfxSrc, WAVE_FORMAT_PCM, -1, -1, -1, 0)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}

				// open the first acm conversion stream
				//
				else if ((lpAcm->hAcmStream1 = AcmStreamOpen(AcmGetHandle(lpAcm),
					lpAcm->lpwfxSrc, lpAcm->lpwfxInterm1, NULL, dwFlags)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}

				// find a suitable intermediate PCM destination format
				//
				else if ((lpAcm->lpwfxInterm2 = AcmFormatSuggest(hAcm,
					lpwfxDst, WAVE_FORMAT_PCM, -1, -1, -1, 0)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}

				// open the second acm conversion stream
				//
				else if (WavFormatCmp(lpAcm->lpwfxInterm1,
					lpAcm->lpwfxInterm2) == 0 &&
					(lpAcm->hAcmStream2 = AcmStreamOpen(AcmGetHandle(lpAcm),
					lpAcm->lpwfxInterm1, lpAcm->lpwfxDst, NULL, dwFlags)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}

				// open the second acm conversion stream
				//
				else if (WavFormatCmp(lpAcm->lpwfxInterm1,
					lpAcm->lpwfxInterm2) != 0 &&
					(lpAcm->hAcmStream2 = AcmStreamOpen(AcmGetHandle(lpAcm),
					lpAcm->lpwfxInterm1, lpAcm->lpwfxInterm2, NULL, dwFlags)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}

				// open the third acm conversion stream if necessary
				//
				else if (WavFormatCmp(lpAcm->lpwfxInterm1,
					lpAcm->lpwfxInterm2) != 0 &&
					(lpAcm->hAcmStream3 = AcmStreamOpen(AcmGetHandle(lpAcm),
					lpAcm->lpwfxInterm2, lpAcm->lpwfxDst, NULL, dwFlags)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}
			}

			// non-PCM source --> PCM destination
			//
			else if (lpwfxSrc->wFormatTag != WAVE_FORMAT_PCM &&
				lpwfxDst->wFormatTag == WAVE_FORMAT_PCM)
			{
				// find a suitable intermediate PCM format 
				//
				if ((lpAcm->lpwfxInterm1 = AcmFormatSuggest(hAcm,
					lpwfxSrc, WAVE_FORMAT_PCM, -1, -1, -1, 0)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}

				// open the first acm conversion stream
				//
				else if ((lpAcm->hAcmStream1 = AcmStreamOpen(AcmGetHandle(lpAcm),
					lpAcm->lpwfxSrc, lpAcm->lpwfxInterm1, NULL, dwFlags)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}

				// open the second acm conversion stream if necessary
				//
				else if (WavFormatCmp(lpAcm->lpwfxInterm1,
					lpAcm->lpwfxDst) != 0 &&
					(lpAcm->hAcmStream2 = AcmStreamOpen(AcmGetHandle(lpAcm),
					lpAcm->lpwfxInterm1, lpAcm->lpwfxDst, NULL, dwFlags)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}
			}

			// PCM source --> non-PCM destination
			//
			else if (lpwfxSrc->wFormatTag == WAVE_FORMAT_PCM &&
				lpwfxDst->wFormatTag != WAVE_FORMAT_PCM)
			{
				// find a suitable intermediate PCM format 
				//
				if ((lpAcm->lpwfxInterm1 = AcmFormatSuggest(hAcm,
					lpwfxDst, WAVE_FORMAT_PCM, -1, -1, -1, 0)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}

				// open the first acm conversion stream
				//
				else if ((lpAcm->hAcmStream1 = AcmStreamOpen(AcmGetHandle(lpAcm),
					lpAcm->lpwfxSrc, lpAcm->lpwfxInterm1, NULL, dwFlags)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}

				// open the second acm conversion stream
				//
				else if ((lpAcm->hAcmStream2 = AcmStreamOpen(AcmGetHandle(lpAcm),
					lpAcm->lpwfxInterm1, lpAcm->lpwfxDst, NULL, dwFlags)) == NULL)
				{
					fSuccess = TraceFALSE(NULL);
				}
			}
		}
#ifdef AVPCM
		else if (lpAcm->dwFlags & ACM_NOACM)
		{
			// if we do not have the acm, we are limited to
			// the sub-set of PCM formats handled by pcm.c
			// $FIXUP - move this code to pcm.c
			//

			if (lpwfxSrc->wFormatTag != WAVE_FORMAT_PCM)
				fSuccess = TraceFALSE(NULL);

			else if (lpwfxSrc->nChannels != 1)
				fSuccess = TraceFALSE(NULL);

			else if (lpwfxSrc->nSamplesPerSec != 6000 &&
				lpwfxSrc->nSamplesPerSec != 8000 &&
				lpwfxSrc->nSamplesPerSec != 11025 &&
				lpwfxSrc->nSamplesPerSec != 22050 &&
				lpwfxSrc->nSamplesPerSec != 44100)
				fSuccess = TraceFALSE(NULL);

			else if (lpwfxDst->wFormatTag != WAVE_FORMAT_PCM)
				fSuccess = TraceFALSE(NULL);

			else if (lpwfxDst->nChannels != 1)
				fSuccess = TraceFALSE(NULL);

			else if (lpwfxDst->nSamplesPerSec != 6000 &&
				lpwfxDst->nSamplesPerSec != 8000 &&
				lpwfxDst->nSamplesPerSec != 11025 &&
				lpwfxDst->nSamplesPerSec != 22050 &&
				lpwfxDst->nSamplesPerSec != 44100)
				fSuccess = TraceFALSE(NULL);
		}
#endif
	}

	if (!fSuccess || (dwFlags & ACM_QUERY))
	{
		if (AcmConvertTerm(hAcm) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// AcmConvertTerm - shut down acm conversion engine
//		<hAcm>				(i) handle returned from AcmInit
// return 0 if success
//
int DLLEXPORT WINAPI AcmConvertTerm(HACM hAcm)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// close the acm conversion stream
	//
	else if (lpAcm->hAcmStream1 != NULL &&
		AcmStreamClose(hAcm, lpAcm->hAcmStream1) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	else if (lpAcm->hAcmStream1 = NULL, FALSE)
		;

	// close the acm conversion stream
	//
	else if (lpAcm->hAcmStream2 != NULL &&
		AcmStreamClose(hAcm, lpAcm->hAcmStream2) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	else if (lpAcm->hAcmStream2 = NULL, FALSE)
		;

	// close the acm conversion stream
	//
	else if (lpAcm->hAcmStream3 != NULL &&
		AcmStreamClose(hAcm, lpAcm->hAcmStream3) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	else if (lpAcm->hAcmStream3 = NULL, FALSE)
		;

	// free source and destination formats
	//
	else if (lpAcm->lpwfxSrc != NULL && WavFormatFree(lpAcm->lpwfxSrc) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (lpAcm->lpwfxSrc = NULL, FALSE)
		;

	else if (lpAcm->lpwfxInterm1 != NULL && WavFormatFree(lpAcm->lpwfxInterm1) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (lpAcm->lpwfxInterm1 = NULL, FALSE)
		;

	else if (lpAcm->lpwfxInterm2 != NULL && WavFormatFree(lpAcm->lpwfxInterm2) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (lpAcm->lpwfxInterm2 = NULL, FALSE)
		;

	else if (lpAcm->lpwfxDst != NULL && WavFormatFree(lpAcm->lpwfxDst) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (lpAcm->lpwfxDst = NULL, FALSE)
		;

	return fSuccess ? 0 : -1;
}

// AcmConvertGetSizeSrc - calculate source buffer size
//		<hAcm>				(i) handle returned from AcmInit
//		<sizBufDst>			(i) size of destination buffer in bytes
// return source buffer size, -1 if error
//
long DLLEXPORT WINAPI AcmConvertGetSizeSrc(HACM hAcm, long sizBufDst)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;
    //
    // We should intialize local variable
	long sizBufSrc = -1;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!(lpAcm->dwFlags & ACM_NOACM))
	{
		if (lpAcm->hAcmStream1 == NULL)
			fSuccess = TraceFALSE(NULL);

		if (fSuccess && lpAcm->hAcmStream3 != NULL &&
			(sizBufDst = AcmStreamSize(hAcm, lpAcm->hAcmStream3,
			(DWORD) sizBufDst, ACM_DESTINATION)) < 0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		if (fSuccess && lpAcm->hAcmStream2 != NULL &&
			(sizBufDst = AcmStreamSize(hAcm, lpAcm->hAcmStream2,
			(DWORD) sizBufDst, ACM_DESTINATION)) < 0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		if (fSuccess &&
			(sizBufSrc = AcmStreamSize(hAcm, lpAcm->hAcmStream1,
			(DWORD) sizBufDst, ACM_DESTINATION)) < 0)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}
#ifdef AVPCM
	else if (lpAcm->dwFlags & ACM_NOACM)
	{
		if ((sizBufSrc = PcmCalcSizBufSrc(lpAcm->hPcm, sizBufDst,
			lpAcm->lpwfxSrc, lpAcm->lpwfxDst)) < 0)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}
#endif
	return fSuccess ? sizBufSrc : -1;
}

// AcmConvertGetSizeDst - calculate destination buffer size
//		<hAcm>				(i) handle returned from AcmInit
//		<sizBufSrc>			(i) size of source buffer in bytes
// return destination buffer size, -1 if error
//
long DLLEXPORT WINAPI AcmConvertGetSizeDst(HACM hAcm, long sizBufSrc)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;
    //
    // We should initialize the ocal variable
    //
	long sizBufDst = -1;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!(lpAcm->dwFlags & ACM_NOACM))
	{
		if (lpAcm->hAcmStream1 == NULL)
			fSuccess = TraceFALSE(NULL);

		if (fSuccess && lpAcm->hAcmStream3 != NULL &&
			(sizBufSrc = AcmStreamSize(hAcm, lpAcm->hAcmStream3,
			(DWORD) sizBufSrc, ACM_SOURCE)) < 0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		if (fSuccess && lpAcm->hAcmStream2 != NULL &&
			(sizBufSrc = AcmStreamSize(hAcm, lpAcm->hAcmStream2,
			(DWORD) sizBufSrc, ACM_SOURCE)) < 0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		if (fSuccess &&
			(sizBufDst = AcmStreamSize(hAcm, lpAcm->hAcmStream1,
			(DWORD) sizBufSrc, ACM_SOURCE)) < 0)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}
#ifdef AVPCM
	else if (lpAcm->dwFlags & ACM_NOACM)
	{
		if ((sizBufDst = PcmCalcSizBufDst(lpAcm->hPcm, sizBufSrc,
			lpAcm->lpwfxSrc, lpAcm->lpwfxDst)) < 0)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}
#endif

	return fSuccess ? sizBufDst : -1;
}

// AcmConvert - convert wav data from one format to another
//		<hAcm>				(i) handle returned from AcmInit
//		<hpBufSrc> 			(i) buffer containing bytes to reformat
//		<sizBufSrc>			(i) size of buffer in bytes
//		<hpBufDst> 			(o) buffer to contain new format
//		<sizBufDst>			(i) size of buffer in bytes
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return count of bytes in destination buffer (-1 if error)
//
// NOTE: the destination buffer must be large enough to hold the result
//
long DLLEXPORT WINAPI AcmConvert(HACM hAcm,
	void _huge *hpBufSrc, long sizBufSrc,
	void _huge *hpBufDst, long sizBufDst,
	DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;

    //
    // We should initialize local variable
    //
	long cbDst = -1;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!(lpAcm->dwFlags & ACM_NOACM))
	{
		if (lpAcm->hAcmStream1 == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (lpAcm->hAcmStream2 == NULL)
		{
			if ((cbDst = AcmStreamConvert(hAcm, lpAcm->hAcmStream1,
				hpBufSrc, sizBufSrc, hpBufDst, sizBufDst, dwFlags)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}

		else if (lpAcm->hAcmStream3 == NULL)
		{
			long sizBufInterm;
			long cbInterm;
			void _huge *hpBufInterm = NULL;

			if ((sizBufInterm = AcmStreamSize(hAcm, lpAcm->hAcmStream1,
				(DWORD) sizBufSrc, ACM_SOURCE)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if (sizBufInterm == 0)
				cbDst = 0; // nothing to do

			else if ((hpBufInterm = (void _huge *) MemAlloc(NULL,
				sizBufInterm, 0)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if ((cbInterm = AcmStreamConvert(hAcm, lpAcm->hAcmStream1,
				hpBufSrc, sizBufSrc, hpBufInterm, sizBufInterm, dwFlags)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if ((cbDst = AcmStreamConvert(hAcm, lpAcm->hAcmStream2,
				hpBufInterm, cbInterm, hpBufDst, sizBufDst, dwFlags)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			if (hpBufInterm != NULL &&
				(hpBufInterm = MemFree(NULL, hpBufInterm)) != NULL)
				fSuccess = TraceFALSE(NULL);
		}

		else // if (lpAcm->hAcmStream3 !== NULL)
		{
			long sizBufInterm1;
			long cbInterm1;
			void _huge *hpBufInterm1 = NULL;
			long sizBufInterm2;
			long cbInterm2;
			void _huge *hpBufInterm2 = NULL;

			if ((sizBufInterm1 = AcmStreamSize(hAcm, lpAcm->hAcmStream1,
				(DWORD) sizBufSrc, ACM_SOURCE)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if (sizBufInterm1 == 0)
				cbDst = 0; // nothing to do

			else if ((hpBufInterm1 = (void _huge *) MemAlloc(NULL,
				sizBufInterm1, 0)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if ((sizBufInterm2 = AcmStreamSize(hAcm, lpAcm->hAcmStream2,
				(DWORD) sizBufInterm1, ACM_SOURCE)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if (sizBufInterm2 == 0)
				cbDst = 0; // nothing to do

			else if ((hpBufInterm2 = (void _huge *) MemAlloc(NULL,
				sizBufInterm2, 0)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if ((cbInterm1 = AcmStreamConvert(hAcm, lpAcm->hAcmStream1,
				hpBufSrc, sizBufSrc, hpBufInterm1, sizBufInterm1, dwFlags)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if ((cbInterm2 = AcmStreamConvert(hAcm, lpAcm->hAcmStream2,
				hpBufInterm1, cbInterm1, hpBufInterm2, sizBufInterm2, dwFlags)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if ((cbDst = AcmStreamConvert(hAcm, lpAcm->hAcmStream3,
				hpBufInterm2, cbInterm2, hpBufDst, sizBufDst, dwFlags)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			if (hpBufInterm1 != NULL &&
				(hpBufInterm1 = MemFree(NULL, hpBufInterm1)) != NULL)
				fSuccess = TraceFALSE(NULL);

			if (hpBufInterm2 != NULL &&
				(hpBufInterm2 = MemFree(NULL, hpBufInterm2)) != NULL)
				fSuccess = TraceFALSE(NULL);
		}
	}
#ifdef AVPCM
	else if (lpAcm->dwFlags & ACM_NOACM)
	{
		// perform the conversion
		//
		if ((cbDst = PcmConvert(lpAcm->hPcm,
			hpBufSrc, sizBufSrc, lpAcm->lpwfxSrc,
			hpBufDst, sizBufDst, lpAcm->lpwfxDst, 0)) < 0)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}
#endif

	return fSuccess ? cbDst : -1;
}

// AcmDriverLoad - load an acm driver for use by this process
//		<hAcm>				(i) handle returned from AcmInit
//		<wMid>				(i) manufacturer id
//		<wPid>				(i) product id
//		<lpszDriver>		(i) name of driver module
//		<lpszDriverProc>	(i) name of driver proc function
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return handle (NULL if error)
//
HACMDRV DLLEXPORT WINAPI AcmDriverLoad(HACM hAcm, WORD wMid, WORD wPid,
	LPTSTR lpszDriver, LPSTR lpszDriverProc, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;
	LPACMDRV lpAcmDrv = NULL;
	DRIVERPROC lpfnDriverProc;
	ACMDRIVERENUMCB lpfnAcmDriverLoadEnumCallback;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpszDriver == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpszDriverProc == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpAcmDrv = (LPACMDRV) MemAlloc(NULL, sizeof(ACMDRV), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpAcmDrv->hAcm = hAcm;
		lpAcmDrv->hInstLib = NULL;
		lpAcmDrv->hadid = NULL;
		lpAcmDrv->wMid = wMid;
		lpAcmDrv->wPid = wPid;
		lpAcmDrv->nLastError = 0;
		lpAcmDrv->dwFlags = 0;

		if ((lpfnAcmDriverLoadEnumCallback = (ACMDRIVERENUMCB)
			MakeProcInstance((FARPROC) AcmDriverLoadEnumCallback,
			lpAcm->hInst)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// enumerate all drivers to see if specified driver is already loaded
		//
		else if ((lpAcmDrv->nLastError = acmDriverEnum(lpfnAcmDriverLoadEnumCallback, PtrToUlong(lpAcmDrv), 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("acmDriverEnum failed (%u)\n"),
				(unsigned) lpAcmDrv->nLastError);
		}

		// if error or driver is already loaded, we are done
		//
		if (!fSuccess || lpAcmDrv->hadid != NULL)
			;

		// load the driver module if possible
		//
		else if ((lpAcmDrv->hInstLib = LoadLibraryPath(lpszDriver,
			lpAcm->hInst, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// get address of driver proc function
		//
		else if ((lpfnDriverProc = (DRIVERPROC)
			GetProcAddress(lpAcmDrv->hInstLib, lpszDriverProc)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// add driver to list of available acm drivers
		//
		else if ((lpAcmDrv->nLastError = acmDriverAdd(&lpAcmDrv->hadid,
			lpAcmDrv->hInstLib, (LPARAM) lpfnDriverProc, 0,
			ACM_DRIVERADDF_FUNCTION | ACM_DRIVERADDF_LOCAL)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("acmDriverAdd failed (%u)\n"),
				(unsigned) lpAcmDrv->nLastError);
		}

		// set flag so we know to call acmDriverRemove
		//
		else
			lpAcmDrv->dwFlags |= ACMDRV_REMOVEDRIVER;
	}

	if (!fSuccess && lpAcmDrv != NULL &&
		(lpAcmDrv = MemFree(NULL, lpAcmDrv)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? AcmDrvGetHandle(lpAcmDrv) : NULL;
}

// AcmDriverUnload - unload an acm driver
//		<hAcm>				(i) handle returned from AcmInit
//		<hAcmDrv>			(i) handle returned from AcmDriverLoad
// return 0 if success
//
int DLLEXPORT WINAPI AcmDriverUnload(HACM hAcm, HACMDRV hAcmDrv)
{
	BOOL fSuccess = TRUE;
	LPACMDRV lpAcmDrv;
	LPACM lpAcm;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpAcmDrv = AcmDrvGetPtr(hAcmDrv)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (hAcm != lpAcmDrv->hAcm)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// remove driver from acm if necessary
		//
		if ((lpAcmDrv->dwFlags & ACMDRV_REMOVEDRIVER) &&
			lpAcmDrv->hadid != NULL &&
			(lpAcmDrv->nLastError =
			acmDriverRemove(lpAcmDrv->hadid, 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("acmDriverRemove failed (%u)\n"),
				(unsigned) lpAcmDrv->nLastError);
		}
		else
			lpAcmDrv->hadid = NULL;

		// driver module no longer needed
		//
		if (lpAcmDrv->hInstLib != NULL)
		{
			FreeLibrary(lpAcmDrv->hInstLib);
			lpAcmDrv->hInstLib = NULL;
		}

		if ((lpAcmDrv = MemFree(NULL, lpAcmDrv)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

// AcmGetPtr - verify that acm handle is valid,
//		<hAcm>				(i) handle returned from AcmInit
// return corresponding acm pointer (NULL if error)
//
static LPACM AcmGetPtr(HACM hAcm)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;

	if ((lpAcm = (LPACM) hAcm) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpAcm, sizeof(ACM)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the acm handle
	//
	else if (lpAcm->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpAcm : NULL;
}

// AcmGetHandle - verify that acm pointer is valid,
//		<lpAcm>				(i) pointer to ACM struct
// return corresponding acm handle (NULL if error)
//
static HACM AcmGetHandle(LPACM lpAcm)
{
	BOOL fSuccess = TRUE;
	HACM hAcm;

	if ((hAcm = (HACM) lpAcm) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hAcm : NULL;
}

// AcmDrvGetPtr - verify that acmdrv handle is valid,
//		<hAcmDrv>				(i) handle returned from AcmDrvLoad
// return corresponding acmdrv pointer (NULL if error)
//
static LPACMDRV AcmDrvGetPtr(HACMDRV hAcmDrv)
{
	BOOL fSuccess = TRUE;
	LPACMDRV lpAcmDrv;

	if ((lpAcmDrv = (LPACMDRV) hAcmDrv) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpAcmDrv, sizeof(ACMDRV)))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpAcmDrv : NULL;
}

// AcmDrvGetHandle - verify that acmdrv pointer is valid,
//		<lpAcm>				(i) pointer to ACM struct
// return corresponding acmdrv handle (NULL if error)
//
static HACMDRV AcmDrvGetHandle(LPACMDRV lpAcmDrv)
{
	BOOL fSuccess = TRUE;
	HACMDRV hAcmDrv;

	if ((hAcmDrv = (HACMDRV) lpAcmDrv) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hAcmDrv : NULL;
}

// AcmStreamOpen - open acm conversion stream
//		<hAcm>				(i) handle returned from AcmInit
//		<lpwfxSrc>			(i) pointer to source WAVEFORMATEX struct
//		<lpwfxDst>			(i) pointer to destination WAVEFORMATEX struct
//		<lpwfltr>			(i) pointer to WAVEFILTER struct
//		<dwFlags>			(i) control flags
//			ACM_NONREALTIME		realtime stream conversion not required
//			ACM_QUERY			return TRUE if conversion would be supported
// return handle (NULL if error)
//
static HACMSTREAM WINAPI AcmStreamOpen(HACM hAcm, LPWAVEFORMATEX lpwfxSrc,
	LPWAVEFORMATEX lpwfxDst, LPWAVEFILTER lpwfltr, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	HACMSTREAM hAcmStream = NULL;
	LPACM lpAcm;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfxSrc))
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfxDst))
		fSuccess = TraceFALSE(NULL);

	else
	{
		DWORD dwFlagsStreamOpen = 0;

		// set non-realtime flag if necessary
		//
		if (dwFlags & ACM_NONREALTIME)
			dwFlagsStreamOpen |= ACM_STREAMOPENF_NONREALTIME;

		// set query flag if necessary
		//
		if (dwFlags & ACM_QUERY)
			dwFlagsStreamOpen |= ACM_STREAMOPENF_QUERY;

		// open (or query) the acm conversion stream
		//
		if ((lpAcm->nLastError = acmStreamOpen(&hAcmStream,
			NULL, lpwfxSrc, lpwfxDst, lpwfltr, 0, 0, dwFlagsStreamOpen)) != 0)
		{
			if ((dwFlags & ACM_QUERY) &&
				lpAcm->nLastError == ACMERR_NOTPOSSIBLE)
			{
				fSuccess = FALSE;
			}
			else
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("acmStreamOpen failed (%u)\n"),
					(unsigned) lpAcm->nLastError);
			}
		}
	}

	// close stream if we are finished with it
	//
	if (!fSuccess || (dwFlags & ACM_QUERY))
	{
		if (AcmStreamClose(hAcm, hAcmStream) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (dwFlags & ACM_QUERY)
		return fSuccess ? (HACMSTREAM) TRUE : (HACMSTREAM) FALSE;
	else
		return fSuccess ? hAcmStream : NULL;
}

// AcmStreamClose - close acm conversion stream
//		<hAcm>				(i) handle returned from AcmInit
//		<hAcmStream>		(i) handle returned from AcmStreamOpen
// return 0 if success
//
static int WINAPI AcmStreamClose(HACM hAcm, HACMSTREAM hAcmStream)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// close the acm conversion stream
	//
	else if (hAcmStream != NULL &&
		(lpAcm->nLastError = acmStreamClose(hAcmStream, 0)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("acmStreamClose failed (%u)\n"),
			(unsigned) lpAcm->nLastError);
	}

	else if (hAcmStream = NULL, FALSE)
		;

	return fSuccess ? 0 : -1;
}

// AcmStreamSize - calculate stream buffer size
//		<hAcm>				(i) handle returned from AcmInit
//		<hAcmStream>		(i) handle returned from AcmStreamOpen
//		<sizBuf>			(i) size of buffer in bytes
//		<dwFlags>			(i) control flags
//			ACM_SOURCE			sizBuf is source, calc destination
//			ACM_DESTINATION		sizBuf is destination, calc source
// return buffer size, -1 if error
//
static long WINAPI AcmStreamSize(HACM hAcm, HACMSTREAM hAcmStream, long sizBuf, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm = NULL;
	DWORD sizBufRet = 0;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (hAcmStream == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (sizBuf == 0)
		sizBufRet = 0;

	else
	{
		DWORD dwFlagsSize = 0;
		if (dwFlags & ACM_SOURCE)
			dwFlagsSize |= ACM_STREAMSIZEF_SOURCE;
		if (dwFlags & ACM_DESTINATION)
			dwFlagsSize |= ACM_STREAMSIZEF_DESTINATION;

		if ((lpAcm->nLastError = acmStreamSize(hAcmStream,
			(DWORD) sizBuf, &sizBufRet, dwFlagsSize)) != 0)
		{
			if (lpAcm->nLastError == ACMERR_NOTPOSSIBLE)
			{
				// not a fatal error; just return buffer size as zero
				//
				fSuccess = TraceTRUE(NULL);
				sizBufRet = 0;
			}
			else
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("acmStreamSize failed (%u)\n"),
					(unsigned) lpAcm->nLastError);
			}
		}
	}

	return fSuccess ? (long) sizBufRet : -1;

}

// AcmStreamConvert - convert wav data from one format to another
//		<hAcm>				(i) handle returned from AcmInit
//		<hAcmStream>		(i) handle returned from AcmStreamOpen
//		<hpBufSrc> 			(i) buffer containing bytes to reformat
//		<sizBufSrc>			(i) size of buffer in bytes
//		<hpBufDst> 			(o) buffer to contain new format
//		<sizBufDst>			(i) size of buffer in bytes
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return count of bytes in destination buffer (-1 if error)
//
// NOTE: the destination buffer must be large enough to hold the result
//
static long WINAPI AcmStreamConvert(HACM hAcm, HACMSTREAM hAcmStream,
	void _huge *hpBufSrc, long sizBufSrc,
	void _huge *hpBufDst, long sizBufDst,
	DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPACM lpAcm;
	long cbDst;

	if ((lpAcm = AcmGetPtr(hAcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (hAcmStream == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		ACMSTREAMHEADER ash;

		MemSet(&ash, 0, sizeof(ash));

		// initialize stream header
		//
		ash.cbStruct = sizeof(ash);
		ash.pbSrc = (LPBYTE) hpBufSrc;
		ash.cbSrcLength = (DWORD) sizBufSrc;
		ash.pbDst = (LPBYTE) hpBufDst;
		ash.cbDstLength = (DWORD) sizBufDst;

		// prepare stream header
		//
		if ((lpAcm->nLastError = acmStreamPrepareHeader(hAcmStream,
			&ash, 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("acmStreamPrepareHeader failed (%u)\n"),
				(unsigned) lpAcm->nLastError);
		}

		else
		{
			// perform the conversion
			//
			if ((lpAcm->nLastError = acmStreamConvert(hAcmStream,
				&ash, ACM_STREAMCONVERTF_BLOCKALIGN)) != 0)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("acmStreamConvert failed (%u)\n"),
					(unsigned) lpAcm->nLastError);
			}
			else
			{
				// save count of bytes in destination buffer
				//
				cbDst = (long) ash.cbDstLengthUsed;
			}

			// reset these to original values before unprepare
			//
			ash.cbSrcLength = (DWORD) sizBufSrc;
			ash.cbDstLength = (DWORD) sizBufDst;

			// unprepare stream header (even if conversion failed)
			//
			if ((lpAcm->nLastError = acmStreamUnprepareHeader(hAcmStream,
				&ash, 0)) != 0)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("acmStreamUnprepareHeader failed (%u)\n"),
					(unsigned) lpAcm->nLastError);
			}
		}
	}

	return fSuccess ? cbDst : -1;
}

BOOL CALLBACK AcmDriverLoadEnumCallback(HACMDRIVERID hadid,
	DWORD dwInstance, DWORD fdwSupport)
{
	BOOL fSuccess = TRUE;
	LPACMDRV lpAcmDrv;
	ACMDRIVERDETAILS add;

	MemSet(&add, 0, sizeof(add));
	add.cbStruct = sizeof(ACMDRIVERDETAILS);

	if (hadid == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpAcmDrv = (LPACMDRV)(DWORD_PTR)dwInstance) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get information about this driver
	//
	else if ((lpAcmDrv->nLastError = acmDriverDetails(hadid, &add, 0)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("acmDriverDetails failed (%u)\n"),
			(unsigned) lpAcmDrv->nLastError);
	}

	// check for match on manufacturer id and product id
	//
	else if (add.wMid == lpAcmDrv->wMid && add.wPid == lpAcmDrv->wPid)
	{
		lpAcmDrv->hadid = hadid; // pass driver id handle back to caller
		return FALSE; // we are finished enumerating
	}

	return TRUE; // continue enumeration
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\acmthunk.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  acmthunk.h
//
//  Description:
//      Contains function prototypes for the thunking code in acmthunk.c.
//
//
//==========================================================================;

#ifndef _INC_ACMTHUNK
#define _INC_ACMTHUNK

#ifdef __cplusplus
extern "C"
{
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

BOOL FAR PASCAL acmThunkInitialize
(
    void
);

BOOL FAR PASCAL acmThunkTerminate
(
    void
);


#ifdef __cplusplus
}
#endif
#endif  // _INC_ACMTHUNK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\dllmain.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	dllmain.c - LibMain and WEP functions
////

//#if 0
//#include "winlocal.h"
//#else
#ifndef STRICT
#define STRICT
#endif
#include <windows.h>
#include <windowsx.h>
#define DLLEXPORT __declspec(dllexport)
#define DECLARE_HANDLE32    DECLARE_HANDLE
//#endif

// global to keep track of DLL's instance/module handle;
//
HINSTANCE g_hInstLib;

#ifdef _WIN32

BOOL WINAPI DllMain(HANDLE hModule, DWORD fdwReason, LPVOID lpReserved);

BOOL WINAPI DllMain(HANDLE hModule, DWORD fdwReason, LPVOID lpReserved)
{
	BOOL fSuccess = TRUE;

	switch (fdwReason)
	{
		case DLL_PROCESS_ATTACH:
			g_hInstLib = (HINSTANCE) hModule;
			break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_THREAD_DETACH:
			break;

		case DLL_PROCESS_DETACH:
			break;

		default:
			break;
	}

	return fSuccess;
}

#else

int CALLBACK LibMain(HINSTANCE hinst, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine);
int CALLBACK WEP(int nExitType);

int CALLBACK LibMain(HINSTANCE hinst, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine)
{
	g_hInstLib = hinst;

	if (cbHeapSize != 0)
		UnlockData(0);

	return 1; // success
}

int CALLBACK WEP(int nExitType)
{
	switch (nExitType)
	{
		case WEP_SYSTEM_EXIT:	// system shutdown in progress
		case WEP_FREE_DLL:		// DLL usage count is zero
		default:				// undefined
			return 1;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\mmio.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// mmio.h - interface to mmio file functions in mmio.c
////

#ifndef __MMIO_H__
#define __MMIO_H__

#include "winlocal.h"

// user-defined messages
//
#ifndef MMIOM_GETINFO
#define MMIOM_GETINFO		 (MMIOM_USER + 0x1000)
#endif
#ifndef MMIOM_CHSIZE
#define MMIOM_CHSIZE		 (MMIOM_USER + 0x1001)
#endif

#ifdef __cplusplus
extern "C" {
#endif

// MmioIOProc - i/o procedure for mmio data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing mmio format file data.
//
LRESULT DLLEXPORT CALLBACK MmioIOProc(LPTSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#ifdef __cplusplus
}
#endif

#endif // __MMIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\mulaw.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	mulaw.c - mulaw file format functions
////

#include "winlocal.h"

#include <mmsystem.h>

#include "mulaw.h"
#include "mem.h"
#include "sys.h"
#include "trace.h"
#include "wavfmt.h"

////
//	private definitions
////

// mulaw engine control structure
//
typedef struct MULAW
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	DWORD dwFlags;
} MULAW, FAR *LPMULAW;

// helper functions
//
static LPMULAW MulawGetPtr(HMULAW hMulaw);
static HMULAW MulawGetHandle(LPMULAW lpMulaw);
static unsigned char linear2ulaw(int sample);
static int ulaw2linear(unsigned char ulawbyte);

static LRESULT MulawIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName);
static LRESULT MulawIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags);
static LRESULT MulawIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch);
static LRESULT MulawIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush);
static LRESULT MulawIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin);
static LRESULT MulawIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName);

////
//	public functions
////

// MulawInit - initialize mulaw engine
//		<dwVersion>			(i) must be MULAW_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) reserved; must be 0
// return handle (NULL if error)
//
HMULAW DLLEXPORT WINAPI MulawInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPMULAW lpMulaw = NULL;

	if (dwVersion != MULAW_VERSION)
		fSuccess = TraceFALSE(NULL);

	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpMulaw = (LPMULAW) MemAlloc(NULL, sizeof(MULAW), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// initialize engine structure
		//
		lpMulaw->dwVersion = dwVersion;
		lpMulaw->hInst = hInst;
		lpMulaw->hTask = GetCurrentTask();
		lpMulaw->dwFlags = dwFlags;

		if (MulawReset(MulawGetHandle(lpMulaw)) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (!fSuccess)
	{
		MulawTerm(MulawGetHandle(lpMulaw));
		lpMulaw = NULL;
	}

	return fSuccess ? MulawGetHandle(lpMulaw) : NULL;
}

// MulawTerm - shut down mulaw engine
//		<hMulaw>			(i) handle returned from MulawInit
// return 0 if success
//
int DLLEXPORT WINAPI MulawTerm(HMULAW hMulaw)
{
	BOOL fSuccess = TRUE;
	LPMULAW lpMulaw;
	
	if ((lpMulaw = MulawGetPtr(hMulaw)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpMulaw = MemFree(NULL, lpMulaw)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// MulawReset - reset mulaw engine
//		<hMulaw>			(i) handle returned from MulawInit
// return 0 if success
//
int DLLEXPORT WINAPI MulawReset(HMULAW hMulaw)
{
	BOOL fSuccess = TRUE;
	LPMULAW lpMulaw;
	
	if ((lpMulaw = MulawGetPtr(hMulaw)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// currently nothing to do
	}

	return fSuccess ? 0 : -1;
}

// MulawDecode - decode mulaw samples
//		<hMulaw>			(i) handle returned from MulawInit
//		<lpabMulaw>			(i) array of encoded samples
//		<lpaiPcm>			(o) array of decoded samples
//		<uSamples>			(i) number of samples to decode
// return 0 if success
//
// NOTE: each BYTE in <lpabMulaw> contains 1 8-bit encoded sample
// in Mulaw format.
// Each PCM16 in <lpaiPcm> contains 1 16-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI MulawDecode(HMULAW hMulaw, LPBYTE lpabMulaw, LPPCM16 lpaiPcm, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPMULAW lpMulaw;

	if ((lpMulaw = MulawGetPtr(hMulaw)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpaiPcm == NULL || lpabMulaw == NULL)
		fSuccess = TraceFALSE(NULL);

	// decode each sample
	//
	else while (uSamples-- > 0)
		*lpaiPcm++ = (PCM16) ulaw2linear((BYTE) *lpabMulaw++);

	return fSuccess ? 0 : -1;
}

// MulawEncode - encode mulaw samples
//		<hMulaw>			(i) handle returned from MulawInit
//		<lpaiPcm>			(i) array of decoded samples
//		<lpabMulaw>			(o) array of encoded samples
//		<uSamples>			(i) number of samples to encode
// return 0 if success
//
// NOTE: each BYTE in <lpabMulaw> contains 1 8-bit encoded sample
// in Mulaw format.
// Each PCM16 in <lpaiPcm> contains 1 16-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI MulawEncode(HMULAW hMulaw, LPPCM16 lpaiPcm, LPBYTE lpabMulaw, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPMULAW lpMulaw;

	if ((lpMulaw = MulawGetPtr(hMulaw)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpaiPcm == NULL || lpabMulaw == NULL)
		fSuccess = TraceFALSE(NULL);

	// encode each sample
	//
	else while (uSamples-- > 0)
		*lpabMulaw++ = (BYTE) linear2ulaw((PCM16) *lpaiPcm++);

	return fSuccess ? 0 : -1;
}

// MulawIOProc - i/o procedure for mulaw format file data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing mulaw format file data.
//
LRESULT DLLEXPORT CALLBACK MulawIOProc(LPTSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult = 0;

	if (lpmmioinfo == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (uMessage)
	{
		case MMIOM_OPEN:
			lResult = MulawIOOpen((LPMMIOINFO) lpmmioinfo,
				(LPTSTR) lParam1);
			break;

		case MMIOM_CLOSE:
			lResult = MulawIOClose((LPMMIOINFO) lpmmioinfo,
				(UINT) lParam1);
			break;

		case MMIOM_READ:
			lResult = MulawIORead((LPMMIOINFO) lpmmioinfo,
				(HPSTR) lParam1, (LONG) lParam2);
			break;

		case MMIOM_WRITE:
			lResult = MulawIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, FALSE);
			break;

		case MMIOM_WRITEFLUSH:
			lResult = MulawIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, TRUE);
			break;

		case MMIOM_SEEK:
			lResult = MulawIOSeek((LPMMIOINFO) lpmmioinfo,
				(LONG) lParam1, (int) lParam2);
			break;

		case MMIOM_RENAME:
			lResult = MulawIORename((LPMMIOINFO) lpmmioinfo,
				(LPCTSTR) lParam1, (LPCTSTR) lParam2);
			break;

		default:
			lResult = 0;
			break;
	}

	return lResult;
}

////
//	private functions
////

// MulawGetPtr - verify that mulaw handle is valid,
//		<hMulaw>				(i) handle returned from MulawInit
// return corresponding mulaw pointer (NULL if error)
//
static LPMULAW MulawGetPtr(HMULAW hMulaw)
{
	BOOL fSuccess = TRUE;
	LPMULAW lpMulaw;

	if ((lpMulaw = (LPMULAW) hMulaw) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpMulaw, sizeof(MULAW)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the mulaw engine handle
	//
	else if (lpMulaw->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpMulaw : NULL;
}

// MulawGetHandle - verify that mulaw pointer is valid,
//		<lpMulaw>				(i) pointer to MULAW structure
// return corresponding mulaw handle (NULL if error)
//
static HMULAW MulawGetHandle(LPMULAW lpMulaw)
{
	BOOL fSuccess = TRUE;
	HMULAW hMulaw;

	if ((hMulaw = (HMULAW) lpMulaw) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hMulaw : NULL;
}

////
//	low-level mulaw stuff
////

// source - http://www.speech.su.oz.au/comp.speech/Section2/Q2.7.html

#define ZEROTRAP		// turn on the trap as per the MIL-STD
#define BIAS 0x84		// define the add-in bias for 16 bit samples
#define CLIP 32635

//// linear2ulaw - this routine converts from 16 bit linear to ulaw
//
//	Craig Reese: IDA/Supercomputing Research Center
//	Joe Campbell, Department of Defense
//	29 September 1989
//
//	References:
//	1)	CCITT Recommendation G.711  (very difficult to follow)
//	2)	"A New Digital Technique for Implementation of Any
//		Continuous PCM Companding Law," Villeret, Michel,
//		et. al. 1973 IEEE Int. Conf. on Communications, Vol 1,
//		1973, pg. 11.12-11.17
//	3)	MIL-STD-188-113, "Interoperability and Performance Standards
//		for Analog-to-Digital Conversion Techniques,"
//		17 February 1987
//
//	Input: Signed 16 bit linear sample
//	Output: 8 bit ulaw sample
//
static unsigned char linear2ulaw(int sample)
{
	static int exp_lut[256] =
	{
		0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
		5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
	};

	int sign;
	int exponent;
	int mantissa;
	unsigned char ulawbyte;

	//
	// get the sample into sign-magnitude
	//

	// set aside the sign
	//
	sign = (sample >> 8) & 0x80;

	// get magnitude
	//
	if (sign != 0)
		sample = -sample;


	// clip the magnitude
	//
	if (sample > CLIP)
		sample = CLIP;

	//
	// convert from 16 bit linear to ulaw
	//

	sample = sample + BIAS;
	exponent = exp_lut[(sample >> 7) & 0xFF];
	mantissa = (sample >> (exponent + 3)) & 0x0F;
	ulawbyte = ~(sign | (exponent << 4) | mantissa);

#ifdef ZEROTRAP
	// optional CCITT trap
	//
	if (ulawbyte == 0)
		ulawbyte = 0x02;
#endif

	return ulawbyte;
}

//// ulaw2linear - this routine converts from ulaw to 16 bit linear
//
//	Craig Reese: IDA/Supercomputing Research Center
//	29 September 1989
//
//	References:
//	1)	CCITT Recommendation G.711  (very difficult to follow)
//	2)	MIL-STD-188-113, "Interoperability and Performance Standards
//		for Analog-to-Digital Conversion Techniques,"
//		17 February 1987
//
//	Input: 8 bit ulaw sample
//	Output: Signed 16 bit linear sample
//
static int ulaw2linear(unsigned char ulawbyte)
{
	static int exp_lut[8] =
	{
		0, 132, 396, 924, 1980, 4092, 8316, 16764
	};

	int sign;
	int exponent;
	int mantissa;
	int sample;

	ulawbyte = ~ulawbyte;
	sign = (ulawbyte & 0x80);
	exponent = (ulawbyte >> 4) & 0x07;
	mantissa = ulawbyte & 0x0F;
	sample = exp_lut[exponent] + (mantissa << (exponent + 3));
	if (sign != 0)
		sample = -sample;

	return sample;
}

////
//	installable file i/o procedures
////

static LRESULT MulawIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = NULL;
	MMIOINFO mmioinfo;
	HMULAW hMulaw = NULL;
	HINSTANCE hInst;

 	TracePrintf_1(NULL, 5,
 		TEXT("MulawIOOpen (%s)\n"),
		(LPTSTR) lpszFileName);

	MemSet(&mmioinfo, 0, sizeof(mmioinfo));

	// interpret first value passed as pointer to next i/o procedure in chain
	//
	mmioinfo.pIOProc = (LPMMIOPROC) lpmmioinfo->adwInfo[0];

	// pass along second and third values to next i/o procedure
	//
	mmioinfo.adwInfo[0] = lpmmioinfo->adwInfo[1];
	mmioinfo.adwInfo[1] = lpmmioinfo->adwInfo[2];
	mmioinfo.adwInfo[2] = 0L;

	// get instance handle of current task
	//
	if ((hInst = SysGetTaskInstance(NULL)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hMulaw = MulawInit(MULAW_VERSION, hInst, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hmmio = mmioOpen(lpszFileName, &mmioinfo, lpmmioinfo->dwFlags)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// save stuff for use in other i/o routines
		//
		lpmmioinfo->adwInfo[0] = (DWORD) (LPVOID) hmmio;
		lpmmioinfo->adwInfo[1] = (DWORD) (LPVOID) hMulaw;
	}

	// clean up after error
	//
	if (!fSuccess && hMulaw != NULL && MulawTerm(hMulaw) != 0)
		fSuccess = TraceFALSE(NULL);

	if (!fSuccess && hmmio != NULL && mmioClose(hmmio, 0) != 0)
		fSuccess = TraceFALSE(NULL);

	// return the same error code given by mmioOpen
	//
	return fSuccess ? lpmmioinfo->wErrorRet = mmioinfo.wErrorRet : MMIOERR_CANNOTOPEN;
}

static LRESULT MulawIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	HMULAW hMulaw = (HMULAW) lpmmioinfo->adwInfo[1];
	UINT uRet = MMIOERR_CANNOTCLOSE;

 	TracePrintf_0(NULL, 5,
 		TEXT("MulawIOClose\n"));

	if (MulawTerm(hMulaw) != 0)
		fSuccess = TraceFALSE(NULL);

	else if ((uRet = mmioClose(hmmio, uFlags)) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpmmioinfo->adwInfo[0] = (DWORD) NULL;
		lpmmioinfo->adwInfo[1] = (DWORD) NULL;
	}

	return fSuccess ? 0 : uRet;
}

static LRESULT MulawIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	HMULAW hMulaw = (HMULAW) lpmmioinfo->adwInfo[1];
	HPSTR pchMulaw = NULL;
	LONG cchMulaw;
	LONG lBytesRead;

 	TracePrintf_1(NULL, 5,
 		TEXT("MulawIORead (%ld)\n"),
		(long) cch);

	// mulaw format files contain 8 bit samples,
	// but we must simulate access to 16 bit samples.
	//
	cchMulaw = cch / 2L;
	
	if (cchMulaw <= 0)
		lBytesRead = 0; // nothing to do

	// allocate temporary buffer to hold the mulaw format samples
	//
	else if ((pchMulaw = (HPSTR) MemAlloc(NULL, cchMulaw, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// read mulaw format samples
	//
	else if ((lBytesRead = mmioRead(hmmio, pchMulaw, cchMulaw)) == -1)
		fSuccess = TraceFALSE(NULL);

	// decode mulaw format samples into pcm format samples
	//
	else if (MulawDecode(hMulaw, (LPBYTE) pchMulaw, (LPPCM16) pch, (UINT) lBytesRead) != 0)
		fSuccess = TraceFALSE(NULL);

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset += lBytesRead * 2L;

	// clean up
	//
	if (pchMulaw != NULL &&
		(pchMulaw = MemFree(NULL, pchMulaw)) != NULL)
		fSuccess = TraceFALSE(NULL);

 	TracePrintf_2(NULL, 5,
 		TEXT("MulawIO: lpmmioinfo->lDiskOffset=%ld, lBytesRead=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesRead);

	// return number of bytes read/decoded into pch
	//
	return fSuccess ? lBytesRead * 4L : -1;
}

static LRESULT MulawIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	HMULAW hMulaw = (HMULAW) lpmmioinfo->adwInfo[1];
	HPSTR pchMulaw = NULL;
	LONG cchMulaw;
	LONG lBytesWritten;

 	TracePrintf_1(NULL, 5,
 		TEXT("MulawIOWrite (%ld)\n"),
		(long) cch);

	// mulaw format files contain 8 bit samples,
	// but we must simulate access to 16 bit samples.
	//
	cchMulaw = cch / 2L;
	
	if (cchMulaw <= 0)
		lBytesWritten = 0; // nothing to do

	// allocate temporary buffer to hold the mulaw format samples
	//
	else if ((pchMulaw = (HPSTR) MemAlloc(NULL, cchMulaw, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// encode pcm format samples into mulaw format samples
	// (there are 2 bytes required for each pcm sample)
	//
	else if (MulawEncode(hMulaw, (LPPCM16) pch, (LPBYTE) pchMulaw, (UINT) (cch / 2L)) != 0)
		fSuccess = TraceFALSE(NULL);

	// write mulaw format samples
	//
	else if ((lBytesWritten = mmioWrite(hmmio, pchMulaw, cchMulaw)) == -1)
		fSuccess = TraceFALSE(NULL);

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset += lBytesWritten * 2L;

	// clean up
	//
	if (pchMulaw != NULL &&
		(pchMulaw = MemFree(NULL, pchMulaw)) != NULL)
		fSuccess = TraceFALSE(NULL);

 	TracePrintf_2(NULL, 5,
 		TEXT("MulawIO: lpmmioinfo->lDiskOffset=%ld, lBytesWritten=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesWritten);

	// return number of bytes encoded/written from pch
	//
	return fSuccess ? lBytesWritten * 2L : -1;
}

static LRESULT MulawIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	LONG lPosNew;

 	TracePrintf_2(NULL, 5,
 		TEXT("MulawIOSeek (%ld, %d)\n"),
		(long) lOffset,
		(int) iOrigin);

	// mulaw format files contain 8 bit samples,
	// but we must simulate access to 16 bit samples.
	//
	if ((lPosNew = mmioSeek(hmmio, lOffset / 2L, iOrigin)) == -1)
		fSuccess = TraceFALSE(NULL);

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset = lPosNew * 2L;

 	TracePrintf_1(NULL, 5,
 		TEXT("MulawIO: lpmmioinfo->lDiskOffset=%ld\n"),
		(long) lpmmioinfo->lDiskOffset);

	return fSuccess ? lpmmioinfo->lDiskOffset : -1;
}

static LRESULT MulawIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName)
{
	BOOL fSuccess = TRUE;
	UINT uRet = MMIOERR_FILENOTFOUND;

 	TracePrintf_2(NULL, 5,
 		TEXT("MulawIORename (%s, %s)\n"),
		(LPTSTR) lpszFileName,
		(LPTSTR) lpszNewFileName);

	if ((uRet = mmioRename(lpszFileName, lpszNewFileName, lpmmioinfo, 0)) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\awav.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// awav.h - interface for command line awavument functions in awav.c
////

#ifndef __AWAV_H__
#define __AWAV_H__

#include "winlocal.h"

#include "wav.h"

#define AWAV_VERSION 0x00000100

// handle to awav engine
//
DECLARE_HANDLE32(HAWAV);

#ifdef __cplusplus
extern "C" {
#endif

// AWavOpen - initialize array of open wav files
//		<dwVersion>			(i) must be AWAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpahWav>			(i) pointer to array of HWAVs
//		<chWav>				(i) count of HWAVs pointed to by lpahWav
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return handle (NULL if error)
//
HAWAV DLLEXPORT WINAPI AWavOpen(DWORD dwVersion, HINSTANCE hInst, HWAV FAR *lpahWav, int chWav, DWORD dwFlags);

// AWavClose - shut down array of open wav files
//		<hAWav>				(i) handle returned from AWavOpen
// return 0 if success
//
int DLLEXPORT WINAPI AWavClose(HAWAV hAWav);

// AWavPlayEx - play array of wav files
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavPlayEx() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavPlayEx(HAWAV hAWav, int idDev,
	PLAYSTOPPEDPROC lpfnPlayStopped, HANDLE hUserPlayStopped,
	DWORD dwReserved, DWORD dwFlags);

// AWavStop - stop playing wav array
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavStop() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavStop(HAWAV hAWav);

// AWavGetState - return current wav state
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetState() for further description
// return WAV_STOPPED, WAV_PLAYING, WAV_RECORDING, or 0 if error
//
WORD DLLEXPORT WINAPI AWavGetState(HAWAV hAWav);

// AWavGetLength - get current wav data length in milleseconds
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetState() for further description
// return milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI AWavGetLength(HAWAV hAWav);

// AWavGetPosition - get current wav data position in milleseconds
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetPosition() for further description
// return milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI AWavGetPosition(HAWAV hAWav);

// AWavSetPosition - set current wav data position in milleseconds
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavSetPosition() for further description
// return new position in milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI AWavSetPosition(HAWAV hAWav, long msPosition);

// AWavGetFormat - get wav format of current element in wav array
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetFormat() for further description
// return pointer to specified format, NULL if error
//
LPWAVEFORMATEX DLLEXPORT WINAPI AWavGetFormat(HAWAV hAWav, DWORD dwFlags);

// AWavSetFormat - set wav format for all elements in wav array
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavSetFormat() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavSetFormat(HAWAV hAWav,
	LPWAVEFORMATEX lpwfx, DWORD dwFlags);

// AWavChooseFormat - choose and set audio format from dialog box
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavChooseFormat() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavChooseFormat(HAWAV hAWav, HWND hwndOwner, LPCTSTR lpszTitle, DWORD dwFlags);

// AWavGetVolume - get current volume level
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetVolume() for further description
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int DLLEXPORT WINAPI AWavGetVolume(HAWAV hAWav, int idDev, DWORD dwFlags);

// AWavSetVolume - set current volume level
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetVolume() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavSetVolume(HAWAV hAWav, int idDev, int nLevel, DWORD dwFlags);

// AWavSupportsVolume - check if audio can be played at specified volume
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavSupportsVolume() for further description
// return TRUE if supported
//
BOOL DLLEXPORT WINAPI AWavSupportsVolume(HAWAV hAWav, int idDev, int nLevel, DWORD dwFlags);

// AWavGetSpeed - get current speed level
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetSpeed() for further description
// return speed level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI AWavGetSpeed(HAWAV hAWav, int idDev, DWORD dwFlags);

// AWavSetSpeed - set current speed level
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavSetSpeed() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavSetSpeed(HAWAV hAWav, int idDev, int nLevel, DWORD dwFlags);

// AWavSupportsSpeed - check if audio can be played at specified speed
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavSupportsSpeed() for further description
// return TRUE if supported
//
BOOL DLLEXPORT WINAPI AWavSupportsSpeed(HAWAV hAWav, int idDev, int nLevel, DWORD dwFlags);

// AWavGetChunks - get chunk count and size of current element in wav array
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetChunks() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavGetChunks(HAWAV hAWav,
	int FAR *lpcChunks, long FAR *lpmsChunkSize, BOOL fWavOut);

// AWavSetChunks - set chunk count and size of all elements in wav array
//		<hAWav>				(i) handle returned from WavOpen
//		see WavSetChunks() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavSetChunks(HAWAV hAWav, int cChunks, long msChunkSize, BOOL fWavOut);

// AWavCopy - copy data from wav array to wav file
//		<hAWavSrc>			(i) source handle returned from AWavOpen
//		see WavCopy() for further description
// return 0 if success (-1 if error, +1 if user abort)
//
int DLLEXPORT WINAPI AWavCopy(HAWAV hAWavSrc, HWAV hWavDst,
	void _huge *hpBuf, long sizBuf, USERABORTPROC lpfnUserAbort, DWORD dwUser, DWORD dwFlags);

// AWavGetOutputDevice - get handle to open wav output device
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetOutputDevice() for further description
// return handle to wav output device (NULL if device not open or error)
//
HWAVOUT DLLEXPORT WINAPI AWavGetOutputDevice(HAWAV hAWav);

// AWavGetInputDevice - get handle to open wav input device
//		<hAWav>				(i) handle returned from AWavOpen
// return handle to wav input device (NULL if device not open or error)
//
HWAVIN DLLEXPORT WINAPI AWavGetInputDevice(HAWAV hAWav);

#ifdef __cplusplus
}
#endif

#endif // __AWAV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\awav.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	awav.c - wav array functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "awav.h"
#include "wav.h"
#include "mem.h"
#include "trace.h"

////
//	private definitions
////

// awav control struct
//
typedef struct AWAV
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HWAV FAR *lpahWav;
	int chWav;
	int ihWav;
	int idDev;
	PLAYSTOPPEDPROC lpfnPlayStopped;
	HANDLE hUserPlayStopped;
	DWORD dwReserved;
	DWORD dwFlags;
	BOOL fStopping;
} AWAV, FAR *LPAWAV;

// helper functions
//
static LPAWAV AWavGetPtr(HAWAV hAWav);
static HAWAV AWavGetHandle(LPAWAV lpAWav);
BOOL CALLBACK PlayStoppedProc(HWAV hWav, HANDLE hUser, DWORD dwReserved);

////
//	public functions
////

// AWavOpen - initialize array of open wav files
//		<dwVersion>			(i) must be AWAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpahWav>			(i) pointer to array of HWAVs
//		<chWav>				(i) count of HWAVs pointed to by lpahWav
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return handle (NULL if error)
//
HAWAV DLLEXPORT WINAPI AWavOpen(DWORD dwVersion, HINSTANCE hInst, HWAV FAR *lpahWav, int chWav, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav = NULL;

	if (dwVersion != AWAV_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);
                        
	else if (lpahWav == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (chWav < 1)
		fSuccess = TraceFALSE(NULL);

	else if ((lpAWav = (LPAWAV) MemAlloc(NULL, sizeof(AWAV), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpAWav->dwVersion = dwVersion;
		lpAWav->hInst = hInst;
		lpAWav->hTask = GetCurrentTask();
		lpAWav->lpahWav = lpahWav;
		lpAWav->chWav = chWav;
		lpAWav->ihWav = 0;
		lpAWav->idDev = 0;
		lpAWav->lpfnPlayStopped = NULL;
		lpAWav->hUserPlayStopped = 0;
		lpAWav->dwReserved = 0;
		lpAWav->dwFlags = 0;
		lpAWav->fStopping = FALSE;
	}

	if (!fSuccess)
	{
		AWavClose(AWavGetHandle(lpAWav));
		lpAWav = NULL;
	}

	return fSuccess ? AWavGetHandle(lpAWav) : NULL;
}

// AWavClose - shut down array of open wav files
//		<hAWav>				(i) handle returned from AWavOpen
// return 0 if success
//
int DLLEXPORT WINAPI AWavClose(HAWAV hAWav)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// make sure playback is complete
		//
		if (AWavStop(hAWav) != 0)
			fSuccess = TraceFALSE(NULL);

		else if ((lpAWav = MemFree(NULL, lpAWav)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// AWavPlayEx - play array of wav files
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavPlayEx() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavPlayEx(HAWAV hAWav, int idDev,
	PLAYSTOPPEDPROC lpfnPlayStopped, HANDLE hUserPlayStopped,
	DWORD dwReserved, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure we are not playing
	//
	else if (AWavStop(hAWav) != 0)
		fSuccess = TraceFALSE(NULL);

	// save params so we can use them for each element in array
	//
	else if (lpAWav->idDev = idDev, FALSE)
		;
	else if (lpAWav->lpfnPlayStopped = lpfnPlayStopped, FALSE)
		;
	else if (lpAWav->hUserPlayStopped = hUserPlayStopped, FALSE)
		;
	else if (lpAWav->dwReserved = dwReserved, FALSE)
		;
	else if (lpAWav->dwFlags = dwFlags, FALSE)
		;

	// start playback of current element in wav array
	//
	else if (WavPlayEx(*(lpAWav->lpahWav + lpAWav->ihWav),
		lpAWav->idDev, PlayStoppedProc, hAWav,
		lpAWav->dwReserved, lpAWav->dwFlags) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// AWavStop - stop playing wav array
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavStop() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavStop(HAWAV hAWav)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// set flag for use in PlayStoppedProc
	//
	else if (lpAWav->fStopping = TRUE, FALSE)
		;

	// stop playback of current element in wav array
	//
	else if (WavStop(*(lpAWav->lpahWav + lpAWav->ihWav)) != 0)
		fSuccess = TraceFALSE(NULL);

	// clear flag used in PlayStoppedProc
	//
	if (lpAWav != NULL)
		lpAWav->fStopping = FALSE;

	return fSuccess ? 0 : -1;
}

// AWavGetState - return current wav state
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetState() for further description
// return WAV_STOPPED, WAV_PLAYING, WAV_RECORDING, or 0 if error
//
WORD DLLEXPORT WINAPI AWavGetState(HAWAV hAWav)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	WORD wState = WAV_STOPPED;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// get state of current element in wav array
		//
		wState = WavGetState(*(lpAWav->lpahWav + lpAWav->ihWav));
	}

	return fSuccess ? wState : 0;
}

// AWavGetLength - get current wav data length in milleseconds
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetState() for further description
// return milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI AWavGetLength(HAWAV hAWav)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	long msLength = 0;
	int ihWav;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// simulated length is calculated as
	// total length of each element in wav array
	//
	else for (ihWav = 0; fSuccess && ihWav < lpAWav->chWav; ++ihWav)
	{
		long msTemp;

		if ((msTemp = WavGetLength(*(lpAWav->lpahWav + ihWav))) < 0)
			fSuccess = TraceFALSE(NULL);
		else
			msLength += msTemp;
	}

	return fSuccess ? msLength : -1;
}

// AWavGetPosition - get current wav data position in milleseconds
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetPosition() for further description
// return milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI AWavGetPosition(HAWAV hAWav)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	long msPos = 0;
	int ihWav;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// simulated position is calculated as
	// total length of previous elements plus position of current element
	//
	else for (ihWav = 0; fSuccess && ihWav <= lpAWav->ihWav; ++ihWav)
	{
		long msTemp = 0;

		if (ihWav < lpAWav->ihWav &&
			(msTemp = WavGetLength(*(lpAWav->lpahWav + ihWav))) < 0)
			fSuccess = TraceFALSE(NULL);

		else if (ihWav == lpAWav->ihWav &&
			(msTemp = WavGetPosition(*(lpAWav->lpahWav + ihWav))) < 0)
			fSuccess = TraceFALSE(NULL);

		msPos += msTemp;
	}

	return fSuccess ? msPos : -1;
}

// AWavSetPosition - set current wav data position in milleseconds
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavSetPosition() for further description
// return new position in milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI AWavSetPosition(HAWAV hAWav, long msPosition)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	int ihWav;
	long msPos = 0;
	BOOL fPosSet = FALSE;
	BOOL fRestart = FALSE;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure requested position is reasonable
	//
	else if (msPosition < 0 || msPosition > AWavGetLength(hAWav))
		fSuccess = TraceFALSE(NULL);

	// search for the element which contains requested position
	//
	else for (ihWav = 0; fSuccess && ihWav < lpAWav->chWav; ++ihWav)
	{
		long msTemp;

		if (WavGetState(*(lpAWav->lpahWav + ihWav)) == WAV_PLAYING)
		{
			// set flag for use in PlayStoppedProc
			//
			if (lpAWav->fStopping = TRUE, FALSE)
				;

			// stop playback of current element in wav array
			//
			else if (WavStop(*(lpAWav->lpahWav + ihWav)) != 0)
				fSuccess = TraceFALSE(NULL);

			// clear flag used in PlayStoppedProc
			//
			if (lpAWav != NULL)
				lpAWav->fStopping = FALSE;

			// remember to restart playback later
			//
			fRestart = TRUE;
		}

		if ((msTemp = WavGetLength(*(lpAWav->lpahWav + ihWav))) < 0)
			fSuccess = TraceFALSE(NULL);

		if (fPosSet)
		{
			// all elements after the current one should have zero position
			//
			if ((msTemp = WavSetPosition(*(lpAWav->lpahWav + ihWav), 0)) < 0)
				fSuccess = TraceFALSE(NULL);
		}

		else if (msPosition < msPos + msTemp)
		{
			// set relative position within current element
			//
			if ((msTemp = WavSetPosition(*(lpAWav->lpahWav + ihWav),
				msPosition - msPos)) < 0)
				fSuccess = TraceFALSE(NULL);
			else
			{
				// keep track of simulated position
				//
				msPos += msTemp;

				// this element becomes the current one
				//
				lpAWav->ihWav = ihWav;

				fPosSet = TRUE;
			}
		}

		else
		{
		 	msPos += msTemp;

			// all elements before the current one should have zero position
			//
			if ((msTemp = WavSetPosition(*(lpAWav->lpahWav + ihWav), 0)) < 0)
				fSuccess = TraceFALSE(NULL);
		}
	}

	// if necessary, restart playback of current element in wav array
	//
	if (fSuccess && fRestart &&
		WavPlayEx(*(lpAWav->lpahWav + lpAWav->ihWav),
		lpAWav->idDev, PlayStoppedProc, hAWav,
		lpAWav->dwReserved, lpAWav->dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? msPos : -1;
}

// AWavGetFormat - get wav format of current element in wav array
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetFormat() for further description
// return pointer to specified format, NULL if error
//
LPWAVEFORMATEX DLLEXPORT WINAPI AWavGetFormat(HAWAV hAWav, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	LPWAVEFORMATEX lpwfx;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get format of current element
	//
	else if ((lpwfx = WavGetFormat(*(lpAWav->lpahWav + lpAWav->ihWav), dwFlags)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpwfx : NULL;
}

// AWavSetFormat - set wav format for all elements in wav array
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavSetFormat() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavSetFormat(HAWAV hAWav,
	LPWAVEFORMATEX lpwfx, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	int ihWav;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// set format for all elements
	//
	else for (ihWav = 0; fSuccess && ihWav < lpAWav->chWav; ++ihWav)
	{
		if (WavSetFormat(*(lpAWav->lpahWav + ihWav), lpwfx, dwFlags) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// AWavChooseFormat - choose and set audio format from dialog box
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavChooseFormat() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavChooseFormat(HAWAV hAWav, HWND hwndOwner, LPCTSTR lpszTitle, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	int ihWav;
	LPWAVEFORMATEX lpwfx = NULL;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// choose and set format for current element
	//
	else if (WavChooseFormat(*(lpAWav->lpahWav + lpAWav->ihWav), hwndOwner, lpszTitle, dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);

	// get chosen format
	//
	else if ((lpwfx = WavGetFormat(*(lpAWav->lpahWav + lpAWav->ihWav), dwFlags)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// set chosen format for all other elements
	//
	else for (ihWav = 0; fSuccess && ihWav < lpAWav->chWav; ++ihWav)
	{
		if (ihWav != lpAWav->ihWav)
		{
			if (WavSetFormat(*(lpAWav->lpahWav + ihWav), lpwfx, dwFlags) != 0)
				fSuccess = TraceFALSE(NULL);
		}
	}

	if (lpwfx != NULL && WavFormatFree(lpwfx) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// AWavGetVolume - get current volume level
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetVolume() for further description
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int DLLEXPORT WINAPI AWavGetVolume(HAWAV hAWav, int idDev, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	int nLevel;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get volume of current element
	//
	else if ((nLevel = WavGetVolume(*(lpAWav->lpahWav + lpAWav->ihWav), idDev, dwFlags)) < 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? nLevel : -1;
}

// AWavSetVolume - set current volume level
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetVolume() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavSetVolume(HAWAV hAWav, int idDev, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	int ihWav;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// set volume for all elements
	//
	else for (ihWav = 0; fSuccess && ihWav < lpAWav->chWav; ++ihWav)
	{
		if (WavSetVolume(*(lpAWav->lpahWav + ihWav), idDev, nLevel, dwFlags) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// AWavSupportsVolume - check if audio can be played at specified volume
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavSupportsVolume() for further description
// return TRUE if supported
//
BOOL DLLEXPORT WINAPI AWavSupportsVolume(HAWAV hAWav, int idDev, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	int ihWav;
	BOOL fSupported = TRUE;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// see if all elements support the specified volume
	//
	else for (ihWav = 0; fSuccess && ihWav < lpAWav->chWav; ++ihWav)
	{
		if (!WavSupportsVolume(*(lpAWav->lpahWav + ihWav), idDev, nLevel, dwFlags))
		{
			fSupported = FALSE;
			break;
		}
	}

	return fSuccess ? fSupported : FALSE;
}

// AWavGetSpeed - get current speed level
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetSpeed() for further description
// return speed level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI AWavGetSpeed(HAWAV hAWav, int idDev, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	int nLevel;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get speed of current element
	//
	else if ((nLevel = WavGetSpeed(*(lpAWav->lpahWav + lpAWav->ihWav), idDev, dwFlags)) < 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? nLevel : -1;
}

// AWavSetSpeed - set current speed level
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavSetSpeed() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavSetSpeed(HAWAV hAWav, int idDev, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	int ihWav;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// set speed for all elements
	//
	else for (ihWav = 0; fSuccess && ihWav < lpAWav->chWav; ++ihWav)
	{
		if (WavSetSpeed(*(lpAWav->lpahWav + ihWav), idDev, nLevel, dwFlags) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// AWavSupportsSpeed - check if audio can be played at specified speed
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavSupportsSpeed() for further description
// return TRUE if supported
//
BOOL DLLEXPORT WINAPI AWavSupportsSpeed(HAWAV hAWav, int idDev, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	int ihWav;
	BOOL fSupported = TRUE;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// see if all elements support the specified speed
	//
	else for (ihWav = 0; fSuccess && ihWav < lpAWav->chWav; ++ihWav)
	{
		if (!WavSupportsSpeed(*(lpAWav->lpahWav + ihWav), idDev, nLevel, dwFlags))
		{
			fSupported = FALSE;
			break;
		}
	}

	return fSuccess ? fSupported : FALSE;
}

// AWavGetChunks - get chunk count and size of current element in wav array
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetChunks() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavGetChunks(HAWAV hAWav,
	int FAR *lpcChunks, long FAR *lpmsChunkSize, BOOL fWavOut)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get chunk count and size of current element
	//
	else if (WavGetChunks(*(lpAWav->lpahWav + lpAWav->ihWav),
		lpcChunks, lpmsChunkSize, fWavOut) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// AWavSetChunks - set chunk count and size of all elements in wav array
//		<hAWav>				(i) handle returned from WavOpen
//		see WavSetChunks() for further description
// return 0 if success
//
int DLLEXPORT WINAPI AWavSetChunks(HAWAV hAWav, int cChunks, long msChunkSize, BOOL fWavOut)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	int ihWav;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// set chunk count and size for all elements
	//
	else for (ihWav = 0; fSuccess && ihWav < lpAWav->chWav; ++ihWav)
	{
		if (WavSetChunks(*(lpAWav->lpahWav + ihWav), cChunks, msChunkSize, fWavOut) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// AWavCopy - copy data from wav array to wav file
//		<hAWavSrc>			(i) source handle returned from AWavOpen
//		see WavCopy() for further description
// return 0 if success (-1 if error, +1 if user abort)
//
int DLLEXPORT WINAPI AWavCopy(HAWAV hAWavSrc, HWAV hWavDst,
	void _huge *hpBuf, long sizBuf, USERABORTPROC lpfnUserAbort, DWORD dwUser, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	int ihWav;
	int iRet = 0;

	if ((lpAWav = AWavGetPtr(hAWavSrc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// copy each source element to destination
	//
	else for (ihWav = 0; fSuccess && ihWav < lpAWav->chWav; ++ihWav)
	{
		if ((iRet = WavCopy(*(lpAWav->lpahWav + ihWav), hWavDst,
			hpBuf, sizBuf, lpfnUserAbort, dwUser, dwFlags)) == -1)
			fSuccess = TraceFALSE(NULL);
		else if (iRet == +1)
			break; // user abort
	}

	return fSuccess ? iRet : -1;
}

// AWavGetOutputDevice - get handle to open wav output device
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetOutputDevice() for further description
// return handle to wav output device (NULL if device not open or error)
//
HWAVOUT DLLEXPORT WINAPI AWavGetOutputDevice(HAWAV hAWav)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	HWAVOUT hWavOut;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get device handle of current element
	//
	else if ((hWavOut = WavGetOutputDevice(*(lpAWav->lpahWav + lpAWav->ihWav))) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hWavOut : NULL;
}

// AWavGetInputDevice - get handle to open wav input device
//		<hAWav>				(i) handle returned from AWavOpen
// return handle to wav input device (NULL if device not open or error)
//
HWAVIN DLLEXPORT WINAPI AWavGetInputDevice(HAWAV hAWav)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;
	HWAVIN hWavIn;

	if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get device handle of current element
	//
	else if ((hWavIn = WavGetInputDevice(*(lpAWav->lpahWav + lpAWav->ihWav))) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hWavIn : NULL;
}

////
//	helper functions
////

// AWavGetPtr - verify that awav handle is valid,
//		<hAWav>				(i) handle returned from AWavOpen
//		see WavGetInputDevice() for further description
// return corresponding awav pointer (NULL if error)
//
static LPAWAV AWavGetPtr(HAWAV hAWav)
{
	BOOL fSuccess = TRUE;
	LPAWAV lpAWav;

	if ((lpAWav = (LPAWAV) hAWav) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpAWav, sizeof(AWAV)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the awav handle
	//
	else if (lpAWav->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpAWav : NULL;
}

// AWavGetHandle - verify that awav pointer is valid,
//		<lpAWav>				(i) pointer to AWAV struct
// return corresponding awav handle (NULL if error)
//
static HAWAV AWavGetHandle(LPAWAV lpAWav)
{
	BOOL fSuccess = TRUE;
	HAWAV hAWav;

	if ((hAWav = (HAWAV) lpAWav) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hAWav : NULL;
}

BOOL CALLBACK PlayStoppedProc(HWAV hWav, HANDLE hUser, DWORD dwReserved)
{
	BOOL fSuccess = TRUE;
	BOOL bRet = TRUE;
	HAWAV hAWav;
	LPAWAV lpAWav;

	if ((hAWav = hUser) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpAWav = AWavGetPtr(hAWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!lpAWav->fStopping && lpAWav->ihWav + 1 < lpAWav->chWav)
	{
		// start playback of next wav array element
		//
		if (WavPlayEx(*(lpAWav->lpahWav + (++lpAWav->ihWav)),
			lpAWav->idDev, PlayStoppedProc, hAWav,
			lpAWav->dwReserved, lpAWav->dwFlags) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}

	else
	{
		// playback of entire array is complete; send notification
		//
		if (lpAWav->lpfnPlayStopped != NULL)
			(*lpAWav->lpfnPlayStopped)((HWAV) hAWav, lpAWav->hUserPlayStopped, 0);
	}

	return fSuccess ? bRet : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\pcm.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	pcm.c - pcm functions
////

#include "winlocal.h"

#include "pcm.h"
#include "calc.h"
#include "mem.h"
#include "trace.h"

////
//	private definitions
////

// macros to convert PCM samples to/from other sizes
//
#define _Pcm8To16(pcm8) (((PCM16) (pcm8) - 128) << 8)
#define _Pcm16To8(pcm16) ((PCM8) (((PCM16) (pcm16) >> 8) + 128))

#define BYTESPERSAMPLE(nBitsPerSample) (nBitsPerSample > 8 ? 2 : 1)

// pcm control struct
//
typedef struct PCM
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	DWORD dwFlags;
	short nCounter;
	PCM16 pcm16Prev;
	PCM16 pcm16Prev0F;
	PCM16 pcm16Prev1F;
	PCM16 pcm16Prev2F;
	PCM16 pcm16Prev0;
	PCM16 pcm16Prev1;
	PCM16 pcm16Prev2;
} PCM, FAR *LPPCM;

// helper functions
//
static UINT PcmResampleCalcDstMax(HPCM hPcm,
	long nSamplesPerSecSrc, long nSamplesPerSecDst,	UINT uSamples);
static UINT PcmResample6Kto8K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample6Kto11K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample6Kto22K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample6Kto44K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample8Kto6K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample8Kto11K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample8Kto22K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample8Kto44K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample11Kto6K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample11Kto8K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample11Kto22K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample11Kto44K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample22Kto6K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample22Kto8K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample22Kto11K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample22Kto44K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample44Kto6K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample44Kto8K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample44Kto11K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static UINT PcmResample44Kto22K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples);
static LPPCM PcmGetPtr(HPCM hPcm);
static HPCM PcmGetHandle(LPPCM lpPcm);

////
//	public functions
////

// PcmInit - initialize pcm engine
//		<dwVersion>			(i) must be PCM_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) reserved; must be 0
// return handle (NULL if error)
//
HPCM DLLEXPORT WINAPI PcmInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm = NULL;

	if (dwVersion != PCM_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpPcm = (LPPCM) MemAlloc(NULL, sizeof(PCM), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpPcm->dwVersion = dwVersion;
		lpPcm->hInst = hInst;
		lpPcm->hTask = GetCurrentTask();
		lpPcm->dwFlags = dwFlags;

		if (PcmReset(PcmGetHandle(lpPcm)) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (!fSuccess)
	{
		PcmTerm(PcmGetHandle(lpPcm));
		lpPcm = NULL;
	}

	return fSuccess ? PcmGetHandle(lpPcm) : NULL;
}

// PcmTerm - shut down pcm engine
//		<hPcm>				(i) handle returned from PcmInit
// return 0 if success
//
int DLLEXPORT WINAPI PcmTerm(HPCM hPcm)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm;

	if ((lpPcm = PcmGetPtr(hPcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpPcm = MemFree(NULL, lpPcm)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// PcmReset - reset pcm engine
//		<hPcm>				(i) handle returned from PcmInit
// return 0 if success
//
int DLLEXPORT WINAPI PcmReset(HPCM hPcm)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm;
	
	if ((lpPcm = PcmGetPtr(hPcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpPcm->nCounter = -1;
		lpPcm->pcm16Prev = 0;
		lpPcm->pcm16Prev0F = 0;
		lpPcm->pcm16Prev1F = 0;
		lpPcm->pcm16Prev2F = 0;
		lpPcm->pcm16Prev0 = 0;
		lpPcm->pcm16Prev1 = 0;
		lpPcm->pcm16Prev2 = 0;
	}

	return fSuccess ? 0 : -1;
}

// PcmCalcSizBufSrc - calculate source buffer size
//		<hPcm>				(i) handle returned from PcmInit
//		<sizBufDst>			(i) size of destination buffer in bytes
//		<lpwfxSrc>			(i) source wav format
//		<lpwfxDst>			(i) destination wav format
// return source buffer size, -1 if error
//
long DLLEXPORT WINAPI PcmCalcSizBufSrc(HPCM hPcm, long sizBufDst,
	LPWAVEFORMATEX lpwfxSrc, LPWAVEFORMATEX lpwfxDst)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm;
	long sizBufSrc;
	UINT uSamplesDst;
	UINT uSamplesSrc;

	if ((lpPcm = PcmGetPtr(hPcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// calc how many samples can fit in destination buffer
	//
	else if ((uSamplesDst = (UINT) (sizBufDst /
		BYTESPERSAMPLE(lpwfxDst->wBitsPerSample))) <= 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// calc how many samples can fit in source buffer
	//
	else if ((uSamplesSrc = PcmResampleCalcDstMax(hPcm,
		lpwfxDst->nSamplesPerSec,
		lpwfxSrc->nSamplesPerSec, uSamplesDst)) <= 0)
	{
		fSuccess = TraceFALSE(NULL);
	}
		
	// calc size of source buffer
	//
	else if ((sizBufSrc = (long) (uSamplesSrc *
		BYTESPERSAMPLE(lpwfxSrc->wBitsPerSample))) <= 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? sizBufSrc : -1;
}

// PcmCalcSizBufDst - calculate destination buffer size
//		<hPcm>				(i) handle returned from PcmInit
//		<sizBufSrc>			(i) size of source buffer in bytes
//		<lpwfxSrc>			(i) source wav format
//		<lpwfxDst>			(i) destination wav format
// return destination buffer size, -1 if error
//
long DLLEXPORT WINAPI PcmCalcSizBufDst(HPCM hPcm, long sizBufSrc,
	LPWAVEFORMATEX lpwfxSrc, LPWAVEFORMATEX lpwfxDst)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm;
	long sizBufDst;
	UINT uSamplesSrc;
	UINT uSamplesDst;

	if ((lpPcm = PcmGetPtr(hPcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// calc how many samples can fit in source buffer
	//
	else if ((uSamplesSrc = (UINT) (sizBufSrc /
		BYTESPERSAMPLE(lpwfxSrc->wBitsPerSample))) <= 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// calc how many samples can fit in destination buffer
	//
	else if ((uSamplesDst = PcmResampleCalcDstMax(hPcm,
		lpwfxSrc->nSamplesPerSec,
		lpwfxDst->nSamplesPerSec, uSamplesSrc)) <= 0)
	{
		fSuccess = TraceFALSE(NULL);
	}
		
	// calc size of destination buffer
	//
	else if ((sizBufDst = (long) (uSamplesDst *
		BYTESPERSAMPLE(lpwfxDst->wBitsPerSample))) <= 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? sizBufDst : -1;
}

// PcmConvert - convert pcm data from one format to another
//		<hPcm>				(i) handle returned from PcmInit
//		<hpBufSrc> 			(i) buffer containing bytes to reformat
//		<sizBufSrc>			(i) size of buffer in bytes
//		<lpwfxSrc>			(i) source wav format
//		<hpBufDst> 			(o) buffer to contain new format
//		<sizBufDst>			(i) size of buffer in bytes
//		<lpwfxDst>			(i) destination wav format
//		<dwFlags>			(i) control flags
//			PCMFILTER_LOWPASS	perform lowpass filter
// return count of bytes in destination buffer (-1 if error)
//
// NOTE: the destination buffer must be large enough to hold the result
//
long DLLEXPORT WINAPI PcmConvert(HPCM hPcm,
	void _huge *hpBufSrc, long sizBufSrc, LPWAVEFORMATEX lpwfxSrc,
	void _huge *hpBufDst, long sizBufDst, LPWAVEFORMATEX lpwfxDst,
	DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm;
	BOOL fSampleRateChange = (BOOL)
		(lpwfxSrc->nSamplesPerSec != lpwfxDst->nSamplesPerSec);
	BOOL fSampleSizeChange = (BOOL)
		(lpwfxSrc->wBitsPerSample != lpwfxDst->wBitsPerSample);
	BOOL fChannelsChange = (BOOL)
		(lpwfxSrc->nChannels != lpwfxDst->nChannels);
	BOOL fLowPassFilter = (BOOL) (dwFlags & PCMFILTER_LOWPASS);
	BOOL fFormatChange = (BOOL)	(fSampleRateChange ||
		fSampleSizeChange || fChannelsChange || fLowPassFilter);
	UINT uSamples = (UINT) (sizBufSrc / BYTESPERSAMPLE(lpwfxSrc->wBitsPerSample));
	UINT uSamplesDst = uSamples;
	BOOL f8To16Bits = (BOOL) (lpwfxSrc->wBitsPerSample <= 8 &&
		(lpwfxDst->wBitsPerSample > 8 || fSampleRateChange || fLowPassFilter));
	BOOL f16To8Bits = (BOOL) (lpwfxDst->wBitsPerSample <= 8 &&
		(lpwfxSrc->wBitsPerSample > 8 || f8To16Bits));
	void _huge *hpBufSrcTmp = hpBufSrc;
	void _huge *hpBufDstTmp1 = NULL;
	void _huge *hpBufDstTmp2 = NULL;
	void _huge *hpBufDstTmp3 = NULL;

	if (!fFormatChange)
	{
		// nothing to do but copy
		//
		MemCpy(hpBufDst, hpBufSrc, min(sizBufDst, sizBufSrc));
	}

	else if ((lpPcm = PcmGetPtr(hPcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (hpBufSrc == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfxSrc))
		fSuccess = TraceFALSE(NULL);

	else if (hpBufDst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfxDst))
		fSuccess = TraceFALSE(NULL);

	// $FIXUP - we cannot handle reformatting of stereo
	//
	else if (lpwfxSrc->nChannels != 1)
		fSuccess = TraceFALSE(NULL);

	else if (lpwfxDst->nChannels != 1)
		fSuccess = TraceFALSE(NULL);

	// $FIXUP - we cannot handle reformatting of non-PCM data
	//
	else if (lpwfxSrc->wFormatTag != WAVE_FORMAT_PCM)
		fSuccess = TraceFALSE(NULL);

	else if (lpwfxDst->wFormatTag != WAVE_FORMAT_PCM)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// convert to 16 bit samples if necessary
		//
		if (f8To16Bits)
		{
			long sizBufTmp = uSamples * 2;

			// assume this is the last stage of the format
			//
			hpBufDstTmp1 = hpBufDst;

			// allocate temporary buffer if this is not the last stage
			//
			if ((fSampleRateChange || fLowPassFilter || f16To8Bits) &&
				(hpBufDstTmp1 = (void _huge *) MemAlloc(NULL,
				sizBufTmp, 0)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if (Pcm8To16(hPcm,
				(LPPCM8) hpBufSrcTmp, (LPPCM16) hpBufDstTmp1, uSamples) != 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else
			{
				// the source of the next stage will be this destination
				//
				hpBufSrcTmp = hpBufDstTmp1;
			}
		}

		// convert to new sample rate if necessary
		//
		if (fSuccess && fSampleRateChange)
		{
			long sizBufTmp;

			// assume this is the last stage of the format
			//
			hpBufDstTmp2 = hpBufDst;

			// calc size of temp buffer if this is not the last stage
			//
			if ((fLowPassFilter || f16To8Bits) &&
				(sizBufTmp = 2 * PcmResampleCalcDstMax(hPcm,
				lpwfxSrc->nSamplesPerSec, lpwfxDst->nSamplesPerSec, uSamples)) <= 0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		
			// allocate temporary buffer if this is not the last stage
			//
			else if ((fLowPassFilter || f16To8Bits) &&
				(hpBufDstTmp2 = (void _huge *) MemAlloc(NULL,
				sizBufTmp, 0)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// do the sample rate change
			//
			else if ((uSamplesDst = PcmResample(hPcm,
				(LPPCM16) hpBufSrcTmp, lpwfxSrc->nSamplesPerSec,
				(LPPCM16) hpBufDstTmp2, lpwfxDst->nSamplesPerSec, uSamples, 0)) <= 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else
			{
				// the source of the next stage will be this destination
				//
				hpBufSrcTmp = hpBufDstTmp2;
			}
		}

		// perform lowpass filter if necessary
		//
		if (fSuccess && fLowPassFilter)
		{
			long sizBufTmp = uSamplesDst * 2;

			// assume this is the last stage of the format
			//
			hpBufDstTmp3 = hpBufDst;

			// allocate temporary buffer if this is not the last stage
			//
			if (f16To8Bits &&
				(hpBufDstTmp3 = (void _huge *) MemAlloc(NULL,
				sizBufTmp, 0)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if (PcmFilter(hPcm, (LPPCM16) hpBufSrcTmp,
				(LPPCM16) hpBufDstTmp3, uSamples, PCMFILTER_LOWPASS) != 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else
			{
				// the source of the next stage will be this destination
				//
				hpBufSrcTmp = hpBufDstTmp3;
			}
		}

		// convert to 8 bit samples if necessary
		//
		if (fSuccess && f16To8Bits)
		{
			long sizBufTmp = uSamples;

			// this is the last stage of the format
			//
			if (Pcm16To8(hPcm,
				(LPPCM16) hpBufSrcTmp, (LPPCM8) hpBufDst, uSamples) != 0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}

		// clean up
		//
		if (hpBufDstTmp1 != NULL && hpBufDstTmp1 != hpBufDst &&
			(hpBufDstTmp1 = MemFree(NULL, hpBufDstTmp1)) != NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		if (hpBufDstTmp2 != NULL && hpBufDstTmp2 != hpBufDst &&
			(hpBufDstTmp2 = MemFree(NULL, hpBufDstTmp2)) != NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		if (hpBufDstTmp3 != NULL && hpBufDstTmp3 != hpBufDst &&
			(hpBufDstTmp3 = MemFree(NULL, hpBufDstTmp3)) != NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}
		
	return fSuccess ? (long) uSamplesDst *
		BYTESPERSAMPLE(lpwfxDst->wBitsPerSample) : -1;
}

// Pcm16To8 - convert 16-bit samples to 8-bit samples
//		<hPcm>				(i) handle returned from PcmInit
//		<lppcm16Src>		(i) buffer of source samples
//		<lppcm8Dst>			(o) buffer to hold destination samples
//		<uSamples>			(i) count of source samples to convert
// return 0 if success
//
int DLLEXPORT WINAPI Pcm16To8(HPCM hPcm,
	LPPCM16 lppcm16Src, LPPCM8 lppcm8Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm;

	if ((lpPcm = PcmGetPtr(hPcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lppcm16Src == NULL || lppcm8Dst == NULL)
		fSuccess = TraceFALSE(NULL);

	else while (uSamples-- > 0)
		*lppcm8Dst++ = _Pcm16To8(*lppcm16Src++);

	return fSuccess ? 0 : -1;
}

// Pcm8To16 - convert 8-bit samples to 16-bit samples
//		<hPcm>				(i) handle returned from PcmInit
//		<lppcm8Src>			(i) buffer of source samples
//		<lppcm16Dst>		(o) buffer to hold destination samples
//		<uSamples>			(i) count of source samples to convert
// return 0 if success
//
int DLLEXPORT WINAPI Pcm8To16(HPCM hPcm,
	LPPCM8 lppcm8Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm;

	if ((lpPcm = PcmGetPtr(hPcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lppcm8Src == NULL || lppcm16Dst == NULL)
		fSuccess = TraceFALSE(NULL);

	else while (uSamples-- > 0)
		*lppcm16Dst++ = _Pcm8To16(*lppcm8Src++);

	return fSuccess ? 0 : -1;
}

// PcmFilter - filter pcm samples
//		<hPcm>				(i) handle returned from PcmInit
//		<lppcm16Src>		(i) buffer of source samples
//		<lppcm16Dst>		(o) buffer to hold destination samples
//		<uSamples>			(i) count of source samples to filter
//		<dwFlags>			(i) control flags
//			PCMFILTER_LOWPASS	perform a low pass filter
// return 0 if success
//
// NOTE: <lppcm16Src> and <lppcm16Dst> can point to the same buffer
//
int DLLEXPORT WINAPI PcmFilter(HPCM hPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm;

	if ((lpPcm = PcmGetPtr(hPcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lppcm16Src == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lppcm16Dst == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		PCM16 pcm16Prev0F = lpPcm->pcm16Prev0F;
		PCM16 pcm16Prev1F = lpPcm->pcm16Prev1F;
		PCM16 pcm16Prev2F = lpPcm->pcm16Prev2F;

		while (uSamples-- > 0)
		{
			pcm16Prev2F = pcm16Prev1F;
			pcm16Prev1F = pcm16Prev0F;
			pcm16Prev0F = *lppcm16Src++;
			*lppcm16Dst++ = (PCM16) ((__int32) pcm16Prev0F +
				((__int32) pcm16Prev1F * 2) + (__int32) pcm16Prev2F) / 4;
		}

		lpPcm->pcm16Prev0F = pcm16Prev0F;
		lpPcm->pcm16Prev1F = pcm16Prev1F;
		lpPcm->pcm16Prev2F = pcm16Prev2F;
	}

	return fSuccess ? 0 : -1;
}

// PcmResample - resample pcm samples
//		<hPcm>				(i) handle returned from PcmInit
//		<lppcm16Src>		(i) buffer of source samples
//		<nSamplesPerSecSrc>	(i) sample rate of source samples
//		<lppcm16Dst>		(o) buffer to hold destination samples
//		<nSamplesPerSecDst>	(i) sample rate of destination samples
//		<uSamples>			(i) count of source samples to resample
//		<dwFlags>			(i) control flags
//			0					reserved, must be zero
// return count of samples in destination buffer (0 if error)
//
// NOTE: the destination buffer must be large enough to hold the result
//
UINT DLLEXPORT WINAPI PcmResample(HPCM hPcm,
	LPPCM16 lppcm16Src, long nSamplesPerSecSrc,
	LPPCM16 lppcm16Dst, long nSamplesPerSecDst,
	UINT uSamples, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm;
	UINT uSamplesDst;

	if ((lpPcm = PcmGetPtr(hPcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lppcm16Src == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lppcm16Dst == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (nSamplesPerSecSrc)
	{
		case 6000:
		{
			switch (nSamplesPerSecDst)
			{
				case 6000:
					// nothing to do but copy
					//
					MemCpy(lppcm16Dst, lppcm16Dst, uSamples * 2);
					uSamplesDst = uSamples;
					break;

				case 8000:
					uSamplesDst = PcmResample6Kto8K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 11025:
					uSamplesDst = PcmResample6Kto11K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 22050:
					uSamplesDst = PcmResample6Kto22K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 44100:
					uSamplesDst = PcmResample6Kto44K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				default:
					fSuccess = TraceFALSE(NULL);
					break;
			}
		}
			break;

		case 8000:
			switch (nSamplesPerSecDst)
			{
				case 6000:
					uSamplesDst = PcmResample8Kto6K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 8000:
					// nothing to do but copy
					//
					MemCpy(lppcm16Dst, lppcm16Dst, uSamples * 2);
					uSamplesDst = uSamples;
					break;

				case 11025:
					uSamplesDst = PcmResample8Kto11K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 22050:
					uSamplesDst = PcmResample8Kto22K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 44100:
					uSamplesDst = PcmResample8Kto44K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				default:
					fSuccess = TraceFALSE(NULL);
					break;
			}
			break;

		case 11025:
			switch (nSamplesPerSecDst)
			{
				case 6000:
					uSamplesDst = PcmResample11Kto6K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 8000:
					uSamplesDst = PcmResample11Kto8K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 11025:
					// nothing to do but copy
					//
					MemCpy(lppcm16Dst, lppcm16Dst, uSamples * 2);
					uSamplesDst = uSamples;
					break;

				case 22050:
					uSamplesDst = PcmResample11Kto22K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 44100:
					uSamplesDst = PcmResample11Kto44K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				default:
					fSuccess = TraceFALSE(NULL);
					break;
			}
			break;

		case 22050:
			switch (nSamplesPerSecDst)
			{
				case 6000:
					uSamplesDst = PcmResample22Kto6K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 8000:
					uSamplesDst = PcmResample22Kto8K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 11025:
					uSamplesDst = PcmResample22Kto11K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 22050:
					// nothing to do but copy
					//
					MemCpy(lppcm16Dst, lppcm16Dst, uSamples * 2);
					uSamplesDst = uSamples;
					break;

				case 44100:
					uSamplesDst = PcmResample22Kto44K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				default:
					fSuccess = TraceFALSE(NULL);
					break;
			}
			break;

		case 44100:
			switch (nSamplesPerSecDst)
			{
				case 6000:
					uSamplesDst = PcmResample44Kto6K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 8000:
					uSamplesDst = PcmResample44Kto8K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 11025:
					uSamplesDst = PcmResample44Kto11K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 22050:
					uSamplesDst = PcmResample44Kto22K(lpPcm,
						lppcm16Src, lppcm16Dst, uSamples);
					break;

				case 44100:
					// nothing to do but copy
					//
					MemCpy(lppcm16Dst, lppcm16Dst, uSamples * 2);
					uSamplesDst = uSamples;
					break;

				default:
					fSuccess = TraceFALSE(NULL);
					break;
			}
			break;

		default:
			fSuccess = TraceFALSE(NULL);
			break;
	}

	return fSuccess ? uSamplesDst : 0;
}

////
//	helper functions
////

static UINT PcmResampleCalcDstMax(HPCM hPcm,
	long nSamplesPerSecSrc, long nSamplesPerSecDst,	UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm;
	UINT uSamplesDst;

	if ((lpPcm = PcmGetPtr(hPcm)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (nSamplesPerSecSrc)
	{
		case 6000:
		{
			switch (nSamplesPerSecDst)
			{
				case 6000:
					uSamplesDst = uSamples;
					break;

				case 8000:
					uSamplesDst = (UINT) (((long) uSamples * 8) / 6);
					break;

				case 11025:
					uSamplesDst = (UINT) (((long) uSamples * 11) / 6);
					break;

				case 22050:
					uSamplesDst = (UINT) (((long) uSamples * 22) / 6);
					break;

				case 44100:
					uSamplesDst = (UINT) (((long) uSamples * 44) / 6);
					break;

				default:
					fSuccess = TraceFALSE(NULL);
					break;
			}
		}
			break;

		case 8000:
			switch (nSamplesPerSecDst)
			{
				case 6000:
					uSamplesDst = (UINT) (((long) uSamples * 6) / 8);
					break;

				case 8000:
					uSamplesDst = uSamples;
					break;

				case 11025:
					uSamplesDst = (UINT) (((long) uSamples * 11) / 8);
					break;

				case 22050:
					uSamplesDst = (UINT) (((long) uSamples * 22) / 8);
					break;

				case 44100:
					uSamplesDst = (UINT) (((long) uSamples * 44) / 8);
					break;

				default:
					fSuccess = TraceFALSE(NULL);
					break;
			}
			break;

		case 11025:
			switch (nSamplesPerSecDst)
			{
				case 6000:
					uSamplesDst = (UINT) (((long) uSamples * 6) / 11);
					break;

				case 8000:
					uSamplesDst = (UINT) (((long) uSamples * 8) / 11);
					break;

				case 11025:
					uSamplesDst = uSamples;
					break;

				case 22050:
					uSamplesDst = (UINT) (((long) uSamples * 22) / 11);
					break;

				case 44100:
					uSamplesDst = (UINT) (((long) uSamples * 44) / 11);
					break;

				default:
					fSuccess = TraceFALSE(NULL);
					break;
			}
			break;

		case 22050:
			switch (nSamplesPerSecDst)
			{
				case 6000:
					uSamplesDst = (UINT) (((long) uSamples * 6) / 22);
					break;

				case 8000:
					uSamplesDst = (UINT) (((long) uSamples * 8) / 22);
					break;

				case 11025:
					uSamplesDst = (UINT) (((long) uSamples * 11) / 22);
					break;

				case 22050:
					uSamplesDst = uSamples;
					break;

				case 44100:
					uSamplesDst = (UINT) (((long) uSamples * 44) / 22);
					break;

				default:
					fSuccess = TraceFALSE(NULL);
					break;
			}
			break;

		case 44100:
			switch (nSamplesPerSecDst)
			{
				case 6000:
					uSamplesDst = (UINT) (((long) uSamples * 6) / 44);
					break;

				case 8000:
					uSamplesDst = (UINT) (((long) uSamples * 8) / 44);
					break;

				case 11025:
					uSamplesDst = (UINT) (((long) uSamples * 11) / 44);
					break;

				case 22050:
					uSamplesDst = (UINT) (((long) uSamples * 22) / 44);
					break;

				case 44100:
					uSamplesDst = uSamples;
					break;

				default:
					fSuccess = TraceFALSE(NULL);
					break;
			}
			break;

		default:
			fSuccess = TraceFALSE(NULL);
			break;
	}

	return fSuccess ? uSamplesDst : 0;
}

static UINT PcmResample6Kto8K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 3)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 8);
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Src - pcm16Prev), 8);
				break;

			case 2:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Src - pcm16Prev), 8);
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample6Kto11K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 6)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Src - pcm16Prev), 11);
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Src - pcm16Prev), 11);
				break;

			case 2:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Delta) / 11;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Delta), 11);
			}
				break;

			case 3:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(8, (pcm16Delta), 11);
			}
				break;

			case 4:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(9, (pcm16Delta), 11);
			}
				break;

			case 5:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(10, (pcm16Delta), 11);
			}
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample6Kto22K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 3)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(8, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Src;
			}
				break;

			case 1:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(9, (pcm16Delta), 11);
			}
				break;

			case 2:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Delta) / 11;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(10, (pcm16Delta), 11);
			}
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample6Kto44K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 3)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Delta) / 22;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(10, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(13, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(16, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(19, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Src;
			}
				break;

			case 1:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(9, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(12, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(15, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(18, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(21, (pcm16Delta), 22);
			}
				break;

			case 2:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(8, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(11, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(14, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(17, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(20, (pcm16Delta), 22);
			}
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample8Kto6K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 4)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 6);
				break;

			case 3:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Src - pcm16Prev), 6);
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample8Kto11K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 8)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Src - pcm16Prev), 11);
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(8, (pcm16Src - pcm16Prev), 11);
				break;

			case 2:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Src - pcm16Prev), 11);
				break;

			case 3:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(10, (pcm16Delta), 11);
			}
				break;

			case 4:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Src - pcm16Prev), 11);
				break;

			case 5:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Src - pcm16Prev), 11);
				break;

			case 6:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Delta) / 11;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(9, (pcm16Delta), 11);
			}
				break;

			case 7:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Src - pcm16Prev), 11);
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample8Kto22K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 4)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Src;
			}
				break;

			case 1:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(8, (pcm16Delta), 11);
			}
				break;

			case 2:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Delta) / 11;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(9, (pcm16Delta), 11);
			}
				break;

			case 3:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(10, (pcm16Delta), 11);
			}
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample8Kto44K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 2)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Delta) / 11;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(9, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Src;
			}
				break;

			case 1:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(8, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(10, (pcm16Delta), 11);
			}
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample11Kto6K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 11)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Src - pcm16Prev), 6);
				break;

			case 3:
				break;

			case 4:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Src - pcm16Prev), 6);
				break;

			case 5:
				break;

			case 6:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Src - pcm16Prev), 6);
				break;

			case 7:
				break;

			case 8:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 6);
				break;

			case 9:
				break;

			case 10:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 6;
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample11Kto8K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 11)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Src - pcm16Prev), 8);
				break;

			case 3:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Src - pcm16Prev), 8);
				break;

			case 4:
				break;

			case 5:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 8;
				break;

			case 6:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Src - pcm16Prev), 8);
				break;

			case 7:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Src - pcm16Prev), 8);
				break;

			case 8:
				break;

			case 9:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 8);
				break;

			case 10:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Src - pcm16Prev), 8);
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample11Kto22K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		*lppcm16Dst++ = pcm16Prev +
			(pcm16Src - pcm16Prev) / 2;
		*lppcm16Dst++ = pcm16Src;
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample11Kto44K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		*lppcm16Dst++ = pcm16Prev +
			(pcm16Src - pcm16Prev) / 4;
		*lppcm16Dst++ = pcm16Prev +
			MULDIV16(2, (pcm16Src - pcm16Prev), 4);
		*lppcm16Dst++ = pcm16Prev +
			MULDIV16(3, (pcm16Src - pcm16Prev), 4);
		*lppcm16Dst++ = pcm16Src;
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample22Kto6K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 11)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				break;

			case 3:
				break;

			case 4:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 3);
				break;

			case 5:
				break;

			case 6:
				break;

			case 7:
				break;

			case 8:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 3;
				break;

			case 9:
				break;

			case 10:
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample22Kto8K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 11)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				break;

			case 3:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Src - pcm16Prev), 4);
				break;

			case 4:
				break;

			case 5:
				break;

			case 6:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 4);
				break;

			case 7:
				break;

			case 8:
				break;

			case 9:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 4;
				break;

			case 10:
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample22Kto11K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 2)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				break;

			case 1:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 2;
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample22Kto44K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		*lppcm16Dst++ = pcm16Prev +
			(pcm16Src - pcm16Prev) / 2;
		*lppcm16Dst++ = pcm16Src;
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample44Kto6K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 22)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				break;

			case 3:
				break;

			case 4:
				break;

			case 5:
				break;

			case 6:
				break;

			case 7:
				break;

			case 8:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 3;
				break;

			case 9:
				break;

			case 10:
				break;

			case 11:
				break;

			case 12:
				break;

			case 13:
				break;

			case 14:
				break;

			case 15:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 3);
				break;

			case 16:
				break;

			case 17:
				break;

			case 18:
				break;

			case 19:
				break;

			case 20:
				break;

			case 21:
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample44Kto8K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 11)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				break;

			case 3:
				break;

			case 4:
				break;

			case 5:
				break;

			case 6:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 2;
				break;

			case 7:
				break;

			case 8:
				break;

			case 9:
				break;

			case 10:
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample44Kto11K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev0 = lpPcm->pcm16Prev0;
	PCM16 pcm16Prev1 = lpPcm->pcm16Prev1;
	PCM16 pcm16Prev2 = lpPcm->pcm16Prev2;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 4)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				pcm16Prev0 = pcm16Src;
				break;

			case 1:
				pcm16Prev1 = pcm16Src;
				break;

			case 2:
				pcm16Prev2 = pcm16Src;
				break;

			case 3:
				*lppcm16Dst++ = (PCM16) ((__int32) pcm16Prev0 +
					(__int32) pcm16Prev1 + (__int32) pcm16Prev2 +
					(__int32) pcm16Src) / 4;
				break;
		}
	}

	lpPcm->pcm16Prev0 = pcm16Prev0;
	lpPcm->pcm16Prev1 = pcm16Prev1;
	lpPcm->pcm16Prev2 = pcm16Prev2;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample44Kto22K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 2)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				break;

			case 1:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 2;
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

// PcmGetPtr - verify that pcm handle is valid,
//		<hPcm>		(i) handle returned from PcmInit
// return corresponding pcm pointer (NULL if error)
//
static LPPCM PcmGetPtr(HPCM hPcm)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm;

	if ((lpPcm = (LPPCM) hPcm) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpPcm, sizeof(PCM)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the pcm handle
	//
	else if (lpPcm->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpPcm : NULL;
}

// PcmGetHandle - verify that pcm pointer is valid,
//		<lpPcm>		(i) pointer to PCM struct
// return corresponding pcm handle (NULL if error)
//
static HPCM PcmGetHandle(LPPCM lpPcm)
{
	BOOL fSuccess = TRUE;
	HPCM hPcm;

	if ((hPcm = (HPCM) lpPcm) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hPcm : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\mmio.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	mmio.c - mmio functions
////

#include "winlocal.h"

#include <mmsystem.h>

#include "mmio.h"
#include "mem.h"
#include "sys.h"
#include "trace.h"

////
//	private definitions
////

// helper functions
//
static LRESULT MmioIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName);
static LRESULT MmioIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags);
static LRESULT MmioIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch);
static LRESULT MmioIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush);
static LRESULT MmioIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin);
static LRESULT MmioIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName);
static LRESULT MmioIOGetInfo(LPMMIOINFO lpmmioinfo, int iInfo);
static LRESULT MmioIOChSize(LPMMIOINFO lpmmioinfo, long lSize);

////
//	public functions
////

// MmioIOProc - i/o procedure for mmio data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing mmio format file data.
//
LRESULT DLLEXPORT CALLBACK MmioIOProc(LPTSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult = 0;

	if (lpmmioinfo == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (uMessage)
	{
		case MMIOM_OPEN:
			lResult = MmioIOOpen((LPMMIOINFO) lpmmioinfo,
				(LPTSTR) lParam1);
			break;

		case MMIOM_CLOSE:
			lResult = MmioIOClose((LPMMIOINFO) lpmmioinfo,
				(UINT) lParam1);
			break;

		case MMIOM_READ:
			lResult = MmioIORead((LPMMIOINFO) lpmmioinfo,
				(HPSTR) lParam1, (LONG) lParam2);
			break;

		case MMIOM_WRITE:
			lResult = MmioIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, FALSE);
			break;

		case MMIOM_WRITEFLUSH:
			lResult = MmioIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, TRUE);
			break;

		case MMIOM_SEEK:
			lResult = MmioIOSeek((LPMMIOINFO) lpmmioinfo,
				(LONG) lParam1, (int) lParam2);
			break;

		case MMIOM_RENAME:
			lResult = MmioIORename((LPMMIOINFO) lpmmioinfo,
				(LPCTSTR) lParam1, (LPCTSTR) lParam2);
			break;

		case MMIOM_GETINFO:
			lResult = MmioIOGetInfo((LPMMIOINFO) lpmmioinfo,
				(int) lParam1);
			break;

		case MMIOM_CHSIZE:
			lResult = MmioIOChSize((LPMMIOINFO) lpmmioinfo,
				(long) lParam1);
			break;

		default:
			lResult = 0;
			break;
	}

	return lResult;
}

////
//	installable file i/o procedures
////

static LRESULT MmioIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = NULL;
	MMIOINFO mmioinfo;

 	TracePrintf_1(NULL, 5,
 		TEXT("MmioIOOpen (%s)\n"),
		(LPTSTR) lpszFileName);

	MemSet(&mmioinfo, 0, sizeof(mmioinfo));

	// special case flags which do not actually return an open file handle
	//
	if ((lpmmioinfo->dwFlags & MMIO_EXIST) ||
		(lpmmioinfo->dwFlags & MMIO_DELETE) ||
		(lpmmioinfo->dwFlags & MMIO_GETTEMP) ||
		(lpmmioinfo->dwFlags & MMIO_PARSE))
	{
		hmmio = mmioOpen(lpszFileName, &mmioinfo, lpmmioinfo->dwFlags);

		return (LRESULT) fSuccess;
	}

	else if ((hmmio = mmioOpen(lpszFileName, &mmioinfo, lpmmioinfo->dwFlags)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// save stuff for use in other i/o routines
		//
		lpmmioinfo->adwInfo[0] = (DWORD) (LPVOID) hmmio;
	}

	if (!fSuccess && hmmio != NULL && mmioClose(hmmio, 0) != 0)
		fSuccess = TraceFALSE(NULL);

	// return the same error code given by mmioOpen
	//
	return fSuccess ? lpmmioinfo->wErrorRet = mmioinfo.wErrorRet : MMIOERR_CANNOTOPEN;
}

static LRESULT MmioIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	UINT uRet = MMIOERR_CANNOTCLOSE;

 	TracePrintf_0(NULL, 5,
 		TEXT("MmioIOClose\n"));

	if ((uRet = mmioClose(hmmio, uFlags)) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpmmioinfo->adwInfo[0] = (DWORD) NULL;
	}

	return fSuccess ? 0 : uRet;
}

static LRESULT MmioIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	LONG lBytesRead;

 	TracePrintf_1(NULL, 5,
 		TEXT("MmioIORead (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		lBytesRead = 0; // nothing to do

	// read
	//
	else if ((lBytesRead = mmioRead(hmmio, pch, cch)) == -1)
		fSuccess = TraceFALSE(NULL);

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset += lBytesRead;

 	TracePrintf_2(NULL, 5,
 		TEXT("lpmmioinfo->lDiskOffset=%ld, lBytesRead=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesRead);

	// return number of bytes read
	//
	return fSuccess ? lBytesRead : -1;
}

static LRESULT MmioIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	LONG lBytesWritten;

 	TracePrintf_1(NULL, 5,
 		TEXT("MmioIOWrite (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		lBytesWritten = 0; // nothing to do

	// write
	//
	else if ((lBytesWritten = mmioWrite(hmmio, pch, cch)) == -1)
		fSuccess = TraceFALSE(NULL);

	// update file position
	//
	else
		lpmmioinfo->lDiskOffset += lBytesWritten;

 	TracePrintf_2(NULL, 5,
 		TEXT("lpmmioinfo->lDiskOffset=%ld, lBytesWritten=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesWritten);

	// return number of bytes written
	//
	return fSuccess ? lBytesWritten : -1;
}

static LRESULT MmioIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	LONG lPosNew;

 	TracePrintf_2(NULL, 5,
 		TEXT("MmioIOSeek (%ld, %d)\n"),
		(long) lOffset,
		(int) iOrigin);

	// seek
	//
	if ((lPosNew = mmioSeek(hmmio, lOffset, iOrigin)) == -1)
		fSuccess = TraceFALSE(NULL);

	// update file position
	//
	else
		lpmmioinfo->lDiskOffset = lPosNew;

 	TracePrintf_1(NULL, 5,
 		TEXT("lpmmioinfo->lDiskOffset=%ld\n"),
		(long) lpmmioinfo->lDiskOffset);

	return fSuccess ? lpmmioinfo->lDiskOffset : -1;
}

static LRESULT MmioIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName)
{
	BOOL fSuccess = TRUE;
	UINT uRet;

 	TracePrintf_2(NULL, 5,
 		TEXT("MmioIORename (%s, %s)\n"),
		(LPTSTR) lpszFileName,
		(LPTSTR) lpszNewFileName);

	if ((uRet = mmioRename(lpszFileName, lpszNewFileName, lpmmioinfo, 0)) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : uRet;
}

static LRESULT MmioIOGetInfo(LPMMIOINFO lpmmioinfo, int iInfo)
{
	BOOL fSuccess = TRUE;

 	TracePrintf_1(NULL, 5,
 		TEXT("MmioIOGetInfo (%d)\n"),
		(int) iInfo);

	if (iInfo < 0 || iInfo > 2)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? (LRESULT) lpmmioinfo->adwInfo[iInfo] : 0;
}

static LRESULT MmioIOChSize(LPMMIOINFO lpmmioinfo, long lSize)
{
	BOOL fSuccess = TRUE;
	long lPosCurr;
	long lPosEnd;

 	TracePrintf_1(NULL, 5,
 		TEXT("MmioIOChSize (%ld)\n"),
		(long) lSize);

	if ((lPosCurr = MmioIOSeek(lpmmioinfo, 0, SEEK_CUR)) < 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lPosEnd = MmioIOSeek(lpmmioinfo, 0, SEEK_END)) < 0)
		fSuccess = TraceFALSE(NULL);

	else if (lPosEnd == lSize)
		; // nothing to do, since the file is already the specified size

	// make file larger by writing bytes at end
	//
	else if (lPosEnd < lSize)
	{
		void _huge *hpBuf = NULL;
		long sizBuf = lSize - lPosEnd;

		if ((hpBuf = MemAlloc(NULL, sizBuf, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);
			
		else if (MmioIOWrite(lpmmioinfo, hpBuf, sizBuf, TRUE) < 0)
			fSuccess = TraceFALSE(NULL);
			
		if (hpBuf != NULL && (hpBuf = MemFree(NULL, hpBuf)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	// make file smaller by truncating at specified position
	//
	else if (lPosEnd > lSize)
	{
		// seek to the specified position
		//
		if (MmioIOSeek(lpmmioinfo, lSize, SEEK_SET) != lSize)
			fSuccess = TraceFALSE(NULL);

		// truncate file
		//
		else
		{
#ifdef _WIN32
			// $FIXUP - where do we get the file handle ?
			//
#if 0
			if (SetEndOfFile(hfile)
				fSuccess = TraceFALSE(NULL);
#endif
#else
			BYTE abBuf[1];
			
			// writing zero bytes under DOS will truncate file at current position
			//
			if (MmioIOWrite(lpmmioinfo, abBuf, 0, TRUE) < 0)
				fSuccess = TraceFALSE(NULL);
#endif
		}
	}

	return fSuccess ? 0 : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\mulaw.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// mulaw.h - interface to mulaw functions in mulaw.c
////

#ifndef __MULAW_H__
#define __MULAW_H__

#include "winlocal.h"

#include "wavfmt.h"

#define MULAW_VERSION 0x00000108

// handle to a mulaw engine instance
//
DECLARE_HANDLE32(HMULAW);

#ifdef __cplusplus
extern "C" {
#endif

// these macros for compatibility with old code
//
#define MulawFormat(lpwfx, nSamplesPerSec) \
	WavFormatMulaw(lpwfx, nSamplesPerSec)

// MulawInit - initialize mulaw engine
//		<dwVersion>			(i) must be MULAW_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) reserved; must be 0
// return handle (NULL if error)
//
HMULAW DLLEXPORT WINAPI MulawInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags);

// MulawTerm - shut down mulaw engine
//		<hMulaw>			(i) handle returned from MulawInit
// return 0 if success
//
int DLLEXPORT WINAPI MulawTerm(HMULAW hMulaw);

// MulawReset - reset mulaw engine
//		<hMulaw>			(i) handle returned from MulawInit
// return 0 if success
//
int DLLEXPORT WINAPI MulawReset(HMULAW hMulaw);

// MulawDecode - decode mulaw samples
//		<hMulaw>			(i) handle returned from MulawInit
//		<lpabMulaw>			(i) array of encoded samples
//		<lpaiPcm>			(o) array of decoded samples
//		<uSamples>			(i) number of samples to decode
// return 0 if success
//
// NOTE: each BYTE in <lpabMulaw> contains 1 8-bit encoded sample
// in Mulaw format.
// Each PCM16 in <lpaiPcm> contains 1 16-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI MulawDecode(HMULAW hMulaw, LPBYTE lpabMulaw, LPPCM16 lpaiPcm, UINT uSamples);

// MulawEncode - encode mulaw samples
//		<hMulaw>			(i) handle returned from MulawInit
//		<lpaiPcm>			(i) array of decoded samples
//		<lpabMulaw>			(o) array of encoded samples
//		<uSamples>			(i) number of samples to encode
// return 0 if success
//
// NOTE: each BYTE in <lpabMulaw> contains 1 8-bit encoded sample
// in Mulaw format.
// Each PCM16 in <lpaiPcm> contains 1 16-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI MulawEncode(HMULAW hMulaw, LPPCM16 lpaiPcm, LPBYTE lpabMulaw, UINT uSamples);

// MulawIOProc - i/o procedure for mulaw format file data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing mulaw format file data.
//
LRESULT DLLEXPORT CALLBACK MulawIOProc(LPTSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#ifdef __cplusplus
}
#endif

#endif // __MULAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by avwav.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\pcm.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// pcm.h - interface to pcm functions in pcm.c
////

#ifndef __PCM_H__
#define __PCM_H__

#include "winlocal.h"

#include "wavfmt.h"

#define PCM_VERSION 0x00000100

// handle to pcm engine
//
DECLARE_HANDLE32(HPCM);

// <dwFlags> param in PcmFilter and PcmConvert
//
#define PCMFILTER_LOWPASS		0x00000001

#ifdef __cplusplus
extern "C" {
#endif

// PcmInit - initialize pcm engine
//		<dwVersion>			(i) must be PCM_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) reserved; must be 0
// return handle (NULL if error)
//
HPCM DLLEXPORT WINAPI PcmInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags);

// PcmTerm - shut down pcm engine
//		<hPcm>				(i) handle returned from PcmInit
// return 0 if success
//
int DLLEXPORT WINAPI PcmTerm(HPCM hPcm);

// PcmReset - reset pcm engine
//		<hPcm>				(i) handle returned from PcmInit
// return 0 if success
//
int DLLEXPORT WINAPI PcmReset(HPCM hPcm);

// PcmCalcSizBufSrc - calculate source buffer size
//		<hPcm>				(i) handle returned from PcmInit
//		<sizBufDst>			(i) size of destination buffer in bytes
//		<lpwfxSrc>			(i) source wav format
//		<lpwfxDst>			(i) destination wav format
// return source buffer size, -1 if error
//
long DLLEXPORT WINAPI PcmCalcSizBufSrc(HPCM hPcm, long sizBufDst,
	LPWAVEFORMATEX lpwfxSrc, LPWAVEFORMATEX lpwfxDst);

// PcmCalcSizBufDst - calculate destination buffer size
//		<hPcm>				(i) handle returned from PcmInit
//		<sizBufSrc>			(i) size of source buffer in bytes
//		<lpwfxSrc>			(i) source wav format
//		<lpwfxDst>			(i) destination wav format
// return destination buffer size, -1 if error
//
long DLLEXPORT WINAPI PcmCalcSizBufDst(HPCM hPcm, long sizBufSrc,
	LPWAVEFORMATEX lpwfxSrc, LPWAVEFORMATEX lpwfxDst);

// PcmConvert - convert pcm data from one format to another
//		<hPcm>				(i) handle returned from PcmInit
//		<hpBufSrc> 			(i) buffer containing bytes to reformat
//		<sizBufSrc>			(i) size of buffer in bytes
//		<lpwfxSrc>			(i) source wav format
//		<hpBufDst> 			(o) buffer to contain new format
//		<sizBufDst>			(i) size of buffer in bytes
//		<lpwfxDst>			(i) destination wav format
//		<dwFlags>			(i) control flags
//			PCMFILTER_LOWPASS	perform lowpass filter
// return count of bytes in destination buffer (-1 if error)
//
// NOTE: the destination buffer must be large enough to hold the result
//
long DLLEXPORT WINAPI PcmConvert(HPCM hPcm,
	void _huge *hpBufSrc, long sizBufSrc, LPWAVEFORMATEX lpwfxSrc,
	void _huge *hpBufDst, long sizBufDst, LPWAVEFORMATEX lpwfxDst,
	DWORD dwFlags);

// Pcm16To8 - convert 16-bit samples to 8-bit samples
//		<hPcm>				(i) handle returned from PcmInit
//		<lppcm16Src>		(i) buffer of source samples
//		<lppcm8Dst>			(o) buffer to hold destination samples
//		<uSamples>			(i) count of source samples to convert
// return 0 if success
//
int DLLEXPORT WINAPI Pcm16To8(HPCM hPcm,
	LPPCM16 lppcm16Src, LPPCM8 lppcm8Dst, UINT uSamples);

// Pcm8To16 - convert 8-bit samples to 16-bit samples
//		<hPcm>				(i) handle returned from PcmInit
//		<lppcm8Src>			(i) buffer of source samples
//		<lppcm16Dst>		(o) buffer to hold destination samples
//		<uSamples>			(i) count of source samples to convert
// return 0 if success
//
int DLLEXPORT WINAPI Pcm8To16(HPCM hPcm,
	LPPCM8 lppcm8Src, LPPCM16 lppcm16Dst, UINT uSamples);

// PcmFilter - filter pcm samples
//		<hPcm>				(i) handle returned from PcmInit
//		<lppcm16Src>		(i) buffer of source samples
//		<lppcm16Dst>		(o) buffer to hold destination samples
//		<uSamples>			(i) count of source samples to filter
//		<dwFlags>			(i) control flags
//			PCMFILTER_LOWPASS	perform a low pass filter
// return 0 if success
//
// NOTE: <lppcm16Src> and <lppcm16Dst> can point to the same buffer
//
int DLLEXPORT WINAPI PcmFilter(HPCM hPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples, DWORD dwFlags);

// PcmResample - resample pcm samples
//		<hPcm>				(i) handle returned from PcmInit
//		<lppcm16Src>		(i) buffer of source samples
//		<nSamplesPerSecSrc>	(i) sample rate of source samples
//		<lppcm16Dst>		(o) buffer to hold destination samples
//		<nSamplesPerSecDst>	(i) sample rate of destination samples
//		<uSamples>			(i) count of source samples to resample
//		<dwFlags>			(i) control flags
//			0					reserved, must be zero
// return count of samples in destination buffer (0 if error)
//
// NOTE: the destination buffer must be large enough to hold the result.
// Call PcmResampleCalcDstMax() to calculate max destination samples
//
UINT DLLEXPORT WINAPI PcmResample(HPCM hPcm,
	LPPCM16 lppcm16Src, long nSamplesPerSecSrc,
	LPPCM16 lppcm16Dst, long nSamplesPerSecDst,
	UINT uSamples, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __PCM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\propio.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	propio.cpp - property i/o functions
////

#include "winlocal.h"

#include <mmsystem.h>

#include <mapi.h>
#include <mapidefs.h>

#include "propio.h"
#include "trace.h"
#include "str.h"

////
//	private definitions
////

// helper functions
//
static LRESULT PropIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName);
static LRESULT PropIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags);
static LRESULT PropIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch);
static LRESULT PropIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush);
static LRESULT PropIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin);
static LRESULT PropIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName);

////
//	public functions
////

// PropIOProc - i/o procedure for property data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing property data.
//
LRESULT DLLEXPORT CALLBACK PropIOProc(LPSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult = 0;

	if (lpmmioinfo == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (uMessage)
	{
		case MMIOM_OPEN:
			lResult = PropIOOpen((LPMMIOINFO) lpmmioinfo,
				(LPTSTR) lParam1);
			break;

		case MMIOM_CLOSE:
			lResult = PropIOClose((LPMMIOINFO) lpmmioinfo,
				(UINT) lParam1);
			break;

		case MMIOM_READ:
			lResult = PropIORead((LPMMIOINFO) lpmmioinfo,
				(HPSTR) lParam1, (LONG) lParam2);
			break;

		case MMIOM_WRITE:
			lResult = PropIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, FALSE);
			break;

		case MMIOM_WRITEFLUSH:
			lResult = PropIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, TRUE);
			break;

		case MMIOM_SEEK:
			lResult = PropIOSeek((LPMMIOINFO) lpmmioinfo,
				(LONG) lParam1, (int) lParam2);
			break;

		case MMIOM_RENAME:
			lResult = PropIORename((LPMMIOINFO) lpmmioinfo,
				(LPCTSTR) lParam1, (LPCTSTR) lParam2);
			break;

		default:
			lResult = 0;
			break;
	}

	return lResult;
}

////
//	installable file i/o procedures
////

static LRESULT PropIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName)
{
	BOOL fSuccess = TRUE;
	LPMESSAGE lpmsg;
	ULONG ulPropTag;
	ULONG ulFlags = 0L;
	HRESULT hr;
	IID IID_IStream;
	LPSTREAM lpStream;

 	TracePrintf_0(NULL, 5,
 		TEXT("PropIOOpen\n"));

	// convert MMIOINFO flags to equivalent OpenProperty flags
	//
	if (lpmmioinfo->dwFlags & MMIO_CREATE)
		ulFlags |= MAPI_CREATE | MAPI_MODIFY;
	if (lpmmioinfo->dwFlags & MMIO_READWRITE)
		ulFlags |= MAPI_MODIFY;

	// message pointer is within first element of info array
	//
	if ((lpmsg = (LPMESSAGE) lpmmioinfo->adwInfo[0]) == NULL)
		fSuccess = TraceFALSE(NULL);

	// property id is within second element of info array
	//
	else if ((ulPropTag = (ULONG) lpmmioinfo->adwInfo[1]) == (ULONG) 0)
		fSuccess = TraceFALSE(NULL);

	// open the property
	//
	else if ((hr = lpmsg->OpenProperty(ulPropTag, (LPCIID) &IID_IStream, 0,
		ulFlags, (LPUNKNOWN *) &lpStream)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("OpenProperty failed (%ld)\n"),
	 		(long) hr);
	}

	else
	{
		// save stream pointer for use in other i/o routines
		//
		lpmmioinfo->adwInfo[0] = (DWORD) (LPVOID) lpStream;
	}

	// return the same error code given by mmioOpen
	//
	return fSuccess ? lpmmioinfo->wErrorRet = 0 : MMIOERR_CANNOTOPEN;
}

static LRESULT PropIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM) lpmmioinfo->adwInfo[0];
	UINT uRet = MMIOERR_CANNOTCLOSE;

 	TracePrintf_0(NULL, 5,
 		TEXT("PropIOClose\n"));

	// close the stream
	//
	if (lpStream->Release() < 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_0(NULL, 5,
	 		TEXT("Stream:Close failed\n"));
	}

	else
	{
		lpmmioinfo->adwInfo[0] = (DWORD) NULL;
	}

	return fSuccess ? 0 : uRet;
}

static LRESULT PropIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM) lpmmioinfo->adwInfo[0];
	HRESULT hr;
	LONG lBytesRead = 0L;

 	TracePrintf_1(NULL, 5,
 		TEXT("PropIORead (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		lBytesRead = 0; // nothing to do

	// read
	//
	else if ((hr = lpStream->Read((LPVOID) pch,
		(ULONG) cch, (ULONG FAR *) &lBytesRead)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_2(NULL, 5,
	 		TEXT("IStream:Read failed (%ld, %ld)\n"),
	 		(long) hr,
			(long) lBytesRead);
	}

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset += (LONG) lBytesRead;

 	TracePrintf_2(NULL, 5,
 		TEXT("PropIO: lpmmioinfo->lDiskOffset=%ld, lBytesRead=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesRead);

	// return number of bytes read
	//
	return fSuccess ? lBytesRead : -1;
}

static LRESULT PropIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM) lpmmioinfo->adwInfo[0];
	HRESULT hr;
	LONG lBytesWritten;

 	TracePrintf_1(NULL, 5,
 		TEXT("PropIOWrite (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		lBytesWritten = 0; // nothing to do

	// write
	//
	else if ((hr = lpStream->Write((LPVOID) pch,
		(ULONG) cch, (ULONG FAR *) &lBytesWritten)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_2(NULL, 5,
	 		TEXT("IStream:Write failed (%ld, %ld)\n"),
	 		(long) hr,
			(long) lBytesWritten);
	}

	// update file position
	//
	else
		lpmmioinfo->lDiskOffset += lBytesWritten;

 	TracePrintf_2(NULL, 5,
 		TEXT("PropIO: lpmmioinfo->lDiskOffset=%ld, lBytesWritten=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesWritten);

	// return number of bytes written
	//
	return fSuccess ? lBytesWritten : -1;
}

static LRESULT PropIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM) lpmmioinfo->adwInfo[0];
	HRESULT hr;
	LARGE_INTEGER largeOffset;
	ULARGE_INTEGER ulargePosNew;

	largeOffset.LowPart = (DWORD) lOffset;
	largeOffset.HighPart = (DWORD) 0L;

 	TracePrintf_2(NULL, 5,
 		TEXT("PropIOSeek (%ld, %d)\n"),
		(long) lOffset,
		(int) iOrigin);

	// seek
	//
	if ((hr = lpStream->Seek(largeOffset,
		(DWORD) iOrigin, &ulargePosNew)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("IStream:Seek failed (%ld)\n"),
	 		(long) hr);
	}

	// update file position
	//
	else
		lpmmioinfo->lDiskOffset = (long) ulargePosNew.LowPart;

 	TracePrintf_1(NULL, 5,
 		TEXT("PropIO: lpmmioinfo->lDiskOffset=%ld\n"),
		(long) lpmmioinfo->lDiskOffset);

	return fSuccess ? lpmmioinfo->lDiskOffset : -1;
}

static LRESULT PropIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName)
{
	BOOL fSuccess = TRUE;
	UINT uRet = MMIOERR_FILENOTFOUND;

 	TracePrintf_2(NULL, 5,
 		TEXT("PropIORename (%s, %s)\n"),
		(LPTSTR) lpszFileName,
		(LPTSTR) lpszNewFileName);

	// rename is not supported by this i/o procedure
	//
	if (TRUE)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\propio.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// propio.h - interface to property i/o functions in propio.c
////

#ifndef __PROPIO_H__
#define __PROPIO_H__

#include "winlocal.h"

#ifdef __cplusplus
extern "C" {
#endif

// PropIOProc - i/o procedure for property data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing property data.
//
LRESULT DLLEXPORT CALLBACK PropIOProc(LPSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#ifdef __cplusplus
}
#endif

#endif // __PROPIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\sockio.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	sockio.c - winsock i/o functions
////

#include "winlocal.h"

#include <mmsystem.h>
#include <winsock.h>

#include "sockio.h"
#include "trace.h"
#include "str.h"

////
//	private definitions
////

// sock control struct
//
typedef struct SOCK
{
	WSADATA wsaData;
	LPTSTR lpszServerName;
	unsigned short uPort;
	SOCKADDR_IN sin;
	SOCKET iSocket;
} SOCK, FAR *LPSOCK;

#define PORT_DEFAULT 1024

// helper functions
//
static LRESULT SockIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName);
static LRESULT SockIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags);
static LRESULT SockIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch);
static LRESULT SockIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush);
static LRESULT SockIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin);
static LRESULT SockIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName);

////
//	public functions
////

// SockIOProc - i/o procedure for winsock data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing property data.
//
LRESULT DLLEXPORT CALLBACK SockIOProc(LPSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult = 0;

	if (lpmmioinfo == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (uMessage)
	{
		case MMIOM_OPEN:
			lResult = SockIOOpen((LPMMIOINFO) lpmmioinfo,
				(LPTSTR) lParam1);
			break;

		case MMIOM_CLOSE:
			lResult = SockIOClose((LPMMIOINFO) lpmmioinfo,
				(UINT) lParam1);
			break;

		case MMIOM_READ:
			lResult = SockIORead((LPMMIOINFO) lpmmioinfo,
				(HPSTR) lParam1, (LONG) lParam2);
			break;

		case MMIOM_WRITE:
			lResult = SockIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, FALSE);
			break;

		case MMIOM_WRITEFLUSH:
			lResult = SockIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, TRUE);
			break;

		case MMIOM_SEEK:
			lResult = SockIOSeek((LPMMIOINFO) lpmmioinfo,
				(LONG) lParam1, (int) lParam2);
			break;

		case MMIOM_RENAME:
			lResult = SockIORename((LPMMIOINFO) lpmmioinfo,
				(LPCTSTR) lParam1, (LPCTSTR) lParam2);
			break;

		default:
			lResult = 0;
			break;
	}

	return lResult;
}

////
//	installable file i/o procedures
////

static LRESULT SockIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName)
{
	BOOL fSuccess = TRUE;
	int nRet;
	LPSOCK lpSock = NULL;
	LPTSTR lpsz;

 	TracePrintf_0(NULL, 5,
 		TEXT("SockIOOpen\n"));

	// convert MMIOINFO flags to equivalent socket flags
	//
	if (lpmmioinfo->dwFlags & MMIO_CREATE)
		;
	if (lpmmioinfo->dwFlags & MMIO_READWRITE)
		;

	// server name pointer is first element of info array
	//
	if ((LPTSTR) lpmmioinfo->adwInfo[0] == NULL)
		fSuccess = TraceFALSE(NULL);

	// allocate control struct
	//
	else if ((lpSock = (LPSOCK) GlobalAllocPtr(GMEM_MOVEABLE |
		GMEM_ZEROINIT, sizeof(SOCK))) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// initialize Windows Sockets DLL, requesting v1.1 compatibility
	//
	else if ((nRet = WSAStartup(0x0101, &lpSock->wsaData)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("WSAStartup failed (%d)\n"),
	 		(int) nRet);
	}

	// Confirm that the Windows Sockets DLL supports winsock v1.1
	//
	else if (LOBYTE(lpSock->wsaData.wVersion) != 1 ||
			HIBYTE(lpSock->wsaData.wVersion) != 1)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_0(NULL, 5,
	 		TEXT("Winsock is not v1.1 compatible\n"));
	}

	// save copy of server name
	//
	else if ((lpSock->lpszServerName =
		(LPTSTR) StrDup((LPTSTR) lpmmioinfo->adwInfo[0])) == NULL)
		fSuccess = TraceFALSE(NULL);

	// parse out port number if present (servername:port)
	//
	else if ((lpsz = StrRChr(lpSock->lpszServerName, ':')) != NULL)
	{
		*lpsz = '\0';
		lpSock->uPort = (unsigned int) StrAtoI(lpsz + 1);
	}

	// otherwise assume default port
	//
	else
		lpSock->uPort = PORT_DEFAULT;

	// construct server's socket address struct
	//
	if (fSuccess)
	{
		LPHOSTENT lpHostEnt = NULL;

		// address family must be internetwork: UDP, TCP, etc.
		//
		lpSock->sin.sin_family = AF_INET;

		// convert port from host byte order to network byte order
		//
		lpSock->sin.sin_port = htons(lpSock->uPort);

		// if servername contains anything other than digits and periods
		//
		if (StrSpn(lpSock->lpszServerName, TEXT(".0123456789")) !=
			StrLen(lpSock->lpszServerName))
		{
			// try to resolve with DNS
			//
			if ((lpHostEnt = gethostbyname(lpSock->lpszServerName)) == NULL)
			{
			 	TracePrintf_2(NULL, 5,
		 			TEXT("gethostbyname(%s) failed (%d)\n"),
					(LPTSTR) lpSock->lpszServerName,
					(int) WSAGetLastError());
			}

		 	// store resolved address
		 	//
			else
			{
				lpSock->sin.sin_addr.s_addr =
					*((LPDWORD) lpHostEnt->h_addr);
			}		
		}

		// if servername contains only digits and periods,
		// or if gethostbyname() failed, convert address string to binary
		//
		if (lpHostEnt == NULL)
		{
		    if ((lpSock->sin.sin_addr.s_addr =
				inet_addr(lpSock->lpszServerName)) == INADDR_NONE)
			{
				fSuccess = TraceFALSE(NULL);
			 	TracePrintf_1(NULL, 5,
		 			TEXT("inet_addr(%s) failed\n"),
					(LPTSTR) lpSock->lpszServerName);
			}
		}
	}

	if (fSuccess)
	{
		LINGER l;

		l.l_onoff = 1;
		l.l_linger = 0;

		// create a socket
		//
		if ((lpSock->iSocket = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
		 		TEXT("socket() failed (%d)\n"),
				(int) WSAGetLastError());
		}

		// establish a socket connection to server
		//
		else if (connect(lpSock->iSocket, (LPSOCKADDR) &lpSock->sin,
			sizeof(lpSock->sin)) == SOCKET_ERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
		 		TEXT("connect() failed (%d)\n"),
				(int) WSAGetLastError());
		}

		// enable SO_LINGER option so that closesocket() will discard
		// unsent data rather than block until queued data is sent
		//
		else if (setsockopt(lpSock->iSocket, SOL_SOCKET, SO_LINGER,
			(LPVOID) &l, sizeof(l)) == SOCKET_ERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
		 		TEXT("setsockopt(SO_LINGER) failed (%d)\n"),
				(int) WSAGetLastError());
		}
	}

	if (fSuccess)
	{
		// save socket control struct pointer for use in other i/o routines
		//
		lpmmioinfo->adwInfo[0] = (DWORD) (LPVOID) lpSock;
	}

	// return the same error code given by mmioOpen
	//
	return fSuccess ? lpmmioinfo->wErrorRet = 0 : MMIOERR_CANNOTOPEN;
}

static LRESULT SockIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags)
{
	BOOL fSuccess = TRUE;
	LPSOCK lpSock = (LPSOCK) lpmmioinfo->adwInfo[0];
	UINT uRet = MMIOERR_CANNOTCLOSE;

 	TracePrintf_0(NULL, 5,
 		TEXT("SockIOClose\n"));

	// cancel any blocking call if necessary
	//
	if (WSAIsBlocking() && WSACancelBlockingCall() == SOCKET_ERROR)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
	 		TEXT("WSACancelBlockingCall() failed (%d)\n"),
			(int) WSAGetLastError());
	}

	// close the socket
	//
	else if (lpSock->iSocket != INVALID_SOCKET &&
		closesocket(lpSock->iSocket) == SOCKET_ERROR)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
	 		TEXT("closesocket() failed (%d)\n"),
			(int) WSAGetLastError());
	}

	else
		lpSock->iSocket = INVALID_SOCKET;

	if (fSuccess)
	{
		// free server name buffer
		//
		if (lpSock->lpszServerName != NULL &&
			StrDupFree(lpSock->lpszServerName) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		else
			lpSock->lpszServerName = NULL;
	}

	if (fSuccess)
	{
		lpmmioinfo->adwInfo[0] = (DWORD) NULL;
	}

	return fSuccess ? 0 : uRet;
}

static LRESULT SockIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch)
{
	BOOL fSuccess = TRUE;
	LPSOCK lpSock = (LPSOCK) lpmmioinfo->adwInfo[0];
	int nBytesRead;

 	TracePrintf_1(NULL, 5,
 		TEXT("SockIORead (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		nBytesRead = 0; // nothing to do

	// read
	//
	else if ((nBytesRead = recv(lpSock->iSocket,
		(LPVOID) pch, (int) cch, 0)) == SOCKET_ERROR)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
	 		TEXT("recv() failed (%d)\n"),
			(int) WSAGetLastError());
	}

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset += (LONG) nBytesRead;

 	TracePrintf_2(NULL, 5,
 		TEXT("SockIO: lpmmioinfo->lDiskOffset=%ld, lBytesRead=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) nBytesRead);

	// return number of bytes read
	//
	return fSuccess ? (LRESULT) nBytesRead : -1;
}

static LRESULT SockIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush)
{
	BOOL fSuccess = TRUE;
	LPSOCK lpSock = (LPSOCK) lpmmioinfo->adwInfo[0];
	int nBytesWritten;

 	TracePrintf_1(NULL, 5,
 		TEXT("SockIOWrite (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		nBytesWritten = 0; // nothing to do

	// write
	//
	else if ((nBytesWritten = send(lpSock->iSocket,
		(LPVOID) pch, (int) cch, 0)) == SOCKET_ERROR)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
	 		TEXT("send() failed (%d)\n"),
			(int) WSAGetLastError());
	}

	// update file position
	//
	else
		lpmmioinfo->lDiskOffset += (LONG) nBytesWritten;

 	TracePrintf_2(NULL, 5,
 		TEXT("SockIO: lpmmioinfo->lDiskOffset=%ld, lBytesWritten=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) nBytesWritten);

	// return number of bytes written
	//
	return fSuccess ? (LRESULT) nBytesWritten : -1;
}

static LRESULT SockIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin)
{
	BOOL fSuccess = TRUE;
	LPSOCK lpSock = (LPSOCK) lpmmioinfo->adwInfo[0];

 	TracePrintf_2(NULL, 5,
 		TEXT("SockIOSeek (%ld, %d)\n"),
		(long) lOffset,
		(int) iOrigin);

	// seek is not supported by this i/o procedure
	//
	if (TRUE)
		fSuccess = TraceFALSE(NULL);

 	TracePrintf_1(NULL, 5,
 		TEXT("SockIO: lpmmioinfo->lDiskOffset=%ld\n"),
		(long) lpmmioinfo->lDiskOffset);

	return fSuccess ? lpmmioinfo->lDiskOffset : -1;
}

static LRESULT SockIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName)
{
	BOOL fSuccess = TRUE;
	UINT uRet = MMIOERR_FILENOTFOUND;

 	TracePrintf_2(NULL, 5,
 		TEXT("SockIORename (%s, %s)\n"),
		(LPTSTR) lpszFileName,
		(LPTSTR) lpszNewFileName);

	// rename is not supported by this i/o procedure
	//
	if (TRUE)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\strmio.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// strmio.h - interface to property i/o functions in strmio.cpp
////

#ifndef __STRMIO_H__
#define __STRMIO_H__

#include "winlocal.h"

#ifdef __cplusplus
extern "C" {
#endif

// StreamIOProc - i/o procedure for property data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing property data.
//
LRESULT DLLEXPORT CALLBACK StreamIOProc(LPSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#ifdef __cplusplus
}
#endif

#endif // __STRMIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\telthunk.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// telthunk.h - interface for tel thunk functions in telthunk.c
////

#ifndef __TELTHUNK_H__
#define __TELTHUNK_H__

#include "winlocal.h"

#define TELTHUNK_VERSION 0x00000107

// handle to telthunk engine
//
DECLARE_HANDLE32(HTELTHUNK);

#ifdef __cplusplus
extern "C" {
#endif

// TelThunkInit - initialize telthunk engine
//		<dwVersion>			(i) must be TELTHUNK_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HTELTHUNK DLLEXPORT WINAPI TelThunkInit(DWORD dwVersion, HINSTANCE hInst);

// TelThunkTerm - shut down telthunk engine
//		<hTelThunk>				(i) handle returned from TelThunkInit
// return 0 if success
//
int DLLEXPORT WINAPI TelThunkTerm(HTELTHUNK hTelThunk);

#ifdef __cplusplus
}
#endif

#endif // __TELTHUNK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\sockio.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// sockio.h - interface to property i/o functions in sockio.c
////

#ifndef __SOCKIO_H__
#define __SOCKIO_H__

#include "winlocal.h"

#ifdef __cplusplus
extern "C" {
#endif

// SockIOProc - i/o procedure for winsock data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing winsock data.
//
LRESULT DLLEXPORT CALLBACK SockIOProc(LPSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#ifdef __cplusplus
}
#endif

#endif // __SOCKIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\tsmthunk.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	tsmthunk.c - tsm thunk functions
////

// This is a thunk layer to the telephone functions in avtsm.dll.
// It's purpose is to allow an application to use avtsm.dll functions
// only if they are available.
//
// To use this module, link TSMTHUNK.OBJ with your application
// rather than with AVTSM.LIB.  Before calling any Tsm
// functions, call TsmThunkInit.  Before exiting your application,
// call TsmThunkTerm.
//

#include "winlocal.h"

#include <stdlib.h>

#include "avtsm.h"
#include "tsmthunk.h"
#include "loadlib.h"
#include "mem.h"
#include "trace.h"

extern HINSTANCE g_hInstLib;

////
//	private definitions
////

#define TSMTHUNK_LIBNAME		"avtsm.dll"

#ifdef TSMTHUNK
#undef TSMTHUNK
#endif

extern HINSTANCE g_hInstLib;

// tsmthunk control struct
//
typedef struct TSMTHUNK
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HINSTANCE hInstLib;
} TSMTHUNK, FAR *LPTSMTHUNK;

// tsmthunk function struct
//
typedef struct TSMTHUNKFN
{
	int index;
	LPSTR lpszName;
	FARPROC lpfn;
} TSMTHUNKFN, FAR *LPTSMTHUNKFN;

enum
{
	iTsmInit = 0,
	iTsmTerm,
	iTsmSetSpeed,
	iTsmConvert,
	iTsmSupportsSpeed,

	TSMTHUNK_MAXFUNCTIONS
};

static TSMTHUNKFN aTsmThunkFn[] =
{
	iTsmInit, "TsmInit", NULL,
	iTsmTerm, "TsmTerm", NULL,
	iTsmSetSpeed, "TsmSetSpeed", NULL,
	iTsmConvert, "TsmConvert", NULL,
	iTsmSupportsSpeed, "TsmSupportsSpeed", NULL
};

// helper functions
//
static LPTSMTHUNK TsmThunkGetPtr(HTSMTHUNK hTsmThunk);
static HTSMTHUNK TsmThunkGetHandle(LPTSMTHUNK lpTsmThunk);

////
//	public functions
////

// TsmThunkInit - initialize tsmthunk engine
//		<dwVersion>			(i) must be TSMTHUNK_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HTSMTHUNK DLLEXPORT WINAPI TsmThunkInit(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPTSMTHUNK lpTsmThunk = NULL;

	if (dwVersion != TSMTHUNK_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);
                        
	else if ((lpTsmThunk = (LPTSMTHUNK) MemAlloc(NULL, sizeof(TSMTHUNK), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		int i;
		
		lpTsmThunk->dwVersion = dwVersion;
		lpTsmThunk->hInst = hInst;
		lpTsmThunk->hTask = GetCurrentTask();
		lpTsmThunk->hInstLib = NULL;

		// load the library if possible
		//
		if ((lpTsmThunk->hInstLib = LoadLibraryPath(TSMTHUNK_LIBNAME, g_hInstLib, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// get the address of each function in library
		//
		else for (i = 0; i < SIZEOFARRAY(aTsmThunkFn); ++i)
		{
			if (aTsmThunkFn[i].index != i)
				fSuccess = TraceFALSE(NULL);

			else if ((aTsmThunkFn[i].lpfn = GetProcAddress(lpTsmThunk->hInstLib,
				aTsmThunkFn[i].lpszName)) == NULL)
			{
				TracePrintf_1(NULL, 6,
					TEXT("GetProcAddress failed\n   fn=%s\n"),
					(LPTSTR) aTsmThunkFn[i].lpszName);
				fSuccess = TraceFALSE(NULL);
			}
		}
	}

	if (!fSuccess)
	{
		TsmThunkTerm(TsmThunkGetHandle(lpTsmThunk));
		lpTsmThunk = NULL;
	}

	return fSuccess ? TsmThunkGetHandle(lpTsmThunk) : NULL;
}


// TsmThunkTerm - shut down tsmthunk engine
//		<hTsmThunk>				(i) handle returned from TsmThunkInit
// return 0 if success
//
int DLLEXPORT WINAPI TsmThunkTerm(HTSMTHUNK hTsmThunk)
{
	BOOL fSuccess = TRUE;
	LPTSMTHUNK lpTsmThunk;

	if ((lpTsmThunk = TsmThunkGetPtr(hTsmThunk)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// library no longer needed
		//
		FreeLibrary(lpTsmThunk->hInstLib);

		if ((lpTsmThunk = MemFree(NULL, lpTsmThunk)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// Tsm thunk functions
//

HTSM DLLEXPORT WINAPI TsmInit(DWORD dwVersion, HINSTANCE hInst,
	LPWAVEFORMATEX lpwfx, int nScaleEfficiency, long sizBufSrcMax,
	DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	HTSM (WINAPI *lpfnTsmInit)(DWORD dwVersion, HINSTANCE hInst,
		LPWAVEFORMATEX lpwfx, int nScaleEfficiency, long sizBufSrcMax,
		DWORD dwFlags);
	HTSM hTsm;

	if (aTsmThunkFn[iTsmInit].index != iTsmInit)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTsmInit = aTsmThunkFn[iTsmInit].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		hTsm = (*lpfnTsmInit)(dwVersion, hInst,
			lpwfx, nScaleEfficiency, sizBufSrcMax, dwFlags);
	}

	return fSuccess ? hTsm : NULL;
}

int DLLEXPORT WINAPI TsmTerm(HTSM hTsm)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTsmTerm)(HTSM hTsm);
	int iRet;

	if (aTsmThunkFn[iTsmTerm].index != iTsmTerm)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTsmTerm = aTsmThunkFn[iTsmTerm].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTsmTerm)(hTsm);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TsmSetSpeed(HTSM hTsm, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTsmSetSpeed)(HTSM hTsm, int nLevel, DWORD dwFlags);
	int iRet;

	if (aTsmThunkFn[iTsmSetSpeed].index != iTsmSetSpeed)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTsmSetSpeed = aTsmThunkFn[iTsmSetSpeed].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTsmSetSpeed)(hTsm, nLevel, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

long DLLEXPORT WINAPI TsmConvert(HTSM hTsm,
	void _huge *hpBufSrc, long sizBufSrc,
	void _huge *hpBufDst, long sizBufDst,
	DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	long (WINAPI *lpfnTsmConvert)(HTSM hTsm,
		void _huge *hpBufSrc, long sizBufSrc,
		void _huge *hpBufDst, long sizBufDst,
		DWORD dwFlags);
	long lRet;

	if (aTsmThunkFn[iTsmConvert].index != iTsmConvert)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTsmConvert = aTsmThunkFn[iTsmConvert].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lRet = (*lpfnTsmConvert)(hTsm,
			hpBufSrc, sizBufSrc, hpBufDst, sizBufDst, dwFlags);
	}

	return fSuccess ? lRet : -1;
}

BOOL DLLEXPORT WINAPI TsmSupportsSpeed(int nLevel, LPWAVEFORMATEX lpwfx, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTsmSupportsSpeed)(int nLevel, LPWAVEFORMATEX lpwfx, DWORD dwFlags);
	BOOL fRet;

	if (aTsmThunkFn[iTsmSupportsSpeed].index != iTsmSupportsSpeed)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTsmSupportsSpeed = aTsmThunkFn[iTsmSupportsSpeed].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTsmSupportsSpeed)(nLevel, lpwfx, dwFlags);
	}

	return fSuccess ? fRet : FALSE;
}

////
//	helper functions
////

// TsmThunkGetPtr - verify that tsmthunk handle is valid,
//		<hTsmThunk>				(i) handle returned from TsmThunkInit
// return corresponding tsmthunk pointer (NULL if error)
//
static LPTSMTHUNK TsmThunkGetPtr(HTSMTHUNK hTsmThunk)
{
	BOOL fSuccess = TRUE;
	LPTSMTHUNK lpTsmThunk;

	if ((lpTsmThunk = (LPTSMTHUNK) hTsmThunk) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpTsmThunk, sizeof(TSMTHUNK)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the tsmthunk handle
	//
	else if (lpTsmThunk->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpTsmThunk : NULL;
}

// TsmThunkGetHandle - verify that tsmthunk pointer is valid,
//		<lpTsmThunk>				(i) pointer to TSMTHUNK struct
// return corresponding tsmthunk handle (NULL if error)
//
static HTSMTHUNK TsmThunkGetHandle(LPTSMTHUNK lpTsmThunk)
{
	BOOL fSuccess = TRUE;
	HTSMTHUNK hTsmThunk;

	if ((hTsmThunk = (HTSMTHUNK) lpTsmThunk) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hTsmThunk : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\strmio.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	strmio.cpp - IStream i/o functions
////

#include "winlocal.h"

#include <mmsystem.h>

#include <mapi.h>
#include <mapidefs.h>

#include "strmio.h"
#include "trace.h"

////
//	private definitions
////

// helper functions
//
static LRESULT StreamIoOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName);
static LRESULT StreamIoClose(LPMMIOINFO lpmmioinfo, UINT uFlags);
static LRESULT StreamIoRead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch);
static LRESULT StreamIoWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush);
static LRESULT StreamIoSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin);
static LRESULT StreamIoRename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName);

////
//	public functions
////

// StreamIoProc - i/o procedure for IStream data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing IStream data.
//
LRESULT DLLEXPORT CALLBACK StreamIOProc(LPSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult = 0;

	if (lpmmioinfo == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (uMessage)
	{
		case MMIOM_OPEN:
			lResult = StreamIoOpen((LPMMIOINFO) lpmmioinfo,
				(LPTSTR) lParam1);
			break;

		case MMIOM_CLOSE:
			lResult = StreamIoClose((LPMMIOINFO) lpmmioinfo,
				(UINT) lParam1);
			break;

		case MMIOM_READ:
			lResult = StreamIoRead((LPMMIOINFO) lpmmioinfo,
				(HPSTR) lParam1, (LONG) lParam2);
			break;

		case MMIOM_WRITE:
			lResult = StreamIoWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, FALSE);
			break;

		case MMIOM_WRITEFLUSH:
			lResult = StreamIoWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, TRUE);
			break;

		case MMIOM_SEEK:
			lResult = StreamIoSeek((LPMMIOINFO) lpmmioinfo,
				(LONG) lParam1, (int) lParam2);
			break;

		case MMIOM_RENAME:
			lResult = StreamIoRename((LPMMIOINFO) lpmmioinfo,
				(LPCTSTR) lParam1, (LPCTSTR) lParam2);
			break;

		default:
			lResult = 0;
			break;
	}

	return lResult;
}

////
//	installable file i/o procedures
////

static LRESULT StreamIoOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream;

 	TracePrintf_0(NULL, 5,
 		TEXT("StreamIoOpen\n"));

	// stream pointer is within first element of info array
	//
	if ((lpStream = (LPSTREAM)(DWORD_PTR)lpmmioinfo->adwInfo[0]) == NULL)
		fSuccess = TraceFALSE(NULL);

	// seek to the beginning of the stream
	//
	else if (StreamIoSeek(lpmmioinfo, 0, 0) != 0)
		fSuccess = TraceFALSE(NULL);

	else
		lpStream->AddRef();

	// return the same error code given by mmioOpen
	//
	return fSuccess ? lpmmioinfo->wErrorRet = 0 : MMIOERR_CANNOTOPEN;
}

static LRESULT StreamIoClose(LPMMIOINFO lpmmioinfo, UINT uFlags)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM)(DWORD_PTR)lpmmioinfo->adwInfo[0];
	UINT uRet = MMIOERR_CANNOTCLOSE;

 	TracePrintf_0(NULL, 5,
 		TEXT("StreamIoClose\n"));

	// close the stream
	//
	lpStream->Release();
    lpmmioinfo->adwInfo[0] = (DWORD) NULL;

	return fSuccess ? 0 : uRet;
}

static LRESULT StreamIoRead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM)(DWORD_PTR)lpmmioinfo->adwInfo[0];
	HRESULT hr;
	LONG lBytesRead = 0L;

 	TracePrintf_1(NULL, 5,
 		TEXT("StreamIoRead (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		lBytesRead = 0; // nothing to do

	// read
	//
	else if ((hr = lpStream->Read((LPVOID) pch,
		(ULONG) cch, (ULONG FAR *) &lBytesRead)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_2(NULL, 5,
	 		TEXT("IStream:Read failed (%ld, %ld)\n"),
	 		(long) hr,
			(long) lBytesRead);
	}

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset += (LONG) lBytesRead;

 	TracePrintf_2(NULL, 5,
 		TEXT("StreamIo: lpmmioinfo->lDiskOffset=%ld, lBytesRead=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesRead);

	// return number of bytes read
	//
	return fSuccess ? lBytesRead : -1;
}

static LRESULT StreamIoWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM)(DWORD_PTR)lpmmioinfo->adwInfo[0];
	HRESULT hr;
	LONG lBytesWritten;

 	TracePrintf_1(NULL, 5,
 		TEXT("StreamIoWrite (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		lBytesWritten = 0; // nothing to do

	// write
	//
	else if ((hr = lpStream->Write((LPVOID) pch,
		(ULONG) cch, (ULONG FAR *) &lBytesWritten)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_2(NULL, 5,
	 		TEXT("IStream:Write failed (%ld, %ld)\n"),
	 		(long) hr,
			(long) lBytesWritten);
	}

	// update file position
	//
	else
		lpmmioinfo->lDiskOffset += lBytesWritten;

 	TracePrintf_2(NULL, 5,
 		TEXT("StreamIo: lpmmioinfo->lDiskOffset=%ld, lBytesWritten=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesWritten);

	// return number of bytes written
	//
	return fSuccess ? lBytesWritten : -1;
}

static LRESULT StreamIoSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM)(DWORD_PTR)lpmmioinfo->adwInfo[0];
	HRESULT hr;
	LARGE_INTEGER largeOffset;
	ULARGE_INTEGER ulargePosNew;

	largeOffset.LowPart = (DWORD) lOffset;
	largeOffset.HighPart = (DWORD) 0L;

 	TracePrintf_2(NULL, 5,
 		TEXT("StreamIoSeek (%ld, %d)\n"),
		(long) lOffset,
		(int) iOrigin);

	// seek
	//
	if ((hr = lpStream->Seek(largeOffset,
		(DWORD) iOrigin, &ulargePosNew)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("IStream:Seek failed (%ld)\n"),
	 		(long) hr);
	}

	// update file position
	//
	else
		lpmmioinfo->lDiskOffset = (long) ulargePosNew.LowPart;

 	TracePrintf_1(NULL, 5,
 		TEXT("StreamIo: lpmmioinfo->lDiskOffset=%ld\n"),
		(long) lpmmioinfo->lDiskOffset);

	return fSuccess ? lpmmioinfo->lDiskOffset : -1;
}

static LRESULT StreamIoRename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName)
{
	BOOL fSuccess = TRUE;
	UINT uRet = MMIOERR_FILENOTFOUND;

 	TracePrintf_2(NULL, 5,
 		TEXT("StreamIoRename (%s, %s)\n"),
		(LPTSTR) lpszFileName,
		(LPTSTR) lpszNewFileName);

	// rename is not supported by this i/o procedure
	//
	if (TRUE)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\tsmthunk.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// tsmthunk.h - interface for tsm thunk functions in tsmthunk.c
////

#ifndef __TSMTHUNK_H__
#define __TSMTHUNK_H__

#include "winlocal.h"

#define TSMTHUNK_VERSION 0x00000107

// handle to tsmthunk engine
//
DECLARE_HANDLE32(HTSMTHUNK);

#ifdef __cplusplus
extern "C" {
#endif

// TsmThunkInit - initialize tsmthunk engine
//		<dwVersion>			(i) must be TSMTHUNK_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HTSMTHUNK DLLEXPORT WINAPI TsmThunkInit(DWORD dwVersion, HINSTANCE hInst);

// TsmThunkTerm - shut down tsmthunk engine
//		<hTsmThunk>				(i) handle returned from TsmThunkInit
// return 0 if success
//
int DLLEXPORT WINAPI TsmThunkTerm(HTSMTHUNK hTsmThunk);

#ifdef __cplusplus
}
#endif

#endif // __TSMTHUNK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\telthunk.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	telthunk.c - tel thunk functions
////

// This is a thunk layer to the telephone functions in tel.dll.
// It's purpose is to allow an application to use tel.dll functions
// only if they are available.
//
// To use this module, link TELTHUNK.OBJ with your application
// rather than with TEL.LIB.  Before calling any Tel or TelOut
// functions, call TelThunkInit.  Before exiting your application,
// call TelThunkTerm.
//

#include "winlocal.h"

#include <stdlib.h>

#include "telthunk.h"
#include "tel.h"
#include "telcfg.h"
#include "telwav.h"
#include "telout.h"
#include "telin.h"
#include "file.h"
#include "loadlib.h"
#include "mem.h"
#include "str.h"
#include "trace.h"

extern HINSTANCE g_hInstLib;

////
//	private definitions
////

#ifdef _WIN32
#define TELTHUNK_LIBNAME		"tel32.dll"
#define TELTHUNK_LIBNAME_TIU	"tel32nt.dll"
#else
#define TELTHUNK_LIBNAME		"tel.dll"
#endif

#ifdef TELTHUNK
#undef TELTHUNK
#endif

extern HINSTANCE g_hInstLib;

// telthunk control struct
//
typedef struct TELTHUNK
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HINSTANCE hInstLib;
} TELTHUNK, FAR *LPTELTHUNK;

// telthunk function struct
//
typedef struct TELTHUNKFN
{
	int index;
	LPSTR lpszName;
	FARPROC lpfn;
} TELTHUNKFN, FAR *LPTELTHUNKFN;

enum
{
	iTelInitDLL = 0,
	iTelTermDLL,
	iTelInit,
	iTelTerm,
	iTelIsConnected,
	iTelConnect,
	iTelDisconnect,
	iTelTransfer,
	iTelConnectIdleTimeoutReset,

	iTelOutGetDeviceCount,
	iTelOutDeviceIsOpen,
	iTelOutOpen,
	iTelOutClose,
	iTelOutPlay,
	iTelOutStop,
	iTelOutPause,
	iTelOutResume,
	iTelOutGetState,
	iTelOutGetPosition,
	iTelOutGetId,
	iTelOutGetName,
	iTelOutSupportsFormat,
	iTelOutFormatSuggest,
	iTelOutIsSynchronous,
	iTelOutSupportsVolume,
	iTelOutSupportsSpeed,
	iTelOutSupportsPitch,
	iTelOutGetVolume,
	iTelOutSetVolume,
	iTelOutGetSpeed,
	iTelOutSetSpeed,
	iTelOutGetPitch,
	iTelOutSetPitch,
	iTelOutTerm,

	iTelInGetDeviceCount,
	iTelInDeviceIsOpen,
	iTelInOpen,
	iTelInClose,
	iTelInRecord,
	iTelInStop,
	iTelInGetState,
	iTelInGetPosition,
	iTelInGetId,
	iTelInGetName,
	iTelInSupportsFormat,
	iTelInFormatSuggest,
	iTelInTerm,

	iTelCfgRead,
	iTelCfgWrite,
	iTelCfgDoDialog,

	iTelWavOpenEx,

	TELTHUNK_MAXFUNCTIONS
};

static TELTHUNKFN aTelThunkFn[] =
{
	iTelInitDLL, "TelInitDLL", NULL,
	iTelTermDLL, "TelTermDLL", NULL,

	iTelInit, "TelInit", NULL,
	iTelTerm, "TelTerm", NULL,
	iTelIsConnected, "TelIsConnected", NULL,
	iTelConnect, "TelConnect", NULL,
	iTelDisconnect, "TelDisconnect", NULL,
	iTelTransfer, "TelTransfer", NULL,
	iTelConnectIdleTimeoutReset, "TelConnectIdleTimeoutReset", NULL,

	iTelOutGetDeviceCount, "TelOutGetDeviceCount", NULL,
	iTelOutDeviceIsOpen, "TelOutDeviceIsOpen", NULL,
	iTelOutOpen, "TelOutOpen", NULL,
	iTelOutClose, "TelOutClose", NULL,
	iTelOutPlay, "TelOutPlay", NULL,
	iTelOutStop, "TelOutStop", NULL,
	iTelOutPause, "TelOutPause", NULL,
	iTelOutResume, "TelOutResume", NULL,
	iTelOutGetState, "TelOutGetState", NULL,
	iTelOutGetPosition, "TelOutGetPosition", NULL,
	iTelOutGetId, "TelOutGetId", NULL,
	iTelOutGetName, "TelOutGetName", NULL,
	iTelOutSupportsFormat, "TelOutSupportsFormat", NULL,
	iTelOutFormatSuggest, "TelOutFormatSuggest", NULL,
	iTelOutIsSynchronous, "TelOutIsSynchronous", NULL,
	iTelOutSupportsVolume, "TelOutSupportsVolume", NULL,
	iTelOutSupportsSpeed, "TelOutSupportsSpeed", NULL,
	iTelOutSupportsPitch, "TelOutSupportsPitch", NULL,
	iTelOutGetVolume, "TelOutGetVolume", NULL,
	iTelOutSetVolume, "TelOutSetVolume", NULL,
	iTelOutGetSpeed, "TelOutGetSpeed", NULL,
	iTelOutSetSpeed, "TelOutSetSpeed", NULL,
	iTelOutGetPitch, "TelOutGetPitch", NULL,
	iTelOutSetPitch, "TelOutSetPitch", NULL,
	iTelOutTerm, "TelOutTerm", NULL,

	iTelInGetDeviceCount, "TelInGetDeviceCount", NULL,
	iTelInDeviceIsOpen, "TelInDeviceIsOpen", NULL,
	iTelInOpen, "TelInOpen", NULL,
	iTelInClose, "TelInClose", NULL,
	iTelInRecord, "TelInRecord", NULL,
	iTelInStop, "TelInStop", NULL,
	iTelInGetState, "TelInGetState", NULL,
	iTelInGetPosition, "TelInGetPosition", NULL,
	iTelInGetId, "TelInGetId", NULL,
	iTelInGetName, "TelInGetName", NULL,
	iTelInSupportsFormat, "TelInSupportsFormat", NULL,
	iTelInFormatSuggest, "TelInFormatSuggest", NULL,
	iTelInTerm, "TelInTerm", NULL,

	iTelCfgRead, "TelCfgRead", NULL,
	iTelCfgWrite, "TelCfgWrite", NULL,
	iTelCfgDoDialog, "TelCfgDoDialog", NULL,

	iTelWavOpenEx, "TelWavOpenEx", NULL
};

// helper functions
//
static LPTELTHUNK TelThunkGetPtr(HTELTHUNK hTelThunk);
static HTELTHUNK TelThunkGetHandle(LPTELTHUNK lpTelThunk);

////
//	public functions
////

// TelThunkInit - initialize telthunk engine
//		<dwVersion>			(i) must be TELTHUNK_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HTELTHUNK DLLEXPORT WINAPI TelThunkInit(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPTELTHUNK lpTelThunk = NULL;

	if (dwVersion != TELTHUNK_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);
                        
	else if ((lpTelThunk = (LPTELTHUNK) MemAlloc(NULL, sizeof(TELTHUNK), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		int i;
		TCHAR szLibName[_MAX_PATH];
		LPTSTR lpszBackSlash = NULL;
		
		lpTelThunk->dwVersion = dwVersion;
		lpTelThunk->hInst = hInst;
		lpTelThunk->hTask = GetCurrentTask();
		lpTelThunk->hInstLib = NULL;

		// Determine which DLL to use
		//
#ifdef _WIN32
		MemSet(szLibName, 0, sizeof(szLibName));
		GetModuleFileName(g_hInstLib, szLibName, SIZEOFARRAY(szLibName));
		if ((lpszBackSlash = StrRChr(szLibName, '\\')) != NULL)
			StrCpy(lpszBackSlash + 1, TEXT("TiuClient.dll"));

		if (FileExists(szLibName))
			StrNCpy(szLibName, TELTHUNK_LIBNAME_TIU, SIZEOFARRAY(szLibName));
		else
#endif
			StrNCpy(szLibName, TELTHUNK_LIBNAME, SIZEOFARRAY(szLibName));
			
		TracePrintf_1(NULL, 5,
			TEXT("TelThunkInit: Loading DLL=%s\n"),
			(LPTSTR) szLibName);

		// load the library if possible
		//
		if ((lpTelThunk->hInstLib = LoadLibraryPath(szLibName, g_hInstLib, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// get the address of each function in library
		//
		else for (i = 0; i < MAG(aTelThunkFn); ++i)
		{
			if (aTelThunkFn[i].index != i)
				fSuccess = TraceFALSE(NULL);

			else if ((aTelThunkFn[i].lpfn = GetProcAddress(lpTelThunk->hInstLib,
				aTelThunkFn[i].lpszName)) == NULL)
			{
				TracePrintf_1(NULL, 6,
					TEXT("GetProcAddress failed\n   fn=%s\n"),
					(LPTSTR) aTelThunkFn[i].lpszName);
				fSuccess = TraceFALSE(NULL);
			}
		}
	}

	if (!fSuccess)
	{
		TelThunkTerm(TelThunkGetHandle(lpTelThunk));
		lpTelThunk = NULL;
	}
	else
	{
		__int16 (WINAPI *lpfnTelInitDLL)(void);

		if (((FARPROC) lpfnTelInitDLL = aTelThunkFn[iTelInitDLL].lpfn) != NULL)
			(*lpfnTelInitDLL)();
	}

	return fSuccess ? TelThunkGetHandle(lpTelThunk) : NULL;
}


// TelThunkTerm - shut down telthunk engine
//		<hTelThunk>				(i) handle returned from TelThunkInit
// return 0 if success
//
int DLLEXPORT WINAPI TelThunkTerm(HTELTHUNK hTelThunk)
{
	BOOL fSuccess = TRUE;
	LPTELTHUNK lpTelThunk;

	if ((lpTelThunk = TelThunkGetPtr(hTelThunk)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		__int16 (WINAPI *lpfnTelTermDLL)(void);

		if (((FARPROC) lpfnTelTermDLL = aTelThunkFn[iTelTermDLL].lpfn) != NULL)
			(*lpfnTelTermDLL)();

		// library no longer needed
		//
		FreeLibrary(lpTelThunk->hInstLib);

		if ((lpTelThunk = MemFree(NULL, lpTelThunk)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// Tel thunk functions
//

HTEL DLLEXPORT WINAPI TelInit(DWORD dwVersion, HINSTANCE hInst,
	LPCTSTR lpszServerParams, HWND hwndNotify, WORD wFlags)
{
	BOOL fSuccess = TRUE;
	HTEL (WINAPI *lpfnTelInit)(DWORD dwVersion, HINSTANCE hInst,
		LPCTSTR lpszServerParams, HWND hwndNotify, WORD wFlags);
	HTEL hTel;

	if (aTelThunkFn[iTelInit].index != iTelInit)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInit = aTelThunkFn[iTelInit].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		hTel = (*lpfnTelInit)(dwVersion, hInst,
			lpszServerParams, hwndNotify, wFlags);
	}

	return fSuccess ? hTel : NULL;
}

int DLLEXPORT WINAPI TelTerm(HTEL hTel)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelTerm)(HTEL hTel);
	int iRet;

	if (aTelThunkFn[iTelTerm].index != iTelTerm)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelTerm = aTelThunkFn[iTelTerm].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelTerm)(hTel);
	}

	return fSuccess ? iRet : -1;
}

DWORD DLLEXPORT WINAPI TelIsConnected(HTEL hTel)
{
	BOOL fSuccess = TRUE;
	DWORD (WINAPI *lpfnTelIsConnected)(HTEL hTel);
	DWORD dwRet;

	if (aTelThunkFn[iTelIsConnected].index != iTelIsConnected)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelIsConnected = aTelThunkFn[iTelIsConnected].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		dwRet = (*lpfnTelIsConnected)(hTel);
	}

	return fSuccess ? dwRet : 0;
}

int DLLEXPORT WINAPI TelConnect(HTEL hTel, LPCTSTR lpszPhoneConnect,
	HNBOX hNBoxConnect, DWORD dwTimeoutConnect, DWORD dwTimeoutIdle,
	HNBOX hNBoxDisconnect, DWORD dwTimeoutDisconnect, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelConnect)(HTEL hTel, LPCTSTR lpszPhoneConnect,
		HNBOX hNBoxConnect, DWORD dwTimeoutConnect, DWORD dwTimeoutIdle,
		HNBOX hNBoxDisconnect, DWORD dwTimeoutDisconnect, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelConnect].index != iTelConnect)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelConnect = aTelThunkFn[iTelConnect].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelConnect)(hTel, lpszPhoneConnect,
			hNBoxConnect, dwTimeoutConnect, dwTimeoutIdle,
			hNBoxDisconnect, dwTimeoutDisconnect, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelDisconnect(HTEL hTel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelDisconnect)(HTEL hTel, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelDisconnect].index != iTelDisconnect)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelDisconnect = aTelThunkFn[iTelDisconnect].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelDisconnect)(hTel, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelTransfer(HTEL hTel, LPCTSTR lpszPhoneTransfer,
	HNBOX hNBoxTransfer, DWORD dwTimeoutTransfer, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelTransfer)(HTEL hTel, LPCTSTR lpszPhoneTransfer,
		HNBOX hNBoxTransfer, DWORD dwTimeoutTransfer, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelTransfer].index != iTelTransfer)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelTransfer = aTelThunkFn[iTelTransfer].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelTransfer)(hTel, lpszPhoneTransfer,
			hNBoxTransfer, dwTimeoutTransfer, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelConnectIdleTimeoutReset(HTEL hTel, BOOL fReset)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelConnectIdleTimeoutReset)(HTEL hTel, BOOL fReset);
	int iRet;

	if (aTelThunkFn[iTelConnectIdleTimeoutReset].index != iTelConnectIdleTimeoutReset)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelConnectIdleTimeoutReset = aTelThunkFn[iTelConnectIdleTimeoutReset].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelConnectIdleTimeoutReset)(hTel, fReset);
	}

	return fSuccess ? iRet : -1;
}

// TelOut thunk functions
//

int DLLEXPORT WINAPI TelOutGetDeviceCount(void)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutGetDeviceCount)(void);
	int iRet;

	if (aTelThunkFn[iTelOutGetDeviceCount].index != iTelOutGetDeviceCount)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetDeviceCount = aTelThunkFn[iTelOutGetDeviceCount].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutGetDeviceCount)();
	}

	return fSuccess ? iRet : -1;
}

BOOL DLLEXPORT WINAPI TelOutDeviceIsOpen(int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelOutDeviceIsOpen)(int idDev);
	BOOL fRet;

	if (aTelThunkFn[iTelOutDeviceIsOpen].index != iTelOutDeviceIsOpen)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutDeviceIsOpen = aTelThunkFn[iTelOutDeviceIsOpen].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelOutDeviceIsOpen)(idDev);
	}

	return fSuccess ? fRet : -1;
}

HTELOUT DLLEXPORT WINAPI TelOutOpen(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	HTELOUT (WINAPI *lpfnTelOutOpen)(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags);
	HTELOUT hTelOut;

	if (aTelThunkFn[iTelOutOpen].index != iTelOutOpen)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutOpen = aTelThunkFn[iTelOutOpen].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		hTelOut = (*lpfnTelOutOpen)(dwVersion, hInst, idDev, lpwfx,
			hwndNotify, msTimeoutOpen, msTimeoutRetry, dwFlags);
	}

	return fSuccess ? hTelOut : NULL;
}

int DLLEXPORT WINAPI TelOutClose(HTELOUT hTelOut, DWORD msTimeoutClose)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutClose)(HTELOUT hTelOut, DWORD msTimeoutClose);
	int iRet;

	if (aTelThunkFn[iTelOutClose].index != iTelOutClose)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutClose = aTelThunkFn[iTelOutClose].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutClose)(hTelOut, msTimeoutClose);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutPlay(HTELOUT hTelOut, LPVOID lpBuf, long sizBuf, long hrfile)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutPlay)(HTELOUT hTelOut, LPVOID lpBuf, long sizBuf, long hrfile);
	int iRet;

	if (aTelThunkFn[iTelOutPlay].index != iTelOutPlay)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutPlay = aTelThunkFn[iTelOutPlay].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutPlay)(hTelOut, lpBuf, sizBuf, hrfile);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutStop(HTELOUT hTelOut, DWORD msTimeoutStop)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutStop)(HTELOUT hTelOut, DWORD msTimeoutStop);
	int iRet;

	if (aTelThunkFn[iTelOutStop].index != iTelOutStop)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutStop = aTelThunkFn[iTelOutStop].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutStop)(hTelOut, msTimeoutStop);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutPause(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutPause)(HTELOUT hTelOut);
	int iRet;

	if (aTelThunkFn[iTelOutPause].index != iTelOutPause)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutPause = aTelThunkFn[iTelOutPause].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutPause)(hTelOut);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutResume(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutResume)(HTELOUT hTelOut);
	int iRet;

	if (aTelThunkFn[iTelOutResume].index != iTelOutResume)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutResume = aTelThunkFn[iTelOutResume].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutResume)(hTelOut);
	}

	return fSuccess ? iRet : -1;
}

WORD DLLEXPORT WINAPI TelOutGetState(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	WORD (WINAPI *lpfnTelOutGetState)(HTELOUT hTelOut);
	WORD wRet;

	if (aTelThunkFn[iTelOutGetState].index != iTelOutGetState)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetState = aTelThunkFn[iTelOutGetState].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		wRet = (*lpfnTelOutGetState)(hTelOut);
	}

	return fSuccess ? wRet : 0;
}

long DLLEXPORT WINAPI TelOutGetPosition(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	long (WINAPI *lpfnTelOutGetPosition)(HTELOUT hTelOut);
	long lRet;

	if (aTelThunkFn[iTelOutGetPosition].index != iTelOutGetPosition)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetPosition = aTelThunkFn[iTelOutGetPosition].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lRet = (*lpfnTelOutGetPosition)(hTelOut);
	}

	return fSuccess ? lRet : -1;
}

int DLLEXPORT WINAPI TelOutGetId(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutGetId)(HTELOUT hTelOut);
	int iRet;

	if (aTelThunkFn[iTelOutGetId].index != iTelOutGetId)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetId = aTelThunkFn[iTelOutGetId].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutGetId)(hTelOut);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutGetName(HTELOUT hTelOut, int idDev, LPTSTR lpszName, int sizName)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutGetName)(HTELOUT hTelOut, int idDev, LPTSTR lpszName, int sizName);
	int iRet;

	if (aTelThunkFn[iTelOutGetName].index != iTelOutGetName)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetName = aTelThunkFn[iTelOutGetName].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutGetName)(hTelOut, idDev, lpszName, sizName);
	}

	return fSuccess ? iRet : -1;
}

BOOL DLLEXPORT WINAPI TelOutSupportsFormat(HTELOUT hTelOut, int idDev,
	LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelOutSupportsFormat)(HTELOUT hTelOut, int idDev,
		LPWAVEFORMATEX lpwfx);
	BOOL fRet;

	if (aTelThunkFn[iTelOutSupportsFormat].index != iTelOutSupportsFormat)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSupportsFormat = aTelThunkFn[iTelOutSupportsFormat].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelOutSupportsFormat)(hTelOut, idDev, lpwfx);
	}

	return fSuccess ? fRet : FALSE;
}

LPWAVEFORMATEX DLLEXPORT WINAPI TelOutFormatSuggest(HTELOUT hTelOut,
	int idDev, LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX (WINAPI *lpfnTelOutFormatSuggest)(HTELOUT hTelOut,
		int idDev,	LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags);
	LPWAVEFORMATEX lpwfx;

	if (aTelThunkFn[iTelOutFormatSuggest].index != iTelOutFormatSuggest)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutFormatSuggest = aTelThunkFn[iTelOutFormatSuggest].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpwfx = (*lpfnTelOutFormatSuggest)(hTelOut, idDev, lpwfxSrc, dwFlags);
	}

	return fSuccess ? lpwfx : NULL;
}

BOOL DLLEXPORT WINAPI TelOutIsSynchronous(HTELOUT hTelOut, int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelOutIsSynchronous)(HTELOUT hTelOut, int idDev);
	BOOL fRet;

	if (aTelThunkFn[iTelOutIsSynchronous].index != iTelOutIsSynchronous)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutIsSynchronous = aTelThunkFn[iTelOutIsSynchronous].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelOutIsSynchronous)(hTelOut, idDev);
	}

	return fSuccess ? fRet : FALSE;
}

BOOL DLLEXPORT WINAPI TelOutSupportsVolume(HTELOUT hTelOut, int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelOutSupportsVolume)(HTELOUT hTelOut, int idDev);
	BOOL fRet;

	if (aTelThunkFn[iTelOutSupportsVolume].index != iTelOutSupportsVolume)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSupportsVolume = aTelThunkFn[iTelOutSupportsVolume].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelOutSupportsVolume)(hTelOut, idDev);
	}

	return fSuccess ? fRet : FALSE;
}

BOOL DLLEXPORT WINAPI TelOutSupportsSpeed(HTELOUT hTelOut, int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelOutSupportsSpeed)(HTELOUT hTelOut, int idDev);
	BOOL fRet;

	if (aTelThunkFn[iTelOutSupportsSpeed].index != iTelOutSupportsSpeed)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSupportsSpeed = aTelThunkFn[iTelOutSupportsSpeed].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelOutSupportsSpeed)(hTelOut, idDev);
	}

	return fSuccess ? fRet : FALSE;
}

BOOL DLLEXPORT WINAPI TelOutSupportsPitch(HTELOUT hTelOut, int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelOutSupportsPitch)(HTELOUT hTelOut, int idDev);
	BOOL fRet;

	if (aTelThunkFn[iTelOutSupportsPitch].index != iTelOutSupportsPitch)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSupportsPitch = aTelThunkFn[iTelOutSupportsPitch].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelOutSupportsPitch)(hTelOut, idDev);
	}

	return fSuccess ? fRet : FALSE;
}

int DLLEXPORT WINAPI TelOutGetVolume(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutGetVolume)(HTELOUT hTelOut);
	int iRet;

	if (aTelThunkFn[iTelOutGetVolume].index != iTelOutGetVolume)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetVolume = aTelThunkFn[iTelOutGetVolume].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutGetVolume)(hTelOut);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutSetVolume(HTELOUT hTelOut, int nLevel)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutSetVolume)(HTELOUT hTelOut, int nLevel);
	int iRet;

	if (aTelThunkFn[iTelOutSetVolume].index != iTelOutSetVolume)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSetVolume = aTelThunkFn[iTelOutSetVolume].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutSetVolume)(hTelOut, nLevel);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutGetSpeed(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutGetSpeed)(HTELOUT hTelOut);
	int iRet;

	if (aTelThunkFn[iTelOutGetSpeed].index != iTelOutGetSpeed)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetSpeed = aTelThunkFn[iTelOutGetSpeed].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutGetSpeed)(hTelOut);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutSetSpeed(HTELOUT hTelOut, int nLevel)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutSetSpeed)(HTELOUT hTelOut, int nLevel);
	int iRet;

	if (aTelThunkFn[iTelOutSetSpeed].index != iTelOutSetSpeed)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSetSpeed = aTelThunkFn[iTelOutSetSpeed].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutSetSpeed)(hTelOut, nLevel);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutGetPitch(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutGetPitch)(HTELOUT hTelOut);
	int iRet;

	if (aTelThunkFn[iTelOutGetPitch].index != iTelOutGetPitch)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetPitch = aTelThunkFn[iTelOutGetPitch].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutGetPitch)(hTelOut);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutSetPitch(HTELOUT hTelOut, int nLevel)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutSetPitch)(HTELOUT hTelOut, int nLevel);
	int iRet;

	if (aTelThunkFn[iTelOutSetPitch].index != iTelOutSetPitch)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSetPitch = aTelThunkFn[iTelOutSetPitch].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutSetPitch)(hTelOut, nLevel);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutTerm(HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutTerm)(HINSTANCE hInst, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelOutTerm].index != iTelOutTerm)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutTerm = aTelThunkFn[iTelOutTerm].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutTerm)(hInst, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

// TelIn thunk functions
//

int DLLEXPORT WINAPI TelInGetDeviceCount(void)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInGetDeviceCount)(void);
	int iRet;

	if (aTelThunkFn[iTelInGetDeviceCount].index != iTelInGetDeviceCount)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInGetDeviceCount = aTelThunkFn[iTelInGetDeviceCount].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInGetDeviceCount)();
	}

	return fSuccess ? iRet : -1;
}

BOOL DLLEXPORT WINAPI TelInDeviceIsOpen(int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelInDeviceIsOpen)(int idDev);
	BOOL fRet;

	if (aTelThunkFn[iTelInDeviceIsOpen].index != iTelInDeviceIsOpen)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInDeviceIsOpen = aTelThunkFn[iTelInDeviceIsOpen].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelInDeviceIsOpen)(idDev);
	}

	return fSuccess ? fRet : -1;
}

HTELIN DLLEXPORT WINAPI TelInOpen(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	HTELIN (WINAPI *lpfnTelInOpen)(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags);
	HTELIN hTelIn;

	if (aTelThunkFn[iTelInOpen].index != iTelInOpen)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInOpen = aTelThunkFn[iTelInOpen].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		hTelIn = (*lpfnTelInOpen)(dwVersion, hInst, idDev, lpwfx,
			hwndNotify, msTimeoutOpen, msTimeoutRetry, dwFlags);
	}

	return fSuccess ? hTelIn : NULL;
}

int DLLEXPORT WINAPI TelInClose(HTELIN hTelIn, DWORD msTimeoutClose)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInClose)(HTELIN hTelIn, DWORD msTimeoutClose);
	int iRet;

	if (aTelThunkFn[iTelInClose].index != iTelInClose)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInClose = aTelThunkFn[iTelInClose].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInClose)(hTelIn, msTimeoutClose);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelInRecord(HTELIN hTelIn, LPVOID lpBuf, long sizBuf, long hrfile)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInRecord)(HTELIN hTelIn, LPVOID lpBuf, long sizBuf, long hrfile);
	int iRet;

	if (aTelThunkFn[iTelInRecord].index != iTelInRecord)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInRecord = aTelThunkFn[iTelInRecord].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInRecord)(hTelIn, lpBuf, sizBuf, hrfile);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelInStop(HTELIN hTelIn, DWORD msTimeoutStop)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInStop)(HTELIN hTelIn, DWORD msTimeoutStop);
	int iRet;

	if (aTelThunkFn[iTelInStop].index != iTelInStop)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInStop = aTelThunkFn[iTelInStop].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInStop)(hTelIn, msTimeoutStop);
	}

	return fSuccess ? iRet : -1;
}

WORD DLLEXPORT WINAPI TelInGetState(HTELIN hTelIn)
{
	BOOL fSuccess = TRUE;
	WORD (WINAPI *lpfnTelInGetState)(HTELIN hTelIn);
	WORD wRet;

	if (aTelThunkFn[iTelInGetState].index != iTelInGetState)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInGetState = aTelThunkFn[iTelInGetState].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		wRet = (*lpfnTelInGetState)(hTelIn);
	}

	return fSuccess ? wRet : 0;
}

long DLLEXPORT WINAPI TelInGetPosition(HTELIN hTelIn)
{
	BOOL fSuccess = TRUE;
	long (WINAPI *lpfnTelInGetPosition)(HTELIN hTelIn);
	long lRet;

	if (aTelThunkFn[iTelInGetPosition].index != iTelInGetPosition)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInGetPosition = aTelThunkFn[iTelInGetPosition].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lRet = (*lpfnTelInGetPosition)(hTelIn);
	}

	return fSuccess ? lRet : -1;
}

int DLLEXPORT WINAPI TelInGetId(HTELIN hTelIn)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInGetId)(HTELIN hTelIn);
	int iRet;

	if (aTelThunkFn[iTelInGetId].index != iTelInGetId)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInGetId = aTelThunkFn[iTelInGetId].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInGetId)(hTelIn);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelInGetName(HTELIN hTelIn, int idDev, LPTSTR lpszName, int sizName)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInGetName)(HTELIN hTelIn, int idDev, LPTSTR lpszName, int sizName);
	int iRet;

	if (aTelThunkFn[iTelInGetName].index != iTelInGetName)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInGetName = aTelThunkFn[iTelInGetName].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInGetName)(hTelIn, idDev, lpszName, sizName);
	}

	return fSuccess ? iRet : -1;
}

BOOL DLLEXPORT WINAPI TelInSupportsFormat(HTELIN hTelIn, int idDev,
	LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelInSupportsFormat)(HTELIN hTelIn, int idDev,
		LPWAVEFORMATEX lpwfx);
	BOOL fRet;

	if (aTelThunkFn[iTelInSupportsFormat].index != iTelInSupportsFormat)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInSupportsFormat = aTelThunkFn[iTelInSupportsFormat].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelInSupportsFormat)(hTelIn, idDev, lpwfx);
	}

	return fSuccess ? fRet : FALSE;
}

LPWAVEFORMATEX DLLEXPORT WINAPI TelInFormatSuggest(HTELIN hTelIn,
	int idDev, LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX (WINAPI *lpfnTelInFormatSuggest)(HTELIN hTelIn,
		int idDev,	LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags);
	LPWAVEFORMATEX lpwfx;

	if (aTelThunkFn[iTelInFormatSuggest].index != iTelInFormatSuggest)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInFormatSuggest = aTelThunkFn[iTelInFormatSuggest].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpwfx = (*lpfnTelInFormatSuggest)(hTelIn, idDev, lpwfxSrc, dwFlags);
	}

	return fSuccess ? lpwfx : NULL;
}

int DLLEXPORT WINAPI TelInTerm(HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInTerm)(HINSTANCE hInst, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelInTerm].index != iTelInTerm)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInTerm = aTelThunkFn[iTelInTerm].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInTerm)(hInst, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelCfgRead(DWORD dwVersion, HINSTANCE hInst,
	LPTELCFG lpTelCfg, LPARAM lParam, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelCfgRead)(DWORD dwVersion, HINSTANCE hInst,
		LPTELCFG lpTelCfg, LPARAM lParam, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelCfgRead].index != iTelCfgRead)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelCfgRead = aTelThunkFn[iTelCfgRead].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelCfgRead)(dwVersion, hInst, lpTelCfg, lParam, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelCfgWrite(DWORD dwVersion, HINSTANCE hInst,
	LPTELCFG lpTelCfg, LPARAM lParam, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelCfgWrite)(DWORD dwVersion, HINSTANCE hInst,
		LPTELCFG lpTelCfg, LPARAM lParam, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelCfgWrite].index != iTelCfgWrite)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelCfgWrite = aTelThunkFn[iTelCfgWrite].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelCfgWrite)(dwVersion, hInst, lpTelCfg, lParam, dwFlags);
	}

	return fSuccess ? iRet : -1;
}


int DLLEXPORT WINAPI TelCfgDoDialog(HINSTANCE hInst,
	HWND hwndOwner, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelCfgDoDialog)(HINSTANCE hInst,
		HWND hwndOwner, LPARAM lParam);
	int iRet;

	if (aTelThunkFn[iTelCfgDoDialog].index != iTelCfgDoDialog)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelCfgDoDialog = aTelThunkFn[iTelCfgDoDialog].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelCfgDoDialog)(hInst, hwndOwner, lParam);
	}

	return fSuccess ? iRet : -1;
}

HWAV DLLEXPORT WINAPI TelWavOpenEx(DWORD dwVersion, HINSTANCE hInst,
	LPTSTR lpszFileName, DWORD dwReserved, DWORD dwFlagsOpen, DWORD dwFlagsEx)
{
	BOOL fSuccess = TRUE;
	HWAV (WINAPI *lpfnTelWavOpenEx)(DWORD dwVersion, HINSTANCE hInst,
		LPTSTR lpszFileName, DWORD dwReserved, DWORD dwFlagsOpen, DWORD dwFlagsEx);
	HWAV hWav;

	if (aTelThunkFn[iTelWavOpenEx].index != iTelWavOpenEx)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelWavOpenEx = aTelThunkFn[iTelWavOpenEx].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		hWav = (*lpfnTelWavOpenEx)(dwVersion, hInst,
			lpszFileName, dwReserved, dwFlagsOpen, dwFlagsEx);
	}

	return fSuccess ? hWav : NULL;
}

////
//	helper functions
////

// TelThunkGetPtr - verify that telthunk handle is valid,
//		<hTelThunk>				(i) handle returned from TelThunkInit
// return corresponding telthunk pointer (NULL if error)
//
static LPTELTHUNK TelThunkGetPtr(HTELTHUNK hTelThunk)
{
	BOOL fSuccess = TRUE;
	LPTELTHUNK lpTelThunk;

	if ((lpTelThunk = (LPTELTHUNK) hTelThunk) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpTelThunk, sizeof(TELTHUNK)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the telthunk handle
	//
	else if (lpTelThunk->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpTelThunk : NULL;
}

// TelThunkGetHandle - verify that telthunk pointer is valid,
//		<lpTelThunk>				(i) pointer to TELTHUNK struct
// return corresponding telthunk handle (NULL if error)
//
static HTELTHUNK TelThunkGetHandle(LPTELTHUNK lpTelThunk)
{
	BOOL fSuccess = TRUE;
	HTELTHUNK hTelThunk;

	if ((hTelThunk = (HTELTHUNK) lpTelThunk) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hTelThunk : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\wav.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wav.h - interface for wav functions in wav.c
////

#ifndef __WAV_H__
#define __WAV_H__

#ifdef _WIN32
#define MULTITHREAD 1
#endif

#include "winlocal.h"

#include "wavfmt.h"
#include "wavout.h"
#include "wavin.h"

#define WAV_VERSION 0x00000108

// <dwFlags> values in WavInit
//
#define WAV_TELTHUNK		0x00004000
#define WAV_NOTSMTHUNK		0x00008000
#define WAV_VOXADPCM		0x00000001

// <dwFlags> values in WavOpen
//
#define WAV_READ			0x00000000
#define WAV_WRITE			0x00000001
#define WAV_READWRITE		0x00000002
#define WAV_CREATE			0x00000004
#define WAV_NORIFF			0x00000008
#define WAV_MEMORY			0x00000010
#define WAV_RESOURCE		0x00000020
#define WAV_DENYNONE		0x00000040
#define WAV_DENYREAD		0x00000080
#define WAV_DENYWRITE		0x00000100
#define WAV_EXCLUSIVE		0x00000200
#define WAV_NOACM			0x00000400
#define WAV_DELETE			0x00000800
#define WAV_EXIST			0x00001000
#define WAV_GETTEMP			0x00002000
#define WAV_TELRFILE		0x00008000
#ifdef MULTITHREAD
#define WAV_MULTITHREAD		0x00010000
#define WAV_SINGLETHREAD	0x00020000
#define WAV_COINITIALIZE	0x00040000
#endif

// <dwFlags> values in WavPlay
//
#define WAV_PLAYASYNC		0x00000000
#define WAV_PLAYSYNC		0x00001000
#define WAV_AUTOSTOP		0x00002000
#define WAV_NOAUTOSTOP		0x00004000
#define WAV_AUTOCLOSE		0x00008000

// <dwFlags> values in WavRecord
//
#define WAV_RECORDASYNC		0x00000000
#define WAV_RECORDSYNC		0x00010000

// <dwFlags> values in WavPlaySound
//
#define WAV_ASYNC			0x00000000
#define WAV_SYNC			0x00100000
#define WAV_FILENAME		0x00200000
#define WAV_NODEFAULT		0x00400000
#define WAV_LOOP			0x00800000
#define WAV_NOSTOP			0x01000000
#define WAV_OPENRETRY		0x10000000

// control flags for WavSetSpeed and WavSupportsSpeed
//
#define WAVSPEED_NOPLAYBACKRATE	0x00000001
#define WAVSPEED_NOFORMATADJUST	0x00000002
#define WAVSPEED_NOTSM			0x00000004
#define WAVSPEED_NOACM			0x00000400

// return values from WavGetState
//
#define WAV_STOPPED			0x0001
#define WAV_PLAYING			0x0002
#define WAV_RECORDING		0x0004
#define WAV_STOPPING		0x0008

// <dwFlags> values in WavGetFormat and WavSetFormat
//
#define WAV_FORMATFILE		0x0001
#define WAV_FORMATPLAY		0x0002
#define WAV_FORMATRECORD	0x0004
#define WAV_FORMATALL		(WAV_FORMATFILE | WAV_FORMATPLAY | WAV_FORMATRECORD)

// <dwFlags> values in WavSetVolume and WavSupportsVolume
//
#define WAVVOLUME_MIXER		0x0001

#ifdef TELTHUNK
// control flags for WavOpenEx
//
#define WOX_LOCAL			0x00000001
#define WOX_REMOTE			0x00000002
#define WOX_WAVFMT			0x00000010
#define WOX_VOXFMT			0x00000020
#define WOX_WAVDEV			0x00000100
#define WOX_TELDEV			0x00000200
#endif

// handle returned from WavInit
//
DECLARE_HANDLE32(HWAVINIT);

// handle returned from WavOpen // (NOT the same as Windows HWAVE)
//
DECLARE_HANDLE32(HWAV);

// prototype for <lpfnUserAbort> in WavCopy
//
typedef BOOL (CALLBACK* USERABORTPROC)(DWORD dwUser, int nPctComplete);

// prototype for <lpfnPlayStopped> in WavPlay
//
typedef BOOL (CALLBACK* PLAYSTOPPEDPROC)(HWAV hWav, HANDLE hUser, DWORD dwReserved);

// prototype for <lpfnRecordStopped> in WavRecord
//
typedef BOOL (CALLBACK* RECORDSTOPPEDPROC)(HWAV hWav, DWORD dwUser, DWORD dwReserved);

#ifdef __cplusplus
extern "C" {
#endif

// WavInit - initialize wav engine
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
#ifdef TELTHUNK
//			WAV_TELTHUNK		initialize telephone thunking layer
#endif
//			WAV_NOACM			do not use audio compression manager
//			WAV_VOXADPCM		load acm driver for Dialogic OKI ADPCM
// return handle (NULL if error)
//
HWAVINIT WINAPI WavInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags);

// WavTerm - shut down wav engine
//		<hWavInit>			(i) handle returned from WavInit
// return 0 if success
//
int WINAPI WavTerm(HWAVINIT hWavInit);

// WavOpen - open or create wav file
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpszFileName>		(i) name of file to open or create
//		<lpwfx>				(i) wave format
//			NULL				use format from header or default
//		<lpIOProc>			(i) address of i/o procedure to use
//			NULL				use default i/o procedure
//		<lpadwInfo>			(i) data to pass to i/o procedure during open
//			NULL				no data to pass
//		<dwFlags>			(i) control flags
//			WAV_READ			open file for reading (default)
//			WAV_WRITE			open file for writing
//			WAV_READWRITE		open file for reading and writing
//			WAV_DENYNONE		allow other programs read and write access
//			WAV_DENYREAD		prevent other programs from read access
//			WAV_DENYWRITE		prevent other programs from write access
//			WAV_EXCLUSIVE		prevent other programs from read or write
//			WAV_CREATE			create new file or truncate existing file
//			WAV_NORIFF			file has no RIFF/WAV header
//			WAV_MEMORY			<lpszFileName> points to memory block
//			WAV_RESOURCE		<lpszFileName> points to wave resource
//			WAV_NOACM			do not use audio compression manager
//			WAV_DELETE			delete specified file, return TRUE if success
//			WAV_EXIST			return TRUE if specified file exists
//			WAV_GETTEMP			fill lpszFileName with temp name, return TRUE
//			WAV_TELRFILE		telephone will play audio from file on server
#ifdef MULTITHREAD
//			WAV_MULTITHREAD		support multiple threads (default)
//			WAV_SINGLETHREAD	do not support multiple threads
//			WAV_COINITIALIZE	call CoInitialize in all secondary threads
#endif
// return handle (NULL if error)
//
// NOTE: if WAV_CREATE or WAV_NORIFF are used in <dwFlags>, then the
// <lpwfx> parameter must be specified.  If <lpwfx> is NULL, the
// current default format is assumed.
// WavSetFormat() can be used to set or override the defaults.
//
// NOTE: if WAV_RESOURCE is specified in <dwFlags>, then <lpszFileName>
// must point to a WAVE resource in the module specified by <hInst>.
// If the first character of the string is a pound sign (#), the remaining
// characters represent a decimal number that specifies the resource id.
//
// NOTE: if WAV_MEMORY is specified in <dwFlags>, then <lpszFileName>
// must be a pointer to a memory block obtained by calling MemAlloc().
//
// NOTE: if <lpIOProc> is not NULL, this i/o procedure will be called
// for opening, closing, reading, writing, and seeking the wav file.
// If <lpadwInfo> is not NULL, this array of three (3) DWORDs will be
// passed to the i/o procedure when the wav file is opened.
// See the Windows mmioOpen() and mmioInstallIOProc() function for details
// on these parameters.  Also, the WAV_MEMORY and WAV_RESOURCE flags may
// only be used when <lpIOProc> is NULL.
//
HWAV WINAPI WavOpen(DWORD dwVersion, HINSTANCE hInst,
	LPCTSTR lpszFileName, LPWAVEFORMATEX lpwfx,
	LPMMIOPROC lpIOProc, DWORD FAR *lpadwInfo, DWORD dwFlags);

// WavClose - close wav file
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
int WINAPI WavClose(HWAV hWav);

// WavPlayEx - play data from wav file
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<lpfnPlayStopped>	(i) function to call when play is stopped
//			NULL				do not notify
//		<hUserPlayStopped>	(i) param to pass to lpfnPlayStopped
//		<dwReserved>		(i) reserved; must be zero
//		<dwFlags>			(i) control flags
//			WAV_PLAYASYNC		return when playback starts (default)
//			WAV_PLAYSYNC		return after playback completes
//			WAV_NOSTOP			if device already playing, don't stop it
//			WAV_AUTOSTOP		stop playback when eof reached (default)
//			WAV_NOAUTOSTOP		continue playback until WavStop called
//			WAV_AUTOCLOSE		close wav file after playback stops
//			WAV_OPENRETRY		if output device busy, retry for up to 2 sec
// return 0 if success
//
// NOTE: data from the wav file is sent to the output device in chunks.
// Chunks are submitted to an output device queue, so that when one
// chunk is finished playing, another is ready to start playing. By
// default, each chunk is large enough to hold approximately 666 ms
// of sound, and 3 chunks are maintained in the output device queue.
// WavSetChunks() can be used to override the defaults.
//
// NOTE: if WAV_NOSTOP is specified in <dwFlags>, and the device specified
// by <idDev> is already in use, this function returns without playing.
// Unless this flag is specified, the specified device will be stopped
// so that the new sound can be played.
//
// NOTE: if WAV_AUTOSTOP is specified in <dwFlags>, WavStop() will be
// called automatically when end of file is reached.  This is the
// default behavior, but can be overridden by using the WAV_NOAUTOSTOP
// flag.  WAV_NOAUTOSTOP is useful if you are playing a file that
// is growing dynamically as another program writes to it. If this is
// the case, also use the WAV_DENYNONE flag when calling WavOpen().
//
// NOTE: if WAV_AUTOCLOSE is specified in <dwFlags>, WavClose() will
// be called automatically when playback completes.  This will happen
// when WavStop() is called explicitly, or when WavPlay() reaches end
// of file and WAV_NOAUTOSTOP was not specified.  WAV_AUTOCLOSE is useful
// when used with WAV_PLAYASYNC, since cleanup occurs automatically.
// The <hWav> handle is thereafter invalid, and should not be used again.
//
int WINAPI WavPlay(HWAV hWav, int idDev, DWORD dwFlags);
int DLLEXPORT WINAPI WavPlayEx(HWAV hWav, int idDev,
	PLAYSTOPPEDPROC lpfnPlayStopped, HANDLE hUserPlayStopped,
	DWORD dwReserved, DWORD dwFlags);

// WavRecordEx - record data to wav file
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav input device id
//			-1					use any suitable input device
//		<lpfnRecordStopped>	(i) function to call when record is stopped
//			NULL				do not notify
//		<dwUserRecordStopped>	(i) param to pass to lpfnRecordStopped
//		<msMaxSize>			(i) stop recording if file reaches this size
//			0					no maximum size
//		<dwFlags>			(i) control flags
//			WAV_RECORDASYNC		return when recording starts (default)
//			WAV_RECORDSYNC		return after recording completes
//			WAV_NOSTOP			if device already recording, don't stop it
//			WAV_OPENRETRY		if input device busy, retry for up to 2 sec
// return 0 if success
//
// NOTE: data from the input device is written to the wav file in chunks.
// Chunks are submitted to an input device queue, so that when one
// chunk is finished recording, another is ready to start recording.
// By default, each chunk is large enough to hold approximately 666 ms
// of sound, and 3 chunks are maintained in the input device queue.
// WavSetChunks() can be used to override the defaults.
//
// NOTE: if WAV_NOSTOP is specified in <dwFlags>, and the device specified
// by <idDev> is already in use, this function returns without recording.
// Unless this flag is specified, the specified device will be stopped
// so that the new sound can be recorded.
//
int WINAPI WavRecord(HWAV hWav, int idDev, DWORD dwFlags);
int DLLEXPORT WINAPI WavRecordEx(HWAV hWav, int idDev,
	RECORDSTOPPEDPROC lpfnRecordStopped, DWORD dwUserRecordStopped,
 	long msMaxSize, DWORD dwFlags);

// WavStop - stop playing and/or recording
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
int WINAPI WavStop(HWAV hWav);

// WavRead - read data from wav file
//		<hWav>				(i) handle returned from WavOpen
//		<hpBuf>				(o) buffer to contain bytes read
//		<sizBuf>			(i) size of buffer in bytes
// return bytes read (-1 if error)
//
// NOTE : Even if the read operation does not reach the end of file,
// the number of bytes returned could be less than <sizBuf> if data
// decompression is performed by the wav file's I/O procedure. See the
// <lpIOProc> parameter in WavOpen.  It is safest to keep calling
// WavRead() until 0 bytes are read.
//
long DLLEXPORT WINAPI WavRead(HWAV hWav, void _huge *hpBuf, long sizBuf);

// WavWrite - write data to wav file
//		<hWav>				(i) handle returned from WavOpen
//		<hpBuf>				(i) buffer containing bytes to write
//		<sizBuf>			(i) size of buffer in bytes
// return bytes written (-1 if error)
//
// NOTE : Even if the write operation successfully completes,
// the number of bytes returned could be less than <sizBuf> if data
// compression is performed by the wav file's I/O procedure. See the
// <lpIOProc> parameter in WavOpen.  It is safest to assume no error
// in WavWrite() occurred if the return value is greater than 0.
//
long DLLEXPORT WINAPI WavWrite(HWAV hWav, void _huge *hpBuf, long sizBuf);

// WavSeek - seek within wav file data
//		<hWav>				(i) handle returned from WavOpen
//		<lOffset>			(i) bytes to move pointer
//		<nOrigin>			(i) position to move from
//			0					move pointer relative to start of data chunk
//			1					move pointer relative to current position
//			2					move pointer relative to end of data chunk
// return new file position (-1 if error)
//
long DLLEXPORT WINAPI WavSeek(HWAV hWav, long lOffset, int nOrigin);

// WavGetState - return current wav state
//		<hWav>				(i) handle returned from WavOpen
// return WAV_STOPPED, WAV_PLAYING, WAV_RECORDING, or 0 if error
//
WORD DLLEXPORT WINAPI WavGetState(HWAV hWav);

// WavGetLength - get current wav data length in milleseconds
//		<hWav>				(i) handle returned from WavOpen
// return milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI WavGetLength(HWAV hWav);

// WavSetLength - set current wav data length in milleseconds
//		<hWav>				(i) handle returned from WavOpen
//		<msLength>			(i) length in milleseconds
// return new length in milleseconds if success, otherwise -1
//
// NOTE: afterwards, the current wav data position is set to either
// the previous wav data position or <msLength>, whichever is smaller.
//
long DLLEXPORT WINAPI WavSetLength(HWAV hWav, long msLength);

// WavGetPosition - get current wav data position in milleseconds
//		<hWav>				(i) handle returned from WavOpen
// return milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI WavGetPosition(HWAV hWav);

// WavSetPosition - set current wav data position in milleseconds
//		<hWav>				(i) handle returned from WavOpen
//		<msPosition>		(i) position in milleseconds
// return new position in milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI WavSetPosition(HWAV hWav, long msPosition);

// WavGetFormat - get wav format
//		<hWav>				(i) handle returned from WavOpen
//		<dwFlags>			(i) control flags
//			WAV_FORMATFILE		get format of data in file
//			WAV_FORMATPLAY		get format of output device
//			WAV_FORMATRECORD	get format of input device
// return pointer to specified format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavGetFormat(HWAV hWav, DWORD dwFlags);

// WavSetFormat - set wav format
//		<hWav>				(i) handle returned from WavOpen
//		<lpwfx>				(i) wav format
//		<dwFlags>			(i) control flags
//			WAV_FORMATFILE		set format of data in file
//			WAV_FORMATPLAY		set format of output device
//			WAV_FORMATRECORD	set format of input device
//			WAV_FORMATALL		set all formats
// return 0 if success
//
int DLLEXPORT WINAPI WavSetFormat(HWAV hWav,
	LPWAVEFORMATEX lpwfx, DWORD dwFlags);

// WavChooseFormat - choose and set audio format from dialog box
//		<hWav>				(i) handle returned from WavOpen
//		<hwndOwner>			(i) owner of dialog box
//			NULL				no owner
//		<lpszTitle>			(i) title of the dialog box
//			NULL				use default title ("Sound Selection")
//		<dwFlags>			(i)	control flags
//			WAV_FORMATFILE		set format of data in file
//			WAV_FORMATPLAY		set format of output device
//			WAV_FORMATRECORD	set format of input device
//			WAV_FORMATALL		set all formats
// return 0 if success
//
int DLLEXPORT WINAPI WavChooseFormat(HWAV hWav, HWND hwndOwner, LPCTSTR lpszTitle, DWORD dwFlags);

// WavGetVolume - get current volume level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<dwFlags>			(i) reserved; must be zero
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int DLLEXPORT WINAPI WavGetVolume(HWAV hWav, int idDev, DWORD dwFlags);

// WavSetVolume - set current volume level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<nLevel>			(i) volume level
//			0					minimum volume
//			100					maximum volume
//		<dwFlags>			(i) control flags
//			WAVVOLUME_MIXER		set volume through mixer device
// return 0 if success
//
int DLLEXPORT WINAPI WavSetVolume(HWAV hWav, int idDev, int nLevel, DWORD dwFlags);

// WavSupportsVolume - check if audio can be played at specified volume
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					any suitable output device
//		<nLevel>			(i) volume level
//			0					minimum volume
//			100					maximum volume
//		<dwFlags>			(i) control flags
//			WAVVOLUME_MIXER		check volume support through mixer device
// return TRUE if supported
//
BOOL DLLEXPORT WINAPI WavSupportsVolume(HWAV hWav, int idDev, int nLevel, DWORD dwFlags);

// WavGetSpeed - get current speed level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<dwFlags>			(i) reserved; must be zero
// return speed level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI WavGetSpeed(HWAV hWav, int idDev, DWORD dwFlags);

// WavSetSpeed - set current speed level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
//		<dwFlags>			(i) control flags
#ifdef AVTSM
//			WAVSPEED_NOTSM			do not use time scale modification engine
#endif
//			WAVSPEED_NOPLAYBACKRATE	do not use device driver playback rate
//			WAVSPEED_NOFORMATADJUST	do not use adjusted format to open device
//			WAVSPEED_NOACM			do not use audio compression manager
// return 0 if success
//
// NOTE: In order to accomodate the specified speed change, it is _possible_
// that this function will in turn call WavSetFormat(hWav, ..., WAV_FORMATPLAY)
// to change the playback format of the specified file. You can prevent this
// side-effect by specifying the WAVSPEED_NOACM flag, but this reduces the
// likelihood that WavSetSpeed will succeed.
//
int DLLEXPORT WINAPI WavSetSpeed(HWAV hWav, int idDev, int nLevel, DWORD dwFlags);

// WavSupportsSpeed - check if audio can be played at specified speed
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					any suitable output device
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
//		<dwFlags>			(i) control flags
#ifdef AVTSM
//			WAVSPEED_NOTSM			do not use time scale modification engine
#endif
//			WAVSPEED_NOPLAYBACKRATE	do not use device driver playback rate
//			WAVSPEED_NOFORMATADJUST	do not use adjusted format to open device
//			WAVSPEED_NOACM			do not use audio compression manager
// return TRUE if supported
//
BOOL DLLEXPORT WINAPI WavSupportsSpeed(HWAV hWav, int idDev, int nLevel, DWORD dwFlags);

// WavGetChunks - get chunk count and size
//		<hWav>				(i) handle returned from WavOpen
//			NULL				get default chunk count and size
//		<lpcChunks>			(o) buffer to hold chunk count
//			NULL				do not get chunk count
//		<lpmsChunkSize>		(o) buffer to hold chunk size
//			NULL				do not get chunk size
//		<fWavOut>			(i) TRUE for playback, FALSE for recording
// return 0 if success
//
int DLLEXPORT WINAPI WavGetChunks(HWAV hWav,
	int FAR *lpcChunks, long FAR *lpmsChunkSize, BOOL fWavOut);

// WavSetChunks - set chunk count and size
//		<hWav>				(i) handle returned from WavOpen
//			NULL				set default chunk count and size
//		<cChunks>			(i) number of chunks in device queue
//			-1					do not set chunk count
//		<msChunkSize>		(i) chunk size in milleseconds
//			-1					do not set chunk size
//		<fWavOut>			(i) TRUE for playback, FALSE for recording
// return 0 if success
//
int DLLEXPORT WINAPI WavSetChunks(HWAV hWav, int cChunks, long msChunkSize, BOOL fWavOut);

// WavCalcChunkSize - calculate chunk size in bytes
//		<lpwfx>				(i) wav format
//		<msPlayChunkSize>	(i) chunk size in milleseconds
//			-1					default chunk size
//		<fWavOut>			(i) TRUE for playback, FALSE for recording
// return chunk size in bytes (-1 if success)
//
long DLLEXPORT WINAPI WavCalcChunkSize(LPWAVEFORMATEX lpwfx,
	long msChunkSize, BOOL fWavOut);

// WavCopy - copy data from one open wav file to another
//		<hWavSrc>			(i) source handle returned from WavOpen
//		<hWavDst>			(i) destination handle returned from WavOpen
//		<hpBuf>				(o) pointer to copy buffer
//			NULL				allocate buffer internally
//		<sizBuf>			(i) size of copy buffer
//			-1					default buffer size (16K)
//		<lpfnUserAbort>		(i) function that returns TRUE if user aborts
//			NULL				don't check for user abort
//		<dwUser>			(i) parameter passed to <lpfnUserAbort>
//		<dwFlags>			(i) control flags
//			WAV_NOACM			do not use audio compression manager
// return 0 if success (-1 if error, +1 if user abort)
//
int DLLEXPORT WINAPI WavCopy(HWAV hWavSrc, HWAV hWavDst,
	void _huge *hpBuf, long sizBuf, USERABORTPROC lpfnUserAbort, DWORD dwUser, DWORD dwFlags);

#ifdef AVTSM
// WavReadFormatSpeed - read data from wav file, then format it for speed
//		<hWav>				(i) handle returned from WavOpen
//		<hpBufSpeed>		(o) buffer to contain bytes read
//		<sizBufSpeed>		(i) size of buffer in bytes
// return bytes formatted for speed in <hpBuf> (-1 if error)
//
// NOTE: this function reads a block of data, and then converts it
// from the file format to the speed format, unless those formats
// are identical.
//
long DLLEXPORT WINAPI WavReadFormatSpeed(HWAV hWav, void _huge *hpBufSpeed, long sizBufSpeed);
#endif

// WavReadFormatPlay - read data from wav file, then format it for playback
//		<hWav>				(i) handle returned from WavOpen
//		<hpBufPlay>			(o) buffer to contain bytes read
//		<sizBufPlay>		(i) size of buffer in bytes
// return bytes formatted for playback in <hpBuf> (-1 if error)
//
// NOTE: this function reads a block of data, and then converts it
// from the file format to the playback format, unless those formats
// are identical.
//
long DLLEXPORT WINAPI WavReadFormatPlay(HWAV hWav, void _huge *hpBufPlay, long sizBufPlay);

// WavWriteFormatRecord - write data to file after formatting it for file
//		<hWav>				(i) handle returned from WavOpen
//		<hpBufRecord>		(i) buffer containing bytes in record format
//		<sizBufRecord>		(i) size of buffer in bytes
// return bytes written (-1 if error)
//
// NOTE: this function converts a block of data from the record
// format to the file format (unless those formats are identical),
// and then writes the data to disk.
//
long DLLEXPORT WINAPI WavWriteFormatRecord(HWAV hWav, void _huge *hpBufRecord, long sizBufRecord);

// WavGetOutputDevice - get handle to open wav output device
//		<hWav>				(i) handle returned from WavOpen
// return handle to wav output device (NULL if device not open or error)
//
// NOTE: this function is useful only during playback (after calling
// WavPlay() and before calling WavStop()).  The returned device handle
// can then be used when calling the WavOut functions in wavout.h
//
HWAVOUT DLLEXPORT WINAPI WavGetOutputDevice(HWAV hWav);

// WavGetInputDevice - get handle to open wav input device
//		<hWav>				(i) handle returned from WavOpen
// return handle to wav input device (NULL if device not open or error)
//
// NOTE: this function is useful only during recording (after calling
// WavRecord() and before calling WavStop()).  The returned device handle
// can then be used when calling the WavIn functions in wavin.h
//
HWAVIN DLLEXPORT WINAPI WavGetInputDevice(HWAV hWav);

// WavPlaySound - play wav file
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<lpszFileName>		(i) name of file to play
//			NULL				stop playing current sound, if any
//		<lpwfx>				(i) wave format
//			NULL				use format from header or default
//		<lpIOProc>			(i) address of i/o procedure to use
//			NULL				use default i/o procedure
//		<lpadwInfo>			(i) data to pass to i/o procedure during open
//			NULL				no data to pass
//		<dwFlags>			(i) control flags
//			WAV_ASYNC			return when playback starts (default)
//			WAV_SYNC			return after playback completes
//			WAV_FILENAME		<lpszFileName> points to a filename
//			WAV_RESOURCE		<lpszFileName> points to a resource
//			WAV_MEMORY			<lpszFileName> points to memory block
//			WAV_NODEFAULT		if sound not found, do not play default
//			WAV_LOOP			loop sound until WavPlaySound called again
//			WAV_NOSTOP			if device already playing, don't stop it
//			WAV_NORIFF			file has no RIFF/WAV header
//			WAV_NOACM			do not use audio compression manager
//			WAV_OPENRETRY		if output device busy, retry for up to 2 sec
#ifdef MULTITHREAD
//			WAV_MULTITHREAD		support multiple threads (default)
//			WAV_SINGLETHREAD	do not support multiple threads
//			WAV_COINITIALIZE	call CoInitialize in all secondary threads
#endif
// return 0 if success
//
// NOTE: if WAV_NORIFF is specified in <dwFlags>, then the
// <lpwfx> parameter must be specified.  If <lpwfx> is NULL, the
// current default format is assumed.
// WavSetFormat() can be used to set or override the defaults.
//
// NOTE: if WAV_FILENAME is specified in <dwFlags>, then <lpszFileName>
// must point to a file name.
//
// NOTE: if WAV_RESOURCE is specified in <dwFlags>, then <lpszFileName>
// must point to a WAVE resource in the module specified by <hInst>.
// If the first character of the string is a pound sign (#), the remaining
// characters represent a decimal number that specifies the resource id.
//
// NOTE: if WAV_MEMORY is specified in <dwFlags>, then <lpszFileName>
// must be a pointer to a memory block containing a wav file image.
// The pointer must be obtained by calling MemAlloc().
//
// NOTE: if neither WAV_FILENAME, WAV_RESOURCE, or WAV_MEMORY is specified
// in <dwFlags>, the [sounds] section of win.ini or the registry is
// searched for an entry matching <lpszFileName>.  If no matching entry
// is found, <lpszFileName> is assumed to be a file name.
//
// NOTE: if WAV_NODEFAULT is specified in <dwFlags>, no default sound
// will be played.  Unless this flag is specified, the default system
// event sound entry will be played if the sound specified in
// <lpszFileName> is not found.
//
// NOTE: if WAV_LOOP is specified in <dwFlags>, the sound specified in
// <lpszFileName> will be played repeatedly, until WavPlaySound() is
// called again.  The WAV_ASYNC flag must be specified when using this flag.
//
// NOTE: if WAV_NOSTOP is specified in <dwFlags>, and the device specified
// by <idDev> is already in use, this function returns without playing.
// Unless this flag is specified, the specified device will be stopped
// so that the new sound can be played.
//
// NOTE: if <lpIOProc> is not NULL, this i/o procedure will be called
// for opening, closing, reading, writing, and seeking the wav file.
// If <lpadwInfo> is not NULL, this array of three (3) DWORDs will be
// passed to the i/o procedure when the wav file is opened.
// See the Windows mmioOpen() and mmioInstallIOProc() function for details
// on these parameters.  Also, the WAV_MEMORY and WAV_RESOURCE flags may
// only be used when <lpIOProc> is NULL.
//
int DLLEXPORT WINAPI WavPlaySound(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPCTSTR lpszFileName, LPWAVEFORMATEX lpwfx,
	LPMMIOPROC lpIOProc, DWORD FAR *lpadwInfo, DWORD dwFlags);

// WavSendMessage - send a user-defined message to the i/o procedure
//		<hWav>				(i) handle returned from WavOpen
//		<wMsg>				(i) user-defined message id
//		<lParam1>			(i) parameter for the message
//		<lParam2>			(i) parameter for the message
// return value from the i/o procedure (0 if error or unrecognized message)
//
LRESULT DLLEXPORT WINAPI WavSendMessage(HWAV hWav,
	UINT wMsg, LPARAM lParam1, LPARAM lParam2);

#ifdef TELTHUNK
// WavOpenEx - open an audio file, extra special version
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpszFileName>		(i) name of file to open
//		<dwReserved>		(i) reserved; must be zero
//		<dwFlagsOpen>		(i) control flags to pass to WavOpen
//		<dwFlagsEx>			(i) control flags
//			WOX_LOCAL			file is on local client
//			WOX_REMOTE			file is on remote server
//			WOX_WAVFMT			file is in Microsoft RIFF/WAV format
//			WOX_VOXFMT			file is in Dialogic OKI ADPCM (vox) format
//			WOX_WAVDEV			file will be played on wav output device
//			WOX_TELDEV			file will be played on telephone device
// return handle (NULL if error)
//
HWAV DLLEXPORT WINAPI WavOpenEx(DWORD dwVersion, HINSTANCE hInst,
	LPTSTR lpszFileName, DWORD dwReserved, DWORD dwFlagsOpen, DWORD dwFlagsEx);
#endif

#ifdef __cplusplus
}
#endif

#endif // __WAV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\vox.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// vox.h - interface to vox file functions in vox.c
////

#ifndef __VOX_H__
#define __VOX_H__

#include "winlocal.h"

#include "wavfmt.h"

#define VOX_VERSION 0x00000106

// handle to a vox engine instance
//
DECLARE_HANDLE32(HVOX);

#ifdef __cplusplus
extern "C" {
#endif

// these macros for compatibility with old code
//
#define VoxFormat(lpwfx, nSamplesPerSec) \
	WavFormatVoxadpcm(lpwfx, nSamplesPerSec)
#define VoxFormatPcm(lpwfx) \
	WavFormatPcm(6000, 16, 1, lpwfx)

// VoxInit - initialize vox engine
//		<dwVersion>			(i) must be VOX_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) reserved; must be 0
// return handle (NULL if error)
//
HVOX DLLEXPORT WINAPI VoxInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags);

// VoxTerm - shut down vox engine
//		<hVox>				(i) handle returned from VoxInit
// return 0 if success
//
int DLLEXPORT WINAPI VoxTerm(HVOX hVox);

// VoxReset - reset vox engine
//		<hVox>				(i) handle returned from VoxInit
// return 0 if success
//
int DLLEXPORT WINAPI VoxReset(HVOX hVox);

// VoxDecode_16BitMono - decode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpabVox>			(i) array of encoded samples
//		<lpaiPcm>			(o) array of decoded samples
//		<uSamples>			(i) number of samples to decode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM16 in <lpaiPcm> contains 1 16-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxDecode_16BitMono(HVOX hVox, LPBYTE lpabVox, LPPCM16 lpaiPcm, UINT uSamples);

// VoxEncode_16BitMono - encode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpaiPcm>			(i) array of decoded samples
//		<lpabVox>			(o) array of encoded samples
//		<uSamples>			(i) number of samples to encode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM16 in <lpaiPcm> contains 1 16-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxEncode_16BitMono(HVOX hVox, LPPCM16 lpaiPcm, LPBYTE lpabVox, UINT uSamples);

// VoxDecode_8BitMono - decode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpabVox>			(i) array of encoded samples
//		<lpabPcm>			(o) array of decoded samples
//		<uSamples>			(i) number of samples to decode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM8 in <lpabPcm> contains 1 8-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxDecode_8BitMono(HVOX hVox, LPBYTE lpabVox, LPPCM8 lpabPcm, UINT uSamples);

// VoxEncode_8BitMono - encode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpabPcm>			(i) array of decoded samples
//		<lpabVox>			(o) array of encoded samples
//		<uSamples>			(i) number of samples to encode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM8 in <lpabPcm> contains 1 8-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxEncode_8BitMono(HVOX hVox, LPPCM8 lpabPcm, LPBYTE lpabVox, UINT uSamples);

// VoxIOProc - i/o procedure for vox format file data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing vox format file data.
//
LRESULT DLLEXPORT CALLBACK VoxIOProc(LPTSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#ifdef __cplusplus
}
#endif

#endif // __VOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\vox.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	vox.c - vox file format (OKI ADPCM) functions
////

#include "winlocal.h"

#include "vox.h"
#include "wav.h"
#include "mem.h"
#include "mmio.h"
#include "sys.h"
#include "trace.h"

////
//	private definitions
////

// step size type
//
typedef __int16 ss_type;

// vox engine control structure
//
typedef struct VOX
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	DWORD dwFlags;
	ss_type ssDecoder;		// decoder step size
	ss_type ssEncoder;		// encoder step size
	PCM16 iVoxDecode;		// previous decoded sample
} VOX, FAR *LPVOX;

// macros to convert vox 12 bit samples to/from other size samples
//
#define _Vox12To16(intx) ((PCM16) ((PCM16) (intx) << 4))
#define _Vox12To8(intx) ((BYTE) (((PCM16) (intx) >> 4) + 128))
#define _Vox8To12(bytex) (((PCM16) (bytex) - 128) << 4)
#define _Vox16To12(intx) ((PCM16) (intx) >> 4)

// helper functions
//
static LPVOX VoxGetPtr(HVOX hVox);
static HVOX VoxGetHandle(LPVOX lpVox);
static void ReverseIndexTableInit(void);
static PCM16 DecodeSample(BYTE bVoxEncode, ss_type FAR *lpss, PCM16 iVoxDecodePrev);
static BYTE EncodeSample(__int16 iDelta, ss_type FAR *lpss);

static LRESULT VoxIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName);
static LRESULT VoxIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags);
static LRESULT VoxIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch);
static LRESULT VoxIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush);
static LRESULT VoxIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin);
static LRESULT VoxIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName);
static LRESULT VoxIOGetInfo(LPMMIOINFO lpmmioinfo, int iInfo);
static LRESULT VoxIOChSize(LPMMIOINFO lpmmioinfo, long lSize);

////
//	public functions
////

// VoxInit - initialize vox engine
//		<dwVersion>			(i) must be VOX_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) reserved; must be 0
// return handle (NULL if error)
//
HVOX DLLEXPORT WINAPI VoxInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox = NULL;

	if (dwVersion != VOX_VERSION)
		fSuccess = TraceFALSE(NULL);

	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpVox = (LPVOX) MemAlloc(NULL, sizeof(VOX), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// initialize engine structure
		//
		lpVox->dwVersion = dwVersion;
		lpVox->hInst = hInst;
		lpVox->hTask = GetCurrentTask();
		lpVox->dwFlags = dwFlags;

		ReverseIndexTableInit();

		if (VoxReset(VoxGetHandle(lpVox)) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (!fSuccess)
	{
		VoxTerm(VoxGetHandle(lpVox));
		lpVox = NULL;
	}

	return fSuccess ? VoxGetHandle(lpVox) : NULL;
}

// VoxTerm - shut down vox engine
//		<hVox>				(i) handle returned from VoxInit
// return 0 if success
//
int DLLEXPORT WINAPI VoxTerm(HVOX hVox)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;
	
	if ((lpVox = VoxGetPtr(hVox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpVox = MemFree(NULL, lpVox)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// VoxReset - reset vox engine
//		<hVox>				(i) handle returned from VoxInit
// return 0 if success
//
int DLLEXPORT WINAPI VoxReset(HVOX hVox)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;
	
	if ((lpVox = VoxGetPtr(hVox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpVox->ssDecoder = 16;
		lpVox->ssEncoder = 16;
		lpVox->iVoxDecode = 0;
	}

	return fSuccess ? 0 : -1;
}

// VoxDecode_16BitMono - decode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpabVox>			(i) array of encoded samples
//		<lpaiPcm>			(o) array of decoded samples
//		<uSamples>			(i) number of samples to decode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM16 in <lpaiPcm> contains 1 16-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxDecode_16BitMono(HVOX hVox, LPBYTE lpabVox, LPPCM16 lpaiPcm, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;

	if ((lpVox = VoxGetPtr(hVox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpaiPcm == NULL || lpabVox == NULL)
		fSuccess = TraceFALSE(NULL);

	// since there are two samples per Vox data byte,
	// we will decode two samples each time through the loop
	//
	else while (uSamples > 1)
	{
		BYTE bData;

		bData = *lpabVox++;

		lpVox->iVoxDecode = DecodeSample((BYTE)
			(0xFF & ((BYTE) (bData >> 4) & (BYTE) 0x0F)),
			&lpVox->ssDecoder, lpVox->iVoxDecode);

		*lpaiPcm++ = _Vox12To16(lpVox->iVoxDecode);

		lpVox->iVoxDecode = DecodeSample((BYTE)
			(0xFF & (bData & (BYTE) 0x0F)),
			&lpVox->ssDecoder, lpVox->iVoxDecode);

		*lpaiPcm++ = _Vox12To16(lpVox->iVoxDecode);

		uSamples -= 2;
	}

	return fSuccess ? 0 : -1;
}

// VoxEncode_16BitMono - encode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpaiPcm>			(i) array of decoded samples
//		<lpabVox>			(o) array of encoded samples
//		<uSamples>			(i) number of samples to encode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM16 in <lpaiPcm> contains 1 16-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxEncode_16BitMono(HVOX hVox, LPPCM16 lpaiPcm, LPBYTE lpabVox, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;

	if ((lpVox = VoxGetPtr(hVox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpaiPcm == NULL || lpabVox == NULL)
		fSuccess = TraceFALSE(NULL);

	// since there are two samples per Vox data byte,
	// we will encode two samples each time through the loop
	//
	else while (uSamples > 1)
	{
		__int16 iDelta;
		PCM16 iVoxDecode;
		BYTE bVoxEncode1;
		BYTE bVoxEncode2;

		iVoxDecode = _Vox16To12(*lpaiPcm++);

		iDelta = iVoxDecode - lpVox->iVoxDecode;
		bVoxEncode1 = EncodeSample(iDelta, &lpVox->ssEncoder);
		lpVox->iVoxDecode = DecodeSample(bVoxEncode1, &lpVox->ssDecoder, lpVox->iVoxDecode);

		iVoxDecode = _Vox16To12(*lpaiPcm++);

		iDelta = iVoxDecode - lpVox->iVoxDecode;
		bVoxEncode2 = EncodeSample(iDelta, &lpVox->ssEncoder);
		lpVox->iVoxDecode = DecodeSample(bVoxEncode2, &lpVox->ssDecoder, lpVox->iVoxDecode);

		*lpabVox++ = (BYTE) (((BYTE) (bVoxEncode1 << 4) & (BYTE) 0xF0) | bVoxEncode2);

		uSamples -= 2;
	}

	return fSuccess ? 0 : -1;
}

// VoxDecode_8BitMono - decode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpabVox>			(i) array of encoded samples
//		<lpabPcm>			(o) array of decoded samples
//		<uSamples>			(i) number of samples to decode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM8 in <lpabPcm> contains 1 8-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxDecode_8BitMono(HVOX hVox, LPBYTE lpabVox, LPPCM8 lpabPcm, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;

	if ((lpVox = VoxGetPtr(hVox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpabPcm == NULL || lpabVox == NULL)
		fSuccess = TraceFALSE(NULL);

	// since there are two samples per Vox data byte,
	// we will decode two samples each time through the loop
	//
	else while (uSamples > 1)
	{
		BYTE bData;

		bData = *lpabVox++;

		lpVox->iVoxDecode = DecodeSample((BYTE)
			(0xFF & ((BYTE) (bData >> 4) & (BYTE) 0x0F)),
			&lpVox->ssDecoder, lpVox->iVoxDecode);

		*lpabPcm++ = _Vox12To8(lpVox->iVoxDecode);

		lpVox->iVoxDecode = DecodeSample((BYTE)
			(0xFF & (bData & (BYTE) 0x0F)),
			&lpVox->ssDecoder, lpVox->iVoxDecode);

		*lpabPcm++ = _Vox12To8(lpVox->iVoxDecode);

		uSamples -= 2;
	}

	return fSuccess ? 0 : -1;
}

// VoxEncode_8BitMono - encode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpabPcm>			(i) array of decoded samples
//		<lpabVox>			(o) array of encoded samples
//		<uSamples>			(i) number of samples to encode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM8 in <lpabPcm> contains 1 8-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxEncode_8BitMono(HVOX hVox, LPPCM8 lpabPcm, LPBYTE lpabVox, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;

	if ((lpVox = VoxGetPtr(hVox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpabPcm == NULL || lpabVox == NULL)
		fSuccess = TraceFALSE(NULL);

	// since there are two samples per Vox data byte,
	// we will encode two samples each time through the loop
	//
	else while (uSamples > 1)
	{
		__int16 iDelta;
		PCM16 iVoxDecode;
		BYTE bVoxEncode1;
		BYTE bVoxEncode2;

		iVoxDecode = _Vox8To12(*lpabPcm++);

		iDelta = iVoxDecode - lpVox->iVoxDecode;
		bVoxEncode1 = EncodeSample(iDelta, &lpVox->ssEncoder);
		lpVox->iVoxDecode = DecodeSample(bVoxEncode1, &lpVox->ssDecoder, lpVox->iVoxDecode);

		iVoxDecode = _Vox8To12(*lpabPcm++);

		iDelta = iVoxDecode - lpVox->iVoxDecode;
		bVoxEncode2 = EncodeSample(iDelta, &lpVox->ssEncoder);
		lpVox->iVoxDecode = DecodeSample(bVoxEncode2, &lpVox->ssDecoder, lpVox->iVoxDecode);

		*lpabVox++ = (BYTE) (((BYTE) (bVoxEncode1 << 4) & (BYTE) 0xF0) | bVoxEncode2);

		uSamples -= 2;
	}

	return fSuccess ? 0 : -1;
}

// VoxIOProc - i/o procedure for vox format file data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing vox format file data.
//
LRESULT DLLEXPORT CALLBACK VoxIOProc(LPTSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult = 0;

	if (lpmmioinfo == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (uMessage)
	{
		case MMIOM_OPEN:
			lResult = VoxIOOpen((LPMMIOINFO) lpmmioinfo,
				(LPTSTR) lParam1);
			break;

		case MMIOM_CLOSE:
			lResult = VoxIOClose((LPMMIOINFO) lpmmioinfo,
				(UINT) lParam1);
			break;

		case MMIOM_READ:
			lResult = VoxIORead((LPMMIOINFO) lpmmioinfo,
				(HPSTR) lParam1, (LONG) lParam2);
			break;

		case MMIOM_WRITE:
			lResult = VoxIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, FALSE);
			break;

		case MMIOM_WRITEFLUSH:
			lResult = VoxIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, TRUE);
			break;

		case MMIOM_SEEK:
			lResult = VoxIOSeek((LPMMIOINFO) lpmmioinfo,
				(LONG) lParam1, (int) lParam2);
			break;

		case MMIOM_RENAME:
			lResult = VoxIORename((LPMMIOINFO) lpmmioinfo,
				(LPCTSTR) lParam1, (LPCTSTR) lParam2);
			break;

		case MMIOM_GETINFO:
			lResult = VoxIOGetInfo((LPMMIOINFO) lpmmioinfo,
				(int) lParam1);
			break;

		case MMIOM_CHSIZE:
			lResult = VoxIOChSize((LPMMIOINFO) lpmmioinfo,
				(long) lParam1);
			break;

		default:
			lResult = 0;
			break;
	}

	return lResult;
}

////
//	private functions
////

// VoxGetPtr - verify that vox handle is valid,
//		<hVox>				(i) handle returned from VoxInit
// return corresponding vox pointer (NULL if error)
//
static LPVOX VoxGetPtr(HVOX hVox)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;

	if ((lpVox = (LPVOX) hVox) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpVox, sizeof(VOX)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the vox engine handle
	//
	else if (lpVox->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpVox : NULL;
}

// VoxGetHandle - verify that vox pointer is valid,
//		<lpVox>				(i) pointer to VOX structure
// return corresponding vox handle (NULL if error)
//
static HVOX VoxGetHandle(LPVOX lpVox)
{
	BOOL fSuccess = TRUE;
	HVOX hVox;

	if ((hVox = (HVOX) lpVox) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hVox : NULL;
}

////
//	low-level ADPCM stuff
////

static ss_type const ss_table[] =
	{
	16, 17, 19, 21, 23, 25, 28, 31, 34, 37,
	41, 45, 50, 55, 60, 66, 73, 80, 88, 97,
	107, 118, 130, 143, 157, 173, 190, 209, 230, 253,
	279, 307, 337, 371, 408, 449, 494, 544, 598, 658,
	724, 796, 876, 963, 1060, 1166, 1282, 1411, 1552
	};

static __int16 delta_index_table[] =
	{
	-1, -1, -1, -1, +2, +4, +6, +8, -1, -1, -1, -1, +2, +4, +6, +8
	};

////
//	The reverse index table is designed so that given a step size, we
//	can get back out the index that generated it.
////
static BYTE reverse_index_table[1553];

// initialize reverse index table
//
static void ReverseIndexTableInit(void)
{
 	__int16 i;

 	for (i = 0; i < 49; ++i)
 		reverse_index_table[ss_table[i]] = (BYTE) i;
}

#if 0
static ss_type new_ss(ss_type ss, BYTE bVoxEncode);
static ss_type new_ss(ss_type ss, BYTE bVoxEncode)
{
	__int16 index;

	// find out what our old index into the step size table was
	//
	index = reverse_index_table[ss];

	// modify our index based on the present value of the ADPCM nibble
	//
	index += delta_index_table[bVoxEncode];

	// limit ourselves to the maximum size of the table in case of overflow
	//
	index = max(0, min(48, index));

	// and return our new step size out of the table
	//
	return ss_table[index];
}
#else
#define new_ss(ss, bVoxEncode) ss_table[max(0, min(48, \
	reverse_index_table[ss] + delta_index_table[bVoxEncode]))]
#endif

// DECODE - ADPCM to linear
//
static PCM16 DecodeSample(BYTE bVoxEncode, ss_type FAR *lpss, PCM16 iVoxDecodePrev)
{
	__int16 iDelta;
	PCM16 iVoxDecode;
	ss_type ss;

	ss = *lpss;

	// iDelta = (((nibble * 2) + 1) / 8 ) * ss;
	//
	iDelta = ((((bVoxEncode & 0x07) << 1) + 1) * ss ) >> 3;

	if ((bVoxEncode & 0x08) == 0x08)
		iDelta = -iDelta;

	*lpss = new_ss(ss, bVoxEncode);
	iVoxDecode = iVoxDecodePrev + iDelta;

	// limit ourselves to 12 bits of resolution
	//
	if (iVoxDecode > 2047)
		return 2047;
	else if (iVoxDecode < -2048)
		return -2048;
	else
		return iVoxDecode;
}

// ENCODE - linear to ADPCM
//
static BYTE EncodeSample(__int16 iDelta, ss_type FAR *lpss)
{
	BYTE bVoxEncode;
	ss_type ss;
	__int16 iDeltaTmp;

	ss = *lpss;
	iDeltaTmp = iDelta;

	if (iDeltaTmp < 0)
	{
		iDeltaTmp = -iDeltaTmp;
		bVoxEncode = 0x08;
	}
	else
		bVoxEncode = 0;

	if (iDeltaTmp >= ss)
	{
		bVoxEncode |= 0x04;
		iDeltaTmp -= ss;
	}

	if (iDeltaTmp >= (ss >> 1))
	{
		bVoxEncode |= 0x02;
		iDeltaTmp -= (ss >> 1);
	}

	if (iDeltaTmp >= (ss >> 2))
	{
		bVoxEncode |= 0x01;
	}

	*lpss = new_ss(ss, bVoxEncode);

	return (BYTE) (bVoxEncode & (BYTE) 0x0F);

	// format of return nibble is
	//	S W F F
	//	| | | |
	//	| | | +--- 1/4 of delta/step
	//	| | +----- 1/2 of delta/step
	//	| +------- whole part of delta/step
	//	+--------- sign bit
}


////
//	installable file i/o procedures
////

static LRESULT VoxIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = NULL;
	MMIOINFO mmioinfo;
	HVOX hVox = NULL;
	HINSTANCE hInst;

 	TracePrintf_1(NULL, 5,
 		TEXT("VoxIOOpen (%s)\n"),
		(LPTSTR) lpszFileName);

	MemSet(&mmioinfo, 0, sizeof(mmioinfo));

	// interpret first value passed as pointer to next i/o procedure in chain
	//
	mmioinfo.pIOProc = (LPMMIOPROC) lpmmioinfo->adwInfo[0];

	// pass along second and third values to next i/o procedure
	//
	mmioinfo.adwInfo[0] = lpmmioinfo->adwInfo[1];
	mmioinfo.adwInfo[1] = lpmmioinfo->adwInfo[2];
	mmioinfo.adwInfo[2] = 0L;

	// get instance handle of current task
	//
	if ((hInst = SysGetTaskInstance(NULL)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hVox = VoxInit(VOX_VERSION, hInst, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hmmio = mmioOpen(lpszFileName, &mmioinfo, lpmmioinfo->dwFlags)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// save stuff for use in other i/o routines
		//
		lpmmioinfo->adwInfo[0] = (DWORD) (LPVOID) hmmio;
		lpmmioinfo->adwInfo[1] = (DWORD) (LPVOID) hVox;
	}

	// clean up after error
	//
	if (!fSuccess && hVox != NULL && VoxTerm(hVox) != 0)
		fSuccess = TraceFALSE(NULL);

	if (!fSuccess && hmmio != NULL && mmioClose(hmmio, 0) != 0)
		fSuccess = TraceFALSE(NULL);

	// return the same error code given by mmioOpen
	//
	return fSuccess ? lpmmioinfo->wErrorRet = mmioinfo.wErrorRet : MMIOERR_CANNOTOPEN;
}

static LRESULT VoxIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	HVOX hVox = (HVOX) lpmmioinfo->adwInfo[1];
	UINT uRet = MMIOERR_CANNOTCLOSE;

 	TracePrintf_0(NULL, 5,
 		TEXT("VoxIOClose\n"));

	if (VoxTerm(hVox) != 0)
		fSuccess = TraceFALSE(NULL);

	else if ((uRet = mmioClose(hmmio, uFlags)) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpmmioinfo->adwInfo[0] = (DWORD) NULL;
		lpmmioinfo->adwInfo[1] = (DWORD) NULL;
	}

	return fSuccess ? 0 : uRet;
}

static LRESULT VoxIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	HVOX hVox = (HVOX) lpmmioinfo->adwInfo[1];
	LONG cchVox;
	LONG lBytesRead;
	HPSTR pchVox = NULL;

 	TracePrintf_1(NULL, 5,
 		TEXT("VoxIORead (%ld)\n"),
		(long) cch);

	// vox format files contain 4 bit samples,
	// but we must simulate access to 16 bit samples.
	//
	cchVox = cch / 4L;
	
	if (cchVox <= 0)
		lBytesRead = 0; // nothing to do

	// allocate temporary buffer to hold the vox format samples
	//
	if ((pchVox = (HPSTR) MemAlloc(NULL, cchVox, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// read vox format samples
	//
	else if ((lBytesRead = mmioRead(hmmio, pchVox, cchVox)) == -1)
		fSuccess = TraceFALSE(NULL);

	// decode vox format samples into pcm format samples
	// (there are 2 samples encoded in each vox byte)
	//
	else if (VoxDecode_16BitMono(hVox, (LPBYTE) pchVox, (LPPCM16) pch, (UINT) (lBytesRead * 2L)) != 0)
		fSuccess = TraceFALSE(NULL);

	// update simulated file position
	//
	if (fSuccess)
		lpmmioinfo->lDiskOffset += lBytesRead * 4L;

 	TracePrintf_2(NULL, 5,
 		TEXT("VoxIO: lpmmioinfo->lDiskOffset=%ld, lBytesRead=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesRead);

	// clean up
	//
	if (pchVox != NULL &&
		(pchVox = MemFree(NULL, pchVox)) != NULL)
		fSuccess = TraceFALSE(NULL);

	// return number of bytes read/decoded into pch
	//
	return fSuccess ? lBytesRead * 4L : -1;
}

static LRESULT VoxIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	HVOX hVox = (HVOX) lpmmioinfo->adwInfo[1];
	HPSTR pchVox = NULL;
	LONG cchVox;
	LONG lBytesWritten;

 	TracePrintf_1(NULL, 5,
 		TEXT("VoxIOWrite (%ld)\n"),
		(long) cch);

	// vox format files contain 4 bit samples,
	// but we must simulate access to 16 bit samples.
	//
	cchVox = cch / 4L;
	
	if (cchVox <= 0)
		lBytesWritten = 0; // nothing to do

	// allocate temporary buffer to hold the vox format samples
	//
	else if ((pchVox = (HPSTR) MemAlloc(NULL, cchVox, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// encode pcm format samples into vox format samples
	// (there are 2 bytes required for each pcm sample)
	//
	else if (VoxEncode_16BitMono(hVox, (LPPCM16) pch, (LPBYTE) pchVox, (UINT) (cch / 2L)) != 0)
		fSuccess = TraceFALSE(NULL);

	// write vox format samples
	//
	else if ((lBytesWritten = mmioWrite(hmmio, pchVox, cchVox)) == -1)
		fSuccess = TraceFALSE(NULL);

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset += lBytesWritten * 4L;

	// clean up
	//
	if (pchVox != NULL &&
		(pchVox = MemFree(NULL, pchVox)) != NULL)
		fSuccess = TraceFALSE(NULL);

 	TracePrintf_2(NULL, 5,
 		TEXT("VoxIO: lpmmioinfo->lDiskOffset=%ld, lBytesWritten=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesWritten);

	// return number of bytes encoded/written from pch
	//
	return fSuccess ? lBytesWritten * 4L : -1;
}

static LRESULT VoxIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	LONG lPosNew;

 	TracePrintf_2(NULL, 5,
 		TEXT("VoxIOSeek (%ld, %d)\n"),
		(long) lOffset,
		(int) iOrigin);

	// vox format files contain 4 bit samples,
	// but we must simulate access to 16 bit samples.
	//
	if ((lPosNew = mmioSeek(hmmio, lOffset / 4L, iOrigin)) == -1)
		fSuccess = TraceFALSE(NULL);

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset = lPosNew * 4L;

 	TracePrintf_1(NULL, 5,
 		TEXT("VoxIO: lpmmioinfo->lDiskOffset=%ld\n"),
		(long) lpmmioinfo->lDiskOffset);

	return fSuccess ? lpmmioinfo->lDiskOffset : -1;
}

static LRESULT VoxIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName)
{
	BOOL fSuccess = TRUE;
	UINT uRet = MMIOERR_FILENOTFOUND;

 	TracePrintf_2(NULL, 5,
 		TEXT("VoxIORename (%s, %s)\n"),
		(LPTSTR) lpszFileName,
		(LPTSTR) lpszNewFileName);

	if ((uRet = mmioRename(lpszFileName, lpszNewFileName, lpmmioinfo, 0)) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : uRet;
}

static LRESULT VoxIOGetInfo(LPMMIOINFO lpmmioinfo, int iInfo)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	LRESULT lResult;

 	TracePrintf_1(NULL, 5,
 		TEXT("VoxIOGetInfo (%d)\n"),
		(int) iInfo);

	lResult = mmioSendMessage(hmmio, MMIOM_GETINFO, iInfo, 0);
#if 1
	if (iInfo == 1)
	{
		// vox format files contain 4 bit samples,
		// but we must simulate access to 16 bit samples.
		//
		lResult *= 4;
	}
#endif
	return fSuccess ? lResult : 0;
}

static LRESULT VoxIOChSize(LPMMIOINFO lpmmioinfo, long lSize)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	LRESULT lResult;

 	TracePrintf_1(NULL, 5,
 		TEXT("VoxIOChSize (%ld)\n"),
		(long) lSize);

	lResult = mmioSendMessage(hmmio, MMIOM_CHSIZE, lSize, 0);

	return fSuccess ? lResult : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\wavfmt.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wavfmt.c - wave format functions
////

#include "winlocal.h"

#include <stdlib.h>
#include <stddef.h>

#include "wavfmt.h"
#include "calc.h"
#include "mem.h"
#include "trace.h"

////
//	private definitions
////

#define SAMPLERATE_DEFAULT			11025
#define SAMPLERATE_MAX				64000
#define SAMPLERATE_MIN				1000

#define SAMPLESIZE_DEFAULT 			8
#define SAMPLESIZE_MAX				32
#define SAMPLESIZE_MIN				0

#define CHANNELS_DEFAULT			1
#define CHANNELS_MAX				2
#define CHANNELS_MIN				1

////
//	public functions
////

// WavFormatPcm - fill WAVEFORMATEX struct based on PCM characteristics
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (11025)
//		<nBitsPerSample>	(i) sample size
//			-1					default sample size (8)
//		<nChannels>			(i) number of channels (1=mono, 2=stereo)
//			-1					default (mono)
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatPcm(long nSamplesPerSec,
	WORD nBitsPerSample, WORD nChannels, LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX lpwfxNew = lpwfx;

	if (nSamplesPerSec == -1)
		nSamplesPerSec = SAMPLERATE_DEFAULT;
		
	if (nBitsPerSample == -1)
		nBitsPerSample = SAMPLESIZE_DEFAULT;

	if (nChannels == -1)
		nChannels = CHANNELS_DEFAULT;

	// user passed struct to fill
	//
	if (lpwfx != NULL && IsBadReadPtr(lpwfx, sizeof(WAVEFORMATEX)))
		fSuccess = TraceFALSE(NULL);

	// we allocate struct to fill
	//
	else if (lpwfx == NULL
		&& (lpwfxNew = WavFormatAlloc(sizeof(WAVEFORMATEX))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// fill the struct
	//
	else
	{
		lpwfxNew->wFormatTag = WAVE_FORMAT_PCM;
		lpwfxNew->nChannels = nChannels;
		lpwfxNew->nSamplesPerSec = nSamplesPerSec;
		lpwfxNew->nBlockAlign = nChannels * (((nBitsPerSample - 1) / 8) + 1);
		lpwfxNew->nAvgBytesPerSec = lpwfxNew->nBlockAlign * nSamplesPerSec;
		lpwfxNew->wBitsPerSample = nBitsPerSample;
		lpwfxNew->cbSize = 0;
	}

	return fSuccess ? lpwfxNew : NULL;
}

// WavFormatAlloc - allocate WAVEFORMATEX struct buffer
//		<cbSize>			(i) size of struct, including extra bytes
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatAlloc(WORD cbSize)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX lpwfx;

	if (cbSize < sizeof(WAVEFORMATEX))
		fSuccess = TraceFALSE(NULL);

	// memory is allocated such that the client owns it
	//
	else if ((lpwfx = (LPWAVEFORMATEX) MemAlloc(NULL, cbSize, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);
	else
		lpwfx->cbSize = cbSize - sizeof(WAVEFORMATEX);

	return fSuccess ? lpwfx : NULL;
}

// WavFormatDup - duplicate WAVEFORMATEX structure
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return pointer to new WAVEFORMATEX struct, NULL if error
//
// NOTE: use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatDup(LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX lpwfxNew;

	if (lpwfx == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadReadPtr(lpwfx, WavFormatGetSize(lpwfx)))
		fSuccess = TraceFALSE(NULL);

	else if ((lpwfxNew = WavFormatAlloc((WORD)
		WavFormatGetSize(lpwfx))) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		MemCpy(lpwfxNew, lpwfx, WavFormatGetSize(lpwfx));

	return fSuccess ? lpwfxNew : NULL;
}

// WavFormatFree - free WAVEFORMATEX struct
//		<lpwfx>				(i) pointer returned from WavFormatAlloc/Dup/Pcm
// return 0 if success
//
int DLLEXPORT WINAPI WavFormatFree(LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;

	if (lpwfx == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpwfx = MemFree(NULL, lpwfx)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// WavFormatIsValid - check format for validity
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return TRUE if valid format
//
BOOL DLLEXPORT WINAPI WavFormatIsValid(LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;

	if (lpwfx == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadReadPtr(lpwfx, sizeof(WAVEFORMATEX)))
		fSuccess = TraceFALSE(NULL);

	else if (IsBadReadPtr(lpwfx, WavFormatGetSize(lpwfx)))
		fSuccess = TraceFALSE(NULL);

	else if (lpwfx->nSamplesPerSec < SAMPLERATE_MIN ||
		lpwfx->nSamplesPerSec > SAMPLERATE_MAX)
		fSuccess = TraceFALSE(NULL);

	else if (lpwfx->wBitsPerSample < SAMPLESIZE_MIN ||
		lpwfx->wBitsPerSample > SAMPLESIZE_MAX)
		fSuccess = TraceFALSE(NULL);

	else if (lpwfx->nChannels < CHANNELS_MIN ||
		lpwfx->nChannels > CHANNELS_MAX)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? TRUE : FALSE;
}

// WavFormatCmp - compare one format with another
//		<lpwfx1>			(i) pointer to WAVEFORMATEX struct
//		<lpwfx2>			(i) pointer to WAVEFORMATEX struct
// return 0 if identical
//
#if 0
// NOTE: this function does NOT compare the cbSize field or the extra bytes
#else
// NOTE: this function does NOT compare the extra bytes beyond the cbSize field
#endif
//
int DLLEXPORT WINAPI WavFormatCmp(LPWAVEFORMATEX lpwfx1, LPWAVEFORMATEX lpwfx2)
{
	BOOL fSuccess = TRUE;
	int nCmp = 0; // assume identical

	if (!WavFormatIsValid(lpwfx1))
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfx2))
		fSuccess = TraceFALSE(NULL);

	else
	{
#if 0
		// compare up to (but not including) the cbSize field
		//
		nCmp = MemCmp(lpwfx1, lpwfx2,
			offsetof(WAVEFORMATEX, cbSize));
#else
		// compare up to and including the cbSize field
		//
		nCmp = MemCmp(lpwfx1, lpwfx2, sizeof(WAVEFORMATEX));
#endif
	}

	return fSuccess ? nCmp : -1;
}

// WavFormatCopy - copy one format to another
//		<lpwfxDst>			(i) pointer to destination WAVEFORMATEX struct
//		<lpwfxSrc>			(i) pointer to source WAVEFORMATEX struct
// return 0 if success
//
#if 0
// NOTE: this function does NOT copy the cbSize field or the extra bytes
#else
// NOTE: make sure lpwfxDst points to enough memory to contain the entire
// WAVEFORMATEX struct plus any extra bytes beyond it
#endif
//
int DLLEXPORT WINAPI WavFormatCopy(LPWAVEFORMATEX lpwfxDst, LPWAVEFORMATEX lpwfxSrc)
{
	BOOL fSuccess = TRUE;

	if (!WavFormatIsValid(lpwfxSrc))
		fSuccess = TraceFALSE(NULL);

	else if (lpwfxDst == NULL)
		fSuccess = TraceFALSE(NULL);

#if 0
	// make sure destination is at least as big as WAVEFORMATEX struct
	//
	else if (IsBadReadPtr(lpwfxDst, sizeof(WAVEFORMATEX))
		fSuccess = TraceFALSE(NULL);

	else
	{
		// copy up to (but not including) the cbSize field
		//
		MemCpy(lpwfxDst, lpwfxSrc,
			offsetof(WAVEFORMATEX, cbSize));
	}
#else
	// make sure destination is at least as big as source
	//
	else if (IsBadReadPtr(lpwfxDst, WavFormatGetSize(lpwfxSrc)))
		fSuccess = TraceFALSE(NULL);

	else
	{
		// copy entire structure, including any extra bytes
		//
		MemCpy(lpwfxDst, lpwfxSrc, WavFormatGetSize(lpwfxSrc));
	}
#endif

	return fSuccess ? 0 : -1;
}

// WavFormatGetSize - check size of format structure
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return size of structure, 0 if error
//
int DLLEXPORT WINAPI WavFormatGetSize(LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	int sizwfx = 0;

	if (lpwfx == NULL)
		fSuccess = TraceFALSE(NULL);

	// ignore cbSize value if pcm format
	//
	else if (lpwfx->wFormatTag == WAVE_FORMAT_PCM)
		sizwfx = sizeof(WAVEFORMATEX);

	else
		sizwfx = sizeof(WAVEFORMATEX) + lpwfx->cbSize;

	return fSuccess ? sizwfx : 0;
}

// WavFormatDump - dump WAVEFORMATEX struct to debug
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return 0 if success
//
int DLLEXPORT WINAPI WavFormatDump(LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;

	if (lpwfx == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadReadPtr(lpwfx, sizeof(WAVEFORMATEX)))
		fSuccess = TraceFALSE(NULL);

	else
	{
		TracePrintf_7(NULL, 1,
			TEXT("struct tWAVEFORMATEX\n")
			TEXT("{\n")
				TEXT("\tWORD\twFormatTag = %u;\n")
				TEXT("\tWORD\tnChannels = %u;\n")
				TEXT("\tDWORD\tnSamplesPerSec = %lu;\n")
				TEXT("\tDWORD\tnAvgBytesPerSec = %lu;\n")
				TEXT("\tWORD\tnBlockAlign = %u;\n")
				TEXT("\tWORD\twBitsPerSample = %u;\n")
				TEXT("\tWORD\tcbSize = %u;\n")
			TEXT("} WAVEFORMATEX\n"),
			(unsigned int) lpwfx->wFormatTag,
			(unsigned int) lpwfx->nChannels,
			(unsigned long) lpwfx->nSamplesPerSec,
			(unsigned long) lpwfx->nAvgBytesPerSec,
			(unsigned int) lpwfx->nBlockAlign,
			(unsigned int) lpwfx->wBitsPerSample,
			(unsigned int) lpwfx->cbSize);
	}

	return fSuccess ? 0 : -1;
}

// WavFormatBytesToMilleseconds - convert bytes to milleseconds
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
//		<dwBytes>			(i) bytes
// return milleseconds
//
DWORD DLLEXPORT WINAPI WavFormatBytesToMilleseconds(LPWAVEFORMATEX lpwfx, DWORD dwBytes)
{
	if (lpwfx == NULL || lpwfx->nAvgBytesPerSec == 0)
		return 0;
	else
		return MULDIVU32(dwBytes, 1000, (DWORD) lpwfx->nAvgBytesPerSec);
}

// WavFormatMillesecondsToBytes - convert milleseconds to bytes
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
//		<dwMilleseconds>	(i) milleseconds
// return milleseconds
//
DWORD DLLEXPORT WINAPI WavFormatMillesecondsToBytes(LPWAVEFORMATEX lpwfx, DWORD dwMilleseconds)
{
	if (lpwfx == NULL || lpwfx->nAvgBytesPerSec == 0)
		return 0;
	else
		return MULDIVU32(dwMilleseconds, (DWORD) lpwfx->nAvgBytesPerSec, 1000);
}

// WavFormatSpeedAdjust - adjust format to reflect specified speed
//		<lpwfx>				(i/o) pointer to WAVEFORMATEX struct
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
//		<dwFlags>			(i) reserved; must be zero
// return 0 if success
//
int DLLEXPORT WINAPI WavFormatSpeedAdjust(LPWAVEFORMATEX lpwfx, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	if (lpwfx == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nLevel != 100)
	{
		lpwfx->nSamplesPerSec = lpwfx->nSamplesPerSec * nLevel / 100;
		lpwfx->nAvgBytesPerSec = lpwfx->nBlockAlign * lpwfx->nSamplesPerSec;
	}

	return fSuccess ? 0 : -1;
}

// WavFormatVoxadpcm - fill WAVEFORMATEX struct for Dialogic OKI ADPCM
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (6000)
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatVoxadpcm(LPWAVEFORMATEX lpwfx, long nSamplesPerSec)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX lpwfxNew = lpwfx;
	WORD nBitsPerSample = 4;
	WORD nChannels = 1;
#if 0
	// nBlockAlign is 4 so that chunk size of 5188 is returned from
	// WavCalcChunkSize(VoxFormat(NULL, 6000), 1962, TRUE);
	// 5188 is optimal for Dialogic buffer logic (((12 * 1024) - 512) / 2)
	//
	WORD nBlockAlign = 4;
#else
	WORD nBlockAlign = 1;
#endif

	if (nSamplesPerSec == -1)
		nSamplesPerSec = 6000;
		
	// user passed struct to fill
	//
	if (lpwfx != NULL && IsBadReadPtr(lpwfx, sizeof(WAVEFORMATEX)))
		fSuccess = TraceFALSE(NULL);

	// we allocate struct to fill
	//
	else if (lpwfx == NULL
		&& (lpwfxNew = WavFormatAlloc(sizeof(WAVEFORMATEX))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// fill the struct
	//
	else
	{
		lpwfxNew->wFormatTag = WAVE_FORMAT_DIALOGIC_OKI_ADPCM;
		lpwfxNew->nChannels = nChannels;
		lpwfxNew->nSamplesPerSec = nSamplesPerSec;
		lpwfxNew->nBlockAlign = nBlockAlign;
		lpwfxNew->nAvgBytesPerSec = nSamplesPerSec / 2;
		lpwfxNew->wBitsPerSample = nBitsPerSample;
		lpwfxNew->cbSize = 0;
	}

	return fSuccess ? lpwfxNew : NULL;
}

// WavFormatMulaw - fill WAVEFORMATEX struct for CCITT u-law format
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (8000)
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatMulaw(LPWAVEFORMATEX lpwfx, long nSamplesPerSec)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX lpwfxNew = lpwfx;
	WORD nBitsPerSample = 8;
	WORD nChannels = 1;
	WORD nBlockAlign = 1;

	if (nSamplesPerSec == -1)
		nSamplesPerSec = 8000;
		
	// user passed struct to fill
	//
	if (lpwfx != NULL && IsBadReadPtr(lpwfx, sizeof(WAVEFORMATEX)))
		fSuccess = TraceFALSE(NULL);

	// we allocate struct to fill
	//
	else if (lpwfx == NULL
		&& (lpwfxNew = WavFormatAlloc(sizeof(WAVEFORMATEX))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// fill the struct
	//
	else
	{
		lpwfxNew->wFormatTag = WAVE_FORMAT_MULAW;
		lpwfxNew->nChannels = nChannels;
		lpwfxNew->nSamplesPerSec = nSamplesPerSec;
		lpwfxNew->nBlockAlign = nBlockAlign;
		lpwfxNew->nAvgBytesPerSec = lpwfxNew->nBlockAlign * nSamplesPerSec;
		lpwfxNew->wBitsPerSample = nBitsPerSample;
		lpwfxNew->cbSize = 0;
	}

	return fSuccess ? lpwfxNew : NULL;
}

// WavFormatAlaw - fill WAVEFORMATEX struct for CCITT a-law format
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (8000)
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatAlaw(LPWAVEFORMATEX lpwfx, long nSamplesPerSec)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX lpwfxNew = lpwfx;
	WORD nBitsPerSample = 8;
	WORD nChannels = 1;
	WORD nBlockAlign = 1;

	if (nSamplesPerSec == -1)
		nSamplesPerSec = 8000;
		
	// user passed struct to fill
	//
	if (lpwfx != NULL && IsBadReadPtr(lpwfx, sizeof(WAVEFORMATEX)))
		fSuccess = TraceFALSE(NULL);

	// we allocate struct to fill
	//
	else if (lpwfx == NULL
		&& (lpwfxNew = WavFormatAlloc(sizeof(WAVEFORMATEX))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// fill the struct
	//
	else
	{
		lpwfxNew->wFormatTag = WAVE_FORMAT_ALAW;
		lpwfxNew->nChannels = nChannels;
		lpwfxNew->nSamplesPerSec = nSamplesPerSec;
		lpwfxNew->nBlockAlign = nBlockAlign;
		lpwfxNew->nAvgBytesPerSec = lpwfxNew->nBlockAlign * nSamplesPerSec;
		lpwfxNew->wBitsPerSample = nBitsPerSample;
		lpwfxNew->cbSize = 0;
	}

	return fSuccess ? lpwfxNew : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\wavfmt.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wavfmt.h - interface for wav format functions in wavfmt.c
////

#ifndef __WAVFMT_H__
#define __WAVFMT_H__

#include "winlocal.h"

// 16-bit pcm sample
//
typedef __int16 PCM16;
typedef PCM16 _huge *LPPCM16;

// 8-bit pcm sample
//
typedef BYTE PCM8;
typedef PCM8 _huge *LPPCM8;

#include <mmsystem.h>

#ifdef _WIN32
#include <mmreg.h>
#else
#if 0 // this requires either the VFWDK or MDRK
#include <mmreg.h>
#else // this is copied from the WIN32 version of mmreg.h

#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_
typedef struct tWAVEFORMATEX
{
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
    WORD    wBitsPerSample;    /* Number of bits per sample of mono data */
    WORD    cbSize;            /* The count in bytes of the size of
                                    extra information (after cbSize) */
} WAVEFORMATEX;

typedef WAVEFORMATEX       *PWAVEFORMATEX;
typedef WAVEFORMATEX NEAR *NPWAVEFORMATEX;
typedef WAVEFORMATEX FAR  *LPWAVEFORMATEX;
#endif /* _WAVEFORMATEX_ */

#ifndef _ACM_WAVEFILTER
#define _ACM_WAVEFILTER

#define WAVE_FILTER_UNKNOWN         0x0000
#define WAVE_FILTER_DEVELOPMENT    (0xFFFF)

typedef struct wavefilter_tag {
    DWORD   cbStruct;           /* Size of the filter in bytes */
    DWORD   dwFilterTag;        /* filter type */
    DWORD   fdwFilter;          /* Flags for the filter (Universal Dfns) */
    DWORD   dwReserved[5];      /* Reserved for system use */
} WAVEFILTER;
typedef WAVEFILTER       *PWAVEFILTER;
typedef WAVEFILTER NEAR *NPWAVEFILTER;
typedef WAVEFILTER FAR  *LPWAVEFILTER;

#endif  /* _ACM_WAVEFILTER */

#ifndef WAVE_FORMAT_DIALOGIC_OKI_ADPCM
#define  WAVE_FORMAT_DIALOGIC_OKI_ADPCM 0x0017  /*  Dialogic Corporation  */
#endif

#ifndef MM_DIALOGIC
#define   MM_DIALOGIC                   93         /*  Dialogic Corporation  */
#endif

#ifndef WAVE_FORMAT_MULAW
#define  WAVE_FORMAT_MULAW      0x0007  /*  Microsoft Corporation  */
#endif

#endif
#endif

// issued 5/11/98 by Terri Hendry thendry@microsoft.com
//
#ifndef MM_ACTIVEVOICE
#define MM_ACTIVEVOICE 225
#endif

// issued 5/11/98 by Terri Hendry thendry@microsoft.com
//
#ifndef MM_ACTIVEVOICE_ACM_VOXADPCM
#define MM_ACTIVEVOICE_ACM_VOXADPCM 1
#endif

// $FIXUP - we need to register with Microsoft to get product id
//
#ifndef MM_ACTIVEVOICE_AVPHONE_WAVEOUT
#define MM_ACTIVEVOICE_AVPHONE_WAVEOUT 2
#endif

// $FIXUP - we need to register with Microsoft to get product id
//
#ifndef MM_ACTIVEVOICE_AVPHONE_WAVEIN
#define MM_ACTIVEVOICE_AVPHONE_WAVEIN 3
#endif

#define WAVFMT_VERSION 0x00000105

#ifdef __cplusplus
extern "C" {
#endif

// WavFormatPcm - fill WAVEFORMATEX struct based on PCM characteristics
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (11025)
//		<nBitsPerSample>	(i) sample size
//			-1					default sample size (8)
//		<nChannels>			(i) number of channels (1=mono, 2=stereo)
//			-1					default (mono)
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatPcm(long nSamplesPerSec,
	WORD nBitsPerSample, WORD nChannels, LPWAVEFORMATEX lpwfx);

// WavFormatAlloc - allocate WAVEFORMATEX struct buffer
//		<cbSize>			(i) size of struct, including extra bytes
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatAlloc(WORD cbSize);

// WavFormatDup - duplicate WAVEFORMATEX structure
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return pointer to new WAVEFORMATEX struct, NULL if error
//
// NOTE: use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatDup(LPWAVEFORMATEX lpwfx);

// WavFormatFree - free WAVEFORMATEX struct
//		<lpwfx>				(i) pointer returned from WavFormatAlloc/Dup/Pcm
// return 0 if success
//
int DLLEXPORT WINAPI WavFormatFree(LPWAVEFORMATEX lpwfx);

// WavFormatIsValid - check format for validity
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return TRUE if valid format
//
BOOL DLLEXPORT WINAPI WavFormatIsValid(LPWAVEFORMATEX lpwfx);

// WavFormatCmp - compare one format with another
//		<lpwfx1>			(i) pointer to WAVEFORMATEX struct
//		<lpwfx2>			(i) pointer to WAVEFORMATEX struct
// return 0 if identical
//
// NOTE: this function does NOT compare the cbSize field or the extra bytes
//
int DLLEXPORT WINAPI WavFormatCmp(LPWAVEFORMATEX lpwfx1, LPWAVEFORMATEX lpwfx2);

// WavFormatCopy - copy one format to another
//		<lpwfxDst>			(i) pointer to destination WAVEFORMATEX struct
//		<lpwfxSrc>			(i) pointer to source WAVEFORMATEX struct
// return 0 if success
//
// NOTE: this function does NOT copy the cbSize field or the extra bytes
//
int DLLEXPORT WINAPI WavFormatCopy(LPWAVEFORMATEX lpwfxDst, LPWAVEFORMATEX lpwfxSrc);

// WavFormatGetSize - check size of format structure
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return size of structure, 0 if error
//
int DLLEXPORT WINAPI WavFormatGetSize(LPWAVEFORMATEX lpwfx);

// WavFormatDump - dump WAVEFORMATEX struct to debug
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return 0 if success
//
int DLLEXPORT WINAPI WavFormatDump(LPWAVEFORMATEX lpwfx);

// WavFormatBytesToMilleseconds - convert bytes to milleseconds
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
//		<dwBytes>			(i) bytes
// return milleseconds
//
DWORD DLLEXPORT WINAPI WavFormatBytesToMilleseconds(LPWAVEFORMATEX lpwfx, DWORD dwBytes);

// WavFormatMillesecondsToBytes - convert milleseconds to bytes
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
//		<dwMilleseconds>	(i) milleseconds
// return milleseconds
//
DWORD DLLEXPORT WINAPI WavFormatMillesecondsToBytes(LPWAVEFORMATEX lpwfx, DWORD dwMilleseconds);

// WavFormatSpeedAdjust - adjust format to reflect specified speed
//		<lpwfx>				(i/o) pointer to WAVEFORMATEX struct
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
//		<dwFlags>			(i) reserved; must be zero
// return 0 if success
//
int DLLEXPORT WINAPI WavFormatSpeedAdjust(LPWAVEFORMATEX lpwfx, int nLevel, DWORD dwFlags);

// WavFormatVoxadpcm - fill WAVEFORMATEX struct for Dialogic OKI ADPCM
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (6000)
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatVoxadpcm(LPWAVEFORMATEX lpwfx, long nSamplesPerSec);

// WavFormatMulaw - fill WAVEFORMATEX struct for CCITT u-law format
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (8000)
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatMulaw(LPWAVEFORMATEX lpwfx, long nSamplesPerSec);

// WavFormatAlaw - fill WAVEFORMATEX struct for CCITT a-law format
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (8000)
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatAlaw(LPWAVEFORMATEX lpwfx, long nSamplesPerSec);

#ifdef __cplusplus
}
#endif

#endif // __WAV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\wav.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wav.c - wave file format functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "wav.h"

#ifdef MULTITHREAD
#include <objbase.h>
#endif

#include "wavin.h"
#include "wavout.h"
#include "wavmixer.h"
#include "acm.h"
#include "mem.h"
#include "str.h"
#include "trace.h"
#include "mmio.h"

#ifdef AVTSM
#include "avtsm.h"
#define TSMTHUNK
#ifdef TSMTHUNK
#include "tsmthunk.h"
#endif
#define TSM_OUTBUF_SIZE_FACT 4
#endif

// allow telephone output functions if defined
//
#ifdef TELOUT
#include "telout.h"
#endif

// allow telephone input functions if defined
//
#ifdef TELIN
#include "telin.h"
#endif

// use telephone thunk layer if defined
//
#ifdef TELTHUNK
#include "telthunk.h"
#endif

#if defined(TELOUT) || defined(TELIN)
#include "telwav.h"
#include "vox.h"
#endif

////
//	private definitions
////

#define WAVCLASS TEXT("WavClass")

#define PLAYCHUNKCOUNT_DEFAULT 3
#define PLAYCHUNKCOUNT_MIN 1
#define PLAYCHUNKCOUNT_MAX 16

#define PLAYCHUNKSIZE_DEFAULT 666
#define PLAYCHUNKSIZE_MIN 111
#define PLAYCHUNKSIZE_MAX 9999999

#define RECORDCHUNKCOUNT_DEFAULT 3
#define RECORDCHUNKCOUNT_MIN 1
#define RECORDCHUNKCOUNT_MAX 16

#define RECORDCHUNKSIZE_DEFAULT 666
#define RECORDCHUNKSIZE_MIN 111
#define RECORDCHUNKSIZE_MAX 9999999

// index into format arrays
//
#define FORMATFILE		0
#define FORMATPLAY		1
#define FORMATRECORD	2

// internal state flags
//
#define WAVSTATE_STOPPLAY				0x00000010
#define WAVSTATE_STOPRECORD				0x00000020
#define WAVSTATE_AUTOSTOP				0x00000040
#define WAVSTATE_AUTOCLOSE				0x00000080

// internal array of current handles
//
#define HWAVOUT_MAX 100
#define HWAVIN_MAX 100

#ifdef TELOUT
#define HWAVOUT_MIN -2
#define HWAVOUT_OFFSET 2
#else
#define HWAVOUT_MIN -1
#define HWAVOUT_OFFSET 1
#endif
static HWAV ahWavOutCurr[HWAVOUT_MAX + HWAVOUT_OFFSET] = { 0 };

#ifdef TELIN
#define HWAVIN_MIN -2
#define HWAVIN_OFFSET 2
#else
#define HWAVIN_MIN -1
#define HWAVIN_OFFSET 1
#endif
static HWAV ahWavInCurr[HWAVIN_MAX + HWAVIN_OFFSET] = { 0 };

// internal storage of defaults
//
static int cPlayChunksDefault = PLAYCHUNKCOUNT_DEFAULT;
static long msPlayChunkSizeDefault = PLAYCHUNKSIZE_DEFAULT;
static int cRecordChunksDefault = RECORDCHUNKCOUNT_DEFAULT;
static long msRecordChunkSizeDefault = RECORDCHUNKSIZE_DEFAULT;

// wavinit control struct
//
typedef struct WAVINIT
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	DWORD dwFlags;
	UINT nLastError;
	HACM hAcm;
	HACMDRV hAcmDrv;
#ifdef TELTHUNK
	HTELTHUNK hTelThunk;
#endif
#ifdef TSMTHUNK
	HTSMTHUNK hTsmThunk;
#endif
} WAVINIT, FAR *LPWAVINIT;

// wav control struct
//
typedef struct WAV
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	DWORD dwFlags;
	LPWAVEFORMATEX lpwfx[3];
	LPMMIOPROC lpIOProc;
	int cPlayChunks;
	long msPlayChunkSize;
	int cRecordChunks;
	long msRecordChunkSize;
	HWND hwndNotify;
#ifdef MULTITHREAD
	HANDLE hThreadCallback;
	DWORD dwThreadId;
	HANDLE hEventThreadCallbackStarted;
	HANDLE hEventStopped;
#endif
	UINT nLastError;
	HMMIO hmmio;
	MMCKINFO ckRIFF;
	MMCKINFO ckfmt;
	MMCKINFO ckdata;
	long cbData;
	long lDataOffset;
	long lDataPos;
	long msPositionStop;
	HWAVIN hWavIn;
	HWAVOUT hWavOut;
	HACM hAcm;
	DWORD dwState;
	HGLOBAL hResource;
	long lPosFmt;
	DWORD dwFlagsPlay;
	DWORD dwFlagsRecord;
	int nVolumeLevel;
	int dwFlagsVolume;
	int nSpeedLevel;
	DWORD dwFlagsSpeed;
	PLAYSTOPPEDPROC lpfnPlayStopped;
	HANDLE hUserPlayStopped;
	RECORDSTOPPEDPROC lpfnRecordStopped;
	DWORD dwUserRecordStopped;
#ifdef MULTITHREAD
	HRESULT hrCoInitialize;
#endif
#ifdef AVTSM
	HTSM hTsm;
#endif
	LPTSTR lpszFileName;
	long msMaxSize;
} WAV, FAR *LPWAV;

// helper functions
//
static int WavStopPlay(HWAV hWav);
static int WavStopRecord(HWAV hWav);
static int WavStopOutputDevice(int idDev, DWORD dwFlags);
static int WavStopInputDevice(int idDev, DWORD dwFlags);
static HWAV WavGetOutputHandle(int idDev);
static HWAV WavGetInputHandle(int idDev);
static int WavPlayNextChunk(HWAV hWav);
static int WavRecordNextChunk(HWAV hWav);
static int WavNotifyCreate(LPWAV lpWav);
static int WavNotifyDestroy(LPWAV lpWav);
#ifdef MULTITHREAD
DWORD WINAPI WavCallbackThread(LPVOID lpvThreadParameter);
#endif
LRESULT DLLEXPORT CALLBACK WavNotify(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
static int WavCalcPositionStop(HWAV hWav, long cbPosition);
static int WavSeekTraceBefore(LPWAV lpWav, long lOffset, int nOrigin);
static int WavSeekTraceAfter(LPWAV lpWav, long lPos, long lOffset, int nOrigin);
static LPWAV WavGetPtr(HWAV hWav);
static HWAV WavGetHandle(LPWAV lpWav);
static LPWAVINIT WavInitGetPtr(HWAVINIT hWavInit);
static HWAVINIT WavInitGetHandle(LPWAVINIT lpWavInit);
#ifdef MULTITHREAD
static int SetEventMessageProcessed(LPWAV lpWav, HANDLE hEventMessageProcessed);
#endif
static int WavTempStop(HWAV hWav, LPWORD lpwStatePrev, LPINT lpidDevPrev);
static int WavTempResume(HWAV hWav, WORD wStatePrev, int idDevPrev);

////
//	public functions
////

// WavInit - initialize wav engine
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
//			WAV_TELTHUNK		initialize telephone thunking layer
//			WAV_NOTSMTHUNK		do not initialize tsm thunking layer
//			WAV_NOACM			do not use audio compression manager
//			WAV_VOXADPCM		load acm driver for Dialogic OKI ADPCM
// return handle (NULL if error)
//
HWAVINIT WINAPI WavInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVINIT lpWavInit = NULL;

	if (dwVersion != WAV_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavInit = (LPWAVINIT) MemAlloc(NULL, sizeof(WAVINIT), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpWavInit->dwVersion = dwVersion;
		lpWavInit->hInst = hInst;
		lpWavInit->hTask = GetCurrentTask();
		lpWavInit->dwFlags = dwFlags;
		lpWavInit->hAcm = NULL;
		lpWavInit->hAcmDrv = NULL;
#ifdef TELTHUNK
		lpWavInit->hTelThunk = NULL;
#endif
#ifdef TSMTHUNK
		lpWavInit->hTsmThunk = NULL;
#endif

		// start the acm engine before any other Wav or Acm functions called
		//
		if ((lpWavInit->hAcm = AcmInit(ACM_VERSION,	lpWavInit->hInst,
			(lpWavInit->dwFlags & WAV_NOACM) ? ACM_NOACM : 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// load voxadpcm driver if specified
		//
		else if ((dwFlags & WAV_VOXADPCM) && (!(dwFlags & WAV_NOACM)) &&
			(lpWavInit->hAcmDrv = AcmDriverLoad(lpWavInit->hAcm,
			MM_ACTIVEVOICE, MM_ACTIVEVOICE_ACM_VOXADPCM,
#ifdef _WIN32
			TEXT("avvox.acm"),
#else
			TEXT("voxadpcm.acm"),
#endif
			"DriverProc", 0)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

#ifdef TELTHUNK
		// initialize telephone thunking layer if specified
		//
		else if ((dwFlags & WAV_TELTHUNK) &&
			(lpWavInit->hTelThunk = TelThunkInit(TELTHUNK_VERSION,
			lpWavInit->hInst)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}
#endif

#ifdef TSMTHUNK
		// initialize tsm thunking layer if specified
		//
		else if (!(dwFlags & WAV_NOTSMTHUNK) &&
			(lpWavInit->hTsmThunk = TsmThunkInit(TSMTHUNK_VERSION,
			lpWavInit->hInst)) == NULL)
		{
			fSuccess = TraceTRUE(NULL); // not a fatal error
		}
#endif

	}

	if (!fSuccess)
	{
		WavTerm(WavInitGetHandle(lpWavInit));
		lpWavInit = NULL;
	}

	return fSuccess ? WavInitGetHandle(lpWavInit) : NULL;
}

// WavTerm - shut down wav engine
//		<hWavInit>			(i) handle returned from WavInit
// return 0 if success
//
int WINAPI WavTerm(HWAVINIT hWavInit)
{
	BOOL fSuccess = TRUE;
	LPWAVINIT lpWavInit;

	if ((lpWavInit = WavInitGetPtr(hWavInit)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (WavOutTerm(lpWavInit->hInst, lpWavInit->dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (WavInTerm(lpWavInit->hInst, lpWavInit->dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
#ifdef TELTHUNK
		// shut down telephone thunking layer if necessary
		//
		if (lpWavInit->hTelThunk != NULL &&
			TelThunkTerm(lpWavInit->hTelThunk) != 0)
			fSuccess = TraceFALSE(NULL);

		else
			lpWavInit->hTelThunk = NULL;
#endif

#ifdef TSMTHUNK
		// shut down tsm thunking layer if necessary
		//
		if (lpWavInit->hTsmThunk != NULL &&
			TsmThunkTerm(lpWavInit->hTsmThunk) != 0)
			fSuccess = TraceFALSE(NULL);

		else
			lpWavInit->hTsmThunk = NULL;
#endif

		// unload voxadpcm driver if necessary
		//
		if (lpWavInit->hAcmDrv != NULL &&
			AcmDriverUnload(lpWavInit->hAcm, lpWavInit->hAcmDrv) != 0)
			fSuccess = TraceFALSE(NULL);

		else
			lpWavInit->hAcmDrv = NULL;

		// shut down acm engine
		//
		if (lpWavInit->hAcm != NULL && AcmTerm(lpWavInit->hAcm) != 0)
			fSuccess = TraceFALSE(NULL);

		else
			lpWavInit->hAcm = NULL;

		if (fSuccess && (lpWavInit = MemFree(NULL, lpWavInit)) != NULL)
			fSuccess = TraceFALSE(NULL);

	}

	return fSuccess ? 0 : -1;
}

// WavOpen - open or create wav file
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpszFileName>		(i) name of file to open or create
//		<lpwfx>				(i) wave format
//			NULL				use format from header or default
//		<lpIOProc>			(i) address of i/o procedure to use
//			NULL				use default i/o procedure
//		<lpadwInfo>			(i) data to pass to i/o procedure during open
//			NULL				no data to pass
//		<dwFlags>			(i) control flags
//			WAV_READ			open file for reading (default)
//			WAV_WRITE			open file for writing
//			WAV_READWRITE		open file for reading and writing
//			WAV_DENYNONE		allow other programs read and write access
//			WAV_DENYREAD		prevent other programs from read access
//			WAV_DENYWRITE		prevent other programs from write access
//			WAV_EXCLUSIVE		prevent other programs from read or write
//			WAV_CREATE			create new file or truncate existing file
//			WAV_NORIFF			file has no RIFF/WAV header
//			WAV_MEMORY			<lpszFileName> points to memory block
//			WAV_RESOURCE		<lpszFileName> points to wave resource
//			WAV_NOACM			do not use audio compression manager
//			WAV_DELETE			delete specified file, return TRUE if success
//			WAV_EXIST			return TRUE if specified file exists
//			WAV_GETTEMP			create temp file, return TRUE if success
//			WAV_TELRFILE		telephone will play audio from file on server
#ifdef MULTITHREAD
//			WAV_MULTITHREAD		support multiple threads (default)
//			WAV_SINGLETHREAD	do not support multiple threads
//			WAV_COINITIALIZE	call CoInitialize in all secondary threads
#endif
// return handle (NULL if error)
//
// NOTE: if WAV_CREATE or WAV_NORIFF are used in <dwFlags>, then the
// <lpwfx> parameter must be specified.  If <lpwfx> is NULL, the
// current default format is assumed.
// WavSetFormat() can be used to set or override the defaults.
//
// NOTE: if WAV_RESOURCE is specified in <dwFlags>, then <lpszFileName>
// must point to a WAVE resource in the module specified by <hInst>.
// If the first character of the string is a pound sign (#), the remaining
// characters represent a decimal number that specifies the resource id.
//
// NOTE: if WAV_MEMORY is specified in <dwFlags>, then <lpszFileName>
// must be a pointer to a memory block obtained by calling MemAlloc().
//
// NOTE: if <lpIOProc> is not NULL, this i/o procedure will be called
// for opening, closing, reading, writing, and seeking the wav file.
// If <lpadwInfo> is not NULL, this array of three (3) DWORDs will be
// passed to the i/o procedure when the wav file is opened.
// See the Windows mmioOpen() and mmioInstallIOProc() function for details
// on these parameters.  Also, the WAV_MEMORY and WAV_RESOURCE flags may
// only be used when <lpIOProc> is NULL.
//
HWAV WINAPI WavOpen(DWORD dwVersion, HINSTANCE hInst,
	LPCTSTR lpszFileName, LPWAVEFORMATEX lpwfx,
	LPMMIOPROC lpIOProc, DWORD FAR *lpadwInfo, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav = NULL;

#ifdef MULTITHREAD
	// assume WAV_MULTITHREAD unless WAV_SINGLETHREAD specified
	//
	if (!(dwFlags & WAV_SINGLETHREAD))
		dwFlags |= WAV_MULTITHREAD;
#endif

	if (dwVersion != WAV_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	// special case flags that don't actually open a file
	// return TRUE if success, ignore all other flags
	//
	else if ((dwFlags & WAV_EXIST) ||
		(dwFlags & WAV_DELETE) ||
		(dwFlags & WAV_GETTEMP))
	{
		DWORD dwOpenFlags = 0;
		HMMIO hmmio;

		if (dwFlags & WAV_EXIST)
			dwOpenFlags |= MMIO_EXIST;
		else if (dwFlags & WAV_DELETE)
			dwOpenFlags |= MMIO_DELETE;
		else if (dwFlags & WAV_GETTEMP)
			dwOpenFlags |= MMIO_GETTEMP;

		// use specified i/o procedure
		//
		if (lpIOProc != NULL)
		{
			MMIOINFO mmioinfo;

			MemSet(&mmioinfo, 0, sizeof(mmioinfo));

			mmioinfo.pIOProc = lpIOProc;

			// pass data to the i/o procedure
			//
			if (lpadwInfo != NULL)
				MemCpy(mmioinfo.adwInfo, lpadwInfo, sizeof(mmioinfo.adwInfo));

			hmmio = mmioOpen((LPTSTR) lpszFileName, &mmioinfo, dwOpenFlags);
		}

		// default i/o procedure
		//
		else
		{
			hmmio = mmioOpen((LPTSTR) lpszFileName, NULL, dwOpenFlags);
		}

		if ((dwFlags & WAV_EXIST) && hmmio == (HMMIO) FALSE)
			fSuccess = FALSE; // no trace
		else if ((dwFlags & WAV_DELETE) && hmmio == (HMMIO) FALSE)
			fSuccess = TraceFALSE(NULL);
		else if ((dwFlags & WAV_GETTEMP) && hmmio == (HMMIO) FALSE)
			fSuccess = TraceFALSE(NULL);

		return (HWAV)IntToPtr(fSuccess);
	}

	else if ((lpWav = (LPWAV) MemAlloc(NULL, sizeof(WAV), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpWav->dwVersion = dwVersion;
		lpWav->hInst = hInst;
		lpWav->hTask = GetCurrentTask();
		lpWav->dwFlags = dwFlags;
		lpWav->lpwfx[FORMATFILE] = NULL;
		lpWav->lpwfx[FORMATPLAY] = NULL;
		lpWav->lpwfx[FORMATRECORD] = NULL;
		lpWav->lpIOProc = lpIOProc;
		lpWav->cPlayChunks = cPlayChunksDefault;
		lpWav->msPlayChunkSize = msPlayChunkSizeDefault;
		lpWav->cRecordChunks = cRecordChunksDefault;
		lpWav->msRecordChunkSize = msRecordChunkSizeDefault;
		lpWav->hwndNotify = NULL;
#ifdef MULTITHREAD
		lpWav->hThreadCallback = NULL;
		lpWav->dwThreadId = 0;
		lpWav->hEventThreadCallbackStarted = NULL;
		lpWav->hEventStopped = NULL;
#endif
		lpWav->nLastError = 0;
		lpWav->hmmio = NULL;
		lpWav->cbData = 0;
		lpWav->lDataOffset = 0;
		lpWav->lDataPos = 0;
		lpWav->hWavIn = NULL;
		lpWav->hWavOut = NULL;
		lpWav->hAcm = NULL;
		lpWav->msPositionStop = 0L;
		lpWav->dwState = 0L;
		lpWav->hResource = NULL;
		lpWav->lPosFmt = -1;
		lpWav->dwFlagsPlay = 0;
		lpWav->dwFlagsRecord = 0;
		lpWav->nVolumeLevel = 50;
		lpWav->dwFlagsVolume = 0;
		lpWav->nSpeedLevel = 100;
		lpWav->dwFlagsSpeed = 0;
		lpWav->lpfnPlayStopped = NULL;
		lpWav->hUserPlayStopped = 0;
		lpWav->lpfnRecordStopped = NULL;
		lpWav->dwUserRecordStopped = 0;
#ifdef MULTITHREAD
		lpWav->hrCoInitialize = E_UNEXPECTED;
#endif
#ifdef AVTSM
		lpWav->hTsm = NULL;
#endif
		lpWav->lpszFileName = NULL;
		lpWav->msMaxSize = 0;

		// start the acm engine before any other Wav or Acm functions called
		//
		if ((lpWav->hAcm = AcmInit(ACM_VERSION,	lpWav->hInst,
			(lpWav->dwFlags & WAV_NOACM) ? ACM_NOACM : 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			// assume default wave format if none specified
			//
			if (lpwfx == NULL)
			{
				WAVEFORMATEX wfx;

				if (WavSetFormat(WavGetHandle(lpWav),
					WavFormatPcm(-1, -1, -1, &wfx), WAV_FORMATALL) != 0)
					fSuccess = TraceFALSE(NULL);
			}

			// set specified wave format
			//
			else if (WavSetFormat(WavGetHandle(lpWav), lpwfx, WAV_FORMATALL) != 0)
				fSuccess = TraceFALSE(NULL);
		}
	}

	// load WAVE resource if specified
	//
	if (fSuccess && (dwFlags & WAV_RESOURCE))
	{
		HRSRC hResInfo;
		LPVOID lpResource;

		if ((hResInfo = FindResource(hInst, lpszFileName, TEXT("WAVE"))) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((lpWav->hResource = LoadResource(hInst, hResInfo)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((lpResource = LockResource(lpWav->hResource)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			// <lpszFileName> now points to a memory block
			//
			lpszFileName = lpResource;
			dwFlags |= WAV_MEMORY;
		}
	}

	if (fSuccess && (dwFlags & WAV_MEMORY))
	{
		// i/o procedure can not be specified with memory block
		//
		lpIOProc = NULL;
		lpadwInfo = NULL;
	}

	if (fSuccess)
	{
		DWORD dwOpenFlags = 0;

		if (lpWav->dwFlags & WAV_READ)
			dwOpenFlags |= MMIO_READ;
		if (lpWav->dwFlags & WAV_WRITE)
			dwOpenFlags |= MMIO_WRITE;
		if (lpWav->dwFlags & WAV_READWRITE)
			dwOpenFlags |= MMIO_READWRITE;
		if (lpWav->dwFlags & WAV_CREATE)
			dwOpenFlags |= MMIO_CREATE;
		if (lpWav->dwFlags & WAV_DENYNONE)
			dwOpenFlags |= MMIO_DENYNONE;
		if (lpWav->dwFlags & WAV_DENYREAD)
			dwOpenFlags |= MMIO_DENYREAD;
		if (lpWav->dwFlags & WAV_DENYWRITE)
			dwOpenFlags |= MMIO_DENYWRITE;
		if (lpWav->dwFlags & WAV_EXCLUSIVE)
			dwOpenFlags |= MMIO_EXCLUSIVE;

		// open/create disk wav file with specified i/o procedure
		//
		if (lpIOProc != NULL)
		{
			MMIOINFO mmioinfo;

			MemSet(&mmioinfo, 0, sizeof(mmioinfo));

			mmioinfo.pIOProc = lpIOProc;

			// pass data to the i/o procedure
			//
			if (lpadwInfo != NULL)
				MemCpy(mmioinfo.adwInfo, lpadwInfo, sizeof(mmioinfo.adwInfo));

			if ((lpWav->hmmio = mmioOpen((LPTSTR) lpszFileName,
				&mmioinfo, dwOpenFlags)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}

		// open/create a memory wav file if WAV_MEMORY specified
		//
		else if (lpWav->dwFlags & WAV_MEMORY)
		{
			MMIOINFO mmioinfo;

			MemSet(&mmioinfo, 0, sizeof(mmioinfo));

			mmioinfo.fccIOProc = FOURCC_MEM;
			mmioinfo.pchBuffer = (HPSTR) lpszFileName;

			if (lpszFileName == NULL)
			{
				// expandable memory file
				//
				mmioinfo.cchBuffer = 0;
				mmioinfo.adwInfo[0] = (DWORD) (16 * 1024);
			}
			else
			{
				// expandable memory file
				//
				mmioinfo.cchBuffer = (long) MemSize(NULL, (LPVOID) lpszFileName);
				mmioinfo.adwInfo[0] = (DWORD) 16384;
			}

			if ((lpWav->hmmio = mmioOpen(NULL,
				&mmioinfo, dwOpenFlags)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}

		// otherwise open/create disk wav file
		//
		else
		{
			if ((lpWav->lpszFileName = StrDup(lpszFileName)) == NULL)
				fSuccess = TraceFALSE(NULL);

			else if ((lpWav->hmmio = mmioOpen((LPTSTR) lpszFileName,
				NULL, dwOpenFlags)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}
	}

	// handle reading of RIFF file chunks if necessary
	//
	if (fSuccess && !(lpWav->dwFlags & WAV_CREATE) &&
		!(lpWav->dwFlags & WAV_NORIFF))
	{
		MMCKINFO ck;

		// search for RIFF chunk with form type WAV
		//
		if ((lpWav->nLastError = mmioDescend(lpWav->hmmio,
			&lpWav->ckRIFF, NULL, MMIO_FINDRIFF)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioDescend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// search for "fmt " subchunk
		//
		ck.ckid = mmioFOURCC('f', 'm', 't', ' ');

		if (fSuccess &&	(lpWav->nLastError = mmioDescend(lpWav->hmmio,
			&ck, &lpWav->ckRIFF, MMIO_FINDCHUNK)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioDescend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// save position of "fmt " chunk data so we can seek there later
		//
		else if (fSuccess && (lpWav->lPosFmt = mmioSeek(lpWav->hmmio,
			0, SEEK_CUR)) == -1)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// check for file corruption
		//
		if (fSuccess && (ck.dwDataOffset + ck.cksize) >
			(lpWav->ckRIFF.dwDataOffset + lpWav->ckRIFF.cksize))
		{
			fSuccess = TraceFALSE(NULL);
		}

		if (fSuccess)
		{
			LPWAVEFORMATEX lpwfx = NULL;
			DWORD cksize;

			// save fmt chunk info
			//
			lpWav->ckfmt = ck;

			// fmt chunk must be no smaller than WAVEFORMAT struct
			//
			if ((cksize = max(ck.cksize, sizeof(WAVEFORMAT)))
				< sizeof(WAVEFORMAT))
				fSuccess = TraceFALSE(NULL);

			// allocate space for WAVEFORMATEX struct
			//
			else if ((lpwfx = (LPWAVEFORMATEX) MemAlloc(NULL,
				max(sizeof(WAVEFORMATEX), cksize), 0)) == NULL)
				fSuccess = TraceFALSE(NULL);

			// read the fmt chunk
			//
			else if (mmioRead(lpWav->hmmio,
				(HPSTR) lpwfx, (LONG) cksize) != (LONG) cksize)
				fSuccess = TraceFALSE(NULL);

			// seek to beginning of next chunk if necessary
			//
			else if (ck.cksize > cksize &&
				mmioSeek(lpWav->hmmio, ck.cksize - cksize, SEEK_CUR) == -1)
				fSuccess = TraceFALSE(NULL);

			// calculate bits per sample if necessary
			//
			else if (lpwfx->wFormatTag == WAVE_FORMAT_PCM &&
				lpwfx->wBitsPerSample == 0)
			{
				// NOTE: this only works for PCM data with
				// sample size that is a multiple of 8 bits
				//
				lpwfx->wBitsPerSample =
					(lpwfx->nBlockAlign * 8) / lpwfx->nChannels;
			}

			// save format for later
			//
			if (fSuccess && WavSetFormat(WavGetHandle(lpWav),
				lpwfx, WAV_FORMATALL) != 0)
				fSuccess = TraceFALSE(NULL);

			// clean up
			//
			if (lpwfx != NULL &&
				(lpwfx = MemFree(NULL, lpwfx)) != NULL)
				fSuccess = TraceFALSE(NULL);
		}

		// search for "data" subchunk
		//
		ck.ckid = mmioFOURCC('d', 'a', 't', 'a');

		if (fSuccess &&	(lpWav->nLastError = mmioDescend(lpWav->hmmio,
			&ck, &lpWav->ckRIFF, MMIO_FINDCHUNK)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioDescend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// check for file corruption
		//
		if (fSuccess && (ck.dwDataOffset + ck.cksize) >
			(lpWav->ckRIFF.dwDataOffset + lpWav->ckRIFF.cksize))
		{
			fSuccess = TraceFALSE(NULL);
		}

		if (fSuccess)
		{
			// save data chunk info
			//
			lpWav->ckdata = ck;

			// save data size and offset for later
			//
			lpWav->cbData = (long) ck.cksize;
			lpWav->lDataOffset = (long) ck.dwDataOffset;
		}
	}

	// handle creation of RIFF file chunks if necessary
	//
	else if (fSuccess && (lpWav->dwFlags & WAV_CREATE) &&
		!(lpWav->dwFlags & WAV_NORIFF))
	{
		lpWav->ckRIFF.ckid = mmioFOURCC('R', 'I', 'F', 'F');
		lpWav->ckRIFF.cksize = 0; // unknown
		lpWav->ckRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
		lpWav->ckfmt.ckid = mmioFOURCC('f', 'm', 't', ' ');
		lpWav->ckfmt.cksize = WavFormatGetSize(lpWav->lpwfx[FORMATFILE]);
		lpWav->ckdata.ckid = mmioFOURCC('d', 'a', 't', 'a');
		lpWav->ckdata.cksize = 0; // unknown

		// create RIFF chunk with form type WAV
		//
		if ((lpWav->nLastError = mmioCreateChunk(lpWav->hmmio,
			&lpWav->ckRIFF, MMIO_CREATERIFF)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioCreateChunk failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// create 'fmt ' chunk
		//
		else if ((lpWav->nLastError = mmioCreateChunk(lpWav->hmmio,
			&lpWav->ckfmt, 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioCreateChunk failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// save position of "fmt " chunk data so we can seek there later
		//
		else if ((lpWav->lPosFmt = mmioSeek(lpWav->hmmio,
			0, SEEK_CUR)) == -1)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// write 'fmt ' chunk data
		//
		else if (mmioWrite(lpWav->hmmio, (HPSTR) lpWav->lpwfx[FORMATFILE],
			WavFormatGetSize(lpWav->lpwfx[FORMATFILE])) !=
			WavFormatGetSize(lpWav->lpwfx[FORMATFILE]))
		{
			fSuccess = TraceFALSE(NULL);
		}

		// ascend out of 'fmt ' chunk
		//
		else if ((lpWav->nLastError = mmioAscend(lpWav->hmmio,
			&lpWav->ckfmt, 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioAscend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// create the 'data' chunk which holds the waveform samples
		//
		else if ((lpWav->nLastError = mmioCreateChunk(lpWav->hmmio,
			&lpWav->ckdata, 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioCreateChunk failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// calculate beginning offset of data chunk
		//
		else if ((lpWav->lDataOffset = mmioSeek(lpWav->hmmio, 0, SEEK_CUR)) == -1)
			fSuccess = TraceFALSE(NULL);
	}

	// calculate size of data chunk (file size) for non-RIFF files
	//
	else if (fSuccess && !(lpWav->dwFlags & WAV_CREATE) &&
		(lpWav->dwFlags & WAV_NORIFF))
	{
		// RFileIOProc already knows the file size
		//
		if (lpWav->lpIOProc != NULL &&
			(lpWav->dwFlags & WAV_TELRFILE))
		{
			long lSize;

			// retrieve size of remote file from i/o procedure
			//
			if ((lSize = (long)
				WavSendMessage(WavGetHandle(lpWav), MMIOM_GETINFO, 1, 0)) == (long) -1)
				fSuccess = TraceFALSE(NULL);
			else
				lpWav->cbData = (long) lSize;
		}
		else
		{
			LONG lPosCurr;
			LONG lPosEnd;

			// save current position
			//
			if ((lPosCurr = mmioSeek(lpWav->hmmio, 0, SEEK_CUR)) == -1)
				fSuccess = TraceFALSE(NULL);

			// seek to end of file
			//
			else if ((lPosEnd = mmioSeek(lpWav->hmmio, 0, SEEK_END)) == -1)
				fSuccess = TraceFALSE(NULL);

			// restore current position
			//
			else if (mmioSeek(lpWav->hmmio, lPosCurr, SEEK_SET) == -1)
				fSuccess = TraceFALSE(NULL);

			else
				lpWav->cbData = (long) lPosEnd; // + 1;
		}
	}

	if (fSuccess)
	{
		TracePrintf_4(NULL, 6,
			TEXT("After WavOpen: lpWav->lDataOffset=%ld, lpWav->lDataPos=%ld, lpWav->cbData=%ld, lpWav->msPositionStop=%ld\n"),
			(long) lpWav->lDataOffset,
			(long) lpWav->lDataPos,
			(long) lpWav->cbData,
			(long) lpWav->msPositionStop);
	}

	if (!fSuccess)
	{
		WavClose(WavGetHandle(lpWav));
		lpWav = NULL;
	}

	return fSuccess ? WavGetHandle(lpWav) : NULL;
}

// WavClose - close wav file
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
int WINAPI WavClose(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
#ifdef _WIN32
	long lPosTruncate = -1;
#endif

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// stop playback or record if necessary
	//
	else if (WavStop(hWav) != 0)
		fSuccess = TraceFALSE(NULL);

	// update the RIFF header chunks if dirty flag set
	//
	else if (lpWav->hmmio != NULL &&
		!(lpWav->dwFlags & WAV_NORIFF) &&
		((lpWav->ckdata.dwFlags & MMIO_DIRTY) ||
		(lpWav->ckRIFF.dwFlags & MMIO_DIRTY)))
	{
#if 0
		// seek to end of file
		//
		if (mmioSeek(lpWav->hmmio, 0, SEEK_END) == -1)
		{
			fSuccess = TraceFALSE(NULL);
		}
#else
		// seek to end of the data
		//
		if (mmioSeek(lpWav->hmmio, lpWav->lDataOffset + lpWav->cbData, SEEK_SET) == -1)
		{
			fSuccess = TraceFALSE(NULL);
		}
#endif

		// ascend out of the 'data' chunk; chunk size will be written
		//
		else if ((lpWav->nLastError = mmioAscend(lpWav->hmmio,
			&lpWav->ckdata, 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioAscend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// ascend out of the 'RIFF' chunk; chunk size will be written
		//
		else if ((lpWav->nLastError = mmioAscend(lpWav->hmmio,
			&lpWav->ckRIFF, 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioAscend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}
#if 0
		// seek to beginning of file
		//
		else if (mmioSeek(lpWav->hmmio, 0, SEEK_SET) == -1)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// search for RIFF chunk with form type WAV
		//
		else if ((lpWav->nLastError = mmioDescend(lpWav->hmmio,
			&lpWav->ckRIFF, NULL, MMIO_FINDRIFF)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioDescend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// search for 'fmt ' chunk
		//
		else if ((lpWav->nLastError = mmioDescend(lpWav->hmmio,
			&lpWav->ckfmt, &lpWav->ckRIFF, MMIO_FINDCHUNK)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioDescend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}
#else
		// seek to beginning of "fmt " chunk data
		//
		else if (mmioSeek(lpWav->hmmio, lpWav->lPosFmt, SEEK_SET) == -1)
		{
			fSuccess = TraceFALSE(NULL);
		}
#endif
		// write 'fmt ' chunk data
		// $FIXUP - what happens if current file format struct size
		// is larger than the original format?
		//
		else if (mmioWrite(lpWav->hmmio, (HPSTR) lpWav->lpwfx[FORMATFILE],
			WavFormatGetSize(lpWav->lpwfx[FORMATFILE])) !=
			WavFormatGetSize(lpWav->lpwfx[FORMATFILE]))
		{
			fSuccess = TraceFALSE(NULL);
		}
#ifdef _WIN32
		// see if we need to truncate file
		//
		else if (lpWav->lpIOProc == NULL && !(lpWav->dwFlags & WAV_MEMORY) &&
			!(lpWav->dwFlags & WAV_RESOURCE))
		{
			if (mmioSeek(lpWav->hmmio, 0, SEEK_END) >
				lpWav->lDataOffset + lpWav->cbData)
			{
				lPosTruncate = lpWav->lDataOffset + lpWav->cbData;
			}
		}
#endif
	}

	if (fSuccess)
	{
		// close the file
		//
		if (lpWav->hmmio != NULL && mmioClose(lpWav->hmmio, 0) != 0)
				fSuccess = TraceFALSE(NULL);
		else
			lpWav->hmmio = NULL;

		// close acm engine
		//
		if (lpWav->hAcm != NULL && AcmTerm(lpWav->hAcm) != 0)
			fSuccess = TraceFALSE(NULL);

		else
			lpWav->hAcm = NULL;

		// free wave resource
		//
		if (lpWav->hResource != NULL)
		{
			UnlockResource(lpWav->hResource);

			if (!FreeResource(lpWav->hResource))
				fSuccess = TraceFALSE(NULL);
			else
				lpWav->hResource = NULL;
		}

#ifdef _WIN32
		// truncate file if necessary
		//
		if (lPosTruncate != -1 && lpWav->lpszFileName != NULL)
		{
			HANDLE hFile = INVALID_HANDLE_VALUE;

			// open file
			//
			if ((hFile = CreateFile(lpWav->lpszFileName,
				GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// seek to truncate position
			//
			else if (SetFilePointer(hFile, lPosTruncate,
				NULL, (DWORD) FILE_BEGIN) == 0xFFFFFFFF)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// truncate file
			//
			else if (!SetEndOfFile(hFile))
				fSuccess = TraceFALSE(NULL);

			// close file
			//
			if (hFile != INVALID_HANDLE_VALUE && !CloseHandle(hFile))
				fSuccess = TraceFALSE(NULL);
		}
#endif
		// free formats
		//
		if (1)
		{
			int iType;

			for (iType = FORMATFILE; fSuccess && iType <= FORMATRECORD; ++iType)
			{
				if (lpWav->lpwfx[iType] != NULL &&
					WavFormatFree(lpWav->lpwfx[iType]) != 0)
					fSuccess = TraceFALSE(NULL);
			}
		}

		// free file name string
		//
		if (lpWav->lpszFileName != NULL)
		{
			StrDupFree(lpWav->lpszFileName);
			lpWav->lpszFileName = NULL;
		}

		if ((lpWav = MemFree(NULL, lpWav)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavPlayEx - play data from wav file
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<lpfnPlayStopped>	(i) function to call when play is stopped
//			NULL				do not notify
//		<hUserPlayStopped>	(i) param to pass to lpfnPlayStopped
//		<dwReserved>		(i) reserved; must be zero
//		<dwFlags>			(i) control flags
//			WAV_PLAYASYNC		return when playback starts (default)
//			WAV_PLAYSYNC		return after playback completes
//			WAV_NOSTOP			if device already playing, don't stop it
//			WAV_AUTOSTOP		stop playback when eof reached (default)
//			WAV_NOAUTOSTOP		continue playback until WavStop called
//			WAV_AUTOCLOSE		close wav file after playback stops
//			WAV_OPENRETRY		if output device busy, retry for up to 2 sec
// return 0 if success
//
// NOTE: data from the wav file is sent to the output device in chunks.
// Chunks are submitted to an output device queue, so that when one
// chunk is finished playing, another is ready to start playing. By
// default, each chunk is large enough to hold approximately 666 ms
// of sound, and 3 chunks are maintained in the output device queue.
// WavSetChunks() can be used to override the defaults.
//
// NOTE: if WAV_NOSTOP is specified in <dwFlags>, and the device specified
// by <idDev> is already in use, this function returns without playing.
// Unless this flag is specified, the specified device will be stopped
// so that the new sound can be played.
//
// NOTE: if WAV_AUTOSTOP is specified in <dwFlags>, WavStop() will be
// called automatically when end of file is reached.  This is the
// default behavior, but can be overridden by using the WAV_NOAUTOSTOP
// flag.  WAV_NOAUTOSTOP is useful if you are playing a file that
// is growing dynamically as another program writes to it. If this is
// the case, also use the WAV_DENYNONE flag when calling WavOpen().
//
// NOTE: if WAV_AUTOCLOSE is specified in <dwFlags>, WavClose() will
// be called automatically when playback completes.  This will happen
// when WavStop() is called explicitly, or when WavPlay() reaches end
// of file and WAV_NOAUTOSTOP was not specified.  WAV_AUTOCLOSE is useful
// when used with WAV_PLAYASYNC, since cleanup occurs automatically.
// The <hWav> handle is thereafter invalid, and should not be used again.
//
int WINAPI WavPlay(HWAV hWav, int idDev, DWORD dwFlags)
{
	return WavPlayEx(hWav, idDev, NULL, NULL, 0, dwFlags);
}

int DLLEXPORT WINAPI WavPlayEx(HWAV hWav, int idDev,
	PLAYSTOPPEDPROC lpfnPlayStopped, HANDLE hUserPlayStopped,
	DWORD dwReserved, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	int i;
	LPWAVEFORMATEX lpwfxWavOutOpen = NULL;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure output device is not already open for this file
	//
	else if (lpWav->hWavOut != NULL)
		fSuccess = TraceFALSE(NULL);
		
#ifdef MULTITHREAD
	// we need to know when we can exit
	//
	else if ((lpWav->dwFlags & WAV_MULTITHREAD) &&
		(dwFlags & WAV_PLAYSYNC) &&
		(lpWav->hEventStopped = CreateEvent(
		NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#endif

	// make sure output device is not playing
	//
	else if (WavStopOutputDevice(idDev, dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);

	// set new playback format if device cannot handle the current format
	//
	else if (!WavOutSupportsFormat(NULL, idDev, lpWav->lpwfx[FORMATPLAY]))
	{
		LPWAVEFORMATEX lpwfxPlay = NULL;

		if ((lpwfxPlay = WavOutFormatSuggest(NULL,
			idDev, lpWav->lpwfx[FORMATPLAY],
			(lpWav->dwFlags & WAV_NOACM) ? WAVOUT_NOACM : 0)) != NULL &&
			WavSetFormat(hWav, lpwfxPlay, WAV_FORMATPLAY) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		if (lpwfxPlay != NULL && WavFormatFree(lpwfxPlay) != 0)
			fSuccess = TraceFALSE(NULL);
		else
			lpwfxPlay = NULL;
	}

	if (!fSuccess)
		;

	// create the notification callback window
	//
	else if (WavNotifyCreate(lpWav) != 0)
		fSuccess = TraceFALSE(NULL);

	// non-standard playback speed must be handled here
	//
	else if (lpWav->nSpeedLevel != 100)
	{
#ifdef AVTSM
		// use time scale modification engine
		//
		if (!(lpWav->dwFlagsSpeed & WAVSPEED_NOTSM))
		{
			long sizBufPlay;

			// calculate the size of output chunk
			//
			if ((sizBufPlay = WavCalcChunkSize(lpWav->lpwfx[FORMATPLAY],
				lpWav->msPlayChunkSize, TRUE)) <= 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// initialize time scale modification engine
			//
			else if ((lpWav->hTsm = TsmInit(TSM_VERSION, lpWav->hInst,
				lpWav->lpwfx[FORMATPLAY],
				2, sizBufPlay * TSM_OUTBUF_SIZE_FACT, 0)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// set the speed
			//
			else if (TsmSetSpeed(lpWav->hTsm, lpWav->nSpeedLevel, 0) != 0)
				fSuccess = TraceFALSE(NULL);
		}
		else
#endif
		// device supports playback rate directly
		//
		if (!(lpWav->dwFlagsSpeed & WAVSPEED_NOPLAYBACKRATE))
		{
			// we must wait until device has been opened
			//
			;
		}

		// device supports adjusted format
		//
		else if (!(lpWav->dwFlagsSpeed & WAVSPEED_NOFORMATADJUST))
		{
			// device supports adjusted format with acm
			//
			if (!(lpWav->dwFlagsSpeed & WAVSPEED_NOACM))
			{
#if 0
				LPWAVEFORMATEX lpwfxPlay = NULL;

				if ((lpwfxPlay = WavFormatDup(lpWav->lpwfx[FORMATPLAY])) == NULL)
					fSuccess = TraceFALSE(NULL);

				// we must double sample rate so that adjusted format works
				//
				else if (lpWav->nSpeedLevel < 100 &&
					WavFormatSpeedAdjust(lpwfxPlay, 200, 0) != 0)
				{
					fSuccess = TraceFALSE(NULL);
				}

				// we must halve sample rate so that adjusted format works
				//
				else if (lpWav->nSpeedLevel > 100 &&
					WavFormatSpeedAdjust(lpwfxPlay, 50, 0) != 0)
				{
					fSuccess = TraceFALSE(NULL);
				}

				else if (WavSetFormat(hWav, lpwfxPlay, WAV_FORMATPLAY) != 0)
					fSuccess = TraceFALSE(NULL);

				if (lpwfxPlay != NULL && WavFormatFree(lpwfxPlay) != 0)
					fSuccess = TraceFALSE(NULL);
				else
					lpwfxPlay = NULL;
#endif
			}

			if (fSuccess)
			{
				if ((lpwfxWavOutOpen = WavFormatDup(lpWav->lpwfx[FORMATPLAY])) == NULL)
					fSuccess = TraceFALSE(NULL);

				// adjust output device format to reflect current speed
				//
				else if (WavFormatSpeedAdjust(lpwfxWavOutOpen, lpWav->nSpeedLevel, 0) != 0)
					fSuccess = TraceFALSE(NULL);
			}
		}
	}

	if (!fSuccess)
		;

	// open output device
	//
	else if ((lpWav->hWavOut = WavOutOpen(WAVOUT_VERSION, lpWav->hInst, idDev,
		lpwfxWavOutOpen == NULL ? lpWav->lpwfx[FORMATPLAY] : lpwfxWavOutOpen,
#ifdef MULTITHREAD
		lpWav->dwFlags & WAV_MULTITHREAD ? (HWND)(DWORD_PTR)lpWav->dwThreadId :
#endif
		lpWav->hwndNotify, 0, 0,
#ifdef TELOUT
		((lpWav->dwFlags & WAV_TELRFILE) ? WAVOUT_TELRFILE : 0) |
#endif
#ifdef MULTITHREAD
		((lpWav->dwFlags & WAV_MULTITHREAD) ? WAVOUT_MULTITHREAD : 0) |
#endif
		((dwFlags & WAV_OPENRETRY) ? WAVOUT_OPENRETRY : 0) |
		((lpWav->dwFlags & WAV_NOACM) ? WAVOUT_NOACM : 0))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// save PlayStopped params for later
	//
	else if (lpWav->lpfnPlayStopped = lpfnPlayStopped, FALSE)
		;
	else if (lpWav->hUserPlayStopped = hUserPlayStopped, FALSE)
		;

	// set the device volume if necessary
	//
	else if (lpWav->nVolumeLevel != 50 &&
		WavOutSetVolume(lpWav->hWavOut, -1, lpWav->nVolumeLevel) != 0)
		fSuccess = TraceFALSE(NULL);

	// set the device playback rate if necessary
	//
	else if (lpWav->nSpeedLevel != 100 &&
		!(lpWav->dwFlagsSpeed & WAVSPEED_NOPLAYBACKRATE) &&
		WavOutSetSpeed(lpWav->hWavOut, lpWav->nSpeedLevel) != 0)
		fSuccess = TraceFALSE(NULL);

	// setup acm conversion if play format different than file format
	//
	else if (WavFormatCmp(lpWav->lpwfx[FORMATFILE],
		lpWav->lpwfx[FORMATPLAY]) != 0 &&
		AcmConvertInit(lpWav->hAcm,
		lpWav->lpwfx[FORMATFILE], lpWav->lpwfx[FORMATPLAY], NULL, 0) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

#if 0
	// pause output device before sending chunks to play
	//
	else if (WavOutPause(lpWav->hWavOut) != 0)
		fSuccess = TraceFALSE(NULL);
#endif

	// associate wav handle with device id
	//
	if (fSuccess)
	{
		int idDev;

		if ((idDev = WavOutGetId(lpWav->hWavOut)) < HWAVOUT_MIN ||
			idDev >= HWAVOUT_MAX)
			fSuccess = TraceFALSE(NULL);

		else
			ahWavOutCurr[idDev + HWAVOUT_OFFSET] = WavGetHandle(lpWav);
	}

	// remember the flags used in case we need them later
	//
	if (fSuccess)
		lpWav->dwFlagsPlay = dwFlags;

	// set the WAVSTATE_AUTOSTOP flag for later if necessary
	//
	if (fSuccess && !(dwFlags & WAV_NOAUTOSTOP))
		lpWav->dwState |= WAVSTATE_AUTOSTOP;

	// set the WAVSTATE_AUTOCLOSE flag for later if necessary
	//
	if (fSuccess && (dwFlags & WAV_AUTOCLOSE))
		lpWav->dwState |= WAVSTATE_AUTOCLOSE;

	// load output device queue with chunks to play
	//
	for (i = 0; fSuccess && i < lpWav->cPlayChunks; ++i)
	{
		if (WavPlayNextChunk(hWav) != 0)
			fSuccess = TraceFALSE(NULL);
	}

#if 0
	// start playback
	//
	if (fSuccess && WavOutResume(lpWav->hWavOut) != 0)
		fSuccess = TraceFALSE(NULL);
#endif

	// loop until playback complete if WAV_PLAYSYNC flag specified
	//
	if (fSuccess && (dwFlags & WAV_PLAYSYNC))
	{
#ifdef MULTITHREAD
		// handle WAV_MULTITHREAD flag
		//
		if (fSuccess && (lpWav->dwFlags & WAV_MULTITHREAD))
		{
			// wait for the play to end
			//
			if (WaitForSingleObject(lpWav->hEventStopped, INFINITE) != WAIT_OBJECT_0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// clean up
			//
			else if (lpWav->hEventStopped != NULL)
			{
				if (!CloseHandle(lpWav->hEventStopped))
					fSuccess = TraceFALSE(NULL);
				else
					lpWav->hEventStopped = NULL;
			}
		}
		else
#endif
		// check for valid pointer because WAV_AUTOCLOSE flag
		// could cause hWav to be invalidated during this loop
		//
		while (WavGetPtr(hWav) != NULL &&
			WavGetState(hWav) != WAV_STOPPED)
		{
			MSG msg;

			if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
			{
	 			TranslateMessage(&msg);
	 			DispatchMessage(&msg);
			}
			else
				WaitMessage();
		}
	}

	// close output device only if error or playback complete
	//
	if (!fSuccess || (dwFlags & WAV_PLAYSYNC))
	{
		if (WavGetPtr(hWav) != NULL && WavStopPlay(hWav) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (lpwfxWavOutOpen != NULL && WavFormatFree(lpwfxWavOutOpen) != 0)
		fSuccess = TraceFALSE(NULL);
	else
		lpwfxWavOutOpen = NULL;

	return fSuccess ? 0 : -1;
}

// WavRecordEx - record data to wav file
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav input device id
//			-1					use any suitable input device
//		<lpfnRecordStopped>	(i) function to call when record is stopped
//			NULL				do not notify
//		<dwUserRecordStopped>	(i) param to pass to lpfnRecordStopped
//		<msMaxSize>			(i) stop recording if file reaches this size
//			0					no maximum size
//		<dwFlags>			(i) control flags
//			WAV_RECORDASYNC		return when recording starts (default)
//			WAV_RECORDSYNC		return after recording completes
//			WAV_NOSTOP			if device already recording, don't stop it
//			WAV_OPENRETRY		if input device busy, retry for up to 2 sec
// return 0 if success
//
// NOTE: data from the input device is written to the wav file in chunks.
// Chunks are submitted to an input device queue, so that when one
// chunk is finished recording, another is ready to start recording.
// By default, each chunk is large enough to hold approximately 666 ms
// of sound, and 3 chunks are maintained in the input device queue.
// WavSetChunks() can be used to override the defaults.
//
// NOTE: if WAV_NOSTOP is specified in <dwFlags>, and the device specified
// by <idDev> is already in use, this function returns without recording.
// Unless this flag is specified, the specified device will be stopped
// so that the new sound can be recorded.
//
int WINAPI WavRecord(HWAV hWav, int idDev, DWORD dwFlags)
{
	return WavRecordEx(hWav, idDev, NULL, 0, 0, dwFlags);
}

int DLLEXPORT WINAPI WavRecordEx(HWAV hWav, int idDev,
	RECORDSTOPPEDPROC lpfnRecordStopped, DWORD dwUserRecordStopped,
	long msMaxSize, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	int i;
	LPWAVEFORMATEX lpwfxRecord = NULL;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure input device is not already open for this file
	//
	else if (lpWav->hWavIn != NULL)
		fSuccess = TraceFALSE(NULL);

#ifdef MULTITHREAD
	// we need to know when we can exit
	//
	else if ((lpWav->dwFlags & WAV_MULTITHREAD) &&
		(dwFlags & WAV_RECORDSYNC) &&
		(lpWav->hEventStopped = CreateEvent(
		NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#endif

	// make sure input device is not recording
	//
	else if (WavStopInputDevice(idDev, dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);

	// set new recording format if device cannot handle the current format
	//
	else if (!WavInSupportsFormat(NULL, idDev, lpWav->lpwfx[FORMATRECORD]) &&
		(lpwfxRecord = WavInFormatSuggest(NULL,
		idDev, lpWav->lpwfx[FORMATRECORD],
		(lpWav->dwFlags & WAV_NOACM) ? WAVIN_NOACM : 0)) != NULL &&
		WavSetFormat(hWav, lpwfxRecord, WAV_FORMATRECORD) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// create the notification callback window
	//
	else if (WavNotifyCreate(lpWav) != 0)
		fSuccess = TraceFALSE(NULL);

	// open input device
	//
	else if ((lpWav->hWavIn = WavInOpen(WAVIN_VERSION, lpWav->hInst,
		idDev, lpWav->lpwfx[FORMATRECORD],
#ifdef MULTITHREAD
		lpWav->dwFlags & WAV_MULTITHREAD ? (HWND)(DWORD_PTR)lpWav->dwThreadId :
#endif
		lpWav->hwndNotify, 0, 0,
#ifdef TELIN
		((lpWav->dwFlags & WAV_TELRFILE) ? WAVIN_TELRFILE : 0) |
#endif
#ifdef MULTITHREAD
		((lpWav->dwFlags & WAV_MULTITHREAD) ? WAVOUT_MULTITHREAD : 0) |
#endif
		((dwFlags & WAV_OPENRETRY) ? WAVIN_OPENRETRY : 0) |
		((lpWav->dwFlags & WAV_NOACM) ? WAVIN_NOACM : 0))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// save params for later
	//
	else if (lpWav->lpfnRecordStopped = lpfnRecordStopped, FALSE)
		;
	else if (lpWav->dwUserRecordStopped = dwUserRecordStopped, FALSE)
		;
	else if (lpWav->msMaxSize = msMaxSize, FALSE)
		;

	// setup acm conversion if file format different than record format
	//
	else if (WavFormatCmp(lpWav->lpwfx[FORMATRECORD],
		lpWav->lpwfx[FORMATFILE]) != 0 &&
		AcmConvertInit(lpWav->hAcm,
		lpWav->lpwfx[FORMATRECORD], lpWav->lpwfx[FORMATFILE], NULL, 0) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// associate wav handle with device id
	//
	if (fSuccess)
	{
		int idDev;

		if ((idDev = WavInGetId(lpWav->hWavIn)) < HWAVIN_MIN ||
			idDev >= HWAVIN_MAX)
			TraceFALSE(NULL);

		else
			ahWavInCurr[idDev + HWAVIN_OFFSET] = WavGetHandle(lpWav);
	}

	// remember the flags used in case we need them later
	//
	if (fSuccess)
		lpWav->dwFlagsRecord = dwFlags;

	// load input device queue with chunks to play
	//
	for (i = 0; fSuccess && i < lpWav->cRecordChunks; ++i)
	{
		if (WavRecordNextChunk(hWav) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	// set the WAVSTATE_AUTOSTOP flag for later if necessary
	//
	if (fSuccess && (dwFlags & WAV_AUTOSTOP))
		lpWav->dwState |= WAVSTATE_AUTOSTOP;

	// set the WAVSTATE_AUTOCLOSE flag for later if necessary
	//
	if (fSuccess && (dwFlags & WAV_AUTOCLOSE))
		lpWav->dwState |= WAVSTATE_AUTOCLOSE;

	// loop until recording complete if WAV_RECORDSYNC flag specified
	//
	if (fSuccess && (dwFlags & WAV_RECORDSYNC))
	{
#ifdef MULTITHREAD
		// handle WAV_MULTITHREAD flag
		//
		if (fSuccess && (lpWav->dwFlags & WAV_MULTITHREAD))
		{
			// wait for the record to end
			//
			if (WaitForSingleObject(lpWav->hEventStopped, INFINITE) != WAIT_OBJECT_0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// clean up
			//
			else if (lpWav->hEventStopped != NULL)
			{
				if (!CloseHandle(lpWav->hEventStopped))
					fSuccess = TraceFALSE(NULL);
				else
					lpWav->hEventStopped = NULL;
			}
		}
		else
#endif
		while (WavGetState(hWav) != WAV_STOPPED)
		{
			MSG msg;

			if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
			{
	 			TranslateMessage(&msg);
	 			DispatchMessage(&msg);
			}
			else
				WaitMessage();
		}
	}

	// close input device only if error or recording complete
	//
	if (!fSuccess || (dwFlags & WAV_RECORDSYNC))
	{
		if (WavGetPtr(hWav) != NULL && WavStopRecord(hWav) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (lpwfxRecord != NULL && WavFormatFree(lpwfxRecord) != 0)
		fSuccess = TraceFALSE(NULL);
	else
		lpwfxRecord = NULL;

	return fSuccess ? 0 : -1;
}

// WavStop - stop playing and/or recording
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
int WINAPI WavStop(HWAV hWav)
{
	BOOL fSuccess = TRUE;

	// stop playing
	//
	if (WavStopPlay(hWav) != 0)
		fSuccess = TraceFALSE(NULL);

	// stop recording
	//
	if (WavStopRecord(hWav) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// WavRead - read data from wav file
//		<hWav>				(i) handle returned from WavOpen
//		<hpBuf>				(o) buffer to contain bytes read
//		<sizBuf>			(i) size of buffer in bytes
// return bytes read (-1 if error)
//
// NOTE : Even if the read operation does not reach the end of file,
// the number of bytes returned could be less than <sizBuf> if data
// decompression is performed by the wav file's I/O procedure. See the
// <lpIOProc> parameter in WavOpen.  It is safest to keep calling
// WavRead() until 0 bytes are read.
//
long DLLEXPORT WINAPI WavRead(HWAV hWav, void _huge *hpBuf, long sizBuf)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long lBytesRead;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (hpBuf == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure we don't read beyond the end of the data
	// NOTE: cbData might not be accurate if file is growing dynamically,
	// so it is ok to read beyond eof if sharing flags are set
	//
	else if (!(lpWav->dwFlags & WAV_DENYNONE) &&
		!(lpWav->dwFlags & WAV_DENYREAD) &&
		(sizBuf = min(sizBuf, lpWav->cbData - lpWav->lDataPos)) < 0)
		fSuccess = TraceFALSE(NULL);

	// do the read
	//
	else if ((lBytesRead = mmioRead(lpWav->hmmio, hpBuf, sizBuf)) < 0)
		fSuccess = TraceFALSE(NULL);

 	else if (TracePrintf_1(NULL, 5,
 		TEXT("WavRead (%ld)\n"),
		(long) lBytesRead), FALSE)
		fSuccess = TraceFALSE(NULL);

	// adjust current data position
	// (and total data bytes, if file has grown)
	//
	else if ((lpWav->lDataPos += lBytesRead) > lpWav->cbData)
	{
		if ((lpWav->dwFlags & WAV_DENYNONE) ||
			(lpWav->dwFlags & WAV_DENYREAD))
			lpWav->cbData = lpWav->lDataPos;
		else
			fSuccess = TraceFALSE(NULL);
	}

	// calculate new stop position if stopped
	//
	if (fSuccess && WavCalcPositionStop(hWav, lpWav->lDataPos) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lBytesRead : -1;
}

// WavWrite - write data to wav file
//		<hWav>				(i) handle returned from WavOpen
//		<hpBuf>				(i) buffer containing bytes to write
//		<sizBuf>			(i) size of buffer in bytes
// return bytes written (-1 if error)
//
// NOTE : Even if the write operation successfully completes,
// the number of bytes returned could be less than <sizBuf> if data
// compression is performed by the wav file's I/O procedure. See the
// <lpIOProc> parameter in WavOpen.  It is safest to assume no error
// in WavWrite() occurred if the return value is greater than 0.
//
long DLLEXPORT WINAPI WavWrite(HWAV hWav, void _huge *hpBuf, long sizBuf)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long lBytesWritten;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// special case: truncate file at current position
	//
	else if (hpBuf == NULL && sizBuf == 0)
	{
		if (WavSetLength(hWav, WavGetPosition(hWav)) < 0)
			return -1;
		else
			return 0;
	}

	else if (hpBuf == NULL)
		fSuccess = TraceFALSE(NULL);

	// do the write
	//
	else if ((lBytesWritten = mmioWrite(lpWav->hmmio, hpBuf, sizBuf)) < 0)
		fSuccess = TraceFALSE(NULL);

	// set dirty flags
	//
	else if (lpWav->ckdata.dwFlags |= MMIO_DIRTY,
		lpWav->ckRIFF.dwFlags |= MMIO_DIRTY, FALSE)
		;

 	else if (TracePrintf_1(NULL, 5,
 		TEXT("WavWrite (%ld)\n"),
		(long) lBytesWritten), FALSE)
		fSuccess = TraceFALSE(NULL);

	// adjust current data position
	// (and total data bytes, if file has grown)
	//
	else if ((lpWav->lDataPos += lBytesWritten) > lpWav->cbData)
		lpWav->cbData = lpWav->lDataPos;

	// calculate new stop position if stopped
	//
	if (fSuccess && WavCalcPositionStop(hWav, lpWav->lDataPos) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lBytesWritten : -1;
}

// WavSeek - seek within wav file data
//		<hWav>				(i) handle returned from WavOpen
//		<lOffset>			(i) bytes to move pointer
//		<nOrigin>			(i) position to move from
//			0					move pointer relative to start of data chunk
//			1					move pointer relative to current position
//			2					move pointer relative to end of data chunk
// return new file position (-1 if error)
//
long DLLEXPORT WINAPI WavSeek(HWAV hWav, long lOffset, int nOrigin)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long lPos;
	BOOL fWavTell;
	BOOL fWavSeekTrace;

	// WavSeek(..., 0, 1) is same as WavTell(); i.e. no position change
	//
	fWavTell = (BOOL) (lOffset == 0L && nOrigin == 1);

	// traces only if position change with high trace level
	//
	fWavSeekTrace = (BOOL) (!fWavTell && TraceGetLevel(NULL) >= 6);

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// debug trace output before the seek
	//
	else if (fWavSeekTrace && WavSeekTraceBefore(lpWav, lOffset, nOrigin) != 0)
		fSuccess = TraceFALSE(NULL);

	// SEEK_SET: adjust offset relative to beginning of file
	//
	else if (nOrigin == 0 && (lOffset += lpWav->lDataOffset, FALSE))
		fSuccess = TraceFALSE(NULL);

	// SEEK_CUR: adjust offset relative to beginning of file
	//
	else if (nOrigin == 1 && (lOffset += lpWav->lDataOffset + lpWav->lDataPos, FALSE))
		fSuccess = TraceFALSE(NULL);

	// SEEK_END: adjust offset relative to beginning of file
	//
	else if (nOrigin == 2 && (lOffset += lpWav->lDataOffset + lpWav->cbData, FALSE))
		fSuccess = TraceFALSE(NULL);

	// seek is always relative to the beginning of file
	//
	else if (nOrigin = 0, FALSE)
		;

	// do the seek
	//
	else if ((lPos = mmioSeek(lpWav->hmmio, lOffset, nOrigin)) < 0)
		fSuccess = TraceFALSE(NULL);

	// adjust current data position
	//
	else if ((lpWav->lDataPos = lPos - lpWav->lDataOffset) < 0)
		fSuccess = TraceFALSE(NULL);

	// adjust total data bytes, if file has grown
	//
	else if (lpWav->lDataPos > lpWav->cbData)
	{
		if ((lpWav->dwFlags & WAV_DENYNONE) ||
			(lpWav->dwFlags & WAV_DENYREAD))
			lpWav->cbData = lpWav->lDataPos;
		else
			fSuccess = TraceFALSE(NULL);
	}

	// calculate new stop position if stopped
	// NOTE: we skip this if position unchanged
	//
	if (fSuccess && !fWavTell &&
		WavCalcPositionStop(hWav, lpWav->lDataPos) != 0)
		fSuccess = TraceFALSE(NULL);

	// debug trace output after the seek
	//
	if (fSuccess && fWavSeekTrace &&
		WavSeekTraceAfter(lpWav, lPos, lOffset, nOrigin) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWav->lDataPos : -1;
}

// WavGetState - return current wav state
//		<hWav>				(i) handle returned from WavOpen
// return WAV_STOPPED, WAV_PLAYING, WAV_RECORDING, or 0 if error
//
WORD DLLEXPORT WINAPI WavGetState(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	WORD wState = WAV_STOPPED;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpWav->hWavOut != NULL)
	{
		switch (WavOutGetState(lpWav->hWavOut))
		{
			case WAVOUT_PLAYING:
				wState = WAV_PLAYING;
				break;

			case WAVOUT_STOPPING:
				wState = WAV_STOPPING;
				break;

			case WAVOUT_STOPPED:
			case WAVOUT_PAUSED:
				wState = WAV_STOPPED;
				break;

			case 0:
			default:
				fSuccess = TraceFALSE(NULL);
				break;

		}
	}

	else if (lpWav->hWavIn != NULL)
	{
		switch (WavInGetState(lpWav->hWavIn))
		{
			case WAVIN_RECORDING:
				wState = WAV_RECORDING;
				break;

			case WAVIN_STOPPING:
				wState = WAV_STOPPING;
				break;

			case WAVIN_STOPPED:
				wState = WAV_STOPPED;
				break;

			case 0:
			default:
				fSuccess = TraceFALSE(NULL);
				break;

		}
	}

	// if we are in the middle of WavStopPlay() or WavStopRecord()
	// then set state to WAV_STOPPING, regardless of device state
	//
	if (fSuccess && ((lpWav->dwState & WAVSTATE_STOPPLAY) ||
		(lpWav->dwState & WAVSTATE_STOPRECORD)))
	{
		wState = WAV_STOPPING;
	}

	return fSuccess ? wState : 0;
}

// WavGetLength - get current wav data length in milleseconds
//		<hWav>				(i) handle returned from WavOpen
// return milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI WavGetLength(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long msLength;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		msLength = WavFormatBytesToMilleseconds(
			lpWav->lpwfx[FORMATFILE], (DWORD) lpWav->cbData);
	}

	return fSuccess ? msLength : -1;
}

// WavSetLength - set current wav data length in milleseconds
//		<hWav>				(i) handle returned from WavOpen
//		<msLength>			(i) length in milleseconds
// return new length in milleseconds if success, otherwise -1
//
// NOTE: afterwards, the current wav data position is set to either
// the previous wav data position or <msLength>, whichever is smaller.
//
long DLLEXPORT WINAPI WavSetLength(HWAV hWav, long msLength)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	TracePrintf_1(NULL, 6,
		TEXT("WavSetLength(%ld)\n"),
		(long) msLength);

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// new length must be reasonable
	//
	else if (msLength < 0 || msLength > WavGetLength(hWav))
		fSuccess = TraceFALSE(NULL);

	else
	{
		long lBlockAlign;

		// convert <msLength> to byte offset in file
		//
		lpWav->cbData = WavFormatMillesecondsToBytes(
			lpWav->lpwfx[FORMATFILE], (DWORD) msLength);

		// $FIXUP - add <nRound> parameter to
		// WavFormatMillesecondsToBytes() and WavFormatBytesToMilleseconds()
		//
		if ((lBlockAlign = (long) lpWav->lpwfx[FORMATFILE]->nBlockAlign) > 0)
		{
			// round down to nearest block boundary
			//
			lpWav->cbData = lBlockAlign * (lpWav->cbData / lBlockAlign);
		}

		// set dirty flags
		//
		lpWav->ckdata.dwFlags |= MMIO_DIRTY;
		lpWav->ckRIFF.dwFlags |= MMIO_DIRTY;

		// adjust current data position if necessary
		//
		if (lpWav->lDataPos > lpWav->cbData)
		{
			lpWav->lDataPos = lpWav->cbData;

			// calculate new stop position if stopped
			//
			if (fSuccess && WavCalcPositionStop(hWav, lpWav->lDataPos) != 0)
				fSuccess = TraceFALSE(NULL);
		}
	}

	return fSuccess ? WavGetLength(hWav) : -1;
}

// WavGetPosition - get current wav data position in milleseconds
//		<hWav>				(i) handle returned from WavOpen
// return milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI WavGetPosition(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long msPosition;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (WavGetState(hWav))
	{
		case WAV_PLAYING:
		{
			long msPositionPlay = 0L;

			// get position relative to start of playback
			//
			if ((msPositionPlay = WavOutGetPosition(lpWav->hWavOut)) == -1)
				fSuccess = TraceFALSE(NULL);

			else
			{
				// if necessary, adjust position to compensate for non-standard speed
				//
				if (lpWav->nSpeedLevel != 100 && (
#ifdef AVTSM
					!(lpWav->dwFlagsSpeed & WAVSPEED_NOTSM) ||
#endif
					!(lpWav->dwFlagsSpeed & WAVSPEED_NOFORMATADJUST)))
				{
					msPositionPlay = msPositionPlay * lpWav->nSpeedLevel / 100;
				}

				// calc position relative to start of file
				//
				msPosition = lpWav->msPositionStop + msPositionPlay;
			}
		}
			break;

		case WAV_RECORDING:
		{
			long msPositionRecord = 0L;

			// get position relative to start of recording
			//
			if ((msPositionRecord = WavInGetPosition(lpWav->hWavIn)) == -1)
				fSuccess = TraceFALSE(NULL);

			else
			{
				// calc position relative to start of file
				//
				msPosition = lpWav->msPositionStop + msPositionRecord;
			}
		}
			break;

		default:
		{
			long cbPosition;

			// get current file position
			//
			if ((cbPosition = WavSeek(hWav, 0, 1)) == -1)
				fSuccess = TraceFALSE(NULL);

			// convert file position to milleseconds
			//
			else
			{
				msPosition = WavFormatBytesToMilleseconds(
					lpWav->lpwfx[FORMATFILE], (DWORD) cbPosition);
			}
		}
			break;
	}

	return fSuccess ? msPosition : -1;
}

// WavSetPosition - set current wav data position in milleseconds
//		<hWav>				(i) handle returned from WavOpen
//		<msPosition>		(i) position in milleseconds
// return new position in milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI WavSetPosition(HWAV hWav, long msPosition)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	WORD wStatePrev;
	int idDevPrev;
	long cbPosition;
	long cbPositionNew;
	long msPositionNew;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (WavTempStop(hWav, &wStatePrev, &idDevPrev) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
		long lBlockAlign;

		TracePrintf_1(NULL, 6,
			TEXT("WavSetPosition(%ld)\n"),
			(long) msPosition);

		// convert <msPosition> to byte offset in file
		//
		cbPosition = WavFormatMillesecondsToBytes(
			lpWav->lpwfx[FORMATFILE], (DWORD) msPosition);

		if ((lBlockAlign = (long) lpWav->lpwfx[FORMATFILE]->nBlockAlign) > 0)
		{
			// round down to nearest block boundary
			//
			cbPosition = lBlockAlign * (cbPosition / lBlockAlign);
		}

		// seek to new position
		//
		if ((cbPositionNew = WavSeek(hWav, cbPosition, 0)) == -1)
			fSuccess = TraceFALSE(NULL);

		// convert the new position to milleseconds
		//
		if (fSuccess)
		{
			msPositionNew = WavFormatBytesToMilleseconds(
				lpWav->lpwfx[FORMATFILE], (DWORD) cbPositionNew);
		}

		if (WavTempResume(hWav, wStatePrev, idDevPrev) != 0)
			fSuccess = TraceFALSE(NULL);

	}

	return fSuccess ? msPositionNew : -1;
}

// WavGetFormat - get wav format
//		<hWav>				(i) handle returned from WavOpen
//		<dwFlags>			(i) control flags
//			WAV_FORMATFILE		get format of data in file
//			WAV_FORMATPLAY		get format of output device
//			WAV_FORMATRECORD	get format of input device
// return pointer to specified format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavGetFormat(HWAV hWav, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	int iType = 0;
	LPWAVEFORMATEX lpwfx;

	if (dwFlags & WAV_FORMATFILE)
		iType = FORMATFILE;
	if (dwFlags & WAV_FORMATPLAY)
		iType = FORMATPLAY;
	if (dwFlags & WAV_FORMATRECORD)
		iType = FORMATRECORD;

    //
    // We need to take care if hWav is NULL
    //
    if( NULL != hWav )
    {
	    if ((lpWav = WavGetPtr(hWav)) == NULL)
		    fSuccess = TraceFALSE(NULL);

	    else if ((lpwfx = WavFormatDup(lpWav->lpwfx[iType])) == NULL)
		    fSuccess = TraceFALSE(NULL);
    }
    else
        fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpwfx : NULL;
}

// WavSetFormat - set wav format
//		<hWav>				(i) handle returned from WavOpen
//		<lpwfx>				(i) wav format
//		<dwFlags>			(i) control flags
//			WAV_FORMATFILE		set format of data in file
//			WAV_FORMATPLAY		set format of output device
//			WAV_FORMATRECORD	set format of input device
//			WAV_FORMATALL		set all formats
// return 0 if success
//
int DLLEXPORT WINAPI WavSetFormat(HWAV hWav,
	LPWAVEFORMATEX lpwfx, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	WORD wStatePrev;
	int idDevPrev;

	if (hWav != NULL && (lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfx) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (WavTempStop(hWav, &wStatePrev, &idDevPrev) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
		int iType;

		for (iType = FORMATFILE; fSuccess && iType <= FORMATRECORD; ++iType)
		{
			if (iType == FORMATFILE && !(dwFlags & WAV_FORMATFILE))
				continue;
			if (iType == FORMATPLAY && !(dwFlags & WAV_FORMATPLAY))
				continue;
			if (iType == FORMATRECORD && !(dwFlags & WAV_FORMATRECORD))
				continue;

			// free previous format
			//
			if (lpWav->lpwfx[iType] != NULL &&
				WavFormatFree(lpWav->lpwfx[iType]) != 0)
				fSuccess = TraceFALSE(NULL);

			// save new format
			//
			else if ((lpWav->lpwfx[iType] = WavFormatDup(lpwfx)) == NULL)
				fSuccess = TraceFALSE(NULL);

			// trace format text
			//
			else if (TraceGetLevel(NULL) >= 5)
			{
				TCHAR szText[512];

				switch (iType)
				{
					case FORMATFILE:
						TraceOutput(NULL, 5, TEXT("FORMATFILE:\t"));
						break;

					case FORMATPLAY:
						TraceOutput(NULL, 5, TEXT("FORMATPLAY:\t"));
						break;

					case FORMATRECORD:
						TraceOutput(NULL, 5, TEXT("FORMATRECORD:\t"));
						break;

					default:
						break;
				}

				if (AcmFormatGetText(lpWav->hAcm,
					lpWav->lpwfx[iType], szText, SIZEOFARRAY(szText), 0) != 0)
					; // fSuccess = TraceFALSE(NULL);

				else
				{
					TracePrintf_1(NULL, 5,
						TEXT("%s\n"),
						(LPTSTR) szText);
#if 0
					WavFormatDump(lpWav->lpwfx[iType]);
#endif
				}
			}
		}

		if (WavTempResume(hWav, wStatePrev, idDevPrev) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavChooseFormat - choose and set audio format from dialog box
//		<hWav>				(i) handle returned from WavOpen
//		<hwndOwner>			(i) owner of dialog box
//			NULL				no owner
//		<lpszTitle>			(i) title of the dialog box
//			NULL				use default title ("Sound Selection")
//		<dwFlags>			(i)	control flags
//			WAV_FORMATFILE		set format of data in file
//			WAV_FORMATPLAY		set format of output device
//			WAV_FORMATRECORD	set format of input device
//			WAV_FORMATALL		set all formats
// return 0 if success
//
int DLLEXPORT WINAPI WavChooseFormat(HWAV hWav, HWND hwndOwner, LPCTSTR lpszTitle, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		LPWAVEFORMATEX lpwfx = NULL;
		LPWAVEFORMATEX lpwfxNew = NULL;
		DWORD dwFlagsChoose = 0;

		// see which format we are choosing
		//
		if (dwFlags & WAV_FORMATFILE)
			lpwfx = lpWav->lpwfx[FORMATFILE];
		else if (dwFlags & WAV_FORMATPLAY)
			lpwfx = lpWav->lpwfx[FORMATPLAY];
		else if (dwFlags & WAV_FORMATRECORD)
			lpwfx = lpWav->lpwfx[FORMATRECORD];
#if 0
		// restrict choices if necessary
		//
		if (dwFlags == WAV_FORMATPLAY)
			dwFlagsChoose |= ACM_FORMATPLAY;
		if (dwFlags == WAV_FORMATRECORD)
			dwFlagsChoose |= ACM_FORMATRECORD;
#endif
		// get chosen format
		//
		if ((lpwfxNew = AcmFormatChoose(lpWav->hAcm,
			hwndOwner, lpszTitle, lpwfx, dwFlagsChoose)) == NULL)
			; // no format chosen

		// set chosen format
		//
		else if (WavSetFormat(hWav, lpwfxNew, dwFlags) != 0)
			fSuccess = TraceFALSE(NULL);

		// free chosen format struct
		//
		if (lpwfxNew != NULL && WavFormatFree(lpwfxNew) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavGetVolume - get current volume level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<dwFlags>			(i) reserved; must be zero
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int DLLEXPORT WINAPI WavGetVolume(HWAV hWav, int idDev, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	int nLevel;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		nLevel = lpWav->nVolumeLevel;

	return fSuccess ? nLevel : -1;
}

// WavSetVolume - set current volume level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<nLevel>			(i) volume level
//			0					minimum volume
//			100					maximum volume
//		<dwFlags>			(i) control flags
//			WAVVOLUME_MIXER		set volume through mixer device
// return 0 if success
//
int DLLEXPORT WINAPI WavSetVolume(HWAV hWav, int idDev, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	TracePrintf_4(NULL, 6,
		TEXT("WavSetVolume(hWav=%p, idDev=%d, nLevel=%d, dwFlags=%08X)\n"),
		hWav,
		idDev,
		nLevel,
		dwFlags);

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nLevel == lpWav->nVolumeLevel)
		; // nothing to be done

	else if (dwFlags & WAVVOLUME_MIXER)
	{
		HWAVMIXER hWavMixer = NULL;

		if ((hWavMixer = WavMixerInit(WAVMIXER_VERSION, lpWav->hInst,
			(LPARAM) idDev, 0, 0, WAVMIXER_WAVEOUT)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavMixerSetVolume(hWavMixer, nLevel, 0) < 0)
			fSuccess = TraceFALSE(NULL);

		if (hWavMixer != NULL && WavMixerTerm(hWavMixer) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	else if (!(dwFlags & WAVVOLUME_MIXER))
	{
		if (!WavOutSupportsVolume(lpWav->hWavOut, idDev))
			fSuccess = TraceFALSE(NULL);

		// set the device volume if we are currently playing
		//
		else if (WavGetState(hWav) == WAV_PLAYING &&
			WavOutSetVolume(lpWav->hWavOut, idDev, nLevel) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (fSuccess)
		lpWav->nVolumeLevel = nLevel;

	return fSuccess ? 0 : -1;
}

// WavSupportsVolume - check if audio can be played at specified volume
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					any suitable output device
//		<nLevel>			(i) volume level
//			0					minimum volume
//			100					maximum volume
//		<dwFlags>			(i) control flags
//			WAVVOLUME_MIXER		check volume support through mixer device
// return TRUE if supported
//
BOOL DLLEXPORT WINAPI WavSupportsVolume(HWAV hWav, int idDev, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	BOOL fSupportsVolume = FALSE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (dwFlags & WAVVOLUME_MIXER)
	{
		HWAVMIXER hWavMixer = NULL;

		if ((hWavMixer = WavMixerInit(WAVMIXER_VERSION, lpWav->hInst,
			(LPARAM) idDev, 0, 0, WAVMIXER_WAVEOUT)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavMixerSupportsVolume(hWavMixer, 0))
			fSupportsVolume = TRUE;

		if (hWavMixer != NULL && WavMixerTerm(hWavMixer) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	else if (!(dwFlags & WAVVOLUME_MIXER))
	{
		// see if the device driver supports volume directly
		//
		if (WavOutSupportsVolume(NULL, idDev))
			fSupportsVolume = TRUE;
	}

	return fSuccess ? fSupportsVolume : FALSE;
}

// WavGetSpeed - get current speed level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<dwFlags>			(i) reserved; must be zero
// return speed level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI WavGetSpeed(HWAV hWav, int idDev, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	int nLevel;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		nLevel = lpWav->nSpeedLevel;

	return fSuccess ? nLevel : -1;
}

// WavSetSpeed - set current speed level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
//		<dwFlags>			(i) control flags
#ifdef AVTSM
//			WAVSPEED_NOTSM			do not use time scale modification engine
#endif
//			WAVSPEED_NOPLAYBACKRATE	do not use device driver playback rate
//			WAVSPEED_NOFORMATADJUST	do not use adjusted format to open device
//			WAVSPEED_NOACM			do not use audio compression manager
// return 0 if success
//
// NOTE: In order to accomodate the specified speed change, it is _possible_
// that this function will in turn call WavSetFormat(hWav, ..., WAV_FORMATPLAY)
// to change the playback format of the specified file. You can prevent this
// side-effect by specifying the WAVSPEED_NOACM flag, but this reduces the likelihood
// that WavSetSpeed will succeed.
//
int DLLEXPORT WINAPI WavSetSpeed(HWAV hWav, int idDev, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	WORD wStatePrev;
	int idDevPrev;

	TracePrintf_4(NULL, 6,
		TEXT("WavSetSpeed(hWav=%p, idDev=%d, nLevel=%d, dwFlags=%08X)\n"),
		hWav,
		idDev,
		nLevel,
		dwFlags);

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nLevel == lpWav->nSpeedLevel)
		; // nothing to be done

	else if (WavTempStop(hWav, &wStatePrev, &idDevPrev) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (nLevel == 100)
		{
			// normal speed is a special case
			//
			lpWav->nSpeedLevel = 100;
			lpWav->dwFlagsSpeed = 0;
		}
#ifdef AVTSM
		else if (!(dwFlags & WAVSPEED_NOTSM) &&
			WavSupportsSpeed(hWav, idDev, nLevel,
			WAVSPEED_NOACM | WAVSPEED_NOFORMATADJUST | WAVSPEED_NOPLAYBACKRATE))
		{
			// use time scale modification engine
			//
			lpWav->nSpeedLevel = nLevel;
			lpWav->dwFlagsSpeed = WAVSPEED_NOACM | WAVSPEED_NOFORMATADJUST | WAVSPEED_NOPLAYBACKRATE;
		}

		else if (!(dwFlags & WAVSPEED_NOTSM) &&
			WavSupportsSpeed(hWav, idDev, nLevel,
			WAVSPEED_NOFORMATADJUST | WAVSPEED_NOPLAYBACKRATE))
		{
#if 1
			WAVEFORMATEX wfxTsm;

			// try a format that the tsm engine will handle
			//
			if (WavSetFormat(hWav, WavFormatPcm(
				lpWav->lpwfx[FORMATPLAY]->nSamplesPerSec, 16, 1, &wfxTsm),
				WAV_FORMATPLAY) != 0)
				fSuccess = TraceFALSE(NULL);
#endif
			// use time scale modification engine with adjusted format
			//
			lpWav->nSpeedLevel = nLevel;
			lpWav->dwFlagsSpeed = WAVSPEED_NOFORMATADJUST | WAVSPEED_NOPLAYBACKRATE;
		}
#endif
		else if (!(dwFlags & WAVSPEED_NOPLAYBACKRATE) &&
			WavSupportsSpeed(hWav, idDev, nLevel,
			WAVSPEED_NOACM | WAVSPEED_NOFORMATADJUST | WAVSPEED_NOTSM))
		{
			// device supports playback rate directly
			//
			lpWav->nSpeedLevel = nLevel;
			lpWav->dwFlagsSpeed = WAVSPEED_NOACM | WAVSPEED_NOFORMATADJUST | WAVSPEED_NOTSM;
		}

		else if (!(dwFlags & WAVSPEED_NOFORMATADJUST) &&
			WavSupportsSpeed(hWav, idDev, nLevel,
			WAVSPEED_NOACM | WAVSPEED_NOPLAYBACKRATE | WAVSPEED_NOTSM))
		{
			// device supports adjusted format without acm
			//
			lpWav->nSpeedLevel = nLevel;
			lpWav->dwFlagsSpeed = WAVSPEED_NOACM | WAVSPEED_NOPLAYBACKRATE | WAVSPEED_NOTSM;
		}

		else if (!(dwFlags & WAVSPEED_NOFORMATADJUST) && !(dwFlags & WAVSPEED_NOACM) &&
			WavSupportsSpeed(hWav, idDev, nLevel,
			WAVSPEED_NOPLAYBACKRATE | WAVSPEED_NOTSM))
		{
#if 1
			LPWAVEFORMATEX lpwfxPlay = NULL;

			if ((lpwfxPlay = WavFormatDup(lpWav->lpwfx[FORMATPLAY])) == NULL)
				fSuccess = TraceFALSE(NULL);

			// we must double sample rate so that adjusted format works
			//
			else if (nLevel < 100 &&
				WavFormatSpeedAdjust(lpwfxPlay, 200, 0) != 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// we must halve sample rate so that adjusted format works
			//
			else if (nLevel > 100 &&
				WavFormatSpeedAdjust(lpwfxPlay, 50, 0) != 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if (WavSetFormat(hWav, lpwfxPlay, WAV_FORMATPLAY) != 0)
				fSuccess = TraceFALSE(NULL);

			if (lpwfxPlay != NULL && WavFormatFree(lpwfxPlay) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				lpwfxPlay = NULL;
#endif
			// device supports adjusted format with acm
			//
			lpWav->nSpeedLevel = nLevel;
			lpWav->dwFlagsSpeed = WAVSPEED_NOPLAYBACKRATE | WAVSPEED_NOTSM;
		}

			else
				fSuccess = TraceFALSE(NULL);

		if (WavTempResume(hWav, wStatePrev, idDevPrev) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavSupportsSpeed - check if audio can be played at specified speed
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					any suitable output device
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
//		<dwFlags>			(i) control flags
#ifdef AVTSM
//			WAVSPEED_NOTSM			do not use time scale modification engine
#endif
//			WAVSPEED_NOPLAYBACKRATE	do not use device driver playback rate
//			WAVSPEED_NOFORMATADJUST	do not use adjusted format to open device
//			WAVSPEED_NOACM			do not use audio compression manager
// return TRUE if supported
//
BOOL DLLEXPORT WINAPI WavSupportsSpeed(HWAV hWav, int idDev, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	BOOL fSupportsSpeed = FALSE;
	LPWAV lpWav;
#ifdef AVTSM
	WAVEFORMATEX wfxTsm;
#endif

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// normal speed is a special case
	//
	else if (nLevel == 100 &&
		WavOutSupportsFormat(NULL, idDev, lpWav->lpwfx[FORMATPLAY]))
	{
		fSupportsSpeed = TRUE;
	}
#ifdef AVTSM
	// see if time scale modification will work
	//
	else if (!(dwFlags & WAVSPEED_NOTSM) &&
		TsmSupportsSpeed(nLevel, lpWav->lpwfx[FORMATPLAY], 0))
	{
		fSupportsSpeed = TRUE;
	}

	// see if time scale modification will work with PCM 16-bit mono
	//
	else if (!(dwFlags & WAVSPEED_NOTSM) && !(dwFlags & WAVSPEED_NOACM) &&
		TsmSupportsSpeed(nLevel, WavFormatPcm(
		lpWav->lpwfx[FORMATPLAY]->nSamplesPerSec, 16, 1, &wfxTsm), 0))
	{
		fSupportsSpeed = TRUE;
	}
#endif
	// see if the device driver supports playback rate directly
	//
	else if (!(dwFlags & WAVSPEED_NOPLAYBACKRATE) &&
		WavOutSupportsSpeed(NULL, idDev))
	{
		fSupportsSpeed = TRUE;
	}

	else if (!(dwFlags & WAVSPEED_NOFORMATADJUST))
	{
		LPWAVEFORMATEX lpwfx = NULL;

		if ((lpwfx = WavFormatDup(lpWav->lpwfx[FORMATPLAY])) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatSpeedAdjust(lpwfx, nLevel, 0) != 0)
			fSuccess = TraceTRUE(NULL);

		// see if device supports playback using adjusted format
		//
		else if (WavOutSupportsFormat(NULL, idDev, lpwfx))
		{
			fSupportsSpeed = TRUE;
		}

		if (lpwfx != NULL && WavFormatFree(lpwfx) != 0)
			fSuccess = TraceFALSE(NULL);
		else
			lpwfx = NULL;

		// as a last resort, see if doubling or halving the sample rate
		// would allow us to use a wave format that has been adjusted
		//
		if (!fSupportsSpeed && !(dwFlags & WAVSPEED_NOACM))
		{
			LPWAVEFORMATEX lpwfx = NULL;

			if (nLevel < 100)
				nLevel = nLevel * 100 / 50;
			else if (nLevel > 100)
				nLevel = nLevel * 100 / 200;

			if ((lpwfx = WavFormatDup(lpWav->lpwfx[FORMATPLAY])) == NULL)
				fSuccess = TraceFALSE(NULL);

			else if (WavFormatSpeedAdjust(lpwfx, nLevel, 0) != 0)
				fSuccess = TraceTRUE(NULL);

			// see if device supports playback using adjusted format
			//
			else if (WavOutSupportsFormat(NULL, idDev, lpwfx))
			{
				fSupportsSpeed = TRUE;
			}

			if (lpwfx != NULL && WavFormatFree(lpwfx) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				lpwfx = NULL;
		}
	}

	return fSuccess ? fSupportsSpeed : FALSE;
}

// WavGetChunks - get chunk count and size
//		<hWav>				(i) handle returned from WavOpen
//			NULL				get default chunk count and size
//		<lpcChunks>			(o) buffer to hold chunk count
//			NULL				do not get chunk count
//		<lpmsChunkSize>		(o) buffer to hold chunk size
//			NULL				do not get chunk size
//		<fWavOut>			(i) TRUE for playback, FALSE for recording
// return 0 if success
//
int DLLEXPORT WINAPI WavGetChunks(HWAV hWav,
	int FAR *lpcChunks, long FAR *lpmsChunkSize, BOOL fWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if (hWav != NULL && (lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpcChunks != NULL)
		{
			if (hWav == NULL)
			{
				*lpcChunks = fWavOut ?
					cPlayChunksDefault : cRecordChunksDefault;
			}
			else
			{
				*lpcChunks = fWavOut ?
					lpWav->cPlayChunks : lpWav->cRecordChunks;
			}
		}

		if (lpmsChunkSize != NULL)
		{
			if (hWav == NULL)
			{
				*lpmsChunkSize = fWavOut ?
					msPlayChunkSizeDefault : msRecordChunkSizeDefault;
			}
			else
			{
				*lpmsChunkSize = fWavOut ?
					lpWav->msPlayChunkSize : lpWav->msRecordChunkSize;
			}
		}
	}

	return fSuccess ? 0 : -1;
}

// WavSetChunks - set chunk count and size
//		<hWav>				(i) handle returned from WavOpen
//			NULL				set default chunk count and size
//		<cChunks>			(i) number of chunks in device queue
//			-1					do not set chunk count
//		<msChunkSize>		(i) chunk size in milleseconds
//			-1					do not set chunk size
//		<fWavOut>			(i) TRUE for playback, FALSE for recording
// return 0 if success
//
int DLLEXPORT WINAPI WavSetChunks(HWAV hWav, int cChunks, long msChunkSize, BOOL fWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if (hWav != NULL && (lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (fWavOut && cChunks != -1 &&
		(cChunks < PLAYCHUNKCOUNT_MIN ||
		cChunks > PLAYCHUNKCOUNT_MAX))
		fSuccess = TraceFALSE(NULL);

	else if (fWavOut && msChunkSize != -1 &&
		(msChunkSize < PLAYCHUNKSIZE_MIN ||
		msChunkSize > PLAYCHUNKSIZE_MAX))
		fSuccess = TraceFALSE(NULL);

	else if (!fWavOut && cChunks != -1 &&
		(cChunks < RECORDCHUNKCOUNT_MIN ||
		cChunks > RECORDCHUNKCOUNT_MAX))
		fSuccess = TraceFALSE(NULL);

	else if (!fWavOut && msChunkSize != -1 &&
		(msChunkSize < RECORDCHUNKSIZE_MIN ||
		msChunkSize > RECORDCHUNKSIZE_MAX))
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (fWavOut && cChunks != -1)
		{
			if (hWav == NULL)
				cPlayChunksDefault = cChunks;
			else
				lpWav->cPlayChunks = cChunks;
		}
		
		if (fWavOut && msChunkSize != -1)
		{
			if (hWav == NULL)
				msPlayChunkSizeDefault = msChunkSize;
			else
				lpWav->msPlayChunkSize = msChunkSize;
		}

		if (!fWavOut && cChunks != -1)
		{
			if (hWav == NULL)
				cRecordChunksDefault = cChunks;
			else
				lpWav->cRecordChunks = cChunks;
		}
		
		if (!fWavOut && msChunkSize != -1)
		{
			if (hWav == NULL)
				msRecordChunkSizeDefault = msChunkSize;
			else
				lpWav->msRecordChunkSize = msChunkSize;
		}
	}

	return fSuccess ? 0 : -1;
}

// WavCalcChunkSize - calculate chunk size in bytes
//		<lpwfx>				(i) wav format
//		<msPlayChunkSize>	(i) chunk size in milleseconds
//			-1					default chunk size
//		<fWavOut>			(i) TRUE for playback, FALSE for recording
// return chunk size in bytes (-1 if success)
//
long DLLEXPORT WINAPI WavCalcChunkSize(LPWAVEFORMATEX lpwfx,
	long msChunkSize, BOOL fWavOut)
{
	BOOL fSuccess = TRUE;
	long cbChunkSize;

	if (msChunkSize == -1)
	{
		msChunkSize = fWavOut ?
			PLAYCHUNKSIZE_DEFAULT : RECORDCHUNKSIZE_DEFAULT;
	}

	if (!WavFormatIsValid(lpwfx) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (fWavOut &&
		(msChunkSize < PLAYCHUNKSIZE_MIN ||
		msChunkSize > PLAYCHUNKSIZE_MAX))
		fSuccess = TraceFALSE(NULL);

	else if (!fWavOut &&
		(msChunkSize < RECORDCHUNKSIZE_MIN ||
		msChunkSize > RECORDCHUNKSIZE_MAX))
		fSuccess = TraceFALSE(NULL);

#if 0 // this only works for PCM
	else
	{
		int nBytesPerSample;

		// calculate bytes per sample
		//
		nBytesPerSample = lpwfx->nChannels *
			(((lpwfx->wBitsPerSample - 1) / 8) + 1);

		// calculate chunk size in bytes
		//
		cbChunkSize = msChunkSize *
			lpwfx->nSamplesPerSec * nBytesPerSample / 1000L;

		// round up to nearest 1K bytes
		//
		cbChunkSize = 1024L * ((cbChunkSize + 1023L) / 1024L);
	}
#else
	else
	{
		long lBlockAlign;

		// calculate chunk size in bytes
		//
		cbChunkSize = msChunkSize * lpwfx->nAvgBytesPerSec / 1000L;

		// round up to nearest block boundary
		//
		if ((lBlockAlign = (long) lpwfx->nBlockAlign) > 0)
		{
			cbChunkSize = lBlockAlign *
				((cbChunkSize + lBlockAlign - 1) / lBlockAlign);
		}
	}
#endif

	return fSuccess ? cbChunkSize : -1;
}

// WavCopy - copy data from one open wav file to another
//		<hWavSrc>			(i) source handle returned from WavOpen
//		<hWavDst>			(i) destination handle returned from WavOpen
//		<hpBuf>				(o) pointer to copy buffer
//			NULL				allocate buffer internally
//		<sizBuf>			(i) size of copy buffer
//			-1					default buffer size (16K)
//		<lpfnUserAbort>		(i) function that returns TRUE if user aborts
//			NULL				don't check for user abort
//		<dwUser>			(i) parameter passed to <lpfnUserAbort>
//		<dwFlags>			(i) control flags
//			WAV_NOACM			do not use audio compression manager
// return 0 if success (-1 if error, +1 if user abort)
//
int DLLEXPORT WINAPI WavCopy(HWAV hWavSrc, HWAV hWavDst,
	void _huge *hpBuf, long sizBuf, USERABORTPROC lpfnUserAbort, DWORD dwUser, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWavSrc;
	LPWAV lpWavDst;
	LPWAVEFORMATEX lpwfxSrc;
	LPWAVEFORMATEX lpwfxDst;
	BOOL fFreeBuf = (BOOL) (hpBuf == NULL);
	BOOL fUserAbort = FALSE;

	// calc buffer size if none supplied
	//
	if (sizBuf <= 0)
		sizBuf = 16 * 1024;

	if ((lpWavSrc = WavGetPtr(hWavSrc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavDst = WavGetPtr(hWavDst)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get source file format
	//
	else if ((lpwfxSrc = WavGetFormat(hWavSrc, WAV_FORMATFILE)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get destination file format
	//
	else if ((lpwfxDst = WavGetFormat(hWavDst, WAV_FORMATFILE)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// allocate buffer if none supplied
	//
	else if (hpBuf == NULL && (hpBuf = MemAlloc(NULL, sizBuf, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// do simple copy if no conversion is required
	//
	else if (WavFormatCmp(lpwfxSrc, lpwfxDst) == 0)
	{
		long lBytesReadTotal = 0;
		long lBytesTotal = max(1, lpWavSrc->cbData - lpWavSrc->lDataPos);

		while (fSuccess)
		{
			long lBytesRead;
			long lBytesWritten;

			// check for user abort, notify of percent complete
			//
			if (lpfnUserAbort != NULL &&
				(*lpfnUserAbort)(dwUser, (int) (lBytesReadTotal / lBytesTotal)))
			{
				fUserAbort = TRUE;
				break;
			}

			// fill copy buffer
			//
			else if ((lBytesRead = WavRead(hWavSrc, hpBuf, sizBuf)) < 0)
				fSuccess = TraceFALSE(NULL);

			// keep running total
			//
			else if ((lBytesReadTotal += lBytesRead) < 0)
				fSuccess = TraceFALSE(NULL);

			// check for end of file
			//
			else if (lBytesRead == 0)
				break; // eof

			// write the buffer
			//
			else if ((lBytesWritten = WavWrite(hWavDst, hpBuf, lBytesRead)) < 0)
				fSuccess = TraceFALSE(NULL);
		}

		// notify of 100% complete
		//
		if (fSuccess && lpfnUserAbort != NULL)
			(*lpfnUserAbort)(dwUser, 100);
	}

	// different formats require conversion during copy
	//
	else
	{
		long lBytesReadTotal = 0;
		long lBytesTotal = max(1, lpWavSrc->cbData - lpWavSrc->lDataPos);
		HACM hAcm = NULL;
		long sizBufRead;
		void _huge *hpBufRead = NULL;

		// turn on WAV_NOACM flag if either file was opened with it
		//
		if ((lpWavSrc->dwFlags & WAV_NOACM) ||
			(lpWavDst->dwFlags & WAV_NOACM))
			dwFlags |= WAV_NOACM;

		// start acm engine
		//
		if ((hAcm = AcmInit(ACM_VERSION, lpWavSrc->hInst,
			(dwFlags & WAV_NOACM) ? ACM_NOACM : 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// start conversion engine
		//
		else if (AcmConvertInit(hAcm, lpwfxSrc, lpwfxDst, NULL, 0) != 0)
			fSuccess = TraceFALSE(NULL);

		// calc how many bytes required for read buffer
		//
		else if ((sizBufRead = AcmConvertGetSizeSrc(hAcm, sizBuf)) <= 0)
			fSuccess = TraceFALSE(NULL);
		
		// allocate read buffer
		//
		else if ((hpBufRead = (void _huge *) MemAlloc(NULL,
			sizBufRead, 0)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// do the conversion during the copy
		//
		else while (fSuccess)
		{
			long lBytesRead;
			long lBytesConverted;
			long lBytesWritten;

			// check for user abort, notify of percent complete
			//
			if (lpfnUserAbort != NULL &&
				(*lpfnUserAbort)(dwUser, (int) (lBytesReadTotal / lBytesTotal)))
			{
				fUserAbort = TRUE;
				break;
			}

			// fill read buffer
			//
			else if ((lBytesRead = WavRead(hWavSrc, hpBufRead, sizBufRead)) < 0)
				fSuccess = TraceFALSE(NULL);

			// keep running total
			//
			else if ((lBytesReadTotal += lBytesRead) < 0)
				fSuccess = TraceFALSE(NULL);

			// check for end of file
			//
			else if (lBytesRead == 0)
				break; // eof

			// convert the data
			//
			else if ((lBytesConverted = AcmConvert(hAcm,
				hpBufRead, lBytesRead, hpBuf, sizBuf, 0)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// write the buffer
			//
			else if ((lBytesWritten = WavWrite(hWavDst,
				hpBuf, lBytesConverted)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}

		// notify of 100% complete
		//
		if (fSuccess && lpfnUserAbort != NULL)
			(*lpfnUserAbort)(dwUser, 100);

		// clean up
		//

		if (hpBufRead != NULL &&
			(hpBufRead = MemFree(NULL, hpBufRead)) != NULL)
			fSuccess = TraceFALSE(NULL);

		// NOTE: AcmConvertTerm() is called from AcmTerm()
		//
		if (hAcm != NULL && AcmTerm(hAcm) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (hpBuf != NULL && fFreeBuf &&
		(hpBuf = MemFree(NULL, hpBuf)) != NULL)
		fSuccess = TraceFALSE(NULL);

	if (!fSuccess)
		return -1;
	else if (fUserAbort)
		return +1;
	else
		return 0;
}

#ifdef AVTSM
// WavReadFormatSpeed - read data from wav file, then format it for speed
//		<hWav>				(i) handle returned from WavOpen
//		<hpBufSpeed>		(o) buffer to contain bytes read
//		<sizBufSpeed>		(i) size of buffer in bytes
// return bytes formatted for speed in <hpBuf> (-1 if error)
//
// NOTE: this function reads a block of data, and then converts it
// from the file format to the speed format, unless those formats
// are identical.
//
long DLLEXPORT WINAPI WavReadFormatSpeed(HWAV hWav, void _huge *hpBufSpeed, long sizBufSpeed)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long sizBufPlay;
	void _huge *hpBufPlay = NULL;
	long lBytesPlay;
	long lBytesSpeed = 0;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// see if speed conversion required
	//
	else if (lpWav->nSpeedLevel == 100 ||
		(lpWav->dwFlagsSpeed & WAVSPEED_NOTSM))
	{
		// no, so just convert file format to play format
		//
		if ((lBytesSpeed = WavReadFormatPlay(hWav, hpBufSpeed, sizBufSpeed)) < 0)
			fSuccess = TraceFALSE(NULL);
	}

	// calc how many bytes required for play buffer
	//
	else if ((sizBufPlay = sizBufSpeed * (lpWav->nSpeedLevel - 2) / 100) <= 0)
		fSuccess = TraceFALSE(NULL);

	// round down to nearest block boundary
	//
	else if (lpWav->lpwfx[FORMATPLAY]->nBlockAlign > 0 &&
		(sizBufPlay = lpWav->lpwfx[FORMATPLAY]->nBlockAlign *
		(sizBufPlay / lpWav->lpwfx[FORMATPLAY]->nBlockAlign)) <= 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// allocate play buffer
	//
	else if ((hpBufPlay = (void _huge *) MemAlloc(NULL,
		sizBufPlay, 0)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// fill play buffer
	//
	else if ((lBytesPlay = WavReadFormatPlay(hWav, hpBufPlay, sizBufPlay)) < 0)
		fSuccess = TraceFALSE(NULL);

	// convert the data from playback format to speed format
	//
	else if (lBytesPlay > 0 &&
		(lBytesSpeed = TsmConvert(lpWav->hTsm,
		hpBufPlay, lBytesPlay, hpBufSpeed, sizBufSpeed, 0)) < 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (hpBufPlay != NULL &&
		(hpBufPlay = MemFree(NULL, hpBufPlay)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lBytesSpeed : -1;
}
#endif

// WavReadFormatPlay - read data from wav file, then format it for playback
//		<hWav>				(i) handle returned from WavOpen
//		<hpBufPlay>			(o) buffer to contain bytes read
//		<sizBufPlay>		(i) size of buffer in bytes
// return bytes formatted for playback in <hpBuf> (-1 if error)
//
// NOTE: this function reads a block of data, and then converts it
// from the file format to the playback format, unless those formats
// are identical.
//
long DLLEXPORT WINAPI WavReadFormatPlay(HWAV hWav, void _huge *hpBufPlay, long sizBufPlay)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long sizBufRead;
	void _huge *hpBufRead = NULL;
	long lBytesRead;
	long lBytesPlay = 0;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// see if format conversion required
	//
	else if (WavFormatCmp(lpWav->lpwfx[FORMATFILE],
		lpWav->lpwfx[FORMATPLAY]) == 0)
	{
		// no, so just read block directly into the play buffer
		//
		if ((lBytesPlay = WavRead(hWav, hpBufPlay, sizBufPlay)) < 0)
			fSuccess = TraceFALSE(NULL);
	}

	// calc how many bytes required for read buffer
	//
	else if ((sizBufRead = AcmConvertGetSizeSrc(lpWav->hAcm,
		sizBufPlay)) <= 0)
		fSuccess = TraceFALSE(NULL);
		
	// allocate read buffer
	//
	else if ((hpBufRead = (void _huge *) MemAlloc(NULL,
		sizBufRead, 0)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// fill read buffer
	//
	else if ((lBytesRead = WavRead(hWav, hpBufRead, sizBufRead)) < 0)
		fSuccess = TraceFALSE(NULL);

	// convert the data from file format to playback format
	//
	else if (lBytesRead > 0 &&
		(lBytesPlay = AcmConvert(lpWav->hAcm,
		hpBufRead, lBytesRead, hpBufPlay, sizBufPlay, 0)) < 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (hpBufRead != NULL &&
		(hpBufRead = MemFree(NULL, hpBufRead)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lBytesPlay : -1;
}

// WavWriteFormatRecord - write data to file after formatting it for file
//		<hWav>				(i) handle returned from WavOpen
//		<hpBufRecord>		(i) buffer containing bytes in record format
//		<sizBufRecord>		(i) size of buffer in bytes
// return bytes written (-1 if error)
//
// NOTE: this function converts a block of data from the record
// format to the file format (unless those formats are identical),
// and then writes the data to disk.
//
long DLLEXPORT WINAPI WavWriteFormatRecord(HWAV hWav, void _huge *hpBufRecord, long sizBufRecord)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long sizBufWrite;
	void _huge *hpBufWrite = NULL;
	long lBytesWrite;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// see if format conversion required
	//
	else if (WavFormatCmp(lpWav->lpwfx[FORMATRECORD],
		lpWav->lpwfx[FORMATFILE]) == 0)
	{
		// no, so just write record buffer directly to the file
		//
		if ((lBytesWrite = WavWrite(hWav, hpBufRecord, sizBufRecord)) < 0)
			fSuccess = TraceFALSE(NULL);
	}

	// calc how many bytes required for write buffer
	//
	else if ((sizBufWrite = AcmConvertGetSizeDst(lpWav->hAcm,
		sizBufRecord)) <= 0)
		fSuccess = TraceFALSE(NULL);

	// allocate write buffer
	//
	else if ((hpBufWrite = (void _huge *) MemAlloc(NULL,
		sizBufWrite, 0)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// convert the data from record format to file format
	//
	else if ((lBytesWrite = AcmConvert(lpWav->hAcm,
		hpBufRecord, sizBufRecord, hpBufWrite, sizBufWrite, 0)) < 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// write buffer to disk
	//
	else if ((lBytesWrite = WavWrite(hWav, hpBufWrite, lBytesWrite)) < 0)
		fSuccess = TraceFALSE(NULL);

	// clean up
	//
	if (hpBufWrite != NULL &&
		(hpBufWrite = MemFree(NULL, hpBufWrite)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lBytesWrite : -1;
}

// WavGetOutputDevice - get handle to open wav output device
//		<hWav>				(i) handle returned from WavOpen
// return handle to wav output device (NULL if device not open or error)
//
// NOTE: this function is useful only during playback (after calling
// WavPlay() and before calling WavStop()).  The returned device handle
// can then be used when calling the WavOut functions in wavout.h
//
HWAVOUT DLLEXPORT WINAPI WavGetOutputDevice(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWav->hWavOut : NULL;
}

// WavGetInputDevice - get handle to open wav input device
//		<hWav>				(i) handle returned from WavOpen
// return handle to wav input device (NULL if device not open or error)
//
// NOTE: this function is useful only during recording (after calling
// WavRecord() and before calling WavStop()).  The returned device handle
// can then be used when calling the WavIn functions in wavin.h
//
HWAVIN DLLEXPORT WINAPI WavGetInputDevice(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWav->hWavIn : NULL;
}

// WavPlaySound - play wav file
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<lpszFileName>		(i) name of file to play
//			NULL				stop playing current sound, if any
//		<lpwfx>				(i) wave format
//			NULL				use format from header or default
//		<lpIOProc>			(i) address of i/o procedure to use
//			NULL				use default i/o procedure
//		<lpadwInfo>			(i) data to pass to i/o procedure during open
//			NULL				no data to pass
//		<dwFlags>			(i) control flags
//			WAV_ASYNC			return when playback starts (default)
//			WAV_SYNC			return after playback completes
//			WAV_FILENAME		<lpszFileName> points to a filename
//			WAV_RESOURCE		<lpszFileName> points to a resource
//			WAV_MEMORY			<lpszFileName> points to memory block
//			WAV_NODEFAULT		if sound not found, do not play default
//			WAV_LOOP			loop sound until WavPlaySound called again
//			WAV_NOSTOP			if device already playing, don't stop it
//			WAV_NORIFF			file has no RIFF/WAV header
//			WAV_NOACM			do not use audio compression manager
//			WAV_OPENRETRY		if output device busy, retry for up to 2 sec
#ifdef MULTITHREAD
//			WAV_MULTITHREAD		support multiple threads (default)
//			WAV_SINGLETHREAD	do not support multiple threads
//			WAV_COINITIALIZE	call CoInitialize in all secondary threads
#endif
// return 0 if success
//
// NOTE: if WAV_NORIFF is specified in <dwFlags>, then the
// <lpwfx> parameter must be specified.  If <lpwfx> is NULL, the
// current default format is assumed.
// WavSetFormat() can be used to set or override the defaults.
//
// NOTE: if WAV_FILENAME is specified in <dwFlags>, then <lpszFileName>
// must point to a file name.
//
// NOTE: if WAV_RESOURCE is specified in <dwFlags>, then <lpszFileName>
// must point to a WAVE resource in the module specified by <hInst>.
// If the first character of the string is a pound sign (#), the remaining
// characters represent a decimal number that specifies the resource id.
//
// NOTE: if WAV_MEMORY is specified in <dwFlags>, then <lpszFileName>
// must be a pointer to a memory block containing a wav file image.
// The pointer must be obtained by calling MemAlloc().
//
// NOTE: if neither WAV_FILENAME, WAV_RESOURCE, or WAV_MEMORY is specified
// in <dwFlags>, the [sounds] section of win.ini or the registry is
// searched for an entry matching <lpszFileName>.  If no matching entry
// is found, <lpszFileName> is assumed to be a file name.
//
// NOTE: if WAV_NODEFAULT is specified in <dwFlags>, no default sound
// will be played.  Unless this flag is specified, the default system
// event sound entry will be played if the sound specified in
// <lpszFileName> is not found.
//
// NOTE: if WAV_LOOP is specified in <dwFlags>, the sound specified in
// <lpszFileName> will be played repeatedly, until WavPlaySound() is
// called again.  The WAV_ASYNC flag must be specified when using this flag.
//
// NOTE: if WAV_NOSTOP is specified in <dwFlags>, and the device specified
// by <idDev> is already in use, this function returns without playing.
// Unless this flag is specified, the specified device will be stopped
// so that the new sound can be played.
//
// NOTE: if <lpIOProc> is not NULL, this i/o procedure will be called
// for opening, closing, reading, writing, and seeking the wav file.
// If <lpadwInfo> is not NULL, this array of three (3) DWORDs will be
// passed to the i/o procedure when the wav file is opened.
// See the Windows mmioOpen() and mmioInstallIOProc() function for details
// on these parameters.  Also, the WAV_MEMORY and WAV_RESOURCE flags may
// only be used when <lpIOProc> is NULL.
//
int DLLEXPORT WINAPI WavPlaySound(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPCTSTR lpszFileName, LPWAVEFORMATEX lpwfx,
	LPMMIOPROC lpIOProc, DWORD FAR *lpadwInfo, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	HWAV hWav = NULL;
	LPCTSTR lpszSound = lpszFileName;
	TCHAR szSound[_MAX_PATH];

	// stop current sound if necessary
	//
	if (lpszFileName == NULL && WavStopOutputDevice(idDev, dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);

	if (lpszSound != NULL)
	{
		// search win.ini or registry if necessary
		//
		if (!(dwFlags & WAV_FILENAME) &&
			!(dwFlags & WAV_RESOURCE) &&
			!(dwFlags & WAV_MEMORY))
		{
			if (GetProfileString(TEXT("Sounds"), lpszFileName, TEXT(""),
				szSound, SIZEOFARRAY(szSound)) > 0)
			{
				LPTSTR lpszComma;

				// ignore text description starting with comma
				//
				if ((lpszComma = StrChr(szSound, ',')) != NULL)
					*lpszComma = '\0';

				if (*szSound != '\0')
					lpszSound = szSound;
			}
		}

		// open sound
		//
		if ((hWav = WavOpen(WAV_VERSION, hInst, lpszSound, lpwfx,
			lpIOProc, lpadwInfo, dwFlags | WAV_READ)) == NULL)
		{
			// play default sound unless WAV_NODEFAULT flag set
			//
			if (!(dwFlags & WAV_NODEFAULT))
			{
				// find system default sound
				//
				if (GetProfileString(TEXT("Sounds"), TEXT("SystemDefault"), TEXT(""),
					szSound, SIZEOFARRAY(szSound)) > 0)
				{
					LPTSTR lpszComma;

					// ignore text description starting with comma
					//
					if ((lpszComma = StrChr(szSound, ',')) != NULL)
						*lpszComma = '\0';

					// open system default sound
					//
					if (*szSound != '\0' &&
						(hWav = WavOpen(WAV_VERSION, hInst, szSound,
						NULL, NULL, NULL, WAV_READ)) == NULL)
						fSuccess = TraceFALSE(NULL);
				}
			}
		}

		// play the sound
		//
		if (fSuccess && hWav != NULL)
		{
			if (dwFlags & WAV_ASYNC)
				dwFlags |= WAV_PLAYASYNC;
			if (dwFlags & WAV_SYNC)
				dwFlags |= WAV_PLAYSYNC;

			if (WavPlay(hWav, idDev, dwFlags | WAV_AUTOCLOSE) != 0)
				fSuccess = TraceFALSE(NULL);
		}

		// clean up
		//
		if (!fSuccess && hWav != NULL && WavClose(hWav) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavSendMessage - send a user-defined message to the i/o procedure
//		<hWav>				(i) handle returned from WavOpen
//		<wMsg>				(i) user-defined message id
//		<lParam1>			(i) parameter for the message
//		<lParam2>			(i) parameter for the message
// return value from the i/o procedure (0 if error or unrecognized message)
//
LRESULT DLLEXPORT WINAPI WavSendMessage(HWAV hWav,
	UINT wMsg, LPARAM lParam1, LPARAM lParam2)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	LRESULT lResult;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpWav->hmmio == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lResult = mmioSendMessage(lpWav->hmmio, wMsg, lParam1, lParam2);

	return fSuccess ? lResult : 0;
}

#ifdef TELTHUNK
// WavOpenEx - open an audio file, extra special version
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpszFileName>		(i) name of file to open
//		<dwReserved>		(i) reserved; must be zero
//		<dwFlagsOpen>		(i) control flags to pass to WavOpen
//		<dwFlagsEx>			(i) control flags
//			WOX_LOCAL			file is on local client
//			WOX_REMOTE			file is on remote server
//			WOX_WAVFMT			file is in Microsoft RIFF/WAV format
//			WOX_VOXFMT			file is in Dialogic OKI ADPCM (vox) format
//			WOX_WAVDEV			file will be played on wav output device
//			WOX_TELDEV			file will be played on telephone device
// return handle (NULL if error)
//
HWAV DLLEXPORT WINAPI WavOpenEx(DWORD dwVersion, HINSTANCE hInst,
	LPTSTR lpszFileName, DWORD dwReserved, DWORD dwFlagsOpen, DWORD dwFlagsEx)
{
	BOOL fSuccess = TRUE;
	HWAV hWav = NULL;

	if ((dwFlagsEx & WOX_TELDEV) || (dwFlagsEx & WOX_REMOTE))
	{
	 	hWav = TelWavOpenEx(TELWAV_VERSION, hInst,
			lpszFileName, 0, dwFlagsOpen, dwFlagsEx);
	}
	else
	{
		WAVEFORMATEX wfx;
		LPWAVEFORMATEX lpwfx = NULL;

		if (dwFlagsEx & WOX_VOXFMT)
		{
			dwFlagsOpen |= WAV_NORIFF;
			lpwfx = VoxFormat(&wfx, -1);
		}

		hWav = WavOpen(WAV_VERSION, hInst,
			lpszFileName, lpwfx, NULL, 0, dwFlagsOpen);
	}

	return fSuccess ? hWav : NULL;
}
#endif

////
//	helper functions
////

// WavStopPlay - stop playing
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
static int WavStopPlay(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lpWav->dwState |= WAVSTATE_AUTOSTOP;

	// close output device if necessary
	//
	if (fSuccess &&
		!(lpWav->dwState & WAVSTATE_STOPPLAY) &&
		lpWav->hWavOut != NULL)
	{
		long msPositionPlay = 0L;

		// set a state flag so we never execute this code recursively
		//
		lpWav->dwState |= WAVSTATE_STOPPLAY;

		// get current playback position
		//
		if ((msPositionPlay = WavOutGetPosition(lpWav->hWavOut)) == -1)
		{
			// let's ignore errors here and assume play position is 0;
			//
			msPositionPlay = 0L;
			fSuccess = TraceTRUE(NULL);
		}

		else
		{
			// if necessary, adjust position to compensate for non-standard speed
			//
			if (lpWav->nSpeedLevel != 100 && (
#ifdef AVTSM
				!(lpWav->dwFlagsSpeed & WAVSPEED_NOTSM) ||
#endif
				!(lpWav->dwFlagsSpeed & WAVSPEED_NOFORMATADJUST)))
			{
				msPositionPlay = msPositionPlay * lpWav->nSpeedLevel / 100;
			}
		}
#if 1
		TracePrintf_2(NULL, 6,
			TEXT("lpWav->msPositionStop=%ld, msPositionPlay=%ld\n"),
			(long) lpWav->msPositionStop,
			(long) msPositionPlay);
#endif
		// clear wav handle array entry
		//
		if (fSuccess)
		{
			int idDev;

			if ((idDev = WavOutGetId(lpWav->hWavOut)) < HWAVOUT_MIN ||
				idDev >= HWAVOUT_MAX)
				fSuccess = TraceFALSE(NULL);

			else
				ahWavOutCurr[idDev + HWAVOUT_OFFSET] = NULL;
		}

		// close output device
		//
		if (WavOutClose(lpWav->hWavOut, 0) != 0)
			fSuccess = TraceFALSE(NULL);

		else if ((lpWav->hWavOut = NULL), FALSE)
			fSuccess = TraceFALSE(NULL);

		// destroy the notification callback window
		//
		else if (WavNotifyDestroy(lpWav) != 0)
			fSuccess = TraceFALSE(NULL);

		// move read/write pointer (back) to new stop position
		//
		else if (WavSetPosition(hWav, min(WavGetLength(hWav),
			lpWav->msPositionStop + msPositionPlay)) == -1)
			fSuccess = TraceFALSE(NULL);

		// close acm conversion engine
		//
		else if (AcmConvertTerm(lpWav->hAcm) != 0)
			fSuccess = TraceFALSE(NULL);

		// notify user that play is stopped if necessary
		//
		if (lpWav->lpfnPlayStopped != NULL)
		{
			(*lpWav->lpfnPlayStopped)(hWav, lpWav->hUserPlayStopped, 0);
			lpWav->lpfnPlayStopped = NULL;
			lpWav->hUserPlayStopped = NULL;
		}

		// clear state flags
		//
		lpWav->dwState &= ~WAVSTATE_STOPPLAY;

		// close wav file if specified
		//
		if (lpWav->dwState & WAVSTATE_AUTOCLOSE)
		{
			lpWav->dwState &= ~WAVSTATE_AUTOCLOSE;

			if (WavClose(hWav) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				hWav = NULL; // handle no longer valid
		}
	}

#ifdef AVTSM
	// shut down time scale modification engine if necessary
	//
	if (fSuccess && lpWav->hTsm != NULL)
	{
		if (TsmTerm(lpWav->hTsm) != 0)
			fSuccess = TraceFALSE(NULL);
		else
			lpWav->hTsm = NULL;
	}
#endif

	return fSuccess ? 0 : -1;
}

// WavStopRecord - stop recording
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
static int WavStopRecord(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lpWav->dwState |= WAVSTATE_AUTOSTOP;

	// close input device if necessary
	//
	if (fSuccess &&
		!(lpWav->dwState & WAVSTATE_STOPRECORD) &&
		lpWav->hWavIn != NULL)
	{
		long msPositionRecord = 0L;

		// set a state flag so we never execute this code recursively
		//
		lpWav->dwState |= WAVSTATE_STOPRECORD;

		// get current record position
		//
		if ((msPositionRecord = WavInGetPosition(lpWav->hWavIn)) == -1)
		{
			// let's ignore errors here and assume record position is 0;
			//
			msPositionRecord = 0L;
			fSuccess = TraceTRUE(NULL);
		}
#if 1
		TracePrintf_2(NULL, 6,
			TEXT("lpWav->msPositionStop=%ld, msPositionRecord=%ld\n"),
			(long) lpWav->msPositionStop,
			(long) msPositionRecord);
#endif
		// clear wav handle array entry
		//
		if (fSuccess)
		{
			int idDev;

			if ((idDev = WavInGetId(lpWav->hWavIn)) < HWAVIN_MIN ||
				idDev >= HWAVIN_MAX)
				TraceFALSE(NULL);

			else
				ahWavInCurr[idDev + HWAVIN_OFFSET] = NULL;
		}

		// close input device
		//
		if (WavInClose(lpWav->hWavIn, 0) != 0)
			fSuccess = TraceFALSE(NULL);

		else if ((lpWav->hWavIn = NULL), FALSE)
			fSuccess = TraceFALSE(NULL);

		// destroy the notification callback window
		//
		else if (WavNotifyDestroy(lpWav) != 0)
			fSuccess = TraceFALSE(NULL);

		// move read/write pointer to new stop position
		//
		else if (WavSetPosition(hWav, min(WavGetLength(hWav),
			lpWav->msPositionStop + msPositionRecord)) == -1)
			fSuccess = TraceFALSE(NULL);

		// close acm conversion engine
		//
		else if (AcmConvertTerm(lpWav->hAcm) != 0)
			fSuccess = TraceFALSE(NULL);

		// truncate file if max file size exceeded
		//
		else if (lpWav->msMaxSize > 0 &&
			WavGetLength(hWav) > lpWav->msMaxSize &&
			WavSetLength(hWav, lpWav->msMaxSize) < 0)
			fSuccess = TraceFALSE(NULL);

		// clear state flags
		//
		lpWav->dwState &= ~WAVSTATE_STOPRECORD;

		// notify user that record is stopped if necessary
		//
		if (lpWav->lpfnRecordStopped != NULL)
		{
			(*lpWav->lpfnRecordStopped)(hWav, lpWav->dwUserRecordStopped, 0);
			lpWav->lpfnRecordStopped = NULL;
			lpWav->dwUserRecordStopped = 0;
		}

		// close wav file if specified
		//
		if (lpWav->dwState & WAVSTATE_AUTOCLOSE)
		{
			lpWav->dwState &= ~WAVSTATE_AUTOCLOSE;

			if (WavClose(hWav) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				hWav = NULL; // handle no longer valid
		}
	}

	return fSuccess ? 0 : -1;
}

// WavStopOutputDevice - stop specified output device
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<dwFlags>			(i) control flags
//			WAV_NOSTOP			if device already playing, don't stop it
// return 0 if success
//
static int WavStopOutputDevice(int idDev, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	// stop output device (unless WAV_NOSTOP flag set or device not open)
	//
	if (!(dwFlags & WAV_NOSTOP) && WavOutDeviceIsOpen(idDev))
	{
		HWAV hWavCurr;

		// stop device using WavStopPlay if WavPlay was used
		//
		if ((hWavCurr = WavGetOutputHandle(idDev)) != NULL &&
			WavStopPlay(hWavCurr) != 0)
			fSuccess = TraceFALSE(NULL);
		
		// otherwise stop device using sndPlaySound
		//
		else if (!sndPlaySound(NULL, 0))
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavStopInputDevice - stop specified input device
//		<idDev>				(i) wav input device id
//			-1					use any suitable input device
//		<dwFlags>			(i) control flags
//			WAV_NOSTOP			if device already recording, don't stop it
// return 0 if success
//
static int WavStopInputDevice(int idDev, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	// stop input device (unless WAV_NOSTOP flag set or device not open)
	//
	if (!(dwFlags & WAV_NOSTOP) && WavInDeviceIsOpen(idDev))
	{
		HWAV hWavCurr;

		// stop device using WavStopRecord if WavRecord was used
		//
		if ((hWavCurr = WavGetInputHandle(idDev)) != NULL &&
			WavStopRecord(hWavCurr) != 0)
			fSuccess = TraceFALSE(NULL);
		
		// otherwise stop device using sndPlaySound
		//
		else if (!sndPlaySound(NULL, 0))
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavGetOutputHandle - get wav handle being played on specified device 
//		<idDev>				(i) wav output device id
// return wav handle (NULL if error or if output device not in use)
//
static HWAV WavGetOutputHandle(int idDev)
{
	BOOL fSuccess = TRUE;
	HWAV hWav;

	if (idDev < HWAVOUT_MIN || idDev >= HWAVOUT_MAX)
		fSuccess = TraceFALSE(NULL);

	else
		hWav = ahWavOutCurr[idDev + HWAVOUT_OFFSET];

	return fSuccess ? hWav : NULL;
}

// WavGetInputHandle - get wav handle being recorded on specified device 
//		<idDev>				(i) wav input device id
// return wav handle (NULL if error or if input device not in use)
//
static HWAV WavGetInputHandle(int idDev)
{
	BOOL fSuccess = TRUE;
	HWAV hWav;

	if (idDev < HWAVIN_MIN || idDev >= HWAVIN_MAX)
		fSuccess = TraceFALSE(NULL);

	else
		hWav = ahWavInCurr[idDev + HWAVIN_OFFSET];

	return fSuccess ? hWav : NULL;
}

// WavPlayNextChunk - fill next chunk and submit it to the output device
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
static int WavPlayNextChunk(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	LPVOID lpBuf = NULL;
	long sizBuf;
	long lBytesRead = 0;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// calculate the size of output chunk
	//

    //
    // we have to verify if lpWav is a valid pointer
    //

    else if ((sizBuf = WavCalcChunkSize(lpWav->lpwfx[FORMATPLAY],
		lpWav->msPlayChunkSize, TRUE)) <= 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

#ifdef TELOUT // $FIXUP - need to work on this
	// special case - if we are using the telephone to play audio
	// from a file that already resides on the server, just pass
	// the file handle to TelOutPlay rather than a buffer
	//
	else if (WavOutGetId(lpWav->hWavOut) == TELOUT_DEVICEID &&
		(lpWav->dwFlags & WAV_TELRFILE))
	{
		long hrfile;
		long lSize;
		long lPos;
		
		// retrieve handle to remote file from i/o procedure
		//
		if ((hrfile = (long)
			WavSendMessage(hWav, MMIOM_GETINFO, 0, 0)) == (long) -1)
			fSuccess = TraceFALSE(NULL);

		// retrieve size of remote file from i/o procedure
		//
		else if ((lSize = (long)
			WavSendMessage(hWav, MMIOM_GETINFO, 1, 0)) == (long) -1)
			fSuccess = TraceFALSE(NULL);

		// get current file position
		//
		else if ((lPos = mmioSeek(lpWav->hmmio, 0, SEEK_CUR)) == -1)
			fSuccess = TraceFALSE(NULL);

		// force the remote file pointer to be at that position
		//
		else if (WavOutGetState(lpWav->hWavOut) == WAVOUT_STOPPED)
		{
			long lPosActual;
			
			if ((lPosActual = mmioSendMessage(lpWav->hmmio,
				MMIOM_SEEK, lPos, SEEK_SET)) != lPos)
			{
				fSuccess = TraceTRUE(NULL); // not an error
			}
		}

		// loop until we read some data or we know we are finished
		//
		while (fSuccess && lBytesRead == 0)
		{
			// calculate how many bytes would be read
			//
			lBytesRead = max(0, min(sizBuf, lSize - lPos));

			TracePrintf_4(NULL, 5,
				TEXT("lBytesRead(%ld) = max(0, min(sizBuf(%ld), lSize(%ld) - lPos(%ld)));\n"),
				(long) lBytesRead,
				(long) sizBuf,
				(long) lSize,
				(long) lPos);

			// advance the file position, skipping over the (virtual) chunk
			//
			if (lBytesRead > 0 &&
				mmioSeek(lpWav->hmmio, lBytesRead, SEEK_CUR) == -1)
				fSuccess = TraceFALSE(NULL);

			// submit the (virtual) chunk to the output device for playback
			//
			else if (lBytesRead > 0 &&
				TelOutPlay((HTELOUT) lpWav->hWavOut,
				lpBuf, lBytesRead, hrfile) != 0)
				fSuccess = TraceFALSE(NULL);

			// if no more wav data to play,
			//
			else if (lBytesRead == 0)
			{
				// if WAV_AUTOSTOP flag set, we are finished
				//
				if (lpWav->dwState & WAVSTATE_AUTOSTOP)
				{
					// if output device is idle, then close output device
					//
					if (lpWav->hWavOut != NULL &&
						WavOutGetState(lpWav->hWavOut) == WAVOUT_STOPPED &&
						WavStopPlay(hWav) != 0)
					{
						fSuccess = TraceFALSE(NULL);
					}

					break;
				}

				// if not finished, yield and then try to read again
				//
				else
				{
					MSG msg;

					if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
					{
		 				TranslateMessage(&msg);
		 				DispatchMessage(&msg);
					}
					else
						WaitMessage();
				}
			}
		}

		return fSuccess ? 0 : -1;
	}
#endif

	else if ((lpBuf = (LPVOID) MemAlloc(NULL, sizBuf, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// loop until we read some data or we know we are finished
	//
	while (fSuccess && lBytesRead == 0)
	{
		// fill chunk with wav data
		//
#ifdef AVTSM
		if ((lBytesRead = WavReadFormatSpeed(hWav, lpBuf, sizBuf)) < 0)
#else
		if ((lBytesRead = WavReadFormatPlay(hWav, lpBuf, sizBuf)) < 0)
#endif
			fSuccess = TraceFALSE(NULL);

		// submit the chunk to the output device for playback
		//
		else if (lBytesRead > 0 &&
			WavOutPlay(lpWav->hWavOut, lpBuf, lBytesRead) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// if no more wav data to play,
		//
		else if (lBytesRead == 0)
		{
			// if WAV_AUTOSTOP flag set, we are finished
			//
			if (lpWav->dwState & WAVSTATE_AUTOSTOP)
			{
				// if output device is idle, then close output device
				//
				if (lpWav->hWavOut != NULL &&
					WavOutGetState(lpWav->hWavOut) == WAVOUT_STOPPED &&
					WavStopPlay(hWav) != 0)
				{
					fSuccess = TraceFALSE(NULL);
				}

				break;
			}

			// if not finished, yield and then try to read again
			//
			else
			{
				MSG msg;

				if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
				{
		 			TranslateMessage(&msg);
		 			DispatchMessage(&msg);
				}
				else
					WaitMessage();
			}
		}
	}
	
	// free buffer if it was not sent to output device
	//
	if (!fSuccess || lBytesRead == 0)
	{
		if (lpBuf != NULL && (lpBuf = MemFree(NULL, lpBuf)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavRecordNextChunk - submit next chunk to the input device
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
static int WavRecordNextChunk(HWAV hWav)
{
	BOOL fSuccess = TRUE;
    //
    // We have to initialize local variable
    //
	LPWAV lpWav = NULL;
	LPVOID lpBuf = NULL;
	long sizBuf;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);
    else
    {
        //
        // we should make sure lpWas is not NULL
        //

	// calculate the size of input chunk
	//
	if ((sizBuf = WavCalcChunkSize(lpWav->lpwfx[FORMATRECORD],
		lpWav->msRecordChunkSize, FALSE)) <= 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

#ifdef TELOUT // $FIXUP - need to work on this
	// special case - if we are using the telephone to record audio
	// to a file that already resides on the server, just pass
	// the file handle to TelOutRecord rather than a buffer
	//
	else if (WavInGetId(lpWav->hWavIn) == TELIN_DEVICEID &&
		(lpWav->dwFlags & WAV_TELRFILE))
	{
		long hrfile;
		
		// retrieve handle to remote file from i/o procedure
		//
		if ((hrfile = (long)
			WavSendMessage(hWav, MMIOM_GETINFO, 0, 0)) == (long) -1)
			fSuccess = TraceFALSE(NULL);

		// submit the (virtual) chunk to the output device for playback
		//
		else if (TelInRecord((HTELIN) lpWav->hWavIn,
			lpBuf, sizBuf, hrfile) != 0)
			fSuccess = TraceFALSE(NULL);

		return fSuccess ? 0 : -1;
	}
#endif

	else if ((lpBuf = (LPVOID) MemAlloc(NULL, sizBuf, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// submit the chunk to the input device for recording
	//
	else if (WavInRecord(lpWav->hWavIn, lpBuf, sizBuf) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

    }

	// free buffer if it was not sent to input device
	//
	if (!fSuccess)
	{
		if (lpBuf != NULL && (lpBuf = MemFree(NULL, lpBuf)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

static int WavNotifyCreate(LPWAV lpWav)
{
	BOOL fSuccess = TRUE;
	WNDCLASS wc;

#ifdef MULTITHREAD
	// handle WAV_MULTITHREAD flag
	//
	if (fSuccess && (lpWav->dwFlags & WAV_MULTITHREAD))
	{
		DWORD dwRet;

		// we need to know when callback thread begins execution
		//
		if ((lpWav->hEventThreadCallbackStarted = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// create the callback thread
		//
		else if ((lpWav->hThreadCallback = CreateThread(
			NULL,
			0,
			WavCallbackThread,
			(LPVOID) lpWav,
			0,
			&lpWav->dwThreadId)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// wait for the callback thread to begin execution
		//
		else if ((dwRet = WaitForSingleObject(
			lpWav->hEventThreadCallbackStarted, 10000)) != WAIT_OBJECT_0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// clean up
		//
		if (lpWav->hEventThreadCallbackStarted != NULL)
		{
			if (!CloseHandle(lpWav->hEventThreadCallbackStarted))
				fSuccess = TraceFALSE(NULL);
			else
				lpWav->hEventThreadCallbackStarted = NULL;
		}
	}
	else
#endif
	{
		// register notify class unless it has been already
		//
		if (GetClassInfo(lpWav->hInst, WAVCLASS, &wc) == 0)
		{
			wc.hCursor =		NULL;
			wc.hIcon =			NULL;
			wc.lpszMenuName =	NULL;
			wc.hInstance =		lpWav->hInst;
			wc.lpszClassName =	WAVCLASS;
			wc.hbrBackground =	NULL;
			wc.lpfnWndProc =	WavNotify;
			wc.style =			0L;
			wc.cbWndExtra =		sizeof(lpWav);
			wc.cbClsExtra =		0;

			if (!RegisterClass(&wc))
				fSuccess = TraceFALSE(NULL);
		}

		// create the notify window
		//
		if (fSuccess && lpWav->hwndNotify == NULL &&
			(lpWav->hwndNotify = CreateWindowEx(
			0L,
			WAVCLASS,
			NULL,
			0L,
			0, 0, 0, 0,
			NULL,
			NULL,
			lpWav->hInst,
			lpWav)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}

	return fSuccess ? 0 : -1;
}

static int WavNotifyDestroy(LPWAV lpWav)
{
	BOOL fSuccess = TRUE;

	// destroy notify window
	//
	if (lpWav->hwndNotify != NULL &&
		!DestroyWindow(lpWav->hwndNotify))
	{	
		fSuccess = TraceFALSE(NULL);
	}

	else
		lpWav->hwndNotify = NULL;

#ifdef MULTITHREAD
	if (lpWav->hThreadCallback != NULL)
	{
		if (!CloseHandle(lpWav->hThreadCallback))
			fSuccess = TraceFALSE(NULL);
		else
			lpWav->hThreadCallback = NULL;
	}
#endif

	return fSuccess ? 0 : -1;
}

#ifdef MULTITHREAD
DWORD WINAPI WavCallbackThread(LPVOID lpvThreadParameter)
{
	BOOL fSuccess = TRUE;
	MSG msg;
	LPWAV lpWav = (LPWAV) lpvThreadParameter;

	// initialize COM
	//
	if (lpWav->dwFlags & WAV_COINITIALIZE)
	{
		if ((lpWav->hrCoInitialize = CoInitialize(NULL)) != S_OK &&
			lpWav->hrCoInitialize != S_FALSE)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("CoInitialize failed (%08X)\n"),
				(unsigned long) lpWav->hrCoInitialize);
		}
	}

	// make sure message queue is created before calling SetEvent
	//
	PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

	// notify main thread that callback thread has begun execution
	//
	if (!SetEvent(lpWav->hEventThreadCallbackStarted))
	{
		fSuccess = TraceFALSE(NULL);
	}

	while (fSuccess && GetMessage(&msg, NULL, 0, 0))
	{
		WavNotify((HWND) lpWav, msg.message, msg.wParam, msg.lParam);

		// exit thread when when have processed last expected message
		//
		if (msg.message == WM_WAVOUT_CLOSE || msg.message == WM_WAVIN_CLOSE)
		{
			// notify main thread that we are terminating
			//
			if (lpWav->hEventStopped != NULL &&
				!SetEvent(lpWav->hEventStopped))
			{
				fSuccess = TraceFALSE(NULL);
			}

			break;
		}
	}

	// uninitialize COM
	//
	if (lpWav->dwFlags & WAV_COINITIALIZE)
	{
		if (lpWav->hrCoInitialize == S_OK || lpWav->hrCoInitialize == S_FALSE)
		{
			CoUninitialize();
			lpWav->hrCoInitialize = E_UNEXPECTED;
		}
	}

	return 0;
}
#endif

// WavNotify - window procedure for wav notify
//
LRESULT DLLEXPORT CALLBACK WavNotify(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult;
	LPWAV lpWav;
	
#ifdef MULTITHREAD
	if (!IsWindow(hwnd))
		lpWav = (LPWAV) hwnd;
	else
#endif
	// retrieve lpWav from window extra bytes
	//
	lpWav = (LPWAV) GetWindowLongPtr(hwnd, 0);

	switch (msg)
	{
		case WM_NCCREATE:
		{
			LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
			LPWAV lpWav = (LPWAV) lpcs->lpCreateParams;

			// store lpWav in window extra bytes
			//
			SetWindowLongPtr(hwnd, 0, (LONG_PTR) lpWav);

			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
		}
			break;

		case WM_WAVOUT_OPEN:
		{
		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVOUT_OPEN\n"));

			lResult = 0L;

#ifdef MULTITHREAD
			if ((HANDLE) wParam != NULL)
				SetEventMessageProcessed(lpWav, (HANDLE) wParam);
#endif
		}
			break;

		case WM_WAVOUT_CLOSE:
		{
		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVOUT_CLOSE\n"));

			// handle no longer valid
			//
			lpWav->hWavOut = NULL;

			lResult = 0L;

#ifdef MULTITHREAD
			if ((HANDLE) wParam != NULL)
				SetEventMessageProcessed(lpWav, (HANDLE) wParam);
#endif
		}
			break;

		case WM_WAVOUT_PLAYDONE:
		{
			LPPLAYDONE lpplaydone = (LPPLAYDONE) lParam;

		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVOUT_PLAYDONE\n"));

			if (lpplaydone == NULL)
				fSuccess = TraceFALSE(NULL);

			else if (lpplaydone->lpBuf != NULL &&
				(lpplaydone->lpBuf = MemFree(NULL, lpplaydone->lpBuf)) != NULL)
				fSuccess = TraceFALSE(NULL);

			else switch (WavOutGetState(lpWav->hWavOut))
			{
				case WAVOUT_STOPPED:
					// make sure to close output device when play complete
					//
					if (lpWav->dwState & WAVSTATE_AUTOSTOP)
					{
#ifdef MULTITHREAD
						if (lpWav->dwFlags & WAV_MULTITHREAD)
							PostThreadMessage(lpWav->dwThreadId, WM_WAVOUT_STOPPLAY, 0, 0);
						else
#endif
							PostMessage(lpWav->hwndNotify, WM_WAVOUT_STOPPLAY, 0, 0);
						break;
					}
					// else fall through

				case WAVOUT_PLAYING:
					// load output device queue with next chunk to play
					//
					if (WavPlayNextChunk(WavGetHandle(lpWav)) != 0)
						fSuccess = TraceFALSE(NULL);
					break;

				default:
					break;
			}

			lResult = 0L;

#ifdef MULTITHREAD
			if ((HANDLE) wParam != NULL)
				SetEventMessageProcessed(lpWav, (HANDLE) wParam);
#endif
		}
			break;

		case WM_WAVOUT_STOPPLAY:
		{
		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVOUT_STOPPLAY\n"));

			if (WavStopPlay(WavGetHandle(lpWav)) != 0)
				fSuccess = TraceFALSE(NULL);

			lResult = 0L;
		}
			break;

		case WM_WAVIN_OPEN:
		{
		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVIN_OPEN\n"));

			lResult = 0L;

#ifdef MULTITHREAD
			if ((HANDLE) wParam != NULL)
				SetEventMessageProcessed(lpWav, (HANDLE) wParam);
#endif
		}
			break;

		case WM_WAVIN_CLOSE:
		{
		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVIN_CLOSE\n"));

			// handle no longer valid
			//
			lpWav->hWavIn = NULL;

			lResult = 0L;

#ifdef MULTITHREAD
			if ((HANDLE) wParam != NULL)
				SetEventMessageProcessed(lpWav, (HANDLE) wParam);
#endif
		}
			break;

		case WM_WAVIN_RECORDDONE:
		{
			LPRECORDDONE lprecorddone = (LPRECORDDONE) lParam;
			long lBytesWritten;

		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVIN_RECORDDONE\n"));

			if (lprecorddone == NULL)
				fSuccess = TraceFALSE(NULL);

			// write wav data from chunk to file
			//
			else if (lprecorddone->lpBuf != NULL &&
				lprecorddone->lBytesRecorded > 0 &&
				(lBytesWritten = WavWriteFormatRecord(WavGetHandle(lpWav),
				lprecorddone->lpBuf, lprecorddone->lBytesRecorded)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// free the record buffer, allocated in WavRecordNextChunk()
			//

            //
            // we have to verify if lprecorddone is a valid pointer
            //

			if (lprecorddone != NULL && lprecorddone->lpBuf != NULL &&
				(lprecorddone->lpBuf = MemFree(NULL,
				lprecorddone->lpBuf)) != NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// stop recording if max size exceeded
			//
			else if (lpWav->msMaxSize > 0 &&
				WavGetLength(WavGetHandle(lpWav)) > lpWav->msMaxSize)
			{
#ifdef MULTITHREAD
				if (lpWav->dwFlags & WAV_MULTITHREAD)
					PostThreadMessage(lpWav->dwThreadId, WM_WAVIN_STOPRECORD, 0, 0);
				else
#endif
					PostMessage(lpWav->hwndNotify, WM_WAVIN_STOPRECORD, 0, 0);
			}

			else switch (WavInGetState(lpWav->hWavIn))
			{
				case WAVIN_STOPPED:
					// make sure to close input device when record complete
					//
					if (lpWav->dwState & WAVSTATE_AUTOSTOP)
					{
#ifdef MULTITHREAD
						if (lpWav->dwFlags & WAV_MULTITHREAD)
							PostThreadMessage(lpWav->dwThreadId, WM_WAVIN_STOPRECORD, 0, 0);
						else
#endif
							PostMessage(lpWav->hwndNotify, WM_WAVIN_STOPRECORD, 0, 0);
						break;
					}
					// else fall through

				case WAVIN_RECORDING:
					// load input device queue with next chunk to record
					//
					if (WavRecordNextChunk(WavGetHandle(lpWav)) != 0)
						fSuccess = TraceFALSE(NULL);
					break;

				default:
					break;
			}

			lResult = 0L;

#ifdef MULTITHREAD
			if ((HANDLE) wParam != NULL)
				SetEventMessageProcessed(lpWav, (HANDLE) wParam);
#endif
		}
			break;

		case WM_WAVIN_STOPRECORD:
		{
		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVIN_STOPRECORD\n"));

			if (WavStopRecord(WavGetHandle(lpWav)) != 0)
				fSuccess = TraceFALSE(NULL);

			lResult = 0L;
		}
			break;

		default:
			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
			break;
	}
	
	return lResult;
}

// WavCalcPositionStop - calculate new stop position if stopped
//		<hWav>				(i) handle returned from WavOpen
//		<cbPosition>		(i) new stop position, in bytes
// return 0 if success
//
static int WavCalcPositionStop(HWAV hWav, long cbPosition)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// recalculate stop position only if currently stopped
	// (if playing or recording, defer recalc until stop occurs)
	//
#if 0
	else if (WavGetState(hWav) == WAV_STOPPED)
#else
	else if (lpWav->hWavOut == NULL && lpWav->hWavIn == NULL)
#endif
	{
		// convert byte position to milleseconds
		// save the new stop position
		//
		lpWav->msPositionStop = WavFormatBytesToMilleseconds(
			lpWav->lpwfx[FORMATFILE], (DWORD) cbPosition);
#if 1
		TracePrintf_2(NULL, 6,
			TEXT("lpWav->msPositionStop=%ld, cbPosition=%ld\n"),
			(long) lpWav->msPositionStop,
			(long) cbPosition);
#endif
	}

	return fSuccess ? 0 : -1;
}

// WavSeekTraceBefore - debug trace output before the seek
//		<lpWav>				(i) pointer to WAV struct
//		<lOffset>			(i) bytes to move pointer
//		<nOrigin>			(i) position to move from
// return 0 if success
//
static int WavSeekTraceBefore(LPWAV lpWav, long lOffset, int nOrigin)
{
	BOOL fSuccess = TRUE;

	TracePrintf_2(NULL, 6,
		TEXT("WavSeek(..., lOffset=%ld, nOrigin=%d)\n"),
		(long) lOffset,
		(int) nOrigin);

	TracePrintf_4(NULL, 6,
		TEXT("Before: lpWav->lDataOffset=%ld, lpWav->lDataPos=%ld, lpWav->cbData=%ld, lpWav->msPositionStop=%ld\n"),
		(long) lpWav->lDataOffset,
		(long) lpWav->lDataPos,
		(long) lpWav->cbData,
		(long) lpWav->msPositionStop);

	return fSuccess ? 0 : -1;
}

// WavSeekTraceAfter - debug trace output after the seek
//		<lpWav>				(i) pointer to WAV struct
//		<lPos>				(i) position returned from mmioSeek
//		<lOffset>			(i) bytes to move pointer
//		<nOrigin>			(i) position to move from
// return 0 if success
//
static int WavSeekTraceAfter(LPWAV lpWav, long lPos, long lOffset, int nOrigin)
{
	BOOL fSuccess = TRUE;

	TracePrintf_3(NULL, 6,
		TEXT("%ld = mmioSeek(..., lOffset=%ld, nOrigin=%d)\n"),
		(long) lPos,
		(long) lOffset,
		(int) nOrigin);

	TracePrintf_4(NULL, 6,
		TEXT("After: lpWav->lDataOffset=%ld, lpWav->lDataPos=%ld, lpWav->cbData=%ld, lpWav->msPositionStop=%ld\n"),
		(long) lpWav->lDataOffset,
		(long) lpWav->lDataPos,
		(long) lpWav->cbData,
		(long) lpWav->msPositionStop);

	return fSuccess ? 0 : -1;
}

// WavGetPtr - verify that wav handle is valid,
//		<hWav>				(i) handle returned from WavInit
// return corresponding wav pointer (NULL if error)
//
static LPWAV WavGetPtr(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = (LPWAV) hWav) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpWav, sizeof(WAV)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the wav handle
	//
	else if (lpWav->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpWav : NULL;
}

// WavGetHandle - verify that wav pointer is valid,
//		<lpWav>				(i) pointer to WAV struct
// return corresponding wav handle (NULL if error)
//
static HWAV WavGetHandle(LPWAV lpWav)
{
	BOOL fSuccess = TRUE;
	HWAV hWav;

	if ((hWav = (HWAV) lpWav) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hWav : NULL;
}

// WavInitGetPtr - verify that wavinit handle is valid,
//		<hWavInit>				(i) handle returned from WavInitInit
// return corresponding wavinit pointer (NULL if error)
//
static LPWAVINIT WavInitGetPtr(HWAVINIT hWavInit)
{
	BOOL fSuccess = TRUE;
	LPWAVINIT lpWavInit;

	if ((lpWavInit = (LPWAVINIT) hWavInit) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpWavInit, sizeof(WAVINIT)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the wavinit handle
	//
	else if (lpWavInit->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpWavInit : NULL;
}

// WavInitGetHandle - verify that wavinit pointer is valid,
//		<lpWavInit>				(i) pointer to WAVINIT struct
// return corresponding wavinit handle (NULL if error)
//
static HWAVINIT WavInitGetHandle(LPWAVINIT lpWavInit)
{
	BOOL fSuccess = TRUE;
	HWAVINIT hWavInit;

	if ((hWavInit = (HWAVINIT) lpWavInit) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hWavInit : NULL;
}

#ifdef MULTITHREAD
static int SetEventMessageProcessed(LPWAV lpWav, HANDLE hEventMessageProcessed)
{
	BOOL fSuccess = TRUE;

	if (lpWav == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!(lpWav->dwFlags & WAV_MULTITHREAD))
		; // nothing to do

	else if (hEventMessageProcessed == NULL)
		fSuccess = TraceFALSE(NULL);

	// notify SendMessageEx that message has been processed
	//
	else if (!SetEvent(hEventMessageProcessed))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}
#endif


// WavTempStop - stop playback or recording if necessary, save prev state
//		<hWav>				(i) handle returned from WavInit
//		<lpwStatePrev>		(o) return previous state here
//		<lpidDevPrev>		(o) return device id here
// return 0 if success
//
static int WavTempStop(HWAV hWav, LPWORD lpwStatePrev, LPINT lpidDevPrev)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	WORD wStatePrev;

    //
    // We have to initialize the local variable
    //
	int idDevPrev = 0;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure we not playing or recording
	// $FIXUP - we need to make sure that WAV_PLAYSYNC and
	// WAV_AUTOCLOSE flags are ignored during this stop
	//
	else switch ((wStatePrev = WavGetState(hWav)))
	{
		case WAV_PLAYING:
			if ((idDevPrev = WavOutGetId(lpWav->hWavOut)) < -1)
				fSuccess = TraceFALSE(NULL);

			else if (WavStop(hWav) != 0)
				fSuccess = TraceFALSE(NULL);

			break;

		case WAV_RECORDING:
			if ((idDevPrev = WavInGetId(lpWav->hWavIn)) < -1)
				fSuccess = TraceFALSE(NULL);

			else if (WavStop(hWav) != 0)
				fSuccess = TraceFALSE(NULL);
			break;

		default:
			break;
	}

	if (fSuccess)
	{
		*lpwStatePrev = wStatePrev;
		*lpidDevPrev = idDevPrev;
	}

	return fSuccess ? 0 : -1;
}

// WavTempResume - resume playback or recording if necessary, using prev state
//		<hWav>				(i) handle returned from WavInit
//		<wStatePrev>		(i) previous state returned from WavTempStop
//		<idDevPrev>			(i) device id returned from WavTempStop
// return 0 if success
//
static int WavTempResume(HWAV hWav, WORD wStatePrev, int idDevPrev)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// resume playback or recording if necessary
	//
	else switch (wStatePrev)
	{
		case WAV_PLAYING:
			if (WavPlay(hWav, idDevPrev, lpWav->dwFlagsPlay) != 0)
				fSuccess = TraceFALSE(NULL);
			break;

		case WAV_RECORDING:
			if (WavRecord(hWav, idDevPrev, lpWav->dwFlagsRecord) != 0)
				fSuccess = TraceFALSE(NULL);
			break;

		default:
			break;
	}

	return fSuccess ? 0 : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\wavin.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wavin.h - interface for wav input device functions in wavin.c
////

#ifndef __WAVIN_H__
#define __WAVIN_H__

#ifdef _WIN32
#define MULTITHREAD 1
#endif

#include "winlocal.h"

#include "wavfmt.h"

#define WAVIN_VERSION 0x00000108

// handle to wav input device (NOT the same as Windows HWAVEIN)
//
DECLARE_HANDLE32(HWAVIN);

// <dwFlags> values in WavInOpen
//
#define WAVIN_NOSYNC		0x00000001
#define WAVIN_OPENRETRY		0x00000004
#define WAVIN_OPENASYNC		0x00000008
#define WAVIN_CLOSEASYNC	0x00000010
#define WAVIN_NOACM			0x00000020
#define WAVIN_TELRFILE		0x00000040
#ifdef MULTITHREAD
#define WAVIN_MULTITHREAD 	0x00000080
#endif

// notification messages sent to <hwndNotify>
//
#define WM_WAVIN_OPEN			(WM_USER + 200)
#define WM_WAVIN_CLOSE			(WM_USER + 201)
#define WM_WAVIN_RECORDDONE		(WM_USER + 202)
#define WM_WAVIN_STOPRECORD		(WM_USER + 203)

// structure passed as <lParam> in WM_WAVOUT_RECORDDONE message
//
typedef struct RECORDDONE
{
	LPVOID lpBuf;
	long sizBuf;
	long lBytesRecorded;
} RECORDDONE, FAR *LPRECORDDONE;

// return values from WavInGetState
//
#define WAVIN_STOPPED		0x0001
#define WAVIN_RECORDING		0x0002
#define WAVIN_STOPPING		0x0008

#ifdef __cplusplus
extern "C" {
#endif

// WavInGetDeviceCount - return number of wav input devices found
//		<void>				this function takes no arguments
// return number of wav input devices found (0 if none)
//
int DLLEXPORT WINAPI WavInGetDeviceCount(void);

// WavInDeviceIsOpen - check if input device is open
//		<idDev>				(i) device id
//			-1					open any suitable input device
// return TRUE if open
//
BOOL DLLEXPORT WINAPI WavInDeviceIsOpen(int idDev);

// WavInOpen - open wav input device
//		<dwVersion>			(i) must be WAVIN_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<idDev>				(i) device id
//			-1					open any suitable input device
//		<lpwfx>				(i) wave format
//		<hwndNotify>		(i) notify this window of device events
//			NULL				do not notify
//		<msTimeoutOpen>		(i) device open timeout in milleseconds
//			0					default timeout (30000)
//		<msTimeoutRetry>	(i) device retry timeout in milleseconds
//			0					default timeout (2000)
//		<dwFlags>			(i) control flags
//			WAVIN_NOSYNC		do not open synchronous devices
//			WAVIN_OPENRETRY		retry if device busy
//			WAVIN_OPENASYNC		return before notification of device open
//			WAVIN_CLOSEASYNC	return before notification of device close
//			WAVIN_NOACM			do not use audio compression manager
//			WAVIN_TELRFILE		telephone will record audio to file on server
#ifdef MULTITHREAD
//			WAVOUT_MULTITHREAD use callback thread rather than window
#endif
// return handle (NULL if error)
//
// NOTE: if <hwndNotify> is specified in WavInOpen,
// WM_WAVIN_OPEN will be sent to <hwndNotify>,
// when input device has been opened.
//
// NOTE: if WAVIN_MULTITHREAD is specified in <dwFlags>,
// it is assumed that <hwndNotify> is not a window handle,
// but rather the id of the thread to receive notifications
//
HWAVIN DLLEXPORT WINAPI WavInOpen(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags);

// WavInClose - close wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
//		<msTimeoutClose>	(i) device close timeout in milleseconds
//			0					default timeout (30000)
// return 0 if success
//
// NOTE: if <hwndNotify> was specified in WavInOpen,
// WM_WAVIN_CLOSE will be sent to <hwndNotify>,
// when input device has been closed.
//
int DLLEXPORT WINAPI WavInClose(HWAVIN hWavIn, DWORD msTimeoutClose);

// WavInRecord - submit buffer of samples to wav input device for recording
//		<hWavIn>			(i) handle returned from WavInOpen
//		<lpBuf>				(o) pointer to buffer to be filled with samples
//		<sizBuf>			(i) size of buffer in bytes
// return 0 if success
//
// NOTE: the buffer pointed to by <lpBuf> must have been allocated
// using MemAlloc().
//
// NOTE: if <hwndNotify> is specified in WavInOpen(), a WM_WAVIN_RECORDDONE
// message will be sent to <hwndNotify>, with <lParam> set to a pointer to
// a RECORDDONE structure, when <lpBuf> has been recorded.
//
int DLLEXPORT WINAPI WavInRecord(HWAVIN hWavIn, LPVOID lpBuf, long sizBuf);

// WavInStop - stop recording into buffer(s) sent to wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
//		<msTimeoutStop>		(i) device stop timeout in milleseconds
//			0					default timeout (2000)
// return 0 if success
//
int DLLEXPORT WINAPI WavInStop(HWAVIN hWavIn, DWORD msTimeoutStop);

// WavInGetState - return current wav input device state
//		<hWavIn>			(i) handle returned from WavInOpen
// return WAVIN_STOPPED, WAVIN_RECORDING, or 0 if error
//
WORD DLLEXPORT WINAPI WavInGetState(HWAVIN hWavIn);

// WavInGetPosition - get milleseconds of elapsed recording
//		<hWavIn>			(i) handle returned from WavInOpen
// return 0 if success
//
long DLLEXPORT WINAPI WavInGetPosition(HWAVIN hWavIn);

// WavInGetId - return id of wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
// return device id (-1 if error)
//
int DLLEXPORT WINAPI WavInGetId(HWAVIN hWavIn);

// WavInGetName - get name of wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavIn> is not NULL)
//			-1					any suitable input device
//		<lpszName>			(o) buffer to hold device name
//		<sizName>			(i) size of buffer
// return 0 if success
//
int DLLEXPORT WINAPI WavInGetName(HWAVIN hWavIn, int idDev, LPTSTR lpszName, int sizName);

// WavInGetIdByName - get id of wav input device, lookup by name
//		<lpszName>			(i) device name
#ifdef _WIN32
//			NULL or TEXT("")	get preferred device id
#endif
//		<dwFlags>			(i) reserved; must be zero
// return device id (-1 if error)
//
int WINAPI WavInGetIdByName(LPCTSTR lpszName, DWORD dwFlags);

// WavInSupportsFormat - return TRUE if device supports specified format
//		<hWavIn>			(i) handle returned from WavInOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavIn> is not NULL)
//			-1					any suitable input device
//		<lpwfx>				(i) wave format
// return TRUE if device supports specified format
//
BOOL DLLEXPORT WINAPI WavInSupportsFormat(HWAVIN hWavIn, int idDev,
	LPWAVEFORMATEX lpwfx);

// WavInFormatSuggest - suggest a new format which the device supports
//		<hWavIn>			(i) handle returned from WavInOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavIn> is not NULL)
//			-1					any suitable input device
//		<lpwfxSrc>			(i) source format
//		<dwFlags>			(i)	control flags
//			WAVIN_NOACM			do not use audio compression manager
// return pointer to suggested format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavInFormatSuggest(
	HWAVIN hWavIn, int idDev, LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags);

// WavInTerm - shut down wav input residuals, if any
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
//			WAV_TELTHUNK		terminate telephone thunking layer
// return 0 if success
//
int DLLEXPORT WINAPI WavInTerm(HINSTANCE hInst, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __WAVIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\wavin.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wavin.c - wav input device functions
////

#include "winlocal.h"
#include "wavin.h"
#include "wav.h"
#include "acm.h"
#include "calc.h"
#include "mem.h"
#include "str.h"
#include "sys.h"
#include "trace.h"
#include <mmddk.h>

// allow telephone input functions if defined
//
#ifdef TELIN
#include "telin.h"
static HTELIN hTelIn = NULL;
#endif

////
//	private definitions
////

#define WAVINCLASS TEXT("WavInClass")

// wavin control struct
//
typedef struct WAVIN
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	UINT idDev;
	LPWAVEFORMATEX lpwfx;
	HWND hwndNotify;
	DWORD dwFlags;
	BOOL fIsOpen;
	HWAVEIN hWaveIn;
	WORD wState;
	HWND hwndCallback;
#ifdef MULTITHREAD
	HANDLE hThreadCallback;
	DWORD dwThreadId;
	HANDLE hEventThreadCallbackStarted;
	HANDLE hEventDeviceOpened;
	HANDLE hEventDeviceClosed;
	HANDLE hEventDeviceStopped;
	CRITICAL_SECTION critSectionStop;
#endif
	UINT nLastError;
	int cBufsPending;
} WAVIN, FAR *LPWAVIN;

// helper functions
//
LRESULT DLLEXPORT CALLBACK WavInCallback(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#ifdef MULTITHREAD
DWORD WINAPI WavInCallbackThread(LPVOID lpvThreadParameter);
#endif
static LPWAVIN WavInGetPtr(HWAVIN hWavIn);
static HWAVIN WavInGetHandle(LPWAVIN lpWavIn);
#ifdef MULTITHREAD
static LRESULT SendThreadMessage(DWORD dwThreadId, UINT Msg, LPARAM lParam);
#endif

////
//	public functions
////

// WavInGetDeviceCount - return number of wav input devices found
//		<void>				this function takes no arguments
// return number of wav input devices found (0 if none)
//
int DLLEXPORT WINAPI WavInGetDeviceCount(void)
{
	return waveInGetNumDevs();
}

// WavInDeviceIsOpen - check if input device is open
//		<idDev>				(i) device id
//			-1					open any suitable input device
// return TRUE if open
//
BOOL DLLEXPORT WINAPI WavInDeviceIsOpen(int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL fIsOpen = FALSE;
	WAVEFORMATEX wfx;
	HWAVEIN hWaveIn = NULL;
	int nLastError;

#ifdef TELIN
	if (idDev == TELIN_DEVICEID)
		return TelInDeviceIsOpen(idDev);
#endif

	// try to open device
	//
	if ((nLastError = waveInOpen(&hWaveIn, idDev, 
#ifndef _WIN32
			(LPWAVEFORMAT)
#endif
		WavFormatPcm(-1, -1, -1, &wfx),
		 0, 0, 0)) != 0)
	{
		if (nLastError == MMSYSERR_ALLOCATED)
			fIsOpen = TRUE; // device in use

		else
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveInOpen failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	// close device
	//
	else if (waveInClose(hWaveIn) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? fIsOpen : FALSE;
}

// WavInOpen - open wav input device
//		<dwVersion>			(i) must be WAVIN_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<idDev>				(i) device id
//			-1					open any suitable input device
//		<lpwfx>				(i) wave format
//		<hwndNotify>		(i) notify this window of device events
//			NULL				do not notify
//		<msTimeoutOpen>		(i) device open timeout in milleseconds
//			0					default timeout (30000)
//		<msTimeoutRetry>	(i) device retry timeout in milleseconds
//			0					default timeout (2000)
//		<dwFlags>			(i) control flags
//			WAVIN_NOSYNC		do not open synchronous devices
//			WAVIN_OPENRETRY		retry if device busy
//			WAVIN_OPENASYNC		return before notification of device open
//			WAVIN_CLOSEASYNC	return before notification of device close
//			WAVIN_NOACM			do not use audio compression manager
//			WAVIN_TELRFILE		telephone will record audio to file on server
#ifdef MULTITHREAD
//			WAVIN_MULTITHREAD	support multiple threads
#endif
// return handle (NULL if error)
//
// NOTE: if <hwndNotify> is specified in WavInOpen,
// WM_WAVIN_OPEN will be sent to <hwndNotify>,
// when input device has been opened.
//
// NOTE: if WAVIN_MULTITHREAD is specified in <dwFlags>,
// it is assumed that <hwndNotify> is not a window handle,
// but rather the id of the thread to receive notifications
//
HWAVIN DLLEXPORT WINAPI WavInOpen(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn = NULL;
	WNDCLASS wc;

#ifdef TELIN
	if (idDev == TELIN_DEVICEID)
	{
		hTelIn = TelInOpen(TELIN_VERSION, hInst, idDev, lpwfx,
			hwndNotify, msTimeoutOpen, msTimeoutRetry, dwFlags);
		return (HWAVIN) hTelIn;
	}
#endif

	if (dwVersion != WAVIN_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavIn = (LPWAVIN) MemAlloc(NULL, sizeof(WAVIN), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpWavIn->dwVersion = dwVersion;
		lpWavIn->hInst = hInst;
		lpWavIn->hTask = GetCurrentTask();
		lpWavIn->idDev = (UINT) idDev;
		lpWavIn->lpwfx = NULL;
		lpWavIn->hwndNotify = hwndNotify;
		lpWavIn->dwFlags = dwFlags;
		lpWavIn->fIsOpen = FALSE;
		lpWavIn->hWaveIn = NULL;
		lpWavIn->wState = WAVIN_STOPPED;
		lpWavIn->hwndCallback = NULL;
#ifdef MULTITHREAD
		lpWavIn->hThreadCallback = NULL;
		lpWavIn->dwThreadId = 0;
		lpWavIn->hEventThreadCallbackStarted = NULL;
		lpWavIn->hEventDeviceOpened = NULL;
		lpWavIn->hEventDeviceClosed = NULL;
		lpWavIn->hEventDeviceStopped = NULL;
#endif
		lpWavIn->nLastError = 0;
		lpWavIn->cBufsPending = 0;

		// memory is allocated such that the client app owns it
		//
		if ((lpWavIn->lpwfx = WavFormatDup(lpwfx)) == NULL)
			fSuccess = TraceFALSE(NULL);
	}

#ifdef MULTITHREAD
	// handle WAVIN_MULTITHREAD flag
	//
	if (fSuccess && (lpWavIn->dwFlags & WAVIN_MULTITHREAD))
	{
		DWORD dwRet;

		InitializeCriticalSection(&(lpWavIn->critSectionStop));

		// we need to know when device has been opened
		//
		if ((lpWavIn->hEventDeviceOpened = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// we need to know when callback thread begins execution
		//
		else if ((lpWavIn->hEventThreadCallbackStarted = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// create the callback thread
		//
		else if ((lpWavIn->hThreadCallback = CreateThread(
			NULL,
			0,
			WavInCallbackThread,
			(LPVOID) lpWavIn,
			0,
			&lpWavIn->dwThreadId)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// wait for the callback thread to begin execution
		//
		else if ((dwRet = WaitForSingleObject(
			lpWavIn->hEventThreadCallbackStarted, 10000)) != WAIT_OBJECT_0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// clean up
		//
		if (lpWavIn->hEventThreadCallbackStarted != NULL)
		{
			if (!CloseHandle(lpWavIn->hEventThreadCallbackStarted))
				fSuccess = TraceFALSE(NULL);
			else
				lpWavIn->hEventThreadCallbackStarted = NULL;
		}
	}
	else
#endif
	{
		// register callback class unless it has been already
		//
		if (fSuccess && GetClassInfo(lpWavIn->hInst, WAVINCLASS, &wc) == 0)
		{
			wc.hCursor =		NULL;
			wc.hIcon =			NULL;
			wc.lpszMenuName =	NULL;
			wc.hInstance =		lpWavIn->hInst;
			wc.lpszClassName =	WAVINCLASS;
			wc.hbrBackground =	NULL;
			wc.lpfnWndProc =	WavInCallback;
			wc.style =			0L;
			wc.cbWndExtra =		sizeof(lpWavIn);
			wc.cbClsExtra =		0;

			if (!RegisterClass(&wc))
				fSuccess = TraceFALSE(NULL);
		}

		// create the callback window
		//
		if (fSuccess && (lpWavIn->hwndCallback = CreateWindowEx(
			0L,
			WAVINCLASS,
			NULL,
			0L,
			0, 0, 0, 0,
			NULL,
			NULL,
			lpWavIn->hInst,
			lpWavIn)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}

	if (fSuccess)
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutRetry == 0 ? 2000L : msTimeoutRetry);
		DWORD dwCallback;
		DWORD dwFlags;

#ifdef MULTITHREAD
		if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
		{
			dwCallback = lpWavIn->dwThreadId;
			dwFlags = CALLBACK_THREAD;
		}
		else
#endif
		{
			dwCallback = HandleToUlong(lpWavIn->hwndCallback);
			dwFlags = CALLBACK_WINDOW;
		}

		// allow synchronous device drivers unless WAVIN_NOSYNC specified
		//
		if (!(lpWavIn->dwFlags & WAVIN_NOSYNC))
			dwFlags |= WAVE_ALLOWSYNC;

		// open the device
		//
		while (fSuccess && (lpWavIn->nLastError = waveInOpen(&lpWavIn->hWaveIn,
			(UINT) lpWavIn->idDev,
#ifndef _WIN32
			(LPWAVEFORMAT)
#endif
			lpWavIn->lpwfx, dwCallback, (DWORD) 0, dwFlags)) != 0)
		{
			// no need to retry unless the device is busy
			//
			if (lpWavIn->nLastError != MMSYSERR_ALLOCATED)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("waveInOpen failed (%u)\n"),
					(unsigned) lpWavIn->nLastError);
			}

			// no need to retry if flag not set
			//
			else if (!(lpWavIn->dwFlags & WAVIN_OPENRETRY))
				fSuccess = TraceFALSE(NULL);

			// no more retries if timeout occurred
			//
			else if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else
			{
				MSG msg;

				if (PeekMessage(&msg, lpWavIn->hwndCallback, 0, 0, PM_REMOVE))
				{
				 	TranslateMessage(&msg);
				 	DispatchMessage(&msg);
				}

				else
#ifdef _WIN32
					Sleep(100);
#else
        		    WaitMessage();
#endif
			}
		}
	}

	// make sure a handle was returned
	//
	if (fSuccess && lpWavIn->hWaveIn == NULL)
		fSuccess = TraceFALSE(NULL);

	// wait for device open notification or timeout
	//
	if (fSuccess && !(lpWavIn->dwFlags & WAVIN_OPENASYNC))
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutOpen == 0 ? 2000L : msTimeoutOpen);

#ifdef MULTITHREAD
		if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
		{
			DWORD dwRet;

			// wait for the device top be opened
			//
			if ((dwRet = WaitForSingleObject(
				lpWavIn->hEventDeviceOpened,
				(msTimeoutOpen == 0 ? 30000L : msTimeoutOpen))) != WAIT_OBJECT_0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}
		else
#endif
		while (fSuccess && !lpWavIn->fIsOpen)
		{
			MSG msg;

			if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else if (PeekMessage(&msg, lpWavIn->hwndCallback, 0, 0, PM_REMOVE))
			{
			 	TranslateMessage(&msg);
			 	DispatchMessage(&msg);
			}

			else
        	    WaitMessage();
		}
	}

#ifdef MULTITHREAD
	// clean up
	//
	if (lpWavIn != NULL && lpWavIn->hEventDeviceOpened != NULL)
	{
		if (!CloseHandle(lpWavIn->hEventDeviceOpened))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavIn->hEventDeviceOpened = NULL;
	}

	if (lpWavIn != NULL && lpWavIn->hThreadCallback != NULL)
	{
		if (!CloseHandle(lpWavIn->hThreadCallback))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavIn->hThreadCallback = NULL;
	}
#endif

	if (fSuccess)
	{
		if ((lpWavIn->nLastError = waveInGetID(lpWavIn->hWaveIn,
			&lpWavIn->idDev)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveInGetID failed (%u)\n"),
				(unsigned) lpWavIn->nLastError);
		}
	}

	if (!fSuccess)
	{
		WavInClose(WavInGetHandle(lpWavIn), 0);
		lpWavIn = NULL;
	}

	return fSuccess ? WavInGetHandle(lpWavIn) : NULL;
}

// WavInClose - close wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
//		<msTimeoutClose>	(i) device close timeout in milleseconds
//			0					default timeout (30000)
// return 0 if success
//
// NOTE: if <hwndNotify> was specified in WavInOpen,
// WM_WAVIN_CLOSE will be sent to <hwndNotify>,
// when input device has been closed.
//
int DLLEXPORT WINAPI WavInClose(HWAVIN hWavIn, DWORD msTimeoutClose)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;

#ifdef TELIN
	if (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn)
	{
		int iRet = TelInClose((HTELIN) hWavIn, msTimeoutClose);
		hTelIn = NULL;
		return iRet;
	}
#endif

	if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// stop the device
	//
	else if (WavInStop(hWavIn, 0) != 0)
		fSuccess = TraceFALSE(NULL);

#ifdef MULTITHREAD
	// we need to know when device has been closed
	//
	else if ((lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
		(lpWavIn->hEventDeviceClosed = CreateEvent(
		NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#endif

	// close the device
	//
	else if (lpWavIn->hWaveIn != NULL &&
		(lpWavIn->nLastError = waveInClose(lpWavIn->hWaveIn)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("wavInClose failed (%u)\n"),
	 		(unsigned) lpWavIn->nLastError);
	}

	// wait for device close notification or timeout
	//
	if (fSuccess && !(lpWavIn->dwFlags & WAVIN_CLOSEASYNC))
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutClose == 0 ? 30000L : msTimeoutClose);

#ifdef MULTITHREAD
		if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
		{
			DWORD dwRet;

			// wait for the device to be closed
			//
			if ((dwRet = WaitForSingleObject(
				lpWavIn->hEventDeviceClosed,
				(msTimeoutClose == 0 ? 30000L : msTimeoutClose))) != WAIT_OBJECT_0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}
		else
#endif
		while (fSuccess && lpWavIn->fIsOpen)
		{
			MSG msg;

			if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else if (PeekMessage(&msg, lpWavIn->hwndCallback, 0, 0, PM_REMOVE))
			{
			 	TranslateMessage(&msg);
			 	DispatchMessage(&msg);
			}

			else
        	    WaitMessage();
		}
	}

#ifdef MULTITHREAD
	// clean up
	//
	if (lpWavIn != NULL && lpWavIn->hEventDeviceClosed != NULL)
	{
		if (!CloseHandle(lpWavIn->hEventDeviceClosed))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavIn->hEventDeviceClosed = NULL;
	}
#endif

	if (fSuccess)
	{
#ifdef MULTITHREAD
	   	if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
		{
			while (lpWavIn->critSectionStop.OwningThread != NULL)
				Sleep(100L);

			DeleteCriticalSection(&(lpWavIn->critSectionStop));
		}
#endif
		// device handle is no longer valid
		//
		lpWavIn->hWaveIn = NULL;

		// destroy callback window
		//
		if (lpWavIn->hwndCallback != NULL &&
			!DestroyWindow(lpWavIn->hwndCallback))
			fSuccess = TraceFALSE(NULL);

		else if (lpWavIn->hwndCallback = NULL, FALSE)
			fSuccess = TraceFALSE(NULL);

		else if (lpWavIn->lpwfx != NULL &&
			WavFormatFree(lpWavIn->lpwfx) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (lpWavIn->lpwfx = NULL, FALSE)
			fSuccess = TraceFALSE(NULL);

		else if ((lpWavIn = MemFree(NULL, lpWavIn)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavInRecord - submit buffer of samples to wav input device for recording
//		<hWavIn>			(i) handle returned from WavInOpen
//		<lpBuf>				(o) pointer to buffer to be filled with samples
//		<sizBuf>			(i) size of buffer in bytes
// return 0 if success
//
// NOTE: the buffer pointed to by <lpBuf> must have been allocated
// using MemAlloc().
//
// NOTE: if <hwndNotify> is specified in WavInOpen(), a WM_WAVIN_RECORDDONE
// message will be sent to <hwndNotify>, with <lParam> set to a pointer to
// a RECORDDONE structure, when <lpBuf> has been recorded.
//
int DLLEXPORT WINAPI WavInRecord(HWAVIN hWavIn, LPVOID lpBuf, long sizBuf)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;
	LPWAVEHDR lpWaveHdr = NULL;

#ifdef TELIN
	if (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn)
		return TelInRecord((HTELIN) hWavIn, lpBuf, sizBuf, -1);
#endif

	if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpBuf == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWaveHdr = (LPWAVEHDR) MemAlloc(NULL,
		sizeof(WAVEHDR), 0)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	else
	{
		lpWaveHdr->lpData = (LPSTR) lpBuf;
		lpWaveHdr->dwBufferLength = (DWORD) sizBuf;

		if ((lpWavIn->nLastError = waveInPrepareHeader(lpWavIn->hWaveIn,
			lpWaveHdr, sizeof(WAVEHDR))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		 	TracePrintf_1(NULL, 5,
		 		TEXT("waveInPrepareHeader failed (%u)\n"),
	 			(unsigned) lpWavIn->nLastError);
		}

		else if ((lpWavIn->nLastError = waveInAddBuffer(lpWavIn->hWaveIn,
			lpWaveHdr, sizeof(WAVEHDR))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		 	TracePrintf_1(NULL, 5,
		 		TEXT("waveInAddBuffer failed (%u)\n"),
	 			(unsigned) lpWavIn->nLastError);
		}

		else if ((lpWavIn->nLastError = waveInStart(lpWavIn->hWaveIn)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		 	TracePrintf_1(NULL, 5,
		 		TEXT("waveInStart failed (%u)\n"),
		 		(unsigned) lpWavIn->nLastError);
		}

		else
		{
			++lpWavIn->cBufsPending;
			lpWavIn->wState = WAVIN_RECORDING;
		}
	}

	return fSuccess ? 0 : -1;
}

// WavInStop - stop recording into buffer(s) sent to wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
//		<msTimeoutStop>		(i) device stop timeout in milleseconds
//			0					default timeout (2000)
// return 0 if success
//
int DLLEXPORT WINAPI WavInStop(HWAVIN hWavIn, DWORD msTimeoutStop)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;

#ifdef TELIN
	if (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn)
		return TelInStop((HTELIN) hWavIn, msTimeoutStop);
#endif

	if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
		fSuccess = TraceFALSE(NULL);

#ifdef MULTITHREAD
	else if ((lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
		(EnterCriticalSection(&(lpWavIn->critSectionStop)), FALSE))
		;
#endif

	// make sure device is recording
	//
	else if (WavInGetState(hWavIn) == WAVIN_STOPPED)
		; // not an error to call this function when already stopped

	else if (lpWavIn->wState = WAVIN_STOPPING, FALSE)
		;

#ifdef MULTITHREAD
	// we need to know when device has been stopped
	//
	else if ((lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
		(lpWavIn->hEventDeviceStopped = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#endif

	// stop the device
	//
	else if ((lpWavIn->nLastError = waveInReset(lpWavIn->hWaveIn)) != 0)
	{	
		fSuccess = TraceFALSE(NULL);
 		TracePrintf_1(NULL, 5,
 			TEXT("waveInReset failed (%u)\n"),
			(unsigned) lpWavIn->nLastError);
	}

	// wait for all pending buffers to complete
	//
#ifdef MULTITHREAD
	else if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
	{
		DWORD dwRet;

		LeaveCriticalSection(&(lpWavIn->critSectionStop));

		// wait for the device to be stopped
		//
		if ((dwRet = WaitForSingleObject(
			lpWavIn->hEventDeviceStopped,
			(msTimeoutStop == 0 ? 10000L : msTimeoutStop))) != WAIT_OBJECT_0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		EnterCriticalSection(&(lpWavIn->critSectionStop));
	}
#endif
	else
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutStop == 0 ? 2000L : msTimeoutStop);

		while (fSuccess && lpWavIn->cBufsPending > 0)
		{
			MSG msg;

			// check for timeout
			//
			if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else if (PeekMessage(&msg, lpWavIn->hwndCallback, 0, 0, PM_REMOVE))
			{
		 		TranslateMessage(&msg);
		 		DispatchMessage(&msg);
			}

			else
       			WaitMessage();
		}
	}

#ifdef MULTITHREAD
	// clean up
	//
	if (lpWavIn != NULL && lpWavIn->hEventDeviceStopped != NULL)
	{
		if (!CloseHandle(lpWavIn->hEventDeviceStopped))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavIn->hEventDeviceStopped = NULL;
	}

	if (lpWavIn != NULL && (lpWavIn->dwFlags & WAVIN_MULTITHREAD))
		LeaveCriticalSection(&(lpWavIn->critSectionStop));
#endif

	return fSuccess ? 0 : -1;
}

// WavInGetState - return current wav input device state
//		<hWavIn>			(i) handle returned from WavInOpen
// return WAVIN_STOPPED, WAVIN_RECORDING, or 0 if error
//
WORD DLLEXPORT WINAPI WavInGetState(HWAVIN hWavIn)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;

#ifdef TELIN
	if (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn)
		return TelInGetState((HTELIN) hWavIn);
#endif

	if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWavIn->wState : 0;
}

// WavInGetPosition - get milleseconds of elapsed recording
//		<hWavIn>			(i) handle returned from WavInOpen
// return 0 if success
//
long DLLEXPORT WINAPI WavInGetPosition(HWAVIN hWavIn)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;
	MMTIME mmtime;
	long msPosition;

#ifdef TELIN
	if (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn)
		return TelInGetPosition((HTELIN) hWavIn);
#endif

	MemSet(&mmtime, 0, sizeof(mmtime));

	// we will be requesting position in millesconds
	//
	mmtime.wType = TIME_MS;

	if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get device position
	//
	else if ((lpWavIn->nLastError = waveInGetPosition(
		lpWavIn->hWaveIn, &mmtime, sizeof(MMTIME))) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("waveInGetPosition failed (%u)\n"),
 			(unsigned) lpWavIn->nLastError);
	}

	// see what type of position was returned
	//
	else switch (mmtime.wType)
	{
		case TIME_MS:
		{
			// we got milleseconds; no conversion required
			//
			msPosition = (long) mmtime.u.ms;
		}
			break;

		case TIME_SAMPLES:
		{
			// convert samples to millesconds
			//
			msPosition = (long) MULDIVU32(mmtime.u.sample,
				1000L, lpWavIn->lpwfx->nSamplesPerSec);
		}
			break;

		case TIME_BYTES:
		{
			// convert bytes to millesconds
			//
			msPosition = (long) MULDIVU32(mmtime.u.cb,
				1000L, lpWavIn->lpwfx->nAvgBytesPerSec);
		}
			break;

		case TIME_SMPTE:
		case TIME_MIDI:
		default:
			fSuccess = TraceFALSE(NULL);
			break;
	}

	return fSuccess ? msPosition : -1;
}

// WavInGetId - return id of wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
// return device id (-1 if error)
//
int DLLEXPORT WINAPI WavInGetId(HWAVIN hWavIn)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;

#ifdef TELIN
	if (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn)
		return TelInGetId((HTELIN) hWavIn);
#endif

	if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWavIn->idDev : -1;
}

// WavInGetName - get name of wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavIn> is not NULL)
//			-1					any suitable input device
//		<lpszName>			(o) buffer to hold device name
//		<sizName>			(i) size of buffer
// return 0 if success
//
int DLLEXPORT WINAPI WavInGetName(HWAVIN hWavIn, int idDev, LPTSTR lpszName, int sizName)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;

#ifdef TELIN
	if (idDev == TELIN_DEVICEID || (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn))
		return TelInGetName((HTELIN) hWavIn, idDev, lpszName, sizName);
#endif

	if (hWavIn != NULL)
	{
		if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavIn->idDev;
	}

	if (fSuccess)
	{
		WAVEINCAPS wic;
		UINT nLastError;

		if ((nLastError = waveInGetDevCaps(idDev, &wic, sizeof(WAVEINCAPS))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveInGetDevCaps failed (%u)\n"),
				(unsigned) nLastError);
		}

		else if (lpszName != NULL)
			StrNCpy(lpszName, wic.szPname, sizName);

		if (hWavIn != NULL && lpWavIn != NULL)
			lpWavIn->nLastError = nLastError;
	}

	return fSuccess ? 0 : -1;
}

// WavInGetIdByName - get id of wav input device, lookup by name
//		<lpszName>			(i) device name
#ifdef _WIN32
//			NULL or TEXT("")	get preferred device id
#endif
//		<dwFlags>			(i) reserved; must be zero
// return device id (-1 if error)
//
int WINAPI WavInGetIdByName(LPCTSTR lpszName, DWORD dwFlags)
{
	UINT idDev;
	UINT cDev = (UINT) WavInGetDeviceCount();

	// If no device specified, get the preferred device
	if ( !lpszName || (_tcslen(lpszName) <= 0) )
	{
		DWORD dwTemp;
		DWORD dwRet = waveInMessage( (HWAVEIN)(DWORD_PTR)WAVE_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &idDev, (DWORD_PTR) &dwTemp );
		if ( dwRet == MMSYSERR_NOERROR )
			return idDev;
	}
	else
	{
		// Device specified, search by name
		for ( idDev = 0; idDev < cDev; ++idDev )
		{
			TCHAR szName[256];
			if ( WavInGetName(NULL, idDev, szName, SIZEOFARRAY(szName)) == 0 )
			{
				if ( _tcsicmp(lpszName, szName) == 0 )
					return idDev;
			}
		}
	}

	// No match for device name
	TraceFALSE(NULL);
	return -1;
}

// WavInSupportsFormat - return TRUE if device supports specified format
//		<hWavIn>			(i) handle returned from WavInOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavIn> is not NULL)
//			-1					any suitable input device
//		<lpwfx>				(i) wave format
// return TRUE if device supports specified format
//
BOOL DLLEXPORT WINAPI WavInSupportsFormat(HWAVIN hWavIn, int idDev,
	LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;
	BOOL fSupportsFormat;

#ifdef TELIN
	if (idDev == TELIN_DEVICEID || (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn))
		return TelInSupportsFormat((HTELIN) hWavIn, idDev, lpwfx);
#endif

	if (hWavIn != NULL)
	{
		if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavIn->idDev;
	}

	if (fSuccess)
	{
		UINT nLastError;

		// query the device
		//
		if ((nLastError = waveInOpen(NULL, (UINT) idDev,
#ifndef _WIN32
			(LPWAVEFORMAT)
#endif
			lpwfx, 0,  0,
			WAVE_FORMAT_QUERY)) != 0)
		{
			fSupportsFormat = FALSE;
#if 1
			if (TraceGetLevel(NULL) >= 9)
			{
				TracePrintf_0(NULL, 9,
					TEXT("unsupported format:\n"));
				WavFormatDump(lpwfx);
			}
#endif
			if (nLastError != WAVERR_BADFORMAT)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("waveInOpen/FormatQuery failed (%u)\n"),
					(unsigned) nLastError);
			}
		}

		else
			fSupportsFormat = TRUE;

		if (hWavIn != NULL && lpWavIn != NULL)
			lpWavIn->nLastError = nLastError;
	}

	return fSuccess ? fSupportsFormat : FALSE;
}

// WavInFormatSuggest - suggest a new format which the device supports
//		<hWavIn>			(i) handle returned from WavInOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavIn> is not NULL)
//			-1					any suitable input device
//		<lpwfxSrc>			(i) source format
//		<dwFlags>			(i)	control flags
//			WAVIN_NOACM			do not use audio compression manager
// return pointer to suggested format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavInFormatSuggest(
	HWAVIN hWavIn, int idDev, LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;
	LPWAVEFORMATEX lpwfxSuggest = NULL;
	LPWAVEFORMATEX lpwfxTemp = NULL;
	HACM hAcm = NULL;

#ifdef TELIN
	if (idDev == TELIN_DEVICEID || (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn))
		return TelInFormatSuggest((HTELIN) hWavIn, idDev, lpwfxSrc, dwFlags);
#endif

	if (hWavIn != NULL)
	{
		if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
		{
			idDev = lpWavIn->idDev;
			if (lpWavIn->dwFlags & WAVIN_NOACM)
				dwFlags |= WAVIN_NOACM;
		}
	}

	if ((hAcm = AcmInit(ACM_VERSION, SysGetTaskInstance(NULL),
		(dwFlags & WAVIN_NOACM) ? ACM_NOACM : 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfxSrc))
		fSuccess = TraceFALSE(NULL);

	else if ((lpwfxTemp = WavFormatDup(lpwfxSrc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get suggested format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			-1, -1, -1, -1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavInSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->wFormatTag != WAVE_FORMAT_PCM)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, -1, -1, -1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavInSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM mono format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->nChannels != 1)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, -1, -1, 1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavInSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM 8-bit mono format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->wBitsPerSample != 8)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, -1, 8, 1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavInSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM 11025Hz 8-bit mono format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->nSamplesPerSec != 11025)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, 11025, 8, 1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavInSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// last resort; see if MULAW 8000Hz 8-bit mono format is supported
	//
	if (fSuccess && lpwfxSuggest == NULL)
	{
#if 0
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_MULAW, 8000, 8, 1, 0)) == NULL)
#else
		if ((lpwfxSuggest = WavFormatMulaw(NULL, 8000)) == NULL)
#endif
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavInSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			// no more chances for success
			//
			fSuccess = TraceFALSE(NULL);
			if (WavFormatFree(lpwfxSuggest) != 0)
				fSuccess = TraceFALSE(NULL);
		}
	}

	// clean up
	//
	if (hAcm != NULL && AcmTerm(hAcm) != 0)
		fSuccess = TraceFALSE(NULL);
	else
		hAcm = NULL;

	return fSuccess ? lpwfxSuggest : NULL;
}

// WavInTerm - shut down wav input residuals, if any
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
//			WAV_TELTHUNK		terminate telephone thunking layer
// return 0 if success
//
int DLLEXPORT WINAPI WavInTerm(HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

#ifdef TELIN
	else if ((dwFlags & WAV_TELTHUNK) &&
		TelInTerm(hInst, dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

#ifdef MULTITHREAD
DWORD WINAPI WavInCallbackThread(LPVOID lpvThreadParameter)
{
	BOOL fSuccess = TRUE;
	MSG msg;
	LPWAVIN lpWavIn = (LPWAVIN) lpvThreadParameter;

	// make sure message queue is created before calling SetEvent
	//
	PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

	// notify main thread that callback thread has begun execution
	//
	if (!SetEvent(lpWavIn->hEventThreadCallbackStarted))
	{
		fSuccess = TraceFALSE(NULL);
	}

	while (fSuccess && GetMessage(&msg, NULL, 0, 0))
	{
		WavInCallback((HWND) lpWavIn, msg.message, msg.wParam, msg.lParam);

		// exit thread when when have processed last expected message
		//
		if (msg.message == MM_WIM_CLOSE)
			break;
	}

	return 0;
}
#endif

// WavInCallback - window procedure for wavin callback
//
LRESULT DLLEXPORT CALLBACK WavInCallback(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult;
	LPWAVIN lpWavIn;

#ifdef MULTITHREAD
	if (!IsWindow(hwnd))
		lpWavIn = (LPWAVIN) hwnd;
	else
#endif
	// retrieve lpWavIn from window extra bytes
	//
	lpWavIn = (LPWAVIN) GetWindowLongPtr(hwnd, 0);

	switch (msg)
	{
		case WM_NCCREATE:
		{
			LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
			LPWAVIN lpWavIn = (LPWAVIN) lpcs->lpCreateParams;

			// store lpWavIn in window extra bytes
			//
			SetWindowLongPtr(hwnd, 0, (LONG_PTR) lpWavIn);

			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
		}
			break;

		case MM_WIM_OPEN:
		{
			HWAVEIN hWaveIn = (HWAVEIN) wParam;

		 	TraceOutput(NULL, 5,
				TEXT("MM_WIM_OPEN\n"));

#ifdef MULTITHREAD
			if (!(lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
				hWaveIn != lpWavIn->hWaveIn)
#else
			if (hWaveIn != lpWavIn->hWaveIn)
#endif
				fSuccess = TraceFALSE(NULL);

			else
			{
				lpWavIn->fIsOpen = TRUE;

#ifdef MULTITHREAD
				// notify main thread that device is open
				//
				if ((lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
					!SetEvent(lpWavIn->hEventDeviceOpened))
				{
					fSuccess = TraceFALSE(NULL);
				}
#endif
				// send notification of device opening
				//
#ifdef MULTITHREAD
				if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
				{
					if ( lpWavIn->hwndNotify )
						PostThreadMessage( HandleToUlong(lpWavIn->hwndNotify), WM_WAVIN_OPEN, 0, 0);
				}
				else
#endif
				{
					if (lpWavIn->hwndNotify != NULL &&
						IsWindow(lpWavIn->hwndNotify))
					{
						SendMessage(lpWavIn->hwndNotify, WM_WAVIN_OPEN, 0, 0);
					}
				}
			}

			lResult = 0L;
		}
			break;

		case MM_WIM_CLOSE:
		{
			HWAVEIN hWaveIn = (HWAVEIN) wParam;

		 	TraceOutput(NULL, 5,
				TEXT("MM_WIM_CLOSE\n"));

#ifdef MULTITHREAD
			if (!(lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
				hWaveIn != lpWavIn->hWaveIn)
#else
			if (hWaveIn != lpWavIn->hWaveIn)
#endif
				fSuccess = TraceFALSE(NULL);

			else
			{
				lpWavIn->fIsOpen = FALSE;

				// send notification of device closure
				//
#ifdef MULTITHREAD
				if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
				{
					if ( lpWavIn->hwndNotify )
						PostThreadMessage(HandleToUlong(lpWavIn->hwndNotify), WM_WAVIN_CLOSE, 0, 0);
				}
				else
#endif
				{
					if (lpWavIn->hwndNotify != NULL &&
						IsWindow(lpWavIn->hwndNotify))
					{
						SendMessage(lpWavIn->hwndNotify, WM_WAVIN_CLOSE, 0, 0);
					}
				}
#ifdef MULTITHREAD
				// notify main thread that device is closed
				//
				if ((lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
					!SetEvent(lpWavIn->hEventDeviceClosed))
				{
					fSuccess = TraceFALSE(NULL);
				}
#endif
			}

			lResult = 0L;
		}
			break;

		case MM_WIM_DATA:
		{
			HWAVEIN hWaveIn = (HWAVEIN) wParam;
			LPWAVEHDR lpWaveHdr = (LPWAVEHDR) lParam;
			LPVOID lpBuf;
			long sizBuf;
			long lBytesRecorded;

		 	TracePrintf_1(NULL, 5,
		 		TEXT("MM_WIM_DATA (%lu)\n"),
	 			(unsigned long) lpWaveHdr->dwBytesRecorded);

#ifdef MULTITHREAD
			if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
				EnterCriticalSection(&(lpWavIn->critSectionStop));
#endif
#ifdef MULTITHREAD
			if (!(lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
				hWaveIn != lpWavIn->hWaveIn)
#else
			if (hWaveIn != lpWavIn->hWaveIn)
#endif
				fSuccess = TraceFALSE(NULL);

			else if (lpWaveHdr == NULL)
				fSuccess = TraceFALSE(NULL);

			// NULL buffer is possible with telephone, this is ok
			// 
			else if ((lpBuf = (LPVOID) lpWaveHdr->lpData) == NULL, FALSE)
				;

			else if (sizBuf = (long) lpWaveHdr->dwBufferLength, FALSE)
				fSuccess = TraceFALSE(NULL);

			else if (lBytesRecorded = (long) lpWaveHdr->dwBytesRecorded, FALSE)
				fSuccess = TraceFALSE(NULL);

			else if (!(lpWaveHdr->dwFlags & WHDR_DONE))
				fSuccess = TraceFALSE(NULL);

			else if (!(lpWaveHdr->dwFlags & WHDR_PREPARED))
				fSuccess = TraceFALSE(NULL);

			else if ((lpWavIn->nLastError = waveInUnprepareHeader(
				lpWavIn->hWaveIn, lpWaveHdr, sizeof(WAVEHDR))) != 0)
			{
				fSuccess = TraceFALSE(NULL);
			 	TracePrintf_1(NULL, 5,
			 		TEXT("waveInUnprepareHeader failed (%u)\n"),
		 			(unsigned) lpWavIn->nLastError);
			}

			else if ((lpWaveHdr = MemFree(NULL, lpWaveHdr)) != NULL)
				fSuccess = TraceFALSE(NULL);

			else if (--lpWavIn->cBufsPending < 0)
				fSuccess = TraceFALSE(NULL);

			// device is no longer recording if no more buffers pending
			//
			else if (lpWavIn->cBufsPending == 0)
			{
				lpWavIn->wState = WAVIN_STOPPED;

#ifdef MULTITHREAD
				// notify main thread that device is stopped
				//
				if ((lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
					lpWavIn->hEventDeviceStopped != NULL &&
					!SetEvent(lpWavIn->hEventDeviceStopped))
				{
					fSuccess = TraceFALSE(NULL);
				}
#endif
			}

			if (fSuccess)
			{
				RECORDDONE recorddone;

				recorddone.lpBuf = lpBuf;
				recorddone.sizBuf = sizBuf;
				recorddone.lBytesRecorded = lBytesRecorded;

				// send notification of recording completion
				//
#ifdef MULTITHREAD
				if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
				{
					if ( lpWavIn->hwndNotify )
					{
						SendThreadMessage(HandleToUlong(lpWavIn->hwndNotify),
							WM_WAVIN_RECORDDONE, (LPARAM) (LPVOID) &recorddone);
					}
				}
				else
#endif
				{
					if (lpWavIn->hwndNotify != NULL &&
						IsWindow(lpWavIn->hwndNotify))
					{
						SendMessage(lpWavIn->hwndNotify,
							WM_WAVIN_RECORDDONE, 0, (LPARAM) (LPVOID) &recorddone);
					}
				}
			}

			lResult = 0L;
#ifdef MULTITHREAD
			if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
				LeaveCriticalSection(&(lpWavIn->critSectionStop));
#endif
		}
			break;

		default:
			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
			break;
	}
	
	return lResult;
}

// WavInGetPtr - verify that wavin handle is valid,
//		<hWavIn>				(i) handle returned from WavInInit
// return corresponding wavin pointer (NULL if error)
//
static LPWAVIN WavInGetPtr(HWAVIN hWavIn)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;

	if ((lpWavIn = (LPWAVIN) hWavIn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpWavIn, sizeof(WAVIN)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the wavin handle
	//
	else if (lpWavIn->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpWavIn : NULL;
}

// WavInGetHandle - verify that wavin pointer is valid,
//		<lpWavIn>				(i) pointer to WAVIN struct
// return corresponding wavin handle (NULL if error)
//
static HWAVIN WavInGetHandle(LPWAVIN lpWavIn)
{
	BOOL fSuccess = TRUE;
	HWAVIN hWavIn;

	if ((hWavIn = (HWAVIN) lpWavIn) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hWavIn : NULL;
}

#ifdef MULTITHREAD

static LRESULT SendThreadMessage(DWORD dwThreadId, UINT Msg, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	HANDLE hEventMessageProcessed = NULL;
	DWORD dwRet;

	// we need to know when message has been processed
	//
	if ((hEventMessageProcessed = CreateEvent(
		NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// post message to thread, send event handle as wParam
	//
	else if (!PostThreadMessage(dwThreadId, Msg, (WPARAM) hEventMessageProcessed, lParam))
	{
		fSuccess = TraceFALSE(NULL);
	}

	// wait for the message to be processed
	//
	else if ((dwRet = WaitForSingleObject(
		hEventMessageProcessed, INFINITE)) != WAIT_OBJECT_0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (hEventMessageProcessed != NULL)
	{
		if (!CloseHandle(hEventMessageProcessed))
			fSuccess = TraceFALSE(NULL);
		else
			hEventMessageProcessed = NULL;
	}

	return 0L;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\wavout.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wavout.c - wav output device functions
////

#include "winlocal.h"

#include "wavout.h"
#include "wav.h"
#include "acm.h"
#include "calc.h"
#include "mem.h"
#include "str.h"
#include "sys.h"
#include "trace.h"
#include <mmddk.h>

// allow telephone output functions if defined
//
#ifdef TELOUT
#include "telout.h"
static HTELOUT hTelOut = NULL;
#endif

////
//	private definitions
////

#define WAVOUTCLASS TEXT("WavOutClass")

// wavout control struct
//
typedef struct WAVOUT
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	UINT idDev;
	LPWAVEFORMATEX lpwfx;
	HWND hwndNotify;
	DWORD dwFlags;
	BOOL fIsOpen;
	HWAVEOUT hWaveOut;
	WORD wState;
	HWND hwndCallback;
#ifdef MULTITHREAD
	HANDLE hThreadCallback;
	DWORD dwThreadId;
	HANDLE hEventThreadCallbackStarted;
	HANDLE hEventDeviceOpened;
	HANDLE hEventDeviceClosed;
	HANDLE hEventDeviceStopped;
	CRITICAL_SECTION critSectionStop;
#endif
	UINT nLastError;
	int cBufsPending;
} WAVOUT, FAR *LPWAVOUT;

#define VOLUME_MINLEVEL 0
#define VOLUME_MAXLEVEL 100
#define VOLUME_POSITIONS (VOLUME_MAXLEVEL - VOLUME_MINLEVEL)

// helper functions
//
LRESULT DLLEXPORT CALLBACK WavOutCallback(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#ifdef MULTITHREAD
DWORD WINAPI WavOutCallbackThread(LPVOID lpvThreadParameter);
#endif
static LPWAVOUT WavOutGetPtr(HWAVOUT hWavOut);
static HWAVOUT WavOutGetHandle(LPWAVOUT lpWavOut);
#ifdef MULTITHREAD
static LRESULT SendThreadMessage(DWORD dwThreadId, UINT Msg, LPARAM lParam);
#endif

////
//	public functions
////

// WavOutGetDeviceCount - return number of wav output devices found
//		<void>				this function takes no arguments
// return number of wav output devices found (0 if none)
//
int DLLEXPORT WINAPI WavOutGetDeviceCount(void)
{
	return waveOutGetNumDevs();
}

// WavOutDeviceIsOpen - check if output device is open
//		<idDev>				(i) device id
//			-1					open any suitable output device
// return TRUE if open
//
BOOL DLLEXPORT WINAPI WavOutDeviceIsOpen(int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL fIsOpen = FALSE;
	WAVEFORMATEX wfx;
	HWAVEOUT hWaveOut = NULL;
	int nLastError;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID)
		return TelOutDeviceIsOpen(idDev);
#endif

	// try to open device
	//
	if ((nLastError = waveOutOpen(&hWaveOut, idDev, 
#ifndef _WIN32
			(LPWAVEFORMAT)
#endif
		WavFormatPcm(-1, -1, -1, &wfx),
		0, 0, WAVE_ALLOWSYNC)) != 0)
	{
		if (nLastError == MMSYSERR_ALLOCATED)
			fIsOpen = TRUE; // device in use

		else
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutOpen failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	// close device
	//
	else if (waveOutClose(hWaveOut) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? fIsOpen : FALSE;
}

// WavOutOpen - open wav output device
//		<dwVersion>			(i) must be WAVOUT_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<idDev>				(i) device id
//			-1					open any suitable output device
//		<lpwfx>				(i) wave format
//		<hwndNotify>		(i) notify this window of device events
//			NULL				do not notify
//		<msTimeoutOpen>		(i) device open timeout in milleseconds
//			0					default timeout (30000)
//		<msTimeoutRetry>	(i) device retry timeout in milleseconds
//			0					default timeout (2000)
//		<dwFlags>			(i) control flags
//			WAVOUT_NOSYNC		do not open synchronous devices
//			WAVOUT_AUTOFREE		free each buffer after playback
//			WAVOUT_OPENRETRY	retry if device busy
//			WAVOUT_OPENASYNC	return before notification of device open
//			WAVOUT_CLOSEASYNC	return before notification of device close
//			WAVOUT_NOACM		do not use audio compression manager
//			WAVOUT_TELRFILE		telephone will play/record audio on server
#ifdef MULTITHREAD
//			WAVOUT_MULTITHREAD	support multiple threads
#endif
// return handle (NULL if error)
//
// NOTE: if <hwndNotify> is specified in WavOutOpen,
// WM_WAVOUT_OPEN will be sent to <hwndNotify>,
// when output device has been opened.
//
// NOTE: if WAVOUT_MULTITHREAD is specified in <dwFlags>,
// it is assumed that <hwndNotify> is not a window handle,
// but rather the id of the thread to receive notifications
//
HWAVOUT DLLEXPORT WINAPI WavOutOpen(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut = NULL;
	WNDCLASS wc;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID)
	{
		hTelOut = TelOutOpen(TELOUT_VERSION, hInst, idDev, lpwfx,
			hwndNotify, msTimeoutOpen, msTimeoutRetry, dwFlags);
		return (HWAVOUT) hTelOut;
	}
#endif

	if (dwVersion != WAVOUT_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavOut = (LPWAVOUT) MemAlloc(NULL, sizeof(WAVOUT), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpWavOut->dwVersion = dwVersion;
		lpWavOut->hInst = hInst;
		lpWavOut->hTask = GetCurrentTask();
		lpWavOut->idDev = (UINT) idDev;
		lpWavOut->lpwfx = NULL;
		lpWavOut->hwndNotify = hwndNotify;
		lpWavOut->dwFlags = dwFlags;
		lpWavOut->fIsOpen = FALSE;
		lpWavOut->hWaveOut = NULL;
		lpWavOut->wState = WAVOUT_STOPPED;
		lpWavOut->hwndCallback = NULL;
#ifdef MULTITHREAD
		lpWavOut->hThreadCallback = NULL;
		lpWavOut->dwThreadId = 0;
		lpWavOut->hEventThreadCallbackStarted = NULL;
		lpWavOut->hEventDeviceOpened = NULL;
		lpWavOut->hEventDeviceClosed = NULL;
		lpWavOut->hEventDeviceStopped = NULL;
#endif
		lpWavOut->nLastError = 0;
		lpWavOut->cBufsPending = 0;

		// memory is allocated such that the client app owns it
		//
		if ((lpWavOut->lpwfx = WavFormatDup(lpwfx)) == NULL)
			fSuccess = TraceFALSE(NULL);
	}

#ifdef MULTITHREAD
	// handle WAVOUT_MULTITHREAD flag
	//
	if (fSuccess && (lpWavOut->dwFlags & WAVOUT_MULTITHREAD))
	{
		DWORD dwRet;

		InitializeCriticalSection(&(lpWavOut->critSectionStop));

		// we need to know when device has been opened
		//
		if ((lpWavOut->hEventDeviceOpened = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// we need to know when callback thread begins execution
		//
		else if ((lpWavOut->hEventThreadCallbackStarted = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// create the callback thread
		//
		else if ((lpWavOut->hThreadCallback = CreateThread(
			NULL,
			0,
			WavOutCallbackThread,
			(LPVOID) lpWavOut,
			0,
			&lpWavOut->dwThreadId)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// wait for the callback thread to begin execution
		//
		else if ((dwRet = WaitForSingleObject(
			lpWavOut->hEventThreadCallbackStarted, 10000)) != WAIT_OBJECT_0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// clean up
		//
		if (lpWavOut->hEventThreadCallbackStarted != NULL)
		{
			if (!CloseHandle(lpWavOut->hEventThreadCallbackStarted))
				fSuccess = TraceFALSE(NULL);
			else
				lpWavOut->hEventThreadCallbackStarted = NULL;
		}
	}
	else
#endif
	{
		// register callback class unless it has been already
		//
		if (fSuccess && GetClassInfo(lpWavOut->hInst, WAVOUTCLASS, &wc) == 0)
		{
			wc.hCursor =		NULL;
			wc.hIcon =			NULL;
			wc.lpszMenuName =	NULL;
			wc.hInstance =		lpWavOut->hInst;
			wc.lpszClassName =	WAVOUTCLASS;
			wc.hbrBackground =	NULL;
			wc.lpfnWndProc =	WavOutCallback;
			wc.style =			0L;
			wc.cbWndExtra =		sizeof(lpWavOut);
			wc.cbClsExtra =		0;

			if (!RegisterClass(&wc))
				fSuccess = TraceFALSE(NULL);
		}

		// create the callback window
		//
		if (fSuccess && (lpWavOut->hwndCallback = CreateWindowEx(
			0L,
			WAVOUTCLASS,
			NULL,
			0L,
			0, 0, 0, 0,
			NULL,
			NULL,
			lpWavOut->hInst,
			lpWavOut)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}

	if (fSuccess)
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutRetry == 0 ? 2000L : msTimeoutRetry);
		DWORD dwCallback;
		DWORD dwFlags;

#ifdef MULTITHREAD
		if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
		{
			dwCallback = lpWavOut->dwThreadId;
			dwFlags = CALLBACK_THREAD;
		}
		else
#endif
		{
			dwCallback = HandleToUlong(lpWavOut->hwndCallback);
			dwFlags = CALLBACK_WINDOW;
		}

		// allow synchronous device drivers unless WAVOUT_NOSYNC specified
		//
		if (!(lpWavOut->dwFlags & WAVOUT_NOSYNC))
			dwFlags |= WAVE_ALLOWSYNC;

		// open the device
		//
		while (fSuccess && (lpWavOut->nLastError = waveOutOpen(&lpWavOut->hWaveOut,
			(UINT) lpWavOut->idDev,
#ifndef _WIN32
			(LPWAVEFORMAT)
#endif
			lpWavOut->lpwfx, dwCallback, 0, dwFlags)) != 0)
		{
			// no need to retry unless the device is busy
			//
			if (lpWavOut->nLastError != MMSYSERR_ALLOCATED)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("waveOutOpen failed (%u)\n"),
					(unsigned) lpWavOut->nLastError);
			}

			// no need to retry if flag not set
			//
			else if (!(lpWavOut->dwFlags & WAVOUT_OPENRETRY))
				fSuccess = TraceFALSE(NULL);

			// no more retries if timeout occurred
			//
			else if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else
			{
				MSG msg;

				if (PeekMessage(&msg, lpWavOut->hwndCallback, 0, 0, PM_REMOVE))
				{
				 	TranslateMessage(&msg);
				 	DispatchMessage(&msg);
				}

				else
#ifdef _WIN32
					Sleep(100);
#else
        		    WaitMessage();
#endif
			}
		}
	}

	// make sure a handle was returned
	//
	if (fSuccess && lpWavOut->hWaveOut == NULL)
		fSuccess = TraceFALSE(NULL);

	// wait for device open notification or timeout
	//
	if (fSuccess && !(lpWavOut->dwFlags & WAVOUT_OPENASYNC))
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutOpen == 0 ? 2000L : msTimeoutOpen);

#ifdef MULTITHREAD
		if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
		{
			DWORD dwRet;

			// wait for the device to be opened
			//
			if ((dwRet = WaitForSingleObject(
				lpWavOut->hEventDeviceOpened,
				(msTimeoutOpen == 0 ? 30000L : msTimeoutOpen))) != WAIT_OBJECT_0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}
		else
#endif
		while (fSuccess && !lpWavOut->fIsOpen)
		{
			MSG msg;

			if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else if (PeekMessage(&msg, lpWavOut->hwndCallback, 0, 0, PM_REMOVE))
			{
			 	TranslateMessage(&msg);
			 	DispatchMessage(&msg);
			}

			else
        	    WaitMessage();
		}
	}

#ifdef MULTITHREAD
	// clean up
	//
	if (lpWavOut != NULL && lpWavOut->hEventDeviceOpened != NULL)
	{
		if (!CloseHandle(lpWavOut->hEventDeviceOpened))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavOut->hEventDeviceOpened = NULL;
	}
#endif

	if (fSuccess)
	{
		if ((lpWavOut->nLastError = waveOutGetID(lpWavOut->hWaveOut,
			&lpWavOut->idDev)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutGetID failed (%u)\n"),
				(unsigned) lpWavOut->nLastError);
		}
	}

	if (!fSuccess)
	{
		WavOutClose(WavOutGetHandle(lpWavOut), 0);
		lpWavOut = NULL;
	}

	return fSuccess ? WavOutGetHandle(lpWavOut) : NULL;
}

// WavOutClose - close wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<msTimeoutClose>	(i) device close timeout in milleseconds
//			0					default timeout (30000)
// return 0 if success
//
// NOTE: if <hwndNotify> was specified in WavOutOpen,
// WM_WAVOUT_CLOSE will be sent to <hwndNotify>,
// when output device has been closed.
//
int DLLEXPORT WINAPI WavOutClose(HWAVOUT hWavOut, DWORD msTimeoutClose)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
	{
		int iRet = TelOutClose((HTELOUT) hWavOut, msTimeoutClose);
		hTelOut = NULL;
		return iRet;
	}
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// stop the device
	//
	else if (WavOutStop(hWavOut, 0) != 0)
		fSuccess = TraceFALSE(NULL);

#ifdef MULTITHREAD
	// we need to know when device has been closed
	//
	else if ((lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
		(lpWavOut->hEventDeviceClosed = CreateEvent(
		NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#endif

	// close the device
	//
	else if (lpWavOut->hWaveOut != NULL &&
		(lpWavOut->nLastError = waveOutClose(lpWavOut->hWaveOut)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("wavOutClose failed (%u)\n"),
	 		(unsigned) lpWavOut->nLastError);
	}

	// wait for device close notification or timeout
	//
	if (fSuccess && !(lpWavOut->dwFlags & WAVOUT_CLOSEASYNC))
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutClose == 0 ? 30000L : msTimeoutClose);

#ifdef MULTITHREAD
		if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
		{
			DWORD dwRet;

			// wait for the device to be closed
			//
			if ((dwRet = WaitForSingleObject(
				lpWavOut->hEventDeviceClosed,
				(msTimeoutClose == 0 ? 30000L : msTimeoutClose))) != WAIT_OBJECT_0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}
		else
#endif
		while (fSuccess && lpWavOut->fIsOpen)
		{
			MSG msg;

			if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else if (PeekMessage(&msg, lpWavOut->hwndCallback, 0, 0, PM_REMOVE))
			{
			 	TranslateMessage(&msg);
			 	DispatchMessage(&msg);
			}

			else
        	    WaitMessage();
		}
	}

#ifdef MULTITHREAD
	// clean up
	//
	if (lpWavOut != NULL && lpWavOut->hEventDeviceClosed != NULL)
	{
		if (!CloseHandle(lpWavOut->hEventDeviceClosed))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavOut->hEventDeviceClosed = NULL;
	}

	if (lpWavOut != NULL && lpWavOut->hThreadCallback != NULL)
	{
		if (!CloseHandle(lpWavOut->hThreadCallback))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavOut->hThreadCallback = NULL;
	}
#endif

	if (fSuccess)
	{
#ifdef MULTITHREAD
	   	if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
		{
			while (lpWavOut->critSectionStop.OwningThread != NULL)
				Sleep(100L);

			DeleteCriticalSection(&(lpWavOut->critSectionStop));
		}
#endif
		// device handle is no longer valid
		//
		lpWavOut->hWaveOut = NULL;

		// destroy callback window
		//
		if (lpWavOut->hwndCallback != NULL &&
			!DestroyWindow(lpWavOut->hwndCallback))
			fSuccess = TraceFALSE(NULL);

		else if (lpWavOut->hwndCallback = NULL, FALSE)
			fSuccess = TraceFALSE(NULL);

		else if (lpWavOut->lpwfx != NULL &&
			WavFormatFree(lpWavOut->lpwfx) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (lpWavOut->lpwfx = NULL, FALSE)
			fSuccess = TraceFALSE(NULL);

		else if ((lpWavOut = MemFree(NULL, lpWavOut)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavOutPlay - submit buffer of samples to wav output device for playback
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<lpBuf>				(i) pointer to buffer containing samples
//		<sizBuf>			(i) size of buffer in bytes
// return 0 if success
//
// NOTE: the buffer pointed to by <lpBuf> must have been allocated
// using MemAlloc().
//
// NOTE: if <hwndNotify> is specified in WavOutOpen(), a WM_WAVOUT_PLAYDONE
// message will be sent to <hwndNotify>, with <lParam> set to a pointer to
// a PLAYDONE structure, when <lpBuf> has been played.
//
// NOTE: if WAVOUT_AUTOFREE flag is specified in WavOutOpen,
// GlobalFreePtr(lpBuf) will be called when <lpBuf> has been played.
//
int DLLEXPORT WINAPI WavOutPlay(HWAVOUT hWavOut, LPVOID lpBuf, long sizBuf)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	LPWAVEHDR lpWaveHdr = NULL;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutPlay((HTELOUT) hWavOut, lpBuf, sizBuf, -1);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpBuf == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWaveHdr = (LPWAVEHDR) MemAlloc(NULL,
		sizeof(WAVEHDR), 0)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	else
	{
		lpWaveHdr->lpData = (LPSTR) lpBuf;
		lpWaveHdr->dwBufferLength = (DWORD) sizBuf;

		if ((lpWavOut->nLastError = waveOutPrepareHeader(lpWavOut->hWaveOut,
			lpWaveHdr, sizeof(WAVEHDR))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		 	TracePrintf_1(NULL, 5,
		 		TEXT("waveOutPrepareHeader failed (%u)\n"),
	 			(unsigned) lpWavOut->nLastError);
		}

		else if ((lpWavOut->nLastError = waveOutWrite(lpWavOut->hWaveOut,
			lpWaveHdr, sizeof(WAVEHDR))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		 	TracePrintf_1(NULL, 5,
		 		TEXT("waveOutWrite failed (%u)\n"),
	 			(unsigned) lpWavOut->nLastError);
		}

		else
		{
			++lpWavOut->cBufsPending;
			lpWavOut->wState = WAVOUT_PLAYING;
		}
	}

	return fSuccess ? 0 : -1;
}

// WavOutStop - stop playback of buffer(s) sent to wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<msTimeoutStop>		(i) device stop timeout in milleseconds
//			0					default timeout (2000)
// return 0 if success
//
int DLLEXPORT WINAPI WavOutStop(HWAVOUT hWavOut, DWORD msTimeoutStop)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutStop((HTELOUT) hWavOut, msTimeoutStop);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

#ifdef MULTITHREAD
	else if ((lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
		(EnterCriticalSection(&(lpWavOut->critSectionStop)), FALSE))
		;
#endif

	// make sure device is playing or paused
	//
	else if (WavOutGetState(hWavOut) == WAVOUT_STOPPED ||
		WavOutGetState(hWavOut) == WAVOUT_STOPPING)
		; // not an error to call this function when stopped or stopping

	else if (lpWavOut->wState = WAVOUT_STOPPING, FALSE)
		;

#ifdef MULTITHREAD
	// we need to know when device has been stopped
	//
	else if ((lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
		(lpWavOut->hEventDeviceStopped = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#endif

	// stop the device
	//
	else if ((lpWavOut->nLastError = waveOutReset(lpWavOut->hWaveOut)) != 0)
	{	
		fSuccess = TraceFALSE(NULL);
 		TracePrintf_1(NULL, 5,
 			TEXT("waveOutReset failed (%u)\n"),
			(unsigned) lpWavOut->nLastError);
	}

	// wait for device to be stopped
	//
#ifdef MULTITHREAD
	else if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
	{
		DWORD dwRet;

		LeaveCriticalSection(&(lpWavOut->critSectionStop));

		// wait for the device to be stopped
		//
		if ((dwRet = WaitForSingleObject(
			lpWavOut->hEventDeviceStopped,
			(msTimeoutStop == 0 ? 10000L : msTimeoutStop))) != WAIT_OBJECT_0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		EnterCriticalSection(&(lpWavOut->critSectionStop));
	}
#endif
	else
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutStop == 0 ? 2000L : msTimeoutStop);

		while (fSuccess && WavOutGetState(hWavOut) != WAVOUT_STOPPED)
		{
			MSG msg;

			// check for timeout
			//
			if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

#if 0 // this version doesn't seem to work with TCP/IP protocol
			else if (PeekMessage(&msg, lpWavOut->hwndCallback, 0, 0, PM_REMOVE))
#else
			else if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
#endif
			{
		 		TranslateMessage(&msg);
		 		DispatchMessage(&msg);
			}

			else
       			WaitMessage();
		}
	}

#ifdef MULTITHREAD
	// clean up
	//
	if (lpWavOut != NULL && lpWavOut->hEventDeviceStopped != NULL)
	{
		if (!CloseHandle(lpWavOut->hEventDeviceStopped))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavOut->hEventDeviceStopped = NULL;
	}

	if (lpWavOut != NULL && (lpWavOut->dwFlags & WAVOUT_MULTITHREAD))
		LeaveCriticalSection(&(lpWavOut->critSectionStop));
#endif

	return fSuccess ? 0 : -1;
}

// WavOutPause - pause wav output device playback
//		<hWavOut>			(i) handle returned from WavOutOpen
// return 0 if success
//
int DLLEXPORT WINAPI WavOutPause(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutPause((HTELOUT) hWavOut);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure device is playing or stopped
	//
	else if (WavOutGetState(hWavOut) == WAVOUT_PAUSED)
		; // not an error to call this function when already paused

	// pause the device
	//
	else if ((lpWavOut->nLastError = waveOutPause(lpWavOut->hWaveOut)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("waveOutPause failed (%u)\n"),
 			(unsigned) lpWavOut->nLastError);
	}

	else
		lpWavOut->wState = WAVOUT_PAUSED;

	return fSuccess ? 0 : -1;
}

// WavOutResume - resume wav output device playback
//		<hWavOut>			(i) handle returned from WavOutOpen
// return 0 if success
//
int DLLEXPORT WINAPI WavOutResume(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutResume((HTELOUT) hWavOut);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure the device is paused
	//
	else if (WavOutGetState(hWavOut) != WAVOUT_PAUSED)
		; // not an error to call this function when already playing

	// restart the device
	//
	else if ((lpWavOut->nLastError = waveOutRestart(lpWavOut->hWaveOut)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	  	TracePrintf_1(NULL, 5,
	  		TEXT("waveOutRestart failed (%u)\n"),
	 		(unsigned) lpWavOut->nLastError);
	}

	else
		lpWavOut->wState = WAVOUT_PLAYING;

	return fSuccess ? 0 : -1;
}

// WavOutGetState - return current wav output device state
//		<hWavOut>			(i) handle returned from WavOutOpen
// return WAVOUT_STOPPED, WAVOUT_PLAYING, WAVOUT_PAUSED, or 0 if error
//
WORD DLLEXPORT WINAPI WavOutGetState(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutGetState((HTELOUT) hWavOut);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWavOut->wState : 0;
}

// WavOutGetPosition - get milleseconds of elapsed playback
//		<hWavOut>			(i) handle returned from WavOutOpen
// return 0 if success
//
long DLLEXPORT WINAPI WavOutGetPosition(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	MMTIME mmtime;
	long msPosition;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutGetPosition((HTELOUT) hWavOut);
#endif

	MemSet(&mmtime, 0, sizeof(mmtime));

	// we will be requesting position in milleseconds
	//
	mmtime.wType = TIME_MS;

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get device position
	//
	else if ((lpWavOut->nLastError = waveOutGetPosition(
		lpWavOut->hWaveOut, &mmtime, sizeof(MMTIME))) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("waveOutGetPosition failed (%u)\n"),
 			(unsigned) lpWavOut->nLastError);
	}

	// see what type of position was returned
	//
	else switch (mmtime.wType)
	{
		case TIME_MS:
		{
			// we got milleseconds; no conversion required
			//
			msPosition = (long) mmtime.u.ms;
		}
			break;

		case TIME_SAMPLES:
		{
			// convert samples to millesconds
			//
			msPosition = (long) MULDIVU32(mmtime.u.sample,
				1000L, lpWavOut->lpwfx->nSamplesPerSec);
		}
			break;

		case TIME_BYTES:
		{
			// convert bytes to millesconds
			//
			msPosition = (long) MULDIVU32(mmtime.u.cb,
				1000L, lpWavOut->lpwfx->nAvgBytesPerSec);
		}
			break;

		case TIME_SMPTE:
		case TIME_MIDI:
		default:
			fSuccess = TraceFALSE(NULL);
			break;
	}

	return fSuccess ? msPosition : -1;
}

// WavOutGetId - return id of wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
// return device id (-1 if error)
//
int DLLEXPORT WINAPI WavOutGetId(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutGetId((HTELOUT) hWavOut);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWavOut->idDev : -1;
}

// WavOutGetName - get name of wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
//		<lpszName>			(o) buffer to hold device name
//		<sizName>			(i) size of buffer
// return 0 if success
//
int DLLEXPORT WINAPI WavOutGetName(HWAVOUT hWavOut, int idDev, LPTSTR lpszName, int sizName)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutGetName((HTELOUT) hWavOut, idDev, lpszName, sizName);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavOut->idDev;
	}

	if (fSuccess)
	{
		WAVEOUTCAPS woc;
		UINT nLastError;

		if ((nLastError = waveOutGetDevCaps(idDev, &woc, sizeof(WAVEOUTCAPS))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutGetDevCaps failed (%u)\n"),
				(unsigned) nLastError);
		}

		else if (lpszName != NULL)
			StrNCpy(lpszName, woc.szPname, sizName);

		if (hWavOut != NULL && lpWavOut != NULL)
			lpWavOut->nLastError = nLastError;
	}

	return fSuccess ? 0 : -1;
}

// WavOutGetIdByName - get id of wav output device, lookup by name
//		<lpszName>			(i) device name
#ifdef _WIN32
//			NULL or TEXT("")	get preferred device id
#endif
//		<dwFlags>			(i) reserved; must be zero
// return device id (-1 if error)
//
int WINAPI WavOutGetIdByName(LPCTSTR lpszName, DWORD dwFlags)
{
	UINT idDev;
	UINT cDev = (UINT) WavInGetDeviceCount();

	// If no device specified, get the preferred device
	if ( !lpszName || (_tcslen(lpszName) <= 0) )
	{
		DWORD dwTemp;
		DWORD dwRet = waveOutMessage( (HWAVEOUT)(DWORD_PTR)WAVE_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &idDev, (DWORD_PTR) &dwTemp );
		if ( dwRet == MMSYSERR_NOERROR )
			return idDev;
	}
	else
	{
		// Device specified, search by name
		for ( idDev = 0; idDev < cDev; ++idDev )
		{
			TCHAR szName[256];
			if ( WavOutGetName(NULL, idDev, szName, SIZEOFARRAY(szName)) == 0 )
			{
				if ( _tcsicmp(lpszName, szName) == 0 )
					return idDev;
			}
		}
	}

	// No match for device name
	TraceFALSE(NULL);
	return -1;
}

// WavOutSupportsFormat - return TRUE if device supports specified format
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
//		<lpwfx>				(i) wave format
// return TRUE if device supports specified format
//
BOOL DLLEXPORT WINAPI WavOutSupportsFormat(HWAVOUT hWavOut, int idDev,
	LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	BOOL fSupportsFormat;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutSupportsFormat((HTELOUT) hWavOut, idDev, lpwfx);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavOut->idDev;
	}

	if (fSuccess)
	{
		UINT nLastError;

		// query the device
		//
		if ((nLastError = waveOutOpen(NULL, (UINT) idDev,
#ifndef _WIN32
			(LPWAVEFORMAT)
#endif
			lpwfx, 0, 0,
			WAVE_FORMAT_QUERY | WAVE_ALLOWSYNC)) != 0)
		{
			fSupportsFormat = FALSE;
#if 1
			if (TraceGetLevel(NULL) >= 9)
			{
				TracePrintf_0(NULL, 9,
					TEXT("unsupported format:\n"));
				WavFormatDump(lpwfx);
			}
#endif
			if (nLastError != WAVERR_BADFORMAT)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("waveOutOpen/FormatQuery failed (%u)\n"),
					(unsigned) nLastError);
			}
		}

		else
			fSupportsFormat = TRUE;

		if (hWavOut != NULL && lpWavOut != NULL)
			lpWavOut->nLastError = nLastError;
	}

	return fSuccess ? fSupportsFormat : FALSE;
}

// WavOutFormatSuggest - suggest a new format which the device supports
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
//		<lpwfxSrc>			(i) source format
//		<dwFlags>			(i)	control flags
//			WAVOUT_NOACM		do not use audio compression manager
// return pointer to suggested format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavOutFormatSuggest(
	HWAVOUT hWavOut, int idDev,	LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	LPWAVEFORMATEX lpwfxSuggest = NULL;
	LPWAVEFORMATEX lpwfxTemp = NULL;
	HACM hAcm = NULL;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutFormatSuggest((HTELOUT) hWavOut, idDev, lpwfxSrc, dwFlags);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
		{
			idDev = lpWavOut->idDev;
			if (lpWavOut->dwFlags & WAVOUT_NOACM)
				dwFlags |= WAVOUT_NOACM;
		}
	}

	if ((hAcm = AcmInit(ACM_VERSION, SysGetTaskInstance(NULL),
		(dwFlags & WAVOUT_NOACM) ? ACM_NOACM : 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfxSrc))
		fSuccess = TraceFALSE(NULL);

	else if ((lpwfxTemp = WavFormatDup(lpwfxSrc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get suggested format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			-1, -1, -1, -1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavOutSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->wFormatTag != WAVE_FORMAT_PCM)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, -1, -1, -1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavOutSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM mono format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->nChannels != 1)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, -1, -1, 1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavOutSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM 8-bit mono format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->wBitsPerSample != 8)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, -1, 8, 1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavOutSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM 11025Hz 8-bit mono format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->nSamplesPerSec != 11025)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, 11025, 8, 1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavOutSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// last resort; see if MULAW 8000Hz 8-bit mono format is supported
	//
	if (fSuccess && lpwfxSuggest == NULL)
	{
#if 0
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_MULAW, 8000, 8, 1, 0)) == NULL)
#else
		if ((lpwfxSuggest = WavFormatMulaw(NULL, 8000)) == NULL)
#endif
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavOutSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			// no more chances for success
			//
			fSuccess = TraceFALSE(NULL);
			if (WavFormatFree(lpwfxSuggest) != 0)
				fSuccess = TraceFALSE(NULL);
		}
	}

	// clean up
	//
	if (hAcm != NULL && AcmTerm(hAcm) != 0)
		fSuccess = TraceFALSE(NULL);
	else
		hAcm = NULL;

	return fSuccess ? lpwfxSuggest : NULL;
}

// WavOutIsSynchronous - return TRUE if wav output device is synchronous
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
// return TRUE if wav output device is synchronous
//
BOOL DLLEXPORT WINAPI WavOutIsSynchronous(HWAVOUT hWavOut, int idDev)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	BOOL fIsSynchronous;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutIsSynchronous((HTELOUT) hWavOut, idDev);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavOut->idDev;
	}

	if (fSuccess)
	{
		WAVEOUTCAPS woc;
		UINT nLastError;

		if ((nLastError = waveOutGetDevCaps(idDev, &woc, sizeof(WAVEOUTCAPS))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutGetDevCaps failed (%u)\n"),
				(unsigned) nLastError);
		}

		else
			fIsSynchronous = (BOOL) (woc.dwSupport & WAVECAPS_SYNC);

		if (hWavOut != NULL && lpWavOut != NULL)
			lpWavOut->nLastError = nLastError;
	}

	return fSuccess ? fIsSynchronous : FALSE;
}

// WavOutSupportsVolume - return TRUE if device supports volume control
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return TRUE if device supports volume control
//
BOOL DLLEXPORT WINAPI WavOutSupportsVolume(HWAVOUT hWavOut, int idDev)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	BOOL fSupportsVolume;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutSupportsVolume((HTELOUT) hWavOut, idDev);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavOut->idDev;
	}

	if (fSuccess)
	{
		WAVEOUTCAPS woc;
		UINT nLastError;

		if ((nLastError = waveOutGetDevCaps(idDev, &woc, sizeof(WAVEOUTCAPS))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutGetDevCaps failed (%u)\n"),
				(unsigned) nLastError);
		}

		else
			fSupportsVolume = (BOOL) (woc.dwSupport & WAVECAPS_VOLUME);

		if (hWavOut != NULL && lpWavOut != NULL)
			lpWavOut->nLastError = nLastError;
	}

	return fSuccess ? fSupportsVolume : FALSE;
}

// WavOutSupportsSpeed - return TRUE if device supports speed control
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return TRUE if device supports speed control
//
BOOL DLLEXPORT WINAPI WavOutSupportsSpeed(HWAVOUT hWavOut, int idDev)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	BOOL fSupportsSpeed;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutSupportsSpeed((HTELOUT) hWavOut, idDev);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavOut->idDev;
	}

	if (fSuccess)
	{
		WAVEOUTCAPS woc;
		UINT nLastError;

		if ((nLastError = waveOutGetDevCaps(idDev, &woc, sizeof(WAVEOUTCAPS))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutGetDevCaps failed (%u)\n"),
				(unsigned) nLastError);
		}

		else
			fSupportsSpeed = (BOOL) (woc.dwSupport & WAVECAPS_PLAYBACKRATE);

		if (hWavOut != NULL && lpWavOut != NULL)
			lpWavOut->nLastError = nLastError;
	}

	return fSuccess ? fSupportsSpeed : FALSE;
}

// WavOutSupportsPitch - return TRUE if device supports pitch control
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return TRUE if device supports pitch control
//
BOOL DLLEXPORT WINAPI WavOutSupportsPitch(HWAVOUT hWavOut, int idDev)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	BOOL fSupportsPitch;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutSupportsPitch((HTELOUT) hWavOut, idDev);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavOut->idDev;
	}

	if (fSuccess)
	{
		WAVEOUTCAPS woc;
		UINT nLastError;

		if ((nLastError = waveOutGetDevCaps(idDev, &woc, sizeof(WAVEOUTCAPS))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutGetDevCaps failed (%u)\n"),
				(unsigned) nLastError);
		}

		else
			fSupportsPitch = (BOOL) (woc.dwSupport & WAVECAPS_PITCH);

		if (hWavOut != NULL && lpWavOut != NULL)
			lpWavOut->nLastError = nLastError;
	}

	return fSuccess ? fSupportsPitch : FALSE;
}

// WavOutGetVolume - get current volume level
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int DLLEXPORT WINAPI WavOutGetVolume(HWAVOUT hWavOut, int idDev)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	UINT nLastError;
	DWORD dwVolume;
	int nLevel;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutGetVolume((HTELOUT) hWavOut);
#endif

	if (hWavOut != NULL && (lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((nLastError = waveOutGetVolume(
#ifdef _WIN32
#if (WINVER < 0x0400)
		(UINT)
#endif
		(hWavOut == NULL ? (HWAVEOUT)IntToPtr(idDev) : lpWavOut->hWaveOut),
#else
		(hWavOut == NULL ? (HWAVEOUT)IntToPtr(idDev) : (HWAVEOUT)IntToPtr(lpWavOut->idDev)),
#endif
		&dwVolume)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("waveOutGetVolume failed (%u)\n"),
			(unsigned) nLastError);
	}

	else
	{
		nLevel = LOWORD(dwVolume) / (0xFFFF / VOLUME_POSITIONS);

		TracePrintf_2(NULL, 5,
			TEXT("WavOutGetVolume() = %d, 0x%08lX\n"),
			(int) nLevel,
			(unsigned long) dwVolume);
	}

	if (hWavOut != NULL && lpWavOut != NULL)
		lpWavOut->nLastError = nLastError;

	return fSuccess ? nLevel : -1;
}

// WavOutSetVolume - set current volume level
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//		<nLevel>			(i) volume level
//			0					minimum volume
//			100					maximum volume
// return 0 if success
//
int DLLEXPORT WINAPI WavOutSetVolume(HWAVOUT hWavOut, int idDev, int nLevel)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	DWORD dwVolume = MAKELONG(nLevel * (0xFFFF / VOLUME_POSITIONS),
		nLevel * (0xFFFF / VOLUME_POSITIONS));
	UINT nLastError;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutSetVolume((HTELOUT) hWavOut, nLevel);
#endif

	if (hWavOut != NULL && (lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nLevel < VOLUME_MINLEVEL || nLevel > VOLUME_MAXLEVEL)
		fSuccess = TraceFALSE(NULL);

	else if ((nLastError = waveOutSetVolume(
#ifdef _WIN32
#if (WINVER < 0x0400)
		(UINT)
#endif
		(hWavOut == NULL ? (HWAVEOUT)IntToPtr(idDev) : lpWavOut->hWaveOut),
#else
		(hWavOut == NULL ? idDev : lpWavOut->idDev),
#endif
		dwVolume)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("waveOutSetVolume failed (%u)\n"),
			(unsigned) nLastError);
	}
	else
	{
		TracePrintf_2(NULL, 5,
			TEXT("WavOutSetVolume(%d) = 0x%08lX\n"),
			(int) nLevel,
			(unsigned long) dwVolume);
	}

	if (hWavOut != NULL && lpWavOut != NULL)
		lpWavOut->nLastError = nLastError;

	return fSuccess ? 0 : -1;
}

// WavOutGetSpeed - get current speed level
//		<hWavOut>			(i) handle returned from WavOutOpen
// return speed level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI WavOutGetSpeed(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	DWORD dwSpeed;
	int nLevel;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutGetSpeed((HTELOUT) hWavOut);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavOut->nLastError = waveOutGetPlaybackRate(lpWavOut->hWaveOut,
		&dwSpeed)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("waveOutGetPlaybackRate failed (%u)\n"),
			(unsigned) lpWavOut->nLastError);
	}

	else
	{
		WORD wSpeedInteger = HIWORD(dwSpeed);
		WORD wSpeedFraction = LOWORD(dwSpeed);

		nLevel = (int) (100 * wSpeedInteger) +
			(int) ((DWORD) wSpeedFraction * (DWORD) 100 / 0x10000);

		TracePrintf_2(NULL, 5,
			TEXT("WavOutGetSpeed() = %d, 0x%08lX\n"),
			(int) nLevel,
			(unsigned long) dwSpeed);
	}

	return fSuccess ? nLevel : -1;
}

// WavOutSetSpeed - set current speed level
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
// return 0 if success
//
int DLLEXPORT WINAPI WavOutSetSpeed(HWAVOUT hWavOut, int nLevel)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	WORD wSpeedInteger = nLevel / 100;
	WORD wSpeedFraction = (WORD) (0x10000 * (DWORD) (nLevel % 100L) / 100L);
	DWORD dwSpeed = MAKELONG(wSpeedFraction, wSpeedInteger);

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutSetSpeed((HTELOUT) hWavOut, nLevel);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavOut->nLastError = waveOutSetPlaybackRate(lpWavOut->hWaveOut,
		dwSpeed)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("waveOutSetPlaybackRate failed (%u)\n"),
			(unsigned) lpWavOut->nLastError);
	}

	else
	{
		TracePrintf_2(NULL, 5,
			TEXT("WavOutSetSpeed(%d) = 0x%08lX\n"),
			(int) nLevel,
			(unsigned long) dwSpeed);
	}

	return fSuccess ? 0 : -1;
}

// WavOutGetPitch - get current pitch level
//		<hWavOut>			(i) handle returned from WavOutOpen
// return pitch level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI WavOutGetPitch(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	DWORD dwPitch;
	int nLevel;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutGetPitch((HTELOUT) hWavOut);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavOut->nLastError = waveOutGetPitch(lpWavOut->hWaveOut,
		&dwPitch)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("waveOutGetPitch failed (%u)\n"),
			(unsigned) lpWavOut->nLastError);
	}

	else
	{
		WORD wPitchInteger = HIWORD(dwPitch);
		WORD wPitchFraction = LOWORD(dwPitch);

		nLevel = (int) (100 * wPitchInteger) +
			(int) ((DWORD) wPitchFraction * (DWORD) 100 / 0x10000);

		TracePrintf_2(NULL, 5,
			TEXT("WavOutGetPitch() = %d, 0x%08lX\n"),
			(int) nLevel,
			(unsigned long) dwPitch);
	}

	return fSuccess ? nLevel : -1;
}

// WavOutSetPitch - set current pitch level
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<nLevel>			(i) pitch level
//			50					half pitch
//			100					normal pitch
//			200					double pitch, etc.
// return 0 if success
//
int DLLEXPORT WINAPI WavOutSetPitch(HWAVOUT hWavOut, int nLevel)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	WORD wPitchInteger = nLevel / 100;
	WORD wPitchFraction = (WORD) (0x10000 * (DWORD) (nLevel % 100L) / 100L);
	DWORD dwPitch = MAKELONG(wPitchFraction, wPitchInteger);

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutSetPitch((HTELOUT) hWavOut, nLevel);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavOut->nLastError = waveOutSetPitch(lpWavOut->hWaveOut,
		dwPitch)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("waveOutSetPitch failed (%u)\n"),
			(unsigned) lpWavOut->nLastError);
	}

	else
	{
		TracePrintf_2(NULL, 5,
			TEXT("WavOutSetPitch(%d) = 0x%08lX\n"),
			(int) nLevel,
			(unsigned long) dwPitch);
	}

	return fSuccess ? 0 : -1;
}

// WavOutTerm - shut down wav output residuals, if any
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
//			WAV_TELTHUNK		terminate telephone thunking layer
// return 0 if success
//
int DLLEXPORT WINAPI WavOutTerm(HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

#ifdef TELOUT
	else if ((dwFlags & WAV_TELTHUNK) &&
		TelOutTerm(hInst, dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

#ifdef MULTITHREAD
DWORD WINAPI WavOutCallbackThread(LPVOID lpvThreadParameter)
{
	BOOL fSuccess = TRUE;
	MSG msg;
	LPWAVOUT lpWavOut = (LPWAVOUT) lpvThreadParameter;

	// make sure message queue is created before calling SetEvent
	//
	PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

	// notify main thread that callback thread has begun execution
	//
	if (!SetEvent(lpWavOut->hEventThreadCallbackStarted))
	{
		fSuccess = TraceFALSE(NULL);
	}

	while (fSuccess && GetMessage(&msg, NULL, 0, 0))
	{
		WavOutCallback((HWND) lpWavOut, msg.message, msg.wParam, msg.lParam);

		// exit thread when when have processed last expected message
		//
		if (msg.message == MM_WOM_CLOSE)
			break;
	}

	return 0;
}
#endif

// WavOutCallback - window procedure for wavout callback
//
LRESULT DLLEXPORT CALLBACK WavOutCallback(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult;
	LPWAVOUT lpWavOut;
	
#ifdef MULTITHREAD
	if (!IsWindow(hwnd))
		lpWavOut = (LPWAVOUT) hwnd;
	else
#endif
	// retrieve lpWavOut from window extra bytes
	//
	lpWavOut = (LPWAVOUT) GetWindowLongPtr(hwnd, 0);

	switch (msg)
	{
		case WM_NCCREATE:
		{
			LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
			LPWAVOUT lpWavOut = (LPWAVOUT) lpcs->lpCreateParams;

			// store lpWavOut in window extra bytes
			//
			SetWindowLongPtr(hwnd, 0, (LONG_PTR) lpWavOut);

			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
		}
			break;

		case MM_WOM_OPEN:
		{
			HWAVEOUT hWaveOut = (HWAVEOUT) wParam;

		 	TraceOutput(NULL, 5,
				TEXT("MM_WOM_OPEN\n"));

#ifdef MULTITHREAD
			if (!(lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
				hWaveOut != lpWavOut->hWaveOut)
#else
			if (hWaveOut != lpWavOut->hWaveOut)
#endif
				fSuccess = TraceFALSE(NULL);

			else
			{
				lpWavOut->fIsOpen = TRUE;

#ifdef MULTITHREAD
				// notify main thread that device is open
				//
				if ((lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
					!SetEvent(lpWavOut->hEventDeviceOpened))
				{
					fSuccess = TraceFALSE(NULL);
				}
#endif
				// send notification of device opening
				//
#ifdef MULTITHREAD
				if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
				{
					if ( lpWavOut->hwndNotify )
						PostThreadMessage( HandleToUlong(lpWavOut->hwndNotify), WM_WAVOUT_OPEN, 0, 0);
				}
				else
#endif
				{
					if (lpWavOut->hwndNotify != NULL &&
						IsWindow(lpWavOut->hwndNotify))
					{
						SendMessage(lpWavOut->hwndNotify, WM_WAVOUT_OPEN, 0, 0);
					}
				}
			}

			lResult = 0L;
		}
			break;

		case MM_WOM_CLOSE:
		{
			HWAVEOUT hWaveOut = (HWAVEOUT) wParam;

		 	TraceOutput(NULL, 5,
				TEXT("MM_WOM_CLOSE\n"));

#ifdef MULTITHREAD
			if (!(lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
				hWaveOut != lpWavOut->hWaveOut)
#else
			if (hWaveOut != lpWavOut->hWaveOut)
#endif
				fSuccess = TraceFALSE(NULL);

			else
			{
				lpWavOut->fIsOpen = FALSE;

				// send notification of device closing
				//
#ifdef MULTITHREAD
				if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
				{
					if ( lpWavOut->hwndNotify )
						PostThreadMessage(HandleToUlong(lpWavOut->hwndNotify), WM_WAVOUT_CLOSE, 0, 0);
				}
				else
#endif
				{
					if (lpWavOut->hwndNotify != NULL &&
						IsWindow(lpWavOut->hwndNotify))
					{
						SendMessage(lpWavOut->hwndNotify, WM_WAVOUT_CLOSE, 0, 0);
					}
				}
#ifdef MULTITHREAD
				// notify main thread that device is closed
				//
				if ((lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
					!SetEvent(lpWavOut->hEventDeviceClosed))
				{
					fSuccess = TraceFALSE(NULL);
				}
#endif
			}

			lResult = 0L;
		}
			break;

		case MM_WOM_DONE:
		{
			HWAVEOUT hWaveOut = (HWAVEOUT) wParam;
			LPWAVEHDR lpWaveHdr = (LPWAVEHDR) lParam;
			LPVOID lpBuf;
			long sizBuf;
			BOOL fAutoFree = (BOOL) (lpWavOut->dwFlags & WAVOUT_AUTOFREE);

		 	TracePrintf_1(NULL, 5,
		 		TEXT("MM_WOM_DONE (%lu)\n"),
	 			(unsigned long) lpWaveHdr->dwBufferLength);

#ifdef MULTITHREAD
			if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
				EnterCriticalSection(&(lpWavOut->critSectionStop));
#endif

#ifdef MULTITHREAD
			if (!(lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
				hWaveOut != lpWavOut->hWaveOut)
#else
			if (hWaveOut != lpWavOut->hWaveOut)
#endif
				fSuccess = TraceFALSE(NULL);

			else if (lpWaveHdr == NULL)
				fSuccess = TraceFALSE(NULL);

			// NULL buffer is possible with telephone, this is ok
			// 
			else if ((lpBuf = (LPVOID) lpWaveHdr->lpData) == NULL, FALSE)
				;

			else if (sizBuf = (long) lpWaveHdr->dwBufferLength, FALSE)
				fSuccess = TraceFALSE(NULL);

			else if (!(lpWaveHdr->dwFlags & WHDR_DONE))
				fSuccess = TraceFALSE(NULL);

			else if (!(lpWaveHdr->dwFlags & WHDR_PREPARED))
				fSuccess = TraceFALSE(NULL);

			else if ((lpWavOut->nLastError = waveOutUnprepareHeader(
				lpWavOut->hWaveOut, lpWaveHdr, sizeof(WAVEHDR))) != 0)
			{
				fSuccess = TraceFALSE(NULL);
			 	TracePrintf_1(NULL, 5,
			 		TEXT("waveOutUnprepareHeader failed (%u)\n"),
		 			(unsigned) lpWavOut->nLastError);
			}

			else if ((lpWaveHdr = MemFree(NULL, lpWaveHdr)) != NULL)
				fSuccess = TraceFALSE(NULL);

			else if (--lpWavOut->cBufsPending < 0)
				fSuccess = TraceFALSE(NULL);

			// device is no longer playing if no more buffers pending
			//
			else if (lpWavOut->cBufsPending == 0)
			{
				lpWavOut->wState = WAVOUT_STOPPED;

#ifdef MULTITHREAD
				// notify main thread that device is stopped
				//
				if ((lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
					lpWavOut->hEventDeviceStopped != NULL &&
					!SetEvent(lpWavOut->hEventDeviceStopped))
				{
					fSuccess = TraceFALSE(NULL);
				}
#endif
			}

			if (fSuccess)
			{
				PLAYDONE playdone;

				playdone.lpBuf = lpBuf;
				playdone.sizBuf = sizBuf;

				// send notification of playback completion
				//
#ifdef MULTITHREAD
				if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
				{
					if ( lpWavOut->hwndNotify )
					{
						SendThreadMessage( HandleToUlong(lpWavOut->hwndNotify),
							WM_WAVOUT_PLAYDONE, (LPARAM) (LPVOID) &playdone);
					}
				}
				else
#endif
				{
					if (lpWavOut->hwndNotify != NULL &&
						IsWindow(lpWavOut->hwndNotify))
					{
						SendMessage(lpWavOut->hwndNotify,
							WM_WAVOUT_PLAYDONE, 0, (LPARAM) (LPVOID) &playdone);
					}
				}
			}

			// free data buffer if WAVOUT_AUTOFREE specified
			//
			if (fSuccess && fAutoFree)
			{
				if (lpBuf != NULL && (lpBuf = MemFree(NULL, lpBuf)) != NULL)
					fSuccess = TraceFALSE(NULL);
			}

			lResult = 0L;
#ifdef MULTITHREAD
			if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
				LeaveCriticalSection(&(lpWavOut->critSectionStop));
#endif
		}
			break;

		default:
			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
			break;
	}
	
	return lResult;
}

// WavOutGetPtr - verify that wavout handle is valid,
//		<hWavOut>				(i) handle returned from WavOutInit
// return corresponding wavout pointer (NULL if error)
//
static LPWAVOUT WavOutGetPtr(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

	if ((lpWavOut = (LPWAVOUT) hWavOut) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpWavOut, sizeof(WAVOUT)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the wavout handle
	//
	else if (lpWavOut->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpWavOut : NULL;
}

// WavOutGetHandle - verify that wavout pointer is valid,
//		<lpWavOut>				(i) pointer to WAVOUT struct
// return corresponding wavout handle (NULL if error)
//
static HWAVOUT WavOutGetHandle(LPWAVOUT lpWavOut)
{
	BOOL fSuccess = TRUE;
	HWAVOUT hWavOut;

	if ((hWavOut = (HWAVOUT) lpWavOut) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hWavOut : NULL;
}

#ifdef MULTITHREAD

static LRESULT SendThreadMessage(DWORD dwThreadId, UINT Msg, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	HANDLE hEventMessageProcessed = NULL;
	DWORD dwRet;

	// we need to know when message has been processed
	//
	if ((hEventMessageProcessed = CreateEvent(
		NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// post message to thread, send event handle as wParam
	//
	else if (!PostThreadMessage(dwThreadId, Msg, (WPARAM) hEventMessageProcessed, lParam))
	{
		fSuccess = TraceFALSE(NULL);
	}

	// wait for the message to be processed
	//
	else if ((dwRet = WaitForSingleObject(
		hEventMessageProcessed, INFINITE)) != WAIT_OBJECT_0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (hEventMessageProcessed != NULL)
	{
		if (!CloseHandle(hEventMessageProcessed))
			fSuccess = TraceFALSE(NULL);
		else
			hEventMessageProcessed = NULL;
	}

	return 0L;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\wavmixer.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wavmixer.h - wav mixer functions
////

#ifndef __WAVMIXER_H__
#define __WAVMIXER_H__

#include "winlocal.h"

#define WAVMIXER_VERSION 0x00000100

// handle to wavmixer engine
//
DECLARE_HANDLE32(HWAVMIXER);

#define WAVMIXER_HWAVEIN		0x00000001
#define WAVMIXER_HWAVEOUT		0x00000002
#define WAVMIXER_WAVEIN			0x00000004
#define WAVMIXER_WAVEOUT		0x00000008

#ifdef __cplusplus
extern "C" {
#endif

// WavMixerInit - initialize wav mixer device
//		<dwVersion>			(i) must be WAVMIXER_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lParam>			(i) device id or handle, as specified by <dwFlags>
//		<dwReserved1>		(i) reserved; must be 0;
//		<dwReserved2>		(i) reserved; must be 0;
//		<dwFlags>			(i) control flags
//			WAVMIXER_HWAVEIN	<lParam> contains an HWAVEIN
//			WAVMIXER_HWAVEOUT	<lParam> contains an HWAVEOUT
//			WAVMIXER_WAVEIN		<lParam> contains a wav input device id
//			WAVMIXER_WAVEOUT	<lParam> contains a wav output device id
// return handle (NULL if error)
//
HWAVMIXER WINAPI WavMixerInit(DWORD dwVersion, HINSTANCE hInst,
	LPARAM lParam, DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags);

// WavMixerTerm - shut down wave mixer device
//		<hWavMixer>				(i) handle returned from WavMixerInit
// return 0 if success
//
int WINAPI WavMixerTerm(HWAVMIXER hWavMixer);

// WavMixerSupportsVolume - return TRUE if device supports volume control
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return TRUE if device supports volume control
//
BOOL WINAPI WavMixerSupportsVolume(HWAVMIXER hWavMixer, DWORD dwFlags);

// WavMixerGetVolume - get current volume level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int WINAPI WavMixerGetVolume(HWAVMIXER hWavMixer, DWORD dwFlags);

// WavMixerSetVolume - set current volume level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<nLevel>				(i) volume level
//			0						minimum volume
//			100						maximum volume
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return new volume level (0 minimum through 100 maximum, -1 if error)
//
int WINAPI WavMixerSetVolume(HWAVMIXER hWavMixer, int nLevel, DWORD dwFlags);

// WavMixerSupportsLevel - return TRUE if device supports peak meter level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return TRUE if device supports peak meter level
//
BOOL WINAPI WavMixerSupportsLevel(HWAVMIXER hWavMixer, DWORD dwFlags);

// WavMixerGetLevel - get current peak meter level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return peak meter level (0 minimum through 100 maximum, -1 if error)
//
int WINAPI WavMixerGetLevel(HWAVMIXER hWavMixer, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __WAVMIXER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\wavmixer.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wavmixer.c - wav mixer functions
////

#include "winlocal.h"

#include <mmsystem.h>

#include "wavmixer.h"
#include "calc.h"
#include "mem.h"
#include "trace.h"

////
//	private definitions
////

// wavmixer control struct
//
typedef struct WAVMIXER
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HMIXER hMixer;
	UINT nLastError;
	DWORD dwFlags;
} WAVMIXER, FAR *LPWAVMIXER;

#define VOLUME_MINLEVEL 0
#define VOLUME_MAXLEVEL 100
#define VOLUME_POSITIONS (VOLUME_MAXLEVEL - VOLUME_MINLEVEL)

#define WAVMIXER_SUPPORTSVOLUME		0x00000001
#define WAVMIXER_GETVOLUME			0x00000002
#define WAVMIXER_SETVOLUME			0x00000004

#define LEVEL_MINLEVEL 0
#define LEVEL_MAXLEVEL 100
#define LEVEL_POSITIONS (LEVEL_MAXLEVEL - LEVEL_MINLEVEL)

#define WAVMIXER_SUPPORTSLEVEL		0x00000001
#define WAVMIXER_GETLEVEL			0x00000002

// helper functions
//
static int WINAPI WavMixerVolume(HWAVMIXER hWavMixer, LPINT lpnLevel, DWORD dwFlags);
static int WINAPI WavMixerLevel(HWAVMIXER hWavMixer, LPINT lpnLevel, DWORD dwFlags);
static LPWAVMIXER WavMixerGetPtr(HWAVMIXER hWavMixer);
static HWAVMIXER WavMixerGetHandle(LPWAVMIXER lpWavMixer);

////
//	public functions
////

// WavMixerInit - initialize wav mixer device
//		<dwVersion>			(i) must be WAVMIXER_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lParam>			(i) device id or handle, as specified by <dwFlags>
//		<dwReserved1>		(i) reserved; must be 0;
//		<dwReserved2>		(i) reserved; must be 0;
//		<dwFlags>			(i) control flags
//			WAVMIXER_HWAVEIN	<lParam> contains an HWAVEIN
//			WAVMIXER_HWAVEOUT	<lParam> contains an HWAVEOUT
//			WAVMIXER_WAVEIN		<lParam> contains a wav input device id
//			WAVMIXER_WAVEOUT	<lParam> contains a wav output device id
// return handle (NULL if error)
//
HWAVMIXER WINAPI WavMixerInit(DWORD dwVersion, HINSTANCE hInst,
	LPARAM lParam, DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVMIXER lpWavMixer = NULL;

	if (dwVersion != WAVMIXER_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);
                        
	else if ((lpWavMixer = (LPWAVMIXER) MemAlloc(NULL, sizeof(WAVMIXER), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		UINT uMxId = (UINT) lParam; 
		DWORD fdwOpen = 0;
		UINT nLastError;

		lpWavMixer->dwVersion = dwVersion;
		lpWavMixer->hInst = hInst;
		lpWavMixer->hTask = GetCurrentTask();
		lpWavMixer->hMixer = NULL;
		lpWavMixer->nLastError = 0;
		lpWavMixer->dwFlags = dwFlags;

		if (dwFlags & WAVMIXER_HWAVEIN)
			fdwOpen |= MIXER_OBJECTF_HWAVEIN;
		if (dwFlags & WAVMIXER_HWAVEOUT)
			fdwOpen |= MIXER_OBJECTF_HWAVEOUT;
		if (dwFlags & WAVMIXER_WAVEIN)
			fdwOpen |= MIXER_OBJECTF_WAVEIN;
		if (dwFlags & WAVMIXER_WAVEOUT)
			fdwOpen |= MIXER_OBJECTF_WAVEOUT;

		// open the mixer device
		//
		if ((nLastError = mixerOpen(&lpWavMixer->hMixer, uMxId, 0L, 0L, fdwOpen)) != MMSYSERR_NOERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mixerOpen failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	if (!fSuccess)
	{
		WavMixerTerm(WavMixerGetHandle(lpWavMixer));
		lpWavMixer = NULL;
	}

	return fSuccess ? WavMixerGetHandle(lpWavMixer) : NULL;
}

// WavMixerTerm - shut down wave mixer device
//		<hWavMixer>				(i) handle returned from WavMixerInit
// return 0 if success
//
int WINAPI WavMixerTerm(HWAVMIXER hWavMixer)
{
	BOOL fSuccess = TRUE;
	LPWAVMIXER lpWavMixer;

	if ((lpWavMixer = WavMixerGetPtr(hWavMixer)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpWavMixer->hMixer != NULL)
		{
			UINT nLastError;

			if ((nLastError = mixerClose(lpWavMixer->hMixer)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerClose failed (%u)\n"),
					(unsigned) nLastError);
			}
			else
				lpWavMixer->hMixer = NULL;
		}

		if ((lpWavMixer = MemFree(NULL, lpWavMixer)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavMixerSupportsVolume - return TRUE if device supports volume control
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return TRUE if device supports volume control
//
BOOL WINAPI WavMixerSupportsVolume(HWAVMIXER hWavMixer, DWORD dwFlags)
{
	if (WavMixerVolume(hWavMixer, NULL, WAVMIXER_SUPPORTSVOLUME) != 0)
		return FALSE;
	else
		return TRUE;
}

// WavMixerGetVolume - get current volume level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int WINAPI WavMixerGetVolume(HWAVMIXER hWavMixer, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int nLevel;

	if (WavMixerVolume(hWavMixer, &nLevel, WAVMIXER_GETVOLUME) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? nLevel : -1;
}

// WavMixerSetVolume - set current volume level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<nLevel>				(i) volume level
//			0						minimum volume
//			100						maximum volume
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return new volume level (0 minimum through 100 maximum, -1 if error)
//
int WINAPI WavMixerSetVolume(HWAVMIXER hWavMixer, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	if (WavMixerVolume(hWavMixer, &nLevel, WAVMIXER_SETVOLUME) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? nLevel : -1;
}

static int WINAPI WavMixerVolume(HWAVMIXER hWavMixer, LPINT lpnLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVMIXER lpWavMixer;
	LPMIXERCONTROL lpmxc = NULL;

    //
    // We have to initialize local variable
    //
	UINT nLastError;
	MIXERLINE mxlDst;
	MIXERLINE mxlSrc;
	BOOL fWaveIn = FALSE;

	if ((lpWavMixer = WavMixerGetPtr(hWavMixer)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpmxc = (LPMIXERCONTROL) MemAlloc(NULL, sizeof(MIXERCONTROL), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get info for the destination line
	//
	if (fSuccess)
	{
		if ((lpWavMixer->dwFlags & WAVMIXER_WAVEIN) ||
			(lpWavMixer->dwFlags & WAVMIXER_HWAVEIN))
			fWaveIn = TRUE;

		mxlDst.cbStruct = sizeof(mxlDst);
		mxlDst.dwComponentType = fWaveIn ?
			MIXERLINE_COMPONENTTYPE_DST_WAVEIN :
			MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;

		if ((nLastError = mixerGetLineInfo((HMIXEROBJ) lpWavMixer->hMixer, &mxlDst,
			MIXER_OBJECTF_HMIXER | MIXER_GETLINEINFOF_COMPONENTTYPE)) != MMSYSERR_NOERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mixerGetLineInfo failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	// find appropriate source line connected to this destination line
	//
	if (fSuccess)
	{
		DWORD dwSource;

		for (dwSource = 0; fSuccess && dwSource < mxlDst.cConnections; ++dwSource)
		{
			mxlSrc.cbStruct = sizeof(mxlSrc);
			mxlSrc.dwSource = dwSource;
			mxlSrc.dwDestination = mxlDst.dwDestination;

			if ((nLastError = mixerGetLineInfo((HMIXEROBJ) lpWavMixer->hMixer, &mxlSrc,
				MIXER_OBJECTF_HMIXER | MIXER_GETLINEINFOF_SOURCE)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerGetLineInfo failed (%u)\n"),
					(unsigned) nLastError);
			}

			else if (mxlSrc.dwComponentType == (DWORD) (fWaveIn ?
				MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE :
				MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT))
			{
				// source line found
				//
				break;
			}
		}

		if (dwSource == mxlDst.cConnections)
		{
			// unable to find source line
			//
			fSuccess = TraceFALSE(NULL);
		}
	}

	// find volume control, if any, of the appropriate line
	//
	if (fSuccess)
	{
		MIXERLINECONTROLS mxlc;

		mxlc.cbStruct = sizeof(mxlc);
		mxlc.dwLineID = (fWaveIn ? mxlSrc.dwLineID : mxlDst.dwLineID);
		mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
		mxlc.cControls = 1;
		mxlc.cbmxctrl = sizeof(MIXERCONTROL);
		mxlc.pamxctrl = lpmxc;

		if ((nLastError = mixerGetLineControls((HMIXEROBJ) lpWavMixer->hMixer, &mxlc,
			MIXER_OBJECTF_HMIXER | MIXER_GETLINECONTROLSF_ONEBYTYPE)) != MMSYSERR_NOERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mixerGetLineControls failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	// get and/or set current volume level
	//
	if (fSuccess &&
		((dwFlags & WAVMIXER_GETVOLUME) || (dwFlags & WAVMIXER_SETVOLUME)))
	{
		LPMIXERCONTROLDETAILS_UNSIGNED lpmxcdu = NULL;
		MIXERCONTROLDETAILS mxcd;
		DWORD cChannels = mxlSrc.cChannels;
		DWORD dwVolume;
		int nLevel;

		if (lpmxc->fdwControl & MIXERCONTROL_CONTROLF_UNIFORM)
			cChannels = 1;
		
		if ((lpmxcdu = (LPMIXERCONTROLDETAILS_UNSIGNED) MemAlloc(NULL,
			cChannels * sizeof(MIXERCONTROLDETAILS_UNSIGNED), 0)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		else
		{
			mxcd.cbStruct = sizeof(mxcd);
			mxcd.dwControlID = lpmxc->dwControlID;
			mxcd.cChannels = cChannels;
			mxcd.hwndOwner = (HWND) NULL;
			mxcd.cbDetails = sizeof(MIXERCONTROLDETAILS_UNSIGNED);
			mxcd.paDetails = (LPVOID) lpmxcdu;

			if ((nLastError = mixerGetControlDetails((HMIXEROBJ) lpWavMixer->hMixer, &mxcd,
				MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerGetControlDetails failed (%u)\n"),
					(unsigned) nLastError);
			}
			else
				dwVolume = lpmxcdu[0].dwValue;
		}

		if (fSuccess && (dwFlags & WAVMIXER_SETVOLUME))
		{
			if (lpnLevel != NULL)
				nLevel = *lpnLevel;

			// convert signed level (0 - 100) to unsigned volume (0 - 65535)
			//
			dwVolume = nLevel * (0xFFFF / VOLUME_POSITIONS);

			lpmxcdu[0].dwValue = lpmxcdu[cChannels - 1].dwValue = dwVolume;

			TracePrintf_2(NULL, 5,
				TEXT("WavMixerSetVolume() = %d, 0x%08lX\n"),
				(int) nLevel,
				(unsigned long) dwVolume);

			if ((nLastError = mixerSetControlDetails((HMIXEROBJ) lpWavMixer->hMixer, &mxcd,
				MIXER_OBJECTF_HMIXER | MIXER_SETCONTROLDETAILSF_VALUE)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerSetControlDetails failed (%u)\n"),
					(unsigned) nLastError);
			}
#if 1
			// save new volume to pass back
			//
			else if ((nLastError = mixerGetControlDetails((HMIXEROBJ) lpWavMixer->hMixer, &mxcd,
				MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerGetControlDetails failed (%u)\n"),
					(unsigned) nLastError);
			}
			else
				dwVolume = lpmxcdu[0].dwValue;
#endif
		}

		if (fSuccess &&
#if 1
			((dwFlags & WAVMIXER_GETVOLUME) || (dwFlags & WAVMIXER_SETVOLUME)))
#else
			(dwFlags & WAVMIXER_GETVOLUME))
#endif
		{
			// convert unsigned volume (0 - 65535) to signed level (0 - 100)
			//
			nLevel = LOWORD(dwVolume) / (0xFFFF / VOLUME_POSITIONS);

			if (lpnLevel != NULL)
				*lpnLevel = nLevel;

			TracePrintf_2(NULL, 5,
				TEXT("WavMixerGetVolume() = %d, 0x%08lX\n"),
				(int) nLevel,
				(unsigned long) dwVolume);
		}

		if (lpmxcdu != NULL && (lpmxcdu = MemFree(NULL, lpmxcdu)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (lpmxc != NULL && (lpmxc = MemFree(NULL, lpmxc)) != NULL)
		fSuccess = TraceFALSE(NULL);

	if (hWavMixer != NULL && lpWavMixer != NULL)
		lpWavMixer->nLastError = nLastError;

	return fSuccess ? 0 : -1;
}

// WavMixerSupportsLevel - return TRUE if device supports peak meter level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return TRUE if device supports peak meter level
//
BOOL WINAPI WavMixerSupportsLevel(HWAVMIXER hWavMixer, DWORD dwFlags)
{
	if (WavMixerLevel(hWavMixer, NULL, WAVMIXER_SUPPORTSLEVEL) != 0)
		return FALSE;
	else
		return TRUE;
}

// WavMixerGetLevel - get current peak meter level
//		<hWavMixer>			(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return peak meter level (0 minimum through 100 maximum, -1 if error)
//
int WINAPI WavMixerGetLevel(HWAVMIXER hWavMixer, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int nLevel;

	if (WavMixerLevel(hWavMixer, &nLevel, WAVMIXER_GETLEVEL) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? nLevel : -1;
}

static int WINAPI WavMixerLevel(HWAVMIXER hWavMixer, LPINT lpnLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVMIXER lpWavMixer;
	LPMIXERCONTROL lpmxc = NULL;

    //
    // Initialize local variable
    //

	UINT nLastError = 0;
	MIXERLINE mxlDst;
	MIXERLINE mxlSrc;
	BOOL fWaveIn = FALSE;

	if ((lpWavMixer = WavMixerGetPtr(hWavMixer)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpmxc = (LPMIXERCONTROL) MemAlloc(NULL, sizeof(MIXERCONTROL), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get info for the destination line
	//
	if (fSuccess)
	{
		if ((lpWavMixer->dwFlags & WAVMIXER_WAVEIN) ||
			(lpWavMixer->dwFlags & WAVMIXER_HWAVEIN))
			fWaveIn = TRUE;

		mxlDst.cbStruct = sizeof(mxlDst);
		mxlDst.dwComponentType = fWaveIn ?
			MIXERLINE_COMPONENTTYPE_DST_WAVEIN :
			MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;

		if ((nLastError = mixerGetLineInfo((HMIXEROBJ) lpWavMixer->hMixer, &mxlDst,
			MIXER_OBJECTF_HMIXER | MIXER_GETLINEINFOF_COMPONENTTYPE)) != MMSYSERR_NOERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mixerGetLineInfo failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	// find appropriate source line connected to this destination line
	//
	if (fSuccess)
	{
		DWORD dwSource;

		for (dwSource = 0; fSuccess && dwSource < mxlDst.cConnections; ++dwSource)
		{
			mxlSrc.cbStruct = sizeof(mxlSrc);
			mxlSrc.dwSource = dwSource;
			mxlSrc.dwDestination = mxlDst.dwDestination;

			if ((nLastError = mixerGetLineInfo((HMIXEROBJ) lpWavMixer->hMixer, &mxlSrc,
				MIXER_OBJECTF_HMIXER | MIXER_GETLINEINFOF_SOURCE)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerGetLineInfo failed (%u)\n"),
					(unsigned) nLastError);
			}

			else if (mxlSrc.dwComponentType == (DWORD) (fWaveIn ?
				MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE :
				MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT))
			{
				// source line found
				//
				break;
			}
		}

		if (dwSource == mxlDst.cConnections)
		{
			// unable to find source line
			//
			fSuccess = TraceFALSE(NULL);
		}
	}

	// find peak meter control, if any, of the appropriate line
	//
	if (fSuccess)
	{
		MIXERLINECONTROLS mxlc;

		mxlc.cbStruct = sizeof(mxlc);
		mxlc.dwLineID = (fWaveIn ? mxlDst.dwLineID : mxlSrc.dwLineID);
		mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_PEAKMETER;
		mxlc.cControls = 1;
		mxlc.cbmxctrl = sizeof(MIXERCONTROL);
		mxlc.pamxctrl = lpmxc;

		if ((nLastError = mixerGetLineControls((HMIXEROBJ) lpWavMixer->hMixer, &mxlc,
			MIXER_OBJECTF_HMIXER | MIXER_GETLINECONTROLSF_ONEBYTYPE)) != MMSYSERR_NOERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mixerGetLineControls failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	// get current peak meter level
	//
	if (fSuccess && (dwFlags & WAVMIXER_GETLEVEL))
	{
		LPMIXERCONTROLDETAILS_SIGNED lpmxcds = NULL;
		MIXERCONTROLDETAILS mxcd;
		DWORD cChannels = mxlDst.cChannels;
		DWORD dwLevel;
		int nLevel;

		if (lpmxc->fdwControl & MIXERCONTROL_CONTROLF_UNIFORM)
			cChannels = 1;
		
		if ((lpmxcds = (LPMIXERCONTROLDETAILS_SIGNED) MemAlloc(NULL,
			cChannels * sizeof(MIXERCONTROLDETAILS_SIGNED), 0)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		else
		{
			mxcd.cbStruct = sizeof(mxcd);
			mxcd.dwControlID = lpmxc->dwControlID;
			mxcd.cChannels = cChannels;
			mxcd.hwndOwner = (HWND) NULL;
			mxcd.cbDetails = sizeof(MIXERCONTROLDETAILS_SIGNED);
			mxcd.paDetails = (LPVOID) lpmxcds;

			if ((nLastError = mixerGetControlDetails((HMIXEROBJ) lpWavMixer->hMixer, &mxcd,
				MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerGetControlDetails failed (%u)\n"),
					(unsigned) nLastError);
			}
			else
			{
				// convert signed level to unsigned level
				//
				dwLevel = lpmxcds[0].lValue - 0; // lpmxc->Bounds.lMinimum;
				dwLevel *= 2;
			}
		}

		// convert unsigned level (0 - 65535) to signed level (0 - 100)
		//
		nLevel = LOWORD(dwLevel) / (0xFFFF / LEVEL_POSITIONS);

		if (lpnLevel != NULL)
			*lpnLevel = nLevel;

        //
        // We have to verify lpmxcds pointer
        //
		TracePrintf_3(NULL, 5,
			TEXT("WavMixerGetLevel() = %d, %ld, 0x%08lX\n"),
			(int) nLevel,
            lpmxcds ? lpmxcds[0].lValue : 0,
			(unsigned long) dwLevel);

		if (lpmxcds != NULL && (lpmxcds = MemFree(NULL, lpmxcds)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (lpmxc != NULL && (lpmxc = MemFree(NULL, lpmxc)) != NULL)
		fSuccess = TraceFALSE(NULL);

	if (hWavMixer != NULL && lpWavMixer != NULL)
		lpWavMixer->nLastError = nLastError;

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

// WavMixerGetPtr - verify that wavmixer handle is valid,
//		<hWavMixer>				(i) handle returned from WavMixerInit
// return corresponding wavmixer pointer (NULL if error)
//
static LPWAVMIXER WavMixerGetPtr(HWAVMIXER hWavMixer)
{
	BOOL fSuccess = TRUE;
	LPWAVMIXER lpWavMixer;

	if ((lpWavMixer = (LPWAVMIXER) hWavMixer) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpWavMixer, sizeof(WAVMIXER)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the wavmixer handle
	//
	else if (lpWavMixer->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpWavMixer : NULL;
}

// WavMixerGetHandle - verify that wavmixer pointer is valid,
//		<lpWavMixer>				(i) pointer to WAVMIXER struct
// return corresponding wavmixer handle (NULL if error)
//
static HWAVMIXER WavMixerGetHandle(LPWAVMIXER lpWavMixer)
{
	BOOL fSuccess = TRUE;

    //
    // we have to initialize local variable
    //

	HWAVMIXER hWavMixer = NULL;

	if ((hWavMixer = (HWAVMIXER) lpWavMixer) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hWavMixer : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\confinfo.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// TAPIDialer(tm) and ActiveDialer(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526; 5,488,650; 
// 5,434,906; 5,581,604; 5,533,102; 5,568,540, 5,625,676.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/* $FILEHEADER
*
* FILE
*   ConfInfo.h
*
* CLASS
*	CConfInfo
*
*/

#if !defined(AFX_CONFINFO_H__CE5346F6_4AFC_11D1_84F1_00608CBAE3F4__INCLUDED_)
#define AFX_CONFINFO_H__CE5346F6_4AFC_11D1_84F1_00608CBAE3F4__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <atlbase.h>
#include <iads.h>
#include <rend.h>
#include <sdpblb.h>

typedef enum tagConfCommitError
{
   CONF_COMMIT_ERROR_NONE=0,
   CONF_COMMIT_ERROR_INVALIDDATETIME,
   CONF_COMMIT_ERROR_INVALIDNAME,
   CONF_COMMIT_ERROR_INVALIDOWNER,
   CONF_COMMIT_ERROR_INVALIDDESCRIPTION,
   CONF_COMMIT_ERROR_INVALIDSECURITYDESCRIPTOR,
   CONF_COMMIT_ERROR_MDHCPFAILED,
   CONF_COMMIT_ERROR_GENERALFAILURE,
}ConfCommitError;

class CConfInfo  
{
public:
	CConfInfo();
	virtual ~CConfInfo();

// Members
public:
	IADsSecurityDescriptor			*m_pSecDesc;
	ITDirectoryObjectConference		*m_pITConf;

	long							m_lScopeID;
	bool							m_bNewConference;
	bool							m_bDateTimeChange;

    // TRUE if user selects a row from the scopes list
    bool                            m_bUserSelected;

    // TRUE if has been showed the 'Start/Stop Change Date Message'
    bool                            m_bDateChangeMessage;

protected:
	ITRendezvous *m_pITRend;
	ITDirectoryObject **m_ppDirObject;
	BSTR m_bstrName;
	BSTR m_bstrDescription;
	BSTR m_bstrOwner;

	SYSTEMTIME	m_stStartTime;
	SYSTEMTIME	m_stStopTime;
	DATE		m_dateStart;
	DATE		m_dateStop;
	bool		m_bSecuritySet;

// Attributes
public:
	void get_Name(BSTR *pbstrName);
	void put_Name(BSTR bstrName);
	void get_Description(BSTR *pbstrDescription);
	void put_Description(BSTR bstrDescription);
	void get_Originator(BSTR *pbstrOwner);
	void put_Originator(BSTR bstrOwner);
	void GetStartTime(USHORT *nYear, BYTE *nMonth, BYTE *nDay, BYTE *nHour, BYTE *nMinute);
	void SetStartTime(USHORT nYear, BYTE nMonth, BYTE nDay, BYTE nHour, BYTE nMinute);
	void GetStopTime(USHORT *nYear, BYTE *nMonth, BYTE *nDay, BYTE *nHour, BYTE *nMinute);
	void SetStopTime(USHORT nYear, BYTE nMonth, BYTE nDay, BYTE nHour, BYTE nMinute);
	void GetPrimaryUser( BSTR *pbstrTrustee );
	bool IsNewConference()		{ return m_bNewConference; }
	bool WasSecuritySet()				{ return true; /*return m_bSecuritySet;*/ }
	void SetSecuritySet( bool bSet )	{ m_bSecuritySet = bSet; }


// Operations
public:
	static bool PopulateListWithMDHCPScopeDescriptions( HWND hWndList );
	static HRESULT CreateMDHCPAddress( ITSdp *pSdp, SYSTEMTIME *pStart, SYSTEMTIME *pStop, long lScopeID, bool bUserSelected );
	static HRESULT SetMDHCPAddress( ITMediaCollection *pMC, BSTR bstrAddress, long lCount, unsigned char nTTL );

	HRESULT Init(ITRendezvous *pITRend, ITDirectoryObjectConference *pITConf, ITDirectoryObject **ppDirObject, bool bNewConf );
	HRESULT CommitGeneral( DWORD& dwCommitError );
	HRESULT CommitSecurity( DWORD& dwCommitError, bool bCreate );
	HRESULT	AddDefaultACEs( bool bCreate );
};

#endif // !defined(AFX_CONFINFO_H__CE5346F6_4AFC_11D1_84F1_00608CBAE3F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avwav\wavout.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wavout.h - interface for wav output device functions in wavout.c
////

#ifndef __WAVOUT_H__
#define __WAVOUT_H__

#ifdef _WIN32
#define MULTITHREAD 1
#endif

#include "winlocal.h"

#include "wavfmt.h"

#define WAVOUT_VERSION 0x00000108

// handle to wav output device (NOT the same as Windows HWAVEOUT)
//
DECLARE_HANDLE32(HWAVOUT);

// <dwFlags> values in WavOutOpen
//
#define WAVOUT_NOSYNC		0x00000001
#define WAVOUT_AUTOFREE		0x00000002
#define WAVOUT_OPENRETRY	0x00000004
#define WAVOUT_OPENASYNC	0x00000008
#define WAVOUT_CLOSEASYNC	0x00000010
#define WAVOUT_NOACM		0x00000020
#define WAVOUT_TELRFILE		0x00000040
#ifdef MULTITHREAD
#define WAVOUT_MULTITHREAD 0x00000080
#endif

// notification messages sent to <hwndNotify>
//
#define WM_WAVOUT_OPEN			(WM_USER + 100)
#define WM_WAVOUT_CLOSE			(WM_USER + 101)
#define WM_WAVOUT_PLAYDONE		(WM_USER + 102)
#define WM_WAVOUT_STOPPLAY		(WM_USER + 103)

// structure passed as <lParam> in WM_WAVOUT_PLAYDONE message
//
typedef struct PLAYDONE
{
	LPVOID lpBuf;
	long sizBuf;
} PLAYDONE, FAR *LPPLAYDONE;

// return values from WavOutGetState
//
#define WAVOUT_STOPPED		0x0001
#define WAVOUT_PLAYING		0x0002
#define WAVOUT_PAUSED		0x0004
#define WAVOUT_STOPPING		0x0008

#ifdef __cplusplus
extern "C" {
#endif

// WavOutGetDeviceCount - return number of wav output devices found
//		<void>				this function takes no arguments
// return number of wav output devices found (0 if none)
//
int DLLEXPORT WINAPI WavOutGetDeviceCount(void);

// WavOutDeviceIsOpen - check if output device is open
//		<idDev>				(i) device id
//			-1					open any suitable output device
// return TRUE if open
//
BOOL DLLEXPORT WINAPI WavOutDeviceIsOpen(int idDev);

// WavOutOpen - open wav output device
//		<dwVersion>			(i) must be WAVOUT_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<idDev>				(i) device id
//			-1					open any suitable output device
//		<lpwfx>				(i) wave format
//		<hwndNotify>		(i) notify this window of device events
//			NULL				do not notify
//		<msTimeoutOpen>		(i) device open timeout in milleseconds
//			0					default timeout (30000)
//		<msTimeoutRetry>	(i) device retry timeout in milleseconds
//			0					default timeout (2000)
//		<dwFlags>			(i) control flags
//			WAVOUT_NOSYNC		do not open synchronous devices
//			WAVOUT_AUTOFREE		free each buffer after playback
//			WAVOUT_OPENRETRY	retry if device busy
//			WAVOUT_OPENASYNC	return before notification of device open
//			WAVOUT_CLOSEASYNC	return before notification of device close
//			WAVOUT_NOACM		do not use audio compression manager
//			WAVOUT_TELRFILE		telephone will play/record audio on server
#ifdef MULTITHREAD
//			WAVOUT_MULTITHREAD use callback thread rather than window
#endif
// return handle (NULL if error)
//
// NOTE: if <hwndNotify> is specified in WavOutOpen,
// WM_WAVOUT_OPEN will be sent to <hwndNotify>,
// when output device has been opened.
//
// NOTE: if WAVOUT_MULTITHREAD is specified in <dwFlags>,
// it is assumed that <hwndNotify> is not a window handle,
// but rather the id of the thread to receive notifications
//
HWAVOUT DLLEXPORT WINAPI WavOutOpen(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags);

// WavOutClose - close wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<msTimeoutClose>	(i) device close timeout in milleseconds
//			0					default timeout (30000)
// return 0 if success
//
// NOTE: if <hwndNotify> was specified in WavOutOpen,
// WM_WAVOUT_CLOSE will be sent to <hwndNotify>,
// when output device has been closed.
//
int DLLEXPORT WINAPI WavOutClose(HWAVOUT hWavOut, DWORD msTimeoutClose);

// WavOutPlay - submit buffer of samples to wav output device for playback
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<lpBuf>				(i) pointer to buffer containing samples
//		<sizBuf>			(i) size of buffer in bytes
// return 0 if success
//
// NOTE: the buffer pointed to by <lpBuf> must have been allocated
// using MemAlloc().
//
// NOTE: if <hwndNotify> is specified in WavOutOpen(), a WM_WAVOUT_PLAYDONE
// message will be sent to <hwndNotify>, with <lParam> set to a pointer to
// a PLAYDONE structure, when <lpBuf> has been played.
//
// NOTE: if WAVOUT_AUTOFREE flag is specified in WavOutOpen,
// GlobalFreePtr(lpBuf) will be called when <lpBuf> has been played.
//
int DLLEXPORT WINAPI WavOutPlay(HWAVOUT hWavOut, LPVOID lpBuf, long sizBuf);

// WavOutStop - stop playback of buffer(s) sent to wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<msTimeoutStop>		(i) device stop timeout in milleseconds
//			0					default timeout (2000)
// return 0 if success
//
int DLLEXPORT WINAPI WavOutStop(HWAVOUT hWavOut, DWORD msTimeoutStop);

// WavOutPause - pause wav output device playback
//		<hWavOut>			(i) handle returned from WavOutOpen
// return 0 if success
//
int DLLEXPORT WINAPI WavOutPause(HWAVOUT hWavOut);

// WavOutResume - resume wav output device playback
//		<hWavOut>			(i) handle returned from WavOutOpen
// return 0 if success
//
int DLLEXPORT WINAPI WavOutResume(HWAVOUT hWavOut);

// WavOutGetState - return current wav output device state
//		<hWavOut>			(i) handle returned from WavOutOpen
// return WAVOUT_STOPPED, WAVOUT_PLAYING, WAVOUT_PAUSED, or 0 if error
//
WORD DLLEXPORT WINAPI WavOutGetState(HWAVOUT hWavOut);

// WavOutGetPosition - get milleseconds of elapsed playback
//		<hWavOut>			(i) handle returned from WavOutOpen
// return 0 if success
//
long DLLEXPORT WINAPI WavOutGetPosition(HWAVOUT hWavOut);

// WavOutGetId - return id of wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
// return device id (-1 if error)
//
int DLLEXPORT WINAPI WavOutGetId(HWAVOUT hWavOut);

// WavOutGetName - get name of wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
//		<lpszName>			(o) buffer to hold device name
//		<sizName>			(i) size of buffer
// return 0 if success
//
int DLLEXPORT WINAPI WavOutGetName(HWAVOUT hWavOut, int idDev, LPTSTR lpszName, int sizName);

// WavOutGetIdByName - get id of wav output device, lookup by name
//		<lpszName>			(i) device name
#ifdef _WIN32
//			NULL or TEXT("")	get preferred device id
#endif
//		<dwFlags>			(i) reserved; must be zero
// return device id (-1 if error)
//
int WINAPI WavOutGetIdByName(LPCTSTR lpszName, DWORD dwFlags);

// WavOutSupportsFormat - return TRUE if device supports specified format
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
//		<lpwfx>				(i) wave format
// return TRUE if device supports specified format
//
BOOL DLLEXPORT WINAPI WavOutSupportsFormat(HWAVOUT hWavOut, int idDev,
	LPWAVEFORMATEX lpwfx);

// WavOutFormatSuggest - suggest a new format which the device supports
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
//		<lpwfxSrc>			(i) source format
//		<dwFlags>			(i)	control flags
//			WAVOUT_NOACM		do not use audio compression manager
// return pointer to suggested format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavOutFormatSuggest(
	HWAVOUT hWavOut, int idDev,	LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags);

// WavOutIsSynchronous - return TRUE if wav output device is synchronous
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
// return TRUE if wav output device is synchronous
//
BOOL DLLEXPORT WINAPI WavOutIsSynchronous(HWAVOUT hWavOut, int idDev);

// WavOutSupportsVolume - return TRUE if device supports volume control
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return TRUE if device supports volume control
//
BOOL DLLEXPORT WINAPI WavOutSupportsVolume(HWAVOUT hWavOut, int idDev);

// WavOutSupportsSpeed - return TRUE if device supports speed control
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return TRUE if device supports speed control
//
BOOL DLLEXPORT WINAPI WavOutSupportsSpeed(HWAVOUT hWavOut, int idDev);

// WavOutSupportsPitch - return TRUE if device supports pitch control
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return TRUE if device supports pitch control
//
BOOL DLLEXPORT WINAPI WavOutSupportsPitch(HWAVOUT hWavOut, int idDev);

// WavOutGetVolume - get current volume level
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int DLLEXPORT WINAPI WavOutGetVolume(HWAVOUT hWavOut, int idDev);

// WavOutSetVolume - set current volume level
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//		<nLevel>			(i) volume level
//			0					minimum volume
//			100					maximum volume
// return 0 if success
//
int DLLEXPORT WINAPI WavOutSetVolume(HWAVOUT hWavOut, int idDev, int nLevel);

// WavOutGetSpeed - get current speed level
//		<hWavOut>			(i) handle returned from WavOutOpen
// return speed level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI WavOutGetSpeed(HWAVOUT hWavOut);

// WavOutSetSpeed - set current speed level
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
// return 0 if success
//
int DLLEXPORT WINAPI WavOutSetSpeed(HWAVOUT hWavOut, int nLevel);

// WavOutGetPitch - get current pitch level
//		<hWavOut>			(i) handle returned from WavOutOpen
// return pitch level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI WavOutGetPitch(HWAVOUT hWavOut);

// WavOutSetPitch - set current pitch level
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<nLevel>			(i) pitch level
//			50					half pitch
//			100					normal pitch
//			200					double pitch, etc.
// return 0 if success
//
int DLLEXPORT WINAPI WavOutSetPitch(HWAVOUT hWavOut, int nLevel);

// WavOutTerm - shut down wav output residuals, if any
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return 0 if success
//
int DLLEXPORT WINAPI WavOutTerm(HINSTANCE hInst, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __WAVOUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\confinfo.cpp ===
////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// TAPIDialer(tm) and ActiveDialer(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526; 5,488,650; 
// 5,434,906; 5,581,604; 5,533,102; 5,568,540, 5,625,676.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/* $FILEHEADER
*
* FILE
*   ConfInfo.cpp
*
* CLASS
*	CConfInfo
*
* RESPONSIBILITIES
*	Creates / Gathers info about a conference
*
*/

#include "ConfInfo.h"
#include <limits.h>
#include <mdhcp.h>
#include "winlocal.h"
#include "objsec.h"
#include "rndsec.h"
#include "res.h"
#include "ThreadPub.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
//#define new DEBUG_NEW
#endif

CConfInfo::CConfInfo()
{
	// General properties
	m_pITRend = NULL;
	m_pITConf = NULL;
	m_ppDirObject = NULL;
	m_pSecDesc = NULL;
	m_bSecuritySet = false;
	m_bNewConference = false;
	m_bDateTimeChange = false;

	m_lScopeID = -1;		        // default is auto-select
    m_bUserSelected = false;        // the user doesn't select a scope
    m_bDateChangeMessage = false;   // wasn't show yet the message

	// Conference Info
	m_bstrName = NULL;
	m_bstrDescription = NULL;
	m_bstrOwner = NULL;

	// Default start time is immediately, default end time is +30m
	GetLocalTime( &m_stStartTime );
	GetLocalTime( &m_stStopTime );

	// Add 30 minutes to current time
	DATE dateNow;
	SystemTimeToVariantTime( &m_stStopTime, &dateNow );
	dateNow += (DATE) (.25 / 12);
	VariantTimeToSystemTime( dateNow, &m_stStopTime );
}

CConfInfo::~CConfInfo()
{
	SysFreeString(m_bstrName);
	SysFreeString(m_bstrDescription);
	SysFreeString(m_bstrOwner);

	if (m_pSecDesc)
		m_pSecDesc->Release();
}
 
/****************************************************************************
* Init
*	Stores the address of the ITRendezvous and ITDirectoryObjectConference interface
*	pointers.  When creating a new conference the calling function should set pITConf
*	to NULL.  When editing an existing conference, pITConf should point to the interface
*	of the conference COM object. 
*
* Return Value
*	Returns the HRESULT from the Rendezvous functions 
*
* Comments
*****************************************************************************/
HRESULT CConfInfo::Init(ITRendezvous *pITRend, ITDirectoryObjectConference *pITConf, ITDirectoryObject **ppDirObject, bool bNewConf )
{
	HRESULT hr = 0;
	m_pITRend = pITRend;
	m_pITConf = pITConf;
	m_bNewConference = (bool) (bNewConf || (m_pITConf == NULL));

	// store the pointer to the directory object
	m_ppDirObject = ppDirObject;

	// Create a conference, or edit an existing one?
	if ( m_pITConf )
	{
		// Start and stop time
		m_pITConf->get_StartTime( &m_dateStart );
		VariantTimeToSystemTime( m_dateStart, &m_stStartTime );

		m_pITConf->get_StopTime( &m_dateStop );
		VariantTimeToSystemTime( m_dateStop, &m_stStopTime );

		// get the ITSdp interface
		ITConferenceBlob *pITConferenceBlob;
		if ( SUCCEEDED(hr = m_pITConf->QueryInterface(IID_ITConferenceBlob, (void **) &pITConferenceBlob)) )
		{
			ITSdp *pITSdp;
			if ( SUCCEEDED(hr = pITConferenceBlob->QueryInterface(IID_ITSdp, (void **) &pITSdp)) )
			{
				pITSdp->get_Name( &m_bstrName );
				pITSdp->get_Originator( &m_bstrOwner );
				pITSdp->get_Description( &m_bstrDescription );
				pITSdp->Release();
			}

			pITConferenceBlob->Release();
		}

		if ( SUCCEEDED(hr) )
		{
			// get the security descriptor for the directory object
			if ( SUCCEEDED(hr = m_pITConf->QueryInterface(IID_ITDirectoryObject, (void **) m_ppDirObject)) )
			{
				hr = (*m_ppDirObject)->get_SecurityDescriptor( (IDispatch**) &m_pSecDesc );

				// Clean up
				(*m_ppDirObject)->Release();
				*m_ppDirObject = NULL;
			}
		}
	}
	else
	{
		// Setup defaults for the new conference
		SysFreeString( m_bstrOwner );
		m_bstrOwner = NULL;
		GetPrimaryUser( &m_bstrOwner );
	}

	return hr;
}

void CConfInfo::get_Name(BSTR *pbstrName)
{
	*pbstrName = SysAllocString( m_bstrName );
}

void CConfInfo::put_Name(BSTR bstrName)
{
	SysReAllocString(&m_bstrName, bstrName);
}

void CConfInfo::get_Description(BSTR *pbstrDescription)
{
	*pbstrDescription = SysAllocString( m_bstrDescription );
}

void CConfInfo::put_Description(BSTR bstrDescription)
{
	SysReAllocString(&m_bstrDescription, bstrDescription);
}

void CConfInfo::get_Originator(BSTR *pbstrOwner)
{
	*pbstrOwner = SysAllocString( m_bstrOwner );
}

void CConfInfo::put_Originator(BSTR bstrOwner)
{
	SysReAllocString(&m_bstrOwner, bstrOwner);
}

void CConfInfo::GetStartTime(USHORT *nYear, BYTE *nMonth, BYTE *nDay, BYTE *nHour, BYTE *nMinute)
{
	*nYear = m_stStartTime.wYear;
	*nMonth = (BYTE)m_stStartTime.wMonth;
	*nDay = (BYTE)m_stStartTime.wDay;
	*nHour = (BYTE)m_stStartTime.wHour;
	*nMinute = (BYTE)m_stStartTime.wMinute;
}

void CConfInfo::SetStartTime(USHORT nYear, BYTE nMonth, BYTE nDay, BYTE nHour, BYTE nMinute)
{
	m_stStartTime.wYear = nYear;
	m_stStartTime.wMonth = nMonth;
	m_stStartTime.wDay = nDay;
	m_stStartTime.wHour = nHour;
	m_stStartTime.wMinute = nMinute;
}

void CConfInfo::GetStopTime(USHORT *nYear, BYTE *nMonth, BYTE *nDay, BYTE *nHour, BYTE *nMinute)
{
	*nYear = m_stStopTime.wYear;
	*nMonth = (BYTE)m_stStopTime.wMonth;
	*nDay = (BYTE)m_stStopTime.wDay;
	*nHour = (BYTE)m_stStopTime.wHour;
	*nMinute = (BYTE)m_stStopTime.wMinute;
}

void CConfInfo::SetStopTime(USHORT nYear, BYTE nMonth, BYTE nDay, BYTE nHour, BYTE nMinute)
{
	m_stStopTime.wYear = nYear;
	m_stStopTime.wMonth = nMonth;
	m_stStopTime.wDay = nDay;
	m_stStopTime.wHour = nHour;
	m_stStopTime.wMinute = nMinute;
}

void CConfInfo::GetPrimaryUser(BSTR *pbstrTrustee)
{
	HRESULT		hr = S_OK;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize = 0;
    DWORD       sidLength = 0;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
	{
		ATLTRACE(_T("OpenProcessToken failed\n"));
        return;
	}

	// get the needed size for the tokenUser structure
	else 
    {
        GetTokenInformation(tokenHandle, TokenUser, tokenUser, 0, &tokenSize);
        if ( tokenSize == 0)
	    {
            CloseHandle( tokenHandle );
		    ATLTRACE(_T("GetTokenInformation failed"));
            return;
	    }
	    else
	    {
		    // allocate the tokenUser structure
            BYTE* pToken = new BYTE[tokenSize];
            if( pToken == NULL )
            {
			    ATLTRACE(_T("new tokenUser failed\n"));
                CloseHandle( tokenHandle );
                return;
            }

            // initialize the memory
            memset( pToken, 0, sizeof(BYTE)*tokenSize);

            // cast to the token user
            tokenUser = (TOKEN_USER *)pToken;

		    // get the tokenUser info for the current process
            if (!GetTokenInformation(tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
		    {
                CloseHandle( tokenHandle );
                delete [] pToken;
                pToken = NULL;
                tokenUser = NULL;

			    ATLTRACE(_T("GetTokenInformation failed\n"));
                return;
		    }
		    else
            {
			    TCHAR			domainName [256];
			    TCHAR			userName [256];
			    DWORD			nameLength;
			    SID_NAME_USE	snu;

 			    nameLength = 255;
                if (!LookupAccountSid(NULL,
											     tokenUser->User.Sid,
											     userName,
											     &nameLength,
											     domainName,
											     &nameLength,
											     &snu))
			    {
				    ATLTRACE(_T("LookupAccountSid failed (0x%08lx)\n"),hr);
			    }
			    else
			    {
				    USES_CONVERSION;
				    SysReAllocString(pbstrTrustee, T2OLE(userName));
			    }

		        CloseHandle (tokenHandle);
                delete [] pToken;
                pToken = NULL;
                tokenUser = NULL;
            }
        }
	}
}

/****************************************************************************
* Commit
*	Creates / Modifies the actual conference. 
*
* Return Value
*	Returns the HRESULT from the Rendezvous functions 
*
* Comments
*****************************************************************************/
HRESULT CConfInfo::CommitGeneral(DWORD& dwCommitError)
{
	HRESULT hr = E_FAIL;
	dwCommitError = CONF_COMMIT_ERROR_GENERALFAILURE;

	bool bNewMDHCP = true;
	bool bNewConf = IsNewConference();
	HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_WAIT) );

	// Are we creating a conference from scratch?
	if ( !m_pITConf )
	{
		// Need to create a conference
		if ( SUCCEEDED(hr = m_pITRend->CreateDirectoryObject(OT_CONFERENCE, m_bstrName, m_ppDirObject)) && *m_ppDirObject )
		{
			if ( FAILED(hr = (*m_ppDirObject)->QueryInterface(IID_ITDirectoryObjectConference, (void **) &m_pITConf)) )
				ATLTRACE(_T("(*m_ppDirObject)->QueryInterface(IID_ITDirectoryObjectConference... failed (0x%08lx)\n"),hr);

			(*m_ppDirObject)->Release();
			*m_ppDirObject = NULL;
		}
		else
		{
			ATLTRACE(_T("CreateDirectoryObject failed (0x%08lx)\n"),hr);
		}
	}

	// Should we create a new MDHCP IP address lease?
	DATE dateStart, dateStop;
	SystemTimeToVariantTime( &m_stStartTime, &dateStart );
	SystemTimeToVariantTime( &m_stStopTime, &dateStop );
	if ( !bNewConf && (dateStart == m_dateStart) && (dateStop == m_dateStop) )
	{
		ATLTRACE(_T("CConfInfo::CommitGeneral() -- not changing the MDHCP address for the conf.\n"));
		bNewMDHCP = false;
	}

	// set the conference attributes
	if (  m_pITConf )
	{
		ITConferenceBlob *pITConferenceBlob = NULL;
		ITSdp *pITSdp = NULL;
		DATE vtime;

		// Retrieve the owner for the conference
		if ( !m_bstrOwner )
			GetPrimaryUser( &m_bstrOwner );

		// set the conference start time
		if (FAILED(hr = SystemTimeToVariantTime(&m_stStartTime, &vtime)))
		{
			dwCommitError = CONF_COMMIT_ERROR_INVALIDDATETIME;
			ATLTRACE(_T("SystemTimeToVariantTime failed (0x%08lx)\n"),hr);
		}

		else if (FAILED(hr = m_pITConf->put_StartTime(vtime)))
		{
			dwCommitError = CONF_COMMIT_ERROR_INVALIDDATETIME;
			ATLTRACE(_T("put_StartTime failed (0x%08lx)\n"),hr);
		}

		// set the conference stop time
		else if (FAILED(hr = SystemTimeToVariantTime(&m_stStopTime, &vtime)))
		{
			dwCommitError = CONF_COMMIT_ERROR_INVALIDDATETIME;
			ATLTRACE(_T("SystemTimeToVariantTime failed (0x%08lx)\n"),hr);
		}

		else if (FAILED(hr = m_pITConf->put_StopTime(vtime)))
		{
	        dwCommitError = CONF_COMMIT_ERROR_INVALIDDATETIME;
			ATLTRACE(_T("put_StopTime failed (0x%08lx)\n"),hr);
		}

		// get the ITSdp interface
		else if ( SUCCEEDED(hr = m_pITConf->QueryInterface(IID_ITConferenceBlob, (void **) &pITConferenceBlob)) )
		{
			if ( SUCCEEDED(hr = pITConferenceBlob->QueryInterface(IID_ITSdp, (void **) &pITSdp)) )
			{
				// set the owner of the conference
				if (FAILED(hr = pITSdp->put_Originator(m_bstrOwner)))
				{
					dwCommitError = CONF_COMMIT_ERROR_INVALIDOWNER;
					ATLTRACE(_T("put_Originator failed (0x%08lx)\n"),hr);
				}

				// set the conference description
				else if (FAILED(hr = pITSdp->put_Description(m_bstrDescription)))
				{
					dwCommitError = CONF_COMMIT_ERROR_INVALIDDESCRIPTION;
					ATLTRACE(_T("put_Description failed (0x%08lx)\n"),hr);
				}

				else if ( bNewMDHCP && FAILED(hr = CreateMDHCPAddress(pITSdp, &m_stStartTime, &m_stStopTime, m_lScopeID, m_bUserSelected)) )
				{	
					dwCommitError = CONF_COMMIT_ERROR_MDHCPFAILED;
					ATLTRACE(_T("CreateMDHCPAddress failed (0x%08lx)\n"), hr );
				}

				// if this was an existing conference then allow for changing the name
				else if ( bNewConf )
				{
					if (FAILED(hr = pITSdp->put_Name(m_bstrName)))
					{
						dwCommitError = CONF_COMMIT_ERROR_INVALIDNAME;
						ATLTRACE(_T("put_Name failed (0x%08lx)\n"),hr);
					}
				}
				pITSdp->Release();
			}
			pITConferenceBlob->Release();
		}
		else
		{
			dwCommitError = CONF_COMMIT_ERROR_GENERALFAILURE;
			ATLTRACE(_T("m_pITConf->QueryInterface(IID_ITConferenceBlob... failed (0x%08lx)\n"),hr);
		}
	}

	SetCursor( hCurOld );
	return hr;
}

HRESULT CConfInfo::CommitSecurity(DWORD& dwCommitError, bool bCreate)
{
	HRESULT hr = E_FAIL;
	dwCommitError = CONF_COMMIT_ERROR_GENERALFAILURE;
	HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_WAIT) );

	if ( m_pITConf )
	{
		if (SUCCEEDED(hr = m_pITConf->QueryInterface(IID_ITDirectoryObject, (void **) m_ppDirObject)) && *m_ppDirObject)
		{
			// Setup the default conference security
			if ( !m_pSecDesc )
			{
				hr = CoCreateInstance( CLSID_SecurityDescriptor,
									   NULL,
									   CLSCTX_INPROC_SERVER,
									   IID_IADsSecurityDescriptor,
									   (void **) &m_pSecDesc );

				// Add default settings if successfully created the ACE
				if ( SUCCEEDED(hr) )
					hr = AddDefaultACEs( bCreate );
			}


			// if we created a new security descriptor for the conference, then save it
			if ( m_pSecDesc )
			{
				if (FAILED(hr = (*m_ppDirObject)->put_SecurityDescriptor((IDispatch *)m_pSecDesc)))
				{
					dwCommitError = CONF_COMMIT_ERROR_INVALIDSECURITYDESCRIPTOR;
					ATLTRACE(_T("put_SecurityDescriptor failed (0x%08lx)\n"),hr);
				}
			}
		}
		else
		{
			ATLTRACE(_T("m_pITConf->QueryInterface(IID_ITDirectoryObject... failed (0x%08lx)\n"),hr);
		}
	}

	SetCursor( hCurOld );
	return hr;
}



/////////////////////////////////////////////////////////////////////////////////
// MDHCP support
//
bool CConfInfo::PopulateListWithMDHCPScopeDescriptions( HWND hWndList )
{
	USES_CONVERSION;

	if ( !IsWindow(hWndList) ) return false;


	// First create the MDHCP wrapper object
	int nScopeCount = 0;
	IMcastAddressAllocation *pIMcastAddressAllocation;
	HRESULT hr = CoCreateInstance(  CLSID_McastAddressAllocation,
									NULL,
									CLSCTX_INPROC_SERVER,
									IID_IMcastAddressAllocation,
									(void **) &pIMcastAddressAllocation );
	
	if ( SUCCEEDED(hr) )
	{
		IEnumMcastScope *pEnum = NULL;
		if ( SUCCEEDED(hr = pIMcastAddressAllocation->EnumerateScopes(&pEnum)) )
		{
			// Clear out list
			SendMessage( hWndList, LB_RESETCONTENT, 0, 0 );

			IMcastScope *pScope = NULL;
			while ( SUCCEEDED(hr) && ((hr = pEnum->Next(1, &pScope, NULL)) == S_OK) && pScope )
			{
				if ( IsWindow(hWndList) )
				{
					// Retrieve scope information
					long lScopeID;
					BSTR bstrDescription = NULL;
					pScope->get_ScopeDescription( &bstrDescription );
					pScope->get_ScopeID( &lScopeID );
					ATLTRACE(_T(".1.CConfInfo::CreateMDHCPAddress() scope ID = %ld, description is %s.\n"), lScopeID, bstrDescription );

					// Add information to list box
					long nIndex = SendMessage(hWndList, LB_ADDSTRING, 0, (LPARAM) OLE2CT(bstrDescription));
					if ( nIndex >= 0 )
					{
						nScopeCount++;
						SendMessage(hWndList, LB_SETITEMDATA, nIndex, (LPARAM) lScopeID );
					}

					SysFreeString( bstrDescription );
				}
				else
				{
					hr = E_ABORT;
				}

				// Clean up
				pScope->Release();
				pScope = NULL;
			}
			pEnum->Release();
		}
		pIMcastAddressAllocation->Release();
	}

	// Select first item in the list
	if ( SUCCEEDED(hr) && (nScopeCount > 0) )
	{
		SendMessage( hWndList, LB_SETCURSEL, 0, 0 );
		EnableWindow( hWndList, TRUE );
	}
	else if ( IsWindow(hWndList) )
	{
		MessageBox(GetParent(hWndList), String(g_hInstLib, IDS_CONFPROP_SCOPEENUMFAILED), NULL, MB_OK | MB_ICONEXCLAMATION );
	}

	return (bool) (hr == S_OK);
}


HRESULT CConfInfo::CreateMDHCPAddress( ITSdp *pSdp, SYSTEMTIME *pStart, SYSTEMTIME *pStop, long lScopeID, bool bUserSelected )
{
	_ASSERT( pSdp && pStart && pStop );

	// First create the MDHCP wrapper object
	IMcastAddressAllocation *pIMcastAddressAllocation;
	HRESULT hr = CoCreateInstance(  CLSID_McastAddressAllocation,
									NULL,
									CLSCTX_INPROC_SERVER,
									IID_IMcastAddressAllocation,
									(void **) &pIMcastAddressAllocation );
	
	if ( SUCCEEDED(hr) )
	{
		ITMediaCollection *pMC = NULL;
		if ( SUCCEEDED(hr = pSdp->get_MediaCollection(&pMC)) && pMC )
		{
			long lMCCount = 0;
			pMC->get_Count( &lMCCount );

			IEnumMcastScope *pEnum = NULL;
			if ( SUCCEEDED(hr = pIMcastAddressAllocation->EnumerateScopes(&pEnum)) )
			{
				hr = E_FAIL;

				// Try scopes until you run out or succeed
				long lCount = 1;
				IMcastScope *pScope = NULL;
				while ( FAILED(hr) && ((hr = pEnum->Next(1, &pScope, NULL)) == S_OK) && pScope )
				{
					// If the scope ID has been specified, make sure that this scope matches
					if ( bUserSelected )
					{
						long lID;
						pScope->get_ScopeID(&lID);
						if ( lID != lScopeID )
						{
							hr = E_FAIL;
                            pScope->Release();
							continue;
						}
					}

					DATE dateStart, dateStop;
					SystemTimeToVariantTime( pStart, &dateStart );
					SystemTimeToVariantTime( pStop, &dateStop );

					// Need to assign addresses to all media collections for the conference
					while ( SUCCEEDED(hr) && (lCount <= lMCCount) )
					{
						IMcastLeaseInfo *pInfo = NULL;
						hr = pIMcastAddressAllocation->RequestAddress( pScope, dateStart, dateStop, 1, &pInfo );
						if ( SUCCEEDED(hr) && pInfo )
						{
							unsigned char nTTL = 15;
							long lTemp;
							if ( SUCCEEDED(pInfo->get_TTL(&lTemp)) && (lTemp >= 0) && (lTemp <= UCHAR_MAX) )
								nTTL = (unsigned char) nTTL;

							IEnumBstr *pEnumAddr = NULL;
							if ( SUCCEEDED(hr = pInfo->EnumerateAddresses(&pEnumAddr)) && pEnumAddr )
							{
								BSTR bstrAddress = NULL;

								// Must set addressess for all media types on the conference
								if ( SUCCEEDED((hr = pEnumAddr->Next(1, &bstrAddress, NULL))) && bstrAddress && SysStringLen(bstrAddress) )
								{
									hr = SetMDHCPAddress( pMC, bstrAddress, lCount, nTTL );	
									lCount++;
								}

								SysFreeString( bstrAddress );
								pEnumAddr->Release();
							}
						}
					}

					// Clean up
					pScope->Release();
					pScope = NULL;

                    // Try with just one scope
                    if( FAILED( hr ) && 
                        (bUserSelected == false) )
                        break;
				}

				// Convert to failure
				if ( hr == S_FALSE ) hr = E_FAIL;
				pEnum->Release();
			}
			pMC->Release();
		}
		pIMcastAddressAllocation->Release();
	}

	return hr;
}

HRESULT CConfInfo::SetMDHCPAddress( ITMediaCollection *pMC, BSTR bstrAddress, long lCount, unsigned char nTTL )
{
	_ASSERT( pMC && bstrAddress && (lCount > 0) );
	HRESULT hr;

	ITMedia *pMedia = NULL;
	if ( SUCCEEDED(hr = pMC->get_Item(lCount, &pMedia)) && pMedia )
	{
		ITConnection *pITConn = NULL;
		if ( SUCCEEDED(hr = pMedia->QueryInterface(IID_ITConnection, (void **) &pITConn)) && pITConn )
		{
			hr = pITConn->SetAddressInfo( bstrAddress, 1, nTTL );
			pITConn->Release();
		}
		pMedia->Release();
	}

	return hr;
}

HRESULT	CConfInfo::AddDefaultACEs( bool bCreate )
{
	HRESULT hr = S_OK;
	bool bOwner = false, bWorld = false;
	PACL pACL = NULL;
	PSID pSidWorld = NULL;
	DWORD dwAclSize = sizeof(ACL), dwTemp;
	BSTR bstrTemp = NULL;
	LPWSTR pszTemp = NULL;

    HANDLE hToken;
    UCHAR *pInfoBuffer = NULL;
    DWORD cbInfoBuffer = 512;

	// Only create owner ACL if requested
	if ( bCreate )
	{
		if( !OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken) )
		{
			if( GetLastError() == ERROR_NO_TOKEN )
			{
				// attempt to open the process token, since no thread token exists
				if( !OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken) )
					return E_FAIL;
			}
			else
			{
				// error trying to get thread token
				return E_FAIL;
			}
		}

		// Loop until we have a large enough structure
		while ( (pInfoBuffer = new UCHAR[cbInfoBuffer]) != NULL )
		{
			if ( !GetTokenInformation(hToken, TokenUser, pInfoBuffer, cbInfoBuffer, &cbInfoBuffer) )
			{
				delete pInfoBuffer;
				pInfoBuffer = NULL;

				if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
					return E_FAIL;
			}
			else
			{
				break;
			}
		}
		CloseHandle(hToken);

		// Did we get the owner ACL?
		if ( pInfoBuffer )
		{
			INC_ACCESS_ACL_SIZE( dwAclSize, ((PTOKEN_USER) pInfoBuffer)->User.Sid );
			bOwner = true;
		}
	}

	// Make SID for "Everyone"
	SysReAllocString( &bstrTemp, L"S-1-1-0" );
	hr = ConvertStringToSid( bstrTemp, &pSidWorld, &dwTemp, &pszTemp );
	if ( SUCCEEDED(hr) )
	{
		INC_ACCESS_ACL_SIZE( dwAclSize, pSidWorld );
		bWorld = true;
	}

	////////////////////////////////////
	// Create the ACL containing the Owner and World ACEs
	pACL = (PACL) new BYTE[dwAclSize];
	if ( pACL )
	{
		BAIL_ON_BOOLFAIL( InitializeAcl(pACL, dwAclSize, ACL_REVISION) );

		// Add World Rights
		if ( bWorld )
		{
			if ( bOwner )
			{
				BAIL_ON_BOOLFAIL( AddAccessAllowedAce(pACL, ACL_REVISION, ACCESS_READ, pSidWorld) );
			}
			else
			{
				BAIL_ON_BOOLFAIL( AddAccessAllowedAce(pACL, ACL_REVISION, ACCESS_ALL , pSidWorld) );
			}
		}

		// Add Creator rights
		if ( bOwner )
			BAIL_ON_BOOLFAIL( AddAccessAllowedAce(pACL, ACL_REVISION, ACCESS_ALL, ((PTOKEN_USER) pInfoBuffer)->User.Sid) );


		// Set the DACL onto our security descriptor
		VARIANT varDACL;
		VariantInit( &varDACL );
		if ( SUCCEEDED(hr = ConvertACLToVariant((PACL) pACL, &varDACL)) )
		{
			if ( SUCCEEDED(hr = m_pSecDesc->put_DaclDefaulted(FALSE)) )
				hr = m_pSecDesc->put_DiscretionaryAcl( V_DISPATCH(&varDACL) );
		}
		VariantClear( &varDACL );
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

// Clean up
failed:
	SysFreeString( bstrTemp );
	if ( pACL ) delete pACL;
	if ( pSidWorld ) delete pSidWorld;
	if ( pInfoBuffer ) delete pInfoBuffer;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\confprop.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// confprop.c - conference properties dialog box
////

#include "winlocal.h"
#include <commctrl.h>
#include "confprop.h"
#include "cpgen.h"
#include "res.h"
#include "confinfo.h"
#include "DlgBase.h"
#include "objsec.h"

int CALLBACK ConfProp_PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam);

// global to keep track of DLL's instance/module handle;
//
HINSTANCE g_hInstLib;

///////////////////////////////////////////////////////////////
// ConfProp_Init
//
void ConfProp_Init( HINSTANCE hInst )
{
	g_hInstLib = hInst;
}


///////////////////////////////////////////////////////////////
// ConfProp_DoModal
//
INT64 ConfProp_DoModal( HWND hWndOwner,	CONFPROP& confprop )
{
	INT64 nRet;
    HPROPSHEETPAGE hpsp[2];
	PROPSHEETPAGE psp;
	PROPSHEETHEADER psh;

	do
	{
		// fill out the PROPSHEETPAGE struct for the General sheet
		//
		psp.dwSize		= sizeof(PROPSHEETPAGE);
		psp.dwFlags		= PSP_USETITLE | PSP_HASHELP;
		psp.hInstance	= g_hInstLib;
		psp.pszTemplate	= MAKEINTRESOURCE(IDD_CONFPROP_GENERAL);
		psp.pszIcon		= NULL;
		psp.pszTitle	= MAKEINTRESOURCE(IDS_GENERAL);
		psp.pfnDlgProc	= ConfPropGeneral_DlgProc;
		psp.lParam		= (LPARAM) &confprop;
		psp.pfnCallback	= NULL;
		psp.pcRefParent	= NULL;
		hpsp[0] = CreatePropertySheetPage(&psp);

		CObjSecurity* pObjSecurity = new CObjSecurity;
		HRESULT hr = pObjSecurity->InternalInitialize( &confprop );
		hpsp[1] = CreateSecurityPage(pObjSecurity);

		// fill out the PROPSHEETHEADER
		//
		psh.dwSize			= sizeof(PROPSHEETHEADER);
		psh.dwFlags			= PSH_HASHELP | PSH_NOAPPLYNOW | PSH_USECALLBACK;
		psh.hwndParent		= hWndOwner;
		psh.hInstance		= g_hInstLib;
		psh.pszIcon			= NULL;
		psh.pszCaption		= MAKEINTRESOURCE(IDS_CONFPROP);
		psh.nPages			= sizeof(hpsp) / sizeof(HPROPSHEETPAGE);
		psh.nStartPage		= 0;
		psh.phpage			= (HPROPSHEETPAGE*)&hpsp[0];
		psh.pfnCallback		= ConfProp_PropSheetProc;

		// This is a loop so because the user has the option to cancel things from
		// the security property page.  The program uses a flag (confprop.ConfInfo.WasSecuritySet())
		// to determine when the user has agreed to the security settings to continue.

		// display the modal property sheet
		nRet = PropertySheet( &psh );

        // Clean-up
        if( pObjSecurity )
        {
            pObjSecurity->Release();
            pObjSecurity = NULL;
        }

		if ( nRet == IDOK )
		{
			if ( confprop.ConfInfo.WasSecuritySet() )
			{
				// Repaint window before commit
				UpdateWindow( hWndOwner );
				DWORD dwError;
				if ( confprop.ConfInfo.CommitSecurity(dwError, confprop.ConfInfo.IsNewConference()) )
				{
					//get proper message
					UINT uId = IDS_CONFPROP_INVALIDTIME + dwError - 1;
					MessageBox(hWndOwner, String(g_hInstLib, uId), NULL, MB_OK | MB_ICONEXCLAMATION );
				}
			}
			else
			{
				nRet = IDRETRY;
			}
		}
	} while ( nRet == IDRETRY );

	return nRet;
}

////
//	private
////

int CALLBACK ConfProp_PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
	switch (uMsg)
	{
		case PSCB_PRECREATE:
			break;

		case PSCB_INITIALIZED:
			ConvertPropSheetHelp( hwndDlg );
			break;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\cpgen.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// cpgen.h - conference properties general dialog box
////

#ifndef _INC_CONFPROPGENERAL_DLG
#define _INC_CONFPROPGENERAL_DLG

#include "winlocal.h"
#include "oleauto.h"
#include "tapi3if.h"
#include "rend.h"

int DLLEXPORT WINAPI ConfPropGeneral_DoModal(HWND hwndOwner, DWORD dwUser);
INT_PTR DLLEXPORT CALLBACK ConfPropGeneral_DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif  // !_INC_DLG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\cpgen.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and29 product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// cpgen.c - conference properties general dialog box
////

#include "winlocal.h"
#include "res.h"
#include "wnd.h"
#include "DlgBase.h"
#include "confprop.h"
#include "cpgen.h"
#include "confinfo.h"
#include "ThreadPub.h"

////
//	private
////

extern HINSTANCE g_hInstLib;

#define NAME_MAXLEN 64
#define DESCRIPTION_MAXLEN 256
#define OWNER_MAXLEN 64

static LRESULT ConfPropGeneral_DlgProcEx(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static BOOL ConfPropGeneral_OnInitDialog(HWND hwndDlg, HWND hwndFocus, LPARAM lParam);
static BOOL ConfPropGeneral_OnCommand(HWND hwndDlg, UINT id, HWND hwndCtl, UINT code);
static int ConfPropGeneral_OnNotify(HWND hwndDlg, UINT idFrom, LPNMHDR lpnmhdr);
#define ConfPropGeneral_DefProc(hwnd, msg, wParam, lParam) \
	DefDlgProcEx(hwnd, msg, wParam, lParam, &g_bDefDlgEx)
static BOOL ConfPropGeneral_UpdateData(HWND hwndDlg, BOOL bSaveAndValidate);
static void ConfPropGeneral_SetDateTimeFormats( HWND hwndDlg );

DWORD WINAPI ThreadMDHCPScopeEnum( LPVOID pParam );
void ShowScopeInfo( HWND hwndDlg, int nShow, bool bInit );

static BOOL g_bDefDlgEx = FALSE;


////
//	public
////

int DLLEXPORT WINAPI ConfPropGeneral_DoModal(HWND hwndOwner, DWORD dwUser)
{
	return DialogBoxParam(g_hInstLib, MAKEINTRESOURCE(IDD_CONFPROP_GENERAL),
		hwndOwner, ConfPropGeneral_DlgProc, (LPARAM) dwUser);
}

INT_PTR DLLEXPORT CALLBACK ConfPropGeneral_DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CheckDefDlgRecursion(&g_bDefDlgEx);
	return SetDlgMsgResult(hwndDlg, uMsg, ConfPropGeneral_DlgProcEx(hwndDlg, uMsg, wParam, lParam));
}


////
//	private
////

void EnableOkBtn( HWND hWnd, bool bEnable )
{
	while ( hWnd )
	{
		HWND hWndOk = GetDlgItem( hWnd, IDOK );
		if ( hWndOk )
		{
			EnableWindow( hWndOk, bEnable );
			break;
		}

		hWnd = GetParent( hWnd );
	}
}

static LRESULT ConfPropGeneral_DlgProcEx(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LRESULT lRet = 0;

	switch (uMsg)
	{
		HANDLE_MSG(hwndDlg, WM_INITDIALOG, ConfPropGeneral_OnInitDialog);

		case WM_COMMAND:
			if ( (lRet = HANDLE_WM_COMMAND(hwndDlg, wParam, lParam, ConfPropGeneral_OnCommand)) != 0 )
				return lRet;
			break;

		case WM_NOTIFY:
			if ( (lRet = HANDLE_WM_NOTIFY(hwndDlg, wParam, lParam, ConfPropGeneral_OnNotify)) != 0 )
				return lRet;
			break;

		case WM_HELP:			return GeneralOnHelp( hwndDlg, wParam, lParam );
		case WM_CONTEXTMENU:	return GeneralOnContextMenu( hwndDlg, wParam, lParam );

		case WM_SETTINGCHANGE:
			ConfPropGeneral_SetDateTimeFormats( hwndDlg );
			// do default processing as well
			break;
	}

	return ConfPropGeneral_DefProc(hwndDlg, uMsg, wParam, lParam);
}

static BOOL ConfPropGeneral_OnInitDialog(HWND hwndDlg, HWND hwndFocus, LPARAM lParam)
{
	//_ASSERT( lParam  && ((LPPROPSHEETPAGE) lParam)->lParam );
    //
    // We have to verify the arguments
    //

    if( NULL == ((LPPROPSHEETPAGE)lParam) )
    {
        return TRUE;
    }

	LPCONFPROP lpConfProp = (LPCONFPROP) ((LPPROPSHEETPAGE) lParam)->lParam;

    //
    // Validates lpConfProp
    //

    if( IsBadReadPtr( lpConfProp, sizeof( CONFPROP) ) )
    {
        return TRUE;
    }

	SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR) lpConfProp );

	// Reset content of listbox if necessary
	ConfPropGeneral_UpdateData( hwndDlg, FALSE );
	if  ( lpConfProp->ConfInfo.IsNewConference() )
		ShowScopeInfo( hwndDlg, SW_SHOW, true );

	//WndCenterWindow( GetParent(hwndDlg), NULL, 0, 0 );

	return TRUE; // let Windows decide who gets focus
}

static BOOL ConfPropGeneral_OnCommand(HWND hwndDlg, UINT id, HWND hwndCtl, UINT code)
{
	BOOL bRet = false;

	HWND hwndName = GetDlgItem(hwndDlg, IDC_EDIT_NAME);

	switch (id)
	{
		case IDC_EDIT_NAME:
			if (code == EN_CHANGE)
				EnableOkBtn( hwndDlg, (bool) (Edit_GetTextLength(hwndName) != 0) );

			break;

		default:
			break;
	}

	return bRet;
}

static int ConfPropGeneral_OnNotify(HWND hwndDlg, UINT idFrom, LPNMHDR lpnmhdr)
{
	switch (lpnmhdr->code)
	{
		// page about to be activated and made visible, so initialize page
		//
		case PSN_SETACTIVE:
			return 0; // ok
			// return -1; // activate previous or next page
			// return MAKEINTRESOURCE(id); // activate specific page
			break;

		// page about to lose activation, so validate page
		//
		case PSN_KILLACTIVE:
			return FALSE; // ok
			// return TRUE; // not ok
			break;

		// ok or apply button pushed, so apply properties to object
		//
		case PSN_APPLY:
			return ConfPropGeneral_UpdateData( hwndDlg, TRUE );
			break;

		// cancel button pushed
		//
		case PSN_QUERYCANCEL:
			return FALSE; // ok
			// return TRUE; // not ok
			break;

		// page about to be destroyed after cancel button pushed
		//
		case PSN_RESET:
			return FALSE; // return value ignored
			break;

		// help button pushed
		//
		case PSN_HELP:
			// WinHelp(...); // $FIXUP - need to handle this
			return FALSE; // return value ignored
			break;

		case DTN_DATETIMECHANGE:
			// If this is not a new conference, post a message explaining that
			// the scope information will need to be re-selected
			if ( IsWindow(hwndDlg) )
			{
				LPCONFPROP lpConfProp = (LPCONFPROP) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
				
                //
                // We have to verify the lpConfProp
                //

                if( NULL == lpConfProp )
                {
                    break;
                }

				if ( !lpConfProp->ConfInfo.m_bDateTimeChange )
				{
					lpConfProp->ConfInfo.m_bDateTimeChange = true;
					if ( !lpConfProp->ConfInfo.m_bNewConference )
					{

                        // We send the notification again even if the source is the combo
                        // and show MessageBox at that time
					    //MessageBox(hwndDlg, String(g_hInstLib, IDS_CONFPROP_DATECHANGE_MDHCP), NULL, MB_OK | MB_ICONINFORMATION );
						ShowScopeInfo( hwndDlg, SW_SHOW, true );
                        PostMessage(hwndDlg, WM_NOTIFY, idFrom, (LPARAM)lpnmhdr);
					}
				}
                else
                {
                    //Here is the second notification
                    //I show here the Error message
					if ( !lpConfProp->ConfInfo.m_bNewConference )
					{
                        if(!lpConfProp->ConfInfo.m_bDateChangeMessage)
                        {
                            lpConfProp->ConfInfo.m_bDateChangeMessage = true;
                            MessageBox(hwndDlg, String(g_hInstLib, IDS_CONFPROP_DATECHANGE_MDHCP), NULL, MB_OK | MB_ICONINFORMATION );
                        }
                    }
                }
			}
			break;

		default:
			break;
	}

	return FALSE;
}

static void ConfPropGeneral_SetDateTimeFormats( HWND hwndDlg )
{
	HWND hwndDTPStartDate = GetDlgItem(hwndDlg, IDC_DTP_STARTDATE);
	HWND hwndDTPStartTime = GetDlgItem(hwndDlg, IDC_DTP_STARTTIME);
	HWND hwndDTPStopDate = GetDlgItem(hwndDlg, IDC_DTP_STOPDATE);
	HWND hwndDTPStopTime = GetDlgItem(hwndDlg, IDC_DTP_STOPTIME);

	// conference start time
	TCHAR szFormat[255];
	GetLocaleInfo( LOCALE_USER_DEFAULT,
				   LOCALE_SSHORTDATE,
				   szFormat,
				   ARRAYSIZE(szFormat)  );

	DateTime_SetFormat(hwndDTPStartDate, szFormat );
	DateTime_SetFormat( hwndDTPStopDate,	szFormat );

	// conference stop time
	GetLocaleInfo( LOCALE_USER_DEFAULT,
				   LOCALE_STIMEFORMAT,
				   szFormat,
				   ARRAYSIZE(szFormat)  );
	

	DateTime_SetFormat( hwndDTPStopTime,	szFormat );
	DateTime_SetFormat(hwndDTPStartTime, szFormat );
}

static int ConfPropGeneral_UpdateData(HWND hwndDlg, BOOL bSaveAndValidate)
{
	HRESULT hr = S_OK;
	LPCONFPROP lpConfProp;

	HWND hwndName = GetDlgItem(hwndDlg, IDC_EDIT_NAME);
	HWND hwndDescription = GetDlgItem(hwndDlg, IDC_EDIT_DESCRIPTION);
	HWND hwndOwner = GetDlgItem(hwndDlg, IDC_EDIT_OWNER);
	HWND hwndDTPStartDate = GetDlgItem(hwndDlg, IDC_DTP_STARTDATE);
	HWND hwndDTPStartTime = GetDlgItem(hwndDlg, IDC_DTP_STARTTIME);
	HWND hwndDTPStopDate = GetDlgItem(hwndDlg, IDC_DTP_STOPDATE);
	HWND hwndDTPStopTime = GetDlgItem(hwndDlg, IDC_DTP_STOPTIME);

	BSTR bstrName = NULL;
	BSTR bstrDescription = NULL;
	BSTR bstrOwner = NULL;
	TCHAR szName[NAME_MAXLEN + 1];
	TCHAR szDescription[DESCRIPTION_MAXLEN + 1] = _T("");
	TCHAR szOwner[OWNER_MAXLEN + 1] = _T("");
	SYSTEMTIME st;
	USHORT nYear;
	BYTE nMonth, nDay, nHour, nMinute;

	USES_CONVERSION;

    _ASSERT( IsWindow(hwndDlg) );

	lpConfProp = (LPCONFPROP) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );

	//
    // We have to verify lpConfProp
    //

    if( NULL == lpConfProp )
    {
        return PSNRET_INVALID_NOCHANGEPAGE;
    }
	
	if (!bSaveAndValidate) // initialization
	{
		// conference name
		//
		Edit_LimitText(hwndName, NAME_MAXLEN);

		lpConfProp->ConfInfo.get_Name(&bstrName);
		if (bstrName == NULL)
		{
			// Make up a default name for the conference
			CComBSTR bstrTemp(L"");
            if( bstrTemp.m_str == NULL )
            {
                // E_OUTOFMEMORY
    			_tcsncpy( szName, _T(""), NAME_MAXLEN );
            }
            else
            {
			    lpConfProp->ConfInfo.GetPrimaryUser( &bstrTemp );
			    bstrTemp.Append( String(g_hInstLib, IDS_CONFPROP_UNTITLED_DEFAULT_APPEND) );
			    _tcsncpy( szName, OLE2CT(bstrTemp), NAME_MAXLEN );
            }
		}
		else
		{
			_tcsncpy( szName, OLE2CT(bstrName), NAME_MAXLEN );
		}
		Edit_SetText(hwndName, szName);

		// Don't allow name to be editted if this is an existing conference
		if ( !lpConfProp->ConfInfo.IsNewConference() )
			EnableWindow( hwndName, false );

		// conference description
		//
		Edit_LimitText(hwndDescription, DESCRIPTION_MAXLEN);
		lpConfProp->ConfInfo.get_Description(&bstrDescription);
		if (bstrDescription )
			_tcsncpy(szDescription, OLE2CT(bstrDescription), DESCRIPTION_MAXLEN);

		Edit_SetText(hwndDescription, szDescription);

		// conference owner
		//
		Edit_LimitText(hwndOwner, OWNER_MAXLEN);
		lpConfProp->ConfInfo.get_Originator(&bstrOwner);
		if (bstrOwner )
			_tcsncpy(szOwner, OLE2CT(bstrOwner), OWNER_MAXLEN);

		Edit_SetText(hwndOwner, szOwner);
		
		ConfPropGeneral_SetDateTimeFormats( hwndDlg );

		lpConfProp->ConfInfo.GetStartTime(&nYear, &nMonth, &nDay, &nHour, &nMinute);
		st.wYear = nYear;
		st.wMonth = nMonth;
		st.wDayOfWeek = 0;
		st.wDay = nDay;
		st.wHour = nHour;
		st.wMinute = nMinute;
		st.wSecond = 0;
		st.wMilliseconds = 0;

		DateTime_SetSystemtime( hwndDTPStartDate, GDT_VALID, &st );
		DateTime_SetSystemtime( hwndDTPStartTime, GDT_VALID, &st );

		lpConfProp->ConfInfo.GetStopTime(&nYear, &nMonth, &nDay, &nHour, &nMinute);
		st.wYear = nYear;
		st.wMonth = nMonth;
		st.wDayOfWeek = 0;
		st.wDay = nDay;
		st.wHour = nHour;
		st.wMinute = nMinute;
		st.wSecond = 0;
		st.wMilliseconds = 0;

		DateTime_SetSystemtime( hwndDTPStopDate, GDT_VALID, &st );
		DateTime_SetSystemtime( hwndDTPStopTime, GDT_VALID, &st );
	}

	else // if (bSaveAndValidate)
	{
		// conference name
		//

        //
        // We have to initialize szName
        //

        szName[0] = (TCHAR)0;

		Edit_GetText(hwndName, szName, NAME_MAXLEN+1);
        bstrName = SysAllocString(T2COLE(szName));

        //
        // We have to verify the allocation and
        // initialize the szName
        //

        if( IsBadStringPtr( bstrName, (UINT)-1) )
        {
            return PSNRET_INVALID_NOCHANGEPAGE;
        }

		if ( !*szName )
		{
			// improper name
		    MessageBox(hwndDlg, String(g_hInstLib, IDS_CONFPROP_NONAME), NULL, MB_OK | MB_ICONEXCLAMATION);
		}
		else 
		{
			lpConfProp->ConfInfo.put_Name(bstrName);
		}

		// conference description
		//
		Edit_GetText(hwndDescription, szDescription, DESCRIPTION_MAXLEN);
		bstrDescription = SysAllocString(T2COLE(szDescription));

        //
        // We have to validate the allocation
        //

        if( IsBadStringPtr( bstrDescription, (UINT)-1) )
        {
	        SysFreeString(bstrName);
            return PSNRET_INVALID_NOCHANGEPAGE;
        }

		lpConfProp->ConfInfo.put_Description(bstrDescription);

		// conference start time
		//
		if ( DateTime_GetSystemtime(hwndDTPStartDate, &st) == GDT_VALID )
		{
			nYear = (UINT) st.wYear;
			nMonth = (BYTE) st.wMonth;
			nDay = (BYTE) st.wDay;

			if ( DateTime_GetSystemtime(hwndDTPStartTime, &st) == GDT_VALID )
			{
				nHour = (BYTE) st.wHour;
				nMinute = (BYTE) st.wMinute;

				lpConfProp->ConfInfo.SetStartTime(nYear, nMonth, nDay, nHour, nMinute);
			}
		}

		// conference stop time
		//
		if ( DateTime_GetSystemtime(hwndDTPStopDate, &st) == GDT_VALID )
		{
			nYear = (UINT) st.wYear;
			nMonth = (BYTE) st.wMonth;
			nDay = (BYTE) st.wDay;

			if ( DateTime_GetSystemtime(hwndDTPStopTime, &st) == GDT_VALID )
			{
				nHour = (BYTE) st.wHour;
				nMinute = (BYTE) st.wMinute;

				lpConfProp->ConfInfo.SetStopTime(nYear, nMonth, nDay, nHour, nMinute);
			}
		}

		// MDHCP info
		HWND hWndLst = GetDlgItem(hwndDlg, IDC_LST_SCOPE );
		if ( hWndLst )
		{
            int nSel = SendMessage(hWndLst, LB_GETCURSEL, 0, 0);
            lpConfProp->ConfInfo.m_bUserSelected = (nSel != LB_ERR);
            lpConfProp->ConfInfo.m_lScopeID = SendMessage( hWndLst, LB_GETITEMDATA, nSel, 0 );
		}

		DWORD dwError;
		hr = lpConfProp->ConfInfo.CommitGeneral( dwError );
		if ( hr != S_OK )
		{
			//get proper message
			UINT uId = IDS_CONFPROP_INVALIDTIME + dwError - 1;
			MessageBox(hwndDlg, String(g_hInstLib, uId), NULL, MB_OK | MB_ICONEXCLAMATION );
		}
	}

	SysFreeString(bstrName);
	SysFreeString(bstrDescription);
	SysFreeString(bstrOwner);

	return (hr == S_OK) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}


//////////////////////////////////////////////////////////////////
// This is the thread that goes out and enumerates the scopes
//
DWORD WINAPI ThreadMDHCPScopeEnum( LPVOID pParam )
{
	ATLTRACE(_T(".enter.ThreadMDHCPScopeEnum().\n"));
	HWND hWndDlg = (HWND) pParam;
	if ( !IsWindow(hWndDlg) ) return E_ABORT;
	
	HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY );
	if ( SUCCEEDED(hr) )
	{
		HWND hWndList = GetDlgItem(hWndDlg, IDC_LST_SCOPE );

		CConfInfo::PopulateListWithMDHCPScopeDescriptions( hWndList );
		CoUninitialize();
	}

	ATLTRACE(_T(".exit.ThreadMDHCPScopeEnum(%ld).\n"), hr);
	return hr;
}

void ShowScopeInfo( HWND hwndDlg, int nShow, bool bInit )
{
	HWND hWndFrm = GetDlgItem( hwndDlg, IDC_FRM_SCOPE );
	HWND hWndLbl = GetDlgItem( hwndDlg, IDC_LBL_SCOPE );
	HWND hWndLst = GetDlgItem( hwndDlg, IDC_LST_SCOPE );

	if ( hWndFrm ) ShowWindow( hWndFrm, nShow );
	if ( hWndLbl ) ShowWindow( hWndLbl, nShow );
	if ( hWndLst )
	{
		ShowWindow( hWndLst, nShow );
		if ( bInit )
		{
			EnableWindow( hWndLst, FALSE );
			SendMessage( hWndLst, LB_RESETCONTENT, 0, 0 );
			SendMessage( hWndLst, LB_ADDSTRING, 0, (LPARAM) String(g_hInstLib, IDS_CONFPROP_ENUMERATING_SCOPES) );

			DWORD dwID;
			HANDLE hThread = CreateThread( NULL, 0, ThreadMDHCPScopeEnum, (void *) hwndDlg, NULL, &dwID );
			if ( hThread ) CloseHandle( hThread );
		}
	}    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\confprop.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// confprop.h - conference properties dialog box
////

#ifndef _INC_CONFPROP_DLG
#define _INC_CONFPROP_DLG

//#ifdef __cplusplus
//extern "C" {
//#endif

#include "winlocal.h"

#include "tapi3if.h"
#include "rend.h"
#include "ConfInfo.h"

typedef struct CONFPROP
{
	DWORD dwFlags;
	CConfInfo	ConfInfo;
} CONFPROP, FAR *LPCONFPROP;

////
// public
////

INT64 ConfProp_DoModal( HWND hwndOwner, CONFPROP &confprop );

void ConfProp_Init( HINSTANCE hInst );

//#ifdef __cplusplus
//}
//#endif

#endif  // !_INC_DLG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\objsec.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and29 product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <winnt.h>
#include "res.h"
#include "objsec.h"
#include "rndsec.h"


#define DSOP_FILTER_COMMON ( DSOP_FILTER_USERS |					\
							 DSOP_FILTER_UNIVERSAL_GROUPS_SE |		\
							 DSOP_FILTER_GLOBAL_GROUPS_SE )

#define DSOP_FILTER_DL_COMMON1      ( DSOP_DOWNLEVEL_FILTER_USERS           \
                                    | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS   \
                                    | DSOP_DOWNLEVEL_FILTER_COMPUTERS       \
                                    )

#define DSOP_FILTER_DL_COMMON2      ( DSOP_FILTER_DL_COMMON1                    \
                                    | DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS  \
                                    )

#define DSOP_FILTER_DL_COMMON3      ( DSOP_FILTER_DL_COMMON2                \
                                    | DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS    \
                                    )


#define DECLARE_SCOPE(t,f,b,m,n,d)  \
{ sizeof(DSOP_SCOPE_INIT_INFO), (t), (f), { { (b), (m), (n) }, (d) }, NULL, NULL, S_OK }

static const DSOP_SCOPE_INIT_INFO g_aDSOPScopes[] =
{
    // The domain to which the target computer is joined.
    DECLARE_SCOPE(DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,                  \
                  DSOP_SCOPE_FLAG_STARTING_SCOPE,                         \
                  0,                                                      \
                  DSOP_FILTER_COMMON & ~DSOP_FILTER_UNIVERSAL_GROUPS_SE, \
                  DSOP_FILTER_COMMON,                                    \
                  0),

    DECLARE_SCOPE(DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,0,0,0,0,DSOP_FILTER_DL_COMMON2),

    // The Global Catalog
    DECLARE_SCOPE(DSOP_SCOPE_TYPE_GLOBAL_CATALOG,0,DSOP_FILTER_COMMON|DSOP_FILTER_WELL_KNOWN_PRINCIPALS,0,0,0),

    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    DECLARE_SCOPE(DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,0,DSOP_FILTER_COMMON,0,0,0),

    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    DECLARE_SCOPE(DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN, \
                  0,                        \
                  DSOP_FILTER_COMMON,      \
                  0,                        \
                  0,                        \
                  DSOP_DOWNLEVEL_FILTER_USERS | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS),

    // Target computer scope.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    
    DECLARE_SCOPE(DSOP_SCOPE_TYPE_TARGET_COMPUTER,0,0,0,0,DSOP_FILTER_DL_COMMON3),
};


GENERIC_MAPPING ObjMap =
{
    ACCESS_READ,
    ACCESS_MODIFY,
    ACCESS_DELETE,
};

SI_ACCESS g_siObjAccesses[] = 
{
    { &GUID_NULL, ACCESS_READ,      MAKEINTRESOURCEW(IDS_PRIV_READ),      SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACCESS_MODIFY,    MAKEINTRESOURCEW(IDS_PRIV_MODIFY),    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACCESS_DELETE,    MAKEINTRESOURCEW(IDS_PRIV_DELETE),    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
};

#define g_iObjDefAccess    GENERIC_READ


// The following array defines the inheritance types for my containers.
SI_INHERIT_TYPE g_siObjInheritTypes[] =
{
    &GUID_NULL, 0, L"This container/object only",
};

/////////////////////////////////////////////////////////////////////////////////////////
CObjSecurity::CObjSecurity() : m_cRef(1)
{
	USES_CONVERSION;
	m_dwSIFlags = NULL;
	m_pConfProp = NULL;

    //
    // Let's have a properly constructor
    //

    m_bstrObject = NULL;
    m_bstrPage = NULL;

	m_pObjectPicker = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////
CObjSecurity::~CObjSecurity()
{
    //
    // Properly deallocation
    //

    if( m_bstrObject )
	    SysFreeString( m_bstrObject );

    if( m_bstrPage )
    	SysFreeString( m_bstrPage );

	if ( m_pObjectPicker )
		m_pObjectPicker->Release();
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::InternalInitialize( CONFPROP* pConfProp )
{
    HRESULT hr = S_OK;
    //
    // we can initialize BSTRs here
    //

	m_bstrObject = SysAllocString( T2COLE(String(g_hInstLib, IDS_CONFPROP_PERMISSIONS_OBJECT )) );
    if( IsBadStringPtr( m_bstrObject, (UINT)-1) )
        return E_OUTOFMEMORY;

	m_bstrPage = SysAllocString( T2COLE(String(g_hInstLib, IDS_CONFPROP_PERMISSIONS_PAGE )) );
    if( IsBadStringPtr( m_bstrPage, (UINT)-1) )
    {
        SysFreeString( m_bstrObject);
        return E_OUTOFMEMORY;
    }

    m_pConfProp = pConfProp;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//IUnknown Methods
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CObjSecurity::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CObjSecurity::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
    }
    else if ( IsEqualIID(riid, IID_IDsObjectPicker) )
	{
        *ppv = static_cast<IDsObjectPicker*> (this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

	m_cRef++;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
// IDsObjectPicker
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CObjSecurity::Initialize( PDSOP_INIT_INFO pInitInfo )
{
    HRESULT hr = S_OK;
    DSOP_INIT_INFO InitInfo;
    PDSOP_SCOPE_INIT_INFO pDSOPScopes = NULL;

	_ASSERT( pInitInfo->cbSize >= FIELD_OFFSET(DSOP_INIT_INFO, cAttributesToFetch) );

	// Create an instance of the object
    if (!m_pObjectPicker)
    {
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (LPVOID*)&m_pObjectPicker);
    }

	if ( SUCCEEDED(hr) )
	{
		// Make a local copy of the InitInfo so we can modify it safely
		CopyMemory(&InitInfo, pInitInfo, min(pInitInfo->cbSize, sizeof(InitInfo)));

		// Make a local copy of g_aDSOPScopes so we can modify it safely.
		// Note also that m_pObjectPicker->Initialize returns HRESULTs
		// in this buffer.
		pDSOPScopes = (PDSOP_SCOPE_INIT_INFO)LocalAlloc(LPTR, sizeof(g_aDSOPScopes));
		if (pDSOPScopes)
		{
			CopyMemory(pDSOPScopes, g_aDSOPScopes, sizeof(g_aDSOPScopes));

			// Override the ACLUI default scopes, but don't touch
			// the other stuff.
//			pDSOPScopes->pwzDcName = m_strServerName;
			InitInfo.cDsScopeInfos = ARRAYSIZE(g_aDSOPScopes);
			InitInfo.aDsScopeInfos = pDSOPScopes;

			hr = m_pObjectPicker->Initialize(&InitInfo);

			LocalFree(pDSOPScopes);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}

STDMETHODIMP CObjSecurity::InvokeDialog( HWND hwndParent, IDataObject **ppdoSelection )
{
    HRESULT hr = E_UNEXPECTED;
    _ASSERT( ppdoSelection );

    if (m_pObjectPicker)
        hr = m_pObjectPicker->InvokeDialog(hwndParent, ppdoSelection);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
// ISecurityInformation methods
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    m_dwSIFlags = SI_EDIT_OWNER	| SI_EDIT_PERMS | SI_NO_ACL_PROTECT	|	\
				  SI_PAGE_TITLE;

    pObjectInfo->dwFlags = m_dwSIFlags;
    pObjectInfo->hInstance = g_hInstLib;
    pObjectInfo->pszServerName = NULL;          //use local computer
    pObjectInfo->pszObjectName = m_bstrObject;
	pObjectInfo->pszPageTitle = m_bstrPage;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::GetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault)
{
	HRESULT hr = S_OK;

	// Make the default if necessary...
	if ( !m_pConfProp->ConfInfo.m_pSecDesc )
	{
		hr = CoCreateInstance( CLSID_SecurityDescriptor,
							   NULL,
							   CLSCTX_INPROC_SERVER,
							   IID_IADsSecurityDescriptor,
							   (void **) &m_pConfProp->ConfInfo.m_pSecDesc );

		// Add default settings if successfully created the ACE
		if ( SUCCEEDED(hr) )
			hr = m_pConfProp->ConfInfo.AddDefaultACEs( m_pConfProp->ConfInfo.IsNewConference() );
	}

	// If we failed to get the defaults, just use whatever you can...
	if ( !m_pConfProp->ConfInfo.m_pSecDesc )
	{
		PSECURITY_DESCRIPTOR psdNewSD = LocalAlloc(LPTR,SECURITY_DESCRIPTOR_MIN_LENGTH);

        //
        // Validate the allocation
        //
        if( psdNewSD == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //
            // Allocation succeeded
            //
		    if( !InitializeSecurityDescriptor(psdNewSD,SECURITY_DESCRIPTOR_REVISION) )
		    {
			    hr = GetLastError();
		    }
        }

		*ppSD = psdNewSD;
	}
	else
	{
		DWORD dwSDLen = 0;
		ATLTRACE(_T(".1.CObjSecurity::GetSecurity() pre->Convert ticks = %ld.\n"), GetTickCount() );
		hr = ConvertObjectToSD( m_pConfProp->ConfInfo.m_pSecDesc, ppSD, &dwSDLen );
		ATLTRACE(_T(".1.CObjSecurity::GetSecurity() post Convert ticks = %ld.\n"), GetTickCount() );
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::SetSecurity( SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
	if ( !m_pConfProp ) return E_UNEXPECTED;

	HRESULT hr = S_OK;
	m_pConfProp->ConfInfo.SetSecuritySet( true );
	
	
	///////////////////////////////////////////////////////////
	// If we don't have an existing SD, create one
	//
	if ( !m_pConfProp->ConfInfo.m_pSecDesc )
	{
		hr = CoCreateInstance( CLSID_SecurityDescriptor,
							   NULL,
							   CLSCTX_INPROC_SERVER,
							   IID_IADsSecurityDescriptor,
							   (void **) &m_pConfProp->ConfInfo.m_pSecDesc );

		// Failed te create the security descriptor object
		if ( FAILED(hr) ) return hr;
	}


	/////////////////////////////////////////////////////////////////////////////////
	// Set properties on the Security Descriptor
	//

	// Get control and revision information from SD
    DWORD dwRevision = 0;
    WORD  wControl = 0;
	DWORD dwRet = GetSecurityDescriptorControl( pSD, &wControl, &dwRevision );
    if ( !dwRet ) return HRESULT_FROM_WIN32(GetLastError());

	hr = m_pConfProp->ConfInfo.m_pSecDesc->put_Control( wControl );
	BAIL_ON_FAILURE(hr);

	hr = m_pConfProp->ConfInfo.m_pSecDesc->put_Revision( dwRevision );
	BAIL_ON_FAILURE(hr);

	////////////////////////////////////////////////
	// What was modified on the SD?
	if ( si & OWNER_SECURITY_INFORMATION )
	{
		BOOL bOwnerDefaulted = FALSE;
		LPBYTE pOwnerSidAddress = NULL;

		dwRet = GetSecurityDescriptorOwner( pSD, (PSID *) &pOwnerSidAddress, &bOwnerDefaulted );
		if ( dwRet )
		{
			LPWSTR pszOwner = NULL;
			if ( SUCCEEDED(hr = ConvertSidToFriendlyName(pOwnerSidAddress, &pszOwner)) )
			{
				if ( SUCCEEDED(hr = m_pConfProp->ConfInfo.m_pSecDesc->put_OwnerDefaulted((VARIANT_BOOL) bOwnerDefaulted)) )
					hr = m_pConfProp->ConfInfo.m_pSecDesc->put_Owner( pszOwner );
			}

			// Clean - up
			if ( pszOwner )	delete pszOwner;
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}

	///////////////////////////////////////////////////////
	// Group security information changing...
	if ( si & GROUP_SECURITY_INFORMATION )
	{
		BOOL bGroupDefaulted = FALSE;
		LPBYTE pGroupSidAddress = NULL;

		dwRet = GetSecurityDescriptorGroup( pSD,
											(PSID *)&pGroupSidAddress,
											&bGroupDefaulted	);
		if ( dwRet )
		{
			LPWSTR pszGroup = NULL;
			if ( SUCCEEDED(hr = ConvertSidToFriendlyName(pGroupSidAddress, &pszGroup)) )
			{
				if ( SUCCEEDED(hr = m_pConfProp->ConfInfo.m_pSecDesc->put_GroupDefaulted((VARIANT_BOOL) bGroupDefaulted)) )
					hr = m_pConfProp->ConfInfo.m_pSecDesc->put_Group( pszGroup );
			}

			// Clean - up
			if ( pszGroup ) delete pszGroup;
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	} 

	///////////////////////////////////////////////
	// DACL list changing
	if ( si & DACL_SECURITY_INFORMATION )
	{
		LPBYTE pDACLAddress = NULL;
		BOOL bDaclPresent = FALSE, bDaclDefaulted = FALSE;
		VARIANT varDACL;
		VariantInit( &varDACL );

		// Extract DACL
		GetSecurityDescriptorDacl( pSD,
								   &bDaclPresent,
								   (PACL*) &pDACLAddress,
								   &bDaclDefaulted );

		if ( bDaclPresent && pDACLAddress && SUCCEEDED(hr = ConvertACLToVariant((PACL) pDACLAddress, &varDACL)) )
		{
			if ( SUCCEEDED(hr = m_pConfProp->ConfInfo.m_pSecDesc->put_DaclDefaulted((VARIANT_BOOL) bDaclDefaulted)) )
				hr = m_pConfProp->ConfInfo.m_pSecDesc->put_DiscretionaryAcl( V_DISPATCH(&varDACL) );
		}

		// Clean - up
		VariantClear( &varDACL );
	}

failed:
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    *ppAccesses = g_siObjAccesses;
    *pcAccesses = sizeof(g_siObjAccesses)/sizeof(g_siObjAccesses[0]);
    *piDefaultAccess = g_iObjDefAccess;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask)
{
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
    *ppInheritTypes = g_siObjInheritTypes;
    *pcInheritTypes = sizeof(g_siObjInheritTypes)/sizeof(g_siObjInheritTypes[0]);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::PropertySheetPageCallback(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage)
{
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\res.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// res.h - resource functions
////

#ifndef __RES_H__
#define __RES_H__

#include "resource.h"

#define ARRAYSIZE(_AR_)		(sizeof(_AR_) / sizeof(_AR_[0]))

// Bug397418 Increase the szRes from 256 to 512 to make space
// for IDS_CONFPROP_MDHCP_FAILED string resource
static TCHAR szRes[512];
#define String(hInst, uID) \
	(*szRes = '\0', LoadString(hInst, uID, szRes, ARRAYSIZE(szRes)), szRes)
//	_lstrcpy((LPTCHAR) _alloca(256), szRes))

#endif // __RES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\wnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wnd.c - window functions
////

#include "winlocal.h"

// WndCenterWindow - center one window on top of another
//		<hwnd1>				(i) window to be centered
//		<hwnd2>				(i) window to be centered upon
//			NULL				center on parent or owner
//		<xOffCenter>		(i) offset from horizontal center
//			0					center window exactly
//		<yOffCenter>		(i) offset from vertical center
//			0					center window exactly
// return 0 if success
//
int DLLEXPORT WINAPI WndCenterWindow(HWND hwnd1, HWND hwnd2, int xOffCenter, int yOffCenter)
{
	POINT pt;
	RECT rc1;
	RECT rc2;
	int nWidth;
	int nHeight;

	if ( hwnd1 )
	{
		// use parent or owner window if no other specified
		//
		if (hwnd2 == NULL)
			hwnd2 = GetParent(hwnd1);

		// use desktop window if no parent or owner
		// or if parent or owner is iconic or invisible
		//
		if (hwnd2 == NULL || IsIconic(hwnd2) || !IsWindowVisible(hwnd2))
			hwnd2 = GetDesktopWindow();

		// get the rectangles for both windows
		//
		GetWindowRect(hwnd1, &rc1);
		GetClientRect(hwnd2, &rc2);

		// calculate the height and width for MoveWindow
		//
		nWidth = rc1.right - rc1.left;
		nHeight = rc1.bottom - rc1.top;

		// find the center point and convert to screen coordinates
		//
		pt.x = (rc2.right - rc2.left) / 2;
		pt.y = (rc2.bottom - rc2.top) / 2;
		ClientToScreen(hwnd2, &pt);

		// calculate the new x, y starting point
		//
		pt.x -= (nWidth / 2);
		pt.y -= (nHeight / 2);

		// adjust the window position off center, if necessary
		//
		pt.x = max(0, pt.x + xOffCenter);
		pt.y = max(0, pt.y + yOffCenter);
	
		// center the window
		//
		MoveWindow( hwnd1, pt.x, pt.y, nWidth, nHeight, FALSE );
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\rndsec.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rndsec.h

Abstract:

    Security utilities for Rendezvous Control.

Author:

    KrishnaG (from OLEDS team)

Environment:

    User Mode - Win32

Revision History:

    12-Dec-1997 DonRyan
        Munged KrishnaG's code to work with Rendezvous Control.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <iads.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT
ConvertSDToVariant(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT VARIANT * pVarSec
    );

HRESULT
ConvertSDToIDispatch(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT IDispatch ** ppIDispatch
    );

HRESULT
ConvertObjectToSD(
    IN  IADsSecurityDescriptor FAR * pSecDes,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PDWORD pdwSDLength
    );

HRESULT
ConvertObjectToSDDispatch(
    IN  IDispatch * pDisp,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PDWORD pdwSDLength
    );

HRESULT
ConvertACLToVariant(
    PACL pACL,
    LPVARIANT pvarACL
    );

HRESULT
ConvertSidToFriendlyName(
    PSID pSid,
    LPWSTR * ppszAccountName
    );

HRESULT
ConvertTrusteeToSid(
    BSTR bstrTrustee,
    PSID * ppSid,
    PDWORD pdwSidSize
    );

HRESULT
ConvertStringToSid(
    IN  PWSTR       string,
    OUT PSID       *sid,
    OUT PDWORD     pdwSidSize,
    OUT PWSTR      *end
	 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\objsec.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and29 product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef _OBJSEC_H_
#define _OBJSEC_H_

#include "aclui.h"
#include "confprop.h"
#include "objsel.h"

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//Class CObjSecurity
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

class CObjSecurity : public ISecurityInformation, IDsObjectPicker
{
public:
   CObjSecurity();
    virtual ~CObjSecurity();

protected:
    ULONG                   m_cRef;
    DWORD                   m_dwSIFlags;
    CONFPROP				*m_pConfProp;
	BSTR					m_bstrObject;
	BSTR					m_bstrPage;
    IDsObjectPicker			*m_pObjectPicker;

// Interface methods
public:
    STDMETHOD(InternalInitialize)(CONFPROP* pConfProp);

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);

    // IDsObjectPicker
    STDMETHOD(Initialize)(PDSOP_INIT_INFO pInitInfo);
    STDMETHOD(InvokeDialog)(HWND hwndParent, IDataObject **ppdoSelection);
};



/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) { goto failed; }

#define BAIL_ON_BOOLFAIL(_FN_) \
		if ( !_FN_ )									\
		{												\
			hr = HRESULT_FROM_WIN32(GetLastError());	\
			goto failed;								\
		}

#define INC_ACCESS_ACL_SIZE(_SIZE_, _SID_)	\
		_SIZE_ += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(_SID_));


extern HINSTANCE g_hInstLib;

#define INHERIT_FULL            (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)

//
// DESCRIPTION OF ACCESS FLAG AFFECTS
//
// SI_ACCESS_GENERAL shows up on general properties page
// SI_ACCESS_SPECIFIC shows up on advanced page
// SI_ACCESS_CONTAINER shows on general page IF object is a container
//
// The following array defines the permission names for my objects.
//

// Access rights for our private objects
/*
#define ACCESS_READ		0x10
#define ACCESS_MODIFY   0x20
#define ACCESS_DELETE   (DELETE | WRITE_DAC | 0xf)
*/
#define ACCESS_READ		0x10
#define ACCESS_WRITE	0x20
#define ACCESS_MODIFY   (ACCESS_WRITE | WRITE_DAC)
#define ACCESS_DELETE   DELETE

#define ACCESS_ALL		(ACCESS_READ | ACCESS_MODIFY | ACCESS_DELETE)



#endif //_OBJSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\rndsec.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rndsec.cpp

Abstract:

    Security utilities for Rendezvous Control.

Author:

    KrishnaG (from OLEDS team)

Environment:

    User Mode - Win32

Revision History:

    12-Dec-1997 DonRyan
        Munged KrishnaG's code to work with Rendezvous Control.

--*/


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SECURITY_WIN32

//#include <security.h>
#include "winlocal.h"
#include <objbase.h>
#include <initguid.h>
#include <iads.h>

#include <stdlib.h>
#include <limits.h>

#include <io.h>
#include <wchar.h>
#include <tchar.h>
//#include "ntseapi.h"
#include "rndsec.h"

///////////////////////////////////////////////////////////////////////////////
//Not defined, so I pulled it from ntseapi.h
///////////////////////////////////////////////////////////////////////////////

typedef struct _COMPOUND_ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    USHORT CompoundAceType;
    USHORT Reserved;
    ULONG SidStart;
} COMPOUND_ACCESS_ALLOWED_ACE;

typedef COMPOUND_ACCESS_ALLOWED_ACE *PCOMPOUND_ACCESS_ALLOWED_ACE;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private macros                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) { goto error; }

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) { continue; }


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


LPWSTR
AllocADsStr(
    LPWSTR pStr
)
{
   LPWSTR pMem;

   if (!pStr)
      return NULL;

   if (pMem = new WCHAR[wcslen(pStr) + 1])
      wcscpy(pMem, pStr);

   return pMem;
}


HRESULT
ConvertSidToString(
    PSID pSid,
    LPWSTR   String
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal


Arguments:

    pSid - opaque pointer that supplies the SID that is to be
    converted to Unicode.

Return Value:

    If the Sid is successfully converted to a Unicode string, a
    pointer to the Unicode string is returned, else NULL is
    returned.

--*/

{
    WCHAR Buffer[256];
    UCHAR   i;
    ULONG   Tmp;
    HRESULT hr = S_OK;

    SID_IDENTIFIER_AUTHORITY    *pSidIdentifierAuthority;
    PUCHAR                      pSidSubAuthorityCount;

    if (!IsValidSid( pSid )) {
        *String= L'\0';
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        return(hr);
    }

    wsprintfW(Buffer, L"S-%u-", (USHORT)(((PISID)pSid)->Revision ));
    wcscpy(String, Buffer);

    pSidIdentifierAuthority = GetSidIdentifierAuthority(pSid);

    if (  (pSidIdentifierAuthority->Value[0] != 0)  ||
          (pSidIdentifierAuthority->Value[1] != 0)     ){
        wsprintfW(Buffer, L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)pSidIdentifierAuthority->Value[0],
                    (USHORT)pSidIdentifierAuthority->Value[1],
                    (USHORT)pSidIdentifierAuthority->Value[2],
                    (USHORT)pSidIdentifierAuthority->Value[3],
                    (USHORT)pSidIdentifierAuthority->Value[4],
                    (USHORT)pSidIdentifierAuthority->Value[5] );
        wcscat(String, Buffer);

    } else {

        Tmp = (ULONG)pSidIdentifierAuthority->Value[5]          +
              (ULONG)(pSidIdentifierAuthority->Value[4] <<  8)  +
              (ULONG)(pSidIdentifierAuthority->Value[3] << 16)  +
              (ULONG)(pSidIdentifierAuthority->Value[2] << 24);
        wsprintfW(Buffer, L"%lu", Tmp);
        wcscat(String, Buffer);
    }

    pSidSubAuthorityCount = GetSidSubAuthorityCount(pSid);

    for (i=0;i< *(pSidSubAuthorityCount);i++ ) {
        wsprintfW(Buffer, L"-%lu", *(GetSidSubAuthority(pSid, i)));
        wcscat(String, Buffer);
    }

    return(S_OK);
}

HRESULT
ConvertSidToFriendlyName(
    PSID pSid,
    LPWSTR * ppszAccountName
    )
{
    HRESULT hr = S_OK;
    SID_NAME_USE eUse;
    WCHAR szAccountName[MAX_PATH];
    szAccountName[0] = L'\0';

    WCHAR szDomainName[MAX_PATH];
    szDomainName[0] = L'\0';

    DWORD dwLen = 0;
    DWORD dwRet = 0;

    LPWSTR pszAccountName = NULL;

    DWORD dwAcctLen = 0;
    DWORD dwDomainLen = 0;
    
    dwAcctLen = sizeof(szAccountName);
    dwDomainLen = sizeof(szDomainName);

    dwRet = LookupAccountSidW(
                NULL,
                pSid,
                szAccountName,
                &dwAcctLen,
                szDomainName,
                &dwDomainLen,
                (PSID_NAME_USE)&eUse
                );
    if (!dwRet) {

        hr = ConvertSidToString(
                    pSid,
                    szAccountName
                    );
        BAIL_ON_FAILURE(hr);

        pszAccountName = AllocADsStr(szAccountName);
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *ppszAccountName = pszAccountName;

    }else {

        dwLen = wcslen(szAccountName) + wcslen(szDomainName) + 1 + 1;

        pszAccountName = new WCHAR [dwLen];
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (szDomainName[0] && szAccountName[0]) {
            wsprintfW(pszAccountName,L"%s\\%s",szDomainName, szAccountName);
        }else if (szAccountName[0]) {
            wsprintfW(pszAccountName,L"%s", szAccountName);
        }

        *ppszAccountName = pszAccountName;

    }

error:

    return(hr);
}


HRESULT
ConvertAceToVariant(
    PBYTE pAce,
    LPVARIANT pvarAce
    )
{
    IADsAccessControlEntry * pAccessControlEntry = NULL;
    IDispatch * pDispatch = NULL;

    DWORD dwAceType = 0;
    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    LPWSTR pszAccountName = NULL;
    PACE_HEADER pAceHeader = NULL;
    LPBYTE pSidAddress = NULL;
    LPBYTE pOffset = NULL;
    DWORD dwFlags = 0;

    GUID ObjectGUID;
    GUID InheritedObjectGUID;
    WCHAR szObjectGUID[MAX_PATH];
    WCHAR szInheritedObjectGUID[MAX_PATH];

    HRESULT hr = S_OK;

    szObjectGUID[0] = L'\0';
    szInheritedObjectGUID[0] = L'\0';


    VariantInit(pvarAce);

    hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (void **)&pAccessControlEntry
                );
    BAIL_ON_FAILURE(hr);

    pAceHeader = (ACE_HEADER *)pAce;


    dwAceType = pAceHeader->AceType;
    dwAceFlags = pAceHeader->AceFlags;
    dwAccessMask = *(PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        pSidAddress =  (LPBYTE)pAceHeader + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
        dwFlags = (DWORD)(*(PDWORD)pOffset);

        //
        // Now advance by the size of the flags
        //
        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(&ObjectGUID, pOffset, sizeof(GUID));

            StringFromGUID2(ObjectGUID, szObjectGUID, MAX_PATH);

            pOffset += sizeof (GUID);

        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            memcpy(&InheritedObjectGUID, pOffset, sizeof(GUID));

            StringFromGUID2(InheritedObjectGUID, szInheritedObjectGUID, MAX_PATH);

            pOffset += sizeof (GUID);

        }

        pSidAddress = pOffset;
        break;

    default:
        BAIL_ON_FAILURE(hr);
        break;

    }


    hr = ConvertSidToFriendlyName(
                pSidAddress,
                &pszAccountName
                );

    if (FAILED(hr)){
        pszAccountName = AllocADsStr(L"Unknown Trustee");
    }

    //
    // Now set all the information in the Access Control Entry
    //

    hr = pAccessControlEntry->put_AccessMask(dwAccessMask);
    hr = pAccessControlEntry->put_AceFlags(dwAceFlags);
    hr = pAccessControlEntry->put_AceType(dwAceType);

    //
    // Extended ACE information
    //
    hr = pAccessControlEntry->put_Flags(dwFlags);

    if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Object Type GUID
        //
        hr = pAccessControlEntry->put_ObjectType(szObjectGUID);

    }

    if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Inherited Object Type GUID
        //

        hr = pAccessControlEntry->put_InheritedObjectType(szInheritedObjectGUID);

    }

    hr = pAccessControlEntry->put_Trustee(pszAccountName);

    hr = pAccessControlEntry->QueryInterface(
                IID_IDispatch,
                (void **)&pDispatch
                );
    BAIL_ON_FAILURE(hr);

    V_DISPATCH(pvarAce) =  pDispatch;
    V_VT(pvarAce) = VT_DISPATCH;

cleanup:

    if (pszAccountName) {

        delete (pszAccountName);
    }

    if (pAccessControlEntry) {

        pAccessControlEntry->Release();
    }

    return(hr);


error:

    if (pDispatch) {

        pDispatch->Release();

    }

    goto cleanup;
}


HRESULT
ConvertACLToVariant(
    PACL pACL,
    LPVARIANT pvarACL
    )
{
    IADsAccessControlList * pAccessControlList = NULL;
    IDispatch * pDispatch = NULL;

    VARIANT varAce;
    DWORD dwAclSize = 0;
    DWORD dwAclRevision = 0;
    DWORD dwAceCount = 0;

    ACL_SIZE_INFORMATION AclSize;
    ACL_REVISION_INFORMATION AclRevision;
    DWORD dwStatus = 0;

    DWORD i = 0;
    DWORD dwNewAceCount = 0;

    HRESULT hr = S_OK;
    LPBYTE pAceAddress = NULL;


    memset(&AclSize, 0, sizeof(ACL_SIZE_INFORMATION));
    memset(&AclRevision, 0, sizeof(ACL_REVISION_INFORMATION));


    dwStatus = GetAclInformation(
                        pACL,
                        &AclSize,
                        sizeof(ACL_SIZE_INFORMATION),
                        AclSizeInformation
                        );


    dwStatus = GetAclInformation(
                        pACL,
                        &AclRevision,
                        sizeof(ACL_REVISION_INFORMATION),
                        AclRevisionInformation
                        );

    dwAceCount = AclSize.AceCount;
    dwAclRevision = AclRevision.AclRevision;

    VariantInit(pvarACL);

    hr = CoCreateInstance(
                CLSID_AccessControlList,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlList,
                (void **)&pAccessControlList
                );
    BAIL_ON_FAILURE(hr);

    for (i = 0; i < dwAceCount; i++) {

        dwStatus = GetAce(pACL, i, (void **)&pAceAddress);

        hr = ConvertAceToVariant(
                    pAceAddress,
                    (LPVARIANT)&varAce
                    );

        hr = pAccessControlList->AddAce(V_DISPATCH(&varAce));
        if (SUCCEEDED(hr)) {
           dwNewAceCount++;
        }

        VariantClear(&varAce);
    }

    pAccessControlList->put_AclRevision(dwAclRevision);

    pAccessControlList->put_AceCount(dwNewAceCount);


    hr = pAccessControlList->QueryInterface(
                        IID_IDispatch,
                        (void **)&pDispatch
                        );
    V_VT(pvarACL) = VT_DISPATCH;
    V_DISPATCH(pvarACL) = pDispatch;

error:

    if (pAccessControlList) {

        pAccessControlList->Release();
    }

    return(hr);
}


HRESULT
SecCreateSidFromArray (
    OUT PSID                        *PPSid,
    IN  PSID_IDENTIFIER_AUTHORITY   PSidAuthority,
    IN  UCHAR                       SubAuthorityCount,
    IN  ULONG                       SubAuthorities[],
    OUT PDWORD                      pdwSidSize
    )
/*++

Routine Description:

    Creates a SID with desired authority and sub authorities.

    NOTE:  This routine allocates memory for the SID.  When finished
           the caller should free memory using SEC_FREE (PSid).

Arguments:

    PPSid -- addr of ptr to SID to be created
        Note: if SID creation fails ptr set to NULL

    PSidAuthority -- desired value for SID authority

    SubAuthorityCount -- number of sub authorities desired

    SubAuthorities -- sub-authority values, MUST SPECIFY contain
        at least SubAuthorityCount number of values

Return Value:

    STATUS_SUCCESS if SID created.
    STATUS_UNSUCCESSFUL otherwise.

--*/
{
    USHORT  iSub;           /*  sub-authority index */
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;

    /*  allocate memory for SID */

    dwSidSize = GetSidLengthRequired(SubAuthorityCount);
    *PPSid = (PSID) new BYTE[dwSidSize];
    if (! *PPSid){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    *pdwSidSize = dwSidSize;


    /*  initialize SID with top level SID identifier authority */

    InitializeSid( *PPSid, PSidAuthority, SubAuthorityCount);

    /*  fill in sub authorities */
    for (iSub=0; iSub < SubAuthorityCount; iSub++)
        * GetSidSubAuthority( *PPSid, iSub) = SubAuthorities[iSub];

    /*  sanity check */

    if ( ! IsValidSid( *PPSid) ) {
        delete (*PPSid);
        *PPSid = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        BAIL_ON_FAILURE(hr);
    }

error:


    return(hr);
}


HRESULT
ConvertStringToSid(
    IN  PWSTR       string,
    OUT PSID       *sid,
    OUT PDWORD     pdwSidSize,
    OUT PWSTR      *end
    )
{
    HRESULT                     hr = S_OK;
    UCHAR                       revision;
    UCHAR                       sub_authority_count;
    SID_IDENTIFIER_AUTHORITY    authority;
    ULONG                       sub_authority[SID_MAX_SUB_AUTHORITIES];
    PWSTR                       end_list;
    PWSTR                       current;
    PWSTR                       next;
    ULONG                       x;

    *sid = NULL;

    if (((*string != L'S') && (*string != L's')) || (*(string + 1) != L'-'))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        BAIL_ON_FAILURE(hr);
    }

    current = string + 2;

    revision = (UCHAR)wcstol(current, &end_list, 10);

    current = end_list + 1;

    //
    // Count the number of characters in the indentifer authority...
    //

    next = wcschr(current, L'-');

    if((next != NULL) &&
        (next - current == 6))
    {
        for(x = 0; x < 6; x++)
        {
            authority.Value[x] = (UCHAR)next[x];
        }

        current +=6;
    }
    else
    {
         ULONG Auto = wcstoul(current, &end_list, 10);
         authority.Value[0] = authority.Value[1] = 0;
         authority.Value[5] = (UCHAR)Auto & 0xF;
         authority.Value[4] = (UCHAR)((Auto >> 8) & 0xFF);
         authority.Value[3] = (UCHAR)((Auto >> 16) & 0xFF);
         authority.Value[2] = (UCHAR)((Auto >> 24) & 0xFF);
         current = end_list;
    }

    //
    // Now, count the number of sub auths
    //
    sub_authority_count = 0;
    next = current;

    //
    // We'll have to count our sub authoritys one character at a time,
    // since there are several deliminators that we can have...
    //
    while(next)
    {
        next++;

        if(*next == L'-')
        {
            //
            // We've found one!
            //
            sub_authority_count++;
        }
        else if(*next == L';' || *next  == L'\0')
        {
            *end = next;
            sub_authority_count++;
            break;
        }
    }

    if(sub_authority_count != 0)
    {
        current++;

        for(x = 0; x < sub_authority_count; x++)
        {
            sub_authority[x] = wcstoul(current, &end_list, 10);
            current = end_list + 1;
        }
    }

    //
    // Now, create the SID
    //

    hr = SecCreateSidFromArray(
                    sid,
                    &authority,
                    sub_authority_count,
                    sub_authority,
                    pdwSidSize
                    );

    if (SUCCEEDED(hr))
    {
        /* Set the revision to what was specified in the string, in case, our
           system creates one with newer revision */

        ((SID *)(*sid))->Revision = revision;
    }

error:

    return(hr);
}


HRESULT
ConvertTrusteeToSid(
    BSTR bstrTrustee,
    PSID * ppSid,
    PDWORD pdwSidSize
    )
{
    HRESULT hr = S_OK;
    BYTE Sid[MAX_PATH];
    DWORD dwSidSize = sizeof(Sid);
    DWORD dwRet = 0;
    WCHAR szDomainName[MAX_PATH];
    DWORD dwDomainSize = sizeof(szDomainName)/sizeof(WCHAR);
    SID_NAME_USE eUse;

    PSID pSid = NULL;
    LPWSTR pszEnd = NULL;
    BOOL fNTDSType = FALSE;

    
    dwSidSize = sizeof(Sid);

    dwRet = LookupAccountNameW(
                NULL,
                bstrTrustee,
                Sid,
                &dwSidSize,
                szDomainName,
                &dwDomainSize,
                (PSID_NAME_USE)&eUse
                );
    if (!dwRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // If neither the NTDS nor the U2 conversion
    // worked, then try a textual translation
    //

    if (FAILED(hr)) {

        hr = ConvertStringToSid(
                   bstrTrustee,
                    &pSid,
                    &dwSidSize,
                    &pszEnd
                    );
        BAIL_ON_FAILURE(hr);

        memcpy(Sid,pSid, dwSidSize);

        if (pSid) {
            delete pSid;
        }

    }

    pSid = (PSID) new BYTE[dwSidSize];
    if (!pSid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(pSid, Sid, dwSidSize);

    *pdwSidSize = dwSidSize;

    *ppSid = pSid;

error:

    return(hr);
}


HRESULT
GetOwnerSecurityIdentifier(
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfOwnerDefaulted
    )
{
    BSTR bstrOwner = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Owner(
                    &bstrOwner
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_OwnerDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrOwner && *bstrOwner) {

          hr = ConvertTrusteeToSid(
                    bstrOwner,
                    ppSid,
                    &dwSidSize
                    );
          BAIL_ON_FAILURE(hr);
          *pfOwnerDefaulted = FALSE;
        }else {

            *ppSid = NULL;
            *pfOwnerDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfOwnerDefaulted = TRUE;
    }

error:

    if (bstrOwner) {
        SysFreeString(bstrOwner);
    }

    return(hr);
}


HRESULT
ComputeTotalAclSize(
    PACE_HEADER * ppAceHdr,
    DWORD dwAceCount,
    PDWORD pdwAclSize
    )
{
    DWORD i = 0;
    PACE_HEADER pAceHdr = NULL;
    DWORD dwAceSize = 0;
    DWORD dwAclSize = 0;

    for (i = 0; i < dwAceCount; i++) {

        pAceHdr = *(ppAceHdr + i);
        dwAceSize = pAceHdr->AceSize;
        dwAclSize += dwAceSize;
    }

    dwAclSize += sizeof(ACL);

    *pdwAclSize = dwAclSize;

    return(S_OK);

}


HRESULT
ConvertAccessControlEntryToAce(
    IADsAccessControlEntry * pAccessControlEntry,
    LPBYTE * ppAce
    )
{

    DWORD dwAceType = 0;
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    PSID pSid = NULL;
    DWORD dwSidSize = 0;

    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    DWORD dwAceSize = 0;
    LPBYTE pAce = NULL;
    PACCESS_MASK pAccessMask = NULL;
    PSID pSidAddress = NULL;

    PUSHORT pCompoundAceType = NULL;
    DWORD dwCompoundAceType = 0;

    PACE_HEADER pAceHeader = NULL;

    LPBYTE pOffset = NULL;

    BSTR bstrObjectTypeClsid = NULL;
    BSTR bstrInheritedObjectTypeClsid = NULL;

    GUID ObjectTypeGUID;
    GUID InheritedObjectTypeGUID;
    PULONG pFlags;
    DWORD dwFlags = 0;


    hr = pAccessControlEntry->get_AceType((LONG *)&dwAceType);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_Trustee(&bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = ConvertTrusteeToSid(
                bstrTrustee,
                &pSid,
                &dwSidSize
                );
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AceFlags((long *)&dwAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AccessMask((long *)&dwAccessMask);
    BAIL_ON_FAILURE(hr);


    //
    // we will compensateby adding the entire ACE size
    //

    dwAceSize = dwSidSize - sizeof(ULONG);

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_DENIED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        dwAceSize += sizeof(COMPOUND_ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

         pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pCompoundAceType = (PUSHORT)(pAccessMask + sizeof(ACCESS_MASK));
        *pCompoundAceType = (USHORT)dwCompoundAceType;

        //
        // Fill in the reserved field here.
        //

        pSidAddress = (PSID)((LPBYTE)pCompoundAceType + sizeof(DWORD));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

    case ACCESS_DENIED_OBJECT_ACE_TYPE:

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:


        hr = pAccessControlEntry->get_AceFlags((LONG *)&dwAceFlags);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_Flags((LONG *)&dwFlags);
        BAIL_ON_FAILURE(hr);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        hr = pAccessControlEntry->get_ObjectType(&bstrObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrObjectTypeClsid, &ObjectTypeGUID);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_InheritedObjectType(&bstrInheritedObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrInheritedObjectTypeClsid, &InheritedObjectTypeGUID);
        BAIL_ON_FAILURE(hr);



        dwAceSize += sizeof(ACCESS_ALLOWED_OBJECT_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        //
        // Fill in Flags
        //

        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));

        pFlags = (PULONG)(pOffset);

        *pFlags = dwFlags;

        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &ObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);

        }


        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &InheritedObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);
        }

        pSidAddress = (PSID)((LPBYTE)pOffset);
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    }

    *ppAce = pAce;

error:

    if (bstrTrustee) {
        SysFreeString(bstrTrustee);
    }

    if (pSid) {
        delete (pSid);
    }

    return(hr);
}


HRESULT
ConvertAccessControlListToAcl(
    IADsAccessControlList FAR * pAccessList,
    PACL * ppAcl
    )
{
    IUnknown * pUnknown = NULL;
    IEnumVARIANT * pEnumerator  = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD cReturned = 0;
    VARIANT varAce;

    DWORD dwAceCount = 0;

    IADsAccessControlEntry FAR * pAccessControlEntry = NULL;

    LPBYTE pTempAce = NULL;
    DWORD dwCount = 0;

    PACL pAcl = NULL;
    DWORD dwAclSize = 0;
    PACE_HEADER * ppAceHdr = NULL;

    DWORD dwRet = 0;
    DWORD dwAclRevision = 0;
    DWORD dwStatus = 0;
    DWORD dwError = 0;


    hr = pAccessList->get_AceCount((long *)&dwAceCount);
    BAIL_ON_FAILURE(hr);


    hr = pAccessList->get__NewEnum(
                    &pUnknown
                    );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                        IID_IEnumVARIANT,
                        (void FAR * FAR *)&pEnumerator
                        );
    BAIL_ON_FAILURE(hr);



    ppAceHdr = new PACE_HEADER [dwAceCount];
    if (!ppAceHdr) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwAceCount; i++) {

        VariantInit(&varAce);

        hr = pEnumerator->Next(
                    1,
                    &varAce,
                    &cReturned
                    );

        CONTINUE_ON_FAILURE(hr);


        hr = (V_DISPATCH(&varAce))->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (void **)&pAccessControlEntry
                    );
        CONTINUE_ON_FAILURE(hr);


        hr = ConvertAccessControlEntryToAce(
                    pAccessControlEntry,
                    &(pTempAce)
                    );

        // ZoltanS: Rather than CONTINUE_ON_FAILURE, let's bail so that we
        // know if the Ace we set is invalid.
        BAIL_ON_FAILURE(hr);



        *(ppAceHdr + dwCount) = (PACE_HEADER)pTempAce;

        VariantClear(&varAce);
        if (pAccessControlEntry) {
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;
        }

        dwCount++;
    }

    hr = ComputeTotalAclSize(ppAceHdr, dwCount, &dwAclSize);
    BAIL_ON_FAILURE(hr);

    pAcl = (PACL)new BYTE[dwAclSize];
    if (!pAcl) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = pAccessList->get_AclRevision((long *)&dwAclRevision);
    BAIL_ON_FAILURE(hr);


    dwRet  = InitializeAcl(
                    pAcl,
                    dwAclSize,
                    dwAclRevision
                    );
    if (!dwRet) {
        hr  = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }



    for (i = 0; i < dwCount; i++) {

        dwStatus = AddAce(
                        pAcl,
                        dwAclRevision,
                        i,
                        (LPBYTE)*(ppAceHdr + i),
                        (*(ppAceHdr + i))->AceSize
                        );
        if (!dwStatus) {

            dwError = GetLastError();
        }
    }

    *ppAcl = pAcl;



error:

    if (ppAceHdr) {
        for (i = 0; i < dwCount; i++) {
            if (*(ppAceHdr + i)) {

                delete (*(ppAceHdr + i));
            }
        }

        delete (ppAceHdr);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }


    return(hr);
}


HRESULT
GetGroupSecurityIdentifier(
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfGroupDefaulted
    )
{
    BSTR bstrGroup = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Group(
                    &bstrGroup
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_GroupDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrGroup && *bstrGroup) {

            hr = ConvertTrusteeToSid(
                    bstrGroup,
                    ppSid,
                    &dwSidSize
                    );
            BAIL_ON_FAILURE(hr);
            *pfGroupDefaulted = FALSE;
        }else {
            *ppSid = NULL;
            *pfGroupDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfGroupDefaulted = TRUE;
    }

error:

    if (bstrGroup) {
        SysFreeString(bstrGroup);
    }

    return(hr);

}


HRESULT
GetDacl(
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppDacl,
    PBOOL pfDaclDefaulted
    )
{
    IADsAccessControlList FAR * pDiscAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_DaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfDaclDefaulted = FALSE;
    }else {
        *pfDaclDefaulted = TRUE;
    }

    hr = pSecDes->get_DiscretionaryAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppDacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pDiscAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pDiscAcl,
                ppDacl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pDiscAcl) {
        pDiscAcl->Release();
    }

    return(hr);
}


HRESULT
GetSacl(
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppSacl,
    PBOOL pfSaclDefaulted
    )
{
    IADsAccessControlList FAR * pSystemAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_SaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfSaclDefaulted = FALSE;
    }else {
        *pfSaclDefaulted = TRUE;
    }

    hr = pSecDes->get_SystemAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppSacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pSystemAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pSystemAcl,
                ppSacl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pSystemAcl) {
        pSystemAcl->Release();
    }

    return(hr);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT
ConvertSDToIDispatch(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT IDispatch ** ppIDispatch
    )
{
    IADsSecurityDescriptor * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    LPWSTR pszGroup = NULL;
    LPWSTR pszOwner = NULL;

    BOOL fOwnerDefaulted = 0;
    BOOL fGroupDefaulted = 0;
    BOOL fDaclDefaulted = 0;
    BOOL fSaclDefaulted = 0;

    BOOL fSaclPresent = 0;
    BOOL fDaclPresent = 0;

    LPBYTE pOwnerSidAddress = NULL;
    LPBYTE pGroupSidAddress = NULL;
    LPBYTE pDACLAddress = NULL;
    LPBYTE pSACLAddress = NULL;

    DWORD dwRet = 0;

    VARIANT varDACL;
    VARIANT varSACL;

    HRESULT hr = S_OK;

    DWORD dwRevision = 0;
    WORD  wControl = 0;

    memset(&varSACL, 0, sizeof(VARIANT));
    memset(&varDACL, 0, sizeof(VARIANT));

    if (!pSecurityDescriptor) {
        return(E_FAIL);
    }


    dwRet = GetSecurityDescriptorControl(
                        pSecurityDescriptor,
                        &wControl,
                        &dwRevision
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwRet = GetSecurityDescriptorOwner(
                        pSecurityDescriptor,
                        (PSID *)&pOwnerSidAddress,
                        &fOwnerDefaulted
                        );

    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = ConvertSidToFriendlyName(
                pOwnerSidAddress,
                &pszOwner
                );
    BAIL_ON_FAILURE(hr);


    dwRet = GetSecurityDescriptorGroup(
                        pSecurityDescriptor,
                        (PSID *)&pGroupSidAddress,
                        &fOwnerDefaulted
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = ConvertSidToFriendlyName(
                pGroupSidAddress,
                &pszGroup
                );
    BAIL_ON_FAILURE(hr);


    dwRet = GetSecurityDescriptorDacl(
                        pSecurityDescriptor,
                        &fDaclPresent,
                        (PACL*)&pDACLAddress,
                        &fDaclDefaulted
                        );
    if (pDACLAddress) {

        hr = ConvertACLToVariant(
                (PACL)pDACLAddress,
                &varDACL
                );
        BAIL_ON_FAILURE(hr);
    }



    dwRet = GetSecurityDescriptorSacl(
                        pSecurityDescriptor,
                        &fSaclPresent,
                        (PACL *)&pSACLAddress,
                        &fSaclDefaulted
                        );

    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    if (pSACLAddress) {

        hr = ConvertACLToVariant(
                (PACL)pSACLAddress,
                &varSACL
                );
        BAIL_ON_FAILURE(hr);
    }

    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

	if ( pszOwner )
		hr = pSecDes->put_Owner(pszOwner);
    BAIL_ON_FAILURE(hr);

	if ( pszGroup )
		hr = pSecDes->put_Group(pszGroup);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Revision(dwRevision);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Control((DWORD)wControl);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_DiscretionaryAcl(V_DISPATCH(&varDACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SystemAcl(V_DISPATCH(&varSACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    *ppIDispatch = pDispatch;

error:
    VariantClear(&varSACL);
    VariantClear(&varDACL);

    if (pszOwner) {
        delete (pszOwner);
    }

    if (pszGroup) {
        delete (pszGroup);
    }


    if (pSecDes) {
        pSecDes->Release();
    }

    return(hr);
}

HRESULT
ConvertSDToVariant(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT VARIANT * pVarSec
    )
{
    IDispatch *pIDispatch;

    HRESULT hr = ConvertSDToIDispatch(pSecurityDescriptor, &pIDispatch);

    if (FAILED(hr))
    {
        return hr;
    }

    VariantInit(pVarSec);
    V_VT(pVarSec)       = VT_DISPATCH;
    V_DISPATCH(pVarSec) = pIDispatch;

    return S_OK;
}


HRESULT
ConvertObjectToSD(
    IN  IADsSecurityDescriptor FAR * pSecDes,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PDWORD pdwSDLength
    )
{
    HRESULT hr = S_OK;

    SECURITY_DESCRIPTOR AbsoluteSD;
    PSECURITY_DESCRIPTOR pRelative = NULL;
    BOOL Defaulted = FALSE;
    BOOL DaclPresent = FALSE;
    BOOL SaclPresent = FALSE;

    BOOL fDaclDefaulted = FALSE;
    BOOL fSaclDefaulted = FALSE;
    BOOL fOwnerDefaulted = FALSE;
    BOOL fGroupDefaulted = FALSE;

    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    DWORD   dwSDLength = 0;
    DWORD dwRet = 0;
    BOOL dwStatus = 0;


    //
    // Initialize *pSizeSD = 0;
    //

    dwRet = InitializeSecurityDescriptor (
                &AbsoluteSD,
                SECURITY_DESCRIPTOR_REVISION1
                );
    if (!dwRet) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    hr = GetOwnerSecurityIdentifier(
                pSecDes,
                &pOwnerSid,
                &fOwnerDefaulted
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = SetSecurityDescriptorOwner(
                    &AbsoluteSD,
                    pOwnerSid,
                    fOwnerDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetGroupSecurityIdentifier(
                pSecDes,
                &pGroupSid,
                &fGroupDefaulted
                );
    BAIL_ON_FAILURE(hr);


    dwStatus = SetSecurityDescriptorGroup(
                    &AbsoluteSD,
                    pGroupSid,
                    fGroupDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetDacl(
            pSecDes,
            &pDacl,
            &fDaclDefaulted
            );
    BAIL_ON_FAILURE(hr);


    if (pDacl || fDaclDefaulted) {
        DaclPresent = TRUE;
    }

    dwStatus = SetSecurityDescriptorDacl(
                    &AbsoluteSD,
                    DaclPresent,
                    pDacl,
                    fDaclDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }



    hr = GetSacl(
            pSecDes,
            &pSacl,
            &fSaclDefaulted
            );
    BAIL_ON_FAILURE(hr);


    if (pSacl || fSaclDefaulted) {
        SaclPresent = TRUE;
    }

    dwStatus = SetSecurityDescriptorSacl(
                    &AbsoluteSD,
                    SaclPresent,
                    pSacl,
                    fSaclDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    dwSDLength = GetSecurityDescriptorLength(
                        &AbsoluteSD
                        );

    pRelative = LocalAlloc(LPTR, dwSDLength);
    if (!pRelative) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if (!MakeSelfRelativeSD (&AbsoluteSD, pRelative, &dwSDLength)) {
        delete (pRelative);

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    *ppSecurityDescriptor = pRelative;
    *pdwSDLength = dwSDLength;

cleanup:

    if (pDacl) {
        delete (pDacl);
    }

    if (pSacl) {
        delete (pSacl);
    }

    if (pOwnerSid) {
        delete (pOwnerSid);
    }

    if (pGroupSid) {
        delete (pGroupSid);
    }

    return(hr);

error:
    if (pRelative) {
        LocalFree( pRelative );
    }

    *ppSecurityDescriptor = NULL;
    *pdwSDLength = 0;

    goto cleanup;

}

HRESULT
ConvertObjectToSDDispatch(
    IN  IDispatch * pDisp,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PDWORD pdwSDLength
    )
{
    HRESULT hr;
    IADsSecurityDescriptor * pSecDes;

    hr = pDisp->QueryInterface(
        IID_IADsSecurityDescriptor,
        (VOID **)&pSecDes
        );

    if (FAILED(hr))
    {
        return hr;
    }

    hr = ConvertObjectToSD(pSecDes, ppSecurityDescriptor, pdwSDLength);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\winlocal.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//  winlocal.h - local windows include umbrella
////

#ifndef __WINLOCAL_H__
#define __WINLOCAL_H__

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif 

#include <windows.h>
#include <windowsx.h>
#include <winnt.h>
#include <commctrl.h>
#include <atlbase.h>

#define DLLEXPORT __declspec(dllexport)
#define DECLARE_HANDLE32    DECLARE_HANDLE


#endif // __WINLOCAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\confprop\wnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wnd.h - window functions
////

// WndCenterWindow - center one window on top of another
//		<hwnd1>				(i) window to be centered
//		<hwnd2>				(i) window to be centered upon
//			NULL				center on parent or owner
//		<xOffCenter>		(i) offset from horizontal center
//			0					center window exactly
//		<yOffCenter>		(i) offset from vertical center
//			0					center window exactly
// return 0 if success
//
int DLLEXPORT WINAPI WndCenterWindow(HWND hwnd1, HWND hwnd2, int xOffCenter, int yOffCenter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\synchros\atomics.h ===
////////////////////////////////////////////////
// Atomics.h

#ifndef __ATOMICS_H__
#define __ATOMICS_H__

void AtomicInit();
void AtomicTerm();

// Returns true if val at zero and siezed
bool AtomicSeizeToken( long &lVal );
// Returns true if val at non-zero and released
bool AtomicReleaseToken( long &lVal );


class CAtomicList
{
public:
	typedef enum tag_ListAccess_t
	{
		LIST_READ,
		LIST_WRITE,
	} ListAccess;

// Construction
public:
	CAtomicList();
	~CAtomicList();

// Members
protected:
	long				m_lCount;
	DWORD				m_dwThreadID;
	CRITICAL_SECTION	m_crit;
	HANDLE				m_hEvent;

// Implemetation
public:
	bool Lock( short nType, DWORD dwTimeOut = INFINITE );
	void Unlock( short nType );

};


#endif // __ATOMICS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\transbmp\transbmp.h ===
/////////////////////////////////////////////////////////////////
// TRANSBMP.H
//
// Transparent bitmap header
//

#ifndef __TRANSBMP_H__
#define __TRANSBMP_H__

extern "C" 
{
	void DrawTrans( HDC hDC, HBITMAP hBmp, int x, int y, int dx = -1, int dy = -1 );
	void Draw( HDC hDC, HBITMAP hBmp, int x, int y, int dx = -1, int dy = -1, bool bStretch = false );

	void Draw3dBox(HDC hDC, RECT& rect, bool bUp);
	void Erase3dBox(HDC hDC, RECT& rect, HBRUSH hbr );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\synchros\atomics.cpp ===
/////////////////////////////////////////////////////////////////////
// atomics.cpp
//

#ifndef _WIN32_WINNT
#define _WIN32_WINNT	0x0500
#endif

#include <atlbase.h>
#include "atomics.h"



CComCriticalSection	g_critInc;

void AtomicInit()
{
	g_critInc.Init();
}

void AtomicTerm()
{
	g_critInc.Term();
}

bool AtomicSeizeToken( long &lVal )
{
	bool bRet = false;
	g_critInc.Lock();
	if ( !lVal )
	{
		lVal++;
		bRet = true;
	}
	g_critInc.Unlock();
	return bRet;
}

bool AtomicReleaseToken( long &lVal )
{
	bool bRet = false;
	g_critInc.Lock();
	if ( lVal == 1 )
	{
		lVal--;
		bRet = true;
	}
	g_critInc.Unlock();
	return bRet;
}


///////////////////////////////////////////////////////////////////////////
// class CAtomicList
//

CAtomicList::CAtomicList()
{
	m_dwThreadID = 0;
	m_lCount = 0;
	m_hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
	InitializeCriticalSection( &m_crit );
}

CAtomicList::~CAtomicList()
{
	_ASSERT( m_lCount == 0 );		// don't want to destroy object with outstanding ref's
	CloseHandle( m_hEvent );
	DeleteCriticalSection( &m_crit );
}


bool CAtomicList::Lock( short nType, DWORD dwTimeOut /*= INFINITE*/)
{
	switch ( nType )
	{
		case LIST_READ:
			if ( dwTimeOut == INFINITE )
			{
				EnterCriticalSection( &m_crit );
				m_lCount++;
				LeaveCriticalSection( &m_crit );
			}
			else
			{
				while ( dwTimeOut )
				{
					if ( TryEnterCriticalSection(&m_crit) )
					{
						m_lCount++;
						LeaveCriticalSection(&m_crit);
						break;
					}
					else
					{
						// Sleep for a while
						if ( dwTimeOut > 50 )
						{
							dwTimeOut -= 50;
							Sleep( 50 );
						}
						else
						{
							return false;
						}
					}
				}
			}
			break;

		case LIST_WRITE:
			for ( ;; )
			{
				EnterCriticalSection( &m_crit );
				if ( (GetCurrentThreadId() != m_dwThreadID) && (m_lCount > 0) )
				{	
					LeaveCriticalSection( &m_crit );
					WaitForSingleObject( m_hEvent, INFINITE );
				}
				else
				{
					m_dwThreadID = GetCurrentThreadId();
					m_lCount++;
					break;
				}
			};
			break;
	}

	// Success!
	return true;
}

void CAtomicList::Unlock( short nType )
{
	EnterCriticalSection( &m_crit );
	_ASSERT( m_lCount > 0 );
	m_lCount--;
	if ( nType == LIST_WRITE )
	{
		if ( !m_lCount ) m_dwThreadID = 0;
		LeaveCriticalSection( &m_crit );
	}
	LeaveCriticalSection( &m_crit );

	PulseEvent( m_hEvent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\transbmp\transbmp.cpp ===
#include <windows.h>
#include <assert.h>
#include "transbmp.h"

void GetMetrics( HBITMAP hBmp, int &nWidth, int &nHeight )
{
	// Get width & height
	BITMAP bm;
	if ( GetObject(hBmp, sizeof(bm), &bm) > 0)
	{
		nWidth = bm.bmWidth;
		nHeight = bm.bmHeight;
	}
	assert( nWidth && nHeight );
}

void CreateMask( HDC hDC, HBITMAP hBmp, HBITMAP& hBmpMask, int nWidth, int nHeight )
{
    //
    // We have to verify if hDC is a valid handler
    //
    
    hBmpMask = NULL;
    if( (NULL == hDC) || (NULL == hBmp) )
    {
        hBmpMask = NULL;
        return;
    }

	// Create memory DCs to work with
	HDC hdcMask = CreateCompatibleDC( hDC );

    //
    // We have to verify if hdcMask is a valid handler
    //
    
    if( NULL == hdcMask )
    {
        return;
    }

	HDC hdcImage = CreateCompatibleDC( hDC );

    //
    // We have to verify if hdcMask is a valid handler
    //

    if( NULL == hdcImage )
    {
        DeleteDC( hdcMask );
        return;
    }

	// Create a monochrome bitmap for the mask
	hBmpMask = CreateBitmap( nWidth, nHeight, 1, 1, NULL );

    //
    // We have to verify if hdcMask is a valid handler
    //

    if( NULL == hBmpMask )
    {
        DeleteDC( hdcImage );
        DeleteDC( hdcMask );
        return;
    }

	// Select the mono bitmap into its DC
	HBITMAP hbmOldMask = (HBITMAP) SelectObject( hdcMask, hBmpMask );

    //
    // We have to verify if hdcMask is a valid handler
    //

    if( NULL == hbmOldMask )
    {
        DeleteObject( hBmpMask );
        hBmpMask = NULL;

        DeleteDC( hdcImage );
        DeleteDC( hdcMask );
        return;
    }

	// Select the image bitmap into its DC
	HBITMAP hbmOldImage = (HBITMAP) SelectObject( hdcImage, hBmp );

    //
    // We have to verify if hdcMask is a valid handler
    //

    if( NULL == hbmOldImage )
    {
        SelectObject( hdcMask, hbmOldMask);

        DeleteObject( hBmpMask );
        hBmpMask = NULL;

        DeleteDC( hdcImage );
        DeleteDC( hdcMask );
        return;
    }

	// Set the transparency color to be the top-left pixel
	SetBkColor( hdcImage, GetPixel(hdcImage, 0, 0) );
	
	// Make the mask
	BitBlt( hdcMask, 0, 0, nWidth, nHeight, hdcImage, 0, 0, SRCCOPY );

	// Clean up
	SelectObject( hdcImage, hbmOldImage );
	SelectObject( hdcMask, hbmOldMask );

	DeleteDC( hdcMask );
	DeleteDC( hdcImage );
}

void Draw( HDC hDC, HBITMAP hBmp, int x, int y, int dx /*= -1*/, int dy /*= -1*/, bool bStretch /* = false*/ )
{
	assert( hDC && hBmp );
	int nWidth, nHeight;
	GetMetrics( hBmp, nWidth, nHeight );

	// Create a memory DC
	HDC hDCMem = CreateCompatibleDC( hDC );		  	

	if ( hDCMem )
	{
		// Make sure we have valid values for width & height
		if ( dx == -1 )	dx = nWidth;
		if ( dy == -1 )	dy = nHeight;

		if ( !bStretch )
		{
			dx = min( dx, nWidth );
			dy = min( dy, nHeight );
		}

		HBITMAP hbmOld = (HBITMAP) SelectObject( hDCMem, hBmp );

		// Blt the bits
		if ( !bStretch )
		{
			BitBlt( hDC, x, y, dx, dy, hDCMem, 0, 0, SRCCOPY );
		}
		else
		{
			SetStretchBltMode((HDC) hDC, COLORONCOLOR);
			StretchBlt( hDC, x, y, dx, dy,
						hDCMem, 0, 0, nWidth, nHeight, SRCCOPY );
		}
			
		SelectObject( hDCMem, hbmOld );
		DeleteDC( hDCMem );
	}
}


void DrawTrans( HDC hDC, HBITMAP hBmp, int x, int y, int dx /*= -1*/, int dy /*= -1*/ )
{
    //
    // We should initialize local variables
    //
    if( (NULL == hDC) || (NULL == hBmp))
    {
        return;
    }

	int nWidth = 0, nHeight = 0;
	GetMetrics( hBmp, nWidth, nHeight );

	// Create transparent bitmap mask
	HBITMAP hBmpMask = NULL;
	CreateMask( hDC, hBmp, hBmpMask, nWidth, nHeight );

    //
    //

    if( NULL == hBmpMask )
    {
        return;
    }

	// Make sure we have valid values for width & height
	if ( dx == -1 )	dx = nWidth;
	if ( dy == -1 )	dy = nHeight;
	dx = min( dx, nWidth );
	dy = min( dy, nHeight );


	// Create a memory DC in which to draw
	HDC hdcOffScr = CreateCompatibleDC( hDC );

    //
    // We have to verify hdcOffScr is valid
    //

    if( NULL == hdcOffScr )
    {
	    DeleteObject( hBmpMask );
        return;
    }
	
	// Create a bitmap for the off-screen DC that is really color-compatible with the
	// destination DC
	HBITMAP hbmOffScr = CreateBitmap( dx, dy, (BYTE) GetDeviceCaps(hDC, PLANES),
						  					  (BYTE) GetDeviceCaps(hDC, BITSPIXEL),
											  NULL );

    //
    //

    if( NULL == hbmOffScr )
    {
        DeleteDC( hdcOffScr );
	    DeleteObject( hBmpMask );
        return;
    }

	// Select the buffer bitmap into the off-screen DC
	HBITMAP hbmOldOffScr = (HBITMAP) SelectObject( hdcOffScr, hbmOffScr );

    //
    //

    if( NULL == hbmOldOffScr )
    {
        DeleteObject( hbmOffScr );
        DeleteDC( hdcOffScr );
	    DeleteObject( hBmpMask );
        return;
    }


	// Copy the image of the destination rectangle to the off-screen buffer DC so
	// we can manipulate it
	BitBlt( hdcOffScr, 0, 0, dx, dy, hDC, x, y, SRCCOPY);

	// Create a memory DC for the source image
	HDC hdcImage = CreateCompatibleDC( hDC );

    //
    // We have to verify the hdcImage
    //

    if( NULL == hdcImage )
    {
        // Restore
    	SelectObject( hdcOffScr, hbmOldOffScr );
        DeleteObject( hbmOffScr );
        DeleteDC( hdcOffScr );
	    DeleteObject( hBmpMask );

        return;
    }

	HBITMAP hbmOldImage = (HBITMAP) SelectObject( hdcImage, hBmp );

    //
    // We have to verify the hbmOldImage
    //

    if( NULL == hbmOldImage )
    {
        // Restore
        DeleteDC( hdcImage );
    	SelectObject( hdcOffScr, hbmOldOffScr );
        DeleteObject( hbmOffScr );
        DeleteDC( hdcOffScr );
	    DeleteObject( hBmpMask );

        return;
    }


	// Create a memory DC for the mask
	HDC hdcMask = CreateCompatibleDC( hDC );

    //
    //

    if( NULL == hdcMask )
    {
        // Restore
        SelectObject( hdcImage, hbmOldImage );
        DeleteDC( hdcImage );
    	SelectObject( hdcOffScr, hbmOldOffScr );
        DeleteObject( hbmOffScr );
        DeleteDC( hdcOffScr );
	    DeleteObject( hBmpMask );

        return;
    }

	HBITMAP hbmOldMask = (HBITMAP) SelectObject( hdcMask, hBmpMask );

    //
    // We have to verify the hbmOldMask
    //

    if( NULL == hbmOldMask )
    {
        // Restore
        DeleteDC( hdcMask );
        SelectObject( hdcImage, hbmOldImage );
        DeleteDC( hdcImage );
    	SelectObject( hdcOffScr, hbmOldOffScr );
        DeleteObject( hbmOffScr );
        DeleteDC( hdcOffScr );
	    DeleteObject( hBmpMask );

        return;
    }


	// XOR the image with the destination
	SetBkColor( hdcOffScr, RGB(255, 255, 255) );
	BitBlt( hdcOffScr, 0, 0, dx, dy, hdcImage, 0, 0, SRCINVERT );
	// AND the destination with the mask
	BitBlt( hdcOffScr, 0, 0, dx, dy, hdcMask, 0, 0, SRCAND );
	// XOR the destination with the image again
	BitBlt( hdcOffScr, 0, 0, dx, dy, hdcImage, 0, 0, SRCINVERT);

	// Copy the resultant image back to the screen DC
	BitBlt( hDC, x, y, dx, dy, hdcOffScr, 0, 0, SRCCOPY );

	// Clean up
    //
    // We have to clean up corectly
    //
    SelectObject( hdcMask, hbmOldMask);
    DeleteDC( hdcMask );
    SelectObject( hdcImage, hbmOldImage );
    DeleteDC( hdcImage );
    SelectObject( hdcOffScr, hbmOldOffScr );
    DeleteObject( hbmOffScr );
    DeleteDC( hdcOffScr );
	DeleteObject( hBmpMask );
}

void Draw3dBox(HDC hDC, RECT& rect, bool bUp)
{
	assert ( hDC );

	HBRUSH hbrOld = (HBRUSH) SelectObject( hDC, GetSysColorBrush((bUp) ? COLOR_BTNHIGHLIGHT : COLOR_BTNSHADOW) );

	// Draw left and top sides of indent.		
	PatBlt( hDC, rect.left, rect.top, (rect.right - rect.left), 1, PATCOPY );
	PatBlt( hDC, rect.left, rect.top, 1, (rect.bottom - rect.top), PATCOPY );
    
	// Draw bottom and right sides of indent.
	SelectObject( hDC, GetSysColorBrush((!bUp) ? COLOR_BTNHIGHLIGHT : COLOR_BTNSHADOW) );
	PatBlt( hDC, rect.right - 1, rect.top, 1, (rect.bottom - rect.top), PATCOPY );
	PatBlt( hDC, rect.left, rect.bottom - 1, (rect.right - rect.left), 1, PATCOPY );

	if ( hbrOld )
		SelectObject( hDC, hbrOld );
}

void Erase3dBox(HDC hDC, RECT& rect, HBRUSH hbr )
{
	assert ( hDC );

	HBRUSH hbrOld = (HBRUSH) SelectObject( hDC, (hbr) ? hbr : GetSysColorBrush(GetBkColor(hDC)) );

	// Draw left and top sides of indent.		
	PatBlt( hDC, rect.left, rect.top, (rect.right - rect.left), 1, PATCOPY );
	PatBlt( hDC, rect.left, rect.top, 1, (rect.bottom - rect.top), PATCOPY );
    
	// Draw bottom and right sides of indent.
	PatBlt( hDC, rect.right - 1, rect.top, 1, (rect.bottom - rect.top), PATCOPY );
	PatBlt( hDC, rect.left, rect.bottom - 1, (rect.right - rect.left), 1, PATCOPY );

	if ( hbrOld )
		SelectObject( hDC, hbrOld );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\adds.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddListen
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddListen( long lMediaType )
{
    WCHAR                   szName[256];
    TV_INSERTSTRUCT         tvi;

    //
    // map the mediatype bstr to
    // a string name (like "audio in")
    //
    GetMediaTypeName(
                     lMediaType,
                     szName
                    );

    //
    // insert that string into the
    // listen window
    //
    tvi.hParent = ghListenRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) lMediaType;
    
    TreeView_InsertItem(
                        ghListenWnd,
                        &tvi
                       );


    //
    // select the first item
    //
    SelectFirstItem(
                    ghListenWnd,
                    ghListenRoot
                   );
}
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddAddressToTree
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddAddressToTree( ITAddress * pAddress )
{
    BSTR                bstrName;
    TV_INSERTSTRUCT     tvi;

    //
    // get the name of the address
    //
    pAddress->get_AddressName( &bstrName );


    //
    // set up struct
    //
    tvi.hParent = ghAddressesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = bstrName;
    tvi.item.lParam = (LPARAM) pAddress;


    //
    // addref
    //
    pAddress->AddRef();

    
    //
    // insert it
    //
    TreeView_InsertItem(
                        ghAddressesWnd,
                        &tvi
                       );

    //
    // free name
    //
    SysFreeString( bstrName );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddMediaType
//
// Add a mediatype to the mediatype tree
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddMediaType( long lMediaType )
{
    WCHAR szString[256];
    TV_INSERTSTRUCT tvi;

    //
    // get the displayable name
    //
    GetMediaTypeName(
                     lMediaType,
                     szString
                    );

    //
    // set up struct
    //
    tvi.hParent = ghMediaTypesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szString;
    tvi.item.lParam = (LPARAM) lMediaType;

    //
    // add the item
    //
    TreeView_InsertItem(
                        ghMediaTypesWnd,
                        &tvi
                       );

    //
    // select the first item
    //
    SelectFirstItem(
                    ghMediaTypesWnd,
                    ghMediaTypesRoot
                   );
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddCall
//
// Add a call to the call tree
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddCall( ITCallInfo * pCall )
{
    TV_INSERTSTRUCT             tvi;
    HTREEITEM                   hItem;
    CALL_PRIVILEGE              cp;
    CALL_STATE                  cs;
    WCHAR                       pszName[16];

    //
    // for the name of the call, use
    // the pointer!
    //
    wsprintf(
             pszName,
             L"0x%lx",
             pCall
            );


    //
    // set up struct
    //
    tvi.hParent = ghCallsRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = pszName;
    tvi.item.lParam = (LPARAM) pCall;

    //
    // save a reference
    //
    pCall->AddRef();

    
    //
    // insert the item
    //
    hItem = TreeView_InsertItem(
                                ghCallsWnd,
                                &tvi
                               );

    if (NULL != hItem)
    {
        //
        // select the item
        //
        TreeView_SelectItem(
                            ghCallsWnd,
                            hItem
                           );
    }

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddTerminal( ITTerminal * pTerminal )
{
    BSTR                    bstrName;
    BSTR                    bstrClass;
    TV_INSERTSTRUCT         tvi;
    TERMINAL_DIRECTION      td;
    WCHAR                   szName[256];

    //
    // get the name of the terminal
    //
    pTerminal->get_Name( &bstrName );

    pTerminal->get_Direction( &td );

    if (td == TD_RENDER)
    {
        wsprintfW(szName, L"%s [Playback]", bstrName);
    }
    else if (td == TD_CAPTURE)
    {
        wsprintfW(szName, L"%s [Record]", bstrName);
    }
    else //if (TD == TD_BOTH)
    {
        lstrcpyW(szName, bstrName);
    }
    
    //
    // set up the structure
    //
    tvi.hParent = ghTerminalsRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) pTerminal;


    //
    // keep a refence to the terminal
    //
    pTerminal->AddRef();

    //
    // add it
    //
    TreeView_InsertItem(
                        ghTerminalsWnd,
                        &tvi
                       );

    //
    // free the name
    //
    SysFreeString( bstrName );


    //
    // select
    //
    SelectFirstItem(
                    ghTerminalsWnd,
                    ghTerminalsRoot
                   );
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddTerminalClass
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddTerminalClass( GUID * pguid )
{
    TV_INSERTSTRUCT tvi;
    
    //
    // get the name
    //
    tvi.item.pszText = GetTerminalClassName( pguid );

    //
    // set up the struct
    //
    tvi.hParent = ghClassesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.lParam = (LPARAM) pguid;

    //
    // insert the item
    //
    TreeView_InsertItem(
                        ghClassesWnd,
                        &tvi
                       );

    SysFreeString( tvi.item.pszText );

    //
    // select item
    //
    SelectFirstItem(
                    ghClassesWnd,
                    ghClassesRoot
                   );

}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddCreatedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddCreatedTerminal( ITTerminal * pTerminal )
{
    BSTR                    bstrName;
    TV_INSERTSTRUCT         tvi;


    //
    // get the name
    //
    pTerminal->get_Name( &bstrName );

    //
    // set up the structure
    //
    tvi.hParent = ghCreatedRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;

    if ( ( NULL == bstrName ) || (NULL == bstrName[0] ))
    {
        tvi.item.pszText = L"<No Name Given>";
    }
    else
    {
        tvi.item.pszText = bstrName;
    }

    tvi.item.lParam = (LPARAM) pTerminal;


    //
    // keep reference
    //
    pTerminal->AddRef();

    //
    // insert
    //
    TreeView_InsertItem(
                        ghCreatedWnd,
                        &tvi
                       );

    SysFreeString( bstrName );

    //
    // select
    //
    SelectFirstItem(
                    ghCreatedWnd,
                    ghCreatedRoot
                   );
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddSelectedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddSelectedTerminal(
                                     ITTerminal * pTerminal
                                    )
{
    BSTR bstrName;
    BSTR pMediaType;
    TV_INSERTSTRUCT tvi;
    TERMINAL_DIRECTION td;
    WCHAR szName[256];
    

    //
    // get the name
    //
    pTerminal->get_Name( &bstrName );

    pTerminal->get_Direction( &td );

    if (td == TD_RENDER)
    {
        wsprintfW(szName, L"%s [Playback]", bstrName);
    }
    else if (td == TD_CAPTURE)
    {
        wsprintfW(szName, L"%s [Record]", bstrName);
    }
    else //if (TD == TD_BOTH)
    {
        lstrcpyW(szName, bstrName);
    }
    

    //
    // set up the struct
    //
    tvi.hParent = ghSelectedRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) pTerminal;

    //
    // keep reference
    //
    pTerminal->AddRef();

    //
    // insert item
    //
    TreeView_InsertItem(
                        ghSelectedWnd,
                        &tvi
                       );

    //
    // free name
    //
    SysFreeString( bstrName );


    //
    // select
    //
    SelectFirstItem(
                    ghSelectedWnd,
                    ghSelectedRoot
                   );
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\autoans.cpp ===
// autoans.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "t3testd.h"
#include "autoans.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
extern DataPtrList       gDataPtrList;
/////////////////////////////////////////////////////////////////////////////
// autoans dialog


autoans::autoans(CWnd* pParent /*=NULL*/)
	: CDialog(autoans::IDD, pParent)
{
        CT3testDlg::GetAddress( &m_pAddress );

}


void autoans::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(autoans)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BOOL autoans::OnInitDialog()
{
    CDialog::OnInitDialog();
    PopulateListBox();

    return TRUE;
}


BEGIN_MESSAGE_MAP(autoans, CDialog)
	//{{AFX_MSG_MAP(autoans)
	ON_BN_CLICKED(IDC_TERMINALADD, OnTerminalAdd)
	ON_BN_CLICKED(IDC_TERMINALREMOVE, OnTerminalRemove)
    ON_WM_CLOSE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// autoans message handlers

void autoans::OnTerminalAdd() 
{
    LONG            i;
    ITTerminal *    pTerminal;
    
    i = SendDlgItemMessage(
                           IDC_NOTSELECTED,
                           LB_GETCURSEL,
                           0,
                           0
                          );

    if ( i == LB_ERR )
    {
        return;
    }
    
    pTerminal = (ITTerminal *) SendDlgItemMessage(
        IDC_NOTSELECTED,
        LB_GETITEMDATA,
        i,
        0
        );

    if ( NULL != pTerminal )
    {
        SendDlgItemMessage(
                           IDC_NOTSELECTED,
                           LB_DELETESTRING,
                           i,
                           0
                          );

        AddTerminalToListBox( pTerminal, TRUE );
    }
    else
    {
        AddDynamicTerminalToListBox( TRUE );
    }

	
}

void autoans::OnTerminalRemove() 
{
    LONG        i;
    ITTerminal * pTerminal;
    
    i = SendDlgItemMessage(
                           IDC_SELECTED,
                           LB_GETCURSEL,
                           0,
                           0
                          );

    if ( i == LB_ERR )
    {
        return;
    }
    
    pTerminal = (ITTerminal *) SendDlgItemMessage(
        IDC_SELECTED,
        LB_GETITEMDATA,
        i,
        0
        );

    SendDlgItemMessage(
                       IDC_SELECTED,
                       LB_DELETESTRING,
                       i,
                       0
                      );
    
    if ( NULL != pTerminal )
    {
        AddTerminalToListBox( pTerminal, FALSE );
    }
	
}

void autoans::OnOK() 
{
    LONG        i, count;

    
    i = 0;

    count = SendDlgItemMessage(
                               IDC_SELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );


    for( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        
        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_SELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        AddTerminalToAAList( pTerminal );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }

    count = SendDlgItemMessage(
                               IDC_NOTSELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    for ( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_NOTSELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }
    

	CDialog::OnOK();
}
void autoans::OnCancel()
{
    LONG        i, count;

    
    i = 0;

    count = SendDlgItemMessage(
                               IDC_SELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );


    for( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        
        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_SELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }


    count = SendDlgItemMessage(
                               IDC_NOTSELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    for ( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_NOTSELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }
    
    CDialog::OnCancel();
}

void autoans::PopulateListBox()
{
    ITTerminalSupport * pTerminalSupport;
    IEnumTerminal *     pEnumTerminal;
    IEnumTerminalClass * pEnumClasses;
    HRESULT             hr;
    
    if ( NULL == m_pAddress )
    {
        return;
    }

    m_pAddress->QueryInterface(
                               IID_ITTerminalSupport,
                               (void **) &pTerminalSupport
                              );

    pTerminalSupport->EnumerateStaticTerminals( &pEnumTerminal );

    while (TRUE)
    {
        ITTerminal * pTerminal;
        
        hr = pEnumTerminal->Next(
                                 1,
                                 &pTerminal,
                                 NULL
                                );

        if ( S_OK != hr )
        {
            break;
        }

        AddTerminalToListBox( pTerminal, FALSE );

//        pTerminal->Release();
    }

    pEnumTerminal->Release();

    pTerminalSupport->EnumerateDynamicTerminalClasses( &pEnumClasses );

    while (TRUE)
    {
        GUID        guid;
        
        hr = pEnumClasses->Next(
                                1,
                                &guid,
                                NULL
                               );

        if ( S_OK != hr )
        {
            break;
        }

        if ( guid == CLSID_VideoWindowTerm )
        {
            AddDynamicTerminalToListBox( FALSE );
        }

    }

    pEnumClasses->Release();
    
    pTerminalSupport->Release();
}

void
autoans::AddTerminalToListBox( ITTerminal * pTerminal, BOOL bSelected )
{
    HRESULT         hr;
    LONG            i;
    DWORD           dwLB;
    BSTR            bstrName;
    WCHAR		szBuffer[256];
	TERMINAL_DIRECTION td;

    dwLB = (bSelected ? IDC_SELECTED : IDC_NOTSELECTED);

    hr = pTerminal->get_Name( &bstrName );
    pTerminal->get_Direction( &td );

	if ( td == TD_RENDER )
	{
		wsprintfW(szBuffer, L"%s [Playback]", bstrName);
	}
	else
	{
		wsprintfW(szBuffer, L"%s [Record]", bstrName);	
	}

    i = SendDlgItemMessage(
                           dwLB,
                           LB_ADDSTRING,
                           0,
                           (LPARAM)szBuffer
                          );

    SysFreeString( bstrName );

    SendDlgItemMessage(
                       dwLB,
                       LB_SETITEMDATA,
                       (WPARAM) i,
                       (LPARAM) pTerminal
                      );

}

void
autoans::AddDynamicTerminalToListBox( BOOL bSelected )
{
    LONG            i;
    DWORD           dwLB;

    dwLB = (bSelected ? IDC_SELECTED : IDC_NOTSELECTED);


    i = SendDlgItemMessage(
                           dwLB,
                           LB_ADDSTRING,
                           0,
                           (LPARAM)L"Video Window"
                          );

    SendDlgItemMessage(
                       dwLB,
                       LB_SETITEMDATA,
                       (WPARAM) i,
                       (LPARAM) 0
                      );


    return;
}

void autoans::AddTerminalToAAList( ITTerminal * pTerminal )
{
    if ( NULL != pTerminal )
    {
        pTerminal->AddRef();
    }
    
    m_TerminalPtrList.push_back( pTerminal );
}


void autoans::OnClose()
{
    LONG        i, count;

    
    i = 0;

    count = SendDlgItemMessage(
                               IDC_SELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );


    for( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        
        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_SELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }


    count = SendDlgItemMessage(
                               IDC_NOTSELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    for ( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_NOTSELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }
    
	CDialog::OnClose();
    
}

void
CT3testDlg::DoAutoAnswer(
                         ITCallInfo * pCall
                        )
{
    ITAddress * pAddress;
    ITBasicCallControl * pBCC;
    HRESULT     hr;
    DataPtrList::iterator iter,end;
    TerminalPtrList::iterator terminaliter, terminalend;
    DWORD       dwSize;
    ITTerminalSupport * pTerminalSupport;
    BSTR        bstrTerminalClass;
    PWSTR       pwstr;
    

    StringFromIID(CLSID_VideoWindowTerm,&pwstr);
    bstrTerminalClass = SysAllocString( pwstr );
    CoTaskMemFree( pwstr );

    hr = pCall->get_Address( &pAddress );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    hr = pAddress->QueryInterface(
                                  IID_ITTerminalSupport,
                                  (void **) &pTerminalSupport
                                 );

    if ( !SUCCEEDED(hr) )
    {
        pAddress->Release();
        return;
    }
    
    hr = pCall->QueryInterface(
                               IID_ITBasicCallControl,
                               (void **)&pBCC
                              );

    if ( !SUCCEEDED(hr) )
    {
        pTerminalSupport->Release();
        pAddress->Release();
        return;
    }

    iter = gDataPtrList.begin();
    end  = gDataPtrList.end();

    for ( ; iter != end ; iter++ )
    {
        if ( (*iter)->pAddress == pAddress )
        {
            break;
        }
    }

    pAddress->Release();

    if ( iter == end )
    {
        pBCC->Release();
        pTerminalSupport->Release();
        return;
    }

    dwSize = (*iter)->pTerminalPtrList->size();
    
    if ( 0 == dwSize )
    {
        pTerminalSupport->Release();
        pBCC->Release();
        return ;
    }

    terminaliter = (*iter)->pTerminalPtrList->begin();
    terminalend  = (*iter)->pTerminalPtrList->end();

    for( ; terminaliter != terminalend ; terminaliter++ )
    {
        ITTerminal * pTerminal;
        
        if ( NULL == (*terminaliter) )
        {
            hr = pTerminalSupport->CreateTerminal(
                bstrTerminalClass,
                (long)LINEMEDIAMODE_VIDEO,
                TD_RENDER,
                &pTerminal
                );
        }
        else
        {
            pTerminal = *terminaliter;
        }

//        hr = pBCC->SelectTerminal( pTerminal );

//        if ( !SUCCEEDED(hr) )
//        {
//        }

    }
    
    hr = pBCC->Answer();

    if ( !SUCCEEDED(hr) )
    {
    }
    
    pBCC->Release();
    pTerminalSupport->Release();
    SysFreeString( bstrTerminalClass );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\calldlg.cpp ===
// CreateCallDlg.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "CallDlg.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateCallDlg dialog


CCreateCallDlg::CCreateCallDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCreateCallDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCreateCallDlg)
	m_pszDestAddress = _T("");
	//}}AFX_DATA_INIT
}


void CCreateCallDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCreateCallDlg)
	DDX_Text(pDX, IDC_DESTADDRESS, m_pszDestAddress);
	DDV_MaxChars(pDX, m_pszDestAddress, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCreateCallDlg, CDialog)
	//{{AFX_MSG_MAP(CCreateCallDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCreateCallDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\autoans.h ===
#if !defined(AFX_AUTOANS_H__2BFE6626_7758_11D1_8F5C_00C04FB6809F__INCLUDED_)
#define AFX_AUTOANS_H__2BFE6626_7758_11D1_8F5C_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// autoans.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// autoans dialog

class autoans : public CDialog
{
// Construction
public:
	autoans(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(autoans)
	enum { IDD = IDD_AUTOANSWER };
    TerminalPtrList m_TerminalPtrList;
    ITAddress * m_pAddress;
    
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(autoans)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(autoans)
	virtual BOOL OnInitDialog();
	afx_msg void OnTerminalAdd();
	afx_msg void OnTerminalRemove();
	virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnClose() ;
    void PopulateListBox();
    void AddTerminalToListBox( ITTerminal * pTerminal, BOOL bSelected );
    void AddDynamicTerminalToListBox( BOOL bSelected );
    void AddTerminalToAAList( ITTerminal * pTerminal );
//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUTOANS_H__2BFE6626_7758_11D1_8F5C_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\confdlg.cpp ===
// autoans.cpp : implementation file
//
#include "stdafx.h"

#include "t3test.h"
#include "t3testd.h"
#include "confdlg.h"
#include "strings.h"
#include "resource.h"


#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CConfDlg::CConfDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConfDlg::IDD, pParent)
{
        m_bstrDestAddress = NULL;
}


void CConfDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}

BOOL CConfDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    PopulateConferences();
    return TRUE;
}

void CConfDlg::PopulateConferences()
{
    ITRendezvous *      pRend;
    IEnumDirectory *    pEnumDirectory;
    HRESULT             hr;
    ITDirectory *       pDirectory;
    LPWSTR *            ppServers;
    DWORD               dw;
    
    //
    // create the rendezvous control.
    //
    hr = ::CoCreateInstance(
                            CLSID_Rendezvous,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_ITRendezvous,
                            (void **)&pRend
                           );
    
    if (FAILED(hr))
    {
        return;
    }


    hr = pRend->EnumerateDefaultDirectories(
        &pEnumDirectory
        );

    if (FAILED(hr))
    {
        pRend->Release();
    
        return;
    }

    while (TRUE)
    {

        DWORD dwFetched = 0;

        hr = pEnumDirectory->Next(
                                  1,
                                  &pDirectory,
                                  &dwFetched
                                 );

        if ( S_OK != hr )
        {
            break;
        }

        DIRECTORY_TYPE type;
        // print out the names of the conference found.
        hr = pDirectory->get_DirectoryType(&type);
        if ( FAILED(hr) )
        {
            pDirectory->Release();
            continue;
        }

        if (type == DT_ILS)
        {
            break;
        }

        pDirectory->Release();

    }

    pEnumDirectory->Release();

    //
    // if hr is s_false, we went through the enumerate
    // without finding an ils server
    //
    if ( S_OK == hr )
    {
        hr = pDirectory->Connect(FALSE);

        if ( SUCCEEDED(hr))
        {
            ListObjects( pDirectory );
        }

        pDirectory->Release();
    }

    hr = ListILSServers(
                        &ppServers,
                        &dw
                       );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }
    
    while ( dw )
    {
        dw--;

        hr = pRend->CreateDirectory(
                                    DT_ILS,
                                    ppServers[dw],
                                    &pDirectory
                                   );

        if ( SUCCEEDED(hr) )
        {
            hr = pDirectory->Connect(FALSE);

            if ( SUCCEEDED(hr) )
            {
                ListObjects( pDirectory );
            }

            pDirectory->Release();
        }

        CoTaskMemFree( ppServers[dw] );
    }

    CoTaskMemFree( ppServers );

}

void
CConfDlg::ListObjects( ITDirectory * pDirectory )
{
    BSTR            bstrNameToSearch;
    BSTR            bstrDirName;
    HRESULT         hr;
    int             i;
    
    
    bstrNameToSearch = SysAllocString(L"*");

    if (bstrNameToSearch == NULL)
    {
        return;
    }

    IEnumDirectoryObject * pEnum;
    
    hr = pDirectory->EnumerateDirectoryObjects(
        OT_CONFERENCE,
        bstrNameToSearch,
        &pEnum
        );

    SysFreeString( bstrNameToSearch );

    if (FAILED(hr))
    {
        return;
    }

    pDirectory->get_DisplayName( &bstrDirName );

    // print out the names of all the users found.
    while (TRUE)
    {
        ITDirectoryObject *     pObject;
        BSTR                    bstrObjectName;
        WCHAR                   szBuffer[256];

        hr = pEnum->Next(
                         1,
                         &pObject,
                         NULL
                        );
        
        if ( S_OK != hr )
        {
            break;
        }

        hr = pObject->get_Name(&bstrObjectName);
        
        if (FAILED(hr))
        {
            continue;
        }

        wsprintf(szBuffer, L"%s: %s", bstrDirName, bstrObjectName );
        
        i = SendDlgItemMessage(
                               IDC_CONFLIST,
                               LB_ADDSTRING,
                               0,
                               (LPARAM)szBuffer
                              );

        SysFreeString(bstrObjectName);

        SendDlgItemMessage(
                           IDC_CONFLIST,
                           LB_SETITEMDATA,
                           i,
                           (LPARAM) pObject
                          );
    }

    SysFreeString( bstrDirName );
    
    pEnum->Release();
}

void CConfDlg::OnOK()
{
    DWORD       i;
    HRESULT     hr;
    
    i = SendDlgItemMessage(
                           IDC_CONFLIST,
                           LB_GETCURSEL,
                           0,
                           0
                          );

    if (LB_ERR != i)
    {
        ITDirectoryObject *     pObject;
        IEnumDialableAddrs *    pEnumAddress;

        
        pObject = (ITDirectoryObject *)SendDlgItemMessage(
            IDC_CONFLIST,
            LB_GETITEMDATA,
            i,
            0
            );

        hr = pObject->EnumerateDialableAddrs(
                                             LINEADDRESSTYPE_SDP,
                                             &pEnumAddress
                                            );

        if ( !SUCCEEDED(hr) )
        {
        }

        hr = pEnumAddress->Next(
                                1,
                                &m_bstrDestAddress,
                                NULL
                               );

        if ( S_OK != hr )
        {
        }

        pEnumAddress->Release();
    }

    
	CDialog::OnOK();
}


void CConfDlg::OnDestroy() 
{
    DWORD       count;

    CDialog::OnDestroy();

    count = SendDlgItemMessage(
                               IDC_CONFLIST,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    while ( 0 != count )
    {
        ITDirectoryObject * pObject;

        count--;
        
        pObject = (ITDirectoryObject *)SendDlgItemMessage(
            IDC_CONFLIST,
            LB_GETITEMDATA,
            count,
            0
            );

        pObject->Release();
    }
}


BEGIN_MESSAGE_MAP(CConfDlg, CDialog)
	ON_WM_DESTROY()
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\callnot.h ===
// CallNotification.h : Declaration of the CCallNotification

#ifndef __CALLNOTIFICATION_H_
#define __CALLNOTIFICATION_H_

/////////////////////////////////////////////////////////////////////////////
//
// CTAPIEventNotification
//
/////////////////////////////////////////////////////////////////////////////
class CTAPIEventNotification :
	public ITTAPIEventNotification
{

private:

    LONG m_lRefCount;


public:

    CTAPIEventNotification()
    { 
        m_lRefCount = 0;
    }

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_ITTAPIEventNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }
	ULONG STDMETHODCALLTYPE AddRef()
    {
        ULONG l = InterlockedIncrement(&m_lRefCount);
        return l;
    }
    
	ULONG STDMETHODCALLTYPE Release()
    {
        ULONG l = InterlockedDecrement(&m_lRefCount);

        if ( 0 == l)
        {
            delete this;
        }

        return l;
    }


// ICallNotification
public:

	    HRESULT STDMETHODCALLTYPE Event(
            TAPI_EVENT TapiEvent,
            IDispatch * pEvent
            );

};


#ifdef ENABLE_DIGIT_DETECTION_STUFF

/////////////////////////////////////////////////////////////////////////////
//
// CDigitDetectionNotification
//
/////////////////////////////////////////////////////////////////////////////
class CDigitDetectionNotification :
	public ITDigitDetectionNotification
{

private:

    LONG m_lRefCount;


public:
    
    CDigitDetectionNotification()
    { 
        m_lRefCount = 0;
    }

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_ITDigitDetectionNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IDispatch)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }

	ULONG STDMETHODCALLTYPE AddRef()
    {
        ULONG l = InterlockedIncrement(&m_lRefCount);

        return l;
    }
    
	ULONG STDMETHODCALLTYPE Release()
    {
        ULONG l = InterlockedDecrement(&m_lRefCount);

        if ( 0 == l)
        {
            delete this;
        }

        return l;
    }


// ICallNotification
public:

    HRESULT STDMETHODCALLTYPE DigitDetected(
            unsigned char ucDigit,
            TAPI_DIGITMODE DigitMode,
            long ulTickCount
            );
    
};

#endif // ENABLE_DIGIT_DETECTION_STUFF

#endif //__CALLNOTIFICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\callnot.cpp ===
//

#include "stdafx.h"
#include "t3test.h"
#include "t3testd.h"
#include "callnot.h"
#include "control.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


extern CWnd * gpmainwnd;

HandleVideoWindowCrap(
                      ITCallInfo * pCallInfo
                     );

HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::Event(
                              TAPI_EVENT TapiEvent,
                              IDispatch * pEvent
                             )
{
    HRESULT hr;


    pEvent->AddRef();
    
    hr = PostMessage( gpmainwnd->m_hWnd, WM_USER+101, (WPARAM)TapiEvent, (LPARAM)pEvent );

    return hr;
    
}

afx_msg LONG CT3testDlg::OnTapiEvent(UINT u, LONG_PTR l)
{
    HRESULT         hr;
    TAPI_EVENT      TapiEvent;
    IDispatch *     pEvent;

    TapiEvent = (TAPI_EVENT)u;
    pEvent = (IDispatch *)l;
    
    switch (TapiEvent)
    {
        case TE_CALLNOTIFICATION:
        {
            ITAddress *                 pAddress;
            ITAddress *                 pCallAddress;
            ITCallInfo *                pCallInfo;
            ITCallNotificationEvent *   pCallNotify;


            //
            // get the currently selected address
            //
            if (CT3testDlg::GetAddress( &pAddress ))
            {
                //
                // get the event
                //
                pEvent->QueryInterface(IID_ITCallNotificationEvent, (void **)&pCallNotify );
                //
                // get the call
                //
                pCallNotify->get_Call( &pCallInfo );
                //
                // get the call's event
                //
                pCallInfo->get_Address( &pCallAddress );

                //
                // if this call is supposed to be on this
                // address, add it to the UI
                //
                if (pAddress == pCallAddress)
                {
                    // need to add a second reference for
                    // the tree view
                    CT3testDlg::AddCall( pCallInfo );
                }

                CALL_PRIVILEGE      cp;
                CALL_STATE          cs;
                
                pCallInfo->get_Privilege( &cp );

                if ( CP_OWNER == cp )
                {
                    DoAutoAnswer( pCallInfo );
                }

                pCallInfo->get_CallState(&cs);
                
                //
                // release our references
                // keep refernce to the call or it will
                // be destroyed
                //
                pCallAddress->Release();
                pCallNotify->Release();
            }
        }
        
        break;
        
        case TE_CALLSTATE:
        {
            ITCallStateEvent        * pCallStateEvent;
            ITCallInfo              * pCallInfo;
            CALL_STATE                cs;


            hr = pEvent->QueryInterface(IID_ITCallStateEvent, (void **)&pCallStateEvent);

            pCallStateEvent->get_Call( &pCallInfo );

            CT3testDlg::UpdateCall( pCallInfo );

            pCallStateEvent->get_State(
                                       &cs
                                      );

            if (CS_CONNECTED == cs)
            {
//                HandleVideoWindowCrap( pCallInfo );
            }

            pCallInfo->Release();
            pCallStateEvent->Release();

            break;
        }

        case TE_CALLHUB:
        {
            CT3testDlg::HandleCallHubEvent( pEvent );

            break;
        }

        case TE_TAPIOBJECT:
        {
            CT3testDlg::HandleTapiObjectMessage( pEvent );
            break;
        }
        
        break;

        case TE_CALLMEDIA:
        {
            WCHAR * pwstrEvent;
            WCHAR * pwstrCause;

            ITCallMediaEvent  * pCallMediaEvent;
            hr = pEvent->QueryInterface( IID_ITCallMediaEvent,
                                         (void **)&pCallMediaEvent );

            if (FAILED(hr))
            {
                pwstrEvent = pwstrCause = L"can't get event interface";
            }
            else
            {
                CALL_MEDIA_EVENT    cme;
                hr = pCallMediaEvent->get_Event( &cme );

                if (FAILED(hr))
                {
                    pwstrEvent = L"can't get event type";
                }
                else
                {
                    switch ( cme )
                    {
                    case CME_NEW_STREAM:
                        pwstrEvent = L"CME_NEW_STREAM";
                        break;

                    case CME_STREAM_FAIL:
                        pwstrEvent = L"CME_STREAM_FAIL";
                        break;
            
                    case CME_TERMINAL_FAIL:
                        pwstrEvent = L"CME_TERMINAL_FAIL";
                        break;

                    case CME_STREAM_NOT_USED:
                        pwstrEvent = L"CME_STREAM_NOT_USED";
                        break;

                    case CME_STREAM_ACTIVE:
                        pwstrEvent = L"CME_STREAM_ACTIVE";
                        break;

                    case CME_STREAM_INACTIVE:
                        pwstrEvent = L"CME_STREAM_INACTIVE";
                        break;

                    default:
                        pwstrEvent = L"type undefined";
                        break;
                    }
                }
            }

            CALL_MEDIA_EVENT_CAUSE    cmec;

            hr = pCallMediaEvent->get_Cause( &cmec );

            pCallMediaEvent->Release();

            if (FAILED(hr))
            {
                pwstrCause = L"can't get event cause";
            }
            else
            {
                switch ( cmec )
                {
                case CMC_UNKNOWN:
                    pwstrCause = L"CMC_UNKNOWN";
                    break;

                case CMC_BAD_DEVICE:
                    pwstrCause = L"CMC_BAD_DEVICE";
                    break;
            
                case CMC_CONNECT_FAIL:
                    pwstrCause = L"CMC_CONNECT_FAIL";
                    break;
            
                case CMC_LOCAL_REQUEST:
                    pwstrCause = L"CMC_LOCAL_REQUEST";
                    break;

                case CMC_REMOTE_REQUEST:
                    pwstrCause = L"CMC_REMOTE_REQUEST";
                    break;

                case CMC_MEDIA_TIMEOUT:
                    pwstrCause = L"CMC_MEDIA_TIMEOUT";
                    break;

                case CMC_MEDIA_RECOVERED:
                    pwstrCause = L"CMC_MEDIA_RECOVERED";
                    break;

                default:
                    pwstrCause = L"cause undefined";
                    break;
                }
            }

            ::MessageBox(NULL, pwstrEvent, pwstrCause, MB_OK);

            break;
        }
       
        case TE_ADDRESS:
        {
            ITAddressEvent      * pAddressEvent;
            ITTerminal          * pTerminal;
            ITAddress           * pAddress;
            LONG                lMediaType;
            LONG                lSelectedMediaType;
            BSTR                bstrName = NULL;
            ADDRESS_EVENT       ae;

            hr = pEvent->QueryInterface(IID_ITAddressEvent, (void **)&pAddressEvent);

            if (SUCCEEDED(hr))
            {
                hr = pAddressEvent->get_Event( &ae );
            
                if (SUCCEEDED(hr))
                {
                    hr = pAddressEvent->get_Terminal( &pTerminal );

                    if (SUCCEEDED(hr))
                    {
                        hr = pTerminal->get_Name( &bstrName );

                        if (SUCCEEDED(hr))
                        {
                            switch(ae)
                            {
                            case AE_NEWTERMINAL:
                                ::MessageBox(NULL, bstrName, L"AE_NEWTERMINAL", MB_OK);
                                break;
                    
                            case AE_REMOVETERMINAL:
                                ::MessageBox(NULL, bstrName, L"AE_REMOVETERMINAL", MB_OK);
                                break;
                    
                            }

                            SysFreeString( bstrName );

                            hr = pAddressEvent->get_Address( &pAddress );

                            if (SUCCEEDED(hr))
                            {
                                hr = pTerminal->get_MediaType( &lMediaType );

                                if (SUCCEEDED(hr))
                                {
                                    if (CT3testDlg::GetMediaType( &lSelectedMediaType ) && ( lSelectedMediaType == lMediaType))
                                    {
                                        CT3testDlg::ReleaseTerminals();
                                        CT3testDlg::UpdateTerminals( pAddress, lMediaType );
                                    }
                                }

                                pAddress->Release();
                            }
                        }
                        pTerminal->Release();
                    }
                }
                pAddressEvent->Release();
            }

            break;
        }

        default:

            break;
    }

    pEvent->Release();
    
    return S_OK;
}


#ifdef ENABLE_DIGIT_DETECTION_STUFF

HRESULT
STDMETHODCALLTYPE
CDigitDetectionNotification::DigitDetected(
                                           unsigned char ucDigit,
                                           TAPI_DIGITMODE DigitMode,
                                           long ulTickCount
                                          )
{
    return S_OK;
}
    
#endif // ENABLE_DIGIT_DETECTION_STUFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\event.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "externs.h"

void
CT3testDlg::HandleCallHubEvent( IDispatch * pEvent )
{
    HRESULT             hr;
    ITCallHubEvent *    pCallHubEvent;
    CALLHUB_EVENT       che;
    

    hr = pEvent->QueryInterface(
                                IID_ITCallHubEvent,
                                (void **)&pCallHubEvent
                               );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    hr = pCallHubEvent->get_Event( &che );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    switch ( che )
    {
        case CHE_CALLHUBNEW:

            break;
            
        case CHE_CALLHUBIDLE:

            break;
            
        default:
            break;
    }

    pCallHubEvent->Release();

}


void
CT3testDlg::HandleTapiObjectMessage( IDispatch * pEvent )
{
    ITTAPIObjectEvent * pte;
    HRESULT             hr;
    TAPIOBJECT_EVENT    te;

    hr = pEvent->QueryInterface(
                                IID_ITTAPIObjectEvent,
                                (void**)&pte
                               );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    pte->get_Event( &te );

    switch (te)
    {
        case TE_ADDRESSCREATE:
        case TE_ADDRESSREMOVE:

            ReleaseMediaTypes();
            ReleaseTerminals();
            ReleaseCalls();
            ReleaseSelectedTerminals();
            ReleaseCreatedTerminals();
            ReleaseTerminalClasses();
            ReleaseListen();
            ReleaseAddresses();
            InitializeAddressTree();

            break;
            
        default:
            break;
    }

    pte->Release();
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\calldlg.h ===
#if !defined(AFX_CREATECALLDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_CREATECALLDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CreateCallDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCreateCallDlg dialog

class CCreateCallDlg : public CDialog
{
// Construction
public:
	CCreateCallDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCreateCallDlg)
	enum { IDD = IDD_CREATECALL };
	CString	m_pszDestAddress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateCallDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCreateCallDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CREATECALLDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\confdlg.h ===
#if !defined(AFX_CONFDLG_H)
#define AFX_CONFDLG_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "rend.h"

/////////////////////////////////////////////////////////////////////////////
// CConfDlg dialog

class CConfDlg : public CDialog
{
// Construction
public:
	CConfDlg(CWnd* pParent = NULL);
	enum { IDD = IDD_CONFDLG };
    BSTR       m_bstrDestAddress;
    ITDirectory * m_pDirectory;
    
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void PopulateConferences();
    void ListObjects( ITDirectory * );
    BOOL CConfDlg::OnInitDialog();
    virtual void OnOK();
    afx_msg void OnDestroy();
    DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\externs.h ===
#include "stdafx.h"
#include "t3test.h"

extern ITTAPI * gpTapi;
extern HWND ghAddressesWnd;
extern HWND ghTerminalsWnd;
extern HWND ghMediaTypesWnd;
extern HWND ghCallsWnd;
extern HWND ghSelectedWnd;
extern HWND ghCreatedWnd;
extern HWND ghClassesWnd;
extern HWND ghListenWnd;
extern HTREEITEM ghAddressesRoot;
extern HTREEITEM ghTerminalsRoot;
extern HTREEITEM ghMediaTypesRoot;
extern HTREEITEM ghCallsRoot;
extern HTREEITEM ghSelectedRoot;
extern HTREEITEM ghCreatedRoot;
extern HTREEITEM ghClassesRoot;
extern HTREEITEM ghListenRoot;

extern long       gulAdvise;
extern BOOL gbUpdatingStuff;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\ilsdlg.cpp ===
// autoans.cpp : implementation file
//
#include "stdafx.h"
#include "t3test.h"
#include "t3testd.h"
#include "ilsdlg.h"
#include "servname.h"
#include "resource.h"
#include "strings.h"


#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CILSDlg::CILSDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CILSDlg::IDD, pParent)
{
}


void CILSDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}

BOOL CILSDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    ListServers();
    return TRUE;
}


void CILSDlg::OnOK()
{
    SaveServers();
    
	CDialog::OnOK();
}


void CILSDlg::OnDestroy() 
{
    CleanUp();
    CDialog::OnDestroy();
}


void CILSDlg::ListServers()
{
    HRESULT         hr;
    LPWSTR        * ppServers;
    DWORD           dw;
    
    hr = ListILSServers(
                        &ppServers,
                        &dw
                       );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    while (dw)
    {
        dw--;

        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_ADDSTRING,
                           0,
                           (LPARAM) ppServers[dw]
                          );

        CoTaskMemFree( ppServers[dw] );
        
    }

    CoTaskMemFree( ppServers );
    
}

void CILSDlg::SaveServers()
{
    HKEY        hKey, hAppKey;
    DWORD       dw;

    
    if ( RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      PARENTKEY,
                      0,
                      KEY_WRITE,
                      &hKey
                     ) != ERROR_SUCCESS )
    {
    }

    if ( RegCreateKeyEx(
                        hKey,
                        APPKEY,
                        0,
                        L"",
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hAppKey,
                        &dw
                       ) != ERROR_SUCCESS )
    {
    }

    RegCloseKey( hKey );

        
    RegDeleteKey(
                 hAppKey,
                 SERVERKEY
                );
    
    if ( RegCreateKeyEx(
                        hAppKey,
                        SERVERKEY,
                        0,
                        L"",
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dw
                       ) != ERROR_SUCCESS )
    {
    }

    RegCloseKey (hAppKey );
    
    dw = SendDlgItemMessage(
                            IDC_ILSLIST,
                            LB_GETCOUNT,
                            0,
                            0
                           );

    while ( 0 != dw )
    {
        WCHAR szServer[256];
        WCHAR szBuffer[256];
        
        dw--;

        wsprintf(szServer, L"server%d", dw);
                 
        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_GETTEXT,
                           dw,
                           (LPARAM)szBuffer
                          );

        RegSetValueEx(
                      hKey,
                      szServer,
                      0,
                      REG_SZ,
                      (BYTE *)szBuffer,
                      lstrlenW(szBuffer) * sizeof(WCHAR)
                     );
    }
}

void CILSDlg::CleanUp()
{
}

void CILSDlg::OnAdd()
{
    CServNameDlg dlg;
    
    if (IDOK == dlg.DoModal())
    {
        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_ADDSTRING,
                           0,
                           (LPARAM)(LPCTSTR)(dlg.m_pszServerName)
                          );
    }   
}

void CILSDlg::OnRemove()
{
    DWORD       dw;

    dw = SendDlgItemMessage(
                            IDC_ILSLIST,
                            LB_GETCURSEL,
                            0,
                            0
                           );

    if ( dw != LB_ERR )
    {
        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_DELETESTRING,
                           dw,
                           0
                          );
    }
}


BEGIN_MESSAGE_MAP(CILSDlg, CDialog)
	ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
END_MESSAGE_MAP()

            
HRESULT ListILSServers(
                    LPWSTR ** pppServers,
                    DWORD * pdwNumServers
                   )
{
    HKEY        hKey, hAppKey;
    DWORD       dw, dwSize;

    //
    // look in the directory for the
    //
    if ( RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      PARENTKEY,
                      0,
                      KEY_WRITE,
                      &hKey
                     ) != ERROR_SUCCESS )
    {
    }

    if ( RegOpenKeyEx(
                      hKey,
                      APPKEY,
                      0,
                      KEY_ALL_ACCESS,
                      &hAppKey
                     ) != ERROR_SUCCESS )
    {
        RegCloseKey( hKey );
        return E_FAIL;
    }

    RegCloseKey( hKey );
    
    if ( RegOpenKeyEx(
                      hAppKey,
                      SERVERKEY,
                      0,
                      KEY_ALL_ACCESS,
                      &hKey
                     ) != ERROR_SUCCESS )
    {
        RegCloseKey(hAppKey);
        return E_FAIL;
    }

    RegCloseKey (hAppKey );
    
    dw = 0;
    
    while (TRUE)
    {
        WCHAR       szBuffer[256];
        WCHAR       szServer[256];
        DWORD       dwType;
        
        wsprintf(szBuffer, L"server%d", dw);

        if ( RegQueryValueEx(
                             hKey,
                             szBuffer,
                             NULL,
                             NULL,
                             NULL,
                             &dwSize
                            ) != ERROR_SUCCESS )
        {
            break;
        }

        dw++;
    }

    *pppServers = (LPWSTR *)CoTaskMemAlloc( dw * sizeof (LPWSTR) );

    if ( NULL == *pppServers )
    {
        return E_OUTOFMEMORY;
    }

    dw = 0;
    
    while (TRUE)
    {
        WCHAR       szBuffer[256];
        WCHAR       szServer[256];
        DWORD       dwType;
        
        wsprintf(szBuffer, L"server%d", dw);

        dwSize = 256;
        
        if ( RegQueryValueEx(
                             hKey,
                             szBuffer,
                             NULL,
                             NULL,
                             (LPBYTE)szServer,
                             &dwSize
                            ) != ERROR_SUCCESS )
        {
            break;
        }

        (*pppServers)[dw] = (LPWSTR) CoTaskMemAlloc( (lstrlenW(szServer) + 1) * sizeof(WCHAR));
        
        lstrcpy(
                (*pppServers)[dw],
                szServer
               );
        dw++;
    }

    *pdwNumServers = dw;

    RegCloseKey( hKey );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\ilsdlg.h ===
#if !defined(AFX_ILSDlg_H)
#define AFX_ILSDlg_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "rend.h"

/////////////////////////////////////////////////////////////////////////////
// CILSDlg dialog

class CILSDlg : public CDialog
{
// Construction
public:
	CILSDlg(CWnd* pParent = NULL);
	enum { IDD = IDD_ILSSERVERS };
    
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    BOOL CILSDlg::OnInitDialog();
    virtual void OnOK();
    afx_msg void OnDestroy();
    afx_msg void OnAdd();
    afx_msg void OnRemove();
    void ListServers();
    void SaveServers();
    void CleanUp();
    DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\menus.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"
#include "control.h"

void
CT3testDlg::CreateSelectedTerminalMenu(
                                       POINT pt,
                                       HWND hWnd
                                      )
{
    ITTerminal *                    pTerminal;

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    ITDigitGenerationTerminal *     pDigitGeneration;
    ITDigitDetectionTerminal *         pDigitDetect;
#endif // ENABLE_DIGIT_DETECTION_STUFF


    HRESULT                         hr;
    ITBasicAudioTerminal *          pBasicAudio;
    long                            lval;
    
    //
    // get the terminal in question
    //
    if (!GetSelectedTerminal( &pTerminal ))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITBasicAudioTerminal,
                                   (void **) &pBasicAudio
                                  );

    if ( SUCCEEDED(hr) )
    {
        pBasicAudio->get_Volume( &lval );
        pBasicAudio->put_Volume( lval );
        pBasicAudio->get_Balance( &lval );
        pBasicAudio->put_Balance( lval );
        pBasicAudio->Release();
    }

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    hr = pTerminal->QueryInterface(
                                   IID_ITDigitGenerationTerminal,
                                   (void **) &pDigitGeneration
                                  );

    if (SUCCEEDED(hr))
    {
        DoDigitGenerationTerminalMenu(hWnd, &pt);

        pDigitGeneration->Release();
        
        return;
    }
    
    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetect
                                  );

    if (SUCCEEDED(hr))
    {
        DoDigitDetectTerminalMenu(hWnd,&pt);

        pDigitDetect->Release();
        
        return;
    }
#endif // ENABLE_DIGIT_DETECTION_STUFF


}

void CT3testDlg::DoDigitGenerationTerminalMenu(
                                               HWND hWnd,
                                               POINT * pPt
                                              )
{
    //
    // create the menu
    //
    HMENU                   hMenu;

    hMenu = CreatePopupMenu();

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_MODESUPPORTED,
               L"Modes Supported"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_GENERATE,
               L"Generate"
              );

    // actually show menu
    TrackPopupMenu(
                   hMenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                   pPt->x,
                   pPt->y,
                   0,
                   hWnd,
                   NULL
                  );
}
    
void CT3testDlg::DoDigitDetectTerminalMenu(
                                           HWND hWnd,
                                           POINT * pPt
                                          )
{
    //
    // create the menu
    //
    HMENU                   hMenu;

    hMenu = CreatePopupMenu();

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_MODESUPPORTED2,
               L"Modes Supported"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_STARTDETECT,
               L"Start Detection"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_STOPDETECT,
               L"Stop Detection"
              );

    // actually show menu
    TrackPopupMenu(
                   hMenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                   pPt->x,
                   pPt->y,
                   0,
                   hWnd,
                   NULL
                  );
}

void
CT3testDlg::CreateCallMenu(
                           POINT pt,
                           HWND hWnd
                          )
{
    ITCallInfo              * pCall;
    HMENU                   hMenu;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    //
    // create the menu
    //
    hMenu = CreatePopupMenu();

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_HANDOFF1,
               L"Handoff1"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_HANDOFF2,
               L"Handoff2"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PARK1,
               L"Park1"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PARK2,
               L"Park2"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_UNPARK,
               L"Unpark"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PICKUP1,
               L"Pickup1"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PICKUP2,
               L"Pickup2"
              );

    

    

    //
    // actually show menu
    //
    TrackPopupMenu(
                   hMenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                   pt.x,
                   pt.y,
                   0,
                   hWnd,
                   NULL
                  );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\rate.h ===
#if !defined(AFX_RATEDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_RATEDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// RateDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRateDlg dialog

class CRateDlg : public CDialog
{
// Construction
public:
	CRateDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRateDlg)
	enum { IDD = IDD_RATE };
    DWORD m_dwMinRate;
    DWORD m_dwMaxRate;
    
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRateDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRateDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RATEDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\rate.cpp ===
// RateDlg.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "rate.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRateDlg dialog


CRateDlg::CRateDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRateDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRateDlg)
	m_dwMinRate = 0;
    m_dwMaxRate = 0;

	//}}AFX_DATA_INIT
}


void CRateDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRateDlg)
	DDX_Text(pDX, IDC_MINRATE, m_dwMinRate);
    DDX_Text(pDX, IDC_MAXRATE, m_dwMaxRate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRateDlg, CDialog)
	//{{AFX_MSG_MAP(CRateDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRateDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\gets.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetMediaTypeName
//
// Convert the mediatype bstr to a string, like
// "audio in"
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::GetMediaTypeName(
                                  long lMediaType,
                                  LPWSTR szString
                                 )
{
    if (lMediaType == (long)LINEMEDIAMODE_AUTOMATEDVOICE)
    {
        lstrcpyW(
                 szString,
                 L"Audio"
                );

    }
    else if (lMediaType == (long)LINEMEDIAMODE_VIDEO)
    {
        lstrcpyW(
                 szString,
                 L"Video"
                );

    }
    else if (lMediaType == (long)LINEMEDIAMODE_DATAMODEM)
    {
        lstrcpyW(
                 szString,
                 L"DataModem"
                );

    }
    else if (lMediaType == (long)LINEMEDIAMODE_G3FAX)
    {
        lstrcpyW(
                 szString,
                 L"G3Fax"
                );

    }
    else
    {
        lstrcpyW(
                 szString,
                 L"Unknown MediaType - "
                );
    }

    
}

LPWSTR CT3testDlg::GetCallPrivilegeName(
                                        ITCallInfo * pCall
                                       )
{
    CALL_PRIVILEGE      cp;

    
    pCall->get_Privilege( &cp );

    if (CP_OWNER == cp)
    {
        return SysAllocString(L"OWNER");
        
    }
    else
    {
        return SysAllocString(L"MONITOR");
    }

    return NULL;
}


LPWSTR CT3testDlg::GetCallStateName(
                                    ITCallInfo * pCall
                                   )
{
    CALL_STATE          cs;
    
    //
    // get the current call state
    //
    pCall->get_CallState( &cs );

    //
    // make the name
    //
    switch( cs )
    {
        case CS_INPROGRESS:

            return SysAllocString( L"INPROGRESS" );
            break;

        case CS_CONNECTED:

            return SysAllocString ( L"CONNECTED" );
            break;

        case CS_DISCONNECTED:

            return SysAllocString ( L"DISCONNECTED" );
            break;

        case CS_OFFERING:

            return SysAllocString ( L"OFFERING" );
            break;

        case CS_IDLE:

            return SysAllocString( L"IDLE" );
            break;

        default:

            return SysAllocString( L"<Unknown Call State>" );
            break;
    }


    return NULL;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetAddress
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetAddress( ITAddress ** ppAddress )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghAddressesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghAddressesWnd,
                     &item
                    );

    *ppAddress = (ITAddress *)item.lParam;

    if (NULL == *ppAddress)
    {
//        ::MessageBox(NULL, L"Select an Address", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetTerminal( ITTerminal ** ppTerminal )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghTerminalsWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghTerminalsWnd,
                     &item
                    );

    *ppTerminal = (ITTerminal *)item.lParam;

    if (NULL == *ppTerminal)
    {
        ::MessageBox(NULL, L"Select a Terminal", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetCall( ITCallInfo ** ppCallInfo )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghCallsWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghCallsWnd,
                     &item
                    );

    *ppCallInfo = (ITCallInfo *)item.lParam;

    if (NULL == *ppCallInfo)
    {
        //::MessageBox(NULL, L"Select a Call", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetMediaType
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetMediaType( long * plMediaType )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghMediaTypesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghMediaTypesWnd,
                     &item
                    );

    *plMediaType = (long)(item.lParam);

    if (0 == *plMediaType)
    {
        return FALSE;
    }

    return TRUE;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetTerminalClass
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetTerminalClass( BSTR * pbstrClass )
{
    HTREEITEM       hItem;
    TV_ITEM         item;
    GUID *          pguid;

    hItem = TreeView_GetSelection(
                                  ghClassesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghClassesWnd,
                     &item
                    );

    pguid = (GUID *)item.lParam;

    if (NULL == pguid)
    {
        return FALSE;
    }

    LPWSTR      lphold;

    
    StringFromIID(
                  *pguid,
                  &lphold
                 );

    *pbstrClass = SysAllocString(lphold);

    CoTaskMemFree(lphold);
    
    return TRUE;
}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetCreatedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetCreatedTerminal( ITTerminal ** ppTerminal )
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    hItem = TreeView_GetSelection(
                                  ghCreatedWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghCreatedWnd,
                     &item
                    );

    *ppTerminal = (ITTerminal *)item.lParam;

    if (NULL == *ppTerminal)
    {
        return FALSE;
    }

    return TRUE;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetSelectedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetSelectedTerminal( ITTerminal ** ppTerminal )
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    hItem = TreeView_GetSelection(
                                  ghSelectedWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghSelectedWnd,
                     &item
                    );

    *ppTerminal = (ITTerminal *)item.lParam;

    if (NULL == *ppTerminal)
    {
        return FALSE;
    }

    return TRUE;
}


BSTR CT3testDlg::GetTerminalClassName( GUID * pguid )
{
    if (IsEqualIID( *pguid, CLSID_VideoWindowTerm ))
    {
        return SysAllocString( L"Video" );
    }

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    else if (IsEqualIID( *pguid, CLSID_DigitTerminal ))
    {
        return SysAllocString( L"Digit Terminal" );
    }
    else if (IsEqualIID( *pguid, CLSID_DataTerminal ))
    {
        return SysAllocString( L"Data Terminal" );
    }
#endif // ENABLE_DIGIT_DETECTION_STUFF

    else
    {
        return SysAllocString( L"Unknown Dynamic Type" );
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by t3test.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_T3TEST_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDD_CREATECALL                  129
#define IDR_DIGITPOPUP                  130
#define IDD_AUTOANSWER                  131
#define IDD_CONFDLG                     132
#define IDD_ILSSERVERS                  133
#define IDD_ILSSERVERNAME               134
#define IDD_RATE                        135
#define IDC_ADDRESSES                   1000
#define IDC_MEDIATYPES                  1001
#define IDC_TERMINALS                   1002
#define IDC_CALLS                       1003
#define IDC_CREATECALL                  1004
#define IDC_CONNECT                     1005
#define IDC_ANSWER                      1006
#define IDC_DROP                        1007
#define IDC_ADDTERMINAL                 1008
#define IDC_REMOVETERMINAL              1009
#define IDC_DESTADDRESS                 1010
#define IDC_SELECTEDTERMINALS           1011
#define IDC_LISTEN                      1012
#define IDC_RELEASE                     1013
#define IDC_CREATE                      1014
#define IDC_RELEASETERMINAL             1015
#define IDC_CREATEDTERMINALS            1017
#define IDC_DYNAMICCLASSES              1018
#define IDC_ADDCREATED                  1019
#define IDC_ADDNULL                     1020
#define IDC_LISTENMEDIAMODES            1021
#define IDC_ADDTOLISTEN                 1022
#define IDC_LISTENALL                   1023
#define IDC_CONFIGAUTOANSWER            1024
#define IDC_SELECTED                    1025
#define IDC_NOTSELECTED                 1026
#define IDC_TERMINALADD                 1027
#define IDC_TERMINALREMOVE              1028
#define IDC_CONFLIST                    1029
#define IDC_ILS                         1029
#define IDC_ILSLIST                     1030
#define IDC_ADD                         1031
#define IDC_REMOVE                      1032
#define IDC_SERVERNAME                  1033
#define IDC_RATE                        1034
#define IDC_MINRATE                     1035
#define IDC_MAXRATE                     1036
#define ID_MODESUPPORTED                32771
#define ID_GENERATE                     32772
#define ID_MODESUPPORTED2               32773
#define ID_STARTDETECT                  32774
#define ID_STOPDETECT                   32775
#define ID_NOTHING                      32776
#define ID_PARK1                        32778
#define ID_PARK2                        32779
#define ID_HANDOFF1                     32780
#define ID_HANDOFF2                     32781
#define ID_UNPARK                       32782
#define ID_PICKUP1                      32783
#define ID_PICKUP2                      32784


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32773
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	t3test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef UNICODE
#define UNICODE
#endif

#if !defined(AFX_STDAFX_H__47F9FE88_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_STDAFX_H__47F9FE88_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#include "tapi3.h"
//#include "tapi.h"

#include <list>
using namespace std;

typedef list<ITTerminal *>      TerminalPtrList;
typedef struct
{
    ITAddress * pAddress;
    TerminalPtrList * pTerminalPtrList;
    
} AADATA;

typedef list<AADATA *> DataPtrList;
   


#endif // !defined(AFX_STDAFX_H__47F9FE88_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\strings.h ===
#define PARENTKEY L"Software\\Microsoft"
#define APPKEY L"t3test"
#define SERVERKEY L"Servers"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\servname.cpp ===
// ServNameDlg.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "servname.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServNameDlg dialog


CServNameDlg::CServNameDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CServNameDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CServNameDlg)
	m_pszServerName = _T("");
	//}}AFX_DATA_INIT
}


void CServNameDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServNameDlg)
	DDX_Text(pDX, IDC_SERVERNAME, m_pszServerName);
	DDV_MaxChars(pDX, m_pszServerName, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServNameDlg, CDialog)
	//{{AFX_MSG_MAP(CServNameDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServNameDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\t3test.cpp ===
// t3test.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CWnd * gpmainwnd;

/////////////////////////////////////////////////////////////////////////////
// CT3testApp

BEGIN_MESSAGE_MAP(CT3testApp, CWinApp)
	//{{AFX_MSG_MAP(CT3testApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CT3testApp construction

CT3testApp::CT3testApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CT3testApp object

CT3testApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CT3testApp initialization

BOOL CT3testApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CT3testDlg dlg;
	m_pMainWnd = &dlg;
    gpmainwnd = &dlg;
    
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\servname.h ===
#if !defined(AFX_ServNameDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_ServNameDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ServNameDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServNameDlg dialog

class CServNameDlg : public CDialog
{
// Construction
public:
	CServNameDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CServNameDlg)
	enum { IDD = IDD_ILSSERVERNAME };
	CString	m_pszServerName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServNameDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CServNameDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ServNameDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\autoans.h ===
#if !defined(AFX_AUTOANS_H__2BFE6626_7758_11D1_8F5C_00C04FB6809F__INCLUDED_)
#define AFX_AUTOANS_H__2BFE6626_7758_11D1_8F5C_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// autoans.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// autoans dialog

class autoans : public CDialog
{
// Construction
public:
	autoans(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(autoans)
	enum { IDD = IDD_AUTOANSWER };
    TerminalPtrList m_TerminalPtrList;
    ITAddress * m_pAddress;
    
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(autoans)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(autoans)
	virtual BOOL OnInitDialog();
	afx_msg void OnTerminalAdd();
	afx_msg void OnTerminalRemove();
	virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnClose() ;
    void PopulateListBox();
    void AddTerminalToListBox( ITTerminal * pTerminal, BOOL bSelected );
    void AddDynamicTerminalToListBox( BOOL bSelected );
    void AddTerminalToAAList( ITTerminal * pTerminal );
//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUTOANS_H__2BFE6626_7758_11D1_8F5C_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\t3test.h ===
// t3test.h : main header file for the T3TEST application
//

#if !defined(AFX_T3TEST_H__47F9FE84_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_T3TEST_H__47F9FE84_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CT3testApp:
// See t3test.cpp for the implementation of this class
//

class CT3testApp : public CWinApp
{
public:
	CT3testApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CT3testApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CT3testApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_T3TEST_H__47F9FE84_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\calldlg.cpp ===
// CreateCallDlg.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "CallDlg.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateCallDlg dialog


CCreateCallDlg::CCreateCallDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCreateCallDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCreateCallDlg)
	m_pszDestAddress = _T("");
	//}}AFX_DATA_INIT
}


void CCreateCallDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCreateCallDlg)
	DDX_Text(pDX, IDC_DESTADDRESS, m_pszDestAddress);
	DDV_MaxChars(pDX, m_pszDestAddress, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCreateCallDlg, CDialog)
	//{{AFX_MSG_MAP(CCreateCallDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCreateCallDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\release.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseAddresses
//
// Release all the address objects in the address tree
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseAddresses()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;

    //
    // get the first address
    //
    hItem = TreeView_GetChild(
                              ghAddressesWnd,
                              ghAddressesRoot
                             );

    //
    // go through all the addresses
    // and release
    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        ITAddress * pAddress;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghAddressesWnd,
                         &item
                        );

        pAddress = (ITAddress *)item.lParam;

        if (NULL != pAddress)
        {
            pAddress->Release();
        }
        

        hNewItem = TreeView_GetNextSibling(
                                        ghAddressesWnd,
                                        hItem
                                       );
        //
        // delete the item
        //
//        TreeView_DeleteItem(
//                            ghAddressesWnd,
//                            hItem
//                           );

        hItem = hNewItem;
    }

    TreeView_DeleteAllItems(ghAddressesWnd);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseMediaTypes
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseMediaTypes()
{
    HTREEITEM           hItem;
    TV_ITEM             item;
    BSTR                pMediaType;

    gbUpdatingStuff = TRUE;
    
    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the mediatypes
    // and free the associated strings
    // and delete the item from the
    // tree
    //
    hItem = TreeView_GetChild(
                              ghMediaTypesWnd,
                              ghMediaTypesRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                           ghMediaTypesWnd,
                                           hItem
                                          );


        //
        // delete the item
        //
        TreeView_DeleteItem(
                            ghMediaTypesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

    gbUpdatingStuff = FALSE;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseListen
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseListen()
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // delete all the leave on the listen
    // tree
    // there are no resources associated with
    // this, so nothing to free
    //
    hItem = TreeView_GetChild(
                              ghListenWnd,
                              ghListenRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                        ghListenWnd,
                                        hItem
                                       );

        TreeView_DeleteItem(
                            ghListenWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseTerminalClasses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseTerminalClasses()
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the terminal classes
    // free the memory allocated for the
    // guid, and delete the item
    //
    hItem = TreeView_GetChild(
                              ghClassesWnd,
                              ghClassesRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        GUID *      pGuid;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghClassesWnd,
                         &item
                        );

        pGuid = (GUID *)item.lParam;
        delete pGuid;

        hNewItem = TreeView_GetNextSibling(
                                           ghClassesWnd,
                                           hItem
                                          );

        TreeView_DeleteItem(
                            ghClassesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseTerminalClasses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseTerminals()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go though all the terminals, and
    // free the terminals, and delete the
    // item
    //
    hItem = TreeView_GetChild(
                              ghTerminalsWnd,
                              ghTerminalsRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITTerminal *        pTerminal;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghTerminalsWnd,
                         &item
                        );

        pTerminal = (ITTerminal *)item.lParam;

        pTerminal->Release();

        hNewItem = TreeView_GetNextSibling(
                                        ghTerminalsWnd,
                                        hItem
                                       );
    

        TreeView_DeleteItem(
                            ghTerminalsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseSelectedTerminals
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseSelectedTerminals()
{
    HTREEITEM               hItem;
    TV_ITEM                 item;

    
    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the selected terminals
    // and free and delete
    //
    hItem = TreeView_GetChild(
                              ghSelectedWnd,
                              ghSelectedRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITTerminal *        pTerminal;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghSelectedWnd,
                         &item
                        );

        pTerminal = (ITTerminal *)item.lParam;

        pTerminal->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghSelectedWnd,
                                           hItem
                                          );


        TreeView_DeleteItem(
                            ghSelectedWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseCalls()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the calls, and
    // release and delete
    //
    hItem = TreeView_GetChild(
                              ghCallsWnd,
                              ghCallsRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITCallInfo *        pCallInfo;

        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghCallsWnd,
                         &item
                        );

        pCallInfo = (ITCallInfo *)item.lParam;

        pCallInfo->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghCallsWnd,
                                           hItem
                                          );
    

        TreeView_DeleteItem(
                            ghCallsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseCreatedTerminals()
{
    HTREEITEM hItem;
    TV_ITEM item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    

    //
    // go through all the created terminals
    // and release and delete
    //
    hItem = TreeView_GetChild(
                              ghCreatedWnd,
                              ghCreatedRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM hNewItem;
        ITTerminal * pTerminal;

        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghCreatedWnd,
                         &item
                        );

        pTerminal = (ITTerminal *)item.lParam;

        pTerminal->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghCreatedWnd,
                                           hItem
                                          );
    

        TreeView_DeleteItem(
                            ghCreatedWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\calldlg.h ===
#if !defined(AFX_CREATECALLDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_CREATECALLDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CreateCallDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCreateCallDlg dialog

class CCreateCallDlg : public CDialog
{
// Construction
public:
	CCreateCallDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCreateCallDlg)
	enum { IDD = IDD_CREATECALL };
	CString	m_pszDestAddress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateCallDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCreateCallDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CREATECALLDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\confdlg.cpp ===
// autoans.cpp : implementation file
//
#include "stdafx.h"

#include "t3test.h"
#include "t3testd.h"
#include "confdlg.h"
#include "strings.h"
#include "resource.h"


#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CConfDlg::CConfDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConfDlg::IDD, pParent)
{
        m_bstrDestAddress = NULL;
}


void CConfDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}

BOOL CConfDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    PopulateConferences();
    return TRUE;
}

void CConfDlg::PopulateConferences()
{
    ITRendezvous *      pRend;
    IEnumDirectory *    pEnumDirectory;
    HRESULT             hr;
    ITDirectory *       pDirectory;
    LPWSTR *            ppServers;
    DWORD               dw;
    
    //
    // create the rendezvous control.
    //
    hr = ::CoCreateInstance(
                            CLSID_Rendezvous,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_ITRendezvous,
                            (void **)&pRend
                           );
    
    if (FAILED(hr))
    {
        return;
    }


    hr = pRend->EnumerateDefaultDirectories(
        &pEnumDirectory
        );

    if (FAILED(hr))
    {
        pRend->Release();
    
        return;
    }

    while (TRUE)
    {

        DWORD dwFetched = 0;

        hr = pEnumDirectory->Next(
                                  1,
                                  &pDirectory,
                                  &dwFetched
                                 );

        if ( S_OK != hr )
        {
            break;
        }

        DIRECTORY_TYPE type;
        // print out the names of the conference found.
        hr = pDirectory->get_DirectoryType(&type);
        if ( FAILED(hr) )
        {
            pDirectory->Release();
            continue;
        }

        if (type == DT_ILS)
        {
            break;
        }

        pDirectory->Release();

    }

    pEnumDirectory->Release();

    //
    // if hr is s_false, we went through the enumerate
    // without finding an ils server
    //
    if ( S_OK == hr )
    {
        hr = pDirectory->Connect(FALSE);

        if ( SUCCEEDED(hr))
        {
            ListObjects( pDirectory );
        }

        pDirectory->Release();
    }

    hr = ListILSServers(
                        &ppServers,
                        &dw
                       );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }
    
    while ( dw )
    {
        dw--;

        hr = pRend->CreateDirectory(
                                    DT_ILS,
                                    ppServers[dw],
                                    &pDirectory
                                   );

        if ( SUCCEEDED(hr) )
        {
            hr = pDirectory->Connect(FALSE);

            if ( SUCCEEDED(hr) )
            {
                ListObjects( pDirectory );
            }

            pDirectory->Release();
        }

        CoTaskMemFree( ppServers[dw] );
    }

    CoTaskMemFree( ppServers );

}

void
CConfDlg::ListObjects( ITDirectory * pDirectory )
{
    BSTR            bstrNameToSearch;
    BSTR            bstrDirName;
    HRESULT         hr;
    int             i;
    
    
    bstrNameToSearch = SysAllocString(L"*");

    if (bstrNameToSearch == NULL)
    {
        return;
    }

    IEnumDirectoryObject * pEnum;
    
    hr = pDirectory->EnumerateDirectoryObjects(
        OT_CONFERENCE,
        bstrNameToSearch,
        &pEnum
        );

    SysFreeString( bstrNameToSearch );

    if (FAILED(hr))
    {
        return;
    }

    pDirectory->get_DisplayName( &bstrDirName );

    // print out the names of all the users found.
    while (TRUE)
    {
        ITDirectoryObject *     pObject;
        BSTR                    bstrObjectName;
        WCHAR                   szBuffer[256];

        hr = pEnum->Next(
                         1,
                         &pObject,
                         NULL
                        );
        
        if ( S_OK != hr )
        {
            break;
        }

        hr = pObject->get_Name(&bstrObjectName);
        
        if (FAILED(hr))
        {
            continue;
        }

        wsprintf(szBuffer, L"%s: %s", bstrDirName, bstrObjectName );
        
        i = SendDlgItemMessage(
                               IDC_CONFLIST,
                               LB_ADDSTRING,
                               0,
                               (LPARAM)szBuffer
                              );

        SysFreeString(bstrObjectName);

        SendDlgItemMessage(
                           IDC_CONFLIST,
                           LB_SETITEMDATA,
                           i,
                           (LPARAM) pObject
                          );
    }

    SysFreeString( bstrDirName );
    
    pEnum->Release();
}

void CConfDlg::OnOK()
{
    DWORD       i;
    HRESULT     hr;
    
    i = SendDlgItemMessage(
                           IDC_CONFLIST,
                           LB_GETCURSEL,
                           0,
                           0
                          );

    if (LB_ERR != i)
    {
        ITDirectoryObject *     pObject;
        IEnumDialableAddrs *    pEnumAddress;

        
        pObject = (ITDirectoryObject *)SendDlgItemMessage(
            IDC_CONFLIST,
            LB_GETITEMDATA,
            i,
            0
            );

        hr = pObject->EnumerateDialableAddrs(
                                             LINEADDRESSTYPE_SDP,
                                             &pEnumAddress
                                            );

        if ( !SUCCEEDED(hr) )
        {
        }

        hr = pEnumAddress->Next(
                                1,
                                &m_bstrDestAddress,
                                NULL
                               );

        if ( S_OK != hr )
        {
        }

        pEnumAddress->Release();
    }

    
	CDialog::OnOK();
}


void CConfDlg::OnDestroy() 
{
    DWORD       count;

    CDialog::OnDestroy();

    count = SendDlgItemMessage(
                               IDC_CONFLIST,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    while ( 0 != count )
    {
        ITDirectoryObject * pObject;

        count--;
        
        pObject = (ITDirectoryObject *)SendDlgItemMessage(
            IDC_CONFLIST,
            LB_GETITEMDATA,
            count,
            0
            );

        pObject->Release();
    }
}


BEGIN_MESSAGE_MAP(CConfDlg, CDialog)
	ON_WM_DESTROY()
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\autoans.cpp ===
// autoans.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "t3testd.h"
#include "autoans.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
extern DataPtrList       gDataPtrList;
/////////////////////////////////////////////////////////////////////////////
// autoans dialog


autoans::autoans(CWnd* pParent /*=NULL*/)
	: CDialog(autoans::IDD, pParent)
{
        CT3testDlg::GetAddress( &m_pAddress );

}


void autoans::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(autoans)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BOOL autoans::OnInitDialog()
{
    CDialog::OnInitDialog();
    PopulateListBox();

    return TRUE;
}


BEGIN_MESSAGE_MAP(autoans, CDialog)
	//{{AFX_MSG_MAP(autoans)
	ON_BN_CLICKED(IDC_TERMINALADD, OnTerminalAdd)
	ON_BN_CLICKED(IDC_TERMINALREMOVE, OnTerminalRemove)
    ON_WM_CLOSE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// autoans message handlers

void autoans::OnTerminalAdd() 
{
    LONG            i;
    ITTerminal *    pTerminal;
    
    i = SendDlgItemMessage(
                           IDC_NOTSELECTED,
                           LB_GETCURSEL,
                           0,
                           0
                          );

    if ( i == LB_ERR )
    {
        return;
    }
    
    pTerminal = (ITTerminal *) SendDlgItemMessage(
        IDC_NOTSELECTED,
        LB_GETITEMDATA,
        i,
        0
        );

    if ( NULL != pTerminal )
    {
        SendDlgItemMessage(
                           IDC_NOTSELECTED,
                           LB_DELETESTRING,
                           i,
                           0
                          );

        AddTerminalToListBox( pTerminal, TRUE );
    }
    else
    {
        AddDynamicTerminalToListBox( TRUE );
    }

	
}

void autoans::OnTerminalRemove() 
{
    LONG        i;
    ITTerminal * pTerminal;
    
    i = SendDlgItemMessage(
                           IDC_SELECTED,
                           LB_GETCURSEL,
                           0,
                           0
                          );

    if ( i == LB_ERR )
    {
        return;
    }
    
    pTerminal = (ITTerminal *) SendDlgItemMessage(
        IDC_SELECTED,
        LB_GETITEMDATA,
        i,
        0
        );

    SendDlgItemMessage(
                       IDC_SELECTED,
                       LB_DELETESTRING,
                       i,
                       0
                      );
    
    if ( NULL != pTerminal )
    {
        AddTerminalToListBox( pTerminal, FALSE );
    }
	
}

void autoans::OnOK() 
{
    LONG        i, count;

    
    i = 0;

    count = SendDlgItemMessage(
                               IDC_SELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );


    for( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        
        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_SELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        AddTerminalToAAList( pTerminal );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }

    count = SendDlgItemMessage(
                               IDC_NOTSELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    for ( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_NOTSELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }
    

	CDialog::OnOK();
}
void autoans::OnCancel()
{
    LONG        i, count;

    
    i = 0;

    count = SendDlgItemMessage(
                               IDC_SELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );


    for( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        
        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_SELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }


    count = SendDlgItemMessage(
                               IDC_NOTSELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    for ( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_NOTSELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }
    
    CDialog::OnCancel();
}

void autoans::PopulateListBox()
{
    ITTerminalSupport * pTerminalSupport;
    IEnumTerminal *     pEnumTerminal;
    IEnumTerminalClass * pEnumClasses;
    HRESULT             hr;
    
    if ( NULL == m_pAddress )
    {
        return;
    }

    m_pAddress->QueryInterface(
                               IID_ITTerminalSupport,
                               (void **) &pTerminalSupport
                              );

    pTerminalSupport->EnumerateStaticTerminals( &pEnumTerminal );

    while (TRUE)
    {
        ITTerminal * pTerminal;
        
        hr = pEnumTerminal->Next(
                                 1,
                                 &pTerminal,
                                 NULL
                                );

        if ( S_OK != hr )
        {
            break;
        }

        AddTerminalToListBox( pTerminal, FALSE );

//        pTerminal->Release();
    }

    pEnumTerminal->Release();

    pTerminalSupport->EnumerateDynamicTerminalClasses( &pEnumClasses );

    while (TRUE)
    {
        GUID        guid;
        
        hr = pEnumClasses->Next(
                                1,
                                &guid,
                                NULL
                               );

        if ( S_OK != hr )
        {
            break;
        }

        if ( guid == CLSID_VideoWindowTerm )
        {
            AddDynamicTerminalToListBox( FALSE );
        }

    }

    pEnumClasses->Release();
    
    pTerminalSupport->Release();
}

void
autoans::AddTerminalToListBox( ITTerminal * pTerminal, BOOL bSelected )
{
    HRESULT         hr;
    LONG            i;
    DWORD           dwLB;
    BSTR            bstrName;
    WCHAR		szBuffer[256];
	TERMINAL_DIRECTION td;

    dwLB = (bSelected ? IDC_SELECTED : IDC_NOTSELECTED);

    hr = pTerminal->get_Name( &bstrName );
    pTerminal->get_Direction( &td );

	if ( td == TD_RENDER )
	{
		wsprintfW(szBuffer, L"%s [Playback]", bstrName);
	}
	else
	{
		wsprintfW(szBuffer, L"%s [Record]", bstrName);	
	}

    i = SendDlgItemMessage(
                           dwLB,
                           LB_ADDSTRING,
                           0,
                           (LPARAM)szBuffer
                          );

    SysFreeString( bstrName );

    SendDlgItemMessage(
                       dwLB,
                       LB_SETITEMDATA,
                       (WPARAM) i,
                       (LPARAM) pTerminal
                      );

}

void
autoans::AddDynamicTerminalToListBox( BOOL bSelected )
{
    LONG            i;
    DWORD           dwLB;

    dwLB = (bSelected ? IDC_SELECTED : IDC_NOTSELECTED);


    i = SendDlgItemMessage(
                           dwLB,
                           LB_ADDSTRING,
                           0,
                           (LPARAM)L"Video Window"
                          );

    SendDlgItemMessage(
                       dwLB,
                       LB_SETITEMDATA,
                       (WPARAM) i,
                       (LPARAM) 0
                      );


    return;
}

void autoans::AddTerminalToAAList( ITTerminal * pTerminal )
{
    if ( NULL != pTerminal )
    {
        pTerminal->AddRef();
    }
    
    m_TerminalPtrList.push_back( pTerminal );
}


void autoans::OnClose()
{
    LONG        i, count;

    
    i = 0;

    count = SendDlgItemMessage(
                               IDC_SELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );


    for( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        
        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_SELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }


    count = SendDlgItemMessage(
                               IDC_NOTSELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    for ( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_NOTSELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }
    
	CDialog::OnClose();
    
}

void
CT3testDlg::DoAutoAnswer(
                         ITCallInfo * pCall
                        )
{
    ITAddress * pAddress;
    ITBasicCallControl * pBCC;
    HRESULT     hr;
    DataPtrList::iterator iter,end;
    TerminalPtrList::iterator terminaliter, terminalend;
    DWORD       dwSize;
    ITTerminalSupport * pTerminalSupport;
    BSTR        bstrTerminalClass;
    PWSTR       pwstr;
    

    StringFromIID(CLSID_VideoWindowTerm,&pwstr);
    bstrTerminalClass = SysAllocString( pwstr );
    CoTaskMemFree( pwstr );

    hr = pCall->get_Address( &pAddress );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    hr = pAddress->QueryInterface(
                                  IID_ITTerminalSupport,
                                  (void **) &pTerminalSupport
                                 );

    if ( !SUCCEEDED(hr) )
    {
        pAddress->Release();
        return;
    }
    
    hr = pCall->QueryInterface(
                               IID_ITBasicCallControl,
                               (void **)&pBCC
                              );

    if ( !SUCCEEDED(hr) )
    {
        pTerminalSupport->Release();
        pAddress->Release();
        return;
    }

    iter = gDataPtrList.begin();
    end  = gDataPtrList.end();

    for ( ; iter != end ; iter++ )
    {
        if ( (*iter)->pAddress == pAddress )
        {
            break;
        }
    }

    pAddress->Release();

    if ( iter == end )
    {
        pBCC->Release();
        pTerminalSupport->Release();
        return;
    }

    dwSize = (*iter)->pTerminalPtrList->size();
    
    if ( 0 == dwSize )
    {
        pTerminalSupport->Release();
        pBCC->Release();
        return ;
    }

    terminaliter = (*iter)->pTerminalPtrList->begin();
    terminalend  = (*iter)->pTerminalPtrList->end();

    for( ; terminaliter != terminalend ; terminaliter++ )
    {
        ITTerminal * pTerminal;
        
        if ( NULL == (*terminaliter) )
        {
            hr = pTerminalSupport->CreateTerminal(
                bstrTerminalClass,
                (long)LINEMEDIAMODE_VIDEO,
                TD_RENDER,
                &pTerminal
                );
        }
        else
        {
            pTerminal = *terminaliter;
        }

//        hr = pBCC->SelectTerminal( pTerminal );

//        if ( !SUCCEEDED(hr) )
//        {
//        }

    }
    
    hr = pBCC->Answer();

    if ( !SUCCEEDED(hr) )
    {
    }
    
    pBCC->Release();
    pTerminalSupport->Release();
    SysFreeString( bstrTerminalClass );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\confdlg.h ===
#if !defined(AFX_CONFDLG_H)
#define AFX_CONFDLG_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "rend.h"

/////////////////////////////////////////////////////////////////////////////
// CConfDlg dialog

class CConfDlg : public CDialog
{
// Construction
public:
	CConfDlg(CWnd* pParent = NULL);
	enum { IDD = IDD_CONFDLG };
    BSTR       m_bstrDestAddress;
    ITDirectory * m_pDirectory;
    
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void PopulateConferences();
    void ListObjects( ITDirectory * );
    BOOL CConfDlg::OnInitDialog();
    virtual void OnOK();
    afx_msg void OnDestroy();
    DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\adds.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddListen
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddListen( long lMediaType )
{
    WCHAR                   szName[256];
    TV_INSERTSTRUCT         tvi;

    //
    // map the mediatype bstr to
    // a string name (like "audio in")
    //
    GetMediaTypeName(
                     lMediaType,
                     szName
                    );

    //
    // insert that string into the
    // listen window
    //
    tvi.hParent = ghListenRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) lMediaType;
    
    TreeView_InsertItem(
                        ghListenWnd,
                        &tvi
                       );


    //
    // select the first item
    //
    SelectFirstItem(
                    ghListenWnd,
                    ghListenRoot
                   );
}
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddAddressToTree
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddAddressToTree( ITAddress * pAddress )
{
    BSTR                bstrName;
    TV_INSERTSTRUCT     tvi;

    //
    // get the name of the address
    //
    pAddress->get_AddressName( &bstrName );


    //
    // set up struct
    //
    tvi.hParent = ghAddressesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = bstrName;
    tvi.item.lParam = (LPARAM) pAddress;


    //
    // addref
    //
    pAddress->AddRef();

    
    //
    // insert it
    //
    TreeView_InsertItem(
                        ghAddressesWnd,
                        &tvi
                       );

    //
    // free name
    //
    SysFreeString( bstrName );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddMediaType
//
// Add a mediatype to the mediatype tree
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddMediaType( long lMediaType )
{
    WCHAR szString[256];
    TV_INSERTSTRUCT tvi;

    //
    // get the displayable name
    //
    GetMediaTypeName(
                     lMediaType,
                     szString
                    );

    //
    // set up struct
    //
    tvi.hParent = ghMediaTypesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szString;
    tvi.item.lParam = (LPARAM) lMediaType;

    //
    // add the item
    //
    TreeView_InsertItem(
                        ghMediaTypesWnd,
                        &tvi
                       );

    //
    // select the first item
    //
    SelectFirstItem(
                    ghMediaTypesWnd,
                    ghMediaTypesRoot
                   );
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddCall
//
// Add a call to the call tree
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddCall( ITCallInfo * pCall )
{
    TV_INSERTSTRUCT             tvi;
    HTREEITEM                   hItem;
    CALL_PRIVILEGE              cp;
    CALL_STATE                  cs;
    WCHAR                       pszName[16];

    //
    // for the name of the call, use
    // the pointer!
    //
    wsprintf(
             pszName,
             L"0x%lx",
             pCall
            );


    //
    // set up struct
    //
    tvi.hParent = ghCallsRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = pszName;
    tvi.item.lParam = (LPARAM) pCall;

    //
    // save a reference
    //
    pCall->AddRef();

    
    //
    // insert the item
    //
    hItem = TreeView_InsertItem(
                                ghCallsWnd,
                                &tvi
                               );

    if (NULL != hItem)
    {
        //
        // select the item
        //
        TreeView_SelectItem(
                            ghCallsWnd,
                            hItem
                           );
    }

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddTerminal( ITTerminal * pTerminal )
{
    BSTR                    bstrName;
    BSTR                    bstrClass;
    TV_INSERTSTRUCT         tvi;
    TERMINAL_DIRECTION      td;
    WCHAR                   szName[256];

    //
    // get the name of the terminal
    //
    pTerminal->get_Name( &bstrName );

    pTerminal->get_Direction( &td );

    if (td == TD_RENDER)
    {
        wsprintfW(szName, L"%s [Playback]", bstrName);
    }
    else if (td == TD_CAPTURE)
    {
        wsprintfW(szName, L"%s [Record]", bstrName);
    }
    else //if (TD == TD_BOTH)
    {
        lstrcpyW(szName, bstrName);
    }
    
    //
    // set up the structure
    //
    tvi.hParent = ghTerminalsRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) pTerminal;


    //
    // keep a refence to the terminal
    //
    pTerminal->AddRef();

    //
    // add it
    //
    TreeView_InsertItem(
                        ghTerminalsWnd,
                        &tvi
                       );

    //
    // free the name
    //
    SysFreeString( bstrName );


    //
    // select
    //
    SelectFirstItem(
                    ghTerminalsWnd,
                    ghTerminalsRoot
                   );
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddPhone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddPhone( ITPhone * pPhone )
{
    BSTR                    bstrName;
    TV_INSERTSTRUCT         tvi;
    TERMINAL_DIRECTION      td;
    WCHAR                   szName[256];

    //
    // get the name of the phone
    //
    pPhone->get_PhoneCapsString ( PCS_PHONENAME, &bstrName );

    lstrcpyW(szName, bstrName);

    //
    // set up the structure
    //
    tvi.hParent = ghPhonesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) pPhone;


    //
    // keep a refence to the phone
    //
    pPhone->AddRef();

    //
    // add it
    //
    TreeView_InsertItem(
                        ghPhonesWnd,
                        &tvi
                       );

    //
    // free the name
    //
    SysFreeString( bstrName );


    //
    // select
    //
    SelectFirstItem(
                    ghPhonesWnd,
                    ghPhonesRoot
                   );
    
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddTerminalClass
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddTerminalClass( GUID * pguid )
{
    TV_INSERTSTRUCT tvi;
    
    //
    // get the name
    //
    tvi.item.pszText = GetTerminalClassName( pguid );

    //
    // set up the struct
    //
    tvi.hParent = ghClassesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.lParam = (LPARAM) pguid;

    //
    // insert the item
    //
    TreeView_InsertItem(
                        ghClassesWnd,
                        &tvi
                       );

    SysFreeString( tvi.item.pszText );

    //
    // select item
    //
    SelectFirstItem(
                    ghClassesWnd,
                    ghClassesRoot
                   );

}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddCreatedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddCreatedTerminal( ITTerminal * pTerminal )
{
    BSTR                    bstrName;
    TV_INSERTSTRUCT         tvi;


    //
    // get the name
    //
    pTerminal->get_Name( &bstrName );

    //
    // set up the structure
    //
    tvi.hParent = ghCreatedRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;

    if ( ( NULL == bstrName ) || (NULL == bstrName[0] ))
    {
        tvi.item.pszText = L"<No Name Given>";
    }
    else
    {
        tvi.item.pszText = bstrName;
    }

    tvi.item.lParam = (LPARAM) pTerminal;


    //
    // keep reference
    //
    pTerminal->AddRef();

    //
    // insert
    //
    TreeView_InsertItem(
                        ghCreatedWnd,
                        &tvi
                       );

    SysFreeString( bstrName );

    //
    // select
    //
    SelectFirstItem(
                    ghCreatedWnd,
                    ghCreatedRoot
                   );
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddSelectedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddSelectedTerminal(
                                     ITTerminal * pTerminal
                                    )
{
    BSTR bstrName;
    BSTR pMediaType;
    TV_INSERTSTRUCT tvi;
    TERMINAL_DIRECTION td;
    WCHAR szName[256];
    

    //
    // get the name
    //
    pTerminal->get_Name( &bstrName );

    pTerminal->get_Direction( &td );

    if (td == TD_RENDER)
    {
        wsprintfW(szName, L"%s [Playback]", bstrName);
    }
    else if (td == TD_CAPTURE)
    {
        wsprintfW(szName, L"%s [Record]", bstrName);
    }
    else //if (TD == TD_BOTH)
    {
        lstrcpyW(szName, bstrName);
    }
    

    //
    // set up the struct
    //
    tvi.hParent = ghSelectedRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) pTerminal;

    //
    // keep reference
    //
    pTerminal->AddRef();

    //
    // insert item
    //
    TreeView_InsertItem(
                        ghSelectedWnd,
                        &tvi
                       );

    //
    // free name
    //
    SysFreeString( bstrName );


    //
    // select
    //
    SelectFirstItem(
                    ghSelectedWnd,
                    ghSelectedRoot
                   );
    
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddSelectedCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddSelectedCall(
                                     ITCallInfo * pCall
                                    )
{
    TV_INSERTSTRUCT tvi;
    WCHAR pszName[16];
    
    //
    // for the name of the call, use
    // the pointer!
    //
    wsprintf(
             pszName,
             L"0x%lx",
             pCall
            );

    //
    // set up the struct
    //
    tvi.hParent = ghSelectedCallsRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = pszName;
    tvi.item.lParam = (LPARAM) pCall;

    //
    // keep reference
    //
    pCall->AddRef();

    //
    // insert item
    //
    TreeView_InsertItem(
                        ghSelectedCallsWnd,
                        &tvi
                       );


    //
    // select
    //
    SelectFirstItem(
                    ghSelectedCallsWnd,
                    ghSelectedCallsRoot
                   );
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\updates.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateMediaTypes
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateMediaTypes(
                                  ITAddress * pAddress
                                 )
{
    long                    lMediaType;
    ITMediaSupport *        pMediaSupport;
    HRESULT                 hr;
    

    //
    // get the media support interface
    //
    pAddress->QueryInterface(
                             IID_ITMediaSupport,
                             (void **)&pMediaSupport
                            );

    //
    // get the mediatype enumerator
    //
    pMediaSupport->get_MediaTypes(&lMediaType);


    //
    // release the interface
    //
    pMediaSupport->Release();


    gbUpdatingStuff = TRUE;

    
    //
    // go through the supported mediatypes
    //
    DWORD       dwMediaType = 1;
    DWORD       dwHold = (DWORD)lMediaType;

    while (dwMediaType)
    {
        if ( dwMediaType & dwHold )
        {
            AddMediaType( (long) dwMediaType );
        }

        dwMediaType <<=1;
    }


    gbUpdatingStuff = FALSE;

    //
    // select the first
    // media type
    //
    SelectFirstItem(
                    ghMediaTypesWnd,
                    ghMediaTypesRoot
                   );


    //
    // release and redo terminals
    //
    ReleaseTerminals();
    ReleaseTerminalClasses();

    if ( GetMediaType( &lMediaType ) )
    {
        UpdateTerminals( pAddress, lMediaType );
        UpdateTerminalClasses( pAddress, lMediaType );
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateCalls(
                             ITAddress * pAddress
                            )
{
    IEnumCall *             pEnumCall;
    HRESULT                 hr;
    ITCallInfo *            pCallInfo;

    //
    // enumerate the current calls
    //
    pAddress->EnumerateCalls( &pEnumCall );


    //
    // go through the list
    // and add the calls to the tree
    //
    while (TRUE)
    {
        hr = pEnumCall->Next( 1, &pCallInfo, NULL);

        if (S_OK != hr)
        {
            break;
        }

        AddCall(pCallInfo);

        UpdateCall( pCallInfo );

        //
        // release this reference
        //
        pCallInfo->Release();
    }

    pEnumCall->Release();
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateCall
//
// check the call's state and privelege, and update the call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateCall( ITCallInfo * pCall )
{
    HTREEITEM               hItem, hParent;
    TV_ITEM                 item;
    CALL_PRIVILEGE          cp;
    CALL_STATE              cs;
    TV_INSERTSTRUCT         tvi;
    

    //
    // get the first call
    //
    item.mask = TVIF_HANDLE | TVIF_PARAM;
    
    
    hItem = TreeView_GetChild(
                              ghCallsWnd,
                              ghCallsRoot
                             );

    //
    // go through all the calls
    // and look for the one that matches
    // the one passed in
    //
    while (NULL != hItem)
    {
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghCallsWnd,
                         &item
                        );

        if ( item.lParam == (LPARAM)pCall )
        {
            break;
        }

        hItem = TreeView_GetNextSibling(
                                        ghCallsWnd,
                                        hItem
                                       );
    }

    //
    // did we find it?
    //
    if (NULL == hItem)
    {
        return;
    }

    
    hParent = hItem;

    //
    // delete the current children of the call
    // node (these are the old privelege and state
    //
    hItem = TreeView_GetChild(
                              ghCallsWnd,
                              hItem
                             );

    
    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                           ghCallsWnd,
                                           hItem
                                          );

        TreeView_DeleteItem(
                            ghCallsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

    tvi.hInsertAfter = TVI_LAST;

    //
    // get the current privilege
    //
    tvi.item.pszText = GetCallPrivilegeName( pCall );

    //
    // add it as a child of the
    // call node
    //
    tvi.hParent = hParent;
    tvi.item.mask = TVIF_TEXT;

    TreeView_InsertItem(
                        ghCallsWnd,
                        &tvi
                       );

    SysFreeString( tvi.item.pszText );
    
    //
    // get the current callstate
    //
    tvi.item.pszText = GetCallStateName( pCall );
    
    //
    // add it as a child of the call
    // node
    //
    tvi.hParent = hParent;
    tvi.item.mask = TVIF_TEXT;

    TreeView_InsertItem(
                        ghCallsWnd,
                        &tvi
                       );

    SysFreeString( tvi.item.pszText );

    
}


void CT3testDlg::UpdateTerminals(
                                 ITAddress * pAddress,
                                 long lMediaType
                                )
{
    ITTerminalSupport *     pTerminalSupport;
    IEnumTerminal *         pEnumTerminals;
    HRESULT                 hr;
    ITTerminal *            pTerminal;
    
    
    //
    // get the terminalsupport interface
    //
    hr = pAddress->QueryInterface(
                             IID_ITTerminalSupport,
                             (void **) &pTerminalSupport
                            );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    //
    // enumerate the terminals
    //
    pTerminalSupport->EnumerateStaticTerminals( &pEnumTerminals );

    //
    // go through the terminals
    //
    while (TRUE)
    {
        VARIANT_BOOL        bSupport;
        BSTR                bstr;
        long                l;

        
        hr = pEnumTerminals->Next( 1, &pTerminal, NULL);

        if (S_OK != hr)
        {
            break;
        }

        //
        // get the name
        //
        hr = pTerminal->get_Name( &bstr );

        //
        // if it's a unimodem or a direct sound
        // device don't show it, cause they bother
        // me
        //
        if (wcsstr( bstr, L"Voice Modem" ) || wcsstr( bstr, L"ds:" ) )
        {
            pTerminal->Release();
            SysFreeString( bstr );
            
            continue;
        }

        //
        // free the name
        //
        SysFreeString( bstr );

        //
        // get the mediatype of the terminal
        //
        pTerminal->get_MediaType( &l );

        //
        // if it's the same as the selected mediatype
        // show it
        //
        if ( l == lMediaType )
        {
            AddTerminal(pTerminal);
        }

        //
        // release
        //
        pTerminal->Release();
    }

    //
    // release enumerator
    //
    pEnumTerminals->Release();

    //
    // release
    //
    pTerminalSupport->Release();

    //
    // select
    //
    SelectFirstItem(
                    ghTerminalsWnd,
                    ghTerminalsRoot
                   );

}


void CT3testDlg::UpdateTerminalClasses(
                                       ITAddress * pAddress,
                                       long lMediaType
                                      )
{
    IEnumTerminalClass *        pEnumTerminalClasses;
    HRESULT                     hr;
    ITTerminalSupport *         pTerminalSupport;

    hr = pAddress->QueryInterface(
                             IID_ITTerminalSupport,
                             (void **)&pTerminalSupport
                            );


    if (!SUCCEEDED(hr))
    {
        return;
    }
    
    //
    // now enum dymnamic
    //
    hr = pTerminalSupport->EnumerateDynamicTerminalClasses( &pEnumTerminalClasses );

    if (S_OK == hr)
    {
        
        //
        // go through all the classes
        //
        while (TRUE)
        {
            GUID *                  pDynTerminalClass = new GUID;

            hr = pEnumTerminalClasses->Next(
                                            1,
                                            pDynTerminalClass,
                                            NULL
                                           );

            if (S_OK != hr)
            {
                delete pDynTerminalClass;
                break;
            }

            //
            // manually match up mediatype and
            // class
            //
            if ( (lMediaType == (long)LINEMEDIAMODE_VIDEO) &&
                 (*pDynTerminalClass == CLSID_VideoWindowTerm) )
            {

                AddTerminalClass(
                                 pDynTerminalClass
                                );
            }

#ifdef ENABLE_DIGIT_DETECTION_STUFF
            else if ( (lMediaType == (long)LINEMEDIAMODE_AUTOMATEDVOICE) &&
                      ( *pDynTerminalClass == CLSID_DigitTerminal ) )
            {
                AddTerminalClass(
                                 pDynTerminalClass
                                );
            }
            else if ( ((lMediaType == (long)LINEMEDIAMODE_DATAMODEM) ||
                       (lMediaType == (long)LINEMEDIAMODE_G3FAX)) &&
                      (*pDynTerminalClass == CLSID_DataTerminal) )
            {
                AddTerminalClass( pDynTerminalClass );
            }
#endif // ENABLE_DIGIT_DETECTION_STUFF


            else
            {
                delete pDynTerminalClass;
            }

        }

        //
        // release enumerator
        //
        pEnumTerminalClasses->Release();

    }
    
    //
    // release this interface
    //
    pTerminalSupport->Release();
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\t3testd.cpp ===
// t3testDlg.cpp : implementation file
//

#include "stdafx.h"

#include <control.h> // for IVideoWindow

#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "uuids.h"
#include "autoans.h"
#include "confdlg.h"
#include "ilsdlg.h"
#include "rate.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

ITTAPI * gpTapi;
IConnectionPoint * gpCP;
HWND ghAddressesWnd;
HWND ghTerminalsWnd;
HWND ghMediaTypesWnd;
HWND ghCallsWnd;
HWND ghSelectedWnd;
HWND ghCreatedWnd;
HWND ghClassesWnd;
HWND ghListenWnd;
HTREEITEM ghAddressesRoot;
HTREEITEM ghTerminalsRoot;
HTREEITEM ghMediaTypesRoot;
HTREEITEM ghCallsRoot;
HTREEITEM ghSelectedRoot;
HTREEITEM ghCreatedRoot;
HTREEITEM ghClassesRoot;
HTREEITEM ghListenRoot;

#ifdef ENABLE_DIGIT_DETECTION_STUFF
CDigitDetectionNotification *   gpDigitNotification;
#endif // ENABLE_DIGIT_DETECTION_STUFF

long       gulAdvise;
BOOL gbUpdatingStuff = FALSE;
BOOL gfShuttingDown = FALSE;

DataPtrList       gDataPtrList;
extern CT3testApp theApp;

const BSTR TAPIMEDIATYPE_String_Audio = L"{028ED8C2-DC7A-11D0-8ED3-00C04FB6809F}";
const BSTR TAPIMEDIATYPE_String_Video = L"{028ED8C4-DC7A-11D0-8ED3-00C04FB6809F}";

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CT3testDlg dialog

CT3testDlg::CT3testDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CT3testDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CT3testDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CT3testDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CT3testDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CT3testDlg, CDialog)
	//{{AFX_MSG_MAP(CT3testDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_DESTROY()
	ON_NOTIFY(TVN_SELCHANGED, IDC_ADDRESSES, OnSelchangedAddresses)
	ON_BN_CLICKED(IDC_ADDTERMINAL, OnAddterminal)
	ON_BN_CLICKED(IDC_REMOVETERMINAL, OnRemoveterminal)
	ON_BN_CLICKED(IDC_CREATECALL, OnCreatecall)
	ON_BN_CLICKED(IDC_CONNECT, OnConnect)
	ON_BN_CLICKED(IDC_DROP, OnDrop)
	ON_BN_CLICKED(IDC_ANSWER, OnAnswer)
	ON_BN_CLICKED(IDC_LISTEN, OnListen)
	ON_NOTIFY(TVN_SELCHANGED, IDC_CALLS, OnSelchangedCalls)
	ON_BN_CLICKED(IDC_RELEASE, OnRelease)
	ON_BN_CLICKED(IDC_CREATE, OnCreateTerminal)
	ON_BN_CLICKED(IDC_RELEASETERMINAL, OnReleaseterminal)
	ON_BN_CLICKED(IDC_ADDCREATED, OnAddcreated)
	ON_BN_CLICKED(IDC_ADDNULL, OnAddnull)
	ON_BN_CLICKED(IDC_ADDTOLISTEN, OnAddtolisten)
	ON_BN_CLICKED(IDC_LISTENALL, OnListenall)
    ON_BN_CLICKED(IDC_CONFIGAUTOANSWER, OnConfigAutoAnswer)
    ON_BN_CLICKED(IDC_ILS, OnILS)
    ON_BN_CLICKED(IDC_RATE, OnRate)
	ON_NOTIFY(TVN_SELCHANGED, IDC_MEDIATYPES, OnSelchangedMediatypes)
	ON_NOTIFY(NM_RCLICK, IDC_SELECTEDTERMINALS, OnRclickSelectedterminals)

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    ON_COMMAND(ID_GENERATE, OnGenerate)
    ON_COMMAND(ID_MODESUPPORTED, OnModesSupported)
    ON_COMMAND(ID_MODESUPPORTED2, OnModesSupported2)
    ON_COMMAND(ID_STARTDETECT, OnStartDetect)
    ON_COMMAND(ID_STOPDETECT, OnStopDetect)
#endif // ENABLE_DIGIT_DETECTION_STUFF
    
    ON_COMMAND(ID_PARK1, OnPark1)
    ON_COMMAND(ID_PARK2, OnPark2)
    ON_COMMAND(ID_HANDOFF1, OnHandoff1)
    ON_COMMAND(ID_HANDOFF2, OnHandoff2)
    ON_COMMAND(ID_UNPARK, OnUnpark)
    ON_COMMAND(ID_PICKUP1, OnPickup1)
    ON_COMMAND(ID_PICKUP2, OnPickup2)

    ON_WM_CLOSE()
    ON_MESSAGE(WM_USER+101, OnTapiEvent)
	ON_NOTIFY(NM_RCLICK, IDC_CALLS, OnRclickCalls)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CT3testDlg message handlers

BOOL CT3testDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

    HRESULT     hr;


    //
    // coinit
    //
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    //hr = CoInitialize(NULL);

    if (hr != S_OK)
    {
        MessageBox(L"CoInitialize failed", MB_OK);

        return FALSE;
    }


    //
    // create the tapi object
    //
    hr = CoCreateInstance(
        CLSID_TAPI,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITTAPI,
        (LPVOID *)&gpTapi
        );

    if (hr != S_OK)
    {
        ::MessageBox(NULL, L"CoCreateInstance on TAPI failed", NULL, MB_OK);
        return TRUE;
    }

    //
    // initialize tapi
    //
    hr = gpTapi->Initialize();

    if (hr != S_OK)
    {
        ::MessageBox(NULL, L"TAPI initialize failed", NULL, MB_OK);
        gpTapi->Release();
        return TRUE;
    }


    // Set the Event filter to only give us only the events we process
    gpTapi->put_EventFilter(TE_CALLNOTIFICATION | \
                            TE_CALLSTATE        | \
                            TE_CALLHUB          | \
                            TE_CALLMEDIA        | \
                            TE_TAPIOBJECT       | \
                            TE_ADDRESS);

    //
    // intialize the tree controls
    //
    InitializeTrees();

    //
    // intialize the address tree control
    //
    InitializeAddressTree();

    //
    // register the main event interface
    //
    RegisterEventInterface();

    //
    // register for call notification for
    // all addresses for outgoing calls
    //
    RegisterForCallNotifications();
    
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CT3testDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CT3testDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CT3testDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CT3testDlg::OnFinalRelease() 
{
	// TODO: Add your specialized code here and/or call the base class

	CDialog::OnFinalRelease();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SelectFirstItem
//
// selects the first item under the hroot node in hwnd.
// this is used to make sure that something is selected
// in the window at all times.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::SelectFirstItem(
                                 HWND        hWnd,
                                 HTREEITEM   hRoot
                                )
{
    HTREEITEM           hChild;


    //
    // get the first item
    //
    hChild = TreeView_GetChild(
                               hWnd,
                               hRoot
                              );

    //
    // select it
    //
    TreeView_SelectItem(
                        hWnd,
                        hChild
                       );

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// DeleteSelectedItem
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::DeleteSelectedItem(
                                    HWND hWnd
                                   )
{
    HTREEITEM           hItem;

    //
    // get current selections
    // 
    hItem = TreeView_GetSelection( hWnd );


    //
    // delete it
    //
    TreeView_DeleteItem(
                        hWnd,
                        hItem
                       );
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//  InitializeAddressTree
//      initialize the address tree control with
//      the address objects
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::InitializeAddressTree()
{
    IEnumAddress *      pEnumAddress;
    ITAddress *         pAddress;
    HTREEITEM           hChild;
    HRESULT             hr;
    long                l;
    DWORD               dwCount = 0;
    
    //
    // get the address enumerator
    //
    
    hr = gpTapi->EnumerateAddresses( &pEnumAddress );

    if (S_OK != hr)
    {
        gpTapi->Release();
        gpTapi = NULL;

        return;
    }

    //
    // go through all the address objects
    // and add them to the address treecontrol
    //

    while (TRUE)
    {
        AADATA * pData;
        
        hr = pEnumAddress->Next( 1, &pAddress, NULL );

        if (S_OK != hr)
        {
            break;
        }

        AddAddressToTree( pAddress );

        pAddress->Release();

        pData = (AADATA *)CoTaskMemAlloc( sizeof ( AADATA ) );
        pData->pAddress = pAddress;
        pData->pTerminalPtrList = new TerminalPtrList;
        
        gDataPtrList.push_back( pData );

        dwCount++;
    }

    //
    // release the enumerator
    //
    pEnumAddress->Release();

    //
    // select the first item
    //
    if (dwCount > 0)
    {
        SelectFirstItem(
                        ghAddressesWnd,
                        ghAddressesRoot
                       );
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// RegisterEventInterface
//
// registers the ITTAPIEventNotification interface
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CT3testDlg::RegisterEventInterface()
{
    CTAPIEventNotification *        pTAPIEventNotification;
    IConnectionPointContainer *     pCPC;
    IConnectionPoint *              pCP;
    IUnknown *                      pUnk;
    
    //
    // create the object
    //
    pTAPIEventNotification = new CTAPIEventNotification;


    //
    // get the connectionpointcontainer interface
    // from the tapi object
    //
    gpTapi->QueryInterface(
                           IID_IConnectionPointContainer,
                           (void **) &pCPC
                          );


    //
    // get the connectionpoint we are
    // looking for
    //
    pCPC->FindConnectionPoint(
                              IID_ITTAPIEventNotification,
                              &gpCP
                             );

    pCPC->Release();

    pTAPIEventNotification->QueryInterface(
                                           IID_IUnknown,
                                           (void **)&pUnk
                                          );

    //
    // call the advise method to tell tapi
    // about the interface
    //
    gpCP->Advise(
                 pUnk,
                 (ULONG *)&gulAdvise
                );


    //
    // release our reference to
    // it
    //
    pUnk->Release();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RegisterForCallNotifications
//
// registers for call state notifications for all
// addresses for outgoing calls
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::RegisterForCallNotifications()
{
    VARIANT                 var;

    var.vt = VT_ARRAY;
    var.parray = NULL;
    
    gpTapi->SetCallHubTracking(var, VARIANT_TRUE);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// InitializeTrees
//
// Create and labels the tree controls
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::InitializeTrees()
{
    TV_INSERTSTRUCT tvi;

    tvi.hParent = TVI_ROOT;
    tvi.hInsertAfter = TVI_FIRST;
    tvi.item.mask = TVIF_TEXT;

    //
    // address tree
    //
    tvi.item.pszText = L"Addresses";

    ghAddressesWnd = GetDlgItem( IDC_ADDRESSES )->m_hWnd;
    ghAddressesRoot = TreeView_InsertItem(
                                          ghAddressesWnd,
                                          &tvi
                                         );

    //
    // mediatypes tree
    //
    tvi.item.pszText = L"MediaTypes";

    ghMediaTypesWnd = GetDlgItem( IDC_MEDIATYPES )->m_hWnd;
    ghMediaTypesRoot = TreeView_InsertItem(
                                          ghMediaTypesWnd,
                                          &tvi
                                         );

    //
    // terminals tree
    //
    tvi.item.pszText = L"Terminals";

    ghTerminalsWnd = GetDlgItem( IDC_TERMINALS )->m_hWnd;
    ghTerminalsRoot = TreeView_InsertItem(
                                          ghTerminalsWnd,
                                          &tvi
                                         );

    //
    // calls tree
    //
    tvi.item.pszText = L"Calls";
    
    ghCallsWnd = GetDlgItem( IDC_CALLS )->m_hWnd;
    ghCallsRoot = TreeView_InsertItem(
                                      ghCallsWnd,
                                      &tvi
                                     );

    //
    // selected media terminals tree
    //
    tvi.item.pszText = L"Selected Media Terminals";
    
    ghSelectedWnd = GetDlgItem( IDC_SELECTEDTERMINALS )->m_hWnd;
    ghSelectedRoot = TreeView_InsertItem(
                                        ghSelectedWnd,
                                        &tvi
                                       );

    //
    // dynamic terminal classes tree
    //
    tvi.item.pszText = L"Dynamic Terminal Classes";
    
    ghClassesWnd = GetDlgItem( IDC_DYNAMICCLASSES )->m_hWnd;
    ghClassesRoot = TreeView_InsertItem(
                                        ghClassesWnd,
                                        &tvi
                                       );

    //
    // created terminals tree
    //
    tvi.item.pszText = L"Created Terminals";
    
    ghCreatedWnd = GetDlgItem( IDC_CREATEDTERMINALS )->m_hWnd;
    ghCreatedRoot = TreeView_InsertItem(
                                        ghCreatedWnd,
                                        &tvi
                                       );

    //
    // listen mediatypes tree
    //
    tvi.item.pszText = L"Listen MediaTypes";
    
    ghListenWnd = GetDlgItem( IDC_LISTENMEDIAMODES )->m_hWnd;
    ghListenRoot = TreeView_InsertItem(
                                       ghListenWnd,
                                       &tvi
                                      );
    
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnDestroy
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnDestroy() 
{
	CDialog::OnDestroy();

    gfShuttingDown = TRUE;

    //
    // Release everything
    //
    ReleaseMediaTypes();
    ReleaseTerminals();
    ReleaseCalls();
    ReleaseSelectedTerminals();
    ReleaseCreatedTerminals();
    ReleaseTerminalClasses();
    ReleaseListen();
    ReleaseAddresses();

    DataPtrList::iterator       iter, end;

    iter = gDataPtrList.begin();
    end  = gDataPtrList.end();
    
    for( ; iter != end; iter++ )
    {
        FreeData( *iter );

        delete (*iter)->pTerminalPtrList;
        
        CoTaskMemFree( *iter );
    }

    gDataPtrList.clear();
    

    if (NULL != gpCP)
    {
        gpCP->Unadvise(gulAdvise);
        gpCP->Release();
    }
    
    //
    // shutdown TAPI
    //
    if (NULL != gpTapi)
    {
        gpTapi->Shutdown();
        gpTapi->Release();
    }

}

void
DoAddressCapStuff(ITTAPI * pTapi);
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedAddresses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedAddresses(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW*            pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    ITAddress *             pAddress;


	*pResult = 0;


    //
    // free all the stuff related to
    // the address selected.  this stuff
    // will all be refilled in
    //
    ReleaseMediaTypes();
    ReleaseListen();
    ReleaseCalls();
    ReleaseSelectedTerminals();
    ReleaseCreatedTerminals();
    

    //
    // get the currently selected address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }

    //
    // update these trees
    //
    if ( !gfShuttingDown )
    {
        UpdateMediaTypes( pAddress );
        UpdateCalls( pAddress );
    }
}

/////////////////////////////////////////////////////////////////
// IsVideoCaptureStream
//
// Returns true if the stream is for video capture
/////////////////////////////////////////////////////////////////

BOOL
CT3testDlg::IsVideoCaptureStream(
                     ITStream * pStream
                    )
{
    TERMINAL_DIRECTION tdStreamDirection;
    long               lStreamMediaType;

    if ( FAILED( pStream  ->get_Direction(&tdStreamDirection)   ) ) { return FALSE; }
    if ( FAILED( pStream  ->get_MediaType(&lStreamMediaType)    ) ) { return FALSE; }

    return (tdStreamDirection == TD_CAPTURE) &&
           (lStreamMediaType  == TAPIMEDIATYPE_VIDEO);
}

/////////////////////////////////////////////////////////////////
// EnablePreview
//
// Selects a video render terminal on a video capture stream,
// thereby enabling video preview.
/////////////////////////////////////////////////////////////////

HRESULT
CT3testDlg::EnablePreview(
              ITStream * pStream
             )
{
    ITTerminal * pTerminal;

    HRESULT hr = GetVideoRenderTerminal(&pTerminal);

    if ( SUCCEEDED(hr) )
    {
        hr = pStream->SelectTerminal(pTerminal);

        pTerminal->Release();
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SelectTerminalOnCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT
CT3testDlg::SelectTerminalOnCall(
                ITTerminal * pTerminal,
                ITCallInfo * pCall
               )
{
    ITStreamControl *       pStreamControl;
    TERMINAL_DIRECTION      termtd;
    long                    lTermMediaType;
    HRESULT hr;

    pTerminal->get_Direction( &termtd );
    pTerminal->get_MediaType( &lTermMediaType );
    
    hr = pCall->QueryInterface(
                               IID_ITStreamControl,
                               (void**) &pStreamControl
                              );

    if ( SUCCEEDED(hr) )
    {
        IEnumStream * pEnumStreams;
        
        hr = pStreamControl->EnumerateStreams( &pEnumStreams );

        if ( SUCCEEDED(hr) )
        {
            while (TRUE)
            {
                ITStream              * pStream;
                long                    lMediaType;
                TERMINAL_DIRECTION      td;
                
                hr = pEnumStreams->Next( 1, &pStream, NULL );

                if ( S_OK != hr )
                {
                    hr = E_FAIL; // didn't select it anywhere
                    break;
                }

                pStream->get_MediaType( &lMediaType );
                pStream->get_Direction( &td );

                if ( ( lMediaType == lTermMediaType ) &&
                     ( td == termtd) )
                {
                    hr = pStream->SelectTerminal( pTerminal );

                    if ( FAILED(hr) )
                    {
                        ::MessageBox(NULL, L"SelectTerminals failed", NULL, MB_OK);
                    }
                    else
                    {
                        //
                        // Also enable preview on the video capture stream.
                        //

                        if ( IsVideoCaptureStream( pStream ) )
                        {
                            EnablePreview( pStream );
                        }

                        pStream->Release();
                        
                        break;
                    }
                }
                
                pStream->Release();
            }

            pEnumStreams->Release();
        }

        pStreamControl->Release();
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::OnAddterminal() 
{
    ITCallInfo *            pCall;
    ITTerminal *            pTerminal;
    HRESULT                 hr = S_OK;

    //
    // get the selected call
    //
    if (!(GetCall( &pCall )))
    {
        return;
    }


    //
    // get the selected terminal
    //
    if (!(GetTerminal( &pTerminal )))
    {
        return;
    }

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"SelectTerminals failed", NULL, MB_OK);
        return;
    }
        
    hr = SelectTerminalOnCall(pTerminal, pCall);

    if ( FAILED(hr) )
    {
        return;
    }

    //
    // put the terminal in the
    // tree
    //
    AddSelectedTerminal(
                        pTerminal
                       );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RemovePreview
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::RemovePreview( ITStream * pStream )
{
    //
    // This is a video capture stream and we've unselected the
    // video capture terminal. If there is a video render
    // terminal on the stream, then unselect it now.
    //

    IEnumTerminal * pEnum;

    if ( FAILED( pStream->EnumerateTerminals( &pEnum ) ) )
    {
        return;
    }

    ITTerminal * pTerminal;

    if ( S_OK == pEnum->Next(1, &pTerminal, NULL) )
    {
        pStream->UnselectTerminal( pTerminal );
        pTerminal->Release();
    }

    pEnum->Release();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnRemoveTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnRemoveterminal() 
{
    ITTerminal *                pTerminal;
    ITCallInfo *                pCall;
    HTREEITEM                   hItem;
    HRESULT                     hr;
    ITBasicCallControl *        pBCC;

    

    //
    // get current call
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    //
    // get current terminal
    //
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    TERMINAL_DIRECTION termtd;
    long               lTermMediaType;

    pTerminal->get_Direction( &termtd );
    pTerminal->get_MediaType( &lTermMediaType );

    ITStreamControl * pStreamControl;
    
    hr = pCall->QueryInterface(
                               IID_ITStreamControl,
                               (void**) &pStreamControl
                              );

    BOOL bFound = FALSE;

    if ( SUCCEEDED(hr) )
    {
        IEnumStream * pEnumStreams;
        
        hr = pStreamControl->EnumerateStreams( &pEnumStreams );

        if ( SUCCEEDED(hr) )
        {
            while ( ! bFound )
            {
                ITStream              * pStream;
                long                    lMediaType;
                TERMINAL_DIRECTION      td;
                
                hr = pEnumStreams->Next( 1, &pStream, NULL );

                if ( S_OK != hr )
                {
                    break;
                }

                pStream->get_MediaType( &lMediaType );
                pStream->get_Direction( &td );

                if ( ( lMediaType == lTermMediaType ) &&
                     ( td == termtd) )
                {
                    hr = pStream->UnselectTerminal( pTerminal );

                    if ( !SUCCEEDED(hr) )
                    {
                        ::MessageBox(NULL, L"UnselectTerminals failed", NULL, MB_OK);
                    }
                    else
                    {
                        if ( IsVideoCaptureStream( pStream ) )
                        {
                            RemovePreview( pStream );
                        }

                        bFound = TRUE;
                    }

                }
                
                pStream->Release();
            }

            pEnumStreams->Release();
        }

        pStreamControl->Release();
    }


    if ( !bFound )
    {
        return;
    }

    //
    // remove it from tree
    //
    hItem = TreeView_GetSelection( ghSelectedWnd );
    TreeView_DeleteItem(
                        ghSelectedWnd,
                        hItem
                       );


    //
    // release tree's reference to
    // the terminal
    //
    pTerminal->Release();

	
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnCreateCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnCreatecall() 
{
    ITAddress *             pAddress;
    HRESULT                 hr;
    ITBasicCallControl *    pCall;
    ITCallInfo *            pCallInfo;
    BOOL                    bConference      = FALSE;
    BOOL                    lAddressType     = LINEADDRESSTYPE_PHONENUMBER;
    BSTR                    bstrDestAddress;
    ITAddressCapabilities * pAddressCaps;
    long                    lType = 0;
    ITMediaSupport *        pMediaSupport;
    long                    lSupportedMediaTypes, lMediaTypes = 0;
    
    //
    // get the current address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }


    hr = pAddress->QueryInterface(IID_ITAddressCapabilities, (void**)&pAddressCaps);

    hr = pAddressCaps->get_AddressCapability( AC_ADDRESSTYPES, &lType );

    if ( SUCCEEDED(hr) && (LINEADDRESSTYPE_SDP & lType) )
    {
        bConference = TRUE;
        lAddressType = LINEADDRESSTYPE_SDP;
    }

    if ( SUCCEEDED(hr) && (LINEADDRESSTYPE_DOMAINNAME & lType) )
    {
        lAddressType = LINEADDRESSTYPE_DOMAINNAME;
    }

    pAddressCaps->Release();
    
    if ( !bConference )
    {
        //
        // create the dialog to get the
        // dial string
        //
        CCreateCallDlg Dlg( this );


        if (IDOK == Dlg.DoModal())
        {
            //
            // create a call with the
            // string input in the dialog
            //
            bstrDestAddress = SysAllocString( Dlg.m_pszDestAddress );
        }
        else
        {
            return;
        }
    }
    else
    {
        CConfDlg    Dlg;

        if ( IDOK == Dlg.DoModal() )
        {
            bstrDestAddress = Dlg.m_bstrDestAddress;
        }
        else
        {
            return;
        }
    }

    //
    // Find out if the address supports audio, video, or both.
    //

    pAddress->QueryInterface(
                             IID_ITMediaSupport,
                             (void**)&pMediaSupport
                            );

    pMediaSupport->get_MediaTypes( &lSupportedMediaTypes );
                                  
    pMediaSupport->Release();


    if ( lSupportedMediaTypes & TAPIMEDIATYPE_AUDIO )
    {
        lMediaTypes |= TAPIMEDIATYPE_AUDIO;
    }

    if ( lSupportedMediaTypes & TAPIMEDIATYPE_VIDEO )
    {
        lMediaTypes |= TAPIMEDIATYPE_VIDEO;
    }

    if ( lMediaTypes == 0 )
    {
        if ( lSupportedMediaTypes & TAPIMEDIATYPE_DATAMODEM )
        {
            lMediaTypes |= TAPIMEDIATYPE_DATAMODEM;
        }
    }

    //
    // Create the call.
    //

    hr = pAddress->CreateCall(
                              bstrDestAddress,
                              lAddressType,
                              lMediaTypes,
                              &pCall
                             );

    SysFreeString( bstrDestAddress );


    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"CreateCall failed", NULL, MB_OK);
        return;
    }

    //
    // get the callinfo interface
    //
    pCall->QueryInterface( IID_ITCallInfo, (void **)&pCallInfo );


    //
    // add the call to the tree
    //
    AddCall(pCallInfo);

    //
    // update the callinfo
    //
    UpdateCall( pCallInfo );


    //
    // release this inteface
    //
    pCallInfo->Release();

    //
    // note that we keep a global reference to the call
    // (CreateCall returns with a reference count of 1)
    // so the call does not get destroyed.  When we want
    // the call to actually be destroyed, then we
    // release twice.
    //
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnConnect
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnConnect() 
{
    ITBasicCallControl *            pCall;
    ITCallInfo *                    pCallInfo;
    HRESULT                         hr = S_OK;


    //
    // get the current call
    //
    if (!GetCall( &pCallInfo))
    {
        return;
    }

    //
    // get the call control interface
    //
    hr = pCallInfo->QueryInterface(IID_ITBasicCallControl, (void **)&pCall);
    
    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Connect failed", NULL, MB_OK);
        return;
    }


    //
    // call connect
    //
    hr = pCall->Connect( FALSE );


    //
    // release this interface
    //
    pCall->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Connect failed", NULL, MB_OK);
        return;
    }
	
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnDrop
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnDrop() 
{
    ITBasicCallControl *        pCall;
    ITCallInfo *                pCallInfo;
    HRESULT                     hr =    S_OK;


    //
    // get the current call
    //
    if (!GetCall( &pCallInfo ))
    {
        return;
    }

    //
    // get the bcc interface
    //
    hr = pCallInfo->QueryInterface(
                                   IID_ITBasicCallControl,
                                   (void **)&pCall
                                  );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Disconnect failed", NULL, MB_OK);
        return;
    }


    //
    // call disconnect
    //
    hr = pCall->Disconnect( DC_NORMAL );

    //
    // release this reference
    //
    pCall->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Disconnect failed", NULL, MB_OK);
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnDrop
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnAnswer() 
{
    ITCallInfo *                pCallInfo;
    ITBasicCallControl *        pCall;
    HRESULT                     hr = S_OK;


    //
    // get the current call
    //
    if (!GetCall( &pCallInfo))
    {
        return;
    }

    //
    // get the bcc interface
    //
    hr = pCallInfo->QueryInterface(IID_ITBasicCallControl, (void **)&pCall);
    
    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Answer failed", NULL, MB_OK);
        return;
    }

    //
    // answer it
    //
    hr = pCall->Answer( );

    //
    // release this interface
    //
    pCall->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Answer failed", NULL, MB_OK);
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnListen
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnListen() 
{
    ITAddress *             pAddress;
    HRESULT                 hr = S_OK;
    DWORD                   dwCookie;
    HTREEITEM               hItem;
    long                    ulRegister;
    DWORD                   dwMediaMode = 0;


    //
    // get the current address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }


    hItem = TreeView_GetChild(
                              ghListenWnd,
                              ghListenRoot
                             );

    while (NULL != hItem)
    {
        TV_ITEM item;

        item.mask = TVIF_HANDLE | TVIF_PARAM;
        item.hItem = hItem;

        //
        // get it
        //
        TreeView_GetItem(
                         ghListenWnd,
                         &item
                        );

        dwMediaMode |= (DWORD)(item.lParam);

        hItem = TreeView_GetNextSibling(
                                        ghAddressesWnd,
                                        hItem
                                       );

    }

    hr = gpTapi->RegisterCallNotifications(
                                           pAddress,
                                           VARIANT_TRUE,
                                           VARIANT_TRUE,
                                           (long)dwMediaMode,
                                           gulAdvise,
                                           &ulRegister
                                          );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"RegisterCallNotifications failed", NULL, MB_OK);
    }

    //
    // release all the mediatypes
    // in the listen tree
    //
    ReleaseListen();
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedCalls(NMHDR* pNMHDR, LRESULT* pResult) 
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnRelease()
//
// this is called to release all references to a call
//
// if a call is selected it has two references - once for
// the tree control, and once for our global reference.
// release both here.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnRelease() 
{
    ITCallInfo *        pCallInfo;


    //
    // get the call
    //
    if (!GetCall( &pCallInfo ))
    {
        return;
    }

    //
    // these depend on the call,
    // so release them
    //
    ReleaseSelectedTerminals();
    ReleaseCreatedTerminals();

    //
    // delete it from the tree
    //
    DeleteSelectedItem(
                       ghCallsWnd
                      );

    //
    // release once for the tree view
    //
    pCallInfo->Release();

    //
    // release a second time for our global reference
    //
    pCallInfo->Release();

}

void
CT3testDlg::HelpCreateTerminal(
                               ITTerminalSupport * pTerminalSupport,
                               BSTR bstrClass,
                               long lMediaType,
                               TERMINAL_DIRECTION dir
                              )
{
    ITTerminal * pTerminal;
    HRESULT         hr;
    
    //
    // create it
    //
    hr = pTerminalSupport->CreateTerminal(
                                          bstrClass,
                                          lMediaType,
                                          dir,
                                          &pTerminal
                                         );

    if (S_OK != hr)
    {
        return;
    }

    // 
    // ZoltanS:
    // We do nothing special with our video windows. Just make them visible
    // all the time. If this isn't a video window we just skip this step.
    //

    IVideoWindow * pWindow;

    if ( SUCCEEDED( pTerminal->QueryInterface(IID_IVideoWindow,
                                              (void **) &pWindow) ) )
    {
        pWindow->put_AutoShow( VARIANT_TRUE );

        pWindow->Release();
    }


    //
    // add the terminal
    //
    AddCreatedTerminal(
                       pTerminal
                      );


    //
    // release our reference
    //
    pTerminal->Release();    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetVideoRenderTerminal
//
// this is used to create a video render terminal for preview
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT CT3testDlg::GetVideoRenderTerminal(ITTerminal ** ppTerminal) 
{
    //
    // Get the current address
    //

    ITAddress * pAddress;

    if (!GetAddress( &pAddress ))
    {
        return E_FAIL;
    }

    //
    // get the terminal support interface
    //

    ITTerminalSupport * pTerminalSupport;
    HRESULT hr;

    hr = pAddress->QueryInterface(
                                  IID_ITTerminalSupport,
                                  (void **) &pTerminalSupport
                                 );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Construct a BSTR for the correct IID.
    //

    LPOLESTR            lpTerminalClass;

    hr = StringFromIID(CLSID_VideoWindowTerm,
                       &lpTerminalClass);

    BSTR                bstrTerminalClass;

    if ( FAILED(hr) )
    {
        pTerminalSupport->Release();
        return hr;
    }

    bstrTerminalClass = SysAllocString ( lpTerminalClass );

    CoTaskMemFree( lpTerminalClass );

    if ( bstrTerminalClass == NULL )
    {
        pTerminalSupport->Release();
        return E_OUTOFMEMORY;
    }
    
    //
    // create it
    //

    hr = pTerminalSupport->CreateTerminal(
                                          bstrTerminalClass,
                                          TAPIMEDIATYPE_VIDEO,
                                          TD_RENDER,
                                          ppTerminal
                                         );

    pTerminalSupport->Release();

    if ( FAILED(hr) )
    {
        *ppTerminal = NULL;
        return hr;
    }

    // 
    // We do nothing special with our video windows. Just make them visible
    // all the time.
    //

    IVideoWindow * pWindow;

    if ( FAILED( (*ppTerminal)->QueryInterface(IID_IVideoWindow,
                                               (void **) &pWindow) ) )
    {
        (*ppTerminal)->Release();
        *ppTerminal = NULL;

        return hr;
    }

    pWindow->put_AutoShow( VARIANT_TRUE );

    pWindow->Release();

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnCreateTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnCreateTerminal() 
{
    //
    // Get the selected media type.
    //

    long lMediaType;

    if (!GetMediaType( &lMediaType ))
    {
        return;
    }

    //
    // Get the current address
    //

    ITAddress * pAddress;

    if (!GetAddress( &pAddress ))
    {
        return;
    }

    //
    // Get the selected terminal class.
    //

    BSTR bstrClass;

    if (!GetTerminalClass( &bstrClass ))
    {
        return;
    }

    //
    // get the terminal support interface
    //

    ITTerminalSupport * pTerminalSupport;
    HRESULT hr;

    hr = pAddress->QueryInterface(
                                  IID_ITTerminalSupport,
                                  (void **) &pTerminalSupport
                                 );

    if ( FAILED(hr) )
    {
        SysFreeString( bstrClass );
        return;
    }

    //
    // Convert the terminal class from a BSTR to an IID.
    //

    IID iidTerminalClass;

    IIDFromString(
                bstrClass,
                &iidTerminalClass
               );

    //
    // Create and add the terminal.
    //

    if ( CLSID_VideoWindowTerm == iidTerminalClass )
    {
        HelpCreateTerminal(
                           pTerminalSupport,
                           bstrClass,
                           lMediaType,
                           TD_RENDER
                          );
    }

    //
    // Release references.
    //

    pTerminalSupport->Release();

    SysFreeString(bstrClass);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnReleaseTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnReleaseterminal() 
{
    ITTerminal * pTerminal;

    //
    // get the terminal
    //
    if (GetCreatedTerminal( &pTerminal ))
    {
        //
        // and release it!
        //
        pTerminal->Release();

        //
        // delete it from the tree
        //
        DeleteSelectedItem(
                           ghCreatedWnd
                          );
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddCreated
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnAddcreated() 
{
    ITTerminal *            pTerminal;
    ITCallInfo *            pCall;
    HRESULT                 hr = S_OK;
    ITBasicCallControl *    pBCC;
    

    //
    // get the current call
    //

    if (!(GetCall( &pCall )))
    {
        return;
    }

    //
    // GetCreatedTerminal
    //

    if (!GetCreatedTerminal( &pTerminal ))
    {
        return;
    }

    //
    // Select the terminal on the call.
    //

    hr = SelectTerminalOnCall(pTerminal, pCall);

    if ( FAILED(hr) )
    {
        ::MessageBox(NULL, L"SelectTerminals failed", NULL, MB_OK);
        return;
    }

    //
    // add to the selected window
    //

    AddSelectedTerminal(
                        pTerminal
                       );

    //
    // delete from the created window
    //

    DeleteSelectedItem(
                       ghCreatedWnd
                      );

    //
    // release because there was a reference to
    // this terminal in the created wnd
    //

    pTerminal->Release();
    return;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddNull
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::OnAddnull() 
{
    return;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddToListen
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::OnAddtolisten() 
{
    long lMediaType;

    //
    // get the current mediatype
    //
    if (!GetMediaType( &lMediaType ))
    {
        return;
    }

    //
    // add it
    //
    AddListen( lMediaType );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnListenAll
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnListenall() 
{
    ITAddress *             pAddress;
    HRESULT                 hr = S_OK;
    long                    ulRegister;
    long                    lMediaType;
    ITMediaSupport        * pMediaSupport;
    
    //
    // get the currently selected address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }

    pAddress->QueryInterface(
                             IID_ITMediaSupport,
                             (void **)&pMediaSupport
                            );
    
    pMediaSupport->get_MediaTypes( &lMediaType );
    
    //
    // register
    //
    gpTapi->RegisterCallNotifications(
                                      pAddress,
                                      TRUE,
                                      TRUE,
                                      lMediaType,
                                      gulAdvise,
                                      &ulRegister
                                     );

    
    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"RegisterCallTypes failed", NULL, MB_OK);
    }

	
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedMedia
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedMediatypes(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW*            pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    long                    lMediaType;
    ITAddress *             pAddress;
    HRESULT                 hr;

	*pResult = 0;

    if (gbUpdatingStuff)
        return;

    //
    // get the current mediatype
    //
    if (!GetMediaType( &lMediaType ))
    {
        return;
    }

    //
    // get the current address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }

    //
    // we only show terminals that relate
    // to the selected mediatype
    // so get rid of the old ones
    //
    ReleaseTerminals();
    ReleaseTerminalClasses();

    UpdateTerminals( pAddress, lMediaType );
    UpdateTerminalClasses( pAddress, lMediaType );
    
}

void CT3testDlg::OnRclickSelectedterminals(NMHDR* pNMHDR, LRESULT* pResult) 
{
    POINT                   pt;
    HTREEITEM               hItem;
    TV_HITTESTINFO          hittestinfo;
    RECT                    rc;

    
    *pResult = 0;

    //
    // get the location of the cursor
    //
    GetCursorPos( &pt );

    //
    // get the control's window
    //
    ::GetWindowRect(
                    ghSelectedWnd,
                    &rc
                   );

    //
    // adjust the point to
    // the child's coords
    //
    hittestinfo.pt.x = pt.x - rc.left;
    hittestinfo.pt.y = pt.y - rc.top;


    //
    // hittest to get the tree view item
    //
    hItem = TreeView_HitTest(
                             ghSelectedWnd,
                             &hittestinfo
                            );


    //
    // only display a menu if the mouse is actually
    // over the item (TVHT_ONITEM)
    //
    if (hItem == NULL || (!(hittestinfo.flags & TVHT_ONITEM)) )
    {
        return;
    }


    //
    // select that item (right clicking will not select
    // by default
    //
    TreeView_Select(
                    ghSelectedWnd,
                    hItem,
                    TVGN_CARET
                   );

    CreateSelectedTerminalMenu(
                               pt,
                               m_hWnd
                              );
}


#ifdef ENABLE_DIGIT_DETECTION_STUFF

void CT3testDlg::OnModesSupported()
{
	ITTerminal *                    pTerminal;
    ITDigitGenerationTerminal *     pDigitGeneration;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;

    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitGenerationTerminal,
                                   (void **) &pDigitGeneration
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    pDigitGeneration->get_ModesSupported( &lDigits );

    pDigitGeneration->Release();
}


void CT3testDlg::OnGenerate()
{
	ITTerminal *                    pTerminal;
    ITDigitGenerationTerminal *     pDigitGeneration;
    HRESULT                         hr = S_OK;


    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitGenerationTerminal,
                                   (void **) &pDigitGeneration
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    hr = pDigitGeneration->Generate(
                                    L"12345",
                                    LINEDIGITMODE_DTMF
                                   );

    pDigitGeneration->Release();
}

void CT3testDlg::OnModesSupported2()
{
	ITTerminal *                    pTerminal;
    ITDigitDetectionTerminal *      pDigitDetection;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;

    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetection
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    pDigitDetection->get_ModesSupported( &lDigits );

    pDigitDetection->Release();
}

void CT3testDlg::OnStartDetect()
{
	ITTerminal *                    pTerminal;
    ITDigitDetectionTerminal *      pDigitDetection;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;
    ULONG                           ulAdvise;
    IConnectionPointContainer *     pCPC;
    IConnectionPoint *              pCP;
    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetection
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }


    hr = pTerminal->QueryInterface(
                                   IID_IConnectionPointContainer,
                                   (void **)&pCPC
                                  );

    if (!SUCCEEDED(hr))
    {
        pDigitDetection->Release();
        return;
    }

    gpDigitNotification = new CDigitDetectionNotification;
    
    hr = pCPC->FindConnectionPoint(
                                   IID_ITDigitDetectionNotification,
                                   &pCP
                                  );

    pCPC->Release();

    IUnknown * pUnk;
    
    gpDigitNotification->QueryInterface(
                                        IID_IUnknown,
                                        (void**)&pUnk
                                       );
    
    hr = pCP->Advise(
                     pUnk,
                     &ulAdvise
                    );

    pUnk->Release();
    
    pCP->Release();
    
    pDigitDetection->StartDetect(LINEDIGITMODE_DTMF);

    pDigitDetection->Release();
}

void CT3testDlg::OnStopDetect()
{
	ITTerminal *                    pTerminal;
    ITDigitDetectionTerminal *      pDigitDetection;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;

    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetection
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    pDigitDetection->StopDetect();

    pDigitDetection->Release();
}

#endif // ENABLE_DIGIT_DETECTION_STUFF



void CT3testDlg::OnRclickCalls(NMHDR* pNMHDR, LRESULT* pResult) 
{
    POINT                   pt;
    HTREEITEM               hItem;
    TV_HITTESTINFO          hittestinfo;
    RECT                    rc;

    
    *pResult = 0;

    //
    // get the location of the cursor
    //
    GetCursorPos( &pt );

    //
    // get the control's window
    //
    ::GetWindowRect(
                    ghCallsWnd,
                    &rc
                   );

    //
    // adjust the point to
    // the child's coords
    //
    hittestinfo.pt.x = pt.x - rc.left;
    hittestinfo.pt.y = pt.y - rc.top;


    //
    // hittest to get the tree view item
    //
    hItem = TreeView_HitTest(
                             ghCallsWnd,
                             &hittestinfo
                            );


    //
    // only display a menu if the mouse is actually
    // over the item (TVHT_ONITEM)
    //
    if (hItem == NULL || (!(hittestinfo.flags & TVHT_ONITEM)) )
    {
        return;
    }


    //
    // select that item (right clicking will not select
    // by default
    //
    TreeView_Select(
                    ghCallsWnd,
                    hItem,
                    TVGN_CARET
                   );

}

void CT3testDlg::OnConfigAutoAnswer()
{
    ITAddress * pAddress;
    autoans dlg;
    DataPtrList::iterator   dataiter, dataend;
    
    if (!GetAddress( &pAddress ) )
    {
        return;
    }

    dataiter = gDataPtrList.begin();
    dataend  = gDataPtrList.end();

    for ( ; dataiter != dataend; dataiter++ )
    {
        if ( pAddress == (*dataiter)->pAddress )
        {
            break;
        }
    }

    if ( dataiter == dataend )
    {
        return;
    }

    FreeData( (*dataiter) );
    
    if (IDOK == dlg.DoModal())
    {
        TerminalPtrList::iterator       iter, end;
        DWORD                           dwCount;
        long                            lRegister;
        HRESULT                         hr;
        long                            lMediaType = 0;
        
        dwCount = dlg.m_TerminalPtrList.size();

        if ( 0 == dwCount )
        {
            return;
        }
        
        iter = dlg.m_TerminalPtrList.begin();
        end  = dlg.m_TerminalPtrList.end();
        
        for ( ; iter != end ; iter++ )
        {
            long        l;
            
            (*dataiter)->pTerminalPtrList->push_back( *iter );

            if ( NULL != (*iter) )
            {
                (*iter)->get_MediaType( &l );
                lMediaType |= l;
            }
            else
            {
                lMediaType |= (long)LINEMEDIAMODE_VIDEO;
            }

        }

        //
        // call register call types
        //
        hr = gpTapi->RegisterCallNotifications(
                                               pAddress,
                                               VARIANT_FALSE,
                                               VARIANT_TRUE,
                                               lMediaType,
                                               0,
                                               &lRegister
                                              );

    }

}
void CT3testDlg::FreeData( AADATA * pData )
{
    TerminalPtrList::iterator       iter, end;

    iter = pData->pTerminalPtrList->begin();
    end  = pData->pTerminalPtrList->end();

    for ( ; iter != end; iter++ )
    {
        if ( NULL != (*iter) )
        {
            (*iter)->Release();
        }
    }

    pData->pTerminalPtrList->clear();
}

void CT3testDlg::OnClose() 
{
	CDialog::OnClose();
}


void CT3testDlg::OnILS()
{
    CILSDlg dlg;

    if (IDOK == dlg.DoModal())
    {
    }
    
}

void CT3testDlg::OnRate()
{
    CRateDlg dlg;
    ITCallInfo * pCallInfo;

    if ( !GetCall( &pCallInfo ) )
    {
        return;
    }

    if (IDOK == dlg.DoModal() )
    {
        pCallInfo->put_CallInfoLong(CIL_MINRATE, dlg.m_dwMinRate );
        pCallInfo->put_CallInfoLong(CIL_MAXRATE, dlg.m_dwMaxRate );
    }
}

void CT3testDlg::OnPark1()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;
    
    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void**)&pBCC
                         );
    
    hr = pBCC->ParkDirect( L"101");
    
    pBCC->Release();

}
void CT3testDlg::OnPark2()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;
    BSTR                    pAddress;

    
    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );

    hr = pBCC->ParkIndirect( &pAddress );

    SysFreeString( pAddress );

    pBCC->Release();
    

}
void CT3testDlg::OnHandoff1()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );

    pBCC->HandoffDirect( L"tb20.exe" );

    pBCC->Release();
    
}
void CT3testDlg::OnHandoff2()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;


    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );

    pBCC->HandoffIndirect( TAPIMEDIATYPE_AUDIO );

    pBCC->Release();

}
void CT3testDlg::OnUnpark()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );


    pBCC->Unpark();

    pBCC->Release();
    
}
void CT3testDlg::OnPickup1()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );


    pBCC->Pickup( NULL );

    pBCC->Release();
}
void CT3testDlg::OnPickup2()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3test\t3testd.h ===
// t3testDlg.h : header file
//

#if !defined(AFX_T3TESTDLG_H__2584F27A_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_T3TESTDLG_H__2584F27A_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CT3testDlg dialog
#include "autoans.h"
class CT3testDlg : public CDialog
{
// Construction
public:
	CT3testDlg(CWnd* pParent = NULL);	// standard constructor
    void InitializeTrees();
    static void AddAddressToTree( ITAddress * pAddress );
    static void ReleaseAddresses( );
    static void SelectFirstItem(HWND hWnd,HTREEITEM hRoot);
    static void DeleteSelectedItem(HWND hWnd);
    static void UpdateMediaTypes(ITAddress * pAddress);
    static void UpdateCalls(ITAddress * pAddress);
    static void UpdateTerminalClasses(ITAddress * pAddress,long lMediaType);
    static void UpdateTerminals(ITAddress * pAddress,long lMediaType);
    static void CreateSelectedTerminalMenu(POINT pt, HWND);
    static void DoDigitGenerationTerminalMenu(HWND hWnd,POINT *);
    static void DoDigitDetectTerminalMenu(HWND hWnd, POINT *);
    static void CreateCallMenu(POINT pt, HWND hWnd);
    static void PutCaptions();
    static void HandleCallHubEvent( IDispatch * );
    static void HandleTapiObjectMessage( IDispatch * pEvent );
    static LPWSTR GetCallPrivilegeName(ITCallInfo * pCall);
    static LPWSTR GetCallStateName(ITCallInfo * pCall);
    static BSTR GetTerminalClassName( GUID * pguid );
    static void InitializeAddressTree();
    static void RegisterEventInterface();
    static void RegisterForCallNotifications();
    static void AddMediaType( long lMediaType );
    static void AddTerminal( ITTerminal * pTerminal );
    static void AddCreatedTerminal( ITTerminal * pTerminal );    
    static void AddCall( ITCallInfo * pCall );
    static void UpdateCall( ITCallInfo * pCall );
    static void AddSelectedTerminal( ITTerminal * pTerminal);
    static void AddTerminalClass( GUID * );
    static void AddListen( long );
    static void ReleaseMediaTypes( );
    static void ReleaseTerminals();
    static void ReleaseCalls();
    static void ReleaseTerminalClasses();
    static void ReleaseCreatedTerminals();
    static void ReleaseDynamicClasses();
    static void ReleaseSelectedTerminals();
    static void ReleaseListen();
    static void GetMediaTypeName( long, LPWSTR );
    static BOOL GetMediaType( long * plMediaType );
    static BOOL GetCall( ITCallInfo ** ppCall );
    static BOOL GetAddress( ITAddress ** ppAddress );
    static BOOL GetTerminal( ITTerminal ** ppTerminal );
    static BOOL GetTerminalClass( BSTR * pbstrClass );
    static BOOL GetCreatedTerminal( ITTerminal ** ppTerminal );
    static BOOL GetSelectedTerminal( ITTerminal ** ppTerminal );
    void FreeData( AADATA * pData );
    static void HelpCreateTerminal(
                               ITTerminalSupport * pTerminalSupport,
                               BSTR bstrClass,
                               long lMediaType,
                               TERMINAL_DIRECTION dir
                              );
    BOOL IsVideoCaptureStream(ITStream * pStream);
    HRESULT GetVideoRenderTerminal(ITTerminal ** ppTerminal) ;
    HRESULT SelectTerminalOnCall(ITTerminal * pTerminal, ITCallInfo * pCall);
    HRESULT EnablePreview(ITStream * pStream);
    void RemovePreview( ITStream * pStream );

    void DoAutoAnswer(ITCallInfo * pCall);
    afx_msg void OnClose() ;
// Dialog Data
	//{{AFX_DATA(CT3testDlg)
	enum { IDD = IDD_T3TEST_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CT3testDlg)
	public:
	virtual void OnFinalRelease();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CT3testDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnDestroy();
	afx_msg void OnSelchangedAddresses(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnAddterminal();
	afx_msg void OnRemoveterminal();
	afx_msg void OnCreatecall();
	afx_msg void OnConnect();
	afx_msg void OnDrop();
	afx_msg void OnAnswer();
	afx_msg void OnListen();
	afx_msg void OnSelchangedCalls(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRelease();
	afx_msg void OnCreateTerminal();
	afx_msg void OnReleaseterminal();
	afx_msg void OnAddcreated();
	afx_msg void OnAddnull();
	afx_msg void OnAddtolisten();
	afx_msg void OnListenall();
	afx_msg void OnSelchangedMediatypes(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRclickSelectedterminals(NMHDR* pNMHDR, LRESULT* pResult);

#ifdef ENABLE_DIGIT_DETECTION_STUFF
	afx_msg void OnGenerate();
    afx_msg void OnModesSupported();
    afx_msg void OnModesSupported2();
    afx_msg void OnStartDetect();
    afx_msg void OnStopDetect();
#endif // ENABLE_DIGIT_DETECTION_STUFF

    afx_msg void OnConfigAutoAnswer();
    afx_msg void OnILS();
    afx_msg void OnRate();
    afx_msg void OnPark1();
    afx_msg void OnPark2();
    afx_msg void OnHandoff1();
    afx_msg void OnHandoff2();
    afx_msg void OnUnpark();
    afx_msg void OnPickup1();
    afx_msg void OnPickup2();

    
	afx_msg void OnRclickCalls(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG CT3testDlg::OnTapiEvent(UINT u, LONG_PTR l);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

HRESULT ListILSServers(
                       LPWSTR ** ppServers,
                       DWORD * pdwNumServers
                      );

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_T3TESTDLG_H__2584F27A_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\ilsdlg.cpp ===
// autoans.cpp : implementation file
//
#include "stdafx.h"
#include "t3test.h"
#include "t3testd.h"
#include "ilsdlg.h"
#include "servname.h"
#include "resource.h"
#include "strings.h"


#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CILSDlg::CILSDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CILSDlg::IDD, pParent)
{
}


void CILSDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}

BOOL CILSDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    ListServers();
    return TRUE;
}


void CILSDlg::OnOK()
{
    SaveServers();
    
	CDialog::OnOK();
}


void CILSDlg::OnDestroy() 
{
    CleanUp();
    CDialog::OnDestroy();
}


void CILSDlg::ListServers()
{
    HRESULT         hr;
    LPWSTR        * ppServers;
    DWORD           dw;
    
    hr = ListILSServers(
                        &ppServers,
                        &dw
                       );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    while (dw)
    {
        dw--;

        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_ADDSTRING,
                           0,
                           (LPARAM) ppServers[dw]
                          );

        CoTaskMemFree( ppServers[dw] );
        
    }

    CoTaskMemFree( ppServers );
    
}

void CILSDlg::SaveServers()
{
    HKEY        hKey, hAppKey;
    DWORD       dw;

    
    if ( RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      PARENTKEY,
                      0,
                      KEY_WRITE,
                      &hKey
                     ) != ERROR_SUCCESS )
    {
    }

    if ( RegCreateKeyEx(
                        hKey,
                        APPKEY,
                        0,
                        L"",
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hAppKey,
                        &dw
                       ) != ERROR_SUCCESS )
    {
    }

    RegCloseKey( hKey );

        
    RegDeleteKey(
                 hAppKey,
                 SERVERKEY
                );
    
    if ( RegCreateKeyEx(
                        hAppKey,
                        SERVERKEY,
                        0,
                        L"",
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dw
                       ) != ERROR_SUCCESS )
    {
    }

    RegCloseKey (hAppKey );
    
    dw = SendDlgItemMessage(
                            IDC_ILSLIST,
                            LB_GETCOUNT,
                            0,
                            0
                           );

    while ( 0 != dw )
    {
        WCHAR szServer[256];
        WCHAR szBuffer[256];
        
        dw--;

        wsprintf(szServer, L"server%d", dw);
                 
        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_GETTEXT,
                           dw,
                           (LPARAM)szBuffer
                          );

        RegSetValueEx(
                      hKey,
                      szServer,
                      0,
                      REG_SZ,
                      (BYTE *)szBuffer,
                      lstrlenW(szBuffer) * sizeof(WCHAR)
                     );
    }
}

void CILSDlg::CleanUp()
{
}

void CILSDlg::OnAdd()
{
    CServNameDlg dlg;
    
    if (IDOK == dlg.DoModal())
    {
        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_ADDSTRING,
                           0,
                           (LPARAM)(LPCTSTR)(dlg.m_pszServerName)
                          );
    }   
}

void CILSDlg::OnRemove()
{
    DWORD       dw;

    dw = SendDlgItemMessage(
                            IDC_ILSLIST,
                            LB_GETCURSEL,
                            0,
                            0
                           );

    if ( dw != LB_ERR )
    {
        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_DELETESTRING,
                           dw,
                           0
                          );
    }
}


BEGIN_MESSAGE_MAP(CILSDlg, CDialog)
	ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
END_MESSAGE_MAP()

            
HRESULT ListILSServers(
                    LPWSTR ** pppServers,
                    DWORD * pdwNumServers
                   )
{
    HKEY        hKey, hAppKey;
    DWORD       dw, dwSize;

    //
    // look in the directory for the
    //
    if ( RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      PARENTKEY,
                      0,
                      KEY_WRITE,
                      &hKey
                     ) != ERROR_SUCCESS )
    {
    }

    if ( RegOpenKeyEx(
                      hKey,
                      APPKEY,
                      0,
                      KEY_ALL_ACCESS,
                      &hAppKey
                     ) != ERROR_SUCCESS )
    {
        RegCloseKey( hKey );
        return E_FAIL;
    }

    RegCloseKey( hKey );
    
    if ( RegOpenKeyEx(
                      hAppKey,
                      SERVERKEY,
                      0,
                      KEY_ALL_ACCESS,
                      &hKey
                     ) != ERROR_SUCCESS )
    {
        RegCloseKey(hAppKey);
        return E_FAIL;
    }

    RegCloseKey (hAppKey );
    
    dw = 0;
    
    while (TRUE)
    {
        WCHAR       szBuffer[256];
        WCHAR       szServer[256];
        DWORD       dwType;
        
        wsprintf(szBuffer, L"server%d", dw);

        if ( RegQueryValueEx(
                             hKey,
                             szBuffer,
                             NULL,
                             NULL,
                             NULL,
                             &dwSize
                            ) != ERROR_SUCCESS )
        {
            break;
        }

        dw++;
    }

    *pppServers = (LPWSTR *)CoTaskMemAlloc( dw * sizeof (LPWSTR) );

    if ( NULL == *pppServers )
    {
        return E_OUTOFMEMORY;
    }

    dw = 0;
    
    while (TRUE)
    {
        WCHAR       szBuffer[256];
        WCHAR       szServer[256];
        DWORD       dwType;
        
        wsprintf(szBuffer, L"server%d", dw);

        dwSize = 256;
        
        if ( RegQueryValueEx(
                             hKey,
                             szBuffer,
                             NULL,
                             NULL,
                             (LPBYTE)szServer,
                             &dwSize
                            ) != ERROR_SUCCESS )
        {
            break;
        }

        (*pppServers)[dw] = (LPWSTR) CoTaskMemAlloc( (lstrlenW(szServer) + 1) * sizeof(WCHAR));
        
        lstrcpy(
                (*pppServers)[dw],
                szServer
               );
        dw++;
    }

    *pdwNumServers = dw;

    RegCloseKey( hKey );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\ilsdlg.h ===
#if !defined(AFX_ILSDlg_H)
#define AFX_ILSDlg_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "rend.h"

/////////////////////////////////////////////////////////////////////////////
// CILSDlg dialog

class CILSDlg : public CDialog
{
// Construction
public:
	CILSDlg(CWnd* pParent = NULL);
	enum { IDD = IDD_ILSSERVERS };
    
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    BOOL CILSDlg::OnInitDialog();
    virtual void OnOK();
    afx_msg void OnDestroy();
    afx_msg void OnAdd();
    afx_msg void OnRemove();
    void ListServers();
    void SaveServers();
    void CleanUp();
    DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\menus.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"
#include "control.h"

void
CT3testDlg::CreateSelectedTerminalMenu(
                                       POINT pt,
                                       HWND hWnd
                                      )
{
    ITTerminal *                    pTerminal;

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    ITDigitGenerationTerminal *     pDigitGeneration;
    ITDigitDetectionTerminal *         pDigitDetect;
#endif // ENABLE_DIGIT_DETECTION_STUFF


    HRESULT                         hr;
    ITBasicAudioTerminal *          pBasicAudio;
    long                            lval;
    
    //
    // get the terminal in question
    //
    if (!GetSelectedTerminal( &pTerminal ))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITBasicAudioTerminal,
                                   (void **) &pBasicAudio
                                  );

    if ( SUCCEEDED(hr) )
    {
        pBasicAudio->get_Volume( &lval );
        pBasicAudio->put_Volume( lval );
        pBasicAudio->get_Balance( &lval );
        pBasicAudio->put_Balance( lval );
        pBasicAudio->Release();
    }

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    hr = pTerminal->QueryInterface(
                                   IID_ITDigitGenerationTerminal,
                                   (void **) &pDigitGeneration
                                  );

    if (SUCCEEDED(hr))
    {
        DoDigitGenerationTerminalMenu(hWnd, &pt);

        pDigitGeneration->Release();
        
        return;
    }
    
    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetect
                                  );

    if (SUCCEEDED(hr))
    {
        DoDigitDetectTerminalMenu(hWnd,&pt);

        pDigitDetect->Release();
        
        return;
    }
#endif // ENABLE_DIGIT_DETECTION_STUFF


}

void CT3testDlg::DoDigitGenerationTerminalMenu(
                                               HWND hWnd,
                                               POINT * pPt
                                              )
{
    //
    // create the menu
    //
    HMENU                   hMenu;

    hMenu = CreatePopupMenu();

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_MODESUPPORTED,
               L"Modes Supported"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_GENERATE,
               L"Generate"
              );

    // actually show menu
    TrackPopupMenu(
                   hMenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                   pPt->x,
                   pPt->y,
                   0,
                   hWnd,
                   NULL
                  );
}
    
void CT3testDlg::DoDigitDetectTerminalMenu(
                                           HWND hWnd,
                                           POINT * pPt
                                          )
{
    //
    // create the menu
    //
    HMENU                   hMenu;

    hMenu = CreatePopupMenu();

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_MODESUPPORTED2,
               L"Modes Supported"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_STARTDETECT,
               L"Start Detection"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_STOPDETECT,
               L"Stop Detection"
              );

    // actually show menu
    TrackPopupMenu(
                   hMenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                   pPt->x,
                   pPt->y,
                   0,
                   hWnd,
                   NULL
                  );
}

void
CT3testDlg::CreateCallMenu(
                           POINT pt,
                           HWND hWnd
                          )
{
    ITCallInfo              * pCall;
    HMENU                   hMenu;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    //
    // create the menu
    //
    hMenu = CreatePopupMenu();

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_HANDOFF1,
               L"Handoff1"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_HANDOFF2,
               L"Handoff2"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PARK1,
               L"Park1"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PARK2,
               L"Park2"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_UNPARK,
               L"Unpark"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PICKUP1,
               L"Pickup1"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PICKUP2,
               L"Pickup2"
              );

    

    

    //
    // actually show menu
    //
    TrackPopupMenu(
                   hMenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                   pt.x,
                   pt.y,
                   0,
                   hWnd,
                   NULL
                  );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\rate.cpp ===
// RateDlg.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "rate.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRateDlg dialog


CRateDlg::CRateDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRateDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRateDlg)
	m_dwMinRate = 0;
    m_dwMaxRate = 0;

	//}}AFX_DATA_INIT
}


void CRateDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRateDlg)
	DDX_Text(pDX, IDC_MINRATE, m_dwMinRate);
    DDX_Text(pDX, IDC_MAXRATE, m_dwMaxRate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRateDlg, CDialog)
	//{{AFX_MSG_MAP(CRateDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRateDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\rate.h ===
#if !defined(AFX_RATEDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_RATEDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// RateDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRateDlg dialog

class CRateDlg : public CDialog
{
// Construction
public:
	CRateDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRateDlg)
	enum { IDD = IDD_RATE };
    DWORD m_dwMinRate;
    DWORD m_dwMaxRate;
    
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRateDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRateDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RATEDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\callnot.h ===
// CallNotification.h : Declaration of the CCallNotification

#ifndef __CALLNOTIFICATION_H_
#define __CALLNOTIFICATION_H_

/////////////////////////////////////////////////////////////////////////////
//
// CTAPIEventNotification
//
/////////////////////////////////////////////////////////////////////////////
class CTAPIEventNotification :
	public ITTAPIEventNotification
{
public:
    DWORD m_dwRefCount;
    CTAPIEventNotification(){ m_dwRefCount = 0;}

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_ITTAPIEventNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }
	ULONG STDMETHODCALLTYPE AddRef()
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
	ULONG STDMETHODCALLTYPE Release()
    {
        m_dwRefCount--;

        if ( 0 == m_dwRefCount)
        {
            delete this;
        }

        return 1;
    }


// ICallNotification
public:

	    HRESULT STDMETHODCALLTYPE Event(
            TAPI_EVENT TapiEvent,
            IDispatch * pEvent
            );

};


#ifdef ENABLE_DIGIT_DETECTION_STUFF

/////////////////////////////////////////////////////////////////////////////
//
// CDigitDetectionNotification
//
/////////////////////////////////////////////////////////////////////////////
class CDigitDetectionNotification :
	public ITDigitDetectionNotification
{
public:
    DWORD m_dwRefCount;
    CDigitDetectionNotification(){ m_dwRefCount = 0;}

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_ITDigitDetectionNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IDispatch)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }
	ULONG STDMETHODCALLTYPE AddRef()
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
	ULONG STDMETHODCALLTYPE Release()
    {
        m_dwRefCount--;

        if ( 0 == m_dwRefCount)
        {
            delete this;
        }
        return 1;
    }


// ICallNotification
public:

    HRESULT STDMETHODCALLTYPE DigitDetected(
            unsigned char ucDigit,
            TAPI_DIGITMODE DigitMode,
            long ulTickCount
            );
    
};

#endif // ENABLE_DIGIT_DETECTION_STUFF

#endif //__CALLNOTIFICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\callnot.cpp ===
//

#include "stdafx.h"
#include "t3test.h"
#include "t3testd.h"
#include "callnot.h"
#include "control.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


extern CWnd * gpmainwnd;

HandleVideoWindowCrap(
                      ITCallInfo * pCallInfo
                     );

HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::Event(
                              TAPI_EVENT TapiEvent,
                              IDispatch * pEvent
                             )
{
    HRESULT hr;


    pEvent->AddRef();
    
    hr = PostMessage( gpmainwnd->m_hWnd, WM_USER+101, (WPARAM)TapiEvent, (LPARAM)pEvent );

    return hr;
    
}

afx_msg LONG CT3testDlg::OnTapiEvent(UINT u, LONG_PTR l)
{
    HRESULT         hr;
    TAPI_EVENT      TapiEvent;
    IDispatch *     pEvent;

    TapiEvent = (TAPI_EVENT)u;
    pEvent = (IDispatch *)l;
    
    switch (TapiEvent)
    {
        case TE_CALLNOTIFICATION:
        {
            ITAddress *                 pAddress;
            ITAddress *                 pCallAddress;
            ITCallInfo *                pCallInfo;
            ITCallNotificationEvent *   pCallNotify;


            //
            // get the currently selected address
            //
            if (CT3testDlg::GetAddress( &pAddress ))
            {
                //
                // get the event
                //
                pEvent->QueryInterface(IID_ITCallNotificationEvent, (void **)&pCallNotify );
                //
                // get the call
                //
                pCallNotify->get_Call( &pCallInfo );
                //
                // get the call's event
                //
                pCallInfo->get_Address( &pCallAddress );

                //
                // if this call is supposed to be on this
                // address, add it to the UI
                //
                if (pAddress == pCallAddress)
                {
                    // need to add a second reference for
                    // the tree view
                    CT3testDlg::AddCall( pCallInfo );
                }

                CALL_PRIVILEGE      cp;
                CALL_STATE          cs;
                
                pCallInfo->get_Privilege( &cp );

                if ( CP_OWNER == cp )
                {
                    DoAutoAnswer( pCallInfo );
                }

                pCallInfo->get_CallState(&cs);
                
                //
                // release our references
                // keep refernce to the call or it will
                // be destroyed
                //
                pCallAddress->Release();
                pCallNotify->Release();
            }
        }
        
        break;
        
        case TE_CALLSTATE:
        {
            ITCallStateEvent        * pCallStateEvent;
            ITCallInfo              * pCallInfo;
            CALL_STATE                cs;


            hr = pEvent->QueryInterface(IID_ITCallStateEvent, (void **)&pCallStateEvent);

            pCallStateEvent->get_Call( &pCallInfo );

            CT3testDlg::UpdateCall( pCallInfo );

            pCallStateEvent->get_State(
                                       &cs
                                      );

            if (CS_CONNECTED == cs)
            {
//                HandleVideoWindowCrap( pCallInfo );
            }

            pCallInfo->Release();
            pCallStateEvent->Release();

            break;
        }

        case TE_CALLHUB:
        {
            CT3testDlg::HandleCallHubEvent( pEvent );

            break;
        }

        case TE_TAPIOBJECT:
        {
            CT3testDlg::HandleTapiObjectMessage( pEvent );
            break;
        }

        case TE_ADDRESS:
        {
            CT3testDlg::HandleAddressEvent( pEvent );
            break;
        }

        case TE_PHONEEVENT:
        {
            CT3testDlg::HandlePhoneEvent( pEvent );
            break;
        }

        break;

        case TE_CALLMEDIA:
        {
            WCHAR * pwstrEvent;
            WCHAR * pwstrCause;

            ITCallMediaEvent  * pCallMediaEvent;
            hr = pEvent->QueryInterface( IID_ITCallMediaEvent,
                                         (void **)&pCallMediaEvent );

            if (FAILED(hr))
            {
                pwstrEvent = pwstrCause = L"can't get event interface";
            }
            else
            {
                CALL_MEDIA_EVENT    cme;
                hr = pCallMediaEvent->get_Event( &cme );

                if (FAILED(hr))
                {
                    pwstrEvent = L"can't get event type";
                }
                else
                {
                    switch ( cme )
                    {
                    case CME_NEW_STREAM:
                        pwstrEvent = L"CME_NEW_STREAM";
                        break;

                    case CME_STREAM_FAIL:
                        pwstrEvent = L"CME_STREAM_FAIL";
                        break;
            
                    case CME_TERMINAL_FAIL:
                        pwstrEvent = L"CME_TERMINAL_FAIL";
                        break;

                    case CME_STREAM_NOT_USED:
                        pwstrEvent = L"CME_STREAM_NOT_USED";
                        break;

                    case CME_STREAM_ACTIVE:
                        pwstrEvent = L"CME_STREAM_ACTIVE";
                        break;

                    case CME_STREAM_INACTIVE:
                        pwstrEvent = L"CME_STREAM_INACTIVE";
                        break;

                    default:
                        pwstrEvent = L"type undefined";
                        break;
                    }
                }
            }

            CALL_MEDIA_EVENT_CAUSE    cmec;

            hr = pCallMediaEvent->get_Cause( &cmec );

            pCallMediaEvent->Release();

            if (FAILED(hr))
            {
                pwstrCause = L"can't get event cause";
            }
            else
            {
                switch ( cmec )
                {
                case CMC_UNKNOWN:
                    pwstrCause = L"CMC_UNKNOWN";
                    break;

                case CMC_BAD_DEVICE:
                    pwstrCause = L"CMC_BAD_DEVICE";
                    break;
            
                case CMC_CONNECT_FAIL:
                    pwstrCause = L"CMC_CONNECT_FAIL";
                    break;
            
                case CMC_LOCAL_REQUEST:
                    pwstrCause = L"CMC_LOCAL_REQUEST";
                    break;

                case CMC_REMOTE_REQUEST:
                    pwstrCause = L"CMC_REMOTE_REQUEST";
                    break;

                case CMC_MEDIA_TIMEOUT:
                    pwstrCause = L"CMC_MEDIA_TIMEOUT";
                    break;

                case CMC_MEDIA_RECOVERED:
                    pwstrCause = L"CMC_MEDIA_RECOVERED";
                    break;

                default:
                    pwstrCause = L"cause undefined";
                    break;
                }
            }

            ::MessageBox(NULL, pwstrEvent, pwstrCause, MB_OK);

            break;
        }      

        default:

            break;
    }

    pEvent->Release();
    
    return S_OK;
}


#ifdef ENABLE_DIGIT_DETECTION_STUFF

HRESULT
STDMETHODCALLTYPE
CDigitDetectionNotification::DigitDetected(
                                           unsigned char ucDigit,
                                           TAPI_DIGITMODE DigitMode,
                                           long ulTickCount
                                          )
{
    return S_OK;
}
    
#endif // ENABLE_DIGIT_DETECTION_STUFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\servname.cpp ===
// ServNameDlg.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "servname.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServNameDlg dialog


CServNameDlg::CServNameDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CServNameDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CServNameDlg)
	m_pszServerName = _T("");
	//}}AFX_DATA_INIT
}


void CServNameDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServNameDlg)
	DDX_Text(pDX, IDC_SERVERNAME, m_pszServerName);
	DDV_MaxChars(pDX, m_pszServerName, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServNameDlg, CDialog)
	//{{AFX_MSG_MAP(CServNameDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServNameDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\servname.h ===
#if !defined(AFX_ServNameDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_ServNameDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ServNameDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServNameDlg dialog

class CServNameDlg : public CDialog
{
// Construction
public:
	CServNameDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CServNameDlg)
	enum { IDD = IDD_ILSSERVERNAME };
	CString	m_pszServerName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServNameDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CServNameDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ServNameDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	t3test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef UNICODE
#define UNICODE
#endif

#if !defined(AFX_STDAFX_H__47F9FE88_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_STDAFX_H__47F9FE88_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#include "tapi3.h"
//#include "tapi.h"

#include <list>
using namespace std;

typedef list<ITTerminal *>      TerminalPtrList;
typedef struct
{
    ITAddress * pAddress;
    TerminalPtrList * pTerminalPtrList;
    
} AADATA;

typedef list<AADATA *> DataPtrList;
   


#endif // !defined(AFX_STDAFX_H__47F9FE88_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\t3test.cpp ===
// t3test.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CWnd * gpmainwnd;

/////////////////////////////////////////////////////////////////////////////
// CT3testApp

BEGIN_MESSAGE_MAP(CT3testApp, CWinApp)
	//{{AFX_MSG_MAP(CT3testApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CT3testApp construction

CT3testApp::CT3testApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CT3testApp object

CT3testApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CT3testApp initialization

BOOL CT3testApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CT3testDlg dlg;
	m_pMainWnd = &dlg;
    gpmainwnd = &dlg;
    
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\strings.h ===
#define PARENTKEY L"Software\\Microsoft"
#define APPKEY L"t3test"
#define SERVERKEY L"Servers"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\t3test.h ===
// t3test.h : main header file for the T3TEST application
//

#if !defined(AFX_T3TEST_H__47F9FE84_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_T3TEST_H__47F9FE84_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CT3testApp:
// See t3test.cpp for the implementation of this class
//

class CT3testApp : public CWinApp
{
public:
	CT3testApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CT3testApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CT3testApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_T3TEST_H__47F9FE84_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\externs.h ===
#include "stdafx.h"
#include "t3test.h"

extern ITTAPI * gpTapi;
extern HWND ghAddressesWnd;
extern HWND ghTerminalsWnd;
extern HWND ghMediaTypesWnd;
extern HWND ghCallsWnd;
extern HWND ghSelectedCallsWnd;
extern HWND ghPhonesWnd;
extern HWND ghSelectedWnd;
extern HWND ghCreatedWnd;
extern HWND ghClassesWnd;
extern HWND ghListenWnd;
extern HTREEITEM ghAddressesRoot;
extern HTREEITEM ghTerminalsRoot;
extern HTREEITEM ghMediaTypesRoot;
extern HTREEITEM ghCallsRoot;
extern HTREEITEM ghSelectedCallsRoot;
extern HTREEITEM ghPhonesRoot;
extern HTREEITEM ghSelectedRoot;
extern HTREEITEM ghCreatedRoot;
extern HTREEITEM ghClassesRoot;
extern HTREEITEM ghListenRoot;

extern long       gulAdvise;
extern BOOL gbUpdatingStuff;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\event.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "externs.h"

void
CT3testDlg::HandleCallHubEvent( IDispatch * pEvent )
{
    HRESULT             hr;
    ITCallHubEvent *    pCallHubEvent;
    CALLHUB_EVENT       che;
    

    hr = pEvent->QueryInterface(
                                IID_ITCallHubEvent,
                                (void **)&pCallHubEvent
                               );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    hr = pCallHubEvent->get_Event( &che );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    switch ( che )
    {
        case CHE_CALLHUBNEW:

            break;
            
        case CHE_CALLHUBIDLE:

            break;
            
        default:
            break;
    }

    pCallHubEvent->Release();

}


void
CT3testDlg::HandleTapiObjectMessage( IDispatch * pEvent )
{
    ITTAPIObjectEvent * pte;
    HRESULT             hr;
    TAPIOBJECT_EVENT    te;

    hr = pEvent->QueryInterface(
                                IID_ITTAPIObjectEvent,
                                (void**)&pte
                               );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    pte->get_Event( &te );

    switch (te)
    {
        case TE_ADDRESSCREATE:
        case TE_ADDRESSREMOVE:

            ReleaseMediaTypes();
            ReleaseTerminals();
            ReleaseCalls();
            ReleasePhones();
            ReleaseSelectedTerminals();
            ReleaseCreatedTerminals();
            ReleaseTerminalClasses();
            ReleaseListen();
            ReleaseAddresses();
            InitializeAddressTree();

            break;

        case TE_PHONECREATE:
        case TE_PHONEREMOVE:
            {
                ITAddress           * pSelectedAddress;
                ITTAPIObjectEvent2  * pTAPIObjectEvent2;
                ITPhone             * pPhone;
                BSTR                bstrName = NULL;

                hr = pte->QueryInterface(IID_ITTAPIObjectEvent2, (void **)&pTAPIObjectEvent2);

                if (SUCCEEDED(hr))
                {
                    hr = pTAPIObjectEvent2->get_Phone( &pPhone );

                    if (SUCCEEDED(hr))
                    {
                        hr = pPhone->get_PhoneCapsString( PCS_PHONENAME, &bstrName );

                        if (SUCCEEDED(hr))
                        {     
                            switch(te)
                                    {
                                    case TE_PHONECREATE:
                                        ::MessageBox(NULL, bstrName, L"TE_PHONECREATE", MB_OK);
                                        break;
        
                                    case TE_PHONEREMOVE:
                                        ::MessageBox(NULL, bstrName, L"TE_PHONEREMOVE", MB_OK);
                                        break;
        
                                    }

                            SysFreeString( bstrName );
                        }
                        pPhone->Release();
                    }
                    pTAPIObjectEvent2->Release();
                }

                if ( GetAddress( &pSelectedAddress ) )
                {
                    ReleasePhones();
                
                    UpdatePhones( pSelectedAddress );    
                }
            }

            break;
            
        default:
            break;
    }

    pte->Release();
    
}

void
CT3testDlg::HandleAddressEvent( IDispatch * pEvent )
{
    ITAddressEvent      * pAddressEvent;
    ITTerminal          * pTerminal;
    ITAddress           * pAddress;   
    ITAddress           * pSelectedAddress;
    LONG                lMediaType;
    LONG                lSelectedMediaType;
    BSTR                bstrName = NULL;
    ADDRESS_EVENT       ae;
    HRESULT             hr;

    hr = pEvent->QueryInterface(IID_ITAddressEvent, (void **)&pAddressEvent);

    if (SUCCEEDED(hr))
    {
        hr = pAddressEvent->get_Event( &ae );

        if (SUCCEEDED(hr))
        {
            if ( (ae == AE_NEWTERMINAL) || (ae == AE_REMOVETERMINAL) )
            {
                hr = pAddressEvent->get_Terminal( &pTerminal );

                if (SUCCEEDED(hr))
                {
                    hr = pTerminal->get_Name( &bstrName );

                    if (SUCCEEDED(hr))
                    {                                                               
                        hr = pAddressEvent->get_Address( &pAddress );

                        if (SUCCEEDED(hr))
                        {
                            hr = pTerminal->get_MediaType( &lMediaType );

                            if (SUCCEEDED(hr))
                            {
                                if (CT3testDlg::GetMediaType( &lSelectedMediaType ) && ( lSelectedMediaType == lMediaType) &&
                                    CT3testDlg::GetAddress( &pSelectedAddress ) && ( pSelectedAddress == pAddress) )
                                {
                                    switch(ae)
                                    {
                                    case AE_NEWTERMINAL:
                                        ::MessageBox(NULL, bstrName, L"AE_NEWTERMINAL", MB_OK);
                                        break;
        
                                    case AE_REMOVETERMINAL:
                                        ::MessageBox(NULL, bstrName, L"AE_REMOVETERMINAL", MB_OK);
                                        break;
        
                                    }

                                    CT3testDlg::ReleaseTerminals();
                                    CT3testDlg::UpdateTerminals( pAddress, lMediaType );
                                }
                            }
                            pAddress->Release();
                        }
                        SysFreeString( bstrName );
                    }
                    pTerminal->Release();
                }
            }           
        }
        pAddressEvent->Release();
    }
}

void
CT3testDlg::HandlePhoneEvent( IDispatch * pEvent )
{
    ITPhoneEvent      * pPhoneEvent;
    ITPhone           * pPhone;
    PHONE_EVENT       pe;
    HRESULT           hr;

    hr = pEvent->QueryInterface(IID_ITPhoneEvent, (void **)&pPhoneEvent);

    if (SUCCEEDED(hr))
    {
        hr = pPhoneEvent->get_Event( &pe );

        if (SUCCEEDED(hr))
        {
            hr = pPhoneEvent->get_Phone( &pPhone );

            if ( SUCCEEDED(hr) )
            {
                switch( pe )
                {
                case PE_DISPLAY:
                    ::MessageBox(NULL, L"", L"PE_DISPLAY", MB_OK);
                    break;
                case PE_LAMPMODE:
                    ::MessageBox(NULL, L"", L"PE_LAMPMODE", MB_OK);
                    break;
                case PE_RINGMODE:
                    ::MessageBox(NULL, L"", L"PE_RINGMODE", MB_OK);
                    break;          
                case PE_RINGVOLUME:
                    ::MessageBox(NULL, L"", L"PE_RINGVOLUME", MB_OK);
                    break;            
                case PE_HOOKSWITCH:
                    {
                        PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice;
                        PHONE_HOOK_SWITCH_STATE HookSwitchState;
                        WCHAR szText[256];

                        hr = pPhoneEvent->get_HookSwitchDevice( &HookSwitchDevice );

                        if ( SUCCEEDED(hr) )
                        {
                            hr = pPhoneEvent->get_HookSwitchState( &HookSwitchState );
                            
                            if ( SUCCEEDED(hr) )
                            {
                                switch( HookSwitchDevice )
                                {
                                case PHSD_HANDSET:
                                    lstrcpyW(szText, L"PHSD_HANDSET");
                                    break;
                                case PHSD_SPEAKERPHONE:
                                    lstrcpyW(szText, L"PHSD_SPEAKERPHONE");
                                    break;
                                case PHSD_HEADSET:
                                    lstrcpyW(szText, L"PHSD_HEADSET");
                                    break;
                                }

                                switch( HookSwitchState )
                                {
                                case PHSS_ONHOOK:
                                    lstrcatW(szText, L" PHSS_ONHOOK");
                                    break;
                                case PHSS_OFFHOOK:
                                    lstrcatW(szText, L" PHSS_OFFHOOK");
                                    break;
                                }

                                //::MessageBox(NULL, szText, L"PE_HOOKSWITCH", MB_OK);
                            }
                        }
                    }
                    break;            
                case PE_CAPSCHANGE:
                    ::MessageBox(NULL, L"", L"PE_CAPSCHANGE", MB_OK);
                    break;            
                case PE_BUTTON:
                    {
                        long lButtonId;
                        BSTR pButtonText;
                        WCHAR szText[256];
                        PHONE_BUTTON_STATE ButtonState;

                        hr = pPhoneEvent->get_ButtonLampId( &lButtonId );

                        if ( SUCCEEDED(hr) )
                        {
                            hr = pPhone->get_ButtonText( lButtonId, &pButtonText );
                            
                            if ( SUCCEEDED( hr ) )
                            {
                                lstrcpyW(szText, pButtonText);
                                //wsprintf(szText, L"%d", lButtonId);

                                hr = pPhoneEvent->get_ButtonState( &ButtonState );

                                if ( SUCCEEDED( hr ) )
                                {
                                    switch( ButtonState )
                                    {
                                    case PBS_UP:
                                        lstrcatW(szText, L" PBS_UP");

                                        /*
                                        if ((lButtonId >= PT_KEYPADZERO) && (lButtonId <= PT_KEYPADPOUND))
                                        {
                                            ITAutomatedPhoneControl * pPhoneControl;

                                            //
                                            // get the automated phone control interface
                                            //
                                            hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

                                            if (S_OK != hr)
                                            {
                                                ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
                                                return;
                                            }
                                            
                                            PHONE_TONE Tone;
                                            pPhoneControl->get_Tone(&Tone);

                                            if ((long)Tone == lButtonId)
                                            {
                                                hr = pPhoneControl->StopTone();
                                            }
                                            
                                            pPhoneControl->Release();
                                        }
                                        */
                                        break;
                                    case PBS_DOWN:
                                        lstrcatW(szText, L" PBS_DOWN");

                                        /*
                                        if ((lButtonId >= PT_KEYPADZERO) && (lButtonId <= PT_KEYPADPOUND))
                                        {
                                            ITAutomatedPhoneControl * pPhoneControl;

                                            //
                                            // get the automated phone control interface
                                            //
                                            hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

                                            if (S_OK != hr)
                                            {
                                                ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
                                                return;
                                            }

                                            hr = pPhoneControl->StartTone((PHONE_TONE)lButtonId, 0);

                                            pPhoneControl->Release();
                                        }
                                        */
                                        break;
                                    case PBS_UNKNOWN:
                                        lstrcatW(szText, L" PBS_UNKNOWN");
                                        break;
                                    case PBS_UNAVAIL:
                                        lstrcatW(szText, L" PBS_UNAVAIL");
                                        break;
                                    }

                                    //::MessageBox(NULL, szText, L"PE_BUTTON", MB_OK);
                                }

                                //SysFreeString( pButtonText );
                            }
                        }
                    }
                    break;            
                case PE_CLOSE:
                    ::MessageBox(NULL, L"", L"PE_CLOSE", MB_OK);
                    break;           
                case PE_NUMBERGATHERED:
                    {
                        BSTR pNumberGathered;

                        hr = pPhoneEvent->get_NumberGathered( &pNumberGathered );

                        if ( SUCCEEDED(hr) && (pNumberGathered != NULL) )
                        {
                            ::MessageBox(NULL, pNumberGathered, L"PE_NUMBERGATHERED", MB_OK);
                        }
                    }
                    break; 
                }

                pPhone->Release();
            }
        }

        pPhoneEvent->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\gets.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetMediaTypeName
//
// Convert the mediatype bstr to a string, like
// "audio in"
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::GetMediaTypeName(
                                  long lMediaType,
                                  LPWSTR szString
                                 )
{
    if (lMediaType == (long)LINEMEDIAMODE_AUTOMATEDVOICE)
    {
        lstrcpyW(
                 szString,
                 L"Audio"
                );

    }
    else if (lMediaType == (long)LINEMEDIAMODE_VIDEO)
    {
        lstrcpyW(
                 szString,
                 L"Video"
                );

    }
    else if (lMediaType == (long)LINEMEDIAMODE_DATAMODEM)
    {
        lstrcpyW(
                 szString,
                 L"DataModem"
                );

    }
    else if (lMediaType == (long)LINEMEDIAMODE_G3FAX)
    {
        lstrcpyW(
                 szString,
                 L"G3Fax"
                );

    }
    else
    {
        lstrcpyW(
                 szString,
                 L"Unknown MediaType - "
                );
    }

    
}

LPWSTR CT3testDlg::GetCallPrivilegeName(
                                        ITCallInfo * pCall
                                       )
{
    CALL_PRIVILEGE      cp;
    HRESULT             hr;
   
    hr = pCall->get_Privilege( &cp );

    if ( SUCCEEDED(hr) )
    {
        if (CP_OWNER == cp)
        {
            return SysAllocString(L"OWNER");
        
        }
        else
        {
            return SysAllocString(L"MONITOR");
        }
    }

    return NULL;
}

LPWSTR CT3testDlg::GetPhonePrivilegeName(
                                        ITPhone * pPhone
                                       )
{
    PHONE_PRIVILEGE      pp;
    HRESULT              hr;
    
    hr = pPhone->get_Privilege( &pp );

    if ( SUCCEEDED(hr) )
    {
        if (PP_OWNER == pp)
        {
            return SysAllocString(L"OWNER");
        
        }
        else
        {
            return SysAllocString(L"MONITOR");
        }
    }

    return NULL;
}


LPWSTR CT3testDlg::GetCallStateName(
                                    ITCallInfo * pCall
                                   )
{
    CALL_STATE          cs;
    
    //
    // get the current call state
    //
    pCall->get_CallState( &cs );

    //
    // make the name
    //
    switch( cs )
    {
        case CS_INPROGRESS:

            return SysAllocString( L"INPROGRESS" );
            break;

        case CS_CONNECTED:

            return SysAllocString ( L"CONNECTED" );
            break;

        case CS_DISCONNECTED:

            return SysAllocString ( L"DISCONNECTED" );
            break;

        case CS_OFFERING:

            return SysAllocString ( L"OFFERING" );
            break;

        case CS_IDLE:

            return SysAllocString( L"IDLE" );
            break;

        default:

            return SysAllocString( L"<Unknown Call State>" );
            break;
    }


    return NULL;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetAddress
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetAddress( ITAddress ** ppAddress )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghAddressesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghAddressesWnd,
                     &item
                    );

    *ppAddress = (ITAddress *)item.lParam;

    if (NULL == *ppAddress)
    {
//        ::MessageBox(NULL, L"Select an Address", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetTerminal( ITTerminal ** ppTerminal )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghTerminalsWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghTerminalsWnd,
                     &item
                    );

    *ppTerminal = (ITTerminal *)item.lParam;

    if (NULL == *ppTerminal)
    {
        ::MessageBox(NULL, L"Select a Terminal", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetPhone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetPhone( ITPhone ** ppPhone )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghPhonesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghPhonesWnd,
                     &item
                    );

    *ppPhone = (ITPhone *)item.lParam;

    if (NULL == *ppPhone)
    {
        //::MessageBox(NULL, L"Select a Phone", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetCall( ITCallInfo ** ppCallInfo )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghCallsWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghCallsWnd,
                     &item
                    );

    *ppCallInfo = (ITCallInfo *)item.lParam;

    if (NULL == *ppCallInfo)
    {
        //::MessageBox(NULL, L"Select a Call", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetMediaType
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetMediaType( long * plMediaType )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghMediaTypesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghMediaTypesWnd,
                     &item
                    );

    *plMediaType = (long)(item.lParam);

    if (0 == *plMediaType)
    {
        return FALSE;
    }

    return TRUE;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetTerminalClass
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetTerminalClass( BSTR * pbstrClass )
{
    HTREEITEM       hItem;
    TV_ITEM         item;
    GUID *          pguid;

    hItem = TreeView_GetSelection(
                                  ghClassesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghClassesWnd,
                     &item
                    );

    pguid = (GUID *)item.lParam;

    if (NULL == pguid)
    {
        return FALSE;
    }

    LPWSTR      lphold;

    
    StringFromIID(
                  *pguid,
                  &lphold
                 );

    *pbstrClass = SysAllocString(lphold);

    CoTaskMemFree(lphold);
    
    return TRUE;
}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetCreatedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetCreatedTerminal( ITTerminal ** ppTerminal )
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    hItem = TreeView_GetSelection(
                                  ghCreatedWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghCreatedWnd,
                     &item
                    );

    *ppTerminal = (ITTerminal *)item.lParam;

    if (NULL == *ppTerminal)
    {
        return FALSE;
    }

    return TRUE;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetSelectedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetSelectedTerminal( ITTerminal ** ppTerminal )
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    hItem = TreeView_GetSelection(
                                  ghSelectedWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghSelectedWnd,
                     &item
                    );

    *ppTerminal = (ITTerminal *)item.lParam;

    if (NULL == *ppTerminal)
    {
        return FALSE;
    }

    return TRUE;
}


BSTR CT3testDlg::GetTerminalClassName( GUID * pguid )
{
    if (IsEqualIID( *pguid, CLSID_VideoWindowTerm ))
    {
        return SysAllocString( L"Video" );
    }

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    else if (IsEqualIID( *pguid, CLSID_DigitTerminal ))
    {
        return SysAllocString( L"Digit Terminal" );
    }
    else if (IsEqualIID( *pguid, CLSID_DataTerminal ))
    {
        return SysAllocString( L"Data Terminal" );
    }
#endif // ENABLE_DIGIT_DETECTION_STUFF

    else
    {
        return SysAllocString( L"Unknown Dynamic Type" );
    }

    return NULL;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetSelectedCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetSelectedCall( ITCallInfo ** ppCall )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghSelectedCallsWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghSelectedCallsWnd,
                     &item
                    );

    *ppCall = (ITCallInfo *)item.lParam;

    if (NULL == *ppCall)
    {
        //::MessageBox(NULL, L"Select a Call", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by t3test.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_T3TEST_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDD_CREATECALL                  129
#define IDR_DIGITPOPUP                  130
#define IDD_AUTOANSWER                  131
#define IDD_CONFDLG                     132
#define IDD_ILSSERVERS                  133
#define IDD_ILSSERVERNAME               134
#define IDD_RATE                        135
#define IDC_ADDRESSES                   1000
#define IDC_MEDIATYPES                  1001
#define IDC_TERMINALS                   1002
#define IDC_CALLS                       1003
#define IDC_CREATECALL                  1004
#define IDC_CONNECT                     1005
#define IDC_ANSWER                      1006
#define IDC_DROP                        1007
#define IDC_ADDTERMINAL                 1008
#define IDC_REMOVETERMINAL              1009
#define IDC_DESTADDRESS                 1010
#define IDC_PHONES                      1010
#define IDC_SELECTEDTERMINALS           1011
#define IDC_LISTEN                      1012
#define IDC_RELEASE                     1013
#define IDC_CREATE                      1014
#define IDC_RELEASETERMINAL             1015
#define IDC_SELECTEDCALLS               1016
#define IDC_CREATEDTERMINALS            1017
#define IDC_DYNAMICCLASSES              1018
#define IDC_ADDCREATED                  1019
#define IDC_ADDNULL                     1020
#define IDC_LISTENMEDIAMODES            1021
#define IDC_ADDTOLISTEN                 1022
#define IDC_LISTENALL                   1023
#define IDC_CONFIGAUTOANSWER            1024
#define IDC_SELECTED                    1025
#define IDC_NOTSELECTED                 1026
#define IDC_TERMINALADD                 1027
#define IDC_TERMINALREMOVE              1028
#define IDC_CONFLIST                    1029
#define IDC_ILS                         1029
#define IDC_ILSLIST                     1030
#define IDC_ADD                         1031
#define IDC_REMOVE                      1032
#define IDC_SERVERNAME                  1033
#define IDC_RATE                        1034
#define IDC_MINRATE                     1035
#define IDC_MAXRATE                     1036
#define IDC_OPENPHONE                   1037
#define IDC_CLOSEPHONE                  1038
#define IDC_STARTTONE                   1039
#define IDC_STOPTONE                    1040
#define IDC_STARTRING                   1041
#define IDC_STOPRING                    1042
#define IDC_BUSYTONE                    1043
#define IDC_RINGBACKTONE                1044
#define IDC_ERRORTONE                   1045
#define IDC_PHONEAUTOON                 1046
#define IDC_PHONEAUTOOFF                1047
#define IDC_SELECTCALL                  1048
#define IDC_UNSELECTCALL                1049
#define IDC_PHONESPEAKERONHOOK          1050
#define IDC_PHONESPEAKEROFFHOOK         1051
#define ID_MODESUPPORTED                32771
#define ID_GENERATE                     32772
#define ID_MODESUPPORTED2               32773
#define ID_STARTDETECT                  32774
#define ID_STOPDETECT                   32775
#define ID_NOTHING                      32776
#define ID_PARK1                        32778
#define ID_PARK2                        32779
#define ID_HANDOFF1                     32780
#define ID_HANDOFF2                     32781
#define ID_UNPARK                       32782
#define ID_PICKUP1                      32783
#define ID_PICKUP2                      32784

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32773
#define _APS_NEXT_CONTROL_VALUE         1051
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\release.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseAddresses
//
// Release all the address objects in the address tree
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseAddresses()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;

    //
    // get the first address
    //
    hItem = TreeView_GetChild(
                              ghAddressesWnd,
                              ghAddressesRoot
                             );

    //
    // go through all the addresses
    // and release
    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        ITAddress * pAddress;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghAddressesWnd,
                         &item
                        );

        pAddress = (ITAddress *)item.lParam;

        if (NULL != pAddress)
        {
            pAddress->Release();
        }
        

        hNewItem = TreeView_GetNextSibling(
                                        ghAddressesWnd,
                                        hItem
                                       );
        //
        // delete the item
        //
        TreeView_DeleteItem(
                            ghAddressesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

    //TreeView_DeleteAllItems(ghAddressesWnd);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseMediaTypes
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseMediaTypes()
{
    HTREEITEM           hItem;
    TV_ITEM             item;
    BSTR                pMediaType;

    gbUpdatingStuff = TRUE;
    
    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the mediatypes
    // and free the associated strings
    // and delete the item from the
    // tree
    //
    hItem = TreeView_GetChild(
                              ghMediaTypesWnd,
                              ghMediaTypesRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                           ghMediaTypesWnd,
                                           hItem
                                          );


        //
        // delete the item
        //
        TreeView_DeleteItem(
                            ghMediaTypesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

    gbUpdatingStuff = FALSE;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseListen
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseListen()
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // delete all the leave on the listen
    // tree
    // there are no resources associated with
    // this, so nothing to free
    //
    hItem = TreeView_GetChild(
                              ghListenWnd,
                              ghListenRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                        ghListenWnd,
                                        hItem
                                       );

        TreeView_DeleteItem(
                            ghListenWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseTerminalClasses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseTerminalClasses()
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the terminal classes
    // free the memory allocated for the
    // guid, and delete the item
    //
    hItem = TreeView_GetChild(
                              ghClassesWnd,
                              ghClassesRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        GUID *      pGuid;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghClassesWnd,
                         &item
                        );

        pGuid = (GUID *)item.lParam;
        delete pGuid;

        hNewItem = TreeView_GetNextSibling(
                                           ghClassesWnd,
                                           hItem
                                          );

        TreeView_DeleteItem(
                            ghClassesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseTerminalClasses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseTerminals()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go though all the terminals, and
    // free the terminals, and delete the
    // item
    //
    hItem = TreeView_GetChild(
                              ghTerminalsWnd,
                              ghTerminalsRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITTerminal *        pTerminal;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghTerminalsWnd,
                         &item
                        );

        pTerminal = (ITTerminal *)item.lParam;

        pTerminal->Release();

        hNewItem = TreeView_GetNextSibling(
                                        ghTerminalsWnd,
                                        hItem
                                       );
    

        TreeView_DeleteItem(
                            ghTerminalsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleasePhones
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleasePhones()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go though all the phones, and
    // free the phones, and delete the
    // item
    //
    hItem = TreeView_GetChild(
                              ghPhonesWnd,
                              ghPhonesRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITPhone *           pPhone;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghPhonesWnd,
                         &item
                        );

        pPhone = (ITPhone *)item.lParam;

        pPhone->Release();

        hNewItem = TreeView_GetNextSibling(
                                        ghPhonesWnd,
                                        hItem
                                       );
    

        TreeView_DeleteItem(
                            ghPhonesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseSelectedTerminals
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseSelectedTerminals()
{
    HTREEITEM               hItem;
    TV_ITEM                 item;

    
    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the selected terminals
    // and free and delete
    //
    hItem = TreeView_GetChild(
                              ghSelectedWnd,
                              ghSelectedRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITTerminal *        pTerminal;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghSelectedWnd,
                         &item
                        );

        pTerminal = (ITTerminal *)item.lParam;

        pTerminal->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghSelectedWnd,
                                           hItem
                                          );


        TreeView_DeleteItem(
                            ghSelectedWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseCalls()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the calls, and
    // release and delete
    //
    hItem = TreeView_GetChild(
                              ghCallsWnd,
                              ghCallsRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITCallInfo *        pCallInfo;

        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghCallsWnd,
                         &item
                        );

        pCallInfo = (ITCallInfo *)item.lParam;

        pCallInfo->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghCallsWnd,
                                           hItem
                                          );
    

        TreeView_DeleteItem(
                            ghCallsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseSelectedCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseSelectedCalls()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the calls, and
    // release and delete
    //
    hItem = TreeView_GetChild(
                              ghSelectedCallsWnd,
                              ghSelectedCallsRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITCallInfo *        pCallInfo;

        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghSelectedCallsWnd,
                         &item
                        );

        pCallInfo = (ITCallInfo *)item.lParam;

        pCallInfo->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghSelectedCallsWnd,
                                           hItem
                                          );
    

        TreeView_DeleteItem(
                            ghSelectedCallsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseCreatedTerminals
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseCreatedTerminals()
{
    HTREEITEM hItem;
    TV_ITEM item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    

    //
    // go through all the created terminals
    // and release and delete
    //
    hItem = TreeView_GetChild(
                              ghCreatedWnd,
                              ghCreatedRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM hNewItem;
        ITTerminal * pTerminal;

        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghCreatedWnd,
                         &item
                        );

        pTerminal = (ITTerminal *)item.lParam;

        pTerminal->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghCreatedWnd,
                                           hItem
                                          );
    

        TreeView_DeleteItem(
                            ghCreatedWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\csamsp\common.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    common.h

Abstract:

    commonly used headers.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/
#ifndef __COMMON_H_
#define __COMMON_H_

#include <mmsystem.h>
#include <mmreg.h>
#include <mtype.h>
#include <g711uids.h>
#include <evcode.h>

#include "csamsp.h"
#include "propbag.h"
#include "csaaddr.h"
#include "csastrm.h"
#include "csacall.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\t3testd.h ===
// t3testDlg.h : header file
//

#if !defined(AFX_T3TESTDLG_H__2584F27A_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_T3TESTDLG_H__2584F27A_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CT3testDlg dialog
#include "autoans.h"
class CT3testDlg : public CDialog
{
// Construction
public:
	CT3testDlg(CWnd* pParent = NULL);	// standard constructor
    void InitializeTrees();
    static void AddAddressToTree( ITAddress * pAddress );
    static void ReleaseAddresses( );
    static void SelectFirstItem(HWND hWnd,HTREEITEM hRoot);
    static void DeleteSelectedItem(HWND hWnd);
    static void UpdateMediaTypes(ITAddress * pAddress);
    static void UpdateCalls(ITAddress * pAddress);
    static void UpdateSelectedCalls(ITPhone * pPhone);
    static void UpdateTerminalClasses(ITAddress * pAddress,long lMediaType);
    static void UpdateTerminals(ITAddress * pAddress,long lMediaType);
    static void UpdatePhones(ITAddress * pAddress);
    static void CreateSelectedTerminalMenu(POINT pt, HWND);
    static void DoDigitGenerationTerminalMenu(HWND hWnd,POINT *);
    static void DoDigitDetectTerminalMenu(HWND hWnd, POINT *);
    static void CreateCallMenu(POINT pt, HWND hWnd);
    static void PutCaptions();
    static void HandleCallHubEvent( IDispatch * );
    static void HandleTapiObjectMessage( IDispatch * pEvent );
    static void HandleAddressEvent( IDispatch * pEvent );
    static void HandlePhoneEvent( IDispatch * pEvent );
    static LPWSTR GetCallPrivilegeName(ITCallInfo * pCall);
    static LPWSTR GetPhonePrivilegeName(ITPhone * pPhone);
    static LPWSTR GetCallStateName(ITCallInfo * pCall);
    static BSTR GetTerminalClassName( GUID * pguid );
    static void InitializeAddressTree();
    static void RegisterEventInterface();
    static void RegisterForCallNotifications();
    static void AddMediaType( long lMediaType );
    static void AddTerminal( ITTerminal * pTerminal );
    static void AddCreatedTerminal( ITTerminal * pTerminal );    
    static void AddCall( ITCallInfo * pCall );
    static void AddPhone( ITPhone * pPhone );
    static void UpdateCall( ITCallInfo * pCall );
    static void UpdatePhone( ITPhone * pPhone);
    static void AddSelectedTerminal( ITTerminal * pTerminal);
    static void AddSelectedCall( ITCallInfo *pCall);
    static void AddTerminalClass( GUID * );
    static void AddListen( long );
    static void ReleaseMediaTypes( );
    static void ReleaseTerminals();
    static void ReleaseCalls();
    static void ReleasePhones();
    static void ReleaseTerminalClasses();
    static void ReleaseCreatedTerminals();
    static void ReleaseDynamicClasses();
    static void ReleaseSelectedTerminals();
    static void ReleaseSelectedCalls();
    static void ReleaseListen();
    static void GetMediaTypeName( long, LPWSTR );
    static BOOL GetMediaType( long * plMediaType );
    static BOOL GetCall( ITCallInfo ** ppCall );
    static BOOL GetAddress( ITAddress ** ppAddress );
    static BOOL GetTerminal( ITTerminal ** ppTerminal );
    static BOOL GetPhone( ITPhone ** ppPhone );
    static BOOL GetTerminalClass( BSTR * pbstrClass );
    static BOOL GetCreatedTerminal( ITTerminal ** ppTerminal );
    static BOOL GetSelectedTerminal( ITTerminal ** ppTerminal );
    static BOOL GetSelectedCall( ITCallInfo ** ppCall );
    void FreeData( AADATA * pData );
    static void HelpCreateTerminal(
                               ITTerminalSupport * pTerminalSupport,
                               BSTR bstrClass,
                               long lMediaType,
                               TERMINAL_DIRECTION dir
                              );
    BOOL IsVideoCaptureStream(ITStream * pStream);
    HRESULT GetVideoRenderTerminal(ITTerminal ** ppTerminal) ;
    HRESULT SelectTerminalOnCall(ITTerminal * pTerminal, ITCallInfo * pCall);
    HRESULT EnablePreview(ITStream * pStream);
    void RemovePreview( ITStream * pStream );

    void DoAutoAnswer(ITCallInfo * pCall);
    afx_msg void OnClose() ;
// Dialog Data
	//{{AFX_DATA(CT3testDlg)
	enum { IDD = IDD_T3TEST_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CT3testDlg)
	public:
	virtual void OnFinalRelease();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CT3testDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnDestroy();
	afx_msg void OnSelchangedAddresses(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnAddterminal();
	afx_msg void OnRemoveterminal();
	afx_msg void OnCreatecall();
	afx_msg void OnConnect();
	afx_msg void OnDrop();
	afx_msg void OnAnswer();
	afx_msg void OnListen();
	afx_msg void OnSelchangedCalls(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelchangedPhones(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRelease();
	afx_msg void OnCreateTerminal();
	afx_msg void OnReleaseterminal();
	afx_msg void OnAddcreated();
	afx_msg void OnAddnull();
	afx_msg void OnAddtolisten();
	afx_msg void OnListenall();
    afx_msg void OnOpenPhone();
    afx_msg void OnClosePhone();
	afx_msg void OnSelchangedMediatypes(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRclickSelectedterminals(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnStartTone();
    afx_msg void OnStopTone();
    afx_msg void OnBusyTone();
    afx_msg void OnRingBackTone();
    afx_msg void OnErrorTone();
    afx_msg void OnStartRing();
    afx_msg void OnStopRing();
    afx_msg void OnPhoneAutoOn();
    afx_msg void OnPhoneAutoOff();
    afx_msg void OnPhoneSpeakerOnHook();
    afx_msg void OnPhoneSpeakerOffHook();
    afx_msg void OnSelectCall();
    afx_msg void OnUnselectCall();

#ifdef ENABLE_DIGIT_DETECTION_STUFF
	afx_msg void OnGenerate();
    afx_msg void OnModesSupported();
    afx_msg void OnModesSupported2();
    afx_msg void OnStartDetect();
    afx_msg void OnStopDetect();
#endif // ENABLE_DIGIT_DETECTION_STUFF

    afx_msg void OnConfigAutoAnswer();
    afx_msg void OnILS();
    afx_msg void OnRate();
    afx_msg void OnPark1();
    afx_msg void OnPark2();
    afx_msg void OnHandoff1();
    afx_msg void OnHandoff2();
    afx_msg void OnUnpark();
    afx_msg void OnPickup1();
    afx_msg void OnPickup2();

    
	afx_msg void OnRclickCalls(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG CT3testDlg::OnTapiEvent(UINT u, LONG_PTR l);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

HRESULT ListILSServers(
                       LPWSTR ** ppServers,
                       DWORD * pdwNumServers
                      );

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_T3TESTDLG_H__2584F27A_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\t3testd.cpp ===
// t3testDlg.cpp : implementation file
//

#include "stdafx.h"

#include <control.h> // for IVideoWindow

#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "uuids.h"
#include "autoans.h"
#include "confdlg.h"
#include "ilsdlg.h"
#include "rate.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

ITTAPI * gpTapi;
IConnectionPoint * gpCP;
HWND ghAddressesWnd;
HWND ghTerminalsWnd;
HWND ghMediaTypesWnd;
HWND ghCallsWnd;
HWND ghPhonesWnd;
HWND ghSelectedCallsWnd;
HWND ghSelectedWnd;
HWND ghCreatedWnd;
HWND ghClassesWnd;
HWND ghListenWnd;
HTREEITEM ghAddressesRoot;
HTREEITEM ghTerminalsRoot;
HTREEITEM ghMediaTypesRoot;
HTREEITEM ghCallsRoot;
HTREEITEM ghPhonesRoot;
HTREEITEM ghSelectedCallsRoot;
HTREEITEM ghSelectedRoot;
HTREEITEM ghCreatedRoot;
HTREEITEM ghClassesRoot;
HTREEITEM ghListenRoot;

#ifdef ENABLE_DIGIT_DETECTION_STUFF
CDigitDetectionNotification *   gpDigitNotification;
#endif // ENABLE_DIGIT_DETECTION_STUFF

long       gulAdvise;
BOOL gbUpdatingStuff = FALSE;
BOOL gfShuttingDown = FALSE;

DataPtrList       gDataPtrList;
extern CT3testApp theApp;

const BSTR TAPIMEDIATYPE_String_Audio = L"{028ED8C2-DC7A-11D0-8ED3-00C04FB6809F}";
const BSTR TAPIMEDIATYPE_String_Video = L"{028ED8C4-DC7A-11D0-8ED3-00C04FB6809F}";

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CT3testDlg dialog

CT3testDlg::CT3testDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CT3testDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CT3testDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CT3testDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CT3testDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CT3testDlg, CDialog)
	//{{AFX_MSG_MAP(CT3testDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_DESTROY()
	ON_NOTIFY(TVN_SELCHANGED, IDC_ADDRESSES, OnSelchangedAddresses)
	ON_BN_CLICKED(IDC_ADDTERMINAL, OnAddterminal)
	ON_BN_CLICKED(IDC_REMOVETERMINAL, OnRemoveterminal)
	ON_BN_CLICKED(IDC_CREATECALL, OnCreatecall)
	ON_BN_CLICKED(IDC_CONNECT, OnConnect)
	ON_BN_CLICKED(IDC_DROP, OnDrop)
	ON_BN_CLICKED(IDC_ANSWER, OnAnswer)
	ON_BN_CLICKED(IDC_LISTEN, OnListen)
	ON_NOTIFY(TVN_SELCHANGED, IDC_CALLS, OnSelchangedCalls)
    ON_NOTIFY(TVN_SELCHANGED, IDC_PHONES, OnSelchangedPhones)
	ON_BN_CLICKED(IDC_RELEASE, OnRelease)
	ON_BN_CLICKED(IDC_CREATE, OnCreateTerminal)
	ON_BN_CLICKED(IDC_RELEASETERMINAL, OnReleaseterminal)
	ON_BN_CLICKED(IDC_ADDCREATED, OnAddcreated)
	ON_BN_CLICKED(IDC_ADDNULL, OnAddnull)
	ON_BN_CLICKED(IDC_ADDTOLISTEN, OnAddtolisten)
	ON_BN_CLICKED(IDC_LISTENALL, OnListenall)
    ON_BN_CLICKED(IDC_CONFIGAUTOANSWER, OnConfigAutoAnswer)
    ON_BN_CLICKED(IDC_ILS, OnILS)
    ON_BN_CLICKED(IDC_RATE, OnRate)
    ON_BN_CLICKED(IDC_OPENPHONE, OnOpenPhone)
    ON_BN_CLICKED(IDC_CLOSEPHONE, OnClosePhone)
    ON_BN_CLICKED(IDC_STARTTONE, OnStartTone)
    ON_BN_CLICKED(IDC_STOPTONE, OnStopTone)
    ON_BN_CLICKED(IDC_STARTRING, OnStartRing)
    ON_BN_CLICKED(IDC_STOPRING, OnStopRing)
    ON_BN_CLICKED(IDC_BUSYTONE, OnBusyTone)
    ON_BN_CLICKED(IDC_RINGBACKTONE, OnRingBackTone)
    ON_BN_CLICKED(IDC_ERRORTONE, OnErrorTone)
    ON_BN_CLICKED(IDC_PHONEAUTOON, OnPhoneAutoOn)
    ON_BN_CLICKED(IDC_PHONEAUTOOFF, OnPhoneAutoOff)
    ON_BN_CLICKED(IDC_PHONESPEAKERONHOOK, OnPhoneSpeakerOnHook)
    ON_BN_CLICKED(IDC_PHONESPEAKEROFFHOOK, OnPhoneSpeakerOffHook)
    ON_BN_CLICKED(IDC_SELECTCALL, OnSelectCall)
    ON_BN_CLICKED(IDC_UNSELECTCALL, OnUnselectCall)
	ON_NOTIFY(TVN_SELCHANGED, IDC_MEDIATYPES, OnSelchangedMediatypes)
	ON_NOTIFY(NM_RCLICK, IDC_SELECTEDTERMINALS, OnRclickSelectedterminals)

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    ON_COMMAND(ID_GENERATE, OnGenerate)
    ON_COMMAND(ID_MODESUPPORTED, OnModesSupported)
    ON_COMMAND(ID_MODESUPPORTED2, OnModesSupported2)
    ON_COMMAND(ID_STARTDETECT, OnStartDetect)
    ON_COMMAND(ID_STOPDETECT, OnStopDetect)
#endif // ENABLE_DIGIT_DETECTION_STUFF
    
    ON_COMMAND(ID_PARK1, OnPark1)
    ON_COMMAND(ID_PARK2, OnPark2)
    ON_COMMAND(ID_HANDOFF1, OnHandoff1)
    ON_COMMAND(ID_HANDOFF2, OnHandoff2)
    ON_COMMAND(ID_UNPARK, OnUnpark)
    ON_COMMAND(ID_PICKUP1, OnPickup1)
    ON_COMMAND(ID_PICKUP2, OnPickup2)

    ON_WM_CLOSE()
    ON_MESSAGE(WM_USER+101, OnTapiEvent)
	ON_NOTIFY(NM_RCLICK, IDC_CALLS, OnRclickCalls)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CT3testDlg message handlers

BOOL CT3testDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

    HRESULT     hr;


    //
    // coinit
    //
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    //hr = CoInitialize(NULL);

    if (hr != S_OK)
    {
        MessageBox(L"CoInitialize failed", MB_OK);

        return FALSE;
    }


    //
    // create the tapi object
    //
    hr = CoCreateInstance(
        CLSID_TAPI,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITTAPI,
        (LPVOID *)&gpTapi
        );

    if (hr != S_OK)
    {
        ::MessageBox(NULL, L"CoCreateInstance on TAPI failed", NULL, MB_OK);
        return TRUE;
    }

    //
    // initialize tapi
    //
    hr = gpTapi->Initialize();

    if (hr != S_OK)
    {
        ::MessageBox(NULL, L"TAPI initialize failed", NULL, MB_OK);
        gpTapi->Release();
        return TRUE;
    }


    // Set the Event filter to only give us only the events we process
    gpTapi->put_EventFilter(TE_CALLNOTIFICATION | \
                            TE_CALLSTATE        | \
                            TE_CALLHUB          | \
                            TE_CALLMEDIA        | \
                            TE_TAPIOBJECT       | \
                            TE_ADDRESS          | \
                            TE_PHONEEVENT );

    //
    // intialize the tree controls
    //
    InitializeTrees();

    //
    // intialize the address tree control
    //
    InitializeAddressTree();

    //
    // register the main event interface
    //
    RegisterEventInterface();

    //
    // register for call notification for
    // all addresses for outgoing calls
    //
    RegisterForCallNotifications();
    
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CT3testDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CT3testDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CT3testDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CT3testDlg::OnFinalRelease() 
{
	// TODO: Add your specialized code here and/or call the base class

	CDialog::OnFinalRelease();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SelectFirstItem
//
// selects the first item under the hroot node in hwnd.
// this is used to make sure that something is selected
// in the window at all times.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::SelectFirstItem(
                                 HWND        hWnd,
                                 HTREEITEM   hRoot
                                )
{
    HTREEITEM           hChild;


    //
    // get the first item
    //
    hChild = TreeView_GetChild(
                               hWnd,
                               hRoot
                              );

    //
    // select it
    //
    TreeView_SelectItem(
                        hWnd,
                        hChild
                       );

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// DeleteSelectedItem
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::DeleteSelectedItem(
                                    HWND hWnd
                                   )
{
    HTREEITEM           hItem;

    //
    // get current selections
    // 
    hItem = TreeView_GetSelection( hWnd );


    //
    // delete it
    //
    TreeView_DeleteItem(
                        hWnd,
                        hItem
                       );
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//  InitializeAddressTree
//      initialize the address tree control with
//      the address objects
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::InitializeAddressTree()
{
    IEnumAddress *      pEnumAddress;
    ITAddress *         pAddress;
    HTREEITEM           hChild;
    HRESULT             hr;
    long                l;
    DWORD               dwCount = 0;
    
    //
    // get the address enumerator
    //
    
    hr = gpTapi->EnumerateAddresses( &pEnumAddress );

    if (S_OK != hr)
    {
        gpTapi->Release();
        gpTapi = NULL;

        return;
    }

    //
    // go through all the address objects
    // and add them to the address treecontrol
    //

    while (TRUE)
    {
        AADATA * pData;
        
        hr = pEnumAddress->Next( 1, &pAddress, NULL );

        if (S_OK != hr)
        {
            break;
        }

        AddAddressToTree( pAddress );

        pAddress->Release();

        pData = (AADATA *)CoTaskMemAlloc( sizeof ( AADATA ) );
        pData->pAddress = pAddress;
        pData->pTerminalPtrList = new TerminalPtrList;
        
        gDataPtrList.push_back( pData );

        dwCount++;
    }

    //
    // release the enumerator
    //
    pEnumAddress->Release();

    //
    // select the first item
    //
    if (dwCount > 0)
    {
        SelectFirstItem(
                        ghAddressesWnd,
                        ghAddressesRoot
                       );
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// RegisterEventInterface
//
// registers the ITTAPIEventNotification interface
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CT3testDlg::RegisterEventInterface()
{
    CTAPIEventNotification *        pTAPIEventNotification;
    IConnectionPointContainer *     pCPC;
    IConnectionPoint *              pCP;
    IUnknown *                      pUnk;
    
    //
    // create the object
    //
    pTAPIEventNotification = new CTAPIEventNotification;


    //
    // get the connectionpointcontainer interface
    // from the tapi object
    //
    gpTapi->QueryInterface(
                           IID_IConnectionPointContainer,
                           (void **) &pCPC
                          );


    //
    // get the connectionpoint we are
    // looking for
    //
    pCPC->FindConnectionPoint(
                              IID_ITTAPIEventNotification,
                              &gpCP
                             );

    pCPC->Release();

    pTAPIEventNotification->QueryInterface(
                                           IID_IUnknown,
                                           (void **)&pUnk
                                          );

    //
    // call the advise method to tell tapi
    // about the interface
    //
    gpCP->Advise(
                 pUnk,
                 (ULONG *)&gulAdvise
                );


    //
    // release our reference to
    // it
    //
    pUnk->Release();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RegisterForCallNotifications
//
// registers for call state notifications for all
// addresses for outgoing calls
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::RegisterForCallNotifications()
{
    VARIANT                 var;

    var.vt = VT_ARRAY;
    var.parray = NULL;
    
    gpTapi->SetCallHubTracking(var, VARIANT_TRUE);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// InitializeTrees
//
// Create and labels the tree controls
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::InitializeTrees()
{
    TV_INSERTSTRUCT tvi;

    tvi.hParent = TVI_ROOT;
    tvi.hInsertAfter = TVI_FIRST;
    tvi.item.mask = TVIF_TEXT;

    //
    // address tree
    //
    tvi.item.pszText = L"Addresses";

    ghAddressesWnd = GetDlgItem( IDC_ADDRESSES )->m_hWnd;
    ghAddressesRoot = TreeView_InsertItem(
                                          ghAddressesWnd,
                                          &tvi
                                         );

    //
    // mediatypes tree
    //
    tvi.item.pszText = L"MediaTypes";

    ghMediaTypesWnd = GetDlgItem( IDC_MEDIATYPES )->m_hWnd;
    ghMediaTypesRoot = TreeView_InsertItem(
                                          ghMediaTypesWnd,
                                          &tvi
                                         );

    //
    // terminals tree
    //
    tvi.item.pszText = L"Terminals";

    ghTerminalsWnd = GetDlgItem( IDC_TERMINALS )->m_hWnd;
    ghTerminalsRoot = TreeView_InsertItem(
                                          ghTerminalsWnd,
                                          &tvi
                                         );

    //
    // calls tree
    //
    tvi.item.pszText = L"Calls";
    
    ghCallsWnd = GetDlgItem( IDC_CALLS )->m_hWnd;
    ghCallsRoot = TreeView_InsertItem(
                                      ghCallsWnd,
                                      &tvi
                                     );

    //
    // phones tree
    //
    tvi.item.pszText = L"Phones";

    ghPhonesWnd = GetDlgItem( IDC_PHONES )->m_hWnd;
    ghPhonesRoot = TreeView_InsertItem(
                                          ghPhonesWnd,
                                          &tvi
                                         );

    //
    // selected calls tree
    //
    tvi.item.pszText = L"Selected Calls";
    
    ghSelectedCallsWnd = GetDlgItem( IDC_SELECTEDCALLS )->m_hWnd;
    ghSelectedCallsRoot = TreeView_InsertItem(
                                        ghSelectedCallsWnd,
                                        &tvi
                                       );

    //
    // selected media terminals tree
    //
    tvi.item.pszText = L"Selected Media Terminals";
    
    ghSelectedWnd = GetDlgItem( IDC_SELECTEDTERMINALS )->m_hWnd;
    ghSelectedRoot = TreeView_InsertItem(
                                        ghSelectedWnd,
                                        &tvi
                                       );

    //
    // dynamic terminal classes tree
    //
    tvi.item.pszText = L"Dynamic Terminal Classes";
    
    ghClassesWnd = GetDlgItem( IDC_DYNAMICCLASSES )->m_hWnd;
    ghClassesRoot = TreeView_InsertItem(
                                        ghClassesWnd,
                                        &tvi
                                       );

    //
    // created terminals tree
    //
    tvi.item.pszText = L"Created Terminals";
    
    ghCreatedWnd = GetDlgItem( IDC_CREATEDTERMINALS )->m_hWnd;
    ghCreatedRoot = TreeView_InsertItem(
                                        ghCreatedWnd,
                                        &tvi
                                       );

    //
    // listen mediatypes tree
    //
    tvi.item.pszText = L"Listen MediaTypes";
    
    ghListenWnd = GetDlgItem( IDC_LISTENMEDIAMODES )->m_hWnd;
    ghListenRoot = TreeView_InsertItem(
                                       ghListenWnd,
                                       &tvi
                                      );
    
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnDestroy
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnDestroy() 
{
	CDialog::OnDestroy();

    gfShuttingDown = TRUE;

    //
    // Release everything
    //
    ReleaseMediaTypes();
    ReleaseTerminals();
    ReleaseCalls();
    ReleasePhones();
    ReleaseSelectedTerminals();
    ReleaseSelectedCalls();
    ReleaseCreatedTerminals();
    ReleaseTerminalClasses();
    ReleaseListen();
    ReleaseAddresses();

    DataPtrList::iterator       iter, end;

    iter = gDataPtrList.begin();
    end  = gDataPtrList.end();
    
    for( ; iter != end; iter++ )
    {
        FreeData( *iter );

        delete (*iter)->pTerminalPtrList;
        
        CoTaskMemFree( *iter );
    }

    gDataPtrList.clear();
    

    if (NULL != gpCP)
    {
        gpCP->Unadvise(gulAdvise);
        gpCP->Release();
    }
    
    //
    // shutdown TAPI
    //
    if (NULL != gpTapi)
    {
        gpTapi->Shutdown();
        gpTapi->Release();
    }

}

void
DoAddressCapStuff(ITTAPI * pTapi);
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedAddresses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedAddresses(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW*            pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    ITAddress *             pAddress;


	*pResult = 0;


    //
    // free all the stuff related to
    // the address selected.  this stuff
    // will all be refilled in
    //
    ReleaseMediaTypes();
    ReleaseListen();
    ReleaseCalls();
    ReleasePhones();
    ReleaseSelectedCalls();
    ReleaseSelectedTerminals();
    ReleaseCreatedTerminals();
    

    //
    // get the currently selected address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }

    //
    // update these trees
    //
    if ( !gfShuttingDown )
    {
        UpdateMediaTypes( pAddress );
        UpdateCalls( pAddress );
        UpdatePhones( pAddress );
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedPhones
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedPhones(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW*            pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    ITPhone *               pPhone;


	*pResult = 0;


    //
    // free all the stuff related to
    // the phone selected.  this stuff
    // will all be refilled in
    //
    ReleaseSelectedCalls();
    

    //
    // get the currently selected phone
    //
    if (!GetPhone( &pPhone ))
    {
        return;
    }


    //
    // update these trees
    //
    if ( !gfShuttingDown )
    {
        UpdateSelectedCalls( pPhone );

    }
}

/////////////////////////////////////////////////////////////////
// IsVideoCaptureStream
//
// Returns true if the stream is for video capture
/////////////////////////////////////////////////////////////////

BOOL
CT3testDlg::IsVideoCaptureStream(
                     ITStream * pStream
                    )
{
    TERMINAL_DIRECTION tdStreamDirection;
    long               lStreamMediaType;

    if ( FAILED( pStream  ->get_Direction(&tdStreamDirection)   ) ) { return FALSE; }
    if ( FAILED( pStream  ->get_MediaType(&lStreamMediaType)    ) ) { return FALSE; }

    return (tdStreamDirection == TD_CAPTURE) &&
           (lStreamMediaType  == TAPIMEDIATYPE_VIDEO);
}

/////////////////////////////////////////////////////////////////
// EnablePreview
//
// Selects a video render terminal on a video capture stream,
// thereby enabling video preview.
/////////////////////////////////////////////////////////////////

HRESULT
CT3testDlg::EnablePreview(
              ITStream * pStream
             )
{
    ITTerminal * pTerminal;

    HRESULT hr = GetVideoRenderTerminal(&pTerminal);

    if ( SUCCEEDED(hr) )
    {
        hr = pStream->SelectTerminal(pTerminal);

        pTerminal->Release();
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SelectTerminalOnCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT
CT3testDlg::SelectTerminalOnCall(
                ITTerminal * pTerminal,
                ITCallInfo * pCall
               )
{
    ITStreamControl *       pStreamControl;
    TERMINAL_DIRECTION      termtd;
    long                    lTermMediaType;
    HRESULT hr;

    pTerminal->get_Direction( &termtd );
    pTerminal->get_MediaType( &lTermMediaType );
    
    hr = pCall->QueryInterface(
                               IID_ITStreamControl,
                               (void**) &pStreamControl
                              );

    if ( SUCCEEDED(hr) )
    {
        IEnumStream * pEnumStreams;
        
        hr = pStreamControl->EnumerateStreams( &pEnumStreams );

        if ( SUCCEEDED(hr) )
        {
            while (TRUE)
            {
                ITStream              * pStream;
                long                    lMediaType;
                TERMINAL_DIRECTION      td;
                
                hr = pEnumStreams->Next( 1, &pStream, NULL );

                if ( S_OK != hr )
                {
                    hr = E_FAIL; // didn't select it anywhere
                    break;
                }

                pStream->get_MediaType( &lMediaType );
                pStream->get_Direction( &td );

                if ( ( lMediaType == lTermMediaType ) &&
                     ( td == termtd) )
                {
                    hr = pStream->SelectTerminal( pTerminal );

                    if ( FAILED(hr) )
                    {
                        ::MessageBox(NULL, L"SelectTerminals failed", NULL, MB_OK);
                    }
                    else
                    {
                        //
                        // Also enable preview on the video capture stream.
                        //

                        if ( IsVideoCaptureStream( pStream ) )
                        {
                            EnablePreview( pStream );
                        }

                        pStream->Release();
                        
                        break;
                    }
                }
                
                pStream->Release();
            }

            pEnumStreams->Release();
        }

        pStreamControl->Release();
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::OnAddterminal() 
{
    ITCallInfo *            pCall;
    ITTerminal *            pTerminal;
    HRESULT                 hr = S_OK;

    //
    // get the selected call
    //
    if (!(GetCall( &pCall )))
    {
        return;
    }


    //
    // get the selected terminal
    //
    if (!(GetTerminal( &pTerminal )))
    {
        return;
    }

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"SelectTerminals failed", NULL, MB_OK);
        return;
    }
        
    hr = SelectTerminalOnCall(pTerminal, pCall);

    if ( FAILED(hr) )
    {
        return;
    }

    //
    // put the terminal in the
    // tree
    //
    AddSelectedTerminal(
                        pTerminal
                       );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RemovePreview
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::RemovePreview( ITStream * pStream )
{
    //
    // This is a video capture stream and we've unselected the
    // video capture terminal. If there is a video render
    // terminal on the stream, then unselect it now.
    //

    IEnumTerminal * pEnum;

    if ( FAILED( pStream->EnumerateTerminals( &pEnum ) ) )
    {
        return;
    }

    ITTerminal * pTerminal;

    if ( S_OK == pEnum->Next(1, &pTerminal, NULL) )
    {
        pStream->UnselectTerminal( pTerminal );
        pTerminal->Release();
    }

    pEnum->Release();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnRemoveTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnRemoveterminal() 
{
    ITTerminal *                pTerminal;
    ITCallInfo *                pCall;
    HTREEITEM                   hItem;
    HRESULT                     hr;
    ITBasicCallControl *        pBCC;

    

    //
    // get current call
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    //
    // get current terminal
    //
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    TERMINAL_DIRECTION termtd;
    long               lTermMediaType;

    pTerminal->get_Direction( &termtd );
    pTerminal->get_MediaType( &lTermMediaType );

    ITStreamControl * pStreamControl;
    
    hr = pCall->QueryInterface(
                               IID_ITStreamControl,
                               (void**) &pStreamControl
                              );

    BOOL bFound = FALSE;

    if ( SUCCEEDED(hr) )
    {
        IEnumStream * pEnumStreams;
        
        hr = pStreamControl->EnumerateStreams( &pEnumStreams );

        if ( SUCCEEDED(hr) )
        {
            while ( ! bFound )
            {
                ITStream              * pStream;
                long                    lMediaType;
                TERMINAL_DIRECTION      td;
                
                hr = pEnumStreams->Next( 1, &pStream, NULL );

                if ( S_OK != hr )
                {
                    break;
                }

                pStream->get_MediaType( &lMediaType );
                pStream->get_Direction( &td );

                if ( ( lMediaType == lTermMediaType ) &&
                     ( td == termtd) )
                {
                    hr = pStream->UnselectTerminal( pTerminal );

                    if ( !SUCCEEDED(hr) )
                    {
                        ::MessageBox(NULL, L"UnselectTerminals failed", NULL, MB_OK);
                    }
                    else
                    {
                        if ( IsVideoCaptureStream( pStream ) )
                        {
                            RemovePreview( pStream );
                        }

                        bFound = TRUE;
                    }

                }
                
                pStream->Release();
            }

            pEnumStreams->Release();
        }

        pStreamControl->Release();
    }


    if ( !bFound )
    {
        return;
    }

    //
    // remove it from tree
    //
    hItem = TreeView_GetSelection( ghSelectedWnd );
    TreeView_DeleteItem(
                        ghSelectedWnd,
                        hItem
                       );


    //
    // release tree's reference to
    // the terminal
    //
    pTerminal->Release();

	
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnCreateCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnCreatecall() 
{
    ITAddress *             pAddress;
    HRESULT                 hr;
    ITBasicCallControl *    pCall;
    ITCallInfo *            pCallInfo;
    BOOL                    bConference      = FALSE;
    BOOL                    lAddressType     = LINEADDRESSTYPE_PHONENUMBER;
    BSTR                    bstrDestAddress;
    ITAddressCapabilities * pAddressCaps;
    long                    lType = 0;
    ITMediaSupport *        pMediaSupport;
    long                    lSupportedMediaTypes, lMediaTypes = 0;
    
    //
    // get the current address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }


    hr = pAddress->QueryInterface(IID_ITAddressCapabilities, (void**)&pAddressCaps);

    hr = pAddressCaps->get_AddressCapability( AC_ADDRESSTYPES, &lType );

    if ( SUCCEEDED(hr) && (LINEADDRESSTYPE_SDP & lType) )
    {
        bConference = TRUE;
        lAddressType = LINEADDRESSTYPE_SDP;
    }

    if ( SUCCEEDED(hr) && (LINEADDRESSTYPE_DOMAINNAME & lType) )
    {
        lAddressType = LINEADDRESSTYPE_DOMAINNAME;
    }

    pAddressCaps->Release();
    
    if ( !bConference )
    {
        //
        // create the dialog to get the
        // dial string
        //
        CCreateCallDlg Dlg( this );


        if (IDOK == Dlg.DoModal())
        {
            //
            // create a call with the
            // string input in the dialog
            //
            bstrDestAddress = SysAllocString( Dlg.m_pszDestAddress );
        }
        else
        {
            return;
        }
    }
    else
    {
        CConfDlg    Dlg;

        if ( IDOK == Dlg.DoModal() )
        {
            bstrDestAddress = Dlg.m_bstrDestAddress;
        }
        else
        {
            return;
        }
    }

    //
    // Find out if the address supports audio, video, or both.
    //

    pAddress->QueryInterface(
                             IID_ITMediaSupport,
                             (void**)&pMediaSupport
                            );

    pMediaSupport->get_MediaTypes( &lSupportedMediaTypes );
                                  
    pMediaSupport->Release();


    if ( lSupportedMediaTypes & TAPIMEDIATYPE_AUDIO )
    {
        lMediaTypes |= TAPIMEDIATYPE_AUDIO;
    }

    if ( lSupportedMediaTypes & TAPIMEDIATYPE_VIDEO )
    {
        lMediaTypes |= TAPIMEDIATYPE_VIDEO;
    }

    if ( lMediaTypes == 0 )
    {
        if ( lSupportedMediaTypes & TAPIMEDIATYPE_DATAMODEM )
        {
            lMediaTypes |= TAPIMEDIATYPE_DATAMODEM;
        }
    }

    //
    // Create the call.
    //

    hr = pAddress->CreateCall(
                              bstrDestAddress,
                              lAddressType,
                              lMediaTypes,
                              &pCall
                             );

    SysFreeString( bstrDestAddress );


    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"CreateCall failed", NULL, MB_OK);
        return;
    }

    //
    // get the callinfo interface
    //
    pCall->QueryInterface( IID_ITCallInfo, (void **)&pCallInfo );


    //
    // add the call to the tree
    //
    AddCall(pCallInfo);

    //
    // update the callinfo
    //
    UpdateCall( pCallInfo );


    //
    // release this inteface
    //
    pCallInfo->Release();

    //
    // note that we keep a global reference to the call
    // (CreateCall returns with a reference count of 1)
    // so the call does not get destroyed.  When we want
    // the call to actually be destroyed, then we
    // release twice.
    //
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnOpenPhone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnOpenPhone() 
{
    ITPhone *                       pPhone;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // call connect
    //
    hr = pPhone->Open( PP_OWNER );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Open failed", NULL, MB_OK);
        return;
    }

    UpdatePhone( pPhone );
	
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnClosePhone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnClosePhone() 
{
    ITPhone *                       pPhone;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // call connect
    //
    hr = pPhone->Close();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Close failed", NULL, MB_OK);
        return;
    }
	
    UpdatePhone( pPhone );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnStartTone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnStartTone() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StartTone(PT_NORMALDIALTONE, 5000);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StartTone failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnBusyTone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnBusyTone() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StartTone(PT_BUSY, 10000);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StartTone failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnRingBackTone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnRingBackTone() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StartTone(PT_RINGBACK, 10000);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StartTone failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnErrorTone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnErrorTone() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StartTone(PT_ERRORTONE, 10000);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StartTone failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnStopTone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnStopTone() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StopTone();

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StopTone failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelectCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelectCall() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    ITCallInfo *                    pCall;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the current call
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    hr = pPhoneControl->SelectCall( pCall, VARIANT_TRUE );

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"OnSelectCall failed", NULL, MB_OK);
        return;
    }

    //
    // put the call in the
    // tree
    //
    AddSelectedCall(
                        pCall
                       );

    //
    // add the selected terminals to the tree
    //
    ITTerminal *    pTerminal;
    IEnumTerminal * pEnum;
    ITAddress *     pAddress;

    if (!GetAddress( &pAddress ))
    {
        return;
    }

    if ( FAILED( pPhone->EnumerateTerminals( pAddress, &pEnum ) ) )
    {
        return;
    }

    while ( S_OK == pEnum->Next(1, &pTerminal, NULL) )
    {
        AddSelectedTerminal( pTerminal );
        pTerminal->Release();
    }

    pEnum->Release();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnUnselectCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnUnselectCall() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    ITCallInfo *                    pCall;
    HRESULT                         hr = S_OK;
    HTREEITEM                       hItem;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the selected call
    //
    if (!GetSelectedCall( &pCall ))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    hr = pPhoneControl->UnselectCall( pCall );

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"OnUnselectCall failed", NULL, MB_OK);
        return;
    }

    //
    // remove it from tree
    //
    hItem = TreeView_GetSelection( ghSelectedCallsWnd );
    TreeView_DeleteItem(
                        ghSelectedCallsWnd,
                        hItem
                       );


    //
    // release tree's reference to
    // the terminal
    //
    pCall->Release();  
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnPhoneAutoOn
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnPhoneAutoOn() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    hr = pPhoneControl->put_PhoneHandlingEnabled(VARIANT_TRUE);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"OnPhoneAutoOn failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnPhoneAutoOff
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnPhoneAutoOff() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    hr = pPhoneControl->put_PhoneHandlingEnabled(VARIANT_FALSE);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"OnPhoneAutoOff failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnPhoneSpeakerOnHook
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnPhoneSpeakerOnHook() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    hr = pPhone->put_HookSwitchState( PHSD_SPEAKERPHONE, PHSS_ONHOOK );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"OnPhoneSpeakerOnHook failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnPhoneSpeakerOffHook
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnPhoneSpeakerOffHook() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    hr = pPhone->put_HookSwitchState( PHSD_SPEAKERPHONE, PHSS_OFFHOOK );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"OnPhoneSpeakerOffHook failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnStartRing
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnStartRing() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StartRinger(0, 0);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StartRing failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnStopRing
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnStopRing() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StopRinger();

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StopRing failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnConnect
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnConnect() 
{
    ITBasicCallControl *            pCall;
    ITCallInfo *                    pCallInfo;
    HRESULT                         hr = S_OK;


    //
    // get the current call
    //
    if (!GetCall( &pCallInfo))
    {
        return;
    }

    //
    // get the call control interface
    //
    hr = pCallInfo->QueryInterface(IID_ITBasicCallControl, (void **)&pCall);
    
    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Connect failed", NULL, MB_OK);
        return;
    }


    //
    // call connect
    //
    hr = pCall->Connect( FALSE );


    //
    // release this interface
    //
    pCall->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Connect failed", NULL, MB_OK);
        return;
    }
	
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnDrop
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnDrop() 
{
    ITBasicCallControl *        pCall;
    ITCallInfo *                pCallInfo;
    HRESULT                     hr =    S_OK;


    //
    // get the current call
    //
    if (!GetCall( &pCallInfo ))
    {
        return;
    }

    //
    // get the bcc interface
    //
    hr = pCallInfo->QueryInterface(
                                   IID_ITBasicCallControl,
                                   (void **)&pCall
                                  );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Disconnect failed", NULL, MB_OK);
        return;
    }


    //
    // call disconnect
    //
    hr = pCall->Disconnect( DC_NORMAL );

    //
    // release this reference
    //
    pCall->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Disconnect failed", NULL, MB_OK);
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnDrop
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnAnswer() 
{
    ITCallInfo *                pCallInfo;
    ITBasicCallControl *        pCall;
    HRESULT                     hr = S_OK;


    //
    // get the current call
    //
    if (!GetCall( &pCallInfo))
    {
        return;
    }

    //
    // get the bcc interface
    //
    hr = pCallInfo->QueryInterface(IID_ITBasicCallControl, (void **)&pCall);
    
    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Answer failed", NULL, MB_OK);
        return;
    }

    //
    // answer it
    //
    hr = pCall->Answer( );

    //
    // release this interface
    //
    pCall->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Answer failed", NULL, MB_OK);
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnListen
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnListen() 
{
    ITAddress *             pAddress;
    HRESULT                 hr = S_OK;
    DWORD                   dwCookie;
    HTREEITEM               hItem;
    long                    ulRegister;
    DWORD                   dwMediaMode = 0;


    //
    // get the current address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }


    hItem = TreeView_GetChild(
                              ghListenWnd,
                              ghListenRoot
                             );

    while (NULL != hItem)
    {
        TV_ITEM item;

        item.mask = TVIF_HANDLE | TVIF_PARAM;
        item.hItem = hItem;

        //
        // get it
        //
        TreeView_GetItem(
                         ghListenWnd,
                         &item
                        );

        dwMediaMode |= (DWORD)(item.lParam);

        hItem = TreeView_GetNextSibling(
                                        ghAddressesWnd,
                                        hItem
                                       );

    }

    hr = gpTapi->RegisterCallNotifications(
                                           pAddress,
                                           VARIANT_TRUE,
                                           VARIANT_TRUE,
                                           (long)dwMediaMode,
                                           gulAdvise,
                                           &ulRegister
                                          );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"RegisterCallNotifications failed", NULL, MB_OK);
    }

    //
    // release all the mediatypes
    // in the listen tree
    //
    ReleaseListen();
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedCalls(NMHDR* pNMHDR, LRESULT* pResult) 
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnRelease()
//
// this is called to release all references to a call
//
// if a call is selected it has two references - once for
// the tree control, and once for our global reference.
// release both here.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnRelease() 
{
    ITCallInfo *        pCallInfo;


    //
    // get the call
    //
    if (!GetCall( &pCallInfo ))
    {
        return;
    }

    //
    // these depend on the call,
    // so release them
    //
    ReleaseSelectedTerminals();
    ReleaseCreatedTerminals();

    //
    // delete it from the tree
    //
    DeleteSelectedItem(
                       ghCallsWnd
                      );

    //
    // release once for the tree view
    //
    pCallInfo->Release();

    //
    // release a second time for our global reference
    //
    pCallInfo->Release();

}

void
CT3testDlg::HelpCreateTerminal(
                               ITTerminalSupport * pTerminalSupport,
                               BSTR bstrClass,
                               long lMediaType,
                               TERMINAL_DIRECTION dir
                              )
{
    ITTerminal * pTerminal;
    HRESULT         hr;
    
    //
    // create it
    //
    hr = pTerminalSupport->CreateTerminal(
                                          bstrClass,
                                          lMediaType,
                                          dir,
                                          &pTerminal
                                         );

    if (S_OK != hr)
    {
        return;
    }

    // 
    // ZoltanS:
    // We do nothing special with our video windows. Just make them visible
    // all the time. If this isn't a video window we just skip this step.
    //

    IVideoWindow * pWindow;

    if ( SUCCEEDED( pTerminal->QueryInterface(IID_IVideoWindow,
                                              (void **) &pWindow) ) )
    {
        pWindow->put_AutoShow( VARIANT_TRUE );

        pWindow->Release();
    }


    //
    // add the terminal
    //
    AddCreatedTerminal(
                       pTerminal
                      );


    //
    // release our reference
    //
    pTerminal->Release();    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetVideoRenderTerminal
//
// this is used to create a video render terminal for preview
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT CT3testDlg::GetVideoRenderTerminal(ITTerminal ** ppTerminal) 
{
    //
    // Get the current address
    //

    ITAddress * pAddress;

    if (!GetAddress( &pAddress ))
    {
        return E_FAIL;
    }

    //
    // get the terminal support interface
    //

    ITTerminalSupport * pTerminalSupport;
    HRESULT hr;

    hr = pAddress->QueryInterface(
                                  IID_ITTerminalSupport,
                                  (void **) &pTerminalSupport
                                 );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Construct a BSTR for the correct IID.
    //

    LPOLESTR            lpTerminalClass;

    hr = StringFromIID(CLSID_VideoWindowTerm,
                       &lpTerminalClass);

    BSTR                bstrTerminalClass;

    if ( FAILED(hr) )
    {
        pTerminalSupport->Release();
        return hr;
    }

    bstrTerminalClass = SysAllocString ( lpTerminalClass );

    CoTaskMemFree( lpTerminalClass );

    if ( bstrTerminalClass == NULL )
    {
        pTerminalSupport->Release();
        return E_OUTOFMEMORY;
    }
    
    //
    // create it
    //

    hr = pTerminalSupport->CreateTerminal(
                                          bstrTerminalClass,
                                          TAPIMEDIATYPE_VIDEO,
                                          TD_RENDER,
                                          ppTerminal
                                         );

    pTerminalSupport->Release();

    if ( FAILED(hr) )
    {
        *ppTerminal = NULL;
        return hr;
    }

    // 
    // We do nothing special with our video windows. Just make them visible
    // all the time.
    //

    IVideoWindow * pWindow;

    if ( FAILED( (*ppTerminal)->QueryInterface(IID_IVideoWindow,
                                               (void **) &pWindow) ) )
    {
        (*ppTerminal)->Release();
        *ppTerminal = NULL;

        return hr;
    }

    pWindow->put_AutoShow( VARIANT_TRUE );

    pWindow->Release();

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnCreateTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnCreateTerminal() 
{
    //
    // Get the selected media type.
    //

    long lMediaType;

    if (!GetMediaType( &lMediaType ))
    {
        return;
    }

    //
    // Get the current address
    //

    ITAddress * pAddress;

    if (!GetAddress( &pAddress ))
    {
        return;
    }

    //
    // Get the selected terminal class.
    //

    BSTR bstrClass;

    if (!GetTerminalClass( &bstrClass ))
    {
        return;
    }

    //
    // get the terminal support interface
    //

    ITTerminalSupport * pTerminalSupport;
    HRESULT hr;

    hr = pAddress->QueryInterface(
                                  IID_ITTerminalSupport,
                                  (void **) &pTerminalSupport
                                 );

    if ( FAILED(hr) )
    {
        SysFreeString( bstrClass );
        return;
    }

    //
    // Convert the terminal class from a BSTR to an IID.
    //

    IID iidTerminalClass;

    IIDFromString(
                bstrClass,
                &iidTerminalClass
               );

    //
    // Create and add the terminal.
    //

    if ( CLSID_VideoWindowTerm == iidTerminalClass )
    {
        HelpCreateTerminal(
                           pTerminalSupport,
                           bstrClass,
                           lMediaType,
                           TD_RENDER
                          );
    }

    //
    // Release references.
    //

    pTerminalSupport->Release();

    SysFreeString(bstrClass);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnReleaseTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnReleaseterminal() 
{
    ITTerminal * pTerminal;

    //
    // get the terminal
    //
    if (GetCreatedTerminal( &pTerminal ))
    {
        //
        // and release it!
        //
        pTerminal->Release();

        //
        // delete it from the tree
        //
        DeleteSelectedItem(
                           ghCreatedWnd
                          );
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddCreated
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnAddcreated() 
{
    ITTerminal *            pTerminal;
    ITCallInfo *            pCall;
    HRESULT                 hr = S_OK;
    ITBasicCallControl *    pBCC;
    

    //
    // get the current call
    //

    if (!(GetCall( &pCall )))
    {
        return;
    }

    //
    // GetCreatedTerminal
    //

    if (!GetCreatedTerminal( &pTerminal ))
    {
        return;
    }

    //
    // Select the terminal on the call.
    //

    hr = SelectTerminalOnCall(pTerminal, pCall);

    if ( FAILED(hr) )
    {
        ::MessageBox(NULL, L"SelectTerminals failed", NULL, MB_OK);
        return;
    }

    //
    // add to the selected window
    //

    AddSelectedTerminal(
                        pTerminal
                       );

    //
    // delete from the created window
    //

    DeleteSelectedItem(
                       ghCreatedWnd
                      );

    //
    // release because there was a reference to
    // this terminal in the created wnd
    //

    pTerminal->Release();
    return;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddNull
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::OnAddnull() 
{
    return;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddToListen
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::OnAddtolisten() 
{
    long lMediaType;

    //
    // get the current mediatype
    //
    if (!GetMediaType( &lMediaType ))
    {
        return;
    }

    //
    // add it
    //
    AddListen( lMediaType );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnListenAll
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnListenall() 
{
    ITAddress *             pAddress;
    HRESULT                 hr = S_OK;
    long                    ulRegister;
    long                    lMediaType;
    ITMediaSupport        * pMediaSupport;
    
    //
    // get the currently selected address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }

    pAddress->QueryInterface(
                             IID_ITMediaSupport,
                             (void **)&pMediaSupport
                            );
    
    pMediaSupport->get_MediaTypes( &lMediaType );
    
    //
    // register
    //
    gpTapi->RegisterCallNotifications(
                                      pAddress,
                                      TRUE,
                                      TRUE,
                                      lMediaType,
                                      gulAdvise,
                                      &ulRegister
                                     );

    
    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"RegisterCallTypes failed", NULL, MB_OK);
    }

	
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedMedia
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedMediatypes(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW*            pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    long                    lMediaType;
    ITAddress *             pAddress;
    HRESULT                 hr;

	*pResult = 0;

    if (gbUpdatingStuff)
        return;

    //
    // get the current mediatype
    //
    if (!GetMediaType( &lMediaType ))
    {
        return;
    }

    //
    // get the current address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }

    //
    // we only show terminals that relate
    // to the selected mediatype
    // so get rid of the old ones
    //
    ReleaseTerminals();
    ReleaseTerminalClasses();

    UpdateTerminals( pAddress, lMediaType );
    UpdateTerminalClasses( pAddress, lMediaType );
    
}

void CT3testDlg::OnRclickSelectedterminals(NMHDR* pNMHDR, LRESULT* pResult) 
{
    POINT                   pt;
    HTREEITEM               hItem;
    TV_HITTESTINFO          hittestinfo;
    RECT                    rc;

    
    *pResult = 0;

    //
    // get the location of the cursor
    //
    GetCursorPos( &pt );

    //
    // get the control's window
    //
    ::GetWindowRect(
                    ghSelectedWnd,
                    &rc
                   );

    //
    // adjust the point to
    // the child's coords
    //
    hittestinfo.pt.x = pt.x - rc.left;
    hittestinfo.pt.y = pt.y - rc.top;


    //
    // hittest to get the tree view item
    //
    hItem = TreeView_HitTest(
                             ghSelectedWnd,
                             &hittestinfo
                            );


    //
    // only display a menu if the mouse is actually
    // over the item (TVHT_ONITEM)
    //
    if (hItem == NULL || (!(hittestinfo.flags & TVHT_ONITEM)) )
    {
        return;
    }


    //
    // select that item (right clicking will not select
    // by default
    //
    TreeView_Select(
                    ghSelectedWnd,
                    hItem,
                    TVGN_CARET
                   );

    CreateSelectedTerminalMenu(
                               pt,
                               m_hWnd
                              );
}


#ifdef ENABLE_DIGIT_DETECTION_STUFF

void CT3testDlg::OnModesSupported()
{
	ITTerminal *                    pTerminal;
    ITDigitGenerationTerminal *     pDigitGeneration;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;

    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitGenerationTerminal,
                                   (void **) &pDigitGeneration
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    pDigitGeneration->get_ModesSupported( &lDigits );

    pDigitGeneration->Release();
}


void CT3testDlg::OnGenerate()
{
	ITTerminal *                    pTerminal;
    ITDigitGenerationTerminal *     pDigitGeneration;
    HRESULT                         hr = S_OK;


    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitGenerationTerminal,
                                   (void **) &pDigitGeneration
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    hr = pDigitGeneration->Generate(
                                    L"12345",
                                    LINEDIGITMODE_DTMF
                                   );

    pDigitGeneration->Release();
}

void CT3testDlg::OnModesSupported2()
{
	ITTerminal *                    pTerminal;
    ITDigitDetectionTerminal *      pDigitDetection;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;

    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetection
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    pDigitDetection->get_ModesSupported( &lDigits );

    pDigitDetection->Release();
}

void CT3testDlg::OnStartDetect()
{
	ITTerminal *                    pTerminal;
    ITDigitDetectionTerminal *      pDigitDetection;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;
    ULONG                           ulAdvise;
    IConnectionPointContainer *     pCPC;
    IConnectionPoint *              pCP;
    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetection
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }


    hr = pTerminal->QueryInterface(
                                   IID_IConnectionPointContainer,
                                   (void **)&pCPC
                                  );

    if (!SUCCEEDED(hr))
    {
        pDigitDetection->Release();
        return;
    }

    gpDigitNotification = new CDigitDetectionNotification;
    
    hr = pCPC->FindConnectionPoint(
                                   IID_ITDigitDetectionNotification,
                                   &pCP
                                  );

    pCPC->Release();

    IUnknown * pUnk;
    
    gpDigitNotification->QueryInterface(
                                        IID_IUnknown,
                                        (void**)&pUnk
                                       );
    
    hr = pCP->Advise(
                     pUnk,
                     &ulAdvise
                    );

    pUnk->Release();
    
    pCP->Release();
    
    pDigitDetection->StartDetect(LINEDIGITMODE_DTMF);

    pDigitDetection->Release();
}

void CT3testDlg::OnStopDetect()
{
	ITTerminal *                    pTerminal;
    ITDigitDetectionTerminal *      pDigitDetection;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;

    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetection
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    pDigitDetection->StopDetect();

    pDigitDetection->Release();
}

#endif // ENABLE_DIGIT_DETECTION_STUFF



void CT3testDlg::OnRclickCalls(NMHDR* pNMHDR, LRESULT* pResult) 
{
    POINT                   pt;
    HTREEITEM               hItem;
    TV_HITTESTINFO          hittestinfo;
    RECT                    rc;

    
    *pResult = 0;

    //
    // get the location of the cursor
    //
    GetCursorPos( &pt );

    //
    // get the control's window
    //
    ::GetWindowRect(
                    ghCallsWnd,
                    &rc
                   );

    //
    // adjust the point to
    // the child's coords
    //
    hittestinfo.pt.x = pt.x - rc.left;
    hittestinfo.pt.y = pt.y - rc.top;


    //
    // hittest to get the tree view item
    //
    hItem = TreeView_HitTest(
                             ghCallsWnd,
                             &hittestinfo
                            );


    //
    // only display a menu if the mouse is actually
    // over the item (TVHT_ONITEM)
    //
    if (hItem == NULL || (!(hittestinfo.flags & TVHT_ONITEM)) )
    {
        return;
    }


    //
    // select that item (right clicking will not select
    // by default
    //
    TreeView_Select(
                    ghCallsWnd,
                    hItem,
                    TVGN_CARET
                   );

}

void CT3testDlg::OnConfigAutoAnswer()
{
    ITAddress * pAddress;
    autoans dlg;
    DataPtrList::iterator   dataiter, dataend;
    
    if (!GetAddress( &pAddress ) )
    {
        return;
    }

    dataiter = gDataPtrList.begin();
    dataend  = gDataPtrList.end();

    for ( ; dataiter != dataend; dataiter++ )
    {
        if ( pAddress == (*dataiter)->pAddress )
        {
            break;
        }
    }

    if ( dataiter == dataend )
    {
        return;
    }

    FreeData( (*dataiter) );
    
    if (IDOK == dlg.DoModal())
    {
        TerminalPtrList::iterator       iter, end;
        DWORD                           dwCount;
        long                            lRegister;
        HRESULT                         hr;
        long                            lMediaType = 0;
        
        dwCount = dlg.m_TerminalPtrList.size();

        if ( 0 == dwCount )
        {
            return;
        }
        
        iter = dlg.m_TerminalPtrList.begin();
        end  = dlg.m_TerminalPtrList.end();
        
        for ( ; iter != end ; iter++ )
        {
            long        l;
            
            (*dataiter)->pTerminalPtrList->push_back( *iter );

            if ( NULL != (*iter) )
            {
                (*iter)->get_MediaType( &l );
                lMediaType |= l;
            }
            else
            {
                lMediaType |= (long)LINEMEDIAMODE_VIDEO;
            }

        }

        //
        // call register call types
        //
        hr = gpTapi->RegisterCallNotifications(
                                               pAddress,
                                               VARIANT_FALSE,
                                               VARIANT_TRUE,
                                               lMediaType,
                                               0,
                                               &lRegister
                                              );

    }

}
void CT3testDlg::FreeData( AADATA * pData )
{
    TerminalPtrList::iterator       iter, end;

    iter = pData->pTerminalPtrList->begin();
    end  = pData->pTerminalPtrList->end();

    for ( ; iter != end; iter++ )
    {
        if ( NULL != (*iter) )
        {
            (*iter)->Release();
        }
    }

    pData->pTerminalPtrList->clear();
}

void CT3testDlg::OnClose() 
{
	CDialog::OnClose();
}


void CT3testDlg::OnILS()
{
    CILSDlg dlg;

    if (IDOK == dlg.DoModal())
    {
    }
    
}

void CT3testDlg::OnRate()
{
    CRateDlg dlg;
    ITCallInfo * pCallInfo;

    if ( !GetCall( &pCallInfo ) )
    {
        return;
    }

    if (IDOK == dlg.DoModal() )
    {
        pCallInfo->put_CallInfoLong(CIL_MINRATE, dlg.m_dwMinRate );
        pCallInfo->put_CallInfoLong(CIL_MAXRATE, dlg.m_dwMaxRate );
    }
}

void CT3testDlg::OnPark1()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;
    
    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void**)&pBCC
                         );
    
    hr = pBCC->ParkDirect( L"101");
    
    pBCC->Release();

}
void CT3testDlg::OnPark2()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;
    BSTR                    pAddress;

    
    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );

    hr = pBCC->ParkIndirect( &pAddress );

    SysFreeString( pAddress );

    pBCC->Release();
    

}
void CT3testDlg::OnHandoff1()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );

    pBCC->HandoffDirect( L"tb20.exe" );

    pBCC->Release();
    
}
void CT3testDlg::OnHandoff2()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;


    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );

    pBCC->HandoffIndirect( TAPIMEDIATYPE_AUDIO );

    pBCC->Release();

}
void CT3testDlg::OnUnpark()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );


    pBCC->Unpark();

    pBCC->Release();
    
}
void CT3testDlg::OnPickup1()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );


    pBCC->Pickup( NULL );

    pBCC->Release();
}
void CT3testDlg::OnPickup2()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\csamsp\csaaddr.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    waveaddr.cpp 

Abstract:

    This module contains implementation of CWaveMSP.

Author:
    
    Zoltan Szilagyi (zoltans)   September 7, 1998

--*/

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSP::CWaveMSP()
{
    LOG((MSP_TRACE, "CWaveMSP::CWaveMSP entered."));
    LOG((MSP_TRACE, "CWaveMSP::CWaveMSP exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSP::~CWaveMSP()
{
    LOG((MSP_TRACE, "CWaveMSP::~CWaveMSP entered."));
    LOG((MSP_TRACE, "CWaveMSP::~CWaveMSP exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

ULONG CWaveMSP::MSPAddressAddRef(void)
{
    return MSPAddRefHelper(this);
}

ULONG CWaveMSP::MSPAddressRelease(void)
{
    return MSPReleaseHelper(this);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSP::CreateMSPCall(
    IN      MSP_HANDLE      htCall,
    IN      DWORD           dwReserved,
    IN      DWORD           dwMediaType,
    IN      IUnknown     *  pOuterUnknown,
    OUT     IUnknown    **  ppMSPCall
    )
{
    LOG((MSP_TRACE, "CWaveMSP::CreateMSPCall - enter"));

    CWaveMSPCall * pCWaveMSPCall;

    HRESULT hr = CreateMSPCallHelper<CWaveMSPCall>(this,
                                                   htCall,
                                                   dwReserved,
                                                   dwMediaType,
                                                   pOuterUnknown,
                                                   ppMSPCall,
                                                   &pCWaveMSPCall);

    //
    // pCWaveMSPCall is not addrefed; no need to release.
    //

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSP::CreateMSPCall - template helper returned"
            "0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSP::CreateMSPCall - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSP::ShutdownMSPCall (
    IN      IUnknown *          pMSPCall
    )
{
    LOG((MSP_TRACE, "CWaveMSP::ShutdownMSPCall - enter"));

    CWaveMSPCall * pCWaveMSPCall;

    HRESULT hr = ShutdownMSPCallHelper<CWaveMSPCall>(pMSPCall,
                                                     &pCWaveMSPCall);

    //
    // pCWaveMSPCall is not addrefed; no need to release.
    //

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSP::ShutdownMSPCall - template helper returned"
            "0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSP::ShutdownMSPCall - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Mandatory CMSPAddress override. This indicates the media types that
// we support.
//

DWORD CWaveMSP::GetCallMediaTypes(void)
{
    return (DWORD) TAPIMEDIATYPE_AUDIO;
}


// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\t3testph\updates.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateMediaTypes
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateMediaTypes(
                                  ITAddress * pAddress
                                 )
{
    long                    lMediaType;
    ITMediaSupport *        pMediaSupport;
    HRESULT                 hr;
    

    //
    // get the media support interface
    //
    pAddress->QueryInterface(
                             IID_ITMediaSupport,
                             (void **)&pMediaSupport
                            );

    //
    // get the mediatype enumerator
    //
    pMediaSupport->get_MediaTypes(&lMediaType);


    //
    // release the interface
    //
    pMediaSupport->Release();


    gbUpdatingStuff = TRUE;

    
    //
    // go through the supported mediatypes
    //
    DWORD       dwMediaType = 1;
    DWORD       dwHold = (DWORD)lMediaType;

    while (dwMediaType)
    {
        if ( dwMediaType & dwHold )
        {
            AddMediaType( (long) dwMediaType );
        }

        dwMediaType <<=1;
    }


    gbUpdatingStuff = FALSE;

    //
    // select the first
    // media type
    //
    SelectFirstItem(
                    ghMediaTypesWnd,
                    ghMediaTypesRoot
                   );


    //
    // release and redo terminals
    //
    ReleaseTerminals();
    ReleaseTerminalClasses();

    if ( GetMediaType( &lMediaType ) )
    {
        UpdateTerminals( pAddress, lMediaType );
        UpdateTerminalClasses( pAddress, lMediaType );
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateCalls(
                             ITAddress * pAddress
                            )
{
    IEnumCall *             pEnumCall;
    HRESULT                 hr;
    ITCallInfo *            pCallInfo;

    //
    // enumerate the current calls
    //
    pAddress->EnumerateCalls( &pEnumCall );


    //
    // go through the list
    // and add the calls to the tree
    //
    while (TRUE)
    {
        hr = pEnumCall->Next( 1, &pCallInfo, NULL);

        if (S_OK != hr)
        {
            break;
        }

        AddCall(pCallInfo);

        UpdateCall( pCallInfo );

        //
        // release this reference
        //
        pCallInfo->Release();
    }

    pEnumCall->Release();
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateSelectedCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateSelectedCalls(
                             ITPhone * pPhone
                            )
{
    IEnumCall *             pEnumCall;
    HRESULT                 hr;
    ITCallInfo *            pCallInfo;
    ITAutomatedPhoneControl * pPhoneControl;

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        return;
    }
    //
    // enumerate the current calls
    //
    pPhoneControl->EnumerateSelectedCalls( &pEnumCall );

    pPhoneControl->Release();

    //
    // go through the list
    // and add the calls to the tree
    //
    while (TRUE)
    {
        hr = pEnumCall->Next( 1, &pCallInfo, NULL);

        if (S_OK != hr)
        {
            break;
        }

        AddSelectedCall(pCallInfo);

        //
        // release this reference
        //
        pCallInfo->Release();
    }

    pEnumCall->Release();
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateCall
//
// check the call's state and privelege, and update the call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateCall( ITCallInfo * pCall )
{
    HTREEITEM               hItem, hParent;
    TV_ITEM                 item;
    CALL_PRIVILEGE          cp;
    CALL_STATE              cs;
    TV_INSERTSTRUCT         tvi;
    

    //
    // get the first call
    //
    item.mask = TVIF_HANDLE | TVIF_PARAM;
    
    
    hItem = TreeView_GetChild(
                              ghCallsWnd,
                              ghCallsRoot
                             );

    //
    // go through all the calls
    // and look for the one that matches
    // the one passed in
    //
    while (NULL != hItem)
    {
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghCallsWnd,
                         &item
                        );

        if ( item.lParam == (LPARAM)pCall )
        {
            break;
        }

        hItem = TreeView_GetNextSibling(
                                        ghCallsWnd,
                                        hItem
                                       );
    }

    //
    // did we find it?
    //
    if (NULL == hItem)
    {
        return;
    }

    
    hParent = hItem;

    //
    // delete the current children of the call
    // node (these are the old privelege and state
    //
    hItem = TreeView_GetChild(
                              ghCallsWnd,
                              hItem
                             );

    
    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                           ghCallsWnd,
                                           hItem
                                          );

        TreeView_DeleteItem(
                            ghCallsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

    tvi.hInsertAfter = TVI_LAST;

    //
    // get the current privilege
    //
    tvi.item.pszText = GetCallPrivilegeName( pCall );

    //
    // add it as a child of the
    // call node
    //
    tvi.hParent = hParent;
    tvi.item.mask = TVIF_TEXT;

    TreeView_InsertItem(
                        ghCallsWnd,
                        &tvi
                       );

    SysFreeString( tvi.item.pszText );
    
    //
    // get the current callstate
    //
    tvi.item.pszText = GetCallStateName( pCall );
    
    //
    // add it as a child of the call
    // node
    //
    tvi.hParent = hParent;
    tvi.item.mask = TVIF_TEXT;

    TreeView_InsertItem(
                        ghCallsWnd,
                        &tvi
                       );

    SysFreeString( tvi.item.pszText );

    
}

void CT3testDlg::UpdatePhones(
                                 ITAddress * pAddress
                                )
{
    ITAddress2 *            pAddress2;
    IEnumPhone *            pEnumPhones;
    HRESULT                 hr;
    ITPhone *               pPhone;
    
    
    //
    // get the address2 interface
    //
    hr = pAddress->QueryInterface(
                             IID_ITAddress2,
                             (void **) &pAddress2
                            );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    //
    // enumerate the phones
    //
    pAddress2->EnumeratePhones( &pEnumPhones );

    //
    // go through the phones
    //
    while (TRUE)
    {      
        hr = pEnumPhones->Next( 1, &pPhone, NULL);

        if (S_OK != hr)
        {
            break;
        }

        AddPhone(pPhone);

        UpdatePhone(pPhone);

        //
        // release
        //
        pPhone->Release();
    }

    //
    // release enumerator
    //
    pEnumPhones->Release();

    //
    // release
    //
    pAddress2->Release();

    //
    // select
    //
    SelectFirstItem(
                    ghPhonesWnd,
                    ghPhonesRoot
                   );

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdatePhone
//
// check the call's state and privelege, and update the call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdatePhone( ITPhone * pPhone )
{
    HTREEITEM               hItem, hParent;
    TV_ITEM                 item;
    PHONE_PRIVILEGE         pp;
    TV_INSERTSTRUCT         tvi;
    
    //
    // get the first phone
    //
    item.mask = TVIF_HANDLE | TVIF_PARAM;
    
    
    hItem = TreeView_GetChild(
                              ghPhonesWnd,
                              ghPhonesRoot
                             );

    //
    // go through all the phones
    // and look for the one that matches
    // the one passed in
    //
    while (NULL != hItem)
    {
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghPhonesWnd,
                         &item
                        );

        if ( item.lParam == (LPARAM)pPhone )
        {
            break;
        }

        hItem = TreeView_GetNextSibling(
                                        ghPhonesWnd,
                                        hItem
                                       );
    }

    //
    // did we find it?
    //
    if (NULL == hItem)
    {
        return;
    }

    
    hParent = hItem;

    //
    // delete the current children of the phone
    // node (these are the old privelege)
    //
    hItem = TreeView_GetChild(
                              ghPhonesWnd,
                              hItem
                             );

    
    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                           ghPhonesWnd,
                                           hItem
                                          );

        TreeView_DeleteItem(
                            ghPhonesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

    tvi.hInsertAfter = TVI_LAST;

    //
    // get the current privilege
    //
    if (tvi.item.pszText = GetPhonePrivilegeName( pPhone ))
    {
        //
        // add it as a child of the
        // call node
        //
        tvi.hParent = hParent;
        tvi.item.mask = TVIF_TEXT;

        TreeView_InsertItem(
                            ghPhonesWnd,
                            &tvi
                           );

        SysFreeString( tvi.item.pszText );
    }      
}

void CT3testDlg::UpdateTerminals(
                                 ITAddress * pAddress,
                                 long lMediaType
                                )
{
    ITTerminalSupport *     pTerminalSupport;
    IEnumTerminal *         pEnumTerminals;
    HRESULT                 hr;
    ITTerminal *            pTerminal;
    
    
    //
    // get the terminalsupport interface
    //
    hr = pAddress->QueryInterface(
                             IID_ITTerminalSupport,
                             (void **) &pTerminalSupport
                            );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    //
    // enumerate the terminals
    //
    pTerminalSupport->EnumerateStaticTerminals( &pEnumTerminals );

    //
    // go through the terminals
    //
    while (TRUE)
    {
        VARIANT_BOOL        bSupport;
        BSTR                bstr;
        long                l;

        
        hr = pEnumTerminals->Next( 1, &pTerminal, NULL);

        if (S_OK != hr)
        {
            break;
        }

        //
        // get the name
        //
        hr = pTerminal->get_Name( &bstr );

        //
        // if it's a unimodem or a direct sound
        // device don't show it, cause they bother
        // me
        //
        if (wcsstr( bstr, L"Voice Modem" ) || wcsstr( bstr, L"ds:" ) )
        {
            pTerminal->Release();
            SysFreeString( bstr );
            
            continue;
        }

        //
        // free the name
        //
        SysFreeString( bstr );

        //
        // get the mediatype of the terminal
        //
        pTerminal->get_MediaType( &l );

        //
        // if it's the same as the selected mediatype
        // show it
        //
        if ( l == lMediaType )
        {
            AddTerminal(pTerminal);
        }

        //
        // release
        //
        pTerminal->Release();
    }

    //
    // release enumerator
    //
    pEnumTerminals->Release();

    //
    // release
    //
    pTerminalSupport->Release();

    //
    // select
    //
    SelectFirstItem(
                    ghTerminalsWnd,
                    ghTerminalsRoot
                   );

}


void CT3testDlg::UpdateTerminalClasses(
                                       ITAddress * pAddress,
                                       long lMediaType
                                      )
{
    IEnumTerminalClass *        pEnumTerminalClasses;
    HRESULT                     hr;
    ITTerminalSupport *         pTerminalSupport;

    hr = pAddress->QueryInterface(
                             IID_ITTerminalSupport,
                             (void **)&pTerminalSupport
                            );


    if (!SUCCEEDED(hr))
    {
        return;
    }
    
    //
    // now enum dymnamic
    //
    hr = pTerminalSupport->EnumerateDynamicTerminalClasses( &pEnumTerminalClasses );

    if (S_OK == hr)
    {
        
        //
        // go through all the classes
        //
        while (TRUE)
        {
            GUID *                  pDynTerminalClass = new GUID;

            hr = pEnumTerminalClasses->Next(
                                            1,
                                            pDynTerminalClass,
                                            NULL
                                           );

            if (S_OK != hr)
            {
                delete pDynTerminalClass;
                break;
            }

            //
            // manually match up mediatype and
            // class
            //
            if ( (lMediaType == (long)LINEMEDIAMODE_VIDEO) &&
                 (*pDynTerminalClass == CLSID_VideoWindowTerm) )
            {

                AddTerminalClass(
                                 pDynTerminalClass
                                );
            }

#ifdef ENABLE_DIGIT_DETECTION_STUFF
            else if ( (lMediaType == (long)LINEMEDIAMODE_AUTOMATEDVOICE) &&
                      ( *pDynTerminalClass == CLSID_DigitTerminal ) )
            {
                AddTerminalClass(
                                 pDynTerminalClass
                                );
            }
            else if ( ((lMediaType == (long)LINEMEDIAMODE_DATAMODEM) ||
                       (lMediaType == (long)LINEMEDIAMODE_G3FAX)) &&
                      (*pDynTerminalClass == CLSID_DataTerminal) )
            {
                AddTerminalClass( pDynTerminalClass );
            }
#endif // ENABLE_DIGIT_DETECTION_STUFF


            else
            {
                delete pDynTerminalClass;
            }

        }

        //
        // release enumerator
        //
        pEnumTerminalClasses->Release();

    }
    
    //
    // release this interface
    //
    pTerminalSupport->Release();
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\csamsp\csaaddr.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    waveaddr.h

Abstract:

    Declaration of the CWaveMSP

Author:
    
    Zoltan Szilagyi September 6th, 1998

--*/

#ifndef __WAVEADDR_H_
#define __WAVEADDR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CWaveMSP
/////////////////////////////////////////////////////////////////////////////
class CWaveMSP : 
    public CMSPAddress,
    public CComCoClass<CWaveMSP, &CLSID_CSAMSP>,
    public CMSPObjectSafetyImpl
{
public:
    CWaveMSP();
    virtual ~CWaveMSP();

    // BUGUBG document it
    virtual ULONG MSPAddressAddRef(void);
    virtual ULONG MSPAddressRelease(void);

DECLARE_REGISTRY_RESOURCEID(IDR_WaveMSP)
DECLARE_POLY_AGGREGATABLE(CWaveMSP)

// To add extra interfaces to this class, use the following:
BEGIN_COM_MAP(CWaveMSP)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_CHAIN(CMSPAddress)
END_COM_MAP()

public:
    STDMETHOD (CreateMSPCall) (
        IN      MSP_HANDLE     htCall,
        IN      DWORD          dwReserved,
        IN      DWORD          dwMediaType,
        IN      IUnknown    *  pOuterUnknown,
        OUT     IUnknown   **  ppMSPCall
        );

    STDMETHOD (ShutdownMSPCall) (
        IN      IUnknown *          pMSPCall
        );

protected:

    DWORD GetCallMediaTypes(void);
};

#endif //__WAVEADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\csamsp\csacall.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wavecall.cpp 

Abstract:

    This module contains implementation of CWaveMSPCall.

Author:
    
    Zoltan Szilagyi (zoltans)   September 7, 1998

--*/

#include "stdafx.h"

#include <commctrl.h>   // ONLY to compile unimdmp.h
#include <setupapi.h>   // ONLY to compile unimdmp.h
#include <unimdmp.h>


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSPCall::CWaveMSPCall() : CMSPCallMultiGraph()
{
    LOG((MSP_TRACE, "CWaveMSPCall::CWaveMSPCall entered."));
    LOG((MSP_TRACE, "CWaveMSPCall::CWaveMSPCall exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSPCall::~CWaveMSPCall()
{
    LOG((MSP_TRACE, "CWaveMSPCall::~CWaveMSPCall entered."));
    LOG((MSP_TRACE, "CWaveMSPCall::~CWaveMSPCall exited."));
}

ULONG CWaveMSPCall::MSPCallAddRef(void)
{
    return MSPAddRefHelper(this);
}

ULONG CWaveMSPCall::MSPCallRelease(void)
{
    return MSPReleaseHelper(this);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

HRESULT CWaveMSPCall::Init(
    IN      CMSPAddress *       pMSPAddress,
    IN      MSP_HANDLE          htCall,
    IN      DWORD               dwReserved,
    IN      DWORD               dwMediaType
    )
{
    // No need to acquire locks on this call because it is called only
    // once when the object is created. No other calls can be made on
    // this object at this point.

    LOG((MSP_TRACE, "CWaveMSPCall::Init - enter"));
    
    //
    // First do the base class method. We are adding to the functionality,
    // not replacing it.
    //

    HRESULT hr;

    hr = CMSPCallMultiGraph::Init(pMSPAddress,
                                   htCall,
                                   dwReserved,
                                   dwMediaType);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "base class method failed: %x", hr));

        return hr;
    }

    //
    // Our calls always come with two streams. Create them now. Use the base class
    // methods, as our overriden methods (exposed to the user) purposely fail in order
    // to keep the user from creating or removing streams themselves.
    // These methods return a pointer to the ITStream. They get saved in our list of
    // ITStreams, and we also save them here as CWaveMSPStream pointers.
    //

    ITStream * pStream;

    //
    // Create the capture stream.
    //

    hr = InternalCreateStream (dwMediaType,
                               TD_CAPTURE,
                               &pStream);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "couldn't create capture stream: %x", hr));

        return hr;
    }

    m_pCaptureStream = dynamic_cast<CWaveMSPStream *> (pStream);

    if ( m_pCaptureStream == NULL )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "couldn't dynamic_cast capture stream - exit E_FAIL"));

        return E_FAIL;
    }

    pStream->Release();
 
    //
    // Create the render stream.
    //

    hr = InternalCreateStream (dwMediaType,
                               TD_RENDER,
                               &pStream);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "couldn't create capture stream: %x", hr));

        return hr;
    }

    m_pRenderStream = dynamic_cast<CWaveMSPStream *> (pStream);

    if ( m_pRenderStream == NULL )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "couldn't dynamic_cast render stream - exit E_FAIL"));

        return E_FAIL;
    }

    pStream->Release();

    LOG((MSP_TRACE, "CWaveMSPCall::Init - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// We override this to make sure the number of
// streams we have is constant.
//

STDMETHODIMP CWaveMSPCall::CreateStream (
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN OUT  ITStream **         ppStream
    )
{
    LOG((MSP_TRACE, "CWaveMSPCall::CreateStream entered."));
    LOG((MSP_TRACE, "CWaveMSPCall::CreateStream - "
        "we have a fixed set of streams - exit TAPI_E_MAXSTREAMS"));

    return TAPI_E_MAXSTREAMS;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// We override this to make sure the number of
// streams we have is constant.
//

STDMETHODIMP CWaveMSPCall::RemoveStream (
    IN      ITStream *          pStream
    )
{
    LOG((MSP_TRACE, "CWaveMSPCall::RemoveStream entered."));
    LOG((MSP_TRACE, "CWaveMSPCall::RemoveStream - "
        "we have a fixed set of streams - exit TAPI_E_NOTSUPPORTED"));

    return TAPI_E_NOTSUPPORTED;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// This is our override to create the right kind of stream on stream creation.
// The base class checks the arguments for us.
//

HRESULT CWaveMSPCall::CreateStreamObject(
        IN      DWORD               dwMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN      IMediaEvent *       pGraph,
        IN      ITStream **         ppStream
        )
{
    LOG((MSP_TRACE, "CWaveMSPCall::CreateStreamObject - enter"));

    HRESULT hr;
    CMSPComObject<CWaveMSPStream> * pStream;
 
    hr = CMSPComObject<CWaveMSPStream>::CreateInstance( &pStream );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::CreateStreamObject - "
            "can't create stream object - 0x%08x", hr));

        return hr;
    }

    hr = pStream->_InternalQueryInterface( IID_ITStream,
                                           (void **) ppStream );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::CreateStreamObject - "
            "can't get ITStream interface - 0x%08x", hr));

        delete pStream;
        return hr;
    }

    hr = pStream->Init( (MSP_HANDLE) m_pMSPAddress,
                       this,
                       pGraph,
                       dwMediaType,
                       Direction);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::CreateStreamObject - "
            "can't Init stream object - 0x%08x", hr));

        (*ppStream)->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSPCall::CreateStreamObject - exit S_OK"));
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// First DWORD =	Command		Second DWORD	Third DWORD
// 0		Set wave IDs		WaveIn ID		WaveOut ID
// 1		Start streaming	<ignored>		<ignored>
// 2		Stop streaming	<ignored>		<ignored>
//
// The method returns S_OK even if an individual stream failed to
// start, stop, or initialize. This is because TAPI 3.0 doesn't need to
// know about streaming failures in this code path. Instead, we should
// generate events to note failures.
//

HRESULT CWaveMSPCall::ReceiveTSPCallData(
    IN      PBYTE               pBuffer,
    IN      DWORD               dwSize
    )
{
    CSATSPMSPBLOB   *Blob=(CSATSPMSPBLOB*)pBuffer;

    LOG((MSP_TRACE, "CWaveMSPCall::ReceiveTSPCallData - enter"));

    //
    // Check that the buffer is as big as advertised.
    //

    if ( IsBadReadPtr(pBuffer, sizeof(BYTE) * dwSize) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
            "bad buffer - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Check if we have a command DWORD.
    //

    if ( dwSize < sizeof(CSATSPMSPBLOB) ) {

        LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
            "need a DWORD for command - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // We are going to access the streams lists -- grab the lock
    //

    CLock lock(m_lock);

    _ASSERTE( m_Streams.GetSize() == 2 );

    int i;
    HRESULT hr;

    //
    // Based on the command, take action:
    //

    switch ( Blob->dwCmd )
    {
    case CSATSPMSPCMD_CONNECTED:
        {

            LOG((MSP_INFO, "CWaveMSPCall::ReceiveTSPCallData - "
                "setting WaveInID=%d, WaveOutID=%d",
                ((DWORD *) pBuffer) [1],
                ((DWORD *) pBuffer) [2]));

            //
            // Use our saved class pointers to access the private method,
            // and also to conveniently differentiate between render and
            // capture. Note that the capture stream is the one with a
            // capture terminal, and thus we need to give it the wave out id,
            // and we need to give the render terminal the wave in ID.
            //

            hr = m_pRenderStream ->SetWaveID( &Blob->PermanentGuid ); // wavein

            if ( FAILED(hr) )
            {
                LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
                    "render stream SetWaveID failed 0x%08x - "
                    "firing CALL_STREAM_FAIL", hr));

                m_pRenderStream->FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);
            }

            hr = m_pCaptureStream->SetWaveID( &Blob->PermanentGuid ); // waveout

            if ( FAILED(hr) )
            {
                LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
                    "capture stream SetWaveID failed 0x%08x - "
                    "firing CALL_STREAM_FAIL", hr));

                m_pCaptureStream->FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);
            }

        }
//        break;
//
//    case 1: // start streaming
        {
            for ( i = 0; i < m_Streams.GetSize(); i++ )
            {
                hr = m_Streams[i]->StartStream();
            }
        }
        break;

    case CSATSPMSPCMD_DISCONNECTED:
        {
            for ( i = 0; i < m_Streams.GetSize(); i++ )
            {
                hr = m_Streams[i]->StopStream();
            }
        }
        break;

    default:
        LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
            "invalid command - exit E_INVALIDARG"));

        return E_INVALIDARG;

    }

    LOG((MSP_TRACE, "CWaveMSPCall::ReceiveTSPCallData - exit S_OK"));
    return S_OK;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\csamsp\csastrm.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wavestrm.cpp 

Abstract:

    This module contains implementation of CWaveMSPStream.

Author:
    
    Zoltan Szilagyi (zoltans)   September 7, 1998

--*/

#include "stdafx.h"

#include <initguid.h>
#include <g711uids.h>


HRESULT
TryCreateCSAFilter(
    IN  GUID   *PermanentGuid,
    OUT IBaseFilter **ppCSAFilter
    );



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSPStream::CWaveMSPStream() : CMSPStream()
{
    LOG((MSP_TRACE, "CWaveMSPStream::CWaveMSPStream entered."));

    m_fTerminalConnected = FALSE;
    m_fHaveWaveID        = FALSE;
    m_DesiredGraphState  = State_Stopped;
    m_pFilter            = NULL;
    m_pG711Filter        = NULL;

    LOG((MSP_TRACE, "CWaveMSPStream::CWaveMSPStream exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSPStream::~CWaveMSPStream()
{
    LOG((MSP_TRACE, "CWaveMSPStream::~CWaveMSPStream entered."));
    LOG((MSP_TRACE, "CWaveMSPStream::~CWaveMSPStream exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

void CWaveMSPStream::FinalRelease()
{
    LOG((MSP_TRACE, "CWaveMSPStream::FinalRelease entered."));

    //
    // At this point we should have no terminals selected, since
    // Shutdown is supposed to be called before we are destructed.
    //

    _ASSERTE( 0 == m_Terminals.GetSize() );

    //
    // Remove out filter from the graph and release it.
    //

    if ( m_fHaveWaveID )
    {
        _ASSERTE( m_pFilter );

    	m_pIGraphBuilder->RemoveFilter( m_pFilter );
        m_pFilter->Release();
    }

	if ( m_pG711Filter )
    {
    	m_pIGraphBuilder->RemoveFilter( m_pG711Filter );
        m_pG711Filter->Release();
    }

    //
    // Call the base class method to clean up everything else.
    //

    CMSPStream::FinalRelease();

    LOG((MSP_TRACE, "CWaveMSPStream::FinalRelease exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSPStream::get_Name (
    OUT     BSTR *                  ppName
    )
{
    LOG((MSP_TRACE, "CWaveMSPStream::get_Name - enter"));

    //
    // Check argument.
    //

    if ( IsBadWritePtr(ppName, sizeof(BSTR) ) )
    {
        LOG((MSP_TRACE, "CWaveMSPStream::get_Name - "
            "bad return pointer - returning E_POINTER"));

        return E_POINTER;
    }

    //
    // Decide what string to return based on which stream this is.
    //

    ULONG ulID;
    
    if ( m_Direction == TD_CAPTURE )
    {
        ulID = IDS_CAPTURE_STREAM;
    }
    else
    {
        ulID = IDS_RENDER_STREAM;
    }

    //
    // Get the string from the string table.
    //

    const int   ciAllocSize = 2048;
    WCHAR       wszName[ciAllocSize];

    int iReturn = LoadString( _Module.GetModuleInstance(),
                              ulID,
                              wszName,
                              ciAllocSize - 1 );

    if ( iReturn == 0 )
    {
        _ASSERTE( FALSE );
        
        *ppName = NULL;

        LOG((MSP_ERROR, "CWaveMSPStream::get_Name - "
            "LoadString failed - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // Convert to a BSTR and return the BSTR.
    //

    *ppName = SysAllocString(wszName);

    if ( *ppName == NULL )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::get_Name - "
            "SysAllocString failed - returning E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::get_Name - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSPStream::SelectTerminal(
    IN      ITTerminal *            pTerminal
    )
{
    LOG((MSP_TRACE, "CWaveMSPStream::SelectTerminal - enter"));

    //
    // We are going to access the terminal list -- grab the lock
    //

    CLock lock(m_lock);

    //
    // Reject if we already have a terminal selected.
    //

    if ( 0 != m_Terminals.GetSize() )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::SelectTerminal - "
            "exit TAPI_E_MAXTERMINALS"));

        return TAPI_E_MAXTERMINALS;
    }

    //
    // Use base class method to add it to our list of terminals.
    //

    HRESULT hr = CMSPStream::SelectTerminal(pTerminal);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::SelectTerminal - "
            "base class method failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Re-pause or re-start the stream if needed.
    //

    if ( m_DesiredGraphState == State_Paused )
    {
        hr = PauseStream();
    }
    else if ( m_DesiredGraphState == State_Running )
    {
        hr = StartStream();
    }
    else
    {
        _ASSERTE( m_DesiredGraphState == State_Stopped );

        hr = S_OK;
    }

    if ( FAILED(hr) )
    {
        LOG((MSP_TRACE, "CWaveMSPStream::SelectTerminal - "
            "can't regain old graph state - unselecting terminal - "
            "exit 0x%08x", hr));

		//
		// Unselect it to undo all of the above.
		//

	    UnselectTerminal(pTerminal);

        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::SelectTerminal - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSPStream::UnselectTerminal (
        IN     ITTerminal *             pTerminal
        )
{
    LOG((MSP_TRACE, "CWaveMSPStream::UnselectTerminal - enter"));

    CLock lock(m_lock);

    //
    // Add an extra reference to the terminal so it doesn't go away
    // after we call CMSPStream::UnselectTerminal. We need it later
    // in the function.
    //
    pTerminal->AddRef();


    //
    // Use base class method to remove terminal from our list of terminals.
    //

    HRESULT hr = CMSPStream::UnselectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPStream::UnselectTerminal - "
            "base class method failed - exit 0x%08x", hr));

        pTerminal->Release();
        return hr;
    }

    //
    // If we've been given a waveid then we may not be stopped.
    // This does nothing if we are already stopped.
    //

    CMSPStream::StopStream();



    //
    // Disconnect the terminal if this call had it connected.
    //

    if ( m_fTerminalConnected )
    {
        //
        // Get the ITTerminalControl interface.
        //

        ITTerminalControl * pTerminalControl;

        hr = pTerminal->QueryInterface(IID_ITTerminalControl,
                                       (void **) &pTerminalControl);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CWaveMSPStream::UnselectTerminal - "
                "QI for ITTerminalControl failed - exit 0x%08x", hr));

            pTerminal->Release();
            return hr;
        }

        //
        // Disconnect the terminal.
        //

        hr = pTerminalControl->DisconnectTerminal(m_pIGraphBuilder, 0);

        pTerminalControl->Release();

        m_fTerminalConnected = FALSE;

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CWaveMSPStream::UnselectTerminal - "
                "DisconnectTerminal failed - exit 0x%08x", hr));
            pTerminal->Release();
            return hr;
        }
    }

    LOG((MSP_TRACE, "CWaveMSPStream::UnselectTerminal - exit S_OK"));

    pTerminal->Release();
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSPStream::StartStream (void)
{
    LOG((MSP_TRACE, "CWaveMSPStream::StartStream - enter"));

    CLock lock(m_lock);

    m_DesiredGraphState = State_Running;

    //
    // Can't start the stream if we don't know the waveid.
    // (We create our filters on discovery of the waveid.)
    //

    if ( ! m_fHaveWaveID )
    {
        LOG((MSP_WARN, "CWaveMSPStream::StartStream - "
            "no waveid so nothing to do yet - exit S_OK"));

        return S_OK;
    }

    //
    // Can't start the stream if no terminal has been selected.
    //

    if ( 0 == m_Terminals.GetSize() )
    {
        LOG((MSP_WARN, "CWaveMSPStream::StartStream - "
            "no Terminal so nothing to do yet - exit S_OK"));

        return S_OK;
    }

    //
    // Connect the terminal. This does nothing if this call already
    // connected the terminal and fails if another call has the
    // terminal connected.
    //

    HRESULT hr;

    hr = ConnectTerminal(m_Terminals[0]);

    if ( FAILED(hr) )
    {
        FireEvent(CALL_TERMINAL_FAIL, hr, CALL_CAUSE_CONNECT_FAIL);
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_CONNECT_FAIL);

        LOG((MSP_ERROR, "CWaveMSPStream::StartStream - "
            "our ConnectTerminal failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Run the stream via the base class method.
    //

    hr = CMSPStream::StartStream();

    if ( FAILED(hr) )
    {
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);

        LOG((MSP_ERROR, "CWaveMSPStream::StartStream - "
            "Run failed - exit 0x%08x", hr));

        return hr;
    }

    HRESULT hr2 = FireEvent(CALL_STREAM_ACTIVE, hr, CALL_CAUSE_LOCAL_REQUEST);

    if ( FAILED(hr2) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::StartStream - "
            "FireEvent failed - exit 0x%08x", hr2));

        return hr2;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::StartStream - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSPStream::PauseStream (void)
{
    LOG((MSP_TRACE, "CWaveMSPStream::PauseStream - enter"));

    CLock lock(m_lock);

    m_DesiredGraphState = State_Paused;

    //
    // Can't pause the stream if we don't know the waveid.
    // (We create our filters on discovery of the waveid.)
    //

    if ( ! m_fHaveWaveID )
    {
        LOG((MSP_WARN, "CWaveMSPStream::PauseStream - "
            "no waveid so nothing to do yet - exit S_OK"));

        return S_OK;
    }

    //
    // Can't pause the stream if no terminal has been selected.
    //

    if ( 0 == m_Terminals.GetSize() )
    {
        LOG((MSP_WARN, "CWaveMSPStream::PauseStream - "
            "no Terminal so nothing to do yet - exit S_OK"));

        return S_OK;
    }

    //
    // Connect the terminal. This does nothing if this call already
    // connected the terminal and fails if another call has the
    // terminal connected.
    //

    HRESULT hr;

    hr = ConnectTerminal(m_Terminals[0]);

    if ( FAILED(hr) )
    {
        FireEvent(CALL_TERMINAL_FAIL, hr, CALL_CAUSE_CONNECT_FAIL);
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_CONNECT_FAIL);

        LOG((MSP_ERROR, "CWaveMSPStream::StartStream - "
            "our ConnectTerminal failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Pause the stream via the base class method.
    //

    hr = CMSPStream::PauseStream();

    if ( FAILED(hr) )
    {
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);

        LOG((MSP_ERROR, "CWaveMSPStream::PauseStream - "
            "Pause failed - exit 0x%08x", hr));

        return hr;
    }
    
    HRESULT hr2 = FireEvent(CALL_STREAM_INACTIVE, hr, CALL_CAUSE_LOCAL_REQUEST);

    if ( FAILED(hr2) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::PauseStream - "
            "FireEvent failed - exit 0x%08x", hr2));

        return hr2;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::PauseStream - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSPStream::StopStream (void)
{
    LOG((MSP_TRACE, "CWaveMSPStream::StopStream - enter"));

    CLock lock(m_lock);

    m_DesiredGraphState = State_Stopped;

    //
    // Nothing to do if we don't know our waveid.
    //

    if ( ! m_fHaveWaveID )
    {
        LOG((MSP_WARN, "CWaveMSPStream::StopStream - "
            "no waveid - exit S_OK"));

        return S_OK;
    }

    //
    // Nothing to do if no terminal has been selected.
    //

    if ( 0 == m_Terminals.GetSize() )
    {
        LOG((MSP_WARN, "CWaveMSPStream::StopStream - "
            "no Terminal - exit S_OK"));

        return S_OK;
    }

    //
    // Stop the stream via the base class method.
    //

    HRESULT hr;

    hr = CMSPStream::StopStream();

    if ( FAILED(hr) )
    {
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);

        LOG((MSP_ERROR, "CWaveMSPStream::StopStream - "
            "Stop failed - exit 0x%08x", hr));

        return hr;
    }
    
    HRESULT hr2 = FireEvent(CALL_STREAM_INACTIVE, hr, CALL_CAUSE_LOCAL_REQUEST);

    if ( FAILED(hr2) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::StopStream - "
            "FireEvent failed - exit 0x%08x", hr2));

        return hr2;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::StopStream - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

HRESULT CWaveMSPStream::SetWaveID(GUID * PermanentGuid)
{
    LOG((MSP_TRACE, "CWaveMSPStream::SetWaveID - enter"));

    CLock lock(m_lock);

    //
    // create the correct wave filter
    //

    HRESULT hr;

    hr= TryCreateCSAFilter(
        PermanentGuid,
        &m_pFilter
    );

    if (!(SUCCEEDED(hr)))
    {
        LOG((MSP_ERROR, "CWaveMSPStream::SetWaveID - "
            "Filter creation failed - exit 0x%08x", hr));
        
        return hr;
    }

    //
    // Add the filter. Supply a name to make debugging easier.
    //

	WCHAR * pName = (m_Direction == TD_RENDER) ?
						(L"The Stream's WaveIn (on line device)") :
						(L"The Stream's WaveOut (on line device)");

    hr = m_pIGraphBuilder->AddFilter(m_pFilter, pName);
    
    if (!(SUCCEEDED(hr)))
    {
        LOG((MSP_ERROR, "CWaveMSPStream::SetWaveID - "
            "AddFilter failed - exit 0x%08x", hr));
        
        m_pFilter->Release();

        return hr;
    }

    //
    // We now have the wave ID.
    //

    m_fHaveWaveID = TRUE;

    LOG((MSP_TRACE, "CWaveMSPStream::SetWaveID - exit S_OK"));

    return S_OK;
}

#if 0

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Create the G711 filter, which we will try to connect if direct
// connection fails.
//

void CWaveMSPStream::CreateAndAddG711(void)
{
    //
    // Create the G711 filter.
    //

    HRESULT hr;

    hr = CoCreateInstance(
                          CLSID_G711Codec,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IBaseFilter,
                          (void **) &m_pG711Filter
                         );

    if (!(SUCCEEDED(hr)))
    {
        LOG((MSP_ERROR, "CWaveMSPStream - Failed to create G711 codec: %lx", hr));

        //
        // Method #2 for connection will not be available.
        //

        m_pG711Filter = NULL;

        return;
    }

    //
    // add the G711 filter
    //
    hr = m_pIGraphBuilder->AddFilter(
                                    m_pG711Filter,
                                    NULL
                                   );

    if (!(SUCCEEDED(hr)))
    {
        LOG((MSP_ERROR, "CWaveMSPStream - Failed to add G711 filter: %lx", hr));

        //
        // If we couldn't add it to the graph, then it's useless to us.
        // Method #2 for connection will not be available.
        //

        m_pG711Filter->Release();
        m_pG711Filter = NULL; 
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
// This function suggests a reasonable buffer size
// on the wave in filter's output pin. It is called right before
// connection.
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

// Dialogic said something about small buffers causing problems for their wave
// driver. 20 ms samples were ok on a dual-proc Pentium Pro but caused choppy
// sound followed by silence on a single-proc 166 Pentium. I hate to do this
// but we had better try raising this for compatibility... :(

static const long DESIRED_BUFFER_SIZE_MS = 20; // milliseconds

HRESULT CWaveMSPStream::DecideDesiredCaptureBufferSize(IUnknown * pUnknown,
                                                   long * plDesiredSize)
{
    LOG((MSP_TRACE, "CWaveMSPStream::DecideDesiredCaptureBufferSize - "
        "enter"));

    _ASSERTE( ! IsBadReadPtr(pUnknown, sizeof(IUnknown)) );
    _ASSERTE( ! IsBadWritePtr(plDesiredSize, sizeof(long)) );

    HRESULT hr;

    IAMStreamConfig * pConfig = NULL;

    hr = pUnknown->QueryInterface(IID_IAMStreamConfig,
                                  (void **) &pConfig
                                 );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::DecideDesiredCaptureBufferSize"
            " - IAMStreamConfig QI failed on IUnknown 0x%08x; hr = 0x%08x",
            pUnknown, hr));

        return hr;
    }

    AM_MEDIA_TYPE * pMediaType;
    
    hr = pConfig->GetFormat(&pMediaType);

    pConfig->Release();
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::DecideDesiredCaptureBufferSize"
            " - GetFormat failed; hr = 0x%08x", hr));

        return hr;
    }

    _ASSERTE( pMediaType->cbFormat >= sizeof(WAVEFORMATEX) );

    *plDesiredSize = DESIRED_BUFFER_SIZE_MS * 
            ((WAVEFORMATEX *) (pMediaType->pbFormat) )->nChannels *
            ( ((WAVEFORMATEX *) (pMediaType->pbFormat) )->nSamplesPerSec / 1000) * 
            ( ((WAVEFORMATEX *) (pMediaType->pbFormat) )->wBitsPerSample / 8);

    DeleteMediaType(pMediaType);

    LOG((MSP_TRACE, "CWaveMSPStream::DecideDesiredCaptureBufferSize - "
        "exit S_OK"));

    return S_OK;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ManipulateAllocatorProperties
//
// This is a helper function that sets up the allocator properties on the
// capture filter, given the interface pointer required for doing so and 
// an interface pointer that is used to discover downstream allocator
// requirements.
// we are already in a lock; no need to do locking here.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CWaveMSPStream::ManipulateAllocatorProperties
                        (IAMBufferNegotiation * pNegotiation,
                         IMemInputPin         * pMemInputPin)
{
    LOG((MSP_TRACE, "CWaveMSPStream::ManipulateAllocatorProperties - enter"));

    HRESULT hr;
    ALLOCATOR_PROPERTIES props;

    hr = pMemInputPin->GetAllocatorRequirements(&props);

    if ( SUCCEEDED(hr) )
    {
        LOG((MSP_TRACE, "CWaveMSPStream::ManipulateAllocatorProperties - "
            "using downstream allocator requirements"));
    }
    else
    {
        LOG((MSP_TRACE, "CWaveMSPStream::ManipulateAllocatorProperties - "
            "using our default allocator properties"));

        long lDesiredSize = 0;
        hr = DecideDesiredCaptureBufferSize(pNegotiation,
                                            &lDesiredSize);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CWaveMSPStream::ManipulateAllocatorProperties - "
                "DecideDesiredCaptureBufferSize failed - exit 0x%08x", hr));

            return hr;
        }
    
        props.cBuffers  = 32;   // we use 32 to avoid starvation, just as we do in the terminal manager.
        props.cbBuffer  = lDesiredSize;
        props.cbAlign   = -1;   // means "default"
        props.cbPrefix  = -1;   // means "default"
    }

    hr = pNegotiation->SuggestAllocatorProperties(&props);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ManipulateAllocatorProperties - "
            "SuggestAllocatorProperties failed - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::ManipulateAllocatorProperties - "
        "exit S_OK"));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// SetupWaveIn
//
// This is a helper function that sets up the allocator properties on the
// capture filter, given the terminal's pin and our filter's pin. This
// involves deciding where the capture interfaces should be found, checkin
// if the downstream filters have allocator requirements, and then applying
// either these requirements or our default requirements to the capture
// filter.
// we are already in a lock; no need to do locking here.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
HRESULT CWaveMSPStream::SetupWaveIn( IPin * pOutputPin,
                                 IPin * pInputPin )
{
    LOG((MSP_TRACE, "CWaveMSPStream::SetupWaveIn - enter"));

    //
    // Ask the output pin for its buffer negotiation interface.
    //

    HRESULT hr;
    IAMBufferNegotiation * pNegotiation;

    hr = pOutputPin->QueryInterface(IID_IAMBufferNegotiation,
                                    (void **) &pNegotiation);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "IAMBufferNegotiation QI failed - hr = 0x%08x", hr));
        return hr;
    }

    //
    // Ask the input pin for its meminputpin interface.
    //

    IMemInputPin         * pMemInputPin;

    hr = pInputPin->QueryInterface(IID_IMemInputPin,
                                   (void **) &pMemInputPin);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "IMemInputPin QI failed - hr = 0x%08x", hr));

        pNegotiation->Release();
        return hr;
    }

    //
    // now set the properties on the negotiation interface, depending
    // on the properties that are set on the meminputpin interface
    //

    hr = ManipulateAllocatorProperties(pNegotiation, pMemInputPin);

    pNegotiation->Release();
    pMemInputPin->Release();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "ManipulateAllocatorProperties - hr = 0x%08x", hr));
        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::SetupWaveIn - exit S_OK"));
    return S_OK;
}
#endif
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// This function is for debugging purposes only. It pops up a
// couple of message boxes telling you various information about
// media formats and allocator properties. It's called after
// connection has taken place. pPin is the output pin of the
// wavein filter.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
        
HRESULT CWaveMSPStream::ExamineWaveInProperties(IPin *pPin)
{
    LOG((MSP_TRACE, "CWaveMSPStream::ExamineWaveInProperties - enter"));

    HRESULT hr;
    IAMBufferNegotiation * pNegotiation = NULL;

    hr = pPin->QueryInterface(IID_IAMBufferNegotiation,
                              (void **) &pNegotiation
                             );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ExamineWaveInProperties - "
            "IAMBufferNegotiation QI failed on pin 0x%08x; hr = 0x%08x",
            pPin, hr));

        return hr;
    }

    ALLOCATOR_PROPERTIES prop;
    
    hr = pNegotiation->GetAllocatorProperties(&prop);

    pNegotiation->Release();
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ExamineWaveInProperties - "
            "GetAllocatorProperties failed; hr = 0x%08x",
            hr));

        return hr;
    }

    LOG((MSP_TRACE, "GetAllocatorProperties info:\n"
            "buffer count: %d\n"
            "size of each buffer: %d bytes\n"
            "alignment multiple: %d\n"
            "each buffer has a prefix: %d bytes",
            prop.cBuffers,
            prop.cbBuffer,
            prop.cbAlign,
            prop.cbPrefix
           ));

    IAMStreamConfig * pConfig = NULL;

    hr = pPin->QueryInterface(IID_IAMStreamConfig,
                              (void **) &pConfig
                             );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ExamineWaveInProperties - "
            "IAMStreamConfig QI failed on pin 0x%08x; hr = 0x%08x", pPin, hr));

        return hr;
    }

    AM_MEDIA_TYPE * pMediaType;
    
    hr = pConfig->GetFormat(&pMediaType);

    pConfig->Release();
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ExamineWaveInProperties - "
            "GetFormat failed; hr = 0x%08x", hr));

        return hr;
    }

    _ASSERTE( pMediaType->cbFormat >= sizeof(WAVEFORMATEX) );

    LOG((MSP_TRACE, "GetFormat info:\n"
            "sample size: %d bytes\n"
            "channels: %d\n"
            "samples per second: %d\n"
            "bits per sample: %d\n",
            pMediaType->lSampleSize,
            ((WAVEFORMATEX *) (pMediaType->pbFormat) )->nChannels,
            ((WAVEFORMATEX *) (pMediaType->pbFormat) )->nSamplesPerSec,
            ((WAVEFORMATEX *) (pMediaType->pbFormat) )->wBitsPerSample
           ));

    DeleteMediaType(pMediaType);

    LOG((MSP_TRACE, "CWaveMSPStream::ExamineWaveInProperties - "
        "exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Add the terminal to the graph and connect it to our
// filters, if it is not already in use.
//

HRESULT CWaveMSPStream::ConnectTerminal(ITTerminal * pTerminal)
{
    LOG((MSP_TRACE, "CWaveMSPStream::ConnectTerminal - enter"));

    //
    // Find out the terminal's internal state.
    //

    TERMINAL_STATE state;
    HRESULT hr;

    hr = pTerminal->get_State( &state );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "get_State on terminal failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // If we've already connected the terminal on this stream, then
    // there is nothing for us to do. Just assert that the terminal
    // also thinks it's connected.
    //

    if ( m_fTerminalConnected )
    {
        _ASSERTE( state == TS_INUSE );

        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "terminal already connected on this stream - exit S_OK"));

        return S_OK;
    }

    //
    // Otherwise we need to connect the terminal on this call. If the
    // terminal is already connected on another call, we must fail. Note
    // that since we are making several calls on the terminal here, the
    // terminal could become connected on another call while we are
    // in the process of doing this. If this happens, the we will just fail
    // later.
    //

    if ( state == TS_INUSE )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "terminal in use - exit TAPI_E_TERMINALINUSE"));

        return TAPI_E_TERMINALINUSE;
    }

    //
    // Get the ITTerminalControl interface.
    //

    ITTerminalControl * pTerminalControl;

    hr = m_Terminals[0]->QueryInterface(IID_ITTerminalControl,
                                        (void **) &pTerminalControl);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "QI for ITTerminalControl failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Find out how many pins the terminal has. If not one then bail as
    // we have no idea what to do with multiple-pin terminals at this point.
    //

    DWORD dwNumPinsAvailable;

    hr = pTerminalControl->ConnectTerminal(m_pIGraphBuilder,
                                           m_Direction,
                                           &dwNumPinsAvailable,
                                           NULL);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "query for number of terminal pins failed - exit 0x%08x", hr));
        
        pTerminalControl->Release();

        return hr;
    }

    if ( 1 != dwNumPinsAvailable )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "unsupported number of terminal pins - exit E_FAIL"));

        pTerminalControl->Release();

        return E_FAIL;
    }

    IPin * pTerminalPin;

    //
    // Actually connect the terminal.
    //

    hr = pTerminalControl->ConnectTerminal(m_pIGraphBuilder,
                                           m_Direction,
                                           &dwNumPinsAvailable,
                                           &pTerminalPin);
    
    if ( FAILED(hr) )
    {
        pTerminalControl->Release();

        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "ConnectTerminal on terminal failed - exit 0x%08x", hr));

        return hr;
    }

    if (IsBadReadPtr(pTerminalPin,sizeof(IPin))) {
        //
        //  bad pin
        //
        pTerminalControl->Release();

        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "bad IPin returned from ConnectTerminal"));

        return E_POINTER;
    }


    //
    // Now make the connection between our filters and the terminal's pin.
    //

    hr = ConnectToTerminalPin(pTerminalPin);

    pTerminalPin->Release();

    if ( FAILED(hr) )
    {
        pTerminalControl->DisconnectTerminal(m_pIGraphBuilder, 0);

        pTerminalControl->Release();

        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "ConnectToTerminalPin failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //

    m_fTerminalConnected  = TRUE;

    pTerminalControl->CompleteConnectTerminal();

    pTerminalControl->Release();

    LOG((MSP_TRACE, "CWaveMSPStream::ConnectTerminal - exit S_OK"));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// Tries to connect the waveOut filter. First it tries a
// direct connection, then with an intermediate G711
// codec, then an intelligent connect which may draw in
// more filters.
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void ShowMediaTypes(IEnumMediaTypes * pEnum)
{
    AM_MEDIA_TYPE * pMediaType;

    while (pEnum->Next(1, &pMediaType, NULL) == S_OK)
    {
        if ( pMediaType->cbFormat < sizeof(WAVEFORMATEX) )
		{
	        LOG((MSP_TRACE, "*** Media Type: *** non-wave"));
		}
		else
		{
			LOG((MSP_TRACE,"*** Media Type: *** "
					"sample size: %d bytes *** "
					"channels: %d *** "
					"samples per second: %d *** "
					"bits per sample: %d",
					pMediaType->lSampleSize,
					((WAVEFORMATEX *) (pMediaType->pbFormat) )->nChannels,
					((WAVEFORMATEX *) (pMediaType->pbFormat) )->nSamplesPerSec,
					((WAVEFORMATEX *) (pMediaType->pbFormat) )->wBitsPerSample
				   ));
		}

        DeleteMediaType(pMediaType);
    }
}


HRESULT CWaveMSPStream::TryToConnect(
                              IPin * pOutputPin,  // on the capture filter or terminal
                              IPin * pInputPin    // on the render filter or terminal
                             )
{
    LOG((MSP_TRACE, "TryToConnect - enter"));

    HRESULT       hr;


    IEnumMediaTypes * pEnum;

    hr = pOutputPin->EnumMediaTypes(&pEnum);

    if (SUCCEEDED(hr))
    {  
        LOG((MSP_TRACE, "Output pin media types:"));
        ShowMediaTypes(pEnum);
        pEnum->Release();
    }

    hr = pInputPin->EnumMediaTypes(&pEnum);
    if (SUCCEEDED(hr))
    {
        LOG((MSP_TRACE, "Input pin media types:"));
        ShowMediaTypes(pEnum);
        pEnum->Release();
    }

    //
    // Method 1: direct connection
    //

    hr = m_pIGraphBuilder->ConnectDirect(
                              pOutputPin,
                              pInputPin,
                              NULL
                             );

    if ( SUCCEEDED(hr) )
    {
        LOG((MSP_TRACE, "TryToConnect: direct connection worked - exit S_OK"));
        return S_OK;
    }

    LOG((MSP_ERROR, "TryToConnect - direct connection failed - %lx", hr));

    //
    // Method 1.5: work around DirectShow bug for Unimodem.
    //   Try 8 KHz 16-bit mono explicitly
    //

    AM_MEDIA_TYPE MediaType;
    WAVEFORMATEX  WaveFormatEx;

    MediaType.majortype = MEDIATYPE_Audio;
    MediaType.subtype = MEDIASUBTYPE_PCM;
    MediaType.bFixedSizeSamples = TRUE;
    MediaType.bTemporalCompression = FALSE;
    MediaType.lSampleSize = 2;
    MediaType.formattype = FORMAT_WaveFormatEx;
    MediaType.pUnk = NULL;
    MediaType.cbFormat = sizeof( WAVEFORMATEX );
    MediaType.pbFormat = (LPBYTE) & WaveFormatEx;

    WaveFormatEx.wFormatTag = WAVE_FORMAT_PCM;
    WaveFormatEx.nChannels = 1;
    WaveFormatEx.nSamplesPerSec = 8000;
    WaveFormatEx.nAvgBytesPerSec = 16000;
    WaveFormatEx.nBlockAlign = 2;
    WaveFormatEx.wBitsPerSample = 16;
    WaveFormatEx.cbSize = 0;

    IAMStreamConfig * pConfig;

    hr = pOutputPin->QueryInterface(IID_IAMStreamConfig,
                                  (void **) &pConfig
                                 );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::TryToConnect"
            " - IAMStreamConfig QI failed on output pin 0x%08x; hr = 0x%08x",
            pOutputPin, hr));
    }
    else
    {
        AM_MEDIA_TYPE * pOldMediaType;
        
        hr = pConfig->GetFormat(&pOldMediaType);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CWaveMSPStream::TryToConnect - "
                "GetFormat failed - 0x%08x", hr));
        }
        else
        {
            // Suggest the new format. If it fails, we want to know about it
            // as something is wrong.

            hr = pConfig->SetFormat(&MediaType);

            if ( FAILED(hr) )
            {
                LOG((MSP_ERROR, "CWaveMSPStream::TryToConnect - "
                    "SetFormat failed - 0x%08x", hr));
            }
            else
            {
                hr = m_pIGraphBuilder->ConnectDirect(
                                          pOutputPin,
                                          pInputPin,
                                          &MediaType
                                         );

                if ( SUCCEEDED(hr) )
                {
                    LOG((MSP_TRACE, "TryToConnect: direct connection with explicit "
                        "WaveIn 8KHz 16-bit setting worked - exit S_OK"));
                
                    DeleteMediaType(pOldMediaType);
                    pConfig->Release();

                    return S_OK;
                }
                else
                {
                    // restore old type, best effort
                    hr = pConfig->SetFormat(pOldMediaType);

                    if ( FAILED(hr) )
                    {
                        LOG((MSP_ERROR, "CWaveMSPStream::TryToConnect - "
                            "SetFormat failed to restore old type - 0x%08x", hr));
                    }
                }
            }

            DeleteMediaType(pOldMediaType);
        }

        pConfig->Release();
    }

#if 0
    LOG((MSP_ERROR, "TryToConnect - direct connection with explicit "
                    "WaveIn 8KHz 16-bit setting failed - %lx", hr));

    //
    // Method 2: direct connection with G711 filter in between.
    // If we haven't created and added the G711 filter to the graph yet,
    // do so now.
    //

    if ( ! m_pG711Filter )
    {
        CreateAndAddG711();
    }

    //
    // If the CreateAndAddG711 method worked, now or previously, then try to
    // use the G711.
    //

    if (m_pG711Filter)
    {
        IPin * pG711InputPin = NULL;

        hr = FindPinInFilter(
                             false,          // want input pin
                             m_pG711Filter,
                             &pG711InputPin
                            );

        if ( SUCCEEDED(hr) )
        {
            hr = m_pIGraphBuilder->ConnectDirect(
                                  pOutputPin,
                                  pG711InputPin,
                                  NULL
                                 );

            // We don't release the G711's input pin here because we must
            // hang onto it in order to break the connection if any of the
            // subsequent steps fail.

            if ( SUCCEEDED(hr) )
            {
                IPin * pG711OutputPin = NULL;

                hr = FindPinInFilter(
                                     true,          // want output pin
                                     m_pG711Filter,
                                     &pG711OutputPin
                                    );

                if ( SUCCEEDED(hr) )
                {
                    hr = m_pIGraphBuilder->ConnectDirect(
                                          pG711OutputPin,
                                          pInputPin,
                                          NULL
                                         );

                    pG711OutputPin->Release();

                    if ( SUCCEEDED(hr) )
                    {
                        LOG((MSP_TRACE, "TryToConnect - G711 connection succeeded - exit S_OK"));

                        // Held onto this in case of failure... see above
                        pG711InputPin->Release();

                        return S_OK;
                    }
                    else
                    {
                        LOG((MSP_ERROR, "TryToConnect - could not connect "
                                          "G711 codec's output pin - %lx", hr));

                    }
                }
                else
                {
                    LOG((MSP_ERROR, "TryToConnect - could not find "
                                      "G711 codec's input pin - %lx", hr));
                }


                if ( FAILED(hr) )
                {
                    //
                    // The first G711 connection succeeded but something else
                    // subsequently failed. This means we must disconnect the left
                    // end of the G711 filter. Luckily, we held onto the G711 filter's
                    // input pin above. We must disconnect the them here, otherwise
                    // method #3 won't work.
                    //

                    hr = m_pIGraphBuilder->Disconnect(pOutputPin);

                    LOG((MSP_ERROR, "TryToConnect - error undoing what we did - could not "
                        "disconnect the wave filter's output pin! hr = 0x%08x", hr));

                    hr = m_pIGraphBuilder->Disconnect(pG711InputPin);

                    LOG((MSP_ERROR, "TryToConnect - error undoing what we did - could not "
                        "disconnect the wave filter's output pin! hr = 0x%08x", hr));

                    //
                    // Now we no longer need to talk to the pin...
                    //

                    pG711InputPin->Release();

                    //
                    // And the G711 filter itself sticks around in the graph for next time.
                    //
                }
            }
            else
            {
                LOG((MSP_ERROR, "TryToConnect - could not connect "
                                  "G711 codec's input pin - %lx", hr));
            }
        }
        else
        {
            LOG((MSP_ERROR, "TryToConnect - could not find "
                              "G711 codec's input pin - %lx", hr));
        }
    }
    else
    {
        hr = E_FAIL;

        LOG((MSP_ERROR, "TryToConnect - G711 codec does not exist"));
    }

    LOG((MSP_TRACE, "TryToConnect - G711 connection failed - %lx", hr));

    //
    // Method 3: intelligent connection, which may pull in who knows what other filters
    //

#ifdef ALLOW_INTELLIGENT_CONNECTION
    hr = m_pIGraphBuilder->Connect(
                          pOutputPin,
                          pInputPin
                         );
#else // ALLOW_INTELLIGENT_CONNECTION
    LOG((MSP_ERROR, "TryToConnect - NOTE: we never allow intelligent connection"));
    hr = E_FAIL;
#endif // ALLOW_INTELLIGENT_CONNECTION
#endif
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "TryToConnect - intelligent connection failed - %lx", hr));
        return hr;
    }

    LOG((MSP_TRACE, "TryToConnect: intelligent connection worked - exit S_OK"));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

HRESULT CWaveMSPStream::ConnectToTerminalPin(IPin * pTerminalPin)
{
    LOG((MSP_TRACE, "CWaveMSPStream::ConnectToTerminalPin - enter"));

    HRESULT         hr = S_OK;
    IPin *          pMyPin;

    hr = FindPin( &pMyPin );

    if (!SUCCEEDED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectToTerminalPin - "
            "could not find pin - exit 0x%08x", hr));

        return hr; // we can't continue without this pin
    }

    // The OUTPUT pin from WAVEIN; the INPUT pin from WAVEOUT
    IPin * pOutputPin  = ( m_Direction == TD_RENDER  ) ? pMyPin : pTerminalPin;
    IPin * pInputPin   = ( m_Direction == TD_CAPTURE ) ? pMyPin : pTerminalPin;
#if 0
    // don't care if this fails
    SetupWaveIn(pOutputPin,
                pInputPin);
#endif
    hr = TryToConnect(pOutputPin,
                      pInputPin);

    if ( SUCCEEDED(hr) )
    {
        // don't care if this fails...

        ExamineWaveInProperties(pOutputPin);
    }

    pMyPin->Release();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectToTerminalPin - "
            "could not connect to pin - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::ConnectToTerminalPin - exit S_OK"));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CWaveMSPStream::FindPinInFilter(
                     BOOL           bWantOutputPin, // IN:  if false, we want the input pin
                     IBaseFilter *  pFilter,        // IN:  the filter to examine
                     IPin        ** ppPin           // OUT: the pin we found
                     )
{    
    HRESULT         hr;
    IEnumPins     * pEnumPins;
    
    
    *ppPin = NULL;

    // enumerate the pins on the filter
    hr = pFilter->EnumPins( &pEnumPins );

    if (!(SUCCEEDED(hr)))
    {
        return hr;
    }

    // go through the pins
    while (TRUE)
    {
        PIN_DIRECTION       pd;
        
        hr = pEnumPins->Next( 1, ppPin, NULL );

        if (S_OK != hr)
        {
            // didn't find a pin!
            break;
        }

        // get the pin info
        hr = (*ppPin)->QueryDirection( &pd );

        // does it meet the criteria?
        if (bWantOutputPin && (pd == PINDIR_OUTPUT))
        {
            // yes
            break;
        }

        if ( ! bWantOutputPin && (pd == PINDIR_INPUT))
        {
            // yes
            break;
        }
        
        (*ppPin)->Release();
        *ppPin = NULL;
    }

    pEnumPins->Release();

    if (NULL == *ppPin)
    {
        // error
        return E_FAIL;
    }

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// FindPin
//
// Finds the first pin in the filter that meets criteria.
// For bWaveIn == TRUE, the pin must be direction PINDIR_OUTPUT
// For bWaveIn == FALSE, the pin must be direction PINDIR_INPUT
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CWaveMSPStream::FindPin(
        IPin ** ppPin
       )
{
    return FindPinInFilter(m_Direction == TD_RENDER,
                           m_pFilter,
                           ppPin);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ProcessGraphEvent
//
// Sends an event to the app when we get an event from the filter graph.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CWaveMSPStream::ProcessGraphEvent(
    IN  long lEventCode,
    IN  LONG_PTR lParam1,
    IN  LONG_PTR lParam2
    )
{
    LOG((MSP_EVENT, "CWaveMSPStream::ProcessGraphEvent - enter"));

    HRESULT        hr = S_OK;

    switch (lEventCode)
    {
    case EC_COMPLETE:
        
        hr = FireEvent(CALL_STREAM_INACTIVE, (HRESULT) lParam1, CALL_CAUSE_UNKNOWN);
        break;
    
    case EC_USERABORT:
        
        hr = FireEvent(CALL_STREAM_INACTIVE, S_OK, CALL_CAUSE_UNKNOWN);
        break;

    case EC_ERRORABORT:
    case EC_STREAM_ERROR_STOPPED:
    case EC_STREAM_ERROR_STILLPLAYING:
    case EC_ERROR_STILLPLAYING:

        hr = FireEvent(CALL_STREAM_FAIL, (HRESULT) lParam1, CALL_CAUSE_UNKNOWN);
        break;

    default:
        
        LOG((MSP_EVENT, "CWaveMSPStream::ProcessGraphEvent - "
            "ignoring event code %d", lEventCode));
        break;
    }

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ProcessGraphEvent - "
            "FireEvent failed - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_EVENT, "CWaveMSPStream::ProcessGraphEvent - exit S_OK"));

    return S_OK;
}

HRESULT CWaveMSPStream::FireEvent(
    IN MSP_CALL_EVENT        type,
    IN HRESULT               hrError,
    IN MSP_CALL_EVENT_CAUSE  cause
    )                                          
{
    LOG((MSP_EVENT, "CWaveMSPStream::FireEvent - enter"));


    //
    // First, need to check if the call is shutting down. This is important
    // because UnselectTerminal can fire an event, and UnselectTerminal can
    // be called within ITStream::Shutdown. We can safely discard such
    // events because there is nothing the app can do with them anyway.
    //
    // Note on locking: It is convenient to check the m_pMSPCall here
    // and we don't use it until the end of the method, so we simply lock
    // during the entire method. This could be optimized at the expense of
    // some code complexity; note that we also need to lock while accessing
    // m_Terminals. 
    //

    CLock lock(m_lock);

    if ( m_pMSPCall == NULL )
    {
        LOG((MSP_EVENT, "FireEvent - call is shutting down; dropping event - exit S_OK"));
        
        return S_OK;
    }


    //
    // Create the event structure. Must use "new" as it will be
    // "delete"d later.
    //

    MSPEVENTITEM * pEventItem = AllocateEventItem();

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "CWaveMSPStream::FireEvent - "
            "can't create MSPEVENTITEM structure - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    //
    // Fill in the necessary fields for the event structure.
    //

    pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
    pEventItem->MSPEventInfo.Event  = ME_CALL_EVENT;

    ITTerminal * pTerminal = NULL;

    if ( 0 != m_Terminals.GetSize() )
    {
        _ASSERTE( 1 == m_Terminals.GetSize() );
        pTerminal = m_Terminals[0];
        pTerminal->AddRef();
    }

    ITStream * pStream = (ITStream *) this;
    pStream->AddRef();

    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Type      = type;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Cause     = cause;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream   = pStream;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal = pTerminal;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.hrError   = hrError;

    //
    // Send the event to the app.
    //

    HRESULT hr = m_pMSPCall->HandleStreamEvent(pEventItem);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPStream::FireEvent - "
            "HandleStreamEvent failed - returning 0x%08x", hr));

        pStream->Release();
        pTerminal->Release();
        FreeEventItem(pEventItem);

        return hr;
    }

    LOG((MSP_EVENT, "CWaveMSPStream::FireEvent - exit S_OK"));

    return S_OK;
}




DEFINE_GUID(CLSID_Proxy,
0x17CCA71BL, 0xECD7, 0x11D0, 0xB9, 0x08, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);

DEFINE_GUID(CLSID_WDM_RENDER,
0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);


// {F420CB9C-B19D-11d2-A286-00C04F8EC951}
DEFINE_GUID(KSPROPSETID_MODEMCSA,
0xf420cb9c, 0xb19d, 0x11d2, 0xa2, 0x86, 0x0, 0xc0, 0x4f, 0x8e, 0xc9, 0x51);


HRESULT
CheckFilterPropery(
    IBaseFilter *CsaFilter,
    const GUID         *GuidToMatch
    )

{

    IKsPropertySet    *pKsPropSet = NULL;
    HRESULT            hr = S_OK;

    GUID               PermanentGuid;



    hr = CsaFilter->QueryInterface(IID_IKsPropertySet,
                                    (void **)&pKsPropSet);

    if (SUCCEEDED(hr)) {

        DWORD    BytesReturned;

        hr = pKsPropSet->Get(KSPROPSETID_MODEMCSA,
                         0,
                         NULL,
                         0,
                         (LPVOID)&PermanentGuid,
                         sizeof(PermanentGuid),
                         &BytesReturned
                         );



        pKsPropSet->Release();

        if (IsEqualGUID((PermanentGuid), *GuidToMatch)) {

            hr=S_OK;

        } else {

            hr=E_FAIL;
        }
    }

    return hr;
}





HRESULT
FindModemCSA(
    IN  GUID   *PermanentGuid,
    IBaseFilter ** ppFilter
    )

{

    ICreateDevEnum *pCreateDevEnum;

    HRESULT hr;

    //
    //  create system device enumerator
    //
    hr = CoCreateInstance(
            CLSID_SystemDeviceEnum,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_ICreateDevEnum,
            (void**)&pCreateDevEnum
            );

    if (SUCCEEDED(hr)) {

        IEnumMoniker *pEnumMoniker = NULL;

        hr = pCreateDevEnum->CreateClassEnumerator(
            CLSID_WDM_RENDER,
            &pEnumMoniker,
            0
            );

        pCreateDevEnum->Release();

        if (hr == S_OK) {

            pEnumMoniker->Reset();

            while( NULL == *ppFilter ) {

                IMoniker         *pMon;
                VARIANT           var;

                hr = pEnumMoniker->Next(1, &pMon, NULL);

                if ( S_OK != hr ) {

                    break;
                }
                // Bind to selected device
                hr = pMon->BindToObject( 0, 0, IID_IBaseFilter, (void**)ppFilter );

                pMon->Release();

                if (SUCCEEDED(hr)) {

                    hr=CheckFilterPropery(
                        *ppFilter,
                        PermanentGuid
                        );

                    if (SUCCEEDED(hr)) {

                        break;

                    } else {

                        (*ppFilter)->Release();
                        *ppFilter=NULL;
                    }
                }
            }
        }
    }

    return hr;

}


HRESULT
TryCreateCSAFilter(
    IN  GUID   *PermanentGuid,
    OUT IBaseFilter **ppCSAFilter
    )
{
    HRESULT         hr = E_UNEXPECTED;

    if (ppCSAFilter != NULL)
    {
        *ppCSAFilter=NULL;
         hr = FindModemCSA(PermanentGuid,ppCSAFilter);
    }

    return hr;
}





// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\csamsp\csacall.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    wavecall.h

Abstract:

    Declaration of the CWaveMSPCall

Author:
    
    Zoltan Szilagyi September 7th, 1998

--*/

#ifndef __WAVECALL_H_
#define __WAVECALL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CWaveMSPCall
/////////////////////////////////////////////////////////////////////////////

class CWaveMSPCall : public CMSPCallMultiGraph, public CMSPObjectSafetyImpl

{
public:
// DECLARE_POLY_AGGREGATABLE(CWaveMSP)

// To add extra interfaces to this class, use the following:
BEGIN_COM_MAP(CWaveMSPCall)
     COM_INTERFACE_ENTRY( IObjectSafety )
     COM_INTERFACE_ENTRY_CHAIN(CMSPCallMultiGraph)
END_COM_MAP()

public:
    CWaveMSPCall();
    virtual ~CWaveMSPCall();
    virtual ULONG MSPCallAddRef(void);
    virtual ULONG MSPCallRelease(void);

    virtual HRESULT Init(
        IN      CMSPAddress *       pMSPAddress,
        IN      MSP_HANDLE          htCall,
        IN      DWORD               dwReserved,
        IN      DWORD               dwMediaType
        );

    virtual HRESULT CreateStreamObject(
        IN      DWORD               dwMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN      IMediaEvent *       pGraph,
        IN      ITStream **         ppStream
        );

    virtual HRESULT ReceiveTSPCallData(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        );

    //
    // We override these to make sure the number of
    // streams we have is constant.
    //

    STDMETHOD (CreateStream) (
        IN      long                lMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN OUT  ITStream **         ppStream
        );
    
    STDMETHOD (RemoveStream) (
        IN      ITStream *          pStream
        );                      

protected:
    // 
    // Protected data members.
    //

    CWaveMSPStream * m_pRenderStream;
    CWaveMSPStream * m_pCaptureStream;
};

#endif //__WAVEADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\csamsp\propbag.h ===
// propbag.h : Declaration of the CMyPropertyBag

#ifndef __CMyPropertyBag_H_
#define __CMyPropertyBag_H_

//
// CMyPropertyBag
class ATL_NO_VTABLE CMyPropertyBag :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IPropertyBag
{
private:
    
    DWORD m_dwDeviceInID;
    DWORD m_dwDeviceOutID;
    
public:

    BEGIN_COM_MAP(CMyPropertyBag)
            COM_INTERFACE_ENTRY(IPropertyBag)
    END_COM_MAP()


    HRESULT
    STDMETHODCALLTYPE
    Read( 
          LPCOLESTR pszPropName,
          VARIANT *pVar,
          IErrorLog *pErrorLog
        )
    {
        if (lstrcmpiW( pszPropName, L"WaveInId" ) == 0)
        {
            pVar->vt = VT_I4;
            pVar->lVal = m_dwDeviceInID;
            return S_OK;
        }

        if (lstrcmpiW( pszPropName, L"WaveOutId" ) == 0)
        {
            pVar->vt = VT_I4;
            pVar->lVal = m_dwDeviceOutID;
            return S_OK;
        }

        return S_FALSE;
    }
        
    HRESULT
    STDMETHODCALLTYPE
    Write( 
           LPCOLESTR pszPropName,
           VARIANT *pVar
         )
    {
        if (lstrcmpiW( pszPropName, L"WaveInId" ) == 0)
        {
            m_dwDeviceInID = pVar->lVal;
            return S_OK;
        }

        if (lstrcmpiW( pszPropName, L"WaveOutId" ) == 0)
        {
            m_dwDeviceOutID = pVar->lVal;
            return S_OK;
        }

        

        return S_FALSE;
        
    };
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\csamsp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by csamsp.rc
//
#define IDS_PROJNAME                    100
#define IDR_WaveMSP                     101
#define IDR_MSPCALL                     102
#define IDR_MSPSTREAM                   103
#define IDR_MSPPropBag                  104
#define IDS_CAPTURE_STREAM              105
#define IDS_RENDER_STREAM               106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           1000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\csamsp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__902A4A47_56FA_11D1_8F46_00C04FB6809F__INCLUDED_)
#define AFX_STDAFX_H__902A4A47_56FA_11D1_8F46_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <mspbase.h>
#include "common.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // AFX_STDAFX_H__902A4A47_56FA_11D1_8F46_00C04FB6809F__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\csamsp\csastrm.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    wavestrm.h

Abstract:

    Declaration of the CWaveMSPStream

Author:
    
    Zoltan Szilagyi September 7th, 1998

--*/

#ifndef __WAVESTRM_H_
#define __WAVESTRM_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CWaveMSPStream
/////////////////////////////////////////////////////////////////////////////
class CWaveMSPStream : public CMSPStream, public CMSPObjectSafetyImpl
{
public:
// DECLARE_POLY_AGGREGATABLE(CWaveMSP)

// To add extra interfaces to this class, use the following:
BEGIN_COM_MAP(CWaveMSPStream)
    COM_INTERFACE_ENTRY( IObjectSafety )
    COM_INTERFACE_ENTRY_CHAIN(CMSPStream)
END_COM_MAP()

public:

    //
    // Construction and destruction.
    //

    CWaveMSPStream();
    virtual ~CWaveMSPStream();
    virtual void FinalRelease();

    //
    // Required base class overrides.
    // 

    STDMETHOD (get_Name) (
        OUT     BSTR *                  ppName
        );

    //
    // We override these methods to implement our terminal handling.
    // This consists of only allowing one terminal on the stream at a time
    // and adding our filters and the terminal to the graph at the right
    // times.
    //

    STDMETHOD (SelectTerminal) (
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal) (
        IN     ITTerminal *             pTerminal
        );

    STDMETHOD (StartStream) ();

    STDMETHOD (PauseStream) ();

    STDMETHOD (StopStream) ();

    //
    // Overrides for event handling.
    //

    virtual HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  LONG_PTR lParam1,
        IN  LONG_PTR lParam2
        );

    //
    // Public methods specific to our implementation.
    //

    virtual HRESULT SetWaveID(GUID *PermanentGuid);
    virtual HRESULT FireEvent(IN MSP_CALL_EVENT       type,
                              IN HRESULT              hrError,
                              IN MSP_CALL_EVENT_CAUSE cause);

protected:
    //
    // Protected data members.
    //

    BOOL          m_fHaveWaveID;
    BOOL          m_fTerminalConnected;
    IBaseFilter * m_pFilter;
    IBaseFilter * m_pG711Filter;
    FILTER_STATE  m_DesiredGraphState;

private:
    //
    // Private helper methods.
    //

    HRESULT ConnectTerminal(ITTerminal * pTerminal);
    HRESULT ConnectToTerminalPin(IPin * pTerminalPin);
    HRESULT TryToConnect(IPin * pOutputPin, IPin * pInputPin);
    void    CreateAndAddG711(void);

    HRESULT FindPinInFilter(
            BOOL           bWantOutputPin, // IN:  if false, we want the input pin
            IBaseFilter *  pFilter,        // IN:  the filter to examine
            IPin        ** ppPin           // OUT: the pin we found
            );
    HRESULT FindPin(
            IPin ** ppPin
            );
    HRESULT DecideDesiredCaptureBufferSize(IUnknown * pUnknown,
                                           long * plDesiredSize);
    HRESULT SetupWaveIn( IPin * pOutputPin,
                         IPin * pInputPin );
    HRESULT ExamineWaveInProperties(IPin *pPin);
    HRESULT ManipulateAllocatorProperties(IAMBufferNegotiation * pNegotiation,
                                         IMemInputPin          * pMemInputPin);
};

#endif //__WAVEADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\csamsp\csamsp.cpp ===
// csamsp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for wavemsp.idl by adding the following 
//		files to the Outputs.
//			wavemsp_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f wavemspps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "csamsp_i.c"

//
// For the ntbuild environment we need to include this file to get the base
//  class implementations.

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

#ifdef DEBUG_HEAPS
#include <crtdbg.h>
#endif // DEBUG_HEAPS

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CSAMSP, CWaveMSP)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif
	if (dwReason == DLL_PROCESS_ATTACH)
	{

#ifdef DEBUG_HEAPS
	// ZoltanS: turn on leak detection on process exit
	_CrtSetDbgFlag( _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF );

	// ZoltanS: force a memory leak
	char * leak = new char [ 1977 ];
    	sprintf(leak, "csamsp.dll NORMAL leak");
    	leak = NULL;
#endif // DEBUG_HEAPS

        _Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);

        // Register for trace output.
        MSPLOGREGISTER(_T("CSA MSP"));
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        // Deregister for trace output.
        MSPLOGDEREGISTER();

        _Module.Term();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\filters.inc ===
# DXMRTP=1   Link all binaries into DXMRTP
# DXMRTP=0   Every binary is a separate DLL
DXMRTP=1

!if $(DXMRTP)
C_DEFINES=$(C_DEFINES) \
    -DDXMRTP=1
!endif

# DXMRTP_NOVIDEO=1 Remove video from dxmrtp.dll
# DXMRTP_NOVIDEO=0 Keep video in dxmrtp.dll (default)
DXMRTP_NOVIDEO=0

!if $(DXMRTP_NOVIDEO)
C_DEFINES=$(C_DEFINES) \
    -DDXMRTP_NOVIDEO=1
!endif

# AEC=1   Enable AEC.
# AEC=0   Disable AEC.
AEC=1

!if $(AEC)
C_DEFINES=$(C_DEFINES) \
    -DAEC=1
!endif

# XTRA_TRACE=1   Enable xtra trace options (even in free builds)
# XTRA_TRACE=0   Clean retail build w/o any xtra trace features
XTRA_TRACE=0

!if $(XTRA_TRACE)
C_DEFINES=$(C_DEFINES) \
    -DXTRA_TRACE=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\dxmrtp\dxmrtp.cpp ===
#if DXMRTP > 0

#include <objbase.h>
#include <windows.h>
#include <winbase.h>
#include <streams.h>

// #include <crtdbg.h>

#include <tapiaud.h>
#include <tapivid.h>
#include <tapirtp.h>
#include <filterid.h>
#include <audtempl.h>
#include <rtptempl.h>
#include <rtpinit.h>
#include <vidctemp.h>
#include <viddtemp.h>
#include <tpdbg.h>

CFactoryTemplate g_Templates[] = 
{
    /* enchdler */
    AUDIO_HANDLER_TEMPLATE_ENCODING
    ,AUDIO_HANDLER_TEMPLATE_DECODING

    /* tpaudcap */
    ,AUDIO_CAPTURE_TEMPLATE
#if AEC
    ,AUDIO_DUPLEX_DEVICE_TEMPLATE
#endif
    /* tpauddec */
    ,AUDIO_DECODE_TEMPLATE

    /* tpaudenc */
    ,AUDIO_ENCODE_TEMPLATE

    /* tpaudren */
    ,AUDIO_RENDER_TEMPLATE

    /* tpaudmix */
    ,AUDIO_MIXER_TEMPLATE

    /* tapih26x */
    /* NA */

#if defined(i386) && (DXMRTP_NOVIDEO == 0)
    /* tapivcap */
    ,VIDEO_CAPTURE_TEMPLATE
    
#ifdef USE_PROPERTY_PAGES
    /* Begin properties */

#ifdef USE_SOFTWARE_CAMERA_CONTROL
    ,CAPCAMERA_CONTROL_TEMPLATE
#endif
    
#ifdef USE_NETWORK_STATISTICS
    ,NETWORK_STATISTICS_TEMPLATE
#endif
    
#ifdef USE_PROGRESSIVE_REFINEMENT
    ,CAPTURE_PIN_TEMPLATE
#endif
    
    ,CAPTURE_PIN_PROP_TEMPLATE
    ,PREVIEW_PIN_TEMPLATE
    ,CAPTURE_DEV_PROP_TEMPLATE
    
#ifdef USE_CPU_CONTROL
    ,CPU_CONTROL_TEMPLATE
#endif
    
    ,RTP_PD_PROP_TEMPLATE
    
    /* End properties */
#endif /* USE_PROPERTY_PAGES */

    /* tapivdec */
    ,VIDEO_DECODER_TEMPLATE

#ifdef USE_PROPERTY_PAGES
/* Begin properties */

    ,INPUT_PIN_PROP_TEMPLATE

    ,OUTPUT_PIN_PROP_TEMPLATE

#ifdef USE_CAMERA_CONTROL
    ,DECCAMERA_CONTROL_TEMPLATE
#endif

#ifdef USE_VIDEO_PROCAMP
    ,VIDEO_SETTING_PROP_TEMPLATE
#endif

/* End properties */
#endif /* USE_PROPERTY_PAGES */

#endif //defined(i386) && (DXMRTP_NOVIDEO == 0)

    ,RTP_SOURCE_TEMPLATE

    ,RTP_RENDER_TEMPLATE
};

int g_cTemplates = (sizeof(g_Templates)/sizeof(g_Templates[0]));

//
// Register with Amovie's helper functions.
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );

}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );

} 

/*********************************************************************
 * Entry point
 *********************************************************************/

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);

BOOL WINAPI DllMain(
        HINSTANCE        hInstance,
        ULONG            ulReason,
        LPVOID           pv
    )
{
    BOOL             res;
    HRESULT          hr;

/*
    if (ulReason == DLL_PROCESS_ATTACH)
    {
        _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
    }
*/

#if defined(i386) && (DXMRTP_NOVIDEO == 0)
    if (!VideoInit(ulReason))
        return FALSE;
#endif

    if (ulReason == DLL_PROCESS_ATTACH)
    {
        AudInit();
        
        hr = MSRtpInit1(hInstance);

        if (FAILED(hr))
        {
            AudDeinit();

            res = FALSE;

            goto end;
        }
    }
    
    res = DllEntryPoint(hInstance, ulReason, pv);

    if (ulReason == DLL_PROCESS_DETACH)
    {
/*
        _RPT0( _CRT_WARN, "Going to call dump memory leaks.\n");
        _CrtDumpMemoryLeaks();
*/
        AudDeinit();
        
        hr = MSRtpDelete1();

        if (FAILED(hr))
        {
            res = FALSE;

            goto end;
        }
    }

 end:
    return(res);
}

#endif /* DXMRTP > 0 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\inc\filterid.h ===
#ifndef _filterid_h_
#define _filterid_h_

// 
// This file defines guids shared among filters.
//

/**********************************************************************
 * object GUIDs
 **********************************************************************/

// {1dcd0710-0b41-11d3-a565-00c04f8ef6e3} 
struct DECLSPEC_UUID("1dcd0710-0b41-11d3-a565-00c04f8ef6e3") TAPI_ENCODING_HANDLER;
#define CLSID_TAPI_ENCODING_HANDLER (__uuidof(TAPI_ENCODING_HANDLER))

struct DECLSPEC_UUID("1dcd0711-0b41-11d3-a565-00c04f8ef6e3") TAPI_DECODING_HANDLER;
#define CLSID_TAPI_DECODING_HANDLER (__uuidof(TAPI_DECODING_HANDLER))


/**********************************************************************
 * Media types GUIDs
 **********************************************************************/

/* {14099BC0-787B-11d0-9CD3-00A0C9081C19} */
// DEFINE_GUID(MEDIATYPE_RTP_Single_Stream, 
// 0x14099bc0, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);
struct DECLSPEC_UUID("14099BC0-787B-11d0-9CD3-00A0C9081C19") _MEDIATYPE_RTP_Single_Stream;
#define MEDIATYPE_RTP_Single_Stream (__uuidof(_MEDIATYPE_RTP_Single_Stream))

// DEFINE_GUID(MEDIASUBTYPE_H263_V1,
// 0x3336324DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71);
struct DECLSPEC_UUID("3336324D-0000-0010-8000-00AA00389B71") _MEDIASUBTYPE_H263_V1;
#define MEDIASUBTYPE_H263_V1 (__uuidof(_MEDIASUBTYPE_H263_V1))


// DEFINE_GUID(MEDIASUBTYPE_H261,
// 0x3136324DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71);
struct DECLSPEC_UUID("3136324D-0000-0010-8000-00AA00389B71") _MEDIASUBTYPE_H261;
#define MEDIASUBTYPE_H261 (__uuidof(_MEDIASUBTYPE_H261))

// DEFINE_GUID(MEDIASUBTYPE_H263_V2,
// 0x3336324EL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71);
struct DECLSPEC_UUID("3336324e-0000-0010-8000-00AA00389B71") _MEDIASUBTYPE_H263_V2;
#define MEDIASUBTYPE_H263_V2 (__uuidof(_MEDIASUBTYPE_H263_V2))

// RTP packetization descriptor pin GUID
struct DECLSPEC_UUID("9e2fb490-2051-46cd-b9f0-063307996935") _KSDATAFORMAT_TYPE_RTP_PD;
#define KSDATAFORMAT_TYPE_RTP_PD (__uuidof(_KSDATAFORMAT_TYPE_RTP_PD))

// Undefined DDraw formats
// DEFINE_GUID(MEDIASUBTYPE_I420,
// 0x30323449L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71);
struct DECLSPEC_UUID("30323449-0000-0010-8000-00AA00389B71") _MEDIASUBTYPE_I420;
#define MEDIASUBTYPE_I420 (__uuidof(_MEDIASUBTYPE_I420))

/**********************************************************************
 * Property page GUIDs
 **********************************************************************/


#ifdef USE_PROPERTY_PAGES

// Capture pin property page CLSID
struct DECLSPEC_UUID("efc975b3-9c92-4ebb-b966-4e861aedd897") CapturePropertyPage;

// Preview pin property page CLSID
struct DECLSPEC_UUID("5cfcacbd-0e35-47d5-9e07-a4c8c4f12145") PreviewPropertyPage;

// Capture device property page CLSID
struct DECLSPEC_UUID("cc73d6f6-93a8-4a56-91f7-be1e272212a6") CaptureDevicePropertyPage;

// Rtp Pd pin property page CLSID
struct DECLSPEC_UUID("be24891b-ebe5-43a2-a18b-1299104157d9") RtpPdPropertyPage;

#ifdef USE_CPU_CONTROL
// CPU Control property page CLSID
struct DECLSPEC_UUID("a485a8e8-55d4-4ebc-9221-5564117d15c9") CPUCPropertyPage;
#endif

#ifdef USE_PROGRESSIVE_REFINEMENT
// Progressive refinement property page CLSID
struct DECLSPEC_UUID("9a80c9de-24f1-4f28-9b5c-2746573c8c7e") ProgRefPropertyPage;
#endif

#ifdef USE_SOFTWARE_CAMERA_CONTROL
// Camera control property page CLSID
struct DECLSPEC_UUID("78a22d55-3519-4ed4-b204-d6e1a9dcdb4b") TAPICameraControlPropertyPage;
#endif

// Video proc amp property page CLSID
struct DECLSPEC_UUID("b6787f6b-1e36-489a-9460-d59b9ac40199") TAPIProcAmpPropertyPage;

#ifdef USE_NETWORK_STATISTICS
// Network statistics property page CLSID
struct DECLSPEC_UUID("b62b51ba-53ff-4d58-9b29-f134e41b9a73") NetworkStatsPropertyPage;
#endif

// Video decoder input pin property page CLSID
struct DECLSPEC_UUID("fe8877d2-eb94-4d85-ae07-f450f3d2e50a") TAPIVDecInputPinPropertyPage;

// Video decoder output pin property page CLSID
struct DECLSPEC_UUID("58336f1b-42c6-494b-9601-5830ec502500") TAPIVDecOutputPinPropertyPage;

#ifdef USE_CAMERA_CONTROL
// Camera control property page CLSID
struct DECLSPEC_UUID("f6890a20-e6b5-4aa5-8817-796c7027418f") TAPICameraControlPropertyPage;
#endif

#ifdef USE_VIDEO_PROCAMP
// Video proc amp property page CLSID
struct DECLSPEC_UUID("7e38868e-824b-465f-9b67-5524efb4a62a") TAPIProcAmpPropertyPage;
#endif

#endif // USE_PROPERTY_PAGES


/* {14099BC1-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc1-787b-11d0-9cd3-00a0c9081c19") _MEDIATYPE_RTP_Multiple_Stream;
#define MEDIATYPE_RTP_Multiple_Stream (__uuidof(_MEDIATYPE_RTP_Multiple_Stream))

struct DECLSPEC_UUID("14099bc2-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_Mixed;
#define MEDIASUBTYPE_RTP_Payload_Mixed (__uuidof(_MEDIASUBTYPE_RTP_Payload_Mixed))

/* {14099BC3-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc3-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_G711U;
#define MEDIASUBTYPE_RTP_Payload_G711U (__uuidof(_MEDIASUBTYPE_RTP_Payload_G711U))

/* {14099BC4-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc4-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_G711A;
#define MEDIASUBTYPE_RTP_Payload_G711A (__uuidof(_MEDIASUBTYPE_RTP_Payload_G711A))

/* {14099BC5-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc5-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_G723;
#define MEDIASUBTYPE_RTP_Payload_G723 (__uuidof(_MEDIASUBTYPE_RTP_Payload_G723))

/* {14099BC6-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc6-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_H261;
#define MEDIASUBTYPE_RTP_Payload_H261 (__uuidof(_MEDIASUBTYPE_RTP_Payload_H261))

/* {14099BC7-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc7-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_H263;
#define MEDIASUBTYPE_RTP_Payload_H263 (__uuidof(_MEDIASUBTYPE_RTP_Payload_H263))

/* {14099BCA-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc8-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_ANY;
#define MEDIASUBTYPE_RTP_Payload_ANY (__uuidof(_MEDIASUBTYPE_RTP_Payload_ANY))

/* {33363248-0000-0010-8000-00AA00389B71} */
struct DECLSPEC_UUID("33363248-0000-0010-8000-00aa00389b71") _MEDIASUBTYPE_H263;
#define MEDIASUBTYPE_H263 (__uuidof(_MEDIASUBTYPE_H263))

/* {14099BC8-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc8-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_H263EX;
#define MEDIASUBTYPE_H263EX (__uuidof(_MEDIASUBTYPE_H263EX))

#if 0
/* {31363248-0000-0010-8000-00AA00389B71} */
struct DECLSPEC_UUID("31363248-0000-0010-8000-00aa00389b71") _MEDIASUBTYPE_H261;
#define MEDIASUBTYPE_H261 (__uuidof(_MEDIASUBTYPE_H261))
#endif

/* {14099BC9-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc9-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_H261EX;
#define MEDIASUBTYPE_H261EX (__uuidof(_MEDIASUBTYPE_H261EX))


#endif /* _filterid_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\inc\audtempl.h ===
#ifndef _audio_template_h_
#define _audio_template_h_

/**********************************************************************
 * enchdler
 **********************************************************************/
extern CUnknown*
CALLBACK
CreateEncodingHandlerInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );

#define AUDIO_HANDLER_TEMPLATE_ENCODING \
{ \
    L"codec handler", \
    &__uuidof(TAPI_ENCODING_HANDLER), \
    CreateEncodingHandlerInstance, \
    NULL, \
    NULL \
}

extern CUnknown*
CALLBACK
CreateDecodingHandlerInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );

#define AUDIO_HANDLER_TEMPLATE_DECODING \
{ \
    L"DecodingHandler", \
    &__uuidof(TAPI_DECODING_HANDLER), \
    CreateDecodingHandlerInstance, \
    NULL, \
    NULL \
}

/**********************************************************************
 * tpaudcap
 **********************************************************************/

extern CUnknown*
CALLBACK
CreateAudioCaptureInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );


#ifdef USE_GRAPHEDT
extern const AMOVIESETUP_FILTER sudAudCap;

#define AUDIO_CAPTURE_TEMPLATE \
{ \
    L"Tapi Audio Capture Filter", \
    &__uuidof(TAPIAudioCapture), \
    CreateAudioCaptureInstance, \
    NULL, \
    &sudAudCap \
}
#else /* USE_GRAPHEDT */
#define AUDIO_CAPTURE_TEMPLATE \
{ \
    L"Tapi Audio Capture Filter", \
    &__uuidof(TAPIAudioCapture), \
    CreateAudioCaptureInstance, \
    NULL, \
    NULL \
}
#endif /* USE_GRAPHEDT */

#if AEC

extern CUnknown*
CALLBACK
CreateDuplexControllerInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );


#define AUDIO_DUPLEX_DEVICE_TEMPLATE \
{ \
    L"TAPI audio duplex device controller", \
    &__uuidof(TAPIAudioDuplexController), \
    CreateDuplexControllerInstance, \
    NULL, \
    NULL \
}
#endif /* AEC */

/**********************************************************************
 * tpauddec
 **********************************************************************/
extern CUnknown*
CALLBACK
CreateAudioDecoderInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );

#ifdef USE_GRAPHEDT
extern const AMOVIESETUP_FILTER sudAudDec;

#define AUDIO_DECODE_TEMPLATE \
{ \
    L"Tapi Audio Decode Filter", \
    &__uuidof(TAPIAudioDecoder), \
    CreateAudioDecoderInstance, \
    NULL, \
    &sudAudDec \
}
#else /* USE_GRAPHEDT */
#define AUDIO_DECODE_TEMPLATE \
{ \
    L"Tapi Audio Decode Filter", \
    &__uuidof(TAPIAudioDecoder), \
    CreateAudioDecoderInstance, \
    NULL, \
    NULL \
}
#endif /* USE_GRAPHEDT */

/**********************************************************************
 * tpaudenc
 **********************************************************************/
extern CUnknown*
CALLBACK
CreateAudioEncoderInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );

#ifdef USE_GRAPHEDT
extern const AMOVIESETUP_FILTER sudAudEnc;

#define AUDIO_ENCODE_TEMPLATE \
{ \
    L"Tapi Audio Encoder Filter", \
    &__uuidof(TAPIAudioEncoder), \
    CreateAudioEncoderInstance, \
    NULL, \
    &sudAudEnc \
}
#else /* USE_GRAPHEDT */
#define AUDIO_ENCODE_TEMPLATE \
{ \
    L"Tapi Audio Encoder Filter", \
    &__uuidof(TAPIAudioEncoder), \
    CreateAudioEncoderInstance, \
    NULL, \
    NULL \
}
#endif /* USE_GRAPHEDT */

/**********************************************************************
 * tpaudren
 **********************************************************************/
extern CUnknown*
CALLBACK
CreateAudioRenderInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );

#ifdef USE_GRAPHEDT
extern const AMOVIESETUP_FILTER sudAudRen;

#define AUDIO_RENDER_TEMPLATE \
{ \
    L"Tapi Audio Render Filter", \
    &__uuidof(TAPIAudioRender), \
    CreateAudioRenderInstance, \
    NULL, \
    &sudAudRen \
}
#else /* USE_GRAPHEDT */
#define AUDIO_RENDER_TEMPLATE \
{ \
    L"Tapi Audio Render Filter", \
    &__uuidof(TAPIAudioRender), \
    CreateAudioRenderInstance, \
    NULL, \
    NULL \
}
#endif /* USE_GRAPHEDT */

/**********************************************************************
 * tpaudmix
 **********************************************************************/
extern CUnknown*
CALLBACK
CreateAudioMixerInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );

#ifdef USE_GRAPHEDT
extern const AMOVIESETUP_FILTER sudAudMix;

#define AUDIO_MIXER_TEMPLATE \
{ \
    L"Tapi Audio Mixer Filter", \
    &__uuidof(TAPIAudioMixer), \
    CreateAudioMixerInstance, \
    NULL, \
    &sudAudMix \
}
#else /* USE_GRAPHEDT */
#define AUDIO_MIXER_TEMPLATE \
{ \
    L"Tapi Audio Mixer Filter", \
    &__uuidof(TAPIAudioMixer), \
    CreateAudioMixerInstance, \
    NULL, \
    NULL \
}
#endif /* USE_GRAPHEDT */

#endif /* _audio_template_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\inc\rtptempl.h ===
#ifndef _rtp_template_h_
#define _rtp_template_h_

#if USE_GRAPHEDT > 0
#define SOURCE_INFO &g_RtpSourceFilter
#define RENDER_INFO &g_RtpRenderFilter
#else
#define SOURCE_INFO NULL
#define RENDER_INFO NULL
#endif

/* RTP Source */
extern const AMOVIESETUP_FILTER g_RtpSourceFilter;
extern CUnknown *CRtpSourceFilterCreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
#define RTP_SOURCE_TEMPLATE \
{ \
    L"Tapi RTP Source Filter", \
    &__uuidof(MSRTPSourceFilter), \
    CRtpSourceFilterCreateInstance, \
    NULL, \
    SOURCE_INFO \
}

/* RTP Render */
extern const AMOVIESETUP_FILTER g_RtpRenderFilter;
extern CUnknown *CRtpRenderFilterCreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
#define RTP_RENDER_TEMPLATE \
{ \
    L"Tapi RTP Render Filter", \
    &__uuidof(MSRTPRenderFilter), \
    CRtpRenderFilterCreateInstance, \
    NULL, \
    RENDER_INFO \
}

#endif /* _rtp_template_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\inc\rtphdr.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtphdr.h
 *
 *  Abstract:
 *
 *    Defines only the RTP/RTCP specific headers
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#ifndef _rtphdr_h_
#define _rtphdr_h_

/*
 * !!! WARNING !!!
 *
 * Diagrams below are in NETWORK order (big endian) which is different
 * from x86 (little endian).
 *
 * All fields are data coming/goin from/to the network, hence they are
 * received/sent in NETWORK order
 * */

/*
 * Current protocol version.
 * */
#define RTP_VERSION    2

#define RTP_SEQ_MOD    (1<<16)
#define RTP_MAX_SDES   255      /* maximum text length for SDES */

#define MAX_RTCP_RBLOCKS 31     /* 5 bits */

#define NO_PAYLOADTYPE 255
#define NO_SSRC        ~0
#define NO_FREQUENCY   ~0


/**********************************************************************
 * RTP data header.
 **********************************************************************
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                             ....                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   
*/
typedef struct _RtpHdr_t {
    WORD cc      : 4; /* CSRC count */
    WORD x       : 1; /* header extension flag */
    WORD p       : 1; /* padding flag */
    WORD version : 2; /* protocol version */
    
    WORD pt      : 7; /* payload type */
    WORD m       : 1; /* marker bit */
    
    WORD seq;         /* sequence number */

    DWORD ts;         /* timestamp */
    
    DWORD ssrc;       /* synchronization source */
} RtpHdr_t;

/**********************************************************************
 * RTP Header Extension
 **********************************************************************

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      defined by profile       |           length              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        header extension                       |
   |                             ....                              |
*/

typedef struct _RtpHdrExt_t {
    WORD             exttype;
    WORD             length;  /* number of 32-bit words in the
                               * extension, excluding the four-octet
                               * extension header */
} RtpHdrExt_t;

/**********************************************************************
 * RTCP common header word.
 **********************************************************************
     0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|    RC   |      PT       |             length            | header
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

*/

/*
 * RTCP packets's payload type (pt) field
 * */
enum {
    RTCP_SR   = 200,
    RTCP_RR   = 201,
    RTCP_SDES = 202,
    RTCP_BYE  = 203,
    RTCP_APP  = 204
};

/*
 * RTCP common header
 * */
typedef struct _RtcpCommon_t {
    BYTE count   : 5; /* varies by packet type */
    BYTE p       : 1; /* padding flag */
    BYTE version : 2; /* protocol version */
    
    BYTE pt;          /* RTCP packet type */
    
    WORD length;      /* packet len in 32-bit words, w/o this word */
} RtcpCommon_t;

/*
 * Network order (big-endian) mask for version, padding bit and packet
 * type pair on a little endian processor
 * */
#define RTCP_VALID_MASK   (0xc0 | 0x20 | 0xfe00)
#define RTCP_VALID_VALUE  ((RTP_VERSION << 6) | (RTCP_SR << 8))

/**********************************************************************
 * RTPC receiver report (RR) header.
 **********************************************************************

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|    RC   |   PT=RR=201   |             length            | header
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     SSRC of packet sender                     |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                 SSRC_1 (SSRC of first source)                 | report
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
   | fraction lost |       cumulative number of packets lost       |   1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           extended highest sequence number received           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      interarrival jitter                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         last SR (LSR)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   delay since last SR (DLSR)                  |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                 SSRC_2 (SSRC of second source)                | report
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
   :                               ...                             :   2
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                  profile-specific extensions                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

/*
 * Reception report block
 * */
typedef struct _RtcpRBlock_t {
    DWORD ssrc;             /* data source being reported */
    
    DWORD frac_cumlost;     /* fraction lost since last SR/RR and
                             * cumulative number of packets lost
                             * (signed!) (in NETWORK order, fraction =
                             * higher 8 bits, lost = 24 lower bits) */
    
    DWORD last_seq;         /* extended last seq. no. received */
    DWORD jitter;           /* interarrival jitter */
    DWORD lsr;              /* last SR packet from this source (low 16
                             * bits of integer part and high 16 bits
                             * of fraction) */
    DWORD dlsr;             /* delay since last SR packet (16 bits for
                             * integer part and 16 bits for fraction) */
} RtcpRBlock_t;

/**********************************************************************
 * RTPC sender report (SR) header.
 **********************************************************************
 
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|    RC   |   PT=SR=200   |             length            | header
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         SSRC of sender                        |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |              NTP timestamp, most significant word             | sender
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ info
   |             NTP timestamp, least significant word             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         RTP timestamp                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     sender's packet count                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      sender's octet count                     |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                 SSRC_1 (SSRC of first source)                 | report
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
   | fraction lost |       cumulative number of packets lost       |   1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           extended highest sequence number received           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      interarrival jitter                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         last SR (LSR)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   delay since last SR (DLSR)                  |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                 SSRC_2 (SSRC of second source)                | report
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
   :                               ...                             :   2
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                  profile-specific extensions                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

*/

/*
 * sender information
 * */
typedef struct _RtcpSInfo_t {
    DWORD ntp_sec;  /* NTP timestamp (seconds)*/
    DWORD ntp_frac; /* NTP timestamp (fraction) */
    DWORD rtp_ts;   /* RTP timestamp */
    DWORD psent;    /* packets sent */
    DWORD bsent;    /* bytes sent */
} RtcpSInfo_t;

/**********************************************************************
 * RTCP SDES
 **********************************************************************

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|    SC   |  PT=SDES=202  |             length            | header
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                          SSRC/CSRC_1                          | chunk
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   1
   |                           SDES items                          |
   |                              ...                              |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                          SSRC/CSRC_2                          | chunk
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   2
   |                           SDES items                          |
   |                              ...                              |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*/

/**********************************************************************
 * SDES items
 **********************************************************************
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    CNAME=1    |     length    | user and domain name         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NAME=2    |     length    | common name of source        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    EMAIL=3    |     length    | email address of source      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    PHONE=4    |     length    | phone number of source       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     LOC=5     |     length    | geographic location of site  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     TOOL=6    |     length    | name/version of source appl. ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NOTE=7    |     length    | note about the source        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     PRIV=8    |     length    | prefix length | prefix string...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ...             |                  value string                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

/*
 * Types of SDES information
 * */
enum {
    RTCP_SDES_END   = 0,
    RTCP_SDES_CNAME = 1,
    RTCP_SDES_NAME  = 2,
    RTCP_SDES_EMAIL = 3,
    RTCP_SDES_PHONE = 4,
    RTCP_SDES_LOC   = 5,
    RTCP_SDES_TOOL  = 6,
    RTCP_SDES_NOTE  = 7,
    RTCP_SDES_PRIV  = 8,
    RTCP_SDES_BYE   = 9, /* Used to save the BYE reason */
    RTCP_SDES_LAST
};

#define RTCP_SDES_FIRST RTCP_SDES_END

#define RTCP_NUM_SDES (RTCP_SDES_LAST - RTCP_SDES_FIRST - 1)
#define RTCP_MAX_SDES_SIZE 256

/*
 * Sdes item
 * */
typedef struct _RtcpSdesItem_t {
    BYTE type;              /* type of item (SDES) */
    BYTE length;            /* length of item (in octets), not
                             * including this two-octet header */
  /*char data[2];              text, not null-terminated */
} RtcpSdesItem_t;

/**********************************************************************
 * BYE
 **********************************************************************
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|    SC   |   PT=BYE=203  |             length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           SSRC/CSRC                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   :                              ...                              :
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |     length    |               reason for leaving             ... (opt)
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

/**********************************************************************
 * DTMF (RFC2833)
 **********************************************************************
 
                     Event  encoding (decimal)
                     _________________________
                     0--9                0--9
                     *                     10
                     #                     11
                     A--D              12--15
                     Flash                 16

                        DTMF named events

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     event     |E|R| volume    |          duration             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

typedef struct _RtpDtmfEvent_t {
    BYTE event;       /* Event encoded as shown in rfc2833/3.10 */

    BYTE volume  : 6; /* Tone's volume rfc2833/3.5 */
    BYTE r       : 1; /* Reserved */
    BYTE e       : 1; /* End of the event */

    WORD duration;    /* Duration of this digit in timestamp units */
} RtpDtmfEvent_t;

/**********************************************************************
 * Redundant audio (RFC2198)
 **********************************************************************

 When F=1
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |F|   block PT  |  timestamp offset         |   block length    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 When F=0
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |F|   Block PT  |
   +-+-+-+-+-+-+-+-+

   timestamp offset (14) unsigned (negative) offset of timestamp of
   this block relative to timestamp given in RTP header
   
   block length (10) in bytes of the corresponding data block
   excluding header

*/

typedef struct _RtpRedHdr_t {
    BYTE pt      : 7; /* payload type for this block */
    BYTE F       : 1; /* set to 1 indicates more headers follow, 0 for
                       * final/main */
    BYTE ts_high;     /* 8 msbits of timestamp offset */

    BYTE len_high: 2; /* 2 msbits of length */
    BYTE ts_low  : 6; /* 6 lsbits of timestamp offset */

    BYTE len_low;     /* 8 lsbits of length */
} RtpRedHdr_t;

#define RTP_PLUS_RED_HDR_SIZE (sizeof(RtpHdr_t) + \
                               sizeof(RtpRedHdr_t) * (RTP_RED_MAXRED+1))

#define RedLen(pr) ((DWORD)pr->len_low | (pr->len_high << 8))
#define RedTs(pr)  ((DWORD)pr->ts_low  | (pr->ts_high  << 6))

#define PutRedLen(pr, len) \
        {pr->len_low=(BYTE)((len)&0xff);pr->len_high=(BYTE)(((len)>>8)&0x03);}

#define PutRedTs(pr, ts) \
        {pr->ts_low= (BYTE)((ts)&0x3f); pr->ts_high= (BYTE)(((ts) >>6)&0xff);}

/**********************************************************************
 * Profile Extension header
 **********************************************************************

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            type               |          length               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

typedef struct _RtpPEHdr_t {
    WORD  type; /* Type of profile extension */
    WORD  len;  /* Lenght in bytes for the extension including this
                 * header */
} RtpPEHdr_t;

/* Type of profile extensions supported */
enum {
    RTPPE_FIRST,

    RTPPE_BANDESTIMATION,   /* Bandwidth estimation */
    RTPPE_REDLOSSRATE,      /* Loss rate after packet reconstruction */
    
    RTPPE_LAST
};

typedef struct _RtpBandEst_t {
    WORD  type; /* Type of profile extension */
    WORD  len;  /* Lenght in bytes for the extension including this
                 * header */
    DWORD       dwSSRC;       /* SSRC for whom bandwidth is reported */
    DWORD       dwBandwidth;  /* Bandwidth in Kbps */
} RtpBandEst_t;

#endif /* _rtphdr_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\inc\rtpinit.h ===
#ifndef _rtp_init_h_
#define _rtp_init_h_

#if defined(_DSRTP_)
/* The API functions are linked as a library with DShow RTP */
#define RTPSTDAPI HRESULT
#else
/* The API functions are in separate dll (not COM, not DShow) */
#define RTPSTDAPI __declspec (dllexport) HRESULT WINAPI
#endif

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/*
 * Initializes all the modules that require initialization. This
 * function can be called from DllMain(PROCESS_ATTACH) if linked as a
 * DLL, or explicitly from an application initializing the RTP stack
 * if linked as a library. */
RTPSTDAPI MSRtpInit1(HINSTANCE hInstance);

/*
 * Complementary function of MSRtpInit(). Can be called from
 * DllMain(PROCESS_DETACH) if linked as a DLL, or explicitly from an
 * application de-initializing the RTP stack if linked as a
 * library. */
RTPSTDAPI MSRtpDelete1(void);

/*
 * This functions does initialization not allowed during process
 * attach, e.g. initialize winsock2 */
RTPSTDAPI MSRtpInit2(void);

/*
 * Complementary function of MSRtpInit2(). */
RTPSTDAPI MSRtpDelete2(void);

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtp_init_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\inc\tpdbg.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    tpdbg.h
 *
 *  Abstract:
 *
 *    Some debuging support for TAPI filters
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/08/31 created
 *
 **********************************************************************/
#ifndef _tpdbg_h_
#define _tpdbg_h_

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

#define AUDTAG_FIRST                    0x00  /*  0 */
#define AUDTAG_AUDENCHANDLER            0x01  /*  1 */
#define AUDTAG_AUDCAPINPIN              0x02  /*  2 */
#define AUDTAG_AUDCAPOUTPIN             0x03  /*  3 */
#define AUDTAG_AUDCAPFILTER             0x04  /*  4 */
#define AUDTAG_AUDCAPDUPLEXCONTROLLER   0x05  /*  5 */
#define AUDTAG_AUDCAPDSOUNDCAPTURE      0x06  /*  6 */
#define AUDTAG_AUDCAPDTMFCONTROL        0x07  /*  7 */
#define AUDTAG_AUDWAVEINCAPTURE         0x08  /*  8 */
#define AUDTAG_AUDDECINPIN              0x09  /*  9 */
#define AUDTAG_AUDDECOUTPIN             0x0A  /* 10 */
#define AUDTAG_AUDDECFILTER             0x0B  /* 11 */
#define AUDTAG_AUDENCINPIN              0x0C  /* 12 */
#define AUDTAG_AUDENCOUTPIN             0x0D  /* 13 */
#define AUDTAG_AUDENCFILTER             0x0E  /* 14 */
#define AUDTAG_AUDMIXINPIN              0x0F  /* 15 */
#define AUDTAG_AUDMIXOUTPIN             0x10  /* 16 */
#define AUDTAG_AUDMIXFILTER             0x11  /* 17 */
#define AUDTAG_AUDRENINPIN              0x12  /* 18 */
#define AUDTAG_AUDRENFILTER             0x13  /* 19 */
#define AUDTAG_AUDMIXCHANEL             0x14  /* 20 */
#define AUDTAG_AUDDSOUNDREND            0x15  /* 21 */
#define AUDTAG_LAST                     0x16  /* 22 */

#define AUDOBJECTID_B2B1       0x005bb500

#define BUILD_OBJECTID(t)       (((t) << 24) | AUDOBJECTID_B2B1 | t)
#define INVALIDATE_OBJECTID(oi) (oi &= ~0xff)

#define OBJECTID_AUDENCHANDLER          BUILD_OBJECTID(AUDTAG_AUDENCHANDLER)
#define OBJECTID_AUDCAPINPIN            BUILD_OBJECTID(AUDTAG_AUDCAPINPIN)
#define OBJECTID_AUDCAPOUTPIN           BUILD_OBJECTID(AUDTAG_AUDCAPOUTPIN)
#define OBJECTID_AUDCAPFILTER           BUILD_OBJECTID(AUDTAG_AUDCAPFILTER)
#define OBJECTID_AUDCAPDUPLEXCONTROLLER BUILD_OBJECTID(AUDTAG_AUDCAPDUPLEXCONTROLLER)
#define OBJECTID_AUDCAPDSOUNDCAPTURE    BUILD_OBJECTID(AUDTAG_AUDCAPDSOUNDCAPTURE)
#define OBJECTID_AUDCAPDTMFCONTROL      BUILD_OBJECTID(AUDTAG_AUDCAPDTMFCONTROL)
#define OBJECTID_AUDWAVEINCAPTURE       BUILD_OBJECTID(AUDTAG_AUDWAVEINCAPTURE)
#define OBJECTID_AUDDECINPIN            BUILD_OBJECTID(AUDTAG_AUDDECINPIN)
#define OBJECTID_AUDDECOUTPIN           BUILD_OBJECTID(AUDTAG_AUDDECOUTPIN)
#define OBJECTID_AUDDECFILTER           BUILD_OBJECTID(AUDTAG_AUDDECFILTER)
#define OBJECTID_AUDENCINPIN            BUILD_OBJECTID(AUDTAG_AUDENCINPIN)
#define OBJECTID_AUDENCOUTPIN           BUILD_OBJECTID(AUDTAG_AUDENCOUTPIN)
#define OBJECTID_AUDENCFILTER           BUILD_OBJECTID(AUDTAG_AUDENCFILTER)
#define OBJECTID_AUDMIXINPIN            BUILD_OBJECTID(AUDTAG_AUDMIXINPIN)
#define OBJECTID_AUDMIXOUTPIN           BUILD_OBJECTID(AUDTAG_AUDMIXOUTPIN)
#define OBJECTID_AUDMIXFILTER           BUILD_OBJECTID(AUDTAG_AUDMIXFILTER)
#define OBJECTID_AUDRENINPIN            BUILD_OBJECTID(AUDTAG_AUDRENINPIN)
#define OBJECTID_AUDRENFILTER           BUILD_OBJECTID(AUDTAG_AUDRENFILTER)
#define OBJECTID_AUDMIXCHANEL           BUILD_OBJECTID(AUDTAG_AUDMIXCHANEL)
#define OBJECTID_AUDDSOUNDREND          BUILD_OBJECTID(AUDTAG_AUDDSOUNDREND)

typedef struct _QueueItem_t QueueItem_t;
typedef struct _Queue_t     Queue_t;

/*
 * Every object maintained in a queue or a queue/hash will include
 * this structure */
typedef struct _QueueItem_t {
    struct _QueueItem_t *pNext; /* next item */
    struct _QueueItem_t *pPrev; /* previous item */
    struct _Queue_t     *pHead; /* used for robustness, points to
                                    * queue's head */
    /* The next field is used at the programer's discretion. Can be
     * used to point back to the parent object, or as a key during
     * searches, it is the programer's responsibility to set this
     * value, it is not used by the queue/hash functions (except
     * the "Ordered queue insertion" functions) */
    union {
        void  *pvOther;        /* may be used as a general purpose ptr */
        double dKey;           /* may be used as a double key for searches */
        DWORD  dwKey;          /* may be used as DWORD key for searches */
    };
} QueueItem_t;

/*
 * !!! WARNING !!!
 *
 * RtpQueue_t and RtpQueueHash can be casted to each other.
 *
 * A negative count indicates pFirst (or indeed pvTable) is a hash
 * table. This is safe because a hash is destroyed when it has zero
 * elements (becoming a regular queue) and won't be expanded to a hash
 * again but until MAX_QUEUE2HASH_ITEMS items are enqueued */

/*
 * The owner of a queue will include this structure */
typedef struct _Queue_t {
    QueueItem_t         *pFirst;   /* points to first item */
    long                 lCount;   /* number of items in queue (positive) */
} Queue_t;

typedef struct _AudCritSect_t {
    BOOL              bInitOk;
    CRITICAL_SECTION  CritSect;/* critical section */
} AudCritSect_t;

void AudInit();

void AudDeinit();

void AudObjEnqueue(QueueItem_t *pQueueItem, DWORD dwObjectID);

void AudObjDequeue(QueueItem_t *pQueueItem);

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#endif /* _tpdbg_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\inc\tptrace.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name

    tptrace.h

Description

    Defines functions used for tracing for all the TAPI filters.

Note

    Revised based on msplog.h by

    MU Han (muhan) Apr 17 2000

--*/

#ifndef __TPTRACE_H
#define __TPTRACE_H

#ifdef DBG

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)

double RtpGetTimeOfDay(void *);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif

#ifdef DBG

#include <rtutils.h>
#define FAIL ((DWORD)0x00010000 | TRACE_USE_MASK)
#define WARN ((DWORD)0x00020000 | TRACE_USE_MASK)
#define INFO ((DWORD)0x00040000 | TRACE_USE_MASK)
#define TRCE ((DWORD)0x00080000 | TRACE_USE_MASK)
#define ELSE ((DWORD)0x00100000 | TRACE_USE_MASK)



void DBGPrint(DWORD dwTraceID, DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...);
#define DBGOUT(arg) DBGPrint arg

#define ENTER_FUNCTION(s) static char *__fxName = s

#else

#define DBGOUT(arg)
#define ENTER_FUNCTION(s)

#endif // DBG


#endif // _TPTRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\options.inc ===
#**********************************************************************
#*
#*  Copyright (C) Microsoft Corporation, 1999
#*
#*  File name:
#*
#*    common.inc
#*
#*  Abstract:
#*
#*    Common build definitions and libraries
#*
#*  Author:
#*
#*    Andres Vega-Garcia (andresvg)
#*
#*  Revision:
#*
#*    1999/08/31 created
#*
#**********************************************************************

#* To test using GRAPHEDT use
#*     USE_GRAPHEDT=1

#*
#* USE_GRAPHEDT
#*
#* Set to 1 (default 0) if want to use to use RTP under graphedt, i.e. 
#* no body is going to call Init(). Some temporary *MediaType* 
#* functions will also be used
#*
C_DEFINES=\
    $(C_DEFINES) \
    -DUSE_GRAPHEDT=0

#*
#* USE_RTPPREFIX_HDRSIZE
#*
#* Set to 1 (default 1) if want support for RTP header size to
#* be included as a prefix.
#* The buffer is:
#*
#* 1) Prefix: RTP prefix header
#* 2) Begin buffer: RTP header (variable size because of CSRC and extensions)
#* 3) Payload
#*
#* If USE_RTPPREFIX_HDRSIZE is set to 0, then (1) is not used.
#*
C_DEFINES=\
    $(C_DEFINES) \
    -DUSE_RTPPREFIX_HDRSIZE=1

#*
#* Enable Dynamic graph changes
#* Needs some DShow features not present in W2k
#*
C_DEFINES=\
    $(C_DEFINES) \
    -DUSE_DYNGRAPH=0

#*
#* To use UNICODE
#* 0=don't use UNICODE
#* 1=use UNICODE
#*
RTPOPT_USE_UNICODE=1

#*
#* Enable using thread pool for RTCP thread (default 1).
#* By using thread pool, the limitation in RTCP thread to
#* handle 31 RTCP sessions (per thread) is removed.
#* 0=Don't use thread pool
#* 1=Use thread pool
C_DEFINES=\
    $(C_DEFINES) \
    -DUSE_RTCP_THREAD_POOL=1

#*
#* Enable all the TraceDebug to be dependent on the use
#* of UseAdvancedTracing
C_DEFINES=\
    $(C_DEFINES) \
    -DUSE_TRACE_DEBUG=0

#*
#* Enable simulation of random losses in receiver or sender
C_DEFINES=\
    $(C_DEFINES) \
    -DUSE_GEN_LOSSES=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\inc\vidctemp.h ===
#ifndef _vidcap_template_h_
#define _vidcap_template_h_

/**********************************************************************
 * tapih26x
 **********************************************************************/
#if DXMRTP > 0
LRESULT WINAPI H26XDriverProc(
        DWORD            dwDriverID,
        HDRVR            hDriver,
        UINT             uiMessage,
        LPARAM           lParam1,
        LPARAM           lParam2
    );
#endif
/**********************************************************************
 * tapivcap
 **********************************************************************/

extern CUnknown *CALLBACK 
CreateTAPIVCapInstance(IN LPUNKNOWN pUnkOuter, OUT HRESULT *pHr);

#if DXMRTP > 0
BOOL VideoInit(DWORD dwReason);
#endif

#if USE_GRAPHEDT > 0
extern const AMOVIESETUP_FILTER sudVideoCapture;

#define VIDEO_CAPTURE_TEMPLATE \
{ \
    L"TAPI Video Capture", \
    &__uuidof(TAPIVideoCapture), \
    CreateTAPIVCapInstance, \
    NULL, \
    &sudVideoCapture \
}
#else
#define VIDEO_CAPTURE_TEMPLATE \
{ \
    L"TAPI Video Capture", \
    &__uuidof(TAPIVideoCapture), \
    CreateTAPIVCapInstance, \
    NULL, \
    NULL \
}
#endif

#ifdef USE_PROPERTY_PAGES
/* Begin properties */

#ifdef USE_SOFTWARE_CAMERA_CONTROL
extern CUnknown* CALLBACK CCameraControlPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define CAPCAMERA_CONTROL_TEMPLATE \
{ \
    L"TAPI Camera Control Property Page", \
    &__uuidof(TAPICameraControlPropertyPage), \
    CCameraControlPropertiesCreateInstance, \
    NULL, \
    NULL \
}
#endif

#ifdef USE_NETWORK_STATISTICS
extern CUnknown* CALLBACK CNetworkStatsPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define NETWORK_STATISTICS_TEMPLATE \
{ \
    L"TAPI Network Statistics Property Page", \
    &__uuidof(NetworkStatsPropertyPage), \
    CNetworkStatsPropertiesCreateInstance, \
    NULL, \
    NULL \
}
#endif

#ifdef USE_PROGRESSIVE_REFINEMENT
extern CUnknown* CALLBACK CProgRefPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define CAPTURE_PIN_TEMPLATE \
{ \
    L"TAPI Progressive Refinement Property Page", \
    &__uuidof(ProgRefPropertyPage), \
    CProgRefPropertiesCreateInstance, \
    NULL, \
    NULL \
}
#endif

extern CUnknown* CALLBACK CCapturePropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define CAPTURE_PIN_PROP_TEMPLATE \
{ \
    L"TAPI Capture Pin Property Page", \
    &__uuidof(CapturePropertyPage), \
    CCapturePropertiesCreateInstance, \
    NULL, \
    NULL \
}

extern CUnknown* CALLBACK CPreviewPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define PREVIEW_PIN_TEMPLATE \
{ \
    L"TAPI Preview Pin Property Page", \
    &__uuidof(PreviewPropertyPage), \
    CPreviewPropertiesCreateInstance, \
    NULL, \
    NULL \
}

extern CUnknown* CALLBACK CDevicePropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define CAPTURE_DEV_PROP_TEMPLATE \
{ \
    L"TAPI Capture Device Property Page", \
    &__uuidof(CaptureDevicePropertyPage), \
    CDevicePropertiesCreateInstance, \
    NULL, \
    NULL \
}

#ifdef USE_CPU_CONTROL
extern CUnknown* CALLBACK CCPUCPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define CPU_CONTROL_TEMPLATE \
{ \
    L"TAPI CPU Control Property Page", \
    &__uuidof(CPUCPropertyPage), \
    CCPUCPropertiesCreateInstance, \
    NULL, \
    NULL \
}
#endif

extern CUnknown* CALLBACK CRtpPdPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define RTP_PD_PROP_TEMPLATE \
{ \
    L"TAPI Rtp Pd Property Page", \
    &__uuidof(RtpPdPropertyPage), \
    CRtpPdPropertiesCreateInstance, \
    NULL, \
    NULL \
}

/* End properties */
#endif /* USE_PROPERTY_PAGES */

#endif /* _vidcap_template_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\inc\viddtemp.h ===
#ifndef _viddec_template_h_
#define _viddec_template_h_

/**********************************************************************
 * tapih26x
 **********************************************************************/
#if DXMRTP > 0
LRESULT WINAPI H26XDriverProc(
        DWORD            dwDriverID,
        HDRVR            hDriver,
        UINT             uiMessage,
        LPARAM           lParam1,
        LPARAM           lParam2
    );
#endif

/**********************************************************************
 * tapivdec
 **********************************************************************/

extern CUnknown *CALLBACK CTAPIVDecCreateInstance(IN LPUNKNOWN pUnkOuter, OUT HRESULT *pHr);

#if USE_GRAPHEDT > 0
extern const AMOVIESETUP_FILTER sudVideoDecoder;
#define VIDEO_DECODER_TEMPLATE \
{ \
    L"TAPI H.26X Video Decoder", \
    &__uuidof(TAPIVideoDecoder), \
    CTAPIVDecCreateInstance, \
    NULL, \
    &sudVideoDecoder \
}
#else
#define VIDEO_DECODER_TEMPLATE \
{ \
    L"TAPI H.26X Video Decoder", \
    &__uuidof(TAPIVideoDecoder), \
    CTAPIVDecCreateInstance, \
    NULL, \
    NULL \
}
#endif

#ifdef USE_PROPERTY_PAGES
/* Begin properties */

extern CUnknown* CALLBACK CInputPinPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define INPUT_PIN_PROP_TEMPLATE \
{ \
    L"Input Pin Property Page", \
    &__uuidof(TAPIVDecInputPinPropertyPage), \
    CInputPinPropertiesCreateInstance, \
    NULL, \
    NULL \
}

extern CUnknown* CALLBACK COutputPinPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define OUTPUT_PIN_PROP_TEMPLATE \
{ \
    L"Output Pin Property Page", \
    &__uuidof(TAPIVDecOutputPinPropertyPage), \
    COutputPinPropertiesCreateInstance, \
    NULL, \
    NULL \
}

#ifdef USE_CAMERA_CONTROL
extern CUnknown* CALLBACK CCameraControlPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define DECCAMERA_CONTROL_TEMPLATE \
{ \
    L"TAPI Camera Control Property Page", \
    &__uuidof(TAPICameraControlPropertyPage), \
    CCameraControlPropertiesCreateInstance, \
    NULL, \
    NULL \
}
#endif

#ifdef USE_VIDEO_PROCAMP
extern CUnknown* CALLBACK CProcAmpPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define VIDEO_SETTING_PROP_TEMPLATE \
{ \
    L"TAPI Video Settings Property Page", \
    &__uuidof(TAPIProcAmpPropertyPage), \
    CProcAmpPropertiesCreateInstance, \
    NULL, \
    NULL \
}
#endif

/* End properties */
#endif /* USE_PROPERTY_PAGES */

#endif /* _viddec_template_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\dsrtp\inc\classes.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    classes.h
 *
 *  Abstract:
 *
 *    DShow classes
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/14 created
 *
 **********************************************************************/

#ifndef _classes_h_
#define _classes_h_

#include <streams.h>

#include "gtypes.h"
#include "tapirtp.h"

#include "struct.h"

/**********************************************************************
 *
 * Forward declarations
 *
 **********************************************************************/

class CIRtpSession;

class CRtpSourceAllocator;
class CRtpOutputPin;
class CRtpMediaSample;
class CRtpSourceAllocator;
class CRtpSourceFilter;

class CRtpInputPin;
class CRtpRenderFilter;

/**********************************************************************
 *
 * CIRtpSession base class for source and render filters, implemets
 * interface
 *
 **********************************************************************/

enum {
    CIRTPMODE_FIRST,
    CIRTPMODE_AUTO,
    CIRTPMODE_MANUAL,
    CIRTPMODE_LAST
};

#define CIRTPMODE_NOTSET CIRTPMODE_FIRST

/*++++++++++++++++++++++++++++++++++++++*/
class CIRtpSession : public IRtpSession
/*======================================*/
{
    DWORD            m_dwObjectID;
protected:
    /* pointer to RTP session (this is the main owner) */
    RtpSess_t       *m_pRtpSess;

    /* pointer to current address (this is the main owner) */
    RtpAddr_t       *m_pRtpAddr;

    /* Is this for a source or render filter */
    DWORD            m_dwRecvSend;
    
    /* Mode, either auto or manual initialization */
    int              m_iMode;
    
    /* Filter state, can only be State_Running or State_Stopped */
    FILTER_STATE     m_RtpFilterState;
    
private:
    CBaseFilter     *m_pCBaseFilter;
    
    DWORD            m_dwIRtpFlags;

public:

    /* constructor */
    CIRtpSession(
            LPUNKNOWN        pUnk,
            HRESULT         *phr,
            DWORD            dwFlags
        );

    /* destructor */
    ~CIRtpSession();

    void Cleanup(void);

    inline void SetBaseFilter(
            CBaseFilter     *pCBaseFilter
        )
        {
            m_pCBaseFilter = pCBaseFilter;
        }
    
    inline RtpSess_t *GetpRtpSess()
        {
            return(m_pRtpSess);
        }

    inline RtpAddr_t *GetpRtpAddr()
        {
            return(m_pRtpAddr);
        }

    inline FILTER_STATE GetFilterState(void)
        {
            return(m_RtpFilterState);
        }
    
    inline int GetMode()
        {
            return(m_iMode);
        }
    
    inline int SetMode(DWORD iMode)
        {
            return( (m_iMode = iMode) );
        }

    inline DWORD FlagTest(DWORD dwFlag)
        {
            return(RtpBitTest(m_dwIRtpFlags, dwFlag));
        }
    
    inline DWORD FlagSet(DWORD dwFlag)
        {
            return(RtpBitSet(m_dwIRtpFlags, dwFlag));
        }
    
    inline DWORD FlagReset(DWORD dwFlag)
        {
            return(RtpBitReset(m_dwIRtpFlags, dwFlag));
        }
    /**************************************************
     * IRtpSession methods
     **************************************************/
    
    STDMETHODIMP Control(
            DWORD            dwControl,
            DWORD_PTR        dwPar1,
            DWORD_PTR        dwPar2
        );

    STDMETHODIMP GetLastError(
            DWORD           *pdwError
        );

    STDMETHODIMP Init(
            HANDLE          *phCookie,
            DWORD            dwFlags
        );

    STDMETHODIMP Deinit(
            void
        );
    
    STDMETHODIMP GetPorts(
            WORD            *pwRtpLocalPort,
            WORD            *pwRtpremotePort,
            WORD            *pwRtcpLocalPort,
            WORD            *pwRtcpRemotePort
        );
   
    STDMETHODIMP SetPorts(
            WORD             wRtpLocalPort,
            WORD             wRtpremotePort,
            WORD             wRtcpLocalPort,
            WORD             wRtcpRemotePort
        );
   
    STDMETHODIMP SetAddress(
            DWORD            dwLocalAddr,
            DWORD            dwRemoteAddr
        );

    STDMETHODIMP GetAddress(
            DWORD           *pdwLocalAddr,
            DWORD           *pdwRemoteAddr
        );

    STDMETHODIMP SetScope(
            DWORD            dwTTL,
            DWORD            dwFlags
        );

    STDMETHODIMP SetMcastLoopback(
            int              iMcastLoopbackMode,
            DWORD            dwFlags
        );

    /* Miscelaneous */
    
    STDMETHODIMP ModifySessionMask(
            DWORD            dwKind,
            DWORD            dwEventMask,
            DWORD            dwValue,
            DWORD           *pdwModifiedMask
        );

    /* Set the bandwidth limits. A value of -1 will make the parameter
     * to be ignored.
     *
     * All the parameters are in bits/sec */
    STDMETHODIMP SetBandwidth(
            DWORD            dwOutboundBw,
            DWORD            dwInboundBw,
            DWORD            dwReceiversRtcpBw,
            DWORD            dwSendersRtcpBw
        );

    /* Participants */
    /* pdwSSRC points to an array of DWORDs where to copy the SSRCs,
     * pdwNumber contains the maximum entries to copy, and returns the
     * actual number of SSRCs copied. If pdwSSRC is NULL, pdwNumber
     * will return the current number of SSRCs (i.e. the current
     * number of participants) */
    STDMETHODIMP EnumParticipants(
            DWORD           *pdwSSRC,
            DWORD           *pdwNumber
        );

    /* Get the participant state. dwSSRC specifies the
     * participant. piState will return the current participant's
     * state (e.g. RTPPARINFO_TALKING, RTPPARINFO_SILENT). */
    STDMETHODIMP GetParticipantState(
            DWORD            dwSSRC,
            DWORD           *pdwState
        );

    /* Get the participant's mute state. dwSSRC specifies the
     * participant. pbMuted will return the participant's mute state
     * */
    STDMETHODIMP GetMuteState(
            DWORD            dwSSRC,
            BOOL            *pbMuted
        );

    /* Query the network metrics computation state for the specific SSRC */
    STDMETHODIMP GetNetMetricsState(
            DWORD            dwSSRC,
            BOOL            *pbState
        );
    
    /* Enable or disable the computation of networks metrics, this is
     * mandatory in order of the corresponding event to be fired if
     * enabled. This is done for the specific SSRC or the first one
     * found if SSRC=-1, if SSRC=0, then the network metrics
     * computation will be performed for any and all the SSRCs */
    STDMETHODIMP SetNetMetricsState(
            DWORD            dwSSRC,
            BOOL             bState
        );

    /* Retrieves network information, if the network metric
     * computation is enabled for the specific SSRC, all the fields in
     * the structure will be meaningful, if not, only the average
     * values will contain valid data */
    STDMETHODIMP GetNetworkInfo(
            DWORD            dwSSRC,
            RtpNetInfo_t    *pRtpNetInfo
        );

    /* Set the participant's mute state. dwSSRC specifies the
     * participant. bMuted specifies the new state. Note that mute is
     * used to refer to the permission or not to pass packets received
     * up to the application, and it applies equally to audio or video
     * */
    STDMETHODIMP SetMuteState(
            DWORD            dwSSRC,
            BOOL             bMuted
        );

    /* SDES */
    STDMETHODIMP SetSdesInfo(
            DWORD            dwSdesItem,
            WCHAR           *psSdesData
        );

    STDMETHODIMP GetSdesInfo(
            DWORD            dwSdesItem,
            WCHAR           *psSdesData,
            DWORD           *pdwSdesDataLen,
            DWORD            dwSSRC
        );

    /* QOS */
    STDMETHODIMP SetQosByName(
            TCHAR_t         *psQosName,
            DWORD            dwResvStyle,
            DWORD            dwMaxParticipants,
            DWORD            dwQosSendMode,
            DWORD            dwFrameSize
       );

    /* Not yet implemented */
    STDMETHODIMP SetQosParameters(
            RtpQosSpec_t    *pRtpQosSpec,
            DWORD            dwMaxParticipants,/* WF and SE */
            DWORD            dwQosSendMode
        );

    STDMETHODIMP SetQosAppId(
            TCHAR_t         *psAppName,
            TCHAR_t         *psAppGUID,
            TCHAR_t         *psPolicyLocator
        );

    STDMETHODIMP SetQosState(
            DWORD            dwSSRC,
            BOOL             bEnable
        );

    STDMETHODIMP ModifyQosList(
            DWORD           *pdwSSRC,
            DWORD           *pdwNumber,
            DWORD            dwOperation
        );

    /* Cryptography */
    STDMETHODIMP SetEncryptionMode(
            int              iMode,
            DWORD            dwFlags
        );
    
    STDMETHODIMP SetEncryptionKey(
            TCHAR           *psPassPhrase,
            TCHAR           *psHashAlg,
            TCHAR           *psDataAlg,
            BOOL            bRtcp
        );


    /**************************************************
     * Helper methods
     **************************************************/
    
    HRESULT CIRtpSessionNotifyEvent(
            long             EventCode,
            LONG_PTR         EventParam1,
            LONG_PTR         EventParam2
        );
};

/**********************************************************************
 *
 * RTP Output Pin
 *
 **********************************************************************/

/* Some flags in CRtpOutputPin.m_dwFlags */
enum {
    FGOPIN_FIRST,
    FGOPIN_MAPPED,
    FGOPIN_LAST
};

#if USE_DYNGRAPH > 0
#define CBASEOUTPUTPIN CBaseOutputPinEx
#else
#define CBASEOUTPUTPIN CBaseOutputPin
#endif

/* Each pin supports 1 or more PT, a specific SSRC and can operate on
 * a certain mode (the mode has to do with the way the pin is assigned
 * to a specific participant) */
/*++++++++++++++++++++++++++++++++++++++*/
class CRtpOutputPin : public CBASEOUTPUTPIN
/*======================================*/
{
    friend class CRtpSourceFilter;

    DWORD            m_dwObjectID;
    
    RtpQueueItem_t   m_OutputPinQItem;
    
    /* Pointer to owner filter */
    CRtpSourceFilter *m_pCRtpSourceFilter;

    CIRtpSession    *m_pCIRtpSession;

    DWORD            m_dwFlags;

    /* Corresponding RTP output */
    RtpOutput_t     *m_pRtpOutput;

    BYTE             m_bPT;

#if USE_GRAPHEDT > 0
    int              m_iCurrFormat;
#endif

    
public:
    /* constructor */
    CRtpOutputPin(
            CRtpSourceFilter *pCRtpSourceFilter,
            CIRtpSession     *pCIRtpSession,
            HRESULT          *phr,
            LPCWSTR           pPinName
        );

    /* destructor */
    ~CRtpOutputPin();

    void *operator new(size_t size);

    void operator delete(void *pVoid);

    /**************************************************
     * CBasePin overrided methods
     **************************************************/
    
    HRESULT Active(void);

    /* verify we can handle this format */
    HRESULT CheckMediaType(
            const CMediaType *pCMediaType
        );

    HRESULT GetMediaType(
            int              iPosition,
            CMediaType      *pCMediaType
        );

#if USE_GRAPHEDT > 0
    
    HRESULT SetMediaType(
            CMediaType      *pCMediaType
        );
#endif

    STDMETHODIMP Connect(
            IPin            *pReceivePin,
            const AM_MEDIA_TYPE *pmt   // optional media type
        );

    STDMETHODIMP Disconnect();

    /**************************************************
     * CBaseOutputPin overrided methods
     **************************************************/

    HRESULT DecideAllocator(
            IMemInputPin    *pPin,
            IMemAllocator  **ppAlloc
        );

    HRESULT DecideBufferSize(
            IMemAllocator   *pIMemAllocator,
            ALLOCATOR_PROPERTIES *pProperties
        );

    /**************************************************
     * IQualityControl overrided methods
     **************************************************/

    STDMETHODIMP Notify(IBaseFilter *pSelf, Quality q);

    /**************************************************
     * Helper functions
     **************************************************/

    /* Process packets received */
    void OutPinRecvCompletion(
            IMediaSample    *pIMediaSample,
            BYTE             bPT
        );

    inline RtpOutput_t *SetOutput(RtpOutput_t *pRtpOutput)
        {
            return( (m_pRtpOutput = pRtpOutput) );
        }
    
    inline BYTE GetPT()
        {
            return(m_bPT);
        }

    inline BYTE SetPT(BYTE bPT)
        {
            return( (m_bPT = bPT) );
        }
    
    inline DWORD OutPinBitTest(DWORD dwBit)
        {
            return( RtpBitTest(m_dwFlags, dwBit) );
        }

    inline DWORD OutPinBitSet(DWORD dwBit)
        {
            return( RtpBitSet(m_dwFlags, dwBit) );
        }

    inline DWORD OutPinBitReset(DWORD dwBit)
        {
            return( RtpBitReset(m_dwFlags, dwBit) );
        }

    inline RtpOutput_t *GetpRtpOutput()
        {
            return(m_pRtpOutput);
        }
};

/**********************************************************************
 *
 * CRtpSourceAllocator private memory allocator
 *
 **********************************************************************/

/*++++++++++++++++++++++++++++++++++++++*/
class CRtpMediaSample : public CMediaSample
/*======================================*/
{
    friend class CRtpSourceAllocator;

    DWORD            m_dwObjectID;

    /* Link together all the samples */
    RtpQueueItem_t   m_RtpSampleItem;

    /* Owner */
    CRtpSourceAllocator *m_pCRtpSourceAllocator;
    
public:
    CRtpMediaSample(
            TCHAR           *pName,
            CRtpSourceAllocator *pAllocator,
            HRESULT         *phr
        );

    ~CRtpMediaSample();

    void *operator new(size_t size, long lBufferSize);
    
    void operator delete(void *pVoid);
};

/*++++++++++++++++++++++++++++++++++++++*/
class CRtpSourceAllocator : public CBaseAllocator
/*======================================*/
{
    DWORD            m_dwObjectID;
    
    /* Filter owner */
    CRtpSourceFilter *m_pCRtpSourceFilter;

    /* Critical section to access the samples queue's */
    RtpCritSect_t    m_RtpSampleCritSect;

    /* Busy samples queue */
    RtpQueue_t       m_RtpBusySamplesQ;
    
    /* Free samples queue */
    RtpQueue_t       m_RtpFreeSamplesQ;
    
 public:
    DECLARE_IUNKNOWN
    
    CRtpSourceAllocator(
            TCHAR           *pName,
            LPUNKNOWN        pUnk,
            HRESULT         *phr,
            CRtpSourceFilter *pCRtpSourceFilter 
       );
    
    ~CRtpSourceAllocator();

    void Free(void);

    HRESULT Alloc(void);
    
    void *operator new(size_t size);

    void operator delete(void *pVoid);

    /**************************************************
     * INonDelegatingUnknown implemented methods
     **************************************************/

    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID           riid,
            void           **ppv
        );

    /**************************************************
     * IMemAllocator implemented methods
     **************************************************/

    STDMETHODIMP SetProperties(
		    ALLOCATOR_PROPERTIES *pRequest,
		    ALLOCATOR_PROPERTIES *pActual
        );

    STDMETHODIMP GetProperties(
		    ALLOCATOR_PROPERTIES *pProps
        );

    STDMETHODIMP Commit();

    STDMETHODIMP Decommit();

    STDMETHODIMP GetBuffer(
            IMediaSample   **ppBuffer,
            REFERENCE_TIME  *pStartTime,
            REFERENCE_TIME  *pEndTime,
            DWORD            dwFlags
        );

    STDMETHODIMP ReleaseBuffer(
            IMediaSample    *pBuffer
        );

    STDMETHODIMP GetFreeCount(LONG *plBuffersFree);
};

/**********************************************************************
 *
 * RTP Source Filter
 *
 **********************************************************************/

typedef struct _MEDIATYPE_MAPPING
{
    DWORD            dwRTPPayloadType;
    DWORD            dwFrequency;
    CMediaType      *pMediaType;

} MEDIATYPE_MAPPING;

/*++++++++++++++++++++++++++++++++++++++*/
class CRtpSourceFilter : public CBaseFilter,
                         public CIRtpSession,
                         public IRtpMediaControl,
                         public IRtpDemux,
                         public IRtpRedundancy
/*======================================*/
{
    friend class CRtpOutputPin;
    
    /* Identifies object */
    DWORD            m_dwObjectID;

    /* serializes access to filter state */
    CCritSec         m_cRtpSrcCritSec;

    /* pointer to the class implementing the IRtpSession interface */
    CIRtpSession    *m_pCIRtpSession;

    /* Output pins queue critical section */
    RtpCritSect_t    m_OutPinsCritSect;
    
    /* Output pins queue (CRtpOutputPin) */
    RtpQueue_t       m_OutPinsQ;

    /* Remember the prefix length */
    long             m_lPrefix;

    MEDIATYPE_MAPPING m_MediaTypeMappings[MAX_MEDIATYPE_MAPPINGS];
    DWORD            m_dwNumMediaTypeMappings;

    /* Keep track of the start time for all the samples delivered,
     * when a new talkspurt begins, make sure the new start time is
     * not smaller than the last start tiem from the last sample
     * delivered */
    LONGLONG         m_StartTime;
    
#if USE_DYNGRAPH > 0
    HANDLE           m_hStopEvent;
#endif
    
protected:
    /* Private memory allocator */
    CRtpSourceAllocator *m_pCRtpSourceAllocator;

private:
    /**************************************************
     * Private helper functions
     **************************************************/

    /* called on constructor failure and in the destructure */
    void Cleanup(void);

public:
    DECLARE_IUNKNOWN
    
    /* constructor */
    CRtpSourceFilter(
            LPUNKNOWN        pUnk,
            HRESULT         *phr
        );

    /* destructor */
    ~CRtpSourceFilter();

    void *operator new(size_t size);

    void operator delete(void *pVoid);

    /**************************************************
     * Helper functions
     **************************************************/
    
    /* expose state lock to other objects */
    CCritSec *pStateLock(void) { return &m_cRtpSrcCritSec; }

    HRESULT GetMediaType(int iPosition, CMediaType *pCMediaType);

    /* Process packets received */
    void SourceRecvCompletion(
            IMediaSample    *pIMediaSample,
            void            *pvUserInfo,
            RtpUser_t       *pRtpUser,
            double           dPlayTime,
            DWORD            dwError,
            long             lHdrSize,
            DWORD            dwTransfered,
            DWORD            dwFlags
        );

#if USE_GRAPHEDT <= 0
    HRESULT PayloadTypeToMediaType(
            IN DWORD         dwRTPPayloadType, 
            IN CMediaType   *pCMediaType,
            OUT DWORD       *pdwFrequency
       );
#endif

    CRtpOutputPin *FindIPin(IPin *pIPin);

    HRESULT MapPinsToOutputs();

    HRESULT UnmapPinsFromOutputs();

    HRESULT AddPt2FrequencyMap(
            DWORD        dwPt,
            DWORD        dwFrequency
        );
    
    /**************************************************
     * CBaseFilter overrided methods
     **************************************************/

    /* Get number of output pins */
    int GetPinCount();

    /* Get the nth pin */
    CBasePin *GetPin(
            int n
        );

    FILTER_STATE GetState()
        {
            return(m_State);
        }

    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    STDMETHODIMP Run(REFERENCE_TIME tStart);

    STDMETHODIMP Stop();
    
#if USE_DYNGRAPH > 0

    BOOL CRtpSourceFilter::ConfigurePins(
            IN IGraphConfig* pGraphConfig,
            IN HANDLE        hEvent
        );

    STDMETHOD (JoinFilterGraph) ( 
            IFilterGraph*    pGraph, 
            LPCWSTR          pName 
        );
#endif


    /**************************************************
     * INonDelegatingUnknown implemented methods
     **************************************************/

    /* obtain pointers to active movie and private interfaces */

    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID           riid,
            void           **ppv
        );

    /**************************************************
     * IRtpMediaControl implemented methods
     **************************************************/

    /* set the mapping between RTP payload and DShow media types */
    STDMETHODIMP SetFormatMapping(
	        IN DWORD         dwRTPPayLoadType, 
            IN DWORD         dwFrequency,
            IN AM_MEDIA_TYPE *pMediaType
        );
    
    /* Empties the format mapping table */
    STDMETHODIMP FlushFormatMappings(void);
    
    /**************************************************
     * IRtpDemux implemented methods
     **************************************************/
    
    /* Add a single pin, may return its position */
    STDMETHODIMP AddPin(
            IN  int          iOutMode,
            OUT int         *piPos
        );

    /* Set the number of pins, can only be >= than current number of
     * pins */
    STDMETHODIMP SetPinCount(
            IN  int          iCount,
            IN  int          iOutMode
        );

    /* Set the pin mode (e.g. auto, manual, etc), if iPos >= 0 use it,
     * otherwise use pIPin */
    STDMETHODIMP SetPinMode(
            IN  int          iPos,
            IN  IPin        *pIPin,
            IN  int          iOutMode
        );

    /* Map/unmap pin i to/from user with SSRC, if iPos >= 0 use it,
     * otherwise use pIPin, when unmapping, only the pin or the SSRC
     * is required */
    STDMETHODIMP SetMappingState(
            IN  int          iPos,
            IN  IPin        *pIPin,
            IN  DWORD        dwSSRC,
            IN  BOOL         bMapped
        );

    /* Find the Pin assigned (if any) to the SSRC, return either
     * position or pin or both */
    STDMETHODIMP FindPin(
            IN  DWORD        dwSSRC,
            OUT int         *piPos,
            OUT IPin       **ppIPin
        );

    /* Find the SSRC mapped to the Pin, if iPos >= 0 use it, otherwise
     * use pIPin */
    STDMETHODIMP FindSSRC(
            IN  int          iPos,
            IN  IPin        *pIPin,
            OUT DWORD       *pdwSSRC
        );

    /**************************************************
     * IRtpRedundancy implemented methods
     **************************************************/
    
     /* Configures redundancy parameters */
    STDMETHODIMP SetRedParameters(
            DWORD            dwPT_Red, /* Payload type for redundant packets */
            DWORD            dwInitialRedDistance,/* Initial red distance */
            DWORD            dwMaxRedDistance /* default used when passing 0 */
        );
};

/**********************************************************************
 *
 * RTP Input Pin
 *
 **********************************************************************/

/* Some flags in CRtpOutputPin.m_dwFlags */
enum {
    FGIPIN_FIRST,
    FGIPIN_LAST
};

/*++++++++++++++++++++++++++++++++++++++*/
class CRtpInputPin : public CBaseInputPin
/*======================================*/
{
    DWORD            m_dwObjectID;
    
    /* Pointer to owner filter */
    CRtpRenderFilter *m_pCRtpRenderFilter;

    CIRtpSession    *m_pCIRtpSession;
    
    DWORD            m_dwFlags;
    
    /* Pin's possition */
    int              m_iPos;
    
    /* this pin is for capture (as opossed for RTP packetization
       descriptors) */
    BOOL             m_bCapture;

    BYTE             m_bPT;
    DWORD            m_dwSamplingFreq;
    
public:
    /* constructor */
    CRtpInputPin(
            int              iPos,
            BOOL             bCapture,
            CRtpRenderFilter *pCRtpRenderFilter,
            CIRtpSession    *pCIRtpSession,
            HRESULT         *phr,
            LPCWSTR          pPinName
        );

    /* destructor */
    ~CRtpInputPin();

    void *operator new(size_t size);

    void operator delete(void *pVoid);

    inline DWORD GetSamplingFreq(void)
        {
            if (m_dwSamplingFreq)
            {
                return(m_dwSamplingFreq);
            }
            else
            {
                return(DEFAULT_SAMPLING_FREQ);
            }
        }
    
    /**************************************************
     * CBasePin overrided methods
     **************************************************/
    
    /* verify we can handle this format */
    HRESULT CheckMediaType(const CMediaType *pCMediaType);

    HRESULT SetMediaType(const CMediaType *pCMediaType);

    STDMETHODIMP ReceiveConnection(
        IPin * pConnector,      // this is the initiating connecting pin
        const AM_MEDIA_TYPE *pmt   // this is the media type we will exchange
    );

    STDMETHODIMP EndOfStream(void);
    
    /**************************************************
     * CBaseInputPin overrided methods
     **************************************************/

    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);

    /**************************************************
     * IMemInputPin implemented methods
     **************************************************/

    /* send input stream over network */
    STDMETHODIMP Receive(IMediaSample *pIMediaSample);
};

/**********************************************************************
 *
 * RTP Render Filter
 *
 **********************************************************************/

/*++++++++++++++++++++++++++++++++++++++*/
class CRtpRenderFilter : public CBaseFilter,
                         public CIRtpSession,
                         public IRtpMediaControl,
                         public IAMFilterMiscFlags,
                         public IRtpDtmf,
                         public IRtpRedundancy
/*======================================*/
{
     /* Identifies object */
    DWORD            m_dwObjectID;

    /* serializes access to filter state */
    CCritSec         m_cRtpRndCritSec;

    /* pointer to the class implementing the IRtpSession interface */
    CIRtpSession    *m_pCIRtpSession;

    DWORD            m_dwFeatures;
    
    int              m_iPinCount;
    
    /* 2 pins (capture and packetization descriptor) */
    CRtpInputPin    *m_pCRtpInputPin[2];

    /* save the MediaSample from capture when using RTP PDs */
    IMediaSample    *m_pMediaSample;

    /* This filter sends only to 1 address, so the PT can be kept in
     * the filter rather than in the pin */
    DWORD            m_dwPT;

    /* This filter sends only to 1 address, so the sampling frequency
     * can be kept in the filter rather than in the pin */
    DWORD            m_dwFreq;
    
    MEDIATYPE_MAPPING m_MediaTypeMappings[MAX_MEDIATYPE_MAPPINGS];
    DWORD            m_dwNumMediaTypeMappings;
    
    IMediaSample    *m_pRedMediaSample[RTP_RED_MAXDISTANCE];
    DWORD            m_dwRedIndex;

    DWORD            m_dwDtmfId;
    DWORD            m_dwDtmfDuration;
    DWORD            m_dwDtmfTimeStamp;
    BOOL             m_bDtmfEnd;
    
    /**************************************************
     * Private helper functions
     **************************************************/

    /* called on constructor failure and in the destructure */
    void Cleanup(void);
    
public:
    DECLARE_IUNKNOWN

    /* constructor */
    CRtpRenderFilter(
            LPUNKNOWN        pUnk,
            HRESULT         *phr
        );
    
    /* destructor */
    ~CRtpRenderFilter();
    
    void *operator new(size_t size);

    void operator delete(void *pVoid);

    /**************************************************
     * Helper functions
     **************************************************/
    
    /* expose state lock to other objects */
    CCritSec *pStateLock(void) { return &m_cRtpRndCritSec; }

    HRESULT MediaType2PT(
        IN const CMediaType *pCMediaType, 
        OUT DWORD           *pdwPT,
        OUT DWORD           *pdwFreq
        );

    /* MAYDO this might be a list of samples so more than 1 can be
       safely queued. Note that should not happen becase that means
       samples are produced faster than they can be consumed, but we
       must be prepared for that */
    /* Save the MediaSample to be used later when the packetization
     * descriptor is available, if there was already a sample, release
     * it */
    inline void PutMediaSample(IMediaSample *pMediaSample)
        {
            if (m_pMediaSample)
            {
                m_pMediaSample->Release();
            }
            
            m_pMediaSample = pMediaSample;
        }

    /* retrieves the saved MediaSample to be consumed */
    inline IMediaSample *GetMediaSample(void)
        {
            IMediaSample    *pMediaSample;

            pMediaSample = m_pMediaSample;
            
            m_pMediaSample = (IMediaSample *)NULL;
            
            return(pMediaSample);
        }

    inline void ModifyFeature(int iFeature, BOOL bValue)
        {
            if (bValue)
            {
                RtpBitSet(m_dwFeatures, iFeature);
            }
            else
            {
                RtpBitReset(m_dwFeatures, iFeature);
            }
        }

    /**************************************************
     * CBaseFilter overrided methods
     **************************************************/

    /* Get number of input pins */
    int GetPinCount();

    /* Get the nth pin */
    CBasePin *GetPin(
            int              n
        );

    STDMETHODIMP Run(REFERENCE_TIME tStart);

    STDMETHODIMP Stop();

    /**************************************************
     * INonDelegatingUnknown implemented methods
     **************************************************/

    /* obtain pointers to active movie and private interfaces */
    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID           riid,
            void           **ppv
        );

    /**************************************************
     * IRtpMediaControl implemented methods
     **************************************************/

    /* set the mapping between RTP payload and DShow media types */
    STDMETHODIMP SetFormatMapping(
	        IN DWORD         dwRTPPayLoadType, 
            IN DWORD         dwFrequency,
            IN AM_MEDIA_TYPE *pMediaType
        );
    
    /* Empties the format mapping table */
    STDMETHODIMP FlushFormatMappings(void);

    /**************************************************
     * IAMFilterMiscFlags implemented methods
     **************************************************/

    /* tell the filter graph that we generate EC_COMPLETE */
    STDMETHODIMP_(ULONG) GetMiscFlags(void);

    /**************************************************
     * IRtpDtmf implemented methods
     **************************************************/

    /* Configures DTMF parameters */
    STDMETHODIMP SetDtmfParameters(
            DWORD            dwPT_Dtmf  /* Payload type for DTMF events */
        );

    /* Directs an RTP render filter to send a packet formatted
     * according to rfc2833 containing the specified event, specified
     * volume level, duration in milliseconds, and the END flag,
     * following the rules in section 3.6 for events sent in multiple
     * packets. Parameter dwId changes from one digit to the next one.
     *
     * NOTE the duration is given in milliseconds, then it is
     * converted to RTP timestamp units which are represented using 16
     * bits, the maximum value is hence dependent on the sampling
     * frequency, but for 8KHz the valid values would be 0 to 8191 ms
     * */
    STDMETHODIMP SendDtmfEvent(
            DWORD            dwId,
            DWORD            dwEvent,
            DWORD            dwVolume,
            DWORD            dwDuration, /* ms */
            BOOL             bEnd
        );
    
    /**************************************************
     * IRtpRedundancy implemented methods
     **************************************************/
    
     /* Configures redundancy parameters */
    STDMETHODIMP SetRedParameters(
            DWORD            dwPT_Red, /* Payload type for redundant packets */
            DWORD            dwInitialRedDistance,/* Initial red distance */
            DWORD            dwMaxRedDistance /* default used when passing 0 */
        );

    /**************************************************
     * Methods for IRtpRedundancy support
     **************************************************/

    STDMETHODIMP AddRedundantSample(
            IMediaSample *pIMediaSample
        );

    STDMETHODIMP ClearRedundantSamples(void);
};

#endif /* _classes_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\common.inc ===
#**********************************************************************
#*
#*  Copyright (C) Microsoft Corporation, 1999
#*
#*  File name:
#*
#*    common.inc
#*
#*  Abstract:
#*
#*    Common build definitions and libraries
#*
#*  Author:
#*
#*    Andres Vega-Garcia (andresvg)
#*
#*  Revision:
#*
#*    1999/05/20 created
#*
#**********************************************************************
FILTERS=$(RTPROOT)\..
RTPBIN=$(FILTERS)\lib\$(_OBJ_DIR)

!include $(FILTERS)\filters.inc

# MSVCRT.LIB Import library for MSVCRT.DLL, retail version
USE_CRTDLL=1

# Generate map file
USE_MAPSYM=1
BROWSER_INFO=1
USE_ICECAP4=1

!INCLUDE $(RTPROOT)\options.inc

!if !$(FREEBUILD)

#########
# Debug
#########
C_DEFINES=\
    $(C_DEFINES) \
    -DDEBUG=1 \
    -D_DEBUG=1

!endif

!if $(RTPOPT_USE_UNICODE)
C_DEFINES=\
    $(C_DEFINES) \
    -D_UNICODE \
    -DUNICODE
!endif

INCLUDES=\
    $(INCLUDES);\
    $(BASEDIR)\public\sdk\amovie\inc; \
    ..\inc;\
    ..\..\inc;\
    ..\..\..\inc; \
    ..\..\..\..\inc; \
    ..\..\..\..\..\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\dsrtp\inc\dsrtpid.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    dsrtpid.h
 *
 *  Abstract:
 *
 *    CLSIDs, IIDs and GUIDs
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/17 created
 *
 **********************************************************************/

#ifndef _dsrtpid_h_
#define _dsrtpid_h_

#include <olectl.h>

/**********************************************************************
 * Media types GUIDs
 **********************************************************************/

#if 0 // remove later

/* {14099BC0-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIATYPE_RTP_Single_Stream, 
0x14099bc0, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BC1-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIATYPE_RTP_Multiple_Stream, 
0x14099bc1, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BC2-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_Mixed, 
0x14099bc2, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);



/* {14099BC3-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_G711U, 
0x14099bc3, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BC4-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_G711A, 
0x14099bc4, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BC5-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_G723, 
0x14099bc5, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BC6-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_H261, 
0x14099bc6, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BC7-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_H263, 
0x14099bc7, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BCA-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_ANY, 
0x14099bc8, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {33363248-0000-0010-8000-00AA00389B71} */
DEFINE_GUID(MEDIASUBTYPE_H263, 
0x33363248, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

/* {14099BC8-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_H263EX, 
0x14099bc8, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

#if 0
/* {31363248-0000-0010-8000-00AA00389B71} */
DEFINE_GUID(MEDIASUBTYPE_H261, 
0x31363248, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
#endif
/* {14099BC9-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_H261EX, 
0x14099bc9, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

#endif

#endif /* _dsrtpid_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\dsrtp\inc\dsglob.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    dsglob.h
 *
 *  Abstract:
 *
 *    DShow global variables
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#ifndef _dsglob_h_
#define _dsglob_h_

#define WRTP_PIN_ANY                 L""
#define WRTP_PIN_INPUT               L"RTP Input"
#define WRTP_PIN_OUTPUT              L"RTP Output"
#define WRTP_RENDER_FILTER           L"Tapi RTP Render Filter"
#define WRTP_SOURCE_FILTER           L"Tapi RTP Source Filter"
#define WRTP_FILTER_VENDOR_INFO      L"Tapi RTP Network Filters"

#if USE_GRAPHEDT > 0
extern const AMOVIESETUP_MEDIATYPE   g_RtpOutputType;
extern const AMOVIESETUP_PIN         g_RtpOutputPin;
extern const AMOVIESETUP_FILTER      g_RtpSourceFilter;

extern const AMOVIESETUP_MEDIATYPE   g_RtpInputType;
extern const AMOVIESETUP_PIN         g_RtpInputPin;
extern const AMOVIESETUP_FILTER      g_RtpRenderFilter;
#endif

extern const WCHAR                   g_RtpVendorInfo[];

#define RTPDEFAULT_SAMPLE_NUM        MIN_ASYNC_RECVBUF
#define RTPDEFAULT_SAMPLE_SIZE       1500
#if USE_RTPPREFIX_HDRSIZE > 0
#define RTPDEFAULT_SAMPLE_PREFIX     sizeof(RtpPrefixHdr_t)
#else
#define RTPDEFAULT_SAMPLE_PREFIX     0
#endif
#define RTPDEFAULT_SAMPLE_ALIGN      4 /* (sizeof(DWORD)) */

#endif /* _dsglob_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\dsrtp\src\setmtype.cpp ===
#if USE_GRAPHEDT > 0

#include "classes.h"
#include "dsglob.h"
#include "dsrtpid.h"

#include <streams.h>
#include <ks.h>
#include <ksmedia.h>
#include "h26xinc.h"
#include <tapih26x.h>
#include <filterid.h>

#define MAX_FRAME_INTERVAL 10000000L
#define MIN_FRAME_INTERVAL 333333L

// RTP packetized H.263 Version 1 QCIF size
#define CIF_BUFFER_SIZE 32768
#define D_X_CIF 352
#define D_Y_CIF 288
const VIDEOINFOHEADER_H263 VIH_R263_CIF = 
{
    0,0,0,0,                                // RECT  rcSource; 
    0,0,0,0,                                // RECT  rcTarget; 
    CIF_BUFFER_SIZE * 30 * 8,               // DWORD dwBitRate;
    0L,                                     // DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,                     // REFERENCE_TIME  AvgTimePerFrame;   

    {
        sizeof (BITMAPINFOHEADER_H263),     // DWORD biSize;
        D_X_CIF,                            // LONG  biWidth;
        D_Y_CIF,                            // LONG  biHeight;
        1,                                  // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
        24,                                 // WORD  biBitCount;
#else
        0,                                  // WORD  biBitCount;
#endif
        FOURCC_R263,                        // DWORD biCompression;
        CIF_BUFFER_SIZE,                    // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0,                                  // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
        // H.263 specific fields
        CIF_BUFFER_SIZE * 30 * 8 / 100,     // dwMaxBitrate
        CIF_BUFFER_SIZE * 8 / 1024,         // dwBppMaxKb
        0,                                  // dwHRD_B

        //Options
        0,                                  // fUnrestrictedVector
        0,                                  // fArithmeticCoding
        0,                                  // fAdvancedPrediction
        0,                                  // fPBFrames
        0,                                  // fErrorCompensation
        0,                                  // fAdvancedIntraCodingMode
        0,                                  // fDeblockingFilterMode
        0,                                  // fImprovedPBFrameMode
        0,                                  // fUnlimitedMotionVectors
        0,                                  // fFullPictureFreeze
        0,                                  // fPartialPictureFreezeAndRelease
        0,                                  // fResizingPartPicFreezeAndRelease
        0,                                  // fFullPictureSnapshot
        0,                                  // fPartialPictureSnapshot
        0,                                  // fVideoSegmentTagging
        0,                                  // fProgressiveRefinement
        0,                                  // fDynamicPictureResizingByFour
        0,                                  // fDynamicPictureResizingSixteenthPel
        0,                                  // fDynamicWarpingHalfPel
        0,                                  // fDynamicWarpingSixteenthPel
        0,                                  // fIndependentSegmentDecoding
        0,                                  // fSlicesInOrder-NonRect
        0,                                  // fSlicesInOrder-Rect
        0,                                  // fSlicesNoOrder-NonRect
        0,                                  // fSlicesNoOrder-NonRect
        0,                                  // fAlternateInterVLCMode
        0,                                  // fModifiedQuantizationMode
        0,                                  // fReducedResolutionUpdate
        0,                                  // fReserved

        // Reserved
        0, 0, 0, 0                          // dwReserved[4]
#endif
    }
};

const AM_MEDIA_TYPE AMMT_R263_CIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,         // majortype
    STATIC_MEDIASUBTYPE_R263_V1,            // subtype
    FALSE,                                  // bFixedSizeSamples (all samples same size?)
    TRUE,                                   // bTemporalCompression (uses prediction?)
    0,                                      // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
    NULL,                                   // pUnk
    sizeof (VIH_R263_CIF),          // cbFormat
    (LPBYTE)&VIH_R263_CIF,          // pbFormat
};

// H.263 Version 1 QCIF size
#define QCIF_BUFFER_SIZE 8192
#define D_X_QCIF 176
#define D_Y_QCIF 144
const VIDEOINFOHEADER_H263 VIH_R263_QCIF = 
{
    0,0,0,0,                                // RECT  rcSource; 
    0,0,0,0,                                // RECT  rcTarget; 
    QCIF_BUFFER_SIZE * 30 * 8,              // DWORD dwBitRate;
    0L,                                     // DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,                     // REFERENCE_TIME  AvgTimePerFrame;   

    {
        sizeof (BITMAPINFOHEADER_H263),     // DWORD biSize;
        D_X_QCIF,                           // LONG  biWidth;
        D_Y_QCIF,                           // LONG  biHeight;
        1,                                  // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
        24,                                 // WORD  biBitCount;
#else
        0,                                  // WORD  biBitCount;
#endif
        FOURCC_R263,                        // DWORD biCompression;
        QCIF_BUFFER_SIZE,                   // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0,                                  // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
        // H.263 specific fields
        QCIF_BUFFER_SIZE * 30 * 8 / 100,    // dwMaxBitrate
        QCIF_BUFFER_SIZE * 8 / 1024,        // dwBppMaxKb
        0,                                  // dwHRD_B

        //Options
        0,                                  // fUnrestrictedVector
        0,                                  // fArithmeticCoding
        0,                                  // fAdvancedPrediction
        0,                                  // fPBFrames
        0,                                  // fErrorCompensation
        0,                                  // fAdvancedIntraCodingMode
        0,                                  // fDeblockingFilterMode
        0,                                  // fImprovedPBFrameMode
        0,                                  // fUnlimitedMotionVectors
        0,                                  // fFullPictureFreeze
        0,                                  // fPartialPictureFreezeAndRelease
        0,                                  // fResizingPartPicFreezeAndRelease
        0,                                  // fFullPictureSnapshot
        0,                                  // fPartialPictureSnapshot
        0,                                  // fVideoSegmentTagging
        0,                                  // fProgressiveRefinement
        0,                                  // fDynamicPictureResizingByFour
        0,                                  // fDynamicPictureResizingSixteenthPel
        0,                                  // fDynamicWarpingHalfPel
        0,                                  // fDynamicWarpingSixteenthPel
        0,                                  // fIndependentSegmentDecoding
        0,                                  // fSlicesInOrder-NonRect
        0,                                  // fSlicesInOrder-Rect
        0,                                  // fSlicesNoOrder-NonRect
        0,                                  // fSlicesNoOrder-NonRect
        0,                                  // fAlternateInterVLCMode
        0,                                  // fModifiedQuantizationMode
        0,                                  // fReducedResolutionUpdate
        0,                                  // fReserved

        // Reserved
        0, 0, 0, 0                          // dwReserved[4]
#endif
    }
};

const AM_MEDIA_TYPE AMMT_R263_QCIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,         // majortype
    STATIC_MEDIASUBTYPE_R263_V1,            // subtype
    FALSE,                                  // bFixedSizeSamples (all samples same size?)
    TRUE,                                   // bTemporalCompression (uses prediction?)
    0,                                      // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
    NULL,                                   // pUnk
    sizeof (VIH_R263_QCIF),         // cbFormat
    (LPBYTE)&VIH_R263_QCIF,         // pbFormat
};

// H.263 Versions 1 SQCIF size
#define SQCIF_BUFFER_SIZE 8192
#define D_X_SQCIF 128
#define D_Y_SQCIF 96
const VIDEOINFOHEADER_H263 VIH_R263_SQCIF = 
{
    0,0,0,0,                                // RECT  rcSource; 
    0,0,0,0,                                // RECT  rcTarget; 
    SQCIF_BUFFER_SIZE * 30 * 8,             // DWORD dwBitRate;
    0L,                                     // DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,                     // REFERENCE_TIME  AvgTimePerFrame;   

    {
        sizeof (BITMAPINFOHEADER_H263),     // DWORD biSize;
        D_X_SQCIF,                          // LONG  biWidth;
        D_Y_SQCIF,                          // LONG  biHeight;
        1,                                  // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
        24,                                 // WORD  biBitCount;
#else
        0,                                  // WORD  biBitCount;
#endif
        FOURCC_R263,                        // DWORD biCompression;
        SQCIF_BUFFER_SIZE,                  // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0,                                  // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
        // H.263 specific fields
        SQCIF_BUFFER_SIZE * 30 * 8 / 100,   // dwMaxBitrate
        SQCIF_BUFFER_SIZE * 8 / 1024,       // dwBppMaxKb
        0,                                  // dwHRD_B

        //Options
        0,                                  // fUnrestrictedVector
        0,                                  // fArithmeticCoding
        0,                                  // fAdvancedPrediction
        0,                                  // fPBFrames
        0,                                  // fErrorCompensation
        0,                                  // fAdvancedIntraCodingMode
        0,                                  // fDeblockingFilterMode
        0,                                  // fImprovedPBFrameMode
        0,                                  // fUnlimitedMotionVectors
        0,                                  // fFullPictureFreeze
        0,                                  // fPartialPictureFreezeAndRelease
        0,                                  // fResizingPartPicFreezeAndRelease
        0,                                  // fFullPictureSnapshot
        0,                                  // fPartialPictureSnapshot
        0,                                  // fVideoSegmentTagging
        0,                                  // fProgressiveRefinement
        0,                                  // fDynamicPictureResizingByFour
        0,                                  // fDynamicPictureResizingSixteenthPel
        0,                                  // fDynamicWarpingHalfPel
        0,                                  // fDynamicWarpingSixteenthPel
        0,                                  // fIndependentSegmentDecoding
        0,                                  // fSlicesInOrder-NonRect
        0,                                  // fSlicesInOrder-Rect
        0,                                  // fSlicesNoOrder-NonRect
        0,                                  // fSlicesNoOrder-NonRect
        0,                                  // fAlternateInterVLCMode
        0,                                  // fModifiedQuantizationMode
        0,                                  // fReducedResolutionUpdate
        0,                                  // fReserved

        // Reserved
        0, 0, 0, 0                          // dwReserved[4]
#endif
    }
};

const AM_MEDIA_TYPE AMMT_R263_SQCIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,         // majortype
    STATIC_MEDIASUBTYPE_R263_V1,            // subtype
    FALSE,                                  // bFixedSizeSamples (all samples same size?)
    TRUE,                                   // bTemporalCompression (uses prediction?)
    0,                                      // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
    NULL,                                   // pUnk
    sizeof (VIH_R263_SQCIF),        // cbFormat
    (LPBYTE)&VIH_R263_SQCIF,        // pbFormat
};

// RTP packetized H.261 CIF size
const VIDEOINFOHEADER_H261 VIH_R261_CIF = 
{
    0,0,0,0,                                // RECT  rcSource; 
    0,0,0,0,                                // RECT  rcTarget; 
    CIF_BUFFER_SIZE * 30 * 8,               // DWORD dwBitRate;
    0L,                                     // DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,                     // REFERENCE_TIME  AvgTimePerFrame;   

    {
        sizeof (BITMAPINFOHEADER_H261),     // DWORD biSize;
        D_X_CIF,                            // LONG  biWidth;
        D_Y_CIF,                            // LONG  biHeight;
        1,                                  // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
        24,                                 // WORD  biBitCount;
#else
        0,                                  // WORD  biBitCount;
#endif
        FOURCC_R261,                        // DWORD biCompression;
        CIF_BUFFER_SIZE,                    // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0,                                  // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
        // H.261 specific fields
        CIF_BUFFER_SIZE * 30 * 8 / 100,     // dwMaxBitrate
        0,                                  // fStillImageTransmission

        // Reserved
        0, 0, 0, 0                          // dwReserved[4]
#endif
    }
};

const AM_MEDIA_TYPE AMMT_R261_CIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,         // majortype
    STATIC_MEDIASUBTYPE_R261,               // subtype
    FALSE,                                  // bFixedSizeSamples (all samples same size?)
    TRUE,                                   // bTemporalCompression (uses prediction?)
    0,                                      // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
    NULL,                                   // pUnk
    sizeof (VIH_R261_CIF),          // cbFormat
    (LPBYTE)&VIH_R261_CIF,          // pbFormat
};

// RTP packetized H.261 QCIF size
const VIDEOINFOHEADER_H261 VIH_R261_QCIF = 
{
    0,0,0,0,                                // RECT  rcSource; 
    0,0,0,0,                                // RECT  rcTarget; 
    QCIF_BUFFER_SIZE * 30 * 8,              // DWORD dwBitRate;
    0L,                                     // DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,                     // REFERENCE_TIME  AvgTimePerFrame;   

    {
        sizeof (BITMAPINFOHEADER_H261),     // DWORD biSize;
        D_X_QCIF,                           // LONG  biWidth;
        D_Y_QCIF,                           // LONG  biHeight;
        1,                                  // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
        24,                                 // WORD  biBitCount;
#else
        0,                                  // WORD  biBitCount;
#endif
        FOURCC_R261,                        // DWORD biCompression;
        QCIF_BUFFER_SIZE,                   // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0,                                  // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
        // H.261 specific fields
        QCIF_BUFFER_SIZE * 30 * 8 / 100,    // dwMaxBitrate
        0,                                  // fStillImageTransmission

        // Reserved
        0, 0, 0, 0                          // dwReserved[4]
#endif
    }
};

const AM_MEDIA_TYPE AMMT_R261_QCIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,         // majortype
    STATIC_MEDIASUBTYPE_R261,               // subtype
    FALSE,                                  // bFixedSizeSamples (all samples same size?)
    TRUE,                                   // bTemporalCompression (uses prediction?)
    0,                                      // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
    NULL,                                   // pUnk
    sizeof (VIH_R261_QCIF),         // cbFormat
    (LPBYTE)&VIH_R261_QCIF,         // pbFormat
};

// Array of all formats
const AM_MEDIA_TYPE* const R26XFormats[] = 
{
    (AM_MEDIA_TYPE*) &AMMT_R263_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_R263_CIF,
    (AM_MEDIA_TYPE*) &AMMT_R263_SQCIF,
    (AM_MEDIA_TYPE*) &AMMT_R261_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_R261_CIF
};

#define NUM_OUTPUT_FORMATS 5

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CRtpOutputPin | GetMediaType | This method retrieves one
 *    of the media types supported by the pin, which is used by enumerators.
 *
 *  @parm int | iPosition | Specifies a position in the media type list.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type at
 *    the <p iPosition> position in the list of supported media types.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag VFW_S_NO_MORE_ITEMS | End of the list of media types has been reached
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpOutputPin::GetMediaType(IN int iPosition, OUT CMediaType *pMediaType)
{
    HRESULT Hr = NOERROR;

    // Validate input parameters
    ASSERT(iPosition >= 0);
    ASSERT(pMediaType);
    if (iPosition < 0)
    {
        Hr = E_INVALIDARG;
        goto MyExit;
    }
    if (iPosition >= (int)NUM_OUTPUT_FORMATS)
    {
        Hr = VFW_S_NO_MORE_ITEMS;
        goto MyExit;
    }
    if (!pMediaType)
    {
        Hr = E_POINTER;
        goto MyExit;
    }

    // Return our media type
    if (iPosition == 0L)
    {
        pMediaType->SetType(g_RtpOutputType.clsMajorType);
        pMediaType->SetSubtype(g_RtpOutputType.clsMinorType);
    }
    else if (iPosition == 1L)
    {
        if (m_iCurrFormat == -1L)
            *pMediaType = *R26XFormats[0];
        else
            *pMediaType = *R26XFormats[m_iCurrFormat];
    }
    else
    {
        Hr = VFW_S_NO_MORE_ITEMS;
    }

MyExit:
    return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CRtpOutputPin | CheckMediaType | This method is used to
 *    determine if the pin can support a specific media type.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag VFW_E_INVALIDMEDIATYPE | An invalid media type was specified
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpOutputPin::CheckMediaType(IN const CMediaType *pMediaType)
{
    HRESULT Hr = NOERROR;
    BOOL fFormatMatch = FALSE;
    DWORD dwIndex;

    // Validate input parameters
    ASSERT(pMediaType);
    if (!pMediaType)
    {
        Hr = E_POINTER;
        goto MyExit;
    }

    // We support MEDIATYPE_RTP_Multiple_Stream and
    // MEDIASUBTYPE_RTP_Payload_Mixed
    if (*pMediaType->Type() == MEDIATYPE_RTP_Multiple_Stream &&
        *pMediaType->Subtype() == MEDIASUBTYPE_RTP_Payload_Mixed)
    {
        goto MyExit;
    }
    else
    {
        // We support MEDIATYPE_Video and FORMAT_VideoInfo
        if (!pMediaType->pbFormat)
        {
            Hr = E_POINTER;
            goto MyExit;
        }

        if (*pMediaType->Type() != MEDIATYPE_Video ||
            *pMediaType->FormatType() != FORMAT_VideoInfo)
        {
            Hr = VFW_E_INVALIDMEDIATYPE;
            goto MyExit;
        }

        // Quickly test to see if this is the current format (what we
        // provide in GetMediaType). We accept that
        if (m_mt == *pMediaType)
        {
            goto MyExit;
        }

        // Check the media subtype and image resolution
        for (dwIndex = 0;
             dwIndex < NUM_OUTPUT_FORMATS && !fFormatMatch;
             dwIndex++)
        {
            if ( (HEADER(pMediaType->pbFormat)->biCompression ==
                  HEADER(R26XFormats[dwIndex]->pbFormat)->biCompression) &&
                 (HEADER(pMediaType->pbFormat)->biWidth ==
                  HEADER(R26XFormats[dwIndex]->pbFormat)->biWidth) &&
                 (HEADER(pMediaType->pbFormat)->biHeight ==
                  HEADER(R26XFormats[dwIndex]->pbFormat)->biHeight) )
                fFormatMatch = TRUE;
        }

        if (!fFormatMatch)
            Hr = E_FAIL;
    }

MyExit:
    return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CRtpOutputPin | SetMediaType | This method is used to
 *    set a specific media type on a pin.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpOutputPin::SetMediaType(IN CMediaType *pMediaType)
{
    HRESULT Hr = NOERROR;
    DWORD dwIndex;

    // Validate format
    if (FAILED(Hr = CheckMediaType(pMediaType)))
    {
        goto MyExit;
    }

    // Remember the format
    if (SUCCEEDED(Hr = CBasePin::SetMediaType(pMediaType)))
    {
        if (*pMediaType->Type() == MEDIATYPE_Video && *pMediaType->FormatType() == FORMAT_VideoInfo)
        {
            // Which one of our formats is this exactly?
            for (dwIndex=0; dwIndex < NUM_OUTPUT_FORMATS;  dwIndex++)
            {
                if ( (HEADER(pMediaType->pbFormat)->biCompression ==
                      HEADER(R26XFormats[dwIndex]->pbFormat)->biCompression) &&
                     (HEADER(pMediaType->pbFormat)->biWidth ==
                      HEADER(R26XFormats[dwIndex]->pbFormat)->biWidth) &&
                     (HEADER(pMediaType->pbFormat)->biHeight ==
                      HEADER(R26XFormats[dwIndex]->pbFormat)->biHeight) )
                    break;
            }

            if (dwIndex < NUM_OUTPUT_FORMATS)
            {
                // Update current format
                m_iCurrFormat = (int)dwIndex;
            }
            else
            {
                Hr = E_FAIL;
                goto MyExit;
            }
        }
    }

MyExit:
    return Hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\dsrtp\src\rtpcom.cpp ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpcom.cpp
 *
 *  Abstract:
 *
 *    Implements the IRtpSess interface
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/21 created
 *
 **********************************************************************/

#include "struct.h"
#include "classes.h"
#include "rtpsess.h"
#include "rtpaddr.h"
#include "rtpqos.h"
#include "rtpmask.h"
#include "rtpcrypt.h"
#include "rtpreg.h"
#include "rtcpsdes.h"
#include "rtppinfo.h"
#include "rtprtp.h"
#include "rtpred.h"
#include "msrtpapi.h"
#include "tapirtp.h"

#if USE_GRAPHEDT > 0
/* WARNING
 *
 * For AUTO mode and for testing purposes, use a global
 * variable to enabling sharing the same sessions for a
 * receiver and a sender */
HANDLE g_hSharedRtpAddr = NULL;
#endif

/**********************************************************************
 * Callback function to generate DShow events through
 * CBaseFilter::NotifyEvent()
 **********************************************************************/
void CALLBACK DsHandleNotifyEvent(
        void            *pvUserInfo,
        long             EventCode,
        LONG_PTR         EventParam1,
        LONG_PTR         EventParam2
    )
{
    CIRtpSession    *pCIRtpSession;

    pCIRtpSession = (CIRtpSession *)pvUserInfo;

    pCIRtpSession->
        CIRtpSessionNotifyEvent(EventCode, EventParam1, EventParam2);
}

CIRtpSession::CIRtpSession(
        LPUNKNOWN        pUnk,
        HRESULT         *phr,
        DWORD            dwFlags
    )
    //: CUnknown(_T("CIRtpSession"), pUnk, phr)
{
    HRESULT          hr;
    
    TraceFunctionName("CIRtpSession::CIRtpSession");  

    m_dwObjectID = OBJECTID_CIRTP;
    
    m_dwIRtpFlags = dwFlags;

    m_iMode = CIRTPMODE_NOTSET;

    m_RtpFilterState = State_Stopped;
    
    if (RtpBitTest(dwFlags, FGADDR_IRTP_ISSEND))
    {
        m_dwRecvSend = SEND_IDX;
    }
    else
    {
        m_dwRecvSend = RECV_IDX;
    }

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_INIT,
            _T("%s: pCIRtpSess[0x%p] created"),
            _fname, this
        ));
}

CIRtpSession::~CIRtpSession()
{
    TraceFunctionName("CIRtpSession::~CIRtpSession");  

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_INIT,
            _T("%s: pCIRtpSess[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
            _T("being deleted"),
            _fname, this, m_pRtpSess, m_pRtpAddr
        ));
    
    Cleanup();

    INVALIDATE_OBJECTID(m_dwObjectID);
}

STDMETHODIMP CIRtpSession::Control(
        DWORD            dwControl,
        DWORD_PTR        dwPar1,
        DWORD_PTR        dwPar2
    )
{
    return(E_FAIL);
}

STDMETHODIMP CIRtpSession::GetLastError(
        DWORD           *pdwError
    )
{
    return(E_FAIL);
}

/* When receiver and sender share the same session, Init() is called
 * twice, once by the receiver and once by the sender.
 *
 * The first call will set the mode (either automatic, used in
 * graphedt where no body calls Init(), or manual initialization,
 * normally used by the MSP or other application), and will create the
 * RtpSess_t and RtpAddr_t structures.
 *
 * */

const TCHAR_t *g_sCIRtpSessionMode[] = {
    _T("Invalid"),
    _T("AUTO"),
    _T("MANUAL"),
    _T("Invalid")
};

/* Init is the first method to call after an RTP source or render
 * filter is created, using a cookie allows the same RTP session
 * to be shared by a source and a render. The first call will have
 * the coockie initialized to NULL, the next call will use the
 * returned cookie to lookup the same RTP session. dwFlags can be
 * RTPINIT_QOS to create QOS enabled sockets, you can find out the
 * complete list of flags that can be used in file msrtp.h */
STDMETHODIMP CIRtpSession::Init(
        HANDLE              *phCookie,
        DWORD                dwFlags
    )
{
    HRESULT          hr;
    long             lRefCount;
    RtpAddr_t       *pRtpAddr;
    CRtpSourceFilter *pCRtpSourceFilter;

    TraceFunctionName("CIRtpSession::Init");

    hr = NOERROR;

#if USE_GRAPHEDT > 0
    /* WARNING
     *
     * For AUTO mode and for testing purposes, use a global variable
     * to enable sharing the same session for a receiver and a
     * sender. This means exactly 1 receiver and 1 sender at most, and
     * no more */
    phCookie = &g_hSharedRtpAddr;
#else
    if (!phCookie)
    {
        return(RTPERR_POINTER);
    }
#endif
    
    dwFlags &= RTPINIT_MASK;

    /* Map user flags passed (enum of RTPINITFG_* defined in msrtp.h)
     * to internal flags (enum of FGADDR_IRTP_* defined in struct.h)
     * */
    dwFlags <<= (FGADDR_IRTP_AUTO - RTPINITFG_AUTO);
    
    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_INIT,
            _T("%s: CIRtpSession[0x%p] Cookie:0x%p Flags:0x%X"),
            _fname, this, *phCookie, dwFlags
        ));

    if (m_iMode == CIRTPMODE_NOTSET)
    {
        /* Set mode */
        if (RtpBitTest(dwFlags, FGADDR_IRTP_AUTO))
        {
            m_iMode = CIRTPMODE_AUTO;
        }
        else
        {
            m_iMode = CIRTPMODE_MANUAL;
        }
    }
    else
    {
        /* Verify mode matches */
        if (RtpBitTest(dwFlags, FGADDR_IRTP_AUTO) &&
            m_iMode != CIRTPMODE_AUTO)
        {
            /* Fail */

            TraceRetail((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_INIT,
                    _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p]")
                    _T(" failed: Already initialized ")
                    _T("as %s, trying to set unmatched mode"),
                    _fname, this, m_pRtpSess, m_pRtpAddr,
                    g_sCIRtpSessionMode[m_iMode]
                ));

            return(RTPERR_INVALIDARG);
        }
    }
    
    /* TODO when multiple address are going to be supported, we will
     * not be able to use a member variable for the address
     * (i.e. m_pRtpAddr), but will have to lookup the address in the
     * session's addresses list */
    
    if (!*phCookie)
    {
        /* No session and address assigned, create new one */

        if (m_pRtpSess || m_pRtpAddr)
        {
            hr = RTPERR_INVALIDSTATE;
            goto bail;
        }

        /*
         * Create RTP session
         * */
        hr = GetRtpSess(&m_pRtpSess);
    
        if (FAILED(hr))
        {
            /* pass up the same returned error */
            goto bail;
        }

        /* first filter added to session */
        m_pRtpSess->lSessRefCount[m_dwRecvSend] = 1;

        /* Function to be used to pass up events (to the DShow graph) */
        m_pRtpSess->pHandleNotifyEvent = DsHandleNotifyEvent;
        
        /*
         * Create first address
         * */

        /* Create RtpAddr_t first */
        /* TODO call Control(m_pRtpSess, ...) */
        hr = GetRtpAddr(m_pRtpSess, &m_pRtpAddr, dwFlags);

        if (FAILED(hr))
        {
            goto bail;
        }

        /* I need to early check if QOS is disabled */
        if ( IsRegValueSet(g_RtpReg.dwQosEnable) &&
             ((g_RtpReg.dwQosEnable & 0x3) == 0x2) )
        {
            /* disable QOS */
            RtpBitSet(m_pRtpAddr->dwAddrFlagsQ, FGADDRQ_REGQOSDISABLE);
        }

        /* Now update cookie */
        *phCookie = (HANDLE)m_pRtpAddr;
    }
    else
    {
        /* Session and address were already assigned, verify */
        pRtpAddr = (RtpAddr_t *)*phCookie;

        if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
        {
            hr = RTPERR_INVALIDRTPADDR;
            goto bail;
        }

        m_pRtpAddr = pRtpAddr;

        m_pRtpSess = pRtpAddr->pRtpSess;
        
        if (m_pRtpSess)
        {
            lRefCount =
                InterlockedIncrement(&m_pRtpSess->lSessRefCount[m_dwRecvSend]);

            if (lRefCount > 1)
            {
                InterlockedDecrement(&m_pRtpSess->lSessRefCount[m_dwRecvSend]);
                
                /* This is invalid, there can be at the most 1
                 * receiver and 1 sender for a total RefCount equal 2
                 * */
                m_pRtpAddr = (RtpAddr_t *)NULL;
                m_pRtpSess = (RtpSess_t *)NULL;
                
                hr = RTPERR_REFCOUNT;

                goto bail;
            }
        }
        else
        {
            m_pRtpAddr = (RtpAddr_t *)NULL;
            
            hr = RTPERR_INVALIDSTATE;

            TraceRetail((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_INIT,
                    _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p]")
                    _T(" failed: %s (0x%X)"),
                    _fname, this, m_pRtpSess, m_pRtpAddr,
                    RTPERR_TEXT(hr), hr
                ));
            
            goto bail;
        }
    }

    /* update flags */
    m_dwIRtpFlags |= (dwFlags & FGADDR_IRTP_MASK);

    /* Update RtpAddr flags indicating if QOS is going to be used and
     * if was auto initialized */
    m_pRtpAddr->dwIRtpFlags |= (dwFlags & FGADDR_IRTP_MASK);

    /* This address will receive and/or send, but here we are adding
     * either a receiver or a sender */
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISRECV))
    {
        RtpBitSet(m_pRtpAddr->dwAddrFlags, FGADDR_ISRECV);

        /* Save the pointer to CIRtpSession (that contains a pointer
         * to m_pCBaseFilter aka CRtpSourceFilter) */
        m_pRtpSess->pvSessUser[RECV_IDX] = (void *)this;

        /* Is QOS going to be used ? */
        if (RtpBitTest(dwFlags, FGADDR_IRTP_QOS))
        {
            /* will enable QOS for receiver (will make reservation) */
            RtpBitSet(m_pRtpAddr->dwAddrFlags, FGADDR_QOSRECV);
        }
        
        /* If we already have (DShow) output pins, map them to the RTP
         * outputs */
        pCRtpSourceFilter = static_cast<CRtpSourceFilter *>(m_pCBaseFilter);

        pCRtpSourceFilter->MapPinsToOutputs();

        if (RtpGetClass(m_pRtpAddr->dwIRtpFlags) == RTPCLASS_AUDIO)
        {
            RtpBitSet(m_pRtpAddr->dwIRtpFlags, FGADDR_IRTP_USEPLAYOUT);

            if ( IsRegValueSet(g_RtpReg.dwRedEnable) &&
                 ((g_RtpReg.dwRedEnable & 0x03) == 0x03) )
            {
                RtpSetRedParameters(m_pRtpAddr,
                                    RtpBitPar(RECV_IDX),
                                    g_RtpReg.dwRedPT,
                                    g_RtpReg.dwInitialRedDistance,
                                    g_RtpReg.dwMaxRedDistance);
            }
        }
    }
    else if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISSEND))
    {
        RtpBitSet(m_pRtpAddr->dwAddrFlags, FGADDR_ISSEND);

        /* Save the pointer to CIRtpSession (that contains a pointer
         * to m_pCBaseFilter aka CRtpRenderFilter) */
        m_pRtpSess->pvSessUser[SEND_IDX] = (void *)this;

        /* Is QOS going to be used ? */
        if (RtpBitTest(dwFlags, FGADDR_IRTP_QOS))
        {
            /* will enable QOS for sender (will send PATH messages) */
            RtpBitSet(m_pRtpAddr->dwAddrFlags, FGADDR_QOSSEND);
        }

        if (RtpGetClass(m_pRtpAddr->dwIRtpFlags) == RTPCLASS_AUDIO)
        {
            if ( IsRegValueSet(g_RtpReg.dwRedEnable) &&
                 ((g_RtpReg.dwRedEnable & 0x30) == 0x30) )
            {
                RtpSetRedParameters(m_pRtpAddr,
                                    RtpBitPar(SEND_IDX),
                                    g_RtpReg.dwRedPT,
                                    g_RtpReg.dwInitialRedDistance,
                                    g_RtpReg.dwMaxRedDistance);
            }
        }
    }
    else
    {
        /* Unexpected situation */
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_INIT,
                _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("Cookie:0x%p Flags:0x%X not receiver nor sender"),
                _fname, this, m_pRtpSess, m_pRtpAddr,
                *phCookie, dwFlags
            ));

        hr = RTPERR_UNEXPECTED;

        goto bail;
    }

    /* Inidicate that initialization was done */
    RtpBitSet(m_dwIRtpFlags, FGADDR_IRTP_INITDONE);

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_INIT,
            _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
            _T("Cookie:0x%p Flags:0x%X"),
            _fname, this, m_pRtpSess, m_pRtpAddr,
            *phCookie, dwFlags
        ));

    return(hr);
    
 bail:
    TraceRetail((
            CLASS_ERROR, GROUP_DSHOW, S_DSHOW_INIT,
            _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
            _T("Cookie:0x%p Flags:0x%X failed: %u (0x%X)"),
            _fname, this, m_pRtpSess, m_pRtpAddr,
            *phCookie, dwFlags, hr, hr
        ));

    Cleanup();
    
    return(hr);
}

/* Deinit is a method used to take the filter back to a state on
 * which a new Init() can and must be done if the filter is to be
 * started again, also note that just after Init(), a filter needs
 * to be configured, that holds also when you use Deinit() taking
 * the filter to its initial state */
STDMETHODIMP CIRtpSession::Deinit(void)
{
    HRESULT          hr;
    CRtpSourceFilter *pCRtpSourceFilter;

    TraceFunctionName("CIRtpSession::Deinit");

    hr = NOERROR;
    
    if (!RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        /* Do nothing if the filter is not initialized yet */
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_INIT,
                _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("Not initialized yet, nothing to do"),
                _fname, this, m_pRtpSess, m_pRtpAddr
            ));
        
        return(hr);
    }

    if (m_pCBaseFilter->IsActive())
    {
        /* Fail if the filter is still active */
        hr = RTPERR_INVALIDSTATE;

        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_INIT,
                _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: filter is still active: %s (0x%X)"),
                _fname, this, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }
    else
    {
        /* OK to deinit */

        /* Make sure the session is stoppped */
        if (RtpBitTest(m_pRtpAddr->dwIRtpFlags, FGADDR_IRTP_PERSISTSOCKETS))
        {
            /* If FGADDR_IRTP_PERSISTSOCKETS is set, the session may
             * be still running in a muted state regardless DShow Stop
             * has been called, to force a real stop, MUST use the
             * flag provided for that */
            if (m_dwRecvSend == RECV_IDX)
            {
                RtpStop(m_pRtpSess,
                        RtpBitPar2(FGADDR_ISRECV, FGADDR_FORCESTOP));
            }
            else
            {
                RtpStop(m_pRtpSess,
                        RtpBitPar2(FGADDR_ISSEND, FGADDR_FORCESTOP));
            }
        }

        if (m_dwRecvSend == RECV_IDX)
        {
            /* Diassociate DShow pins and RtpOutput */
            pCRtpSourceFilter =
                static_cast<CRtpSourceFilter *>(m_pCBaseFilter);

            pCRtpSourceFilter->UnmapPinsFromOutputs();
        }
        
        Cleanup();

        TraceRetail((
                CLASS_INFO, GROUP_DSHOW, S_DSHOW_INIT,
                _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("Done"),
                _fname, this, m_pRtpSess, m_pRtpAddr
            ));
    }

    return(hr);
}

void CIRtpSession::Cleanup()
{
    long             lRefCount;
    DWORD            dwIndex;
    
    TraceFunctionName("CIRtpSession::Cleanup");

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_INIT,
            _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p]"),
            _fname, this, m_pRtpSess, m_pRtpAddr
        ));
    
    if (m_pRtpSess)
    {
        lRefCount =
            InterlockedDecrement(&m_pRtpSess->lSessRefCount[m_dwRecvSend]);

        /* Get the opposite index */
        if (m_dwRecvSend == RECV_IDX)
        {
            dwIndex = SEND_IDX;
        }
        else
        {
            dwIndex = RECV_IDX;
        }
        
        lRefCount +=
            InterlockedCompareExchange(&m_pRtpSess->lSessRefCount[dwIndex],
                                       0,
                                       0);

        if (lRefCount <= 0)
        {
            if (m_pRtpAddr)
            {
                DelRtpAddr(m_pRtpSess, m_pRtpAddr);
            }
    
            DelRtpSess(m_pRtpSess);

            if (m_iMode == CIRTPMODE_AUTO)
            {
                m_iMode = CIRTPMODE_NOTSET;
            }
#if USE_GRAPHEDT > 0
            g_hSharedRtpAddr = NULL;
#endif
        }

        m_pRtpAddr = (RtpAddr_t *)NULL;
        m_pRtpSess = (RtpSess_t *)NULL;

        RtpBitReset(m_dwIRtpFlags, FGADDR_IRTP_INITDONE);
    }
}

STDMETHODIMP CIRtpSession::GetPorts(
        WORD            *pwRtpLocalPort,
        WORD            *pwRtpRemotePort,
        WORD            *pwRtcpLocalPort,
        WORD            *pwRtcpRemotePort
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetPorts");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpGetPorts(m_pRtpAddr,
                         pwRtpLocalPort,
                         pwRtpRemotePort,
                         pwRtcpLocalPort,
                         pwRtcpRemotePort);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

STDMETHODIMP CIRtpSession::SetPorts(
        WORD             wRtpLocalPort,
        WORD             wRtpRemotePort,
        WORD             wRtcpLocalPort,
        WORD             wRtcpRemotePort
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetPorts");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetPorts(m_pRtpAddr,
                         wRtpLocalPort,
                         wRtpRemotePort,
                         wRtcpLocalPort,
                         wRtcpRemotePort);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/*
 * All parameters in NETWORK order */
STDMETHODIMP CIRtpSession::SetAddress(
        DWORD            dwLocalAddr,
        DWORD            dwRemoteAddr
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetAddress");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetAddress(m_pRtpAddr, dwLocalAddr, dwRemoteAddr);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/*
 * All parameters in NETWORK order */
STDMETHODIMP CIRtpSession::GetAddress(
        DWORD           *pdwLocalAddr,
        DWORD           *pdwRemoteAddr
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetAddress");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpGetAddress(m_pRtpAddr, pdwLocalAddr, pdwRemoteAddr);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* The dwFlags parameter is used to determine if the scope is set for
 * RTP (0x1), RTCP (0x2), or both (0x3) */
STDMETHODIMP CIRtpSession::SetScope(
        DWORD            dwTTL,
        DWORD            dwFlags
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetScope");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        if (dwFlags & 1)
        { /* RTP */
            m_pRtpAddr->dwTTL[0] = dwTTL;
        }
        if (dwFlags & 2)
        { /* RTCP */
            m_pRtpAddr->dwTTL[1] = dwTTL;
        }
        
        hr = NOERROR;
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}
 
/* Set the multicast loopback mode (e.g. RTPMCAST_LOOPBACKMODE_NONE,
 * RTPMCAST_LOOPBACKMODE_PARTIAL, etc) */
STDMETHODIMP CIRtpSession::SetMcastLoopback(
        int              iMcastLoopbackMode,
        DWORD            dwFlags
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetMcastLoopback");  

    hr = RTPERR_NOTINIT;

    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetMcastLoopback(m_pRtpAddr, iMcastLoopbackMode, dwFlags);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Modify the mask specified by dwKind (e.g. RTPMASK_RECV_EVENTS,
 * RTPMASK_SDES_LOCMASK).
 *
 * dwMask is the mask of bits to be set or reset depending on dwValue
 * (reset if 0, set otherwise).
 *
 * pdwModifiedMask will return the resulting mask if the pointer is
 * not NULL. You can just query the current mask value by passing
 * dwMask=0 */
STDMETHODIMP CIRtpSession::ModifySessionMask(
        DWORD            dwKind,
        DWORD            dwEventMask,
        DWORD            dwValue,
        DWORD           *dwModifiedMask
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::ModifySessionMask");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpModifyMask(m_pRtpSess, dwKind, dwEventMask, dwValue,
                           dwModifiedMask);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Set the bandwidth limits. A value of -1 will make the parameter
 * to be left unchanged.
 *
 * All the parameters are in bits/sec */
STDMETHODIMP CIRtpSession::SetBandwidth(
        DWORD            dwInboundBw,
        DWORD            dwOutboundBw,
        DWORD            dwReceiversRtcpBw,
        DWORD            dwSendersRtcpBw
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetRtpBandwidth");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetBandwidth(m_pRtpAddr,
                             dwInboundBw,
                             dwOutboundBw,
                             dwReceiversRtcpBw,
                             dwSendersRtcpBw);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* pdwSSRC points to an array of DWORDs where to copy the SSRCs,
 * pdwNumber contains the maximum entries to copy, and returns the
 * actual number of SSRCs copied. If pdwSSRC is NULL, pdwNumber
 * will return the current number of SSRCs (i.e. the current
 * number of participants) */
STDMETHODIMP CIRtpSession::EnumParticipants(
        DWORD           *pdwSSRC,
        DWORD           *pdwNumber
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::EnumParticipants");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpEnumParticipants(m_pRtpAddr, pdwSSRC, pdwNumber);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Get the participant state. dwSSRC specifies the
 * participant. piState will return the current participant's
 * state (e.g. RTPPARINFO_TALKING, RTPPARINFO_SILENT). */
STDMETHODIMP CIRtpSession::GetParticipantState(
        DWORD            dwSSRC,
        DWORD           *pdwState
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetParticipantState");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpMofifyParticipantInfo(m_pRtpAddr,
                                      dwSSRC,
                                      RTPUSER_GET_PARSTATE,
                                      pdwState);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Get the participant's mute state. dwSSRC specifies the
 * participant. pbMuted will return the participant's mute state
 * */
STDMETHODIMP CIRtpSession::GetMuteState(
        DWORD            dwSSRC,
        BOOL            *pbMuted
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetMuteState");  

    hr = RTPERR_NOTINIT;

    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpMofifyParticipantInfo(m_pRtpAddr,
                                      dwSSRC,
                                      RTPUSER_GET_MUTE,
                                      (DWORD *)pbMuted);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Set the participant's mute state. dwSSRC specifies the
 * participant. bMuted specifies the new state. Note that mute is
 * used to refer to the permission or not to pass packets received
 * up to the application, and it applies equally to audio or video
 * */
STDMETHODIMP CIRtpSession::SetMuteState(
        DWORD            dwSSRC,
        BOOL             bMuted
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetMuteState");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpMofifyParticipantInfo(m_pRtpAddr,
                                      dwSSRC,
                                      RTPUSER_SET_MUTE,
                                      (DWORD *)&bMuted);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Query the network metrics computation state for the specific SSRC */
STDMETHODIMP CIRtpSession::GetNetMetricsState(
        DWORD            dwSSRC,
        BOOL            *pbState
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetNetMetricsState");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpMofifyParticipantInfo(m_pRtpAddr,
                                      dwSSRC,
                                      RTPUSER_GET_NETEVENT,
                                      (DWORD *)pbState);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Enable or disable the computation of networks metrics, this is
 * mandatory in order of the corresponding event to be fired if
 * enabled. This is done for the specific SSRC or the first one
 * found if SSRC=-1, if SSRC=0, then the network metrics
 * computation will be performed for any and all the SSRCs */
STDMETHODIMP CIRtpSession::SetNetMetricsState(
        DWORD            dwSSRC,
        BOOL             bState
    )
{
    HRESULT          hr;
    DWORD            dwControl;
    
    TraceFunctionName("CIRtpSession::SetNetMetricsState");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        if (!dwSSRC)
        {
            /* Set it for any and all SSRCs */
            dwControl = RTPUSER_SET_NETEVENTALL;
        }
        else
        {
            /* Set it for only one SSRC */
            dwControl = RTPUSER_SET_NETEVENT;
        }

        hr = RtpMofifyParticipantInfo(m_pRtpAddr,
                                      dwSSRC,
                                      dwControl,
                                      (DWORD *)&bState);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}
    
/* Retrieves network information, if the network metric
 * computation is enabled for the specific SSRC, all the fields in
 * the structure will be meaningful, if not, only the average
 * values will contain valid data */
STDMETHODIMP CIRtpSession::GetNetworkInfo(
        DWORD            dwSSRC,
        RtpNetInfo_t    *pRtpNetInfo
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetNetworkInfo");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpMofifyParticipantInfo(m_pRtpAddr,
                                      dwSSRC,
                                      RTPUSER_GET_NETINFO,
                                      (DWORD *)pRtpNetInfo);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}


/* Set the local SDES information for item dwSdesItem (e.g
 * RTPSDES_CNAME, RTPSDES_EMAIL), psSdesData contains the UNICODE
 * NULL terminated string to be assigned to the item */
STDMETHODIMP CIRtpSession::SetSdesInfo(
        DWORD            dwSdesItem,
        WCHAR           *psSdesData
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetSdesInfo");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetSdesInfo(m_pRtpAddr, dwSdesItem, psSdesData);
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Get a local SDES item if dwSSRC=0, otherwise gets the SDES item
 * from the participant whose SSRC was specified.
 *
 * dwSdesItem is the item to get (e.g. RTPSDES_CNAME,
 * RTPSDES_EMAIL), psSdesData is the memory place where the item's
 * value will be copied, pdwSdesDataLen contains the initial size
 * in UNICODE chars, and returns the actual UNICODE chars copied
 * (including the NULL terminating char, if any), dwSSRC specify
 * which participant to retrieve the information from. If the SDES
 * item is not available, dwSdesDataLen is set to 0 and the call
 * doesn't fail */
STDMETHODIMP CIRtpSession::GetSdesInfo(
        DWORD            dwSdesItem,
        WCHAR           *psSdesData,
        DWORD           *pdwSdesDataLen,
        DWORD            dwSSRC
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetSdesInfo");  

    hr = RTPERR_NOTINIT;

    if (!dwSSRC || RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpGetSdesInfo(m_pRtpAddr,
                            dwSdesItem,
                            psSdesData,
                            pdwSdesDataLen,
                            dwSSRC);
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Select a QOS template (flowspec) by passing its name in
 * psQosName, dwResvStyle specifies the RSVP style (e.g
 * RTPQOS_STYLE_WF, RTPQOS_STYLE_FF), dwMaxParticipants specifies
 * the max number of participants (1 for unicast, N for
 * multicast), this number is used to scale up the
 * flowspec. dwQosSendMode specifies the send mode (has to do with
 * allowed/not allowed to send) (e.g. RTPQOSSENDMODE_UNRESTRICTED,
 * RTPQOSSENDMODE_RESTRICTED1). dwMinFrameSize is the minimum
 * frame size (in ms), passing 0 makes this parameter be ignored
 * */
STDMETHODIMP CIRtpSession::SetQosByName(
        TCHAR           *psQosName,
        DWORD            dwResvStyle,
        DWORD            dwMaxParticipants,
        DWORD            dwQosSendMode,
        DWORD            dwMinFrameSize
    )
{
    HRESULT          hr;
    
    TraceFunctionName("CIRtpSession::SetQosByName");  

    hr = RTPERR_NOTINIT;

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_CIRTP,
            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
            _T("QOS Name:%s Style:%d MaxParticipants:%d ")
            _T("SendMode:%d FrameSize:%d"),
            _fname, m_pRtpSess, m_pRtpAddr,
            psQosName, dwResvStyle, dwMaxParticipants,
            dwQosSendMode, dwMinFrameSize
        ));

    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetQosByNameOrPT(m_pRtpAddr,
                                 RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISRECV)?
                                 RECV_IDX : SEND_IDX,
                                 psQosName,
                                 NO_DW_VALUESET,
                                 dwResvStyle,
                                 dwMaxParticipants,
                                 dwQosSendMode,
                                 dwMinFrameSize,
                                 FALSE /* Not internal, i.e. from API */);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Not yet implemented, will have same functionality as
 * SetQosByName, except that instead of passing a name to use a
 * predefined flowspec, the caller will pass enough information in
 * the RtpQosSpec structure to obtain the customized flowspec to
 * use */
STDMETHODIMP CIRtpSession::SetQosParameters(
        RtpQosSpec_t    *pRtpQosSpec,
        DWORD            dwMaxParticipants,
        DWORD            dwQosSendMode
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetQosParameters");  

    hr = RTPERR_NOTIMPL;

#if 0
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetQosParameters(m_pRtpAddr,
                                 RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISRECV)?
                                 RECV_IDX : SEND_IDX,
                                 pRtpQosSpec,
                                 dwMaxParticipants,
                                 dwQosSendMode);
    }
#endif
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* If AppName is specified, replaces the default AppName, as well
 * as the APP field in the policy used, with the new UNICODE
 * string, if not, sets the binary image name as the default. If
 * psPolicyLocator is specified, append a comma and this whole
 * string to the default policy locator, if not, just sets the
 * default
 * */
STDMETHODIMP CIRtpSession::SetQosAppId(
        WCHAR           *psAppName,
        WCHAR           *psAppGUID,
        WCHAR           *psPolicyLocator
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetQosAppId");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetQosAppId(m_pRtpAddr, psAppName, psAppGUID, psPolicyLocator);
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Adds/removes a single SSRC to/from the shared explicit list of
 * participants who receive reservation (i.e. it is used when the
 * ResvStyle=RTPQOS_STYLE_SE). */
STDMETHODIMP CIRtpSession::SetQosState(
        DWORD            dwSSRC,
        BOOL             bEnable
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetQosState");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISSEND))
        {
            hr = NOERROR;
        }
        else
        {
            hr = RtpSetQosState(m_pRtpAddr, dwSSRC, bEnable);
        }
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Adds/removes a number of SSRCs to/from the shared explicit list
 * of participants who receive reservation (i.e. it is used when
 * the ResvStyle=RTPQOS_STYLE_SE). dwNumber is the number of SSRCs
 * to add/remove, and returns the actual number of SSRCs
 * added/removed */
STDMETHODIMP CIRtpSession::ModifyQosList(
        DWORD           *pdwSSRC,
        DWORD           *pdwNumber,
        DWORD            dwOperation
    )
{
    HRESULT          hr;
    
    TraceFunctionName("CIRtpSession::ModifyQosList");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISSEND))
        {
            hr = NOERROR;
        }
        else
        {
            hr = RtpModifyQosList(m_pRtpAddr, pdwSSRC, pdwNumber, dwOperation);
        }
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* iMode defines what is going to be encrypted/decrypted,
 * e.g. RTPCRYPTMODE_PAYLOAD to encrypt/decrypt only RTP
 * payload. dwFlag can be RTPCRYPT_SAMEKEY to indicate that (if
 * applicable) the key used for RTCP is the same used for RTP */
STDMETHODIMP CIRtpSession::SetEncryptionMode(
        int              iMode,
        DWORD            dwFlags
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetEncryptionMode");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        if ( !(RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISRECV) &&
               RtpBitTest(m_pRtpAddr->dwAddrFlags, FGADDR_RUNRECV)) &&

             !(RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISSEND) &&
               RtpBitTest(m_pRtpAddr->dwAddrFlags, FGADDR_RUNSEND)) )
        {
            hr = RtpSetEncryptionMode(m_pRtpAddr, iMode, dwFlags);
        }
        else
        {
            hr = RTPERR_INVALIDSTATE;
        }
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Specifies the information needed to derive an
 * encryption/decryption key. PassPhrase is the (random) text used
 * to generate a key. HashAlg specifies the algorithm to use to
 * hash the pass phrase and generate a key. DataAlg is the
 * algorithm used to encrypt/decrypt the data. Default hash
 * algorithm is RTPCRYPT_MD5, default data algorithm is
 * RTPCRYPT_DES. If encryption is to be used, the PassPhrase is a
 * mandatory parameter to set */
STDMETHODIMP CIRtpSession::SetEncryptionKey(
        TCHAR           *psPassPhrase,
        TCHAR           *psHashAlg,
        TCHAR           *psDataAlg,
        BOOL            bRtcp
    )
{
    HRESULT          hr;
    DWORD            dwIndex;

    TraceFunctionName("CIRtpSession::SetEncryptionKey");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        if ( !(RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISRECV) &&
               RtpBitTest(m_pRtpAddr->dwAddrFlags, FGADDR_RUNRECV)) &&

             !(RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISSEND) &&
               RtpBitTest(m_pRtpAddr->dwAddrFlags, FGADDR_RUNSEND)) )
        {
            if (bRtcp)
            {
                dwIndex = CRYPT_RTCP_IDX;
            }
            else
            {
                if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISRECV))
                {
                    dwIndex = CRYPT_RECV_IDX;
                }
                else
                {
                    dwIndex = CRYPT_SEND_IDX;
                }
            }
    
            hr = RtpSetEncryptionKey(m_pRtpAddr, psPassPhrase,
                                     psHashAlg, psDataAlg,
                                     dwIndex);
        }
        else
        {
            hr = RTPERR_INVALIDSTATE;
        }
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/**************************************************
 * Helper methods
 **************************************************/
    
HRESULT CIRtpSession::CIRtpSessionNotifyEvent(
        long             EventCode,
        LONG_PTR         EventParam1,
        LONG_PTR         EventParam2
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::CIRtpSessionNotifyEvent");
    
    hr = NOERROR;
    
    if (m_pCBaseFilter)
    {
        hr = m_pCBaseFilter->NotifyEvent(EventCode, EventParam1, EventParam2);
        if ( SUCCEEDED(hr) )
        {
            TraceRetailAdvanced((
                    0, GROUP_DSHOW,S_DSHOW_EVENT,
                    _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] Succeeded: ")
                    _T("Code:%u (0x%X) P1:0x%p P2:0x%p"),
                    _fname, m_pRtpSess, m_pRtpAddr,
                    EventCode, EventCode,
                    EventParam1, EventParam2
                ));
        }
        else
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_EVENT,
                    _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] failed: ")
                    _T("%u (0x%X) !!! ")
                    _T("Code:%u (0x%X) P1:0x%p P2:0x%p"),
                    _fname, m_pRtpSess, m_pRtpAddr,
                    hr, hr,
                    EventCode, EventCode,
                    EventParam1, EventParam2
                ));
        }
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\lookup.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    lookup.h
 *
 *  Abstract:
 *
 *    Helper functions to look up SSRCs
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/17 created
 *
 **********************************************************************/

#ifndef _lookup_h_
#define _lookup_h_

#include "gtypes.h"
#include "struct.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

RtpUser_t *LookupSSRC(RtpAddr_t *pRtpAddr, DWORD dwSSRC, BOOL *pbCreate);

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _lookup_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\dsrtp\src\render.cpp ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    render.cpp
 *
 *  Abstract:
 *
 *    CRtpRenderFilter and CRtpInputPin implementation
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#include <winsock2.h>

#include <filterid.h>
#include "gtypes.h"
#include "classes.h"
#include "rtpqos.h"
#include "rtpglobs.h"
#include "msrtpapi.h"
#include "dsglob.h"
#include "rtppt.h"
#include "rtppktd.h"
#include "rtpdemux.h"
#include "rtpdtmf.h"
#include "rtpred.h"

#include "tapirtp.h"
#include "dsrtpid.h"

/**********************************************************************
 *
 * RTP Input Pin class implementation: CRtpInputPin
 *
 **********************************************************************/

/*
 * CRtpInputPin constructor
 * */
CRtpInputPin::CRtpInputPin(
        int               iPos,
        BOOL              bCapture,
        CRtpRenderFilter *pCRtpRenderFilter,
        CIRtpSession     *pCIRtpSession,
        HRESULT          *phr,
        LPCWSTR           pPinName
    )
    : CBaseInputPin(
            _T("CRtpInputPin"),
            pCRtpRenderFilter,                   
            pCRtpRenderFilter->pStateLock(),                     
            phr,                       
            pPinName
          ),
      
      m_pCRtpRenderFilter(
              pCRtpRenderFilter
          )
{
    m_dwObjectID = OBJECTID_RTPIPIN;
    
    m_pCIRtpSession = pCIRtpSession;

    m_dwFlags = 0;
     
    m_iPos = iPos;
      
    m_bCapture = bCapture;
    /* TODO should fail if a valid filter is not passed */

    /* TODO some initialization can be removed once I use a private
     * heap for this objects (which will zero the segment) */
}

/*
 * CRtpInputPin destructor
 * */
CRtpInputPin::~CRtpInputPin()
{
    INVALIDATE_OBJECTID(m_dwObjectID);
}

void *CRtpInputPin::operator new(size_t size)
{
    void            *pVoid;
    
    TraceFunctionName("CRtpInputPin::operator new");

    pVoid = RtpHeapAlloc(g_pRtpRenderHeap, size);

    if (!pVoid)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: failed to allocate memory:%u"),
                _fname, size
            ));
    }
    
    return(pVoid);
}

void CRtpInputPin::operator delete(void *pVoid)
{
    if (pVoid)
    {
        RtpHeapFree(g_pRtpRenderHeap, pVoid);
    }
}

/**************************************************
 * CBasePin overrided methods
 **************************************************/
    
/*
 * Verify we can handle this format
 * */
HRESULT CRtpInputPin::CheckMediaType(const CMediaType *pCMediaType)
{
    /* accepts everything */
    return(NOERROR);
}

HRESULT CRtpInputPin::SetMediaType(const CMediaType *pCMediaType)
{
    HRESULT hr;
    DWORD   dwPT;
    DWORD   dwFreq;

    TraceFunctionName("CRtpInputPin::SetMediaType");
    
    hr = CBasePin::SetMediaType(pCMediaType);

    if (SUCCEEDED(hr))
    {
        /* Get default payload type and sampling frequency for Capture
         * pin */
        if (m_bCapture)
        {
            ((CRtpRenderFilter*)m_pFilter)->
                MediaType2PT(pCMediaType, &dwPT, &dwFreq);

            m_bPT = (BYTE)dwPT;
            m_dwSamplingFreq = dwFreq;

            if (*pCMediaType->Type() == MEDIATYPE_RTP_Single_Stream)
            {
                m_pCRtpRenderFilter->
                    ModifyFeature(RTPFEAT_PASSHEADER, TRUE);
            }
            else
            {
                m_pCRtpRenderFilter->
                    ModifyFeature(RTPFEAT_PASSHEADER, FALSE);
            }

            TraceRetail((
                    CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
                    _T("%s: m_pFilter[0x%p] Will send ")
                    _T("PT:%u Frequency:%u"),
                    _fname, m_pFilter, m_bPT, m_dwSamplingFreq
                ));
        }
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: m_pFilter[0x%p] failed: %u (0x%X)"),
                _fname, m_pFilter, hr, hr
            ));
    }
    
    return(hr);
}

STDMETHODIMP CRtpInputPin::EndOfStream()
{
    HRESULT          hr;

    hr = m_pFilter->NotifyEvent(
            EC_COMPLETE, 
            S_OK,
            (LONG_PTR)(IBaseFilter*)m_pFilter
        );

    return(hr);
}

STDMETHODIMP CRtpInputPin::ReceiveConnection(
    IPin * pConnector,      // this is the initiating connecting pin
    const AM_MEDIA_TYPE *pmt   // this is the media type we will exchange
    )
{
    if(pConnector != m_Connected)
    {
        return CBaseInputPin::ReceiveConnection(pConnector, pmt);
    }

    CMediaType cmt(*pmt);
    HRESULT hr = CheckMediaType(&cmt);
    ASSERT(hr == S_OK);

    if(hr == S_OK)
    {
        SetMediaType(&cmt);
    }
    else 
    {
        DbgBreak("??? CheckMediaType failed in dfc ReceiveConnection.");
        hr = E_UNEXPECTED;
    }

    return hr;
}


/**************************************************
 * CBaseInputPin overrided methods
 **************************************************/

STDMETHODIMP CRtpInputPin::GetAllocatorRequirements(
        ALLOCATOR_PROPERTIES *pProps
    )
{
    /* Set here my specific requirements, as I don't know at this
     * point if redundancy is going to be used or not, I need to be
     * prepared and ask resources as if redundancy were to be used
     * (should be the default anyway), and in such case I would hold
     * at the most N buffers (the max redundancy distance), and the
     * previous filter (the encoder or capture) needs to have enough
     * buffers so it will not run out of them */
    pProps->cBuffers = RTP_RED_MAXDISTANCE;

    return(NOERROR);
}

/**************************************************
 * IMemInputPin implemented methods
 **************************************************/

/* send input stream over network */
STDMETHODIMP CRtpInputPin::Receive(IMediaSample *pIMediaSample)
{
    HRESULT          hr;
    RtpAddr_t       *pRtpAddr;
    WSABUF           wsaBuf[3+RTP_RED_MAXRED];
    DWORD            dwNumBuf;
    DWORD            dwSendFlags;
    DWORD            dwTimeStamp;
    DWORD            dwPT;
    DWORD            dwNewFreq;
    int              iFreqChange;
    int              iTsAdjust;
    double           dTime;
    REFERENCE_TIME   AMTimeStart, AMTimeEnd;
    IMediaSample    *pIMediaSampleData;
    
    RTP_PD_HEADER   *pRtpPDHdr;
    RTP_PD          *pRtpPD;
    DWORD            dwNumBlocks;
    char            *pHdr;
    char            *pData;
    DWORD            marker;
    FILTER_STATE     FilterState;
    
    TraceFunctionName("CRtpInputPin::Receive");
    
    hr = CBaseInputPin::Receive(pIMediaSample);

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: CBaseInputPin::Receive failed: %u (0x%X)"),
                _fname, hr, hr
            ));
        
        return(hr);
    }

    if (!(m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE)))
    {
        hr = RTPERR_NOTINIT;
        
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: m_pFilter[0x%p] is in an invalid state: %s (0x%X)"),
                _fname, m_pFilter, RTPERR_TEXT(hr), hr
            ));
        
        return(hr);
    }

    FilterState = State_Stopped;
    
    m_pFilter->GetState(0, &FilterState);

    if (FilterState != State_Running ||
        m_pCRtpRenderFilter->GetFilterState() != State_Running)
    {
        hr = RTPERR_INVALIDSTATE;
        
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: m_pFilter[0x%p] is not running: %s (0x%X)"),
                _fname, m_pFilter, RTPERR_TEXT(hr), hr
            ));
        
        return(NOERROR);
    }
    
    pRtpAddr = m_pCIRtpSession->GetpRtpAddr();

    dwTimeStamp = 0;
    dwSendFlags = NO_FLAGS;
    
    iFreqChange = 0;
            
    if (m_bCapture)
    {
        /* Capture data */

        /* Handle in-band format changes. This needs to be done before
         * the timestamp is computed as the frequency might be
         * different */
        if (m_SampleProps.dwSampleFlags & AM_SAMPLE_TYPECHANGED)
        {
            ((CRtpRenderFilter*)m_pFilter)->
                MediaType2PT((CMediaType *)m_SampleProps.pMediaType,
                             &dwPT,
                             &dwNewFreq);

            iFreqChange = (int)m_dwSamplingFreq - dwNewFreq;
            
            m_bPT = (BYTE)dwPT;
            m_dwSamplingFreq = dwNewFreq;
            
            pRtpAddr->RtpNetSState.bPT = m_bPT;
            pRtpAddr->RtpNetSState.dwSendSamplingFreq = m_dwSamplingFreq;

            TraceRetail((
                    CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
                    _T("%s: m_pFilter[0x%p] RtpAddr[0x%p] ")
                    _T("Sending PT:%u Frequency:%u"),
                    _fname, m_pFilter, pRtpAddr, dwPT, dwNewFreq
                ));
        }
    }

    if (!RtpBitTest(pRtpAddr->pRtpSess->dwFeatureMask, RTPFEAT_PASSHEADER))
    {
        /* Need to generate timestamp. If this flag is set, then this
         * generation is not needed as the timestamp is part of the
         * RTP header which is already contained in the buffer and
         * will be used unchanged */
        
        if (!RtpBitTest(pRtpAddr->pRtpSess->dwFeatureMask,
                        RTPFEAT_GENTIMESTAMP))
        {
            hr = pIMediaSample->GetTime(&AMTimeStart, &AMTimeEnd);

            if (FAILED(hr))
            {
                TraceRetail((
                        CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                        _T("%s: m_pFilter[0x%p] ")
                        _T("pIMediaSample->GetTime failed: %u (0x%X)"),
                        _fname, m_pFilter, hr, hr
                    ));
    
                /* MAYDO may be an alternative time stamp can be obtained
                 * instead */
                return(VFW_E_SAMPLE_REJECTED);
            }

            if (iFreqChange)
            {
                /* If changing frequency, adjust the random timestamp
                 * offset to compensate for the timestamp jump. A
                 * forward jump when passing from lower -> higher
                 * frequency, and a backwards jump when passing from
                 * higher -> lower frequency */
                iTsAdjust = (int)
                    (ConvertToMilliseconds(AMTimeStart) * iFreqChange / 1000);


                pRtpAddr->RtpNetSState.dwTimeStampOffset += (DWORD) iTsAdjust;

                TraceRetail((
                        CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
                        _T("%s: m_pFilter[0x%p] pRtpAddr[0x%p] Start:%0.3f ")
                        _T("frequency change: %u to %u, ts adjust:%d"),
                        _fname, m_pFilter, pRtpAddr,
                        (double)ConvertToMilliseconds(AMTimeStart)/1000,
                        iFreqChange + (int)m_dwSamplingFreq,
                        m_dwSamplingFreq,
                        iTsAdjust
                    ));
            }
            
            /* timestamp */
            dwTimeStamp = (DWORD)
                ( ConvertToMilliseconds(AMTimeStart) *
                  pRtpAddr->RtpNetSState.dwSendSamplingFreq / 1000 );

#if 0
            /* USED TO DEBUG ONLY */
            TraceRetail((
                    CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
                    _T("%s: pRtpAddr[0x%p] SSRC:0x%X ts:%u ")
                    _T("StartTime:%I64u/%u ")
                    _T("EndTime:%I64u/%u"),
                    _fname, pRtpAddr,
                    ntohl(pRtpAddr->RtpNetSState.dwSendSSRC),
                    dwTimeStamp,
                    AMTimeStart,
                    ((CRefTime *)&AMTimeStart)->Millisecs(),
                    AMTimeEnd,
                    ((CRefTime *)&AMTimeEnd)->Millisecs()
                ));
#endif
        }
        else
        {
            dTime = (double)RtpGetTime();
            
            if (iFreqChange)
            {
                /* If changing frequency, adjust the random timestamp
                 * offset to compensate for the timestamp jump. A
                 * forward jump when passing from lower -> higher
                 * frequency, and a backwards jump when passing from
                 * higher -> lower frequency */
                
                pRtpAddr->RtpNetSState.dwTimeStampOffset += (DWORD)
                    (dTime * iFreqChange / 1000);
            }
            
             /* Generate the right timestamp based on the sampling
             * frequency and the RTP's relative elapsed time. It seems
             * that for audio the original timestamp (above code)
             * generates less jitter, but for video the original timestamp
             * has more jitter than the locally generated (this path). As
             * jitter is more noticeble in audio, use by default the above
             * path */
            dwTimeStamp = (DWORD)
                ( dTime *
                  pRtpAddr->RtpNetSState.dwSendSamplingFreq /
                  1000.0 );
        }
    }
    
    dwNumBuf = 0;
    hr = NOERROR;
    
    if (m_bCapture)
    {
        /* Capture data */

        /* decide if using PDs (this happens only with video) */
        CBasePin *pCBasePinPD;

        pCBasePinPD = m_pCRtpRenderFilter->GetPin(1);

        if (pCBasePinPD->IsConnected())
        {
            /* Save video data to be used later when the packetization
             * descriptor is available */
            pIMediaSample->AddRef();
            m_pCRtpRenderFilter->PutMediaSample(pIMediaSample);
        }
        else
        {
            /* Decide if redundant encoding is in place */
            if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_REDSEND) &&
                pRtpAddr->RtpNetSState.dwNxtRedDistance)
            {
                /* Redundancy is used if enabled and the current
                 * redundancy distance is greater than zero. If the
                 * distance is zero (default at the begining), that
                 * means there are not enough losses to trigger the
                 * use of redundancy */

                RtpBitSet(dwSendFlags, FGSEND_USERED);
            }
            
            /* send the data now */
            /* Payload data */
            wsaBuf[1].len = pIMediaSample->GetActualDataLength();

            pIMediaSample->GetPointer((unsigned char **)&wsaBuf[1].buf);

            /* TODO when doing async I/O, the sample will need to be addref
               and released when the overlapped I/O completes */

            /* IsDiscontinuity returns S_OK if the sample is a
             * discontinuous sample, or S_FALSE if not; otherwise,
             * returns an HRESULT error value */
            if (pIMediaSample->IsDiscontinuity() == S_OK)
            {
                pRtpAddr->RtpNetSState.bMarker = 1;

                if (RtpBitTest(dwSendFlags, FGSEND_USERED))
                {
                    m_pCRtpRenderFilter->ClearRedundantSamples();
                }
            }
            else
            {
                pRtpAddr->RtpNetSState.bMarker = 0;
            }
   
            hr = RtpSendTo(pRtpAddr, wsaBuf, 2, dwTimeStamp, dwSendFlags);

            if (RtpBitTest(dwSendFlags, FGSEND_USERED))
            {
                /* Save this sample, we only hold a small number of
                 * the last recently used ones, the oldest may be
                 * removed and  released */
                m_pCRtpRenderFilter->AddRedundantSample(pIMediaSample);
            }
        }
    }
    else
    {
        /* Got RTP packetization descriptor, send now */
        
        pIMediaSample->GetPointer((unsigned char **)&pHdr);
        pRtpPDHdr = (RTP_PD_HEADER *)pHdr;
        
        pIMediaSampleData = m_pCRtpRenderFilter->GetMediaSample();

        if (pIMediaSampleData)
        {
            /* get stored sample */
            pIMediaSampleData->GetPointer((unsigned char **)&pData);

            dwNumBlocks = pRtpPDHdr->dwNumHeaders;

            pRtpPD = (RTP_PD *)(pRtpPDHdr + 1);
            
            /* generate packets */
            for(; dwNumBlocks; dwNumBlocks--, pRtpPD++)
            {
                /* get data sample, read PD and
                 * send as many packets as needed */
                wsaBuf[1].len = pRtpPD->dwPayloadHeaderLength;
                wsaBuf[1].buf = pHdr + pRtpPD->dwPayloadHeaderOffset;

                wsaBuf[2].len = (pRtpPD->dwPayloadEndBitOffset / 8) -
                    (pRtpPD->dwPayloadStartBitOffset / 8) + 1;
                wsaBuf[2].buf = pData + (pRtpPD->dwPayloadStartBitOffset / 8);

                if (pRtpPD->fEndMarkerBit)
                {
                    pRtpAddr->RtpNetSState.bMarker = 1;
                }
                else
                {
                    pRtpAddr->RtpNetSState.bMarker = 0;
                }
            
                hr = RtpSendTo(pRtpAddr, wsaBuf, 3, dwTimeStamp, dwSendFlags);
            }
        
            /* release stored sample */
            pIMediaSampleData->Release();

            /* TODO need to be able to store a list of samples */
        }
        else
        {
            TraceRetail((
                    CLASS_WARNING, GROUP_DSHOW, S_DSHOW_RENDER,
                    _T("%s: m_pFilter[0x%p] failed: ")
                    _T("packetization info but no sample to deliver"),
                    _fname, m_pFilter
                ));
        }
    }

    if (FAILED(hr))
    {
        /*
         * WARNING:
         *
         * Do not report failures to capture as it may stop producing
         * samples
         * */

        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: m_pFilter[0x%p] failed: %u (0x%X)"),
                _fname, m_pFilter, hr, hr
            ));
        
        hr = NOERROR;
    }
    
    return(hr);
}

/**********************************************************************
 *
 * RTP Render Filter class implementation: CRtpRenderFilter
 *
 **********************************************************************/

/*
 * CRtpRenderFilter constructor
 * */
CRtpRenderFilter::CRtpRenderFilter(LPUNKNOWN pUnk, HRESULT *phr)
    :
    CBaseFilter(
            _T("CRtpRenderFilter"), 
            pUnk, 
            &m_cRtpRndCritSec, 
            __uuidof(MSRTPRenderFilter)
        ),

    CIRtpSession(
            pUnk,
            phr,
            RtpBitPar(FGADDR_IRTP_ISSEND)),

    m_dwDtmfId(NO_DW_VALUESET),
    m_bDtmfEnd(FALSE)
{
    HRESULT          hr;
    int              i;
    long             lMaxFilter;
    
    TraceFunctionName("CRtpRenderFilter::CRtpRenderFilter");

    m_pCIRtpSession = static_cast<CIRtpSession *>(this);

    /* Test for NULL pointers, do not test pUnk which may be NULL */
    if (!phr)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: CRtpRenderFilter[0x%p] has phr NULL"),
                _fname, this
            ));
        
        /* TODO this is a really bad situation, we can not pass any
         * error and the memory is allocated, this will be fixed when
         * I find out how to validate this parameters before
         * allocating memory in the overriden new */

        phr = &hr; /* Use this pointer instead */
    }

    *phr = NOERROR;

    lMaxFilter = InterlockedIncrement(&g_RtpContext.lNumRenderFilter);
    if (lMaxFilter > g_RtpContext.lMaxNumRenderFilter)
    {
        g_RtpContext.lMaxNumRenderFilter = lMaxFilter;
    }

    SetBaseFilter(this);
 
    m_dwObjectID = OBJECTID_RTPRENDER;

    m_iPinCount = 2;

    /*
     * Create input pins
     * */

    for(i = 0; i < m_iPinCount; i++)
    {
        m_pCRtpInputPin[i] = (CRtpInputPin *)NULL;
    }
    
    for(i = 0; i < m_iPinCount; i++)
    {
        /* TODO pins are created whenever a new address is added */
        m_pCRtpInputPin[i] = (CRtpInputPin *)
            new CRtpInputPin(i,
                             (i & 1)? FALSE : TRUE, /* bCapture */
                             this,
                             m_pCIRtpSession,
                             phr,
                             (i & 1)? L"RtpPd" : L"Capture");
    
        if (FAILED(*phr))
        {
            /* pass up the same returned error */
            goto bail;
        }

        if (!m_pCRtpInputPin[i])
        {
            /* low in memory, failed to create object */
            *phr = E_OUTOFMEMORY;
            goto bail;
        }
    }

#if USE_GRAPHEDT > 0
    /* When using graphedt, initialize automatically, the coockie can
     * be NULL as a global variable will be shared between source and
     * render */
    *phr = m_pCIRtpSession->Init(NULL, RtpBitPar2(RTPINITFG_AUTO, RTPINITFG_QOS));
    
    if (FAILED(*phr))
    {
        /* pass up the same returned error */
        goto bail;
    }

#endif /* USE_GRAPHEDT > 0 */
    
    *phr = NOERROR;
    
    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
            _T("%s: CRtpRenderFilter[0x%p] CIRtpSession[0x%p] created"),
            _fname, this, static_cast<CIRtpSession *>(this)
        ));
    
    return;
    
 bail:
    Cleanup();
}

/*
 * CRtpRenderFilter destructor
 * */
CRtpRenderFilter::~CRtpRenderFilter()
{
    RtpAddr_t       *pRtpAddr;
    
    TraceFunctionName("CRtpRenderFilter::~CRtpRenderFilter");

    if (m_dwObjectID != OBJECTID_RTPRENDER)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: CRtpRenderFilter[0x%p] ")
                _T("Invalid object ID 0x%X != 0x%X"),
                _fname, this,
                m_dwObjectID, OBJECTID_RTPRENDER
            ));

        return;
    }

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
            _T("%s: CRtpRenderFilter[0x%p] CIRtpSession[0x%p] being deleted..."),
            _fname, this, static_cast<CIRtpSession *>(this)
        ));
    
    if (m_RtpFilterState == State_Running)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: CRtpRenderFilter[0x%p] being deleted ")
                _T("while still running"),
                _fname, this
            ));
        
        Stop();
    }
     
    pRtpAddr = m_pCIRtpSession->GetpRtpAddr();

    if (pRtpAddr &&
        RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_PERSISTSOCKETS))
    {
        RtpStop(pRtpAddr->pRtpSess,
                RtpBitPar2(FGADDR_ISSEND, FGADDR_FORCESTOP));
    }
    
    Cleanup();

    InterlockedDecrement(&g_RtpContext.lNumRenderFilter);

    m_pCIRtpSession = (CIRtpSession *)NULL;

    INVALIDATE_OBJECTID(m_dwObjectID);
}

void CRtpRenderFilter::Cleanup(void)
{
    int              i;

    TraceFunctionName("CRtpRenderFilter::Cleanup");

    for(i = 0; i < 2; i++)
    {
        if (m_pCRtpInputPin[i])
        {
            delete m_pCRtpInputPin[i];
            m_pCRtpInputPin[i] = (CRtpInputPin *)NULL;
        }
    }
    
    FlushFormatMappings();
}

void *CRtpRenderFilter::operator new(size_t size)
{
    void            *pVoid;
    
    TraceFunctionName("CRtpRenderFilter::operator new");

    MSRtpInit2();
    
    pVoid = RtpHeapAlloc(g_pRtpRenderHeap, size);

    if (pVoid)
    {
        ZeroMemory(pVoid, size);
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: failed to allocate memory:%u"),
                _fname, size
            ));

        /* On low memory failure, the destructor will not be called,
         * so decrese the reference count that was increased above */
        MSRtpDelete2(); 
    }
    
    return(pVoid);
}

void CRtpRenderFilter::operator delete(void *pVoid)
{
    if (pVoid)
    {
        RtpHeapFree(g_pRtpRenderHeap, pVoid);

        /* Reduce the reference count only for objects that got
         * memory, those that failed to obtain memory do not increase
         * the counter */
        MSRtpDelete2();
    }
}

/*
 * Create a CRtpRenderFilter instance (for active movie class factory)
 * */
CUnknown *CRtpRenderFilterCreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    /* Test for NULL pointers, do not test pUnk which may be NULL */
    if (!phr)
    {
        return((CUnknown *)NULL);
    }

    *phr = NOERROR;
    
    /* On failure during the constructor, the caller is responsible to
     * delete the object (that is consistent with DShow) */
    CRtpRenderFilter *pCRtpRenderFilter = new CRtpRenderFilter(pUnk, phr);

    if (!pCRtpRenderFilter)
    {
        *phr = RTPERR_MEMORY; 
    }

    return(pCRtpRenderFilter);
}

/**************************************************
 * CBaseFilter overrided methods
 **************************************************/

/*
 * Get the number of input pins
 * */
int CRtpRenderFilter::GetPinCount()
{
    /* WARNING: Only used for DShow's benefit */
    
    /* object lock on filter object */
    CAutoLock LockThis(&m_cRtpRndCritSec);

    /* TODO must go into RtpAddrQ and find out how many items exist in
     * that queue owned by RtpSess_t */
    /* return count */
    return(m_iPinCount);
}

/*
 * Get a reference to the nth pin
 * */
CBasePin *CRtpRenderFilter::GetPin(int n)
{
    /* WARNING: Only used for DShow's benefit */
    
    /* object lock on filter object */
    CAutoLock LockThis(&m_cRtpRndCritSec);

    /* TODO scan list and retrieve the nth element, check there exist at
     * least that many pins */
    if (n < 0 || n >= m_iPinCount) {
        return((CBasePin *)NULL);
    }

    return(m_pCRtpInputPin[n]);
}

STDMETHODIMP CRtpRenderFilter::Run(REFERENCE_TIME tStart)
{
    HRESULT          hr;
    RtpSess_t       *pRtpSess;
    RtpAddr_t       *pRtpAddr;
    
    TraceFunctionName("CRtpRenderFilter::Run");

    if (m_RtpFilterState == State_Running)
    {
        /* Alredy running, do nothing but call base class */
        hr = CBaseFilter::Run(tStart);

        return(hr);
    }

    hr = NOERROR;

    if (!m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        return(RTPERR_NOTINIT);
    }
    
    /* MAYDO when we have multiple addresses, there should be a way to
     * assign to each pin an address */

    pRtpSess = m_pCIRtpSession->GetpRtpSess();
    pRtpAddr = m_pCIRtpSession->GetpRtpAddr();

    if (pRtpSess && pRtpAddr)
    {
        RTPASSERT(pRtpAddr && pRtpAddr->pRtpSess == pRtpSess);
    }
    else
    {
        hr = RTPERR_INVALIDSTATE;
        
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: failed: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("null session or address"),
                _fname, pRtpSess, pRtpAddr
            ));
    }
    
    /* Call base class */
    if (SUCCEEDED(hr))
    {
        hr = CBaseFilter::Run(tStart); /* will call CBasePin::Run in
                                        * all filters */
    }
    
    /* Initialize sockets and start worker thread */
    if (SUCCEEDED(hr))
    {
        pRtpAddr->RtpNetSState.bPT = (BYTE)m_dwPT;
        pRtpAddr->RtpNetSState.dwSendSamplingFreq = m_dwFreq;

        if (RtpBitTest(m_dwFeatures, RTPFEAT_GENTIMESTAMP))
        {
            RtpBitSet(pRtpSess->dwFeatureMask, RTPFEAT_GENTIMESTAMP);
        }
        else
        {
            RtpBitReset(pRtpSess->dwFeatureMask, RTPFEAT_GENTIMESTAMP);
        }
        if (RtpBitTest(m_dwFeatures, RTPFEAT_PASSHEADER))
        {
            RtpBitSet(pRtpSess->dwFeatureMask, RTPFEAT_PASSHEADER);
        }
        else
        {
            RtpBitReset(pRtpSess->dwFeatureMask, RTPFEAT_PASSHEADER);
        }
        
        hr = RtpStart(pRtpSess, RtpBitPar(FGADDR_ISSEND));

        if (SUCCEEDED(hr))
        {
            m_RtpFilterState = State_Running;
        }
    }
    
    return(hr);
}

STDMETHODIMP CRtpRenderFilter::Stop()
{
    HRESULT          hr;
    HRESULT          hr2;
    RtpSess_t       *pRtpSess;
    IMediaSample    *pIMediaSample;
    
    if (m_RtpFilterState == State_Stopped)
    {
        /* Alredy stopped, do nothing but call base class */
        hr2 = CBaseFilter::Stop();

        pIMediaSample = GetMediaSample();

        if (pIMediaSample)
        {
            /* release stored sample */
            pIMediaSample->Release();
        }
    
        return(hr2);
    }

    if (!m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        hr = RTPERR_NOTINIT;
        
        goto end;
    }

    pRtpSess = m_pCIRtpSession->GetpRtpSess();

    if (pRtpSess)
    {
        hr = RtpStop(pRtpSess, RtpBitPar(FGADDR_ISSEND));
    }
    else
    {
        hr = RTPERR_INVALIDSTATE;
    }

 end:
    /* Call base class */
    hr2 = CBaseFilter::Stop(); /* will decommit */

    if (SUCCEEDED(hr))
    {
        hr = hr2;
    }

    pIMediaSample = GetMediaSample();

    if (pIMediaSample)
    {
        /* release stored sample */
        pIMediaSample->Release();
    }
    
    ClearRedundantSamples();
    
    m_RtpFilterState = State_Stopped;
   
    return(hr);
}


/**************************************************
 * INonDelegatingUnknown implemented methods
 **************************************************/

/* obtain pointers to active movie and private interfaces */
STDMETHODIMP CRtpRenderFilter::NonDelegatingQueryInterface(
        REFIID riid,
        void **ppv
    )
{
    HRESULT hr;
    
    if (riid == __uuidof(IRtpMediaControl))
    {
        return GetInterface(static_cast<IRtpMediaControl *>(this), ppv);
    }
    else if (riid == IID_IAMFilterMiscFlags) 
    {
        return GetInterface((IAMFilterMiscFlags *)this, ppv);
    } 
    else if (riid == __uuidof(IRtpSession))
    {
        return GetInterface(static_cast<IRtpSession *>(this), ppv);  
    }
    else if (riid == __uuidof(IRtpDtmf))
    {
        return GetInterface(static_cast<IRtpDtmf *>(this), ppv);
    }
    else if (riid == __uuidof(IRtpRedundancy))
    {
        return GetInterface(static_cast<IRtpRedundancy *>(this), ppv);
    }
    else
    {
        hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }

    return(hr);
}

/**************************************************
 * IRtpMediaControl implemented methods
 **************************************************/

/* set the mapping between RTP payload and DShow media types */
STDMETHODIMP CRtpRenderFilter::SetFormatMapping(
	    IN DWORD         dwRTPPayLoadType, 
        IN DWORD         dwFrequency,
        IN AM_MEDIA_TYPE *pMediaType
    )
{
    DWORD            dw;

    TraceFunctionName("CRtpRenderFilter::SetFormatMapping");

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    if (!pMediaType)
    {
        return(RTPERR_POINTER);
    }
    
    CAutoLock Lock( &m_cRtpRndCritSec );
    
    for (dw = 0; dw < m_dwNumMediaTypeMappings; dw ++)
    {
        if ( (m_MediaTypeMappings[dw].pMediaType->majortype ==
              pMediaType->majortype)  &&
             (m_MediaTypeMappings[dw].pMediaType->subtype ==
              pMediaType->subtype) &&
              m_MediaTypeMappings[dw].dwFrequency == dwFrequency)
        {
            // the media type is known, update the payload type to be used.
            m_MediaTypeMappings[dw].dwRTPPayloadType = dwRTPPayLoadType;
            return NOERROR;
        }
    }

    if (dw >= MAX_MEDIATYPE_MAPPINGS)
    {
        // we don't have space for more mappings.
        return RTPERR_RESOURCES;
    }

    // This is a new mapping. remember it.
    m_MediaTypeMappings[dw].pMediaType = new CMediaType(*pMediaType);
    if (m_MediaTypeMappings[dw].pMediaType == NULL)
    {
        return RTPERR_MEMORY;
    }
    m_MediaTypeMappings[dw].dwRTPPayloadType = dwRTPPayLoadType;
    m_MediaTypeMappings[dw].dwFrequency = dwFrequency;

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
            _T("%s: CRtpRenderFilter[0x%p] New mapping[%u]: ")
            _T("PT:%u Frequency:%u"),
            _fname, this,
            m_dwNumMediaTypeMappings, dwRTPPayLoadType, dwFrequency
        ));
    
    m_dwNumMediaTypeMappings++;

    return NOERROR;
}

/* Empties the format mapping table */
STDMETHODIMP CRtpRenderFilter::FlushFormatMappings(void)
{
    DWORD            dw;
    
    CAutoLock Lock( &m_cRtpRndCritSec );

    for (dw = 0; dw < m_dwNumMediaTypeMappings; dw ++)
    {
        if (m_MediaTypeMappings[dw].pMediaType)
        {
            delete m_MediaTypeMappings[dw].pMediaType;
            m_MediaTypeMappings[dw].pMediaType = NULL;
        }
    }

    m_dwNumMediaTypeMappings = 0;
    
    return(NOERROR);
}

/* Get RTP payload type and sampling frequency from the mediatype */
HRESULT CRtpRenderFilter::MediaType2PT(
        IN const CMediaType *pCMediaType, 
        OUT DWORD           *pdwPT,
        OUT DWORD           *pdwFreq
    )
{
    HRESULT          hr;
    
    TraceFunctionName("CRtpRenderFilter::MediaType2PT");

    ASSERT(!IsBadWritePtr(pdwPT, sizeof(DWORD)));
    ASSERT(!IsBadWritePtr(pdwFreq, sizeof(DWORD)));

    CAutoLock Lock( &m_cRtpRndCritSec );
    
#if USE_GRAPHEDT <= 0
    DWORD dw;

    m_dwPT = 96;
    m_dwFreq = 8000;
    hr = S_FALSE;
    
    for (dw = 0; dw < m_dwNumMediaTypeMappings; dw ++)
    {
        if (m_MediaTypeMappings[dw].pMediaType->majortype ==
            pCMediaType->majortype
            &&
            m_MediaTypeMappings[dw].pMediaType->subtype ==
            pCMediaType->subtype)
        {

            if (pCMediaType->formattype == FORMAT_WaveFormatEx)
            {
                // we need to do an additional check for audio formats
                // because some audio formats have the same guid but
                // different frequency. (DVI4)
                WAVEFORMATEX *pWaveFormatEx = (WAVEFORMATEX *)
                    pCMediaType->pbFormat;
                ASSERT(!IsBadReadPtr(pWaveFormatEx, pCMediaType->cbFormat));

                if (pWaveFormatEx->nSamplesPerSec !=
                    m_MediaTypeMappings[dw].dwFrequency)
                {
                    // this is not the one. try next one.
                    continue;
                }
            }
            
            m_dwPT = m_MediaTypeMappings[dw].dwRTPPayloadType;

            m_dwFreq = m_MediaTypeMappings[dw].dwFrequency;

            hr = NOERROR;

            break;
        }
    }
#else /* USE_GRAPHEDT <= 0 */
    hr = NOERROR;
    
    if (pCMediaType->subtype == MEDIASUBTYPE_RTP_Payload_G711U)
    {
        m_dwPT = RTPPT_PCMU;
        m_dwFreq = 8000;
    }
    else if (pCMediaType->subtype == MEDIASUBTYPE_RTP_Payload_G711A)
    {
        m_dwPT = RTPPT_PCMA;
        m_dwFreq = 8000;
    }
    else if (pCMediaType->subtype == MEDIASUBTYPE_RTP_Payload_G723)
    {
        m_dwPT = RTPPT_G723;
        m_dwFreq = 8000;
    }
    else if (pCMediaType->subtype == MEDIASUBTYPE_H261)
    {
        m_dwPT = RTPPT_H261;
        m_dwFreq = 90000;
    }
    else if ( (pCMediaType->subtype == MEDIASUBTYPE_H263_V1) ||
                (pCMediaType->subtype == MEDIASUBTYPE_H263_V2) ||
              (pCMediaType->subtype == MEDIASUBTYPE_RTP_Payload_H263) )
    {
        m_dwPT = RTPPT_H263;
        m_dwFreq = 90000;
    }
    else
    {
        m_dwPT = 96; /* a dynamic PT */
        m_dwFreq = 8000;
        hr = S_FALSE;
    }
    
#endif /* USE_GRAPHEDT <= 0 */

    if (hr == NOERROR)
    {
        TraceRetail((
                CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: CRtpRenderFilter[0x%p]: PT:%u Frequency:%u"),
                _fname, this, m_dwPT, m_dwFreq
            ));
    }
    else
    {
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: CRtpRenderFilter[0x%p]: No mapping found, ")
                _T("using default: PT:%u Frequency:%u"),
                _fname, this, m_dwPT, m_dwFreq
            ));
    }
    
    if (pdwPT)
    {
        *pdwPT = m_dwPT;
    }
    
    if (pdwFreq)
    {
        *pdwFreq = m_dwFreq;
    }

    return(hr);
}

/**************************************************
 * IAMFilterMiscFlags implemented methods
 **************************************************/
STDMETHODIMP_(ULONG) CRtpRenderFilter::GetMiscFlags(void)
/*++
  Routine Description:

  Implement the IAMFilterMiscFlags::GetMiscFlags method. Retrieves the
  miscelaneous flags. This consists of whether or not the filter moves
  data out of the graph system through a Bridge or None pin.

  Arguments:

  None.
  --*/
{
    return(AM_FILTER_MISC_FLAGS_IS_RENDERER);
}

/**************************************************
 * IRtpDtmf implemented methods
 **************************************************/

/* Configures DTMF parameters */
STDMETHODIMP CRtpRenderFilter::SetDtmfParameters(
        DWORD            dwPT_Dtmf  /* Payload type for DTMF events */
    )
{
    HRESULT          hr;

    TraceFunctionName("CRtpRenderFilter::SetDtmfParameters");  

    hr = RTPERR_NOTINIT;
    
    if (m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetDtmfParameters(m_pRtpAddr, dwPT_Dtmf);
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }
    
    return(hr);
}

/* Directs an RTP render filter to send a packet formatted
 * according to rfc2833 containing the specified event, specified
 * volume level, duration in milliseconds, and the END flag,
 * following the rules in section 3.6 for events sent in multiple
 * packets. Parameter dwId changes from one digit to the next one.
 *
 * NOTE the duration is given in milliseconds, then it is
 * converted to RTP timestamp units which are represented using 16
 * bits, the maximum value is hence dependent on the sampling
 * frequency, but for 8KHz the valid values would be 0 to 8191 ms
 * */
STDMETHODIMP CRtpRenderFilter::SendDtmfEvent(
        DWORD            dwId,
        DWORD            dwEvent,
        DWORD            dwVolume,
        DWORD            dwDuration,
        BOOL             bEnd
    )
{
    HRESULT          hr;
    DWORD            dwSamplingFreq;
    DWORD            dwDtmfFlags;
    REFERENCE_TIME   CurrentTime;
    IReferenceClock *pClock;
    
    TraceFunctionName("CRtpRenderFilter::SendDtmfEvent");  

    hr = RTPERR_NOTINIT;
    
    if (m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        dwDtmfFlags = 0;

        if (bEnd)
        {
            dwDtmfFlags |= RtpBitPar(FGDTMF_END);
        }
        
        if (m_dwDtmfId != dwId)
        {
            /* I have the beginning of a new digit */
            m_dwDtmfId = dwId;

            /* First packet must have marker bit set */
            dwDtmfFlags |= RtpBitPar(FGDTMF_MARKER);
            
            m_dwDtmfDuration = dwDuration;

            m_bDtmfEnd = FALSE;
            
            /* Compute initial timestamp */

            hr = RTPERR_FAIL;
        
            m_dwDtmfTimeStamp = 0;

            if (m_pClock)
            {
                hr = m_pClock->GetTime(&CurrentTime);

                if (SUCCEEDED(hr))
                {
                    CurrentTime -= m_tStart;
                    
                    m_dwDtmfTimeStamp = (DWORD)
                        ( ConvertToMilliseconds(CurrentTime) *
                          m_pRtpAddr->RtpNetSState.dwSendSamplingFreq / 1000 );
                }
            }

            if (FAILED(hr))
            {
                /* Alternate timestamp generation */
                m_dwDtmfTimeStamp = (DWORD)
                    ( timeGetTime() *
                      m_pRtpAddr->RtpNetSState.dwSendSamplingFreq / 1000 );

                hr = NOERROR;
            }
        }
        else
        {
            /* Succesive packets for the same digit, update duration */

            if (!m_bDtmfEnd)
            {
                /* Increase duration for all the request that have the
                 * bit end set to 0 and the first one with bit end set
                 * to 1 */
                m_dwDtmfDuration += dwDuration;
            }
        }
        
        if (!m_bDtmfEnd && bEnd)
        {
            /* Prevent advancing the duration if more packets are to
             * be sent with the bit end set to 1 */
            m_bDtmfEnd = TRUE;
        }
        
        /* Get sender's sampling frequency from the Capture pin, not
         * from the RtpPD pin */
        dwSamplingFreq = m_pCRtpInputPin[0]->GetSamplingFreq();

        /* Convert duration from milliseconds to timestamp units */
        dwDuration = m_dwDtmfDuration * dwSamplingFreq / 1000;

        hr = RtpSendDtmfEvent(m_pRtpAddr, m_dwDtmfTimeStamp,
                              dwEvent, dwVolume, dwDuration, dwDtmfFlags);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }
    else
    {
        TraceDebug((
                CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("ID:%X timestamp:%u event:%u vol:%u duration:%u, end:%u"),
                _fname, m_pRtpSess, m_pRtpAddr,
                dwId, m_dwDtmfTimeStamp, dwEvent, dwVolume, dwDuration, bEnd
            ));
    }
    
    return(hr);
}

/**************************************************
 * IRtpRedundancy implemented methods
 **************************************************/

/* Configures redundancy parameters */
STDMETHODIMP CRtpRenderFilter::SetRedParameters(
        DWORD            dwPT_Red, /* Payload type for redundant packets */
        DWORD            dwInitialRedDistance,/* Initial redundancy distance*/
        DWORD            dwMaxRedDistance /* default used when passing 0 */
    )
{
    HRESULT          hr;

    TraceFunctionName("CRtpRenderFilter::SetRedParameters");  

    hr = RTPERR_NOTINIT;
    
    if (m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetRedParameters(m_pRtpAddr,
                                 RtpBitPar(SEND_IDX),
                                 dwPT_Red,
                                 dwInitialRedDistance,
                                 dwMaxRedDistance);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }
    
    return(hr);
}


/**************************************************
 * Methods for IRtpRedundancy support
 **************************************************/

/* Store and AddRef() a sample for later use as redundance, if the LRU
 * entry is busy, Release() it, then store the new sample */
STDMETHODIMP CRtpRenderFilter::AddRedundantSample(
        IMediaSample    *pIMediaSample
    )
{
    HRESULT          hr;

    hr = RTPERR_POINTER;
    
    if (pIMediaSample)
    {
        pIMediaSample->AddRef();

        if (m_pRedMediaSample[m_dwRedIndex])
        {
            /* Release old sample */
            m_pRedMediaSample[m_dwRedIndex]->Release();
        }

        m_pRedMediaSample[m_dwRedIndex] = pIMediaSample;

        /* Advance index */
        m_dwRedIndex = (m_dwRedIndex + 1) % RTP_RED_MAXDISTANCE;

        hr = NOERROR;
    }
    
    return(hr);
}

STDMETHODIMP CRtpRenderFilter::ClearRedundantSamples(void)
{
    DWORD            i;

    for(i = 0; i < RTP_RED_MAXDISTANCE; i++)
    {
        if (m_pRedMediaSample[i])
        {
            m_pRedMediaSample[i]->Release();

            m_pRedMediaSample[i] = NULL;
        }
    }

    m_dwRedIndex = 0;
    
    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\gtypes.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    gtypes.h
 *
 *  Abstract:
 *
 *    This file contains all the basic types used in RTP, either
 *    defined here, or included from other files. E.g. DWORD, BYTE,etc
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#ifndef _gtypes_h_
#define _gtypes_h_

#include <wtypes.h>
#include <windef.h>
#include <winbase.h>
#include <crtdbg.h>
#include <tchar.h>
#if !defined(UNICODE)
#include <stdio.h>
#endif
#include "rtptags.h"
#include "rtpdbg.h"
#include "rtperr.h"
#include "msrtp.h"

/* Relates to receiver or sender */
#define RECV_IDX          0
#define SEND_IDX          1
#define RECVSENDMASK    0x1

/* Relates to local or remote */
#define LOCAL_IDX         0
#define REMOTE_IDX        1
#define LOCALREMOTEMASK 0x1

/* Relates to RTP or RTCP */
#define RTP_IDX           0
#define RTCP_IDX          1
#define RTPRTCPMASK     0x1

/* Sockets */
#define SOCK_RECV_IDX     0
#define SOCK_SEND_IDX     1
#define SOCK_RTCP_IDX     2

/* Cryptography descriptors */
#define CRYPT_RECV_IDX    0
#define CRYPT_SEND_IDX    1
#define CRYPT_RTCP_IDX    2

/* Some functions receive a DWORD with flags, use this macro instead
 * of 0 when no flags are passed */
#define NO_FLAGS          0

/* Some functions receive a DWORD with a wait time, use this macro
 * instead of 0 when no wait is desired */
#define DO_NOT_WAIT        0
#define DO_NOT_SYNCHRONIZE_CMD 0

/* A DWORD value is not set */
#define NO_DW_VALUESET    ((DWORD)~0)
#define IsDWValueSet(dw)  ((dw) != NO_DW_VALUESET)

/* builds a mask of bit b */
#define RtpBitPar(b)            (1 << (b))
#define RtpBitPar2(b1, b2)      ((1 << (b1)) | (1 << (b2)))

/* test bit b in f */
#define RtpBitTest(f, b)        (f & (1 << (b)))
#define RtpBitTest2(f, b1, b2)  (f & RtpBitPar2(b1, b2))

/* set bit b in f */
#define RtpBitSet(f, b)         (f |= (1 << (b)))
#define RtpBitSet2(f, b1, b2)   (f |= RtpBitPar2(b1, b2))

/* reset bit b in f */
#define RtpBitReset(f, b)       (f &= ~(1 << (b)))
#define RtpBitReset2(f, b1, b2) (f &= ~RtpBitPar2(b1, b2))

#define RtpBuildIPAddr(a, b, c ,d) \
        (((a) << 24) | ((b) << 16) | ((c) << 8) | (d))

#define IS_MULTICAST(addr) (((long)(addr) & 0x000000f0) == 0x000000e0)
#define IS_UNICAST(addr)   (((long)(addr) & 0x000000f0) != 0x000000e0)

/* Returns a pointer-size aligned size */
#define RTP_ALIGNED_SIZE(_size) \
        (((_size) + sizeof(void *) - 1) & ~(sizeof(void *) - 1))

/* Returns a pointer-size aligned size of the size of a type */
#define RTP_ALIGNED_SIZEOF(_type) RTP_ALIGNED_SIZE(sizeof(_type))


typedef struct _RtpTime_t {
    DWORD            dwSecs;          /* seconds since Jan. 1, 1970 */
    DWORD            dwUSecs;         /* and microseconds */
} RtpTime_t;

typedef unsigned int  uint_t;        /* prefix variables with "ui" */
typedef unsigned long ulong_t;       /* prefix variables with "ul" */
typedef BOOL          bool_t;        /* prefix variables with "b" */
typedef TCHAR         tchar_t;       /* prefix variables with "t" */
typedef TCHAR         TCHAR_t;

/* Gets the offset to a field in a structure.
 *
 * E.g DWORD OffToDwAddrFlags = RTPSTRUCTOFFSET(RtpAddr_t, dwAddrFlags); */
#define RTPSTRUCTOFFSET(_struct_t, _field) \
        ((DWORD) ((ULONG_PTR) &((_struct_t *)0)->_field))

/* Gets a (DWORD *) from a structure pointer and an offset
 *
 * E.g. DWORD *pdw = RTPDWORDPTR(pRtpAddr, 64); */
#define RTPDWORDPTR(_pAny_t, _offset) \
        ((DWORD *) ((char *)_pAny_t + _offset))

const TCHAR_t *g_psRtpRecvSendStr[];

const TCHAR_t *g_psRtpStreamClass[];

const TCHAR_t *g_psGetSet[];

#define RTPRECVSENDSTR(_RecvSend) (g_psRtpRecvSendStr[_RecvSend & 0x1])

#define RTPSTREAMCLASS(_class)    (g_psRtpStreamClass[_class & 0x3])

#endif /* _gtypes_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\dsrtp\src\dsrtp.cpp ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    dsrtp.cpp
 *
 *  Abstract:
 *
 *    DShow  RTP templates and entry point
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/17 created
 *
 **********************************************************************/
#include <winsock2.h>

#include "classes.h"

#include "tapirtp.h"

#include <filterid.h>

#include <rtptempl.h>

#include "dsglob.h"

#include "msrtpapi.h"


/**********************************************************************
 *
 * DShow setup information
 *
 **********************************************************************/

/*
 * RTP Source
 */

#if USE_GRAPHEDT > 0

const AMOVIESETUP_MEDIATYPE g_RtpOutputType =
{
    &MEDIATYPE_RTP_Single_Stream,	        // clsMajorType
    &GUID_NULL	        // clsMinorType
}; 

const AMOVIESETUP_PIN g_RtpOutputPin =
{
    WRTP_PIN_OUTPUT,                        // strName
    FALSE,                                  // bRendered
    TRUE,                                   // bOutput
    FALSE,                                  // bZero
    FALSE,                                  // bMany
    &CLSID_NULL,                            // clsConnectsToFilter
    WRTP_PIN_ANY,                           // strConnectsToPin
    1,                                      // nTypes
    &g_RtpOutputType                        // lpTypes
};

const AMOVIESETUP_FILTER g_RtpSourceFilter =
{
    &__uuidof(MSRTPSourceFilter),           // clsID
    WRTP_SOURCE_FILTER,                     // strName
    MERIT_DO_NOT_USE,                       // dwMerit
    1,                                      // nPins
    &g_RtpOutputPin                         // lpPin
};                              

/*
 * RTP Render
 */

const AMOVIESETUP_MEDIATYPE g_RtpInputType =
{
    &MEDIATYPE_NULL,                        // Major type
    &MEDIASUBTYPE_NULL                      // Minor type
}; 

const AMOVIESETUP_PIN g_RtpInputPin =
{ 
    WRTP_PIN_INPUT,                         // strName
    FALSE,                                  // bRendered
    FALSE,                                  // bOutput
    FALSE,                                  // bZero
    TRUE,                                   // bMany
    &CLSID_NULL,                            // clsConnectsToFilter
    WRTP_PIN_ANY,                           // strConnectsToPin
    1,                                      // nTypes
    &g_RtpInputType                         // lpTypes
};

const AMOVIESETUP_FILTER g_RtpRenderFilter =
{ 
    &_uuidof(MSRTPRenderFilter),            // clsID
    WRTP_RENDER_FILTER,                     // strName
    MERIT_DO_NOT_USE,                       // dwMerit
    1,                                      // nPins
    &g_RtpInputPin                          // lpPin
};

#endif /* USE_GRAPHEDT > 0 */

#if DXMRTP <= 0

/**********************************************************************
 *
 * DShow templates
 *
 **********************************************************************/

CFactoryTemplate g_Templates[] =
{
    /* RTP Source */
    RTP_SOURCE_TEMPLATE,

    /* RTP Render */
    RTP_RENDER_TEMPLATE
};

int g_cTemplates = (sizeof(g_Templates)/sizeof(g_Templates[0]));

/**********************************************************************
 *
 * Filter Vendor Information
 *
 **********************************************************************/
const WCHAR g_RtpVendorInfo[] = WRTP_FILTER_VENDOR_INFO; 



/**********************************************************************
 *
 * Public procedures
 *
 **********************************************************************/

extern "C" BOOL WINAPI DllMain(HINSTANCE, ULONG, LPVOID);
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);

/**********************************************************************
 *
 *  Routine Description:
 *
 *    Wrapper around ActiveMovie DLL entry point.
 *
 *  Arguments:
 *
 *    Same as DllEntryPoint.   
 *
 *  Return Values:
 *
 *  Returns TRUE if successful.
 *
 **********************************************************************/

BOOL WINAPI DllMain(
        HINSTANCE hInstance, 
        ULONG     ulReason, 
        LPVOID    pv)
{
    BOOL    error;
    HRESULT hr;

    error = TRUE;
    
    switch(ulReason) {
    case DLL_PROCESS_ATTACH:
        /* RTP global initialization */
        hr = MSRtpInit1(hInstance);

        if (SUCCEEDED(hr)) {
            error = DllEntryPoint(hInstance, ulReason, pv);
        } else {
            error = FALSE;
        }        
        break;
    case DLL_PROCESS_DETACH:
        error = DllEntryPoint(hInstance, ulReason, pv);

        /* RTP global de-initialization */
        hr = MSRtpDelete1();

        if (FAILED(hr)) {
            error = FALSE;
        }
        
        break;
    default:
        ;
    }

    return(error);
}


/**********************************************************************
 *
 *  Routine Description:
 *
 *    Instructs an in-process server to create its registry entries
 *    for * all classes supported in this server module.
 *
 *  Arguments:
 *
 *    None.
 *
 *  Return Values:
 *
 *    NOERROR - The registry entries were created successfully.
 *
 *    E_UNEXPECTED - An unknown error occurred.
 *
 *    E_OUTOFMEMORY - There is not enough memory to complete the
 *    registration.
 *
 *    SELFREG_E_TYPELIB - The server was unable to complete the
 *    registration of all the type libraries used by its classes.
 *
 *    SELFREG_E_CLASS - The server was unable to complete the *
 *    registration of all the object classes.
 **********************************************************************/
HRESULT DllRegisterServer()
{
    // forward to amovie framework
    return AMovieDllRegisterServer2( TRUE );
}


/**********************************************************************
 *
 *  Routine Description:
 *
 *    Instructs an in-process server to remove only registry entries
 *    created through DllRegisterServer.
 *
 *  Arguments:
 *
 *    None.
 *
 *  Return Values:
 *
 *    NOERROR - The registry entries were created successfully.
 *
 *    S_FALSE - Unregistration of this server's known entries was
 *    successful, but other entries still exist for this server's
 *    classes.
 *
 *    E_UNEXPECTED - An unknown error occurred.
 *
 *    E_OUTOFMEMORY - There is not enough memory to complete the
 *    unregistration.
 *
 *    SELFREG_E_TYPELIB - The server was unable to remove the entries
 *    of all the type libraries used by its classes.
 *
 *    SELFREG_E_CLASS - The server was unable to remove the entries of
 *    all the object classes.
**********************************************************************/
HRESULT DllUnregisterServer()
{
    // forward to amovie framework
    return AMovieDllRegisterServer2( FALSE );
}

#endif /* DXMRTP <= 0 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\dsrtp\src\source.cpp ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    source.cpp
 *
 *  Abstract:
 *
 *    CRtpSourceFilter and CRtpOutputPin implementation
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#include <winsock2.h>

#include "classes.h"
#include "dsglob.h"
#include "rtpqos.h"
#include "rtpuser.h"
#include "rtppt.h"
#include "rtpdemux.h"
#include "rtprecv.h"
#include "rtpred.h"
#include "rtpaddr.h"

#include "tapirtp.h"
#include "dsrtpid.h"

#include "rtpglobs.h"
#include "msrtpapi.h"

/**********************************************************************
 * Callback function to process a packet arrival in a CRtpSourceFilter
 **********************************************************************/
void CALLBACK DsRecvCompletionFunc(
        void            *pvUserInfo1, /* pCRtpSourceFilter */
        void            *pvUserInfo2, /* pIMediaSample */
        void            *pvUserInfo3, /* pIPin of pCRtpOutputPin */
        RtpUser_t       *pRtpUser,
        double           dPlayTime,
        DWORD            dwError,
        long             lHdrSize,
        DWORD            dwTransfered,
        DWORD            dwFlags
    )
{
    CRtpSourceFilter *pCRtpSourceFilter;
    
    pCRtpSourceFilter = (CRtpSourceFilter *)pvUserInfo1;

    
    pCRtpSourceFilter->SourceRecvCompletion(
            (IMediaSample *)pvUserInfo2,
            pvUserInfo3,
            pRtpUser,
            dPlayTime,
            dwError,
            lHdrSize,
            dwTransfered,
            dwFlags
        );
}

/**********************************************************************
 *
 * RTP Output Pin class implementation: CRtpOutputPin
 *
 **********************************************************************/

/*
 * CRtpOutputPin constructor
 * */
CRtpOutputPin::CRtpOutputPin(CRtpSourceFilter *pCRtpSourceFilter,
                             CIRtpSession     *pCIRtpSession,
                             HRESULT          *phr,
                             LPCWSTR           pPinName)
    :    
    CBASEOUTPUTPIN(
            _T("CRtpOutputPin"),
            pCRtpSourceFilter,                   
            pCRtpSourceFilter->pStateLock(),                     
            phr,                       
            pPinName
        )
{
    m_dwObjectID = OBJECTID_RTPOPIN;
    
    m_pCRtpSourceFilter = pCRtpSourceFilter;
    
    m_pCIRtpSession = pCIRtpSession;
    
    m_bPT = NO_PAYLOADTYPE;

    m_bCanReconnectWhenActive = TRUE;

#if USE_GRAPHEDT > 0
      /* Temporary SetMediaType */
    m_iCurrFormat = -1;
#endif

    if (phr)
    {
        *phr = NOERROR;
    }
    
    /* TODO should fail if a valid filter and address are not passed */
}

/*
 * CRtpOutputPin destructor
 * */
CRtpOutputPin::~CRtpOutputPin()
{
    INVALIDATE_OBJECTID(m_dwObjectID);
}

void *CRtpOutputPin::operator new(size_t size)
{
    void            *pVoid;
    
    TraceFunctionName("CRtpOutputPin::operator new");

    pVoid = RtpHeapAlloc(g_pRtpSourceHeap, size);

    if (pVoid)
    {
        ZeroMemory(pVoid, size);
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed to allocate memory:%u"),
                _fname, size
            ));
    }
    
    return(pVoid);
}

void CRtpOutputPin::operator delete(void *pVoid)
{
    if (pVoid)
    {
        RtpHeapFree(g_pRtpSourceHeap, pVoid);
    }
}

/**************************************************
 * CBasePin overrided methods
 **************************************************/
#if USE_GRAPHEDT <= 0 /* Temporary SetMediaType (stmtype.cpp) */
/*
 * Verify we can handle this format
 * */
HRESULT CRtpOutputPin::CheckMediaType(const CMediaType *pCMediaType)
{
    if (m_bPT == NO_PAYLOADTYPE)
    {
        /* TODO: we might want to check against the list. */
        return(NOERROR);
    }

    if (m_mt != *pCMediaType)
    {
        /* We only accept one media type when the payload type is set. */
        return(VFW_E_INVALIDMEDIATYPE);
    }

    return(NOERROR);
}

/*
 * Get the media type delivered by the output pins
 * */
HRESULT CRtpOutputPin::GetMediaType(int iPosition, CMediaType *pCMediaType)
{
    HRESULT hr;
    
    hr = NOERROR;

    if (m_bPT == NO_PAYLOADTYPE)
    {
        hr = ((CRtpSourceFilter *)m_pFilter)->
            GetMediaType(iPosition, pCMediaType);
    }
    else
    {
        if (iPosition != 0)
        {
            return(VFW_S_NO_MORE_ITEMS);
        }

        /* Only return the current format */
        *pCMediaType = m_mt;
    }

    return(hr);
}
#endif /* USE_GRAPHEDT <= 0 */

/* The purpose of overriding this method is to enable the
 * corresponding output pin after it is connected */
STDMETHODIMP CRtpOutputPin::Connect(
        IPin            *pReceivePin,
        const AM_MEDIA_TYPE *pmt   // optional media type
    )
{
    HRESULT          hr;

    TraceFunctionName("CRtpOutputPin::Connect");
    
    CAutoLock cObjectLock(m_pLock);
    
    /* Call base class */
    hr = CBasePin::Connect(pReceivePin, pmt);

    if (SUCCEEDED(hr) && m_pRtpOutput)
    {
        /* Now enable the RTP output */
        RtpOutputEnable(m_pRtpOutput, TRUE);
    }

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
            _T("%s: pCRtpOutputPin[%p] pRtpOutput[%p] hr:%u"),
            _fname, this, m_pRtpOutput, hr
        ));
  
    return(hr);
}

/* The purpose of overriding this method is to allow the disconnection
 * while the filter is still running, and disable and unmap the RTP
 * output when this happens. */
STDMETHODIMP CRtpOutputPin::Disconnect()
{
    HRESULT          hr;
    
    TraceFunctionName("CRtpOutputPin::Disconnect");
    
    CAutoLock cObjectLock(m_pLock);

    /*
     * Do not check if the filter is active
     */
#if 0
    /* This code is here only for reference */
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }
#endif

    /* Disable the corresponding RTP output so it will not be selected
     * for another participant */
    if (m_pRtpOutput)
    {
        RtpOutputEnable(m_pRtpOutput, FALSE);
    }
    
    /* Unmapping is needed as the pin, once unmapped, might stay
     * disconnected. During that time it should not be mapped to
     * anyone */
    m_pCRtpSourceFilter->SetMappingState(
            -1,   /* Don't use index */
            static_cast<IPin *>(this),
            0,    /* Use whatever SSRC is currently mapped */
            FALSE /* Unmap */);
    
    hr = DisconnectInternal();
    
    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
            _T("%s: pCRtpOutputPin[%p] pRtpOutput[%p] hr:%u"),
            _fname, this, m_pRtpOutput, hr
        ));

    return(hr);
}

/**************************************************
 * CBaseOutputPin overrided methods
 **************************************************/

HRESULT CRtpOutputPin::DecideAllocator(
        IMemInputPin   *pPin,
        IMemAllocator **ppAlloc
    )
{
    HRESULT hr;
    ALLOCATOR_PROPERTIES prop;

    hr = NOERROR;
    *ppAlloc = NULL;

    /* Get requested properties from downstream filter */
    ZeroMemory(&prop, sizeof(prop));
    pPin->GetAllocatorRequirements(&prop);

    /* if he doesn't care about alignment, then set it to 1 */
    if (prop.cbAlign == 0)
    {
        prop.cbAlign = 1;
    }

	RTPASSERT(m_pCRtpSourceFilter->m_pCRtpSourceAllocator);

    *ppAlloc = m_pCRtpSourceFilter->m_pCRtpSourceAllocator;
    
    if (*ppAlloc != NULL)
    {
        /* We will either keep a reference to this or release it below
         * on an error return */
        (*ppAlloc)->AddRef();

	    hr = DecideBufferSize(*ppAlloc, &prop);
	    if (SUCCEEDED(hr))
        {
	        hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	        if (SUCCEEDED(hr))
            {
    		    return(NOERROR);
	        }
	    }
    }

    /* We may or may not have an allocator to release at this
     * point. */
    if (*ppAlloc)
    {
	    (*ppAlloc)->Release();
	    *ppAlloc = NULL;
    }
    
    return(hr);
}

/*
 * Decide the number of buffers, size, etc.
 * */
HRESULT CRtpOutputPin::DecideBufferSize(
        IMemAllocator        *pIMemAllocator,
        ALLOCATOR_PROPERTIES *pProperties
    )
{
    HRESULT          hr;
    ALLOCATOR_PROPERTIES ActualProperties; /* negotiated properties */

    /* default to something reasonable */
    if (pProperties->cBuffers == 0)
    {
        // use hard-coded defaults values for now
        /* I will hold at the most 2 samples while waiting for
         * redundancy (when using red (i, i-3)), in addition, have 2
         * more ready to receive new packets */
        pProperties->cBuffers = max(RTPDEFAULT_SAMPLE_NUM,
                                    RTP_RED_MAXDISTANCE - 1 + 2);
        pProperties->cbBuffer = RTPDEFAULT_SAMPLE_SIZE;   

        pProperties->cbPrefix = RTPDEFAULT_SAMPLE_PREFIX;      
        pProperties->cbAlign  = RTPDEFAULT_SAMPLE_ALIGN;      
    }

    pProperties->cBuffers = max(pProperties->cBuffers, RTPDEFAULT_SAMPLE_NUM);

    /* Get current properties */
    hr = pIMemAllocator->GetProperties(&ActualProperties);

    if (FAILED(hr))
    {
        return(hr);
    }

    if(m_pFilter->IsActive())
    {
        /* Add the number of buffers requested */
        if (pProperties->cBuffers > ActualProperties.cBuffers
            || pProperties->cbBuffer > ActualProperties.cbBuffer
            || pProperties->cbPrefix > ActualProperties.cbPrefix)
        {
            /* We don't want to change the allocator property at runtime. */
            return(E_FAIL);
        }
        
        return(NOERROR);
    }
    
    /* Add the number of buffers requested */
    pProperties->cBuffers += ActualProperties.cBuffers;

    /* ... and don't let that number be smaller than a certain value */
    pProperties->cBuffers = max(pProperties->cBuffers,
                                2*RTPDEFAULT_SAMPLE_NUM);
    
    /* ...  use the biggest buffer size */
    pProperties->cbBuffer =
        max(pProperties->cbBuffer, ActualProperties.cbBuffer);

    /* ... and max prefix */
    pProperties->cbPrefix =
        max(pProperties->cbPrefix, ActualProperties.cbPrefix);
    
    /* attempt to set negotiated/default values */
    hr = pIMemAllocator->SetProperties(pProperties, &ActualProperties);

    return(hr);
}

/*
 * Process 1 sample and repost the buffer */
void CRtpOutputPin::OutPinRecvCompletion(
        IMediaSample    *pIMediaSample,
        BYTE             bPT
    )
{
    HRESULT          hr;
    DWORD            dwFrequency;

    TraceFunctionName("CRtpOutputPin::OutPinRecvCompletion");
    
    if (bPT == m_bPT)
    {
        hr = Deliver(pIMediaSample);
        return;
    }

    if (m_pInputPin == NULL)
    {
        return;
    }

#if USE_GRAPHEDT > 0
    if (m_pInputPin != NULL)
    {
        if (m_bPT != bPT)
        {
            m_bPT = bPT;

            TraceRetail((
                    CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
                    _T("%s: CRtpOutputPin[0x%p] pRtpUser[0x%p] ")
                    _T("Receiving PT:%u"),
                    _fname, this, m_pRtpOutput->pRtpUser, bPT
                ));
        }

        hr = Deliver(pIMediaSample);
    }

    return;
#else /* USE_GRAPHEDT > 0 */
    // try dynamic format change.
    CMediaType MediaType;
    
    hr = m_pCRtpSourceFilter->
        PayloadTypeToMediaType(bPT, &MediaType, &dwFrequency);

    if (FAILED(hr))
    {
        // TODO: log, we got some packets with strange PT.
        return;
    }
#if USE_DYNGRAPH > 0
    
#ifdef DO_IT_OURSELVES
    
    /* This is a new payload type. Ask if the downstream
     * filter likes it. */
    IPinConnection *pIPinConnection;
    hr = m_pInputPin->QueryInterface(&pIPinConnection);
    if (FAILED(hr))
    {
        // we can't do dynamic format change here.
        return;
    }

    hr = pIPinConnection->DynamicQueryAccept(&MediaType);
    pIPinConnection->Release();
    
    if (hr == S_OK) // QuerryAccept only returns S_OK or S_FALSE.
    {
        hr = pIMediaSample->SetMediaType(&MediaType);
        if (SUCCEEDED(hr))
        {
            hr = Deliver(pIMediaSample);
            m_bPT = bPT;
            pIMediaSample->SetMediaType(NULL);
        }
        return;
    }

    // pGraph is not addrefed, so we don't need to release it either.
    // what if the graph is not valid any more? what lock should I hold here?
    if (!m_pGraphConfig)
    {
        // this should not happen.
        return;
    }

    // we have to set the media type here for the reconnect code.
    m_bPT = bPT;
    SetMediaType(&MediaType);

    /*  Now call through to the graph to reconnect us */
    hr = m_pGraphConfig->Reconnect(
        this, 
        NULL, 
        NULL,
        m_hStopEvent,
        AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS 
        );

    pGraphConfig->Release();

    // TBD - This should be in the filter graph
    //m_pFilter->NotifyEvent(EC_GRAPH_CHANGED, 0, 0);  

#else // DO_IT_OURSELVES

    // we have to set the media type here for the reconnect code.
    m_bPT = bPT;
    SetMediaType(&MediaType);

    // try dynamic format change.
    hr = ChangeMediaType(&MediaType);
    if (FAILED(hr))
    {
        // TODO: fire events.
        return;
    }

    pIMediaSample->SetDiscontinuity(TRUE);
    hr = pIMediaSample->SetMediaType(&MediaType);
    if (SUCCEEDED(hr))
    {
        hr = Deliver(pIMediaSample);
        pIMediaSample->SetMediaType(NULL);
    }

    return;

#endif // DO_IT_OURSELVES
    
#else  /* USE_DYNGRAPH > 0 */

    /* This is a new payload type. Ask if the downstream
     * filter likes it. */
    IPin *pIPin;
    hr = m_pInputPin->QueryInterface(&pIPin);
    ASSERT(SUCCEEDED(hr));

    hr = pIPin->QueryAccept(&MediaType);
    pIPin->Release();
            
    if (hr != S_OK) // QueryAccept returns only S_OK or S_FALSE.
    {
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: CRtpOutputPin[0x%p] pRtpUser[0x%p] ")
                _T("PT:%u pIPin->QueryAccept failed:0x%X"),
                _fname, this, m_pRtpOutput->pRtpUser, bPT, hr
            ));

        return;
    }

    hr = pIMediaSample->SetMediaType(&MediaType);
    if (SUCCEEDED(hr))
    {
        hr = Deliver(pIMediaSample);
        /* If deliver fails, do not update m_bPT because that means
         * the media type might not have been propagated to all the
         * filters down stream, hence I want to try again on next
         * packet until it succeeds */
        if (SUCCEEDED(hr))
        {
            m_bPT = bPT;
        }

        pIMediaSample->SetMediaType(NULL);
    }
    return;
#endif /* USE_DYNGRAPH > 0 */
    
#endif /* USE_GRAPHEDT > 0 */
}

/**************************************************
 * IQualityControl overrided methods
 **************************************************/

HRESULT CRtpOutputPin::Active(void)
{
    m_bPT = NO_PAYLOADTYPE;
    return CBASEOUTPUTPIN::Active();
}

STDMETHODIMP CRtpOutputPin::Notify(IBaseFilter *pSelf, Quality q)
{
    return(S_FALSE);
}

/**********************************************************************
 *
 * CRtpSourceAllocator private memory allocator
 *
 **********************************************************************/

CRtpMediaSample::CRtpMediaSample(
        TCHAR           *pName,
        CRtpSourceAllocator *pAllocator,
        HRESULT         *phr
    )
    : CMediaSample(pName, pAllocator, phr, NULL, 0)
{
    m_dwObjectID = OBJECTID_RTPSAMPLE;
}

CRtpMediaSample::~CRtpMediaSample()
{
    TraceFunctionName("CRtpMediaSample::~CRtpMediaSample");

    if (m_dwObjectID != OBJECTID_RTPSAMPLE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: pCRtpMediaSample[0x%p] ")
                _T("Invalid object ID 0x%X != 0x%X"),
                _fname, this,
                m_dwObjectID, OBJECTID_RTPSAMPLE
            ));

        return;
    }

    INVALIDATE_OBJECTID(m_dwObjectID);
}

void *CRtpMediaSample::operator new(size_t size, long lBufferSize)
{
    void            *pVoid;
    long             lTotalSize;

    TraceFunctionName("CRtpMediaSample::operator new");

    lTotalSize = size + lBufferSize;
    
    pVoid = RtpHeapAlloc(g_pRtpSampleHeap, lTotalSize);

    if (pVoid)
    {
        /* Initialize to zero only the sizeof(CRtpMediaSample) */
        ZeroMemory(pVoid, size);
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed to allocate memory:%u+%u=%u"),
                _fname, size, lBufferSize, size+lBufferSize
            ));
    }

    return(pVoid);
}
    
void CRtpMediaSample::operator delete(void *pVoid)
{
    if (pVoid)
    {
        RtpHeapFree(g_pRtpSampleHeap, pVoid);
    }
}

CRtpSourceAllocator::CRtpSourceAllocator(
        TCHAR           *pName,
        LPUNKNOWN        pUnk,
        HRESULT         *phr,
        CRtpSourceFilter *pCRtpSourceFilter 
    )
    :
    CBaseAllocator(pName, pUnk, phr)
{
    BOOL             bOk;
    HRESULT          hr;
    
    if (*phr != NOERROR)
    {
        /* Already an error?, return with same error */
        return;
    }

    hr = NOERROR;
    
    m_dwObjectID = OBJECTID_RTPALLOCATOR;

    m_pCRtpSourceFilter = pCRtpSourceFilter;

    bOk = RtpInitializeCriticalSection(&m_RtpSampleCritSect,
                                       this,
                                       _T("m_RtpSamplesCritSect"));

    if (!bOk)
    {
        hr = RTPERR_CRITSECT;;
    }

    *phr = hr;
}

CRtpSourceAllocator::~CRtpSourceAllocator()
{
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    CRtpMediaSample *pCRtpMediaSample;
    
    TraceFunctionName("CRtpSourceAllocator::~CRtpSourceAllocator");

    if (m_dwObjectID != OBJECTID_RTPALLOCATOR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: pCRtpSourceAllocator[0x%p] ")
                _T("Invalid object ID 0x%X != 0x%X"),
                _fname, this,
                m_dwObjectID, OBJECTID_RTPALLOCATOR
            ));

        return;
    }

    /* Verify there are no samples in the busy queue, and release all
     * free samples */

    lCount = GetQueueSize(&m_RtpBusySamplesQ);
    
    if (lCount > 0)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: pCRtpSourceAllocator[0x%p] Busy samples:%u"),
                _fname, this, lCount
            ));

        while( (pRtpQueueItem = dequeuef(&m_RtpBusySamplesQ,
                                         &m_RtpSampleCritSect)) )
        {
            pCRtpMediaSample =
                CONTAINING_RECORD(pRtpQueueItem,
                                  CRtpMediaSample,
                                  m_RtpSampleItem);

            delete pCRtpMediaSample;
        }
    }
    
    while( (pRtpQueueItem = dequeuef(&m_RtpFreeSamplesQ,
                                     &m_RtpSampleCritSect)) )
    {
        pCRtpMediaSample =
            CONTAINING_RECORD(pRtpQueueItem,
                              CRtpMediaSample,
                              m_RtpSampleItem);

        delete pCRtpMediaSample;
    }

    RtpDeleteCriticalSection(&m_RtpSampleCritSect);
    
    INVALIDATE_OBJECTID(m_dwObjectID);
}

/**************************************************
 * INonDelegatingUnknown implemented methods
 **************************************************/

STDMETHODIMP CRtpSourceAllocator::NonDelegatingQueryInterface(
        REFIID           riid,
        void           **ppv
    )
{
    if (riid == __uuidof(IMemAllocator))
    {
        return GetInterface((IMemAllocator *)this, ppv);
    }

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}

/**************************************************
 * IMemAllocator implemented methods
 **************************************************/

STDMETHODIMP CRtpSourceAllocator::SetProperties(
        ALLOCATOR_PROPERTIES *pRequest,
        ALLOCATOR_PROPERTIES *pActual
    )
{
    TraceFunctionName("CRtpSourceAllocator::SetProperties");

    if (!pRequest || !pActual)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: pCRtpSourceAllocator[0x%p] NULL pointer passed:%u"),
                _fname, this
            ));

        return(RTPERR_POINTER);
    }

    CAutoLock cObjectLock(this);
    
    pActual->cbBuffer = m_lSize = pRequest->cbBuffer;
    pActual->cBuffers = m_lCount = pRequest->cBuffers;
    pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
    pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

    return(NOERROR);
}

STDMETHODIMP CRtpSourceAllocator::GetProperties(
        ALLOCATOR_PROPERTIES *pActual
    )
{
    CAutoLock cObjectLock(this);

    pActual->cbBuffer = m_lSize;
    pActual->cBuffers = m_lCount;
    pActual->cbAlign = m_lAlignment;
    pActual->cbPrefix = m_lPrefix;
   
    return(NOERROR);
}

STDMETHODIMP CRtpSourceAllocator::Commit()
{
    return(NOERROR);
}

STDMETHODIMP CRtpSourceAllocator::Decommit()
{
    return(NOERROR);
}

STDMETHODIMP CRtpSourceAllocator::GetBuffer(
        IMediaSample   **ppIMedisSample,
        REFERENCE_TIME  *pStartTime,
        REFERENCE_TIME  *pEndTime,
        DWORD            dwFlags
    )
{
    HRESULT          hr;
    BOOL             bOk;
    CRtpMediaSample *pCRtpMediaSample;
    RtpQueueItem_t  *pRtpQueueItem;
    BYTE            *pBuffer;

    TraceFunctionName("CRtpSourceAllocator::GetBuffer");

    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    
    bOk = RtpEnterCriticalSection(&m_RtpSampleCritSect);

    if (!bOk)
    {
        hr = RTPERR_CRITSECT;

        goto end;
    }
    
    hr = RTPERR_RESOURCES;
    
    if (GetQueueSize(&m_RtpFreeSamplesQ) > 0)
    {
        /* If we have at least one free sample, get it */
        pRtpQueueItem = dequeuef(&m_RtpFreeSamplesQ, NULL);

        pCRtpMediaSample =
            CONTAINING_RECORD(pRtpQueueItem, CRtpMediaSample, m_RtpSampleItem);
    }

    RtpLeaveCriticalSection(&m_RtpSampleCritSect);

    if (!pRtpQueueItem)
    {
        /* Create a new sample */
        pCRtpMediaSample =
            new(m_lSize + m_lPrefix) CRtpMediaSample(_T("RTP Media Sample"),
                                                     this,
                                                     &hr);

        if (pCRtpMediaSample)
        {
            pBuffer = ((BYTE *)pCRtpMediaSample) +
                sizeof(CRtpMediaSample) + m_lPrefix;
            
            pCRtpMediaSample->SetPointer(pBuffer, m_lSize);

            InterlockedIncrement(&m_lAllocated);

            if (m_lAllocated > m_lCount)
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                        _T("%s: pCRtpSourceAllocator[0x%p] ")
                        _T("Buffers allocated exceeds agreed number: %d > %d"),
                        _fname, this, m_lAllocated, m_lCount
                    ));
            }
        }
    }

    if (pCRtpMediaSample)
    {
        /* The RefCount should be 0 if taken from the free list or
         * just created */
        if (pCRtpMediaSample->m_cRef != 0)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                    _T("%s: pCRtpSourceAllocator[0x%p] RefCount:%u != 0"),
                    _fname, this, pCRtpMediaSample->m_cRef
                ));
        }

        pCRtpMediaSample->m_cRef = 1;

        /* Keep it in the busy queue */
        enqueuel(&m_RtpBusySamplesQ,
                 &m_RtpSampleCritSect,
                 &pCRtpMediaSample->m_RtpSampleItem);

        *ppIMedisSample = pCRtpMediaSample;

        hr = NOERROR;
    }

 end:
    return(hr);
}

STDMETHODIMP CRtpSourceAllocator::ReleaseBuffer(
        IMediaSample    *pIMediaSample
    )
{
    CRtpMediaSample *pCRtpMediaSample;

    pCRtpMediaSample = (CRtpMediaSample *)pIMediaSample;
    
    move2qf(&m_RtpFreeSamplesQ,
            &m_RtpBusySamplesQ,
            &m_RtpSampleCritSect,
            &pCRtpMediaSample->m_RtpSampleItem);
    
    return(NOERROR);
}

STDMETHODIMP CRtpSourceAllocator::GetFreeCount(LONG *plBuffersFree)
{
    if (plBuffersFree)
    {
        *plBuffersFree = GetQueueSize(&m_RtpFreeSamplesQ);
    }
    
    return(NOERROR);
}

void CRtpSourceAllocator::Free(void)
{
    RTPASSERT(0);
}

HRESULT CRtpSourceAllocator::Alloc(void)
{
    RTPASSERT(0);
    return(NOERROR);
}

void *CRtpSourceAllocator::operator new(size_t size)
{
    void            *pVoid;
    
    TraceFunctionName("CRtpSourceFilter::operator new");

    pVoid = RtpHeapAlloc(g_pRtpSourceHeap, size);

    if (pVoid)
    {
        ZeroMemory(pVoid, size);
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed to allocate memory:%u"),
                _fname, size
            ));
    }
    
    return(pVoid);
}

void CRtpSourceAllocator::operator delete(void *pVoid)
{
    if (pVoid)
    {
        RtpHeapFree(g_pRtpSourceHeap, pVoid);
    }
}

/**********************************************************************
 *
 * RTP Source Filter class implementation: CRtpSourceFilter
 *
 **********************************************************************/

/*
 * CRtpSourceFilter constructor
 * */
CRtpSourceFilter::CRtpSourceFilter(LPUNKNOWN pUnk, HRESULT *phr)
    :
    CBaseFilter(
            _T("CRtpSourceFilter"), 
            pUnk, 
            &m_cRtpSrcCritSec, 
            __uuidof(MSRTPSourceFilter)
        ),

    CIRtpSession(
            pUnk,
            phr,
            RtpBitPar(FGADDR_IRTP_ISRECV)
        )
{
    HRESULT              hr;
    int                  i;
    BOOL                 bOk;
    long                 lMaxFilter;
    CRtpOutputPin       *pCRtpOutputPin;
    
    TraceFunctionName("CRtpSourceFilter::CRtpSourceFilter");

    m_pCIRtpSession = static_cast<CIRtpSession *>(this);
    
    /* Test for NULL pointers, do not test pUnk which may be NULL */
    if (!phr)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: CRtpSourceFilter[0x%p] has phr NULL"),
                _fname, this
            ));
        
        /* MAYDO this is a really bad situation, we can not pass any
         * error and the memory for this object is allocated, this may
         * be fixed if this parameter is tested before allocating
         * memory using an overriden new */

        phr = &hr; /* Use this pointer instead */
    }

    SetBaseFilter(this);
    
    *phr = NOERROR;

    lMaxFilter = InterlockedIncrement(&g_RtpContext.lNumSourceFilter);
    if (lMaxFilter > g_RtpContext.lMaxNumSourceFilter)
    {
        g_RtpContext.lMaxNumSourceFilter = lMaxFilter;
    }
    
    /* Initialize some fields */
    m_dwObjectID = OBJECTID_RTPSOURCE;

    bOk = RtpInitializeCriticalSection(&m_OutPinsCritSect,
                                       this,
                                       _T("m_OutPinsCritSec"));

    if (bOk == FALSE)
    {
        *phr = RTPERR_CRITSECT;
        goto bail;
    }
    
#if USE_DYNGRAPH > 0
    /* Create the stop event */
    m_hStopEvent = ::CreateEvent( NULL, FALSE, FALSE, NULL );

    /* The Win32 SDK function CreateEvent() returns NULL if an error occurs */
    if( m_hStopEvent == NULL )
    {
        *phr = E_OUTOFMEMORY;
        goto bail;
    }
#endif
    
    /* Create the allocator to use by all the output pins */
    m_pCRtpSourceAllocator = new CRtpSourceAllocator(
            _T("CRtpSourceAllocator"),
            NULL,
            phr,
            this);

    if (FAILED(*phr))
    {
        /* pass up the same returned error */
        goto bail;
    }
    
    if (!m_pCRtpSourceAllocator)
    {
        /* low in memory, failed to create object */
        *phr = E_OUTOFMEMORY;
        goto bail;
    }

    /* Add ref our allocator */
    m_pCRtpSourceAllocator->AddRef();

#if USE_GRAPHEDT > 0
    /* When using graphedt, initialize automatically, the coockie can
     * be NULL as a global variable will be shared between source and
     * render */
    *phr = m_pCIRtpSession->Init(NULL, RtpBitPar2(RTPINITFG_AUTO, RTPINITFG_QOS));
    
    if (FAILED(*phr))
    {
        /* pass up the same returned error */
        goto bail;
    }

    /* Set 2 output pins */
    SetPinCount(2, RTPDMXMODE_AUTO);
#else
    SetPinCount(1, RTPDMXMODE_AUTO);
#endif /* USE_GRAPHEDT > 0 */
    
    *phr = NOERROR;

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
            _T("%s: CRtpSourceFilter[0x%p] CIRtpSession[0x%p] created"),
            _fname, this, static_cast<CIRtpSession *>(this)
        ));
    
    return;

 bail:
    Cleanup();
}

/*
 * RtpSourceFilter destructor
 * */
CRtpSourceFilter::~CRtpSourceFilter()
{
    RtpAddr_t       *pRtpAddr;
    
    TraceFunctionName("CRtpSourceFilter::~CRtpSourceFilter");

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
            _T("%s: CRtpSourceFilter[0x%p] CIRtpSession[0x%p] being deleted..."),
            _fname, this, static_cast<CIRtpSession *>(this)
        ));
    
    if (m_RtpFilterState == State_Running)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: Filter[0x%p] being deleted while still running"),
                _fname, this
            ));

        /* Will call RtpStop, which in turn will call RtpRealstop if
         * FGADDR_IRTP_PERSISTSOCKETS is not set, otherwise the
         * session will be stopped for DShow but in RTP will continue
         * running in a muted state */
        Stop();
    }

    pRtpAddr = m_pCIRtpSession->GetpRtpAddr();

    if (pRtpAddr &&
        RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_PERSISTSOCKETS))
    {
        /* If FGADDR_IRTP_PERSISTSOCKETS is set, the session may be
         * still running in a muted state regardless the call to the
         * DShow Stop, to force a real stop, MUST use the flag
         * provided for that */
        RtpStop(pRtpAddr->pRtpSess,
                RtpBitPar2(FGADDR_ISRECV, FGADDR_FORCESTOP));
    }

    Cleanup();

    InterlockedDecrement(&g_RtpContext.lNumSourceFilter);

    m_pCIRtpSession = (CIRtpSession *)NULL;
    
    INVALIDATE_OBJECTID(m_dwObjectID);
}

void CRtpSourceFilter::Cleanup(void)
{
    long             lCount;
    CRtpOutputPin   *pCRtpOutputPin;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("CRtpSourceFilter::Cleanup");

    /* Remove the DShow pins <-> RTP outputs mapping */
    UnmapPinsFromOutputs();
    
    /* Delete all the output pins */
    while( (pRtpQueueItem = m_OutPinsQ.pFirst) )
    {
        dequeue(&m_OutPinsQ, &m_OutPinsCritSect, pRtpQueueItem);

        pCRtpOutputPin =
            CONTAINING_RECORD(pRtpQueueItem, CRtpOutputPin, m_OutputPinQItem);

        delete pCRtpOutputPin;
    }

    if (m_pCRtpSourceAllocator)
    {
        lCount = m_pCRtpSourceAllocator->Release();
        if ( lCount > 0)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                    _T("%s: CRtpSourceAllocator ")
                    _T("unexpected RefCount:%d > 0"),
                    _fname, lCount
                ));
        }
        
        m_pCRtpSourceAllocator = (CRtpSourceAllocator *)NULL;
    }

    FlushFormatMappings();
    
    RtpDeleteCriticalSection(&m_OutPinsCritSect);

#if USE_DYNGRAPH > 0
    if (m_hStopEvent)
    {
        CloseHandle(m_hStopEvent);
        m_hStopEvent = NULL;
    }
#endif
}

void *CRtpSourceFilter::operator new(size_t size)
{
    void            *pVoid;
    
    TraceFunctionName("CRtpSourceFilter::operator new");

    MSRtpInit2();
    
    pVoid = RtpHeapAlloc(g_pRtpSourceHeap, size);

    if (pVoid)
    {
        ZeroMemory(pVoid, size);
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed to allocate memory:%u"),
                _fname, size
            ));

        /* On low memory failure, the destructor will not be called,
         * so decrese the reference count that was increased above */
        MSRtpDelete2(); 
    }
    
    return(pVoid);
}

void CRtpSourceFilter::operator delete(void *pVoid)
{
    if (pVoid)
    {
        RtpHeapFree(g_pRtpSourceHeap, pVoid);
        
        /* Reduce the reference count only for objects that got
         * memory, those that failed to obtain memory do not increase
         * the counter */
        MSRtpDelete2();
    }
}

/*
 * Create a CRtpSourceFiltern instance (for active movie class factory)
 * */
CUnknown *CRtpSourceFilterCreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    /* Test for NULL pointers, do not test pUnk which may be NULL */
    if (!phr)
    {
        return((CUnknown *)NULL);
    }

    *phr = NOERROR;
   
    /* On failure during the constructor, the caller is responsible to
     * delete the object (that is consistent with DShow) */
    CRtpSourceFilter *pCRtpSourceFilter = new CRtpSourceFilter(pUnk, phr);

    if (!pCRtpSourceFilter)
    {
        *phr = RTPERR_MEMORY;
    }
        
    return(pCRtpSourceFilter);
}

/**************************************************
 * CBaseFilter overrided methods
 **************************************************/

/*
 * Get the number of output pins
 * */
int CRtpSourceFilter::GetPinCount()
{
    long                 lCount;
    BOOL                 bOk;

    lCount = 0;
    
    /* Lock pins queue */
    bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

    if (bOk)
    {
        lCount = GetQueueSize(&m_OutPinsQ);

        RtpLeaveCriticalSection(&m_OutPinsCritSect);
    }
    
    return((int)lCount);
}

/*
 * Get a reference to the nth pin
 * */
CBasePin *CRtpSourceFilter::GetPin(int n)
{
    BOOL                 bOk;
    CRtpOutputPin       *pCRtpOutputPin;
    RtpQueueItem_t      *pRtpQueueItem;

    pCRtpOutputPin = (CRtpOutputPin *)NULL;
    
    /* Lock pins queue */
    bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

    if (bOk)
    {
        /* TODO scan list and retrieve the nth element, check there
         * exist at least that many pins */
        if (n >= GetQueueSize(&m_OutPinsQ))
        {
            RtpLeaveCriticalSection(&m_OutPinsCritSect); 
            return((CBasePin *)NULL);
        }

        /* Get to the nth item */
        for(pRtpQueueItem = m_OutPinsQ.pFirst;
            n > 0;
            pRtpQueueItem = pRtpQueueItem->pNext, n--)
        {
            /* Empty body */;
        }

        pCRtpOutputPin =
            CONTAINING_RECORD(pRtpQueueItem, CRtpOutputPin, m_OutputPinQItem);

        RtpLeaveCriticalSection(&m_OutPinsCritSect); 
    }
    
    return(pCRtpOutputPin);
}

/* override GetState to report that we don't send any data when
 * paused, so renderers won't starve expecting that */
STDMETHODIMP CRtpSourceFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);

    CheckPointer(State, E_POINTER);

    ValidateReadWritePtr(State, sizeof(FILTER_STATE));

    *State = m_State;
    
    if (m_State == State_Paused)
    {
        return(VFW_S_CANT_CUE);
    }

    return(NOERROR);
}

/* Creates and start the worker thread */
STDMETHODIMP CRtpSourceFilter::Run(REFERENCE_TIME tStart)
{
    HRESULT          hr;
    RtpSess_t       *pRtpSess;
    RtpAddr_t       *pRtpAddr;
    WSABUF           WSABuf;
    IMediaSample    *pIMediaSample;
    DWORD            dwNumBuffs;
    DWORD            i;
    ALLOCATOR_PROPERTIES CurrentProps;

    TraceFunctionName("CRtpSourceFilter::Run");

    if (m_RtpFilterState == State_Running)
    {
        /* Alredy running, do nothing but call base class */
        hr = CBaseFilter::Run(tStart);

        return(hr);
    }
    
    hr = NOERROR;
    
    if (!m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        return(RTPERR_NOTINIT);
    }
    
    /* MAYDO when we have multiple addresses, there should be a way to
     * assign to each pin an address */

    pRtpSess = m_pCIRtpSession->GetpRtpSess();
    pRtpAddr = m_pCIRtpSession->GetpRtpAddr();

    if (pRtpSess && pRtpAddr)
    {
        /* Register buffers to use for asynchronous I/O, only if we
         * have a valid session and the receiver is not already
         * running. If we are using persistent sockets, the receiver
         * may be already running, in that case, do not attempt to
         * register more reception buffers because we may block */
    
        if(!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RUNRECV))
        {
            RTPASSERT(pRtpAddr->pRtpSess == pRtpSess);
        
            /* Get buffers and register them, they will be used later to
             * start asynchronous reception. After each packet is received
             * and delivered, a new asynchronous reception will be started. */

            /* Get current properties */
            m_pCRtpSourceAllocator->GetProperties(&CurrentProps);

            m_lPrefix = CurrentProps.cbPrefix;
        
            if (CurrentProps.cBuffers == 0)
            {
                TraceRetail((
                        CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                        _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                        _T("CurrentProps.cBuffers = 0"),
                        _fname, pRtpSess, pRtpAddr
                    ));

                CurrentProps.cBuffers = RTPDEFAULT_SAMPLE_NUM;
            }

            /* Register with RTP the completion function */
            RtpRegisterRecvCallback(pRtpAddr, DsRecvCompletionFunc);

            /* Set the number of buffers to keep */
            dwNumBuffs = CurrentProps.cBuffers;

            for(i = 0; i < dwNumBuffs; i++)
            {
                /* GetDeliveryBuffer AddRef pIMediaSample */
                hr = m_pCRtpSourceAllocator->
                    GetBuffer(&pIMediaSample, NULL, NULL, 0);

                /* the allocator might be decommited if the graph has
                 * changed dynamically. */
                if (hr == VFW_E_NOT_COMMITTED)
                {
                    hr = m_pCRtpSourceAllocator->Commit();
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pCRtpSourceAllocator->
                            GetBuffer(&pIMediaSample, NULL, NULL, 0);
                    }
                }

                if (FAILED(hr))
                {
                    TraceRetail((
                            CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                            _T("GetBuffer failed: %u (0x%X)"),
                            _fname, pRtpSess, pRtpAddr,
                            hr, hr
                        ));
                
                    break;
                }
            
                WSABuf.len = pIMediaSample->GetSize();
                pIMediaSample->GetPointer((unsigned char **)&WSABuf.buf);

                /* register buffers for asynchronous I/O */
                hr = RtpRecvFrom(pRtpAddr,
                                 &WSABuf,
                                 this,           /* pvUserInfo1 */
                                 pIMediaSample); /* pvUserInfo2 */
            
                if (FAILED(hr))
                {
                    TraceRetail((
                            CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                            _T("RtpRecvFrom failed: %u (0x%X)"),
                            _fname, pRtpSess, pRtpAddr,
                            hr, hr
                        ));

                    pIMediaSample->Release();
                }
            }

            if (i > 0)
            {
                hr = NOERROR; /* succeeds with at least 1 buffer */
            
                TraceDebug((
                        CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
                        _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                        _T("overlapped I/O started:%d"),
                        _fname, pRtpSess, pRtpAddr,
                        i
                    ));
            }
        }
    }
    else
    {
        hr = RTPERR_INVALIDSTATE;
        
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("null session or address"),
                _fname, pRtpSess, pRtpAddr
            ));
    }
    
    /* Call base class */
    if (SUCCEEDED(hr))
    {
        hr = CBaseFilter::Run(tStart);

        /* This negative value will make the time just obtained be
         * used, it might be < 0, so zero is not accpetable here */
        m_StartTime = -999999999;
        
        /* Initialize sockets and start worker thread */
        if (SUCCEEDED(hr))
        {
            hr = RtpStart(pRtpSess, RtpBitPar(FGADDR_ISRECV));

            if (SUCCEEDED(hr))
            {
                m_RtpFilterState = State_Running;
            }
        }
    }
    
    return(hr);
}

/* Do per filter de-initialization */
STDMETHODIMP CRtpSourceFilter::Stop()
{
    HRESULT    hr;
    HRESULT    hr2;
    RtpSess_t *pRtpSess;

    if (m_RtpFilterState == State_Stopped)
    {
        /* Alredy stopped, do nothing but call base class */
        hr2 = CBaseFilter::Stop();
        
        return(hr2);
    }
    
    if (!m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        hr = RTPERR_NOTINIT;

        goto end;
    }
    
    pRtpSess = m_pCIRtpSession->GetpRtpSess();
    
    if (pRtpSess)
    {
        hr = RtpStop(pRtpSess, RtpBitPar(FGADDR_ISRECV));
    }
    else
    {
        hr = RTPERR_INVALIDSTATE;
    }

 end:
    /* Call base class */
    hr2 = CBaseFilter::Stop(); /* will decommit */

    if (SUCCEEDED(hr))
    {
        hr = hr2;
    }

    m_RtpFilterState = State_Stopped;
    
    return(hr);
}

#if USE_DYNGRAPH > 0

BOOL CRtpSourceFilter::ConfigurePins(
    IN IGraphConfig* pGraphConfig,
    IN HANDLE hEvent
    )
{
    BOOL                bOk;
    long                i;
    CRtpOutputPin       *pCRtpOutputPin;
    RtpQueueItem_t      *pRtpQueueItem;
    
    /* Lock pins queue */
    bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

    if (bOk)
    {
        for(i = 0, pRtpQueueItem = m_OutPinsQ.pFirst;
            i < GetQueueSize(&m_OutPinsQ);
            i++, pRtpQueueItem = pRtpQueueItem->pNext)
        {
            pCRtpOutputPin =
                CONTAINING_RECORD(pRtpQueueItem,
                                  CRtpOutputPin,
                                  m_OutputPinQItem);
            
            pCRtpOutputPin->SetConfigInfo( pGraphConfig, hEvent );
        }

        RtpLeaveCriticalSection(&m_OutPinsCritSect); 
    }

    return bOk;
}

// override JoinFilterGraph for dynamic filter graph change.
STDMETHODIMP CRtpSourceFilter::JoinFilterGraph( 
    IFilterGraph* pGraph, 
    LPCWSTR pName 
    )
{
    CAutoLock Lock( &m_cRtpSrcCritSec );

    HRESULT hr;
 
    // The filter is joining the filter graph.
    if( NULL != pGraph )
    {
        IGraphConfig* pGraphConfig = NULL;
 
        hr = pGraph->QueryInterface(&pGraphConfig);
        
        if( FAILED( hr ) )
        {
            /* TODO log error */
            return hr;
        }

        // we can't hold any refcount to the graph.
        pGraphConfig->Release();

        hr = CBaseFilter::JoinFilterGraph( pGraph, pName );
        if( FAILED( hr ) )
        {
            return hr;
        } 

        ConfigurePins(pGraphConfig, m_hStopEvent);
    }
    else
    {
        hr = CBaseFilter::JoinFilterGraph( pGraph, pName );
        if( FAILED( hr ) )
        {
            return hr;
        }

        // The filter is leaving the filter graph.
        ConfigurePins( NULL, NULL );
    }

    return S_OK;
}

#endif /* USE_DYNGRAPH */

/**************************************************
 * INonDelegatingUnknown implemented methods
 **************************************************/

/* obtain pointers to active movie and private interfaces */
STDMETHODIMP CRtpSourceFilter::NonDelegatingQueryInterface(
        REFIID riid,
        void **ppv
    )
{
    HRESULT hr;
    
    if (riid == __uuidof(IRtpMediaControl))
    {
        return GetInterface(static_cast<IRtpMediaControl *>(this), ppv);
    }
    else if (riid == __uuidof(IRtpDemux))
    {
        return GetInterface(static_cast<IRtpDemux *>(this), ppv);
    }
    else if (riid == __uuidof(IRtpSession))
    {
        return GetInterface(static_cast<IRtpSession *>(this), ppv);
    }
    else if (riid == __uuidof(IRtpRedundancy))
    {
        return GetInterface(static_cast<IRtpRedundancy *>(this), ppv);
    }
    else
    {
        hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }

    return(hr);
}

/**************************************************
 * IRtpMediaControl implemented methods
 **************************************************/

/* set the mapping between RTP payload and DShow media types */
STDMETHODIMP CRtpSourceFilter::SetFormatMapping(
	    IN DWORD         dwRTPPayLoadType, 
        IN DWORD         dwFrequency,
        IN AM_MEDIA_TYPE *pMediaType
    )
{
    DWORD            dw;

    TraceFunctionName("CRtpSourceFilter::SetFormatMapping");

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    if (!pMediaType)
    {
        return(RTPERR_POINTER);
    }

    CAutoLock Lock( &m_cRtpSrcCritSec );
    
    for (dw = 0; dw < m_dwNumMediaTypeMappings; dw ++)
    {
        if (m_MediaTypeMappings[dw].dwRTPPayloadType == dwRTPPayLoadType)
        {
            // the RTP payload type is known, update the media type to be used.
            delete m_MediaTypeMappings[dw].pMediaType;
            m_MediaTypeMappings[dw].pMediaType = new CMediaType(*pMediaType);
            if (m_MediaTypeMappings[dw].pMediaType == NULL)
            {
                return RTPERR_MEMORY;
            }
            m_MediaTypeMappings[dw].dwFrequency = dwFrequency;

            AddPt2FrequencyMap(dwRTPPayLoadType, dwFrequency);
            
            return NOERROR;
        }
    }

    if (dw >= MAX_MEDIATYPE_MAPPINGS)
    {
        // we don't have space for more mappings.
        return RTPERR_RESOURCES;
    }

    // This is a new mapping. remember it.
    m_MediaTypeMappings[dw].pMediaType = new CMediaType(*pMediaType);
    if (m_MediaTypeMappings[dw].pMediaType == NULL)
    {
        return RTPERR_MEMORY;
    }
    m_MediaTypeMappings[dw].dwRTPPayloadType = dwRTPPayLoadType;
    m_MediaTypeMappings[dw].dwFrequency = dwFrequency;

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
            _T("%s: CRtpSourceFilter[0x%p] New mapping[%u]: ")
            _T("PT:%u Frequency:%u"),
            _fname, this,
            m_dwNumMediaTypeMappings, dwRTPPayLoadType, dwFrequency
        ));
    
    AddPt2FrequencyMap(dwRTPPayLoadType, dwFrequency);
    
    m_dwNumMediaTypeMappings++;
    
    return NOERROR;
}

/* Empties the format mapping table */
STDMETHODIMP CRtpSourceFilter::FlushFormatMappings(void)
{
    DWORD            dw;
    
    CAutoLock Lock( &m_cRtpSrcCritSec );

    for (dw = 0; dw < m_dwNumMediaTypeMappings; dw ++)
    {
        if (m_MediaTypeMappings[dw].pMediaType)
        {
            delete m_MediaTypeMappings[dw].pMediaType;
            m_MediaTypeMappings[dw].pMediaType = NULL;
        }
    }

    m_dwNumMediaTypeMappings = 0;
    
    /* Now flush the RTP table */
    if (m_pRtpAddr)
    {
        RtpFlushPt2FrequencyMaps(m_pRtpAddr, RECV_IDX);
    }
    
    return(NOERROR);
}
    
/**************************************************
 * IRtpDemux implemented methods
 **************************************************/

/* Add a single pin, may return its position */
STDMETHODIMP CRtpSourceFilter::AddPin(
        IN  int          iOutMode,
        OUT int         *piPos
    )
{
    HRESULT          hr;
    DWORD            dwError;
    long             lCount;
    RtpOutput_t     *pRtpOutput;
    CRtpOutputPin   *pCRtpOutputPin;

    TraceFunctionName("CRtpSourceFilter::AddPin");

    hr = RTPERR_INVALIDSTATE;
    dwError = NOERROR;
    pRtpOutput = (RtpOutput_t *)NULL;
    pCRtpOutputPin = (CRtpOutputPin *)NULL;

    /* Create the DShow output pin */
    pCRtpOutputPin = (CRtpOutputPin *)
        new CRtpOutputPin(this,
                          m_pCIRtpSession,
                          &hr,
                          L"Capture");

    if (FAILED(hr))
    {
        goto bail;
    }

    if (!pCRtpOutputPin)
    {
        hr = RTPERR_MEMORY;
        
        goto bail;
    }

    lCount = GetQueueSize(&m_OutPinsQ);

    if (m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        /* Add an RTP output, passes the DShow output pin it will be
         * associated with */
        pRtpOutput = RtpAddOutput(
                m_pCIRtpSession->GetpRtpSess(),
                iOutMode,
                (IPin *)pCRtpOutputPin,
                &dwError);

        if (dwError)
        {
            hr = dwError;

            goto bail;
        }

        pCRtpOutputPin->m_OutputPinQItem.dwKey = lCount;
    }
    else
    {
        if (iOutMode <= RTPDMXMODE_FIRST || iOutMode >= RTPDMXMODE_LAST)
        {
            hr = RTPERR_INVALIDARG;
            
            goto bail;
        }
        
        /* Encode in dwKey the OutMode and position. The DShow output
         * pins that are left here without a matching RTP output, will
         * get one when CRtpSourceFilter::MapPinsToOutputs is called in
         * CIRtpSession::Init */
        pCRtpOutputPin->m_OutputPinQItem.dwKey = (iOutMode << 16) | lCount;
    }

    if (piPos)
    {
        *piPos = lCount;
    }

    pCRtpOutputPin->SetOutput(pRtpOutput);

    enqueuel(&m_OutPinsQ,
             &m_OutPinsCritSect,
             &pCRtpOutputPin->m_OutputPinQItem);

    return(hr);
    
 bail:

    TraceRetail((
            CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
            _T("%s: failed: %u (0x%X)"),
            _fname, hr, hr
        ));
    
    if (pCRtpOutputPin)
    {
        delete pCRtpOutputPin;
    }

    return(hr);
}

/* Set the number of pins, can only be >= than current number of pins
 * */
STDMETHODIMP CRtpSourceFilter::SetPinCount(
        IN int           iCount,
        IN int           iOutMode
    )
{
    HRESULT          hr;
    int              i;

    TraceFunctionName("CRtpSourceFilter::SetPinCount");

    hr = NOERROR;

    /* MAYDO I need to be able to remove pins. Right now we can add
     * pins but right now we can not remove them */
    iCount -= GetPinCount();
    
    for(i = 0; i < iCount; i++)
    {
        hr = AddPin(iOutMode, NULL);

        if (FAILED(hr))
        {
            /* pass up the same returned error */
            break;
        }
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed: %u (0x%X)"),
                _fname, hr, hr
            ));
    }
    
    return(hr);
}

/* Set the pin mode (e.g. auto, manual, etc), if iPos >= 0 use it,
 * otherwise use pIPin */
STDMETHODIMP CRtpSourceFilter::SetPinMode(
        IN  int          iPos,
        IN  IPin        *pIPin,
        IN  int          iOutMode
    )
{
    HRESULT          hr;
    CRtpOutputPin   *pCRtpOutputPin;
    RtpOutput_t     *pRtpOutput;

    TraceFunctionName("CRtpSourceFilter::SetPinMode");

    hr = RTPERR_NOTINIT;
    
    if (m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        pRtpOutput = (RtpOutput_t *)NULL;
    
        if (iPos < 0)
        {
            if (pIPin)
            {
                pCRtpOutputPin = FindIPin(pIPin);

                if (pCRtpOutputPin)
                {
                    pRtpOutput = pCRtpOutputPin->GetpRtpOutput();

                    if (!pRtpOutput)
                    {
                        /* The DShow pin doesn't have an RTP output
                         * associated */
                        hr = RTPERR_INVALIDSTATE;

                        goto end;
                    }
                }
                else
                {
                    hr = RTPERR_NOTFOUND;

                    goto end;
                }
            }
        }
        
        hr = RtpSetOutputMode(
                m_pCIRtpSession->GetpRtpSess(),
                iPos,
                pRtpOutput,
                iOutMode);
    }

 end:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed: %u (0x%X)"),
                _fname, hr, hr
            ));
    }

    return(hr);
}

/* Map/unmap pin i to/from user with SSRC, if iPos >= 0 use it,
 * otherwise use pIPin, when unmapping, only the pin or the SSRC is
 * required */
STDMETHODIMP CRtpSourceFilter::SetMappingState(
        IN  int          iPos,
        IN  IPin        *pIPin,
        IN  DWORD        dwSSRC,
        IN  BOOL         bMapped
    )
{
    HRESULT          hr;
    CRtpOutputPin   *pCRtpOutputPin;
    RtpOutput_t     *pRtpOutput;
    
    TraceFunctionName("CRtpSourceFilter::SetMappingState");

    hr = RTPERR_NOTINIT;

    if (m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        pRtpOutput = (RtpOutput_t *)NULL;
        
        if (iPos < 0 && pIPin)
        {
            pCRtpOutputPin = FindIPin(pIPin);

            if (pCRtpOutputPin)
            {
                pRtpOutput = pCRtpOutputPin->GetpRtpOutput();

                if (!pRtpOutput)
                {
                    /* The DShow pin doesn't have an RTP output
                     * associated */
                    hr = RTPERR_INVALIDSTATE;
                    
                    goto end;
                }
            }
        }
        
        hr = RtpOutputState(
                m_pCIRtpSession->GetpRtpAddr(),
                iPos,
                pRtpOutput,
                dwSSRC,
                bMapped);
    }

 end:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed: %u (0x%X)"),
                _fname, hr, hr
            ));
    }

    return(hr);
}

/* Find the Pin assigned (if any) to the SSRC, return either position
 * or pin or both */
STDMETHODIMP CRtpSourceFilter::FindPin(
        IN  DWORD        dwSSRC,
        OUT int         *piPos,
        OUT IPin       **ppIPin
    )
{
    HRESULT          hr;
    void            *pvUserInfo;
    
    TraceFunctionName("CRtpSourceFilter::FindPin");

    hr = RTPERR_NOTINIT;

    if (m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        hr = RtpFindOutput(m_pCIRtpSession->GetpRtpAddr(),
                           dwSSRC,
                           piPos,
                           &pvUserInfo);

        if (SUCCEEDED(hr))
        {
            if (ppIPin)
            {
                if (pvUserInfo)
                {
                    *ppIPin = static_cast<IPin *>(pvUserInfo);
                }
                else
                {
                    /* The SSRC not being mapped is not an error
                     * condition */
                    *ppIPin = (IPin *)NULL;
                }
            }
        }
    }
    
    return(hr);
}

/* Find the SSRC mapped to the Pin, if iPos >= 0 use it, otherwise use
 * pIPin */
STDMETHODIMP CRtpSourceFilter::FindSSRC(
        IN  int          iPos,
        IN  IPin        *pIPin,
        OUT DWORD       *pdwSSRC
    )
{
    HRESULT          hr;
    CRtpOutputPin   *pCRtpOutputPin;
    RtpOutput_t     *pRtpOutput;
    
    TraceFunctionName("CRtpSourceFilter::FindSSRC");

    hr = RTPERR_NOTINIT;

    if (m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        pRtpOutput = (RtpOutput_t *)NULL;
        
        if (iPos < 0 && pIPin)
        {
            pCRtpOutputPin = FindIPin(pIPin);

            if (pCRtpOutputPin)
            {
                pRtpOutput = pCRtpOutputPin->GetpRtpOutput();

                if (!pRtpOutput)
                {
                    /* The DShow pin doesn't have an RTP output
                     * associated */
                    hr = RTPERR_INVALIDSTATE;

                    goto end;
                }
            }
        }
        
        hr = RtpFindSSRC(m_pCIRtpSession->GetpRtpAddr(),
                         iPos,
                         pRtpOutput,
                         pdwSSRC);
    }

 end:
    return(hr);
}

/**************************************************
 * Helper functions
 **************************************************/

HRESULT CRtpSourceFilter::GetMediaType(int iPosition, CMediaType *pCMediaType)
{
    if ((DWORD)iPosition >= m_dwNumMediaTypeMappings)
    {
        return VFW_S_NO_MORE_ITEMS;
    }

    *pCMediaType = *m_MediaTypeMappings[iPosition].pMediaType;
    //CopyMediaType(pCMediaType, m_MediaTypeMappings[iPosition].pMediaType);

    return S_OK;
}

void CRtpSourceFilter::SourceRecvCompletion(
        IMediaSample    *pIMediaSample,
        void            *pvUserInfo, /* pIPin of pCRtpOutputPin */
        RtpUser_t       *pRtpUser,
        double           dPlayTime,
        DWORD            dwError,
        long             lHdrSize,
        DWORD            dwTransfered,
        DWORD            dwFlags
    )
{
    HRESULT          hr;
    BOOL             bNewTalkSpurt;
    RtpAddr_t       *pRtpAddr;
    RtpNetRState_t  *pRtpNetRState;
    RtpHdr_t        *pRtpHdr;
    RtpPrefixHdr_t  *pRtpPrefixHdr;
    RtpQueueItem_t  *pRtpQueueItem;
    CRtpOutputPin   *pCRtpOutputPin;
    unsigned char   *buf;
    WSABUF           WSABuf;
    REFERENCE_TIME   StartTime; /* DShow reference time in 100ns units */
    REFERENCE_TIME   EndTime; /* DShow reference time in 100ns units */

    TraceFunctionName("CRtpSourceFilter::SourceRecvCompletion");

    pRtpAddr = m_pCIRtpSession->GetpRtpAddr();

    if ( (m_State == State_Running) &&
         !RtpBitTest2(dwFlags, FGRECV_ERROR, FGRECV_DROPPED) &&
         pRtpUser )
    {
        /* Try to deliver this sample to the right pin */
        
        pIMediaSample->SetActualDataLength(dwTransfered);
    
        pIMediaSample->GetPointer(&buf);

#if USE_RTPPREFIX_HDRSIZE > 0

        /* Fill RTP prefix header */

        if (m_lPrefix >= sizeof(RtpPrefixHdr_t))
        {
            pRtpPrefixHdr = (RtpPrefixHdr_t *) (buf - m_lPrefix);

            pRtpPrefixHdr->wPrefixID = RTPPREFIXID_HDRSIZE;

            pRtpPrefixHdr->wPrefixLen = sizeof(RtpPrefixHdr_t);

            pRtpPrefixHdr->lHdrSize = lHdrSize;
        }

        pRtpHdr = (RtpHdr_t *)buf;
#else
        pRtpHdr = (RtpHdr_t *)buf;
#endif

        /* Set play time */
        if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_USEPLAYOUT) &&
            m_pClock)
        {
            bNewTalkSpurt = RtpBitTest(dwFlags, FGRECV_MARKER)? 1:0;
            
            pRtpNetRState = &pRtpUser->RtpNetRState;

            if (bNewTalkSpurt)
            {
                /* First packet in a talkspurt */

                hr = m_pClock->GetTime(&StartTime);

                if (SUCCEEDED(hr))
                {
                    StartTime -= m_tStart;

#if 0
                    /* I may adjust StartTime with the time elapsed
                     * since the packet for this talkspurt was
                     * received, but I'm not doing it because after
                     * all, if I got a significat delay from the tume
                     * the packet was received and the time we get
                     * here, I prefer to apply the playout delay from
                     * the current moment and not to reduce it because
                     * of this adjustment */
                    StartTime -= (LONGLONG)
                        ( (RtpGetTimeOfDay((RtpTime_t *)NULL) -
                           pRtpNetRState->dBeginTalkspurtTime) * (1e9/100.0) );
#endif
                    if (StartTime < m_StartTime)
                    {
                        TraceRetail((
                                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                                _T("%s: pRtpAddr[0x%p] Resyncing: ")
                                _T("StartTime:%I64d < m_StartTime:%I64d"),
                                _fname, pRtpAddr, StartTime, m_StartTime
                            ));
                        
                        StartTime = m_StartTime;
                    }
                    
                    pRtpNetRState->llBeginTalkspurt =
                        (LONGLONG)(StartTime + 5e-9);

                    RtpBitSet(pRtpNetRState->dwNetRStateFlags,
                              FGNETRS_TIMESET);
                }
                else
                {
                    pRtpNetRState->llBeginTalkspurt = 0;

                    RtpBitReset(pRtpNetRState->dwNetRStateFlags,
                              FGNETRS_TIMESET);

                    TraceRetail((
                            CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                            _T("%s: pRtpAddr[0x%p] GetTime failed: ")
                            _T("%u (0x%X)"),
                            _fname, pRtpAddr, hr, hr
                        ));
                }
            }

            if (RtpBitTest(pRtpNetRState->dwNetRStateFlags, FGNETRS_TIMESET))
            {
                /* Compute the start time (in units of 100ns) based on
                 * the play time */
                
                m_StartTime = pRtpNetRState->llBeginTalkspurt +
                    (LONGLONG) ((dPlayTime * (1e9/100.0)) + 5e-9);
                /* NOTE adding the 5e-9 to solve the problem of geting
                 * 699999.9999... when multiplying (0.07 * 1e7). Other
                 * multiplications also lead to same problem */

                /* Set End 1ms later (100ns units) */
                /* MAYDO if I have the samples per packet, I may also
                 * set the right end time */
                EndTime = m_StartTime + 10000;
                
                /* Set this sample's play time */
                hr = pIMediaSample->SetTime(&m_StartTime, &EndTime);

                if (FAILED(hr))
                {
                    TraceRetail((
                            CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                            _T("%s: pRtpAddr[0x%p] pIMediaSample[0x%p] ")
                            _T("SetTime failed: %u (0x%X)"),
                            _fname, pRtpAddr, pIMediaSample, hr, hr
                        ));
                }
#if 0
                else
                {
                    /* Print:

                       Start/s End/e llBeginTksprt dPlayTime  bNewTksprt
                    */
                    TraceRetail((
                            CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
                            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                            _T("pIMediaSample[0x%p,%d] @")
                            _T("%I64u/%u %I64u/%u %I64d %0.3f %u"),
                            _fname, pRtpAddr, pRtpUser,
                            pIMediaSample,
                            pIMediaSample->GetActualDataLength(),
                            (LONGLONG)m_StartTime,
                            ((CRefTime *)&m_StartTime)->Millisecs(),
                            (LONGLONG)EndTime,
                            ((CRefTime *)&EndTime)->Millisecs(),
                            (LONGLONG)pRtpNetRState->llBeginTalkspurt,
                            dPlayTime, bNewTalkSpurt
                        ));
                }
#endif
                
                /* Set discontinuity depending on the talkspurt */
                pIMediaSample->SetDiscontinuity(bNewTalkSpurt);
            }
        }
        
        if (pvUserInfo)
        {
            pCRtpOutputPin = (CRtpOutputPin *)((IPin *)pvUserInfo);
        }
        else
        {
            pCRtpOutputPin = (CRtpOutputPin *)NULL;
        }

        if (pCRtpOutputPin)
        {
            /* Deliver only if a pin has been assigned (mapped) */

#if USE_DYNGRAPH > 0
            // The pin may be not be active if the chain is just added.
            // I hate to access members of other object but there is no method.
            if (!pCRtpOutputPin->m_bActive)
            {
                hr = pCRtpOutputPin->Active();
                if (SUCCEEDED(hr))
                {
                    pCRtpOutputPin->
                        OutPinRecvCompletion(pIMediaSample, (BYTE)pRtpHdr->pt);
                }
            }
            else
#endif
            {
                if (pCRtpOutputPin->IsConnected())
                {
                    /* Deliver only if there is a down stream chain of
                     * filters. This test is needed because the
                     * subgraph may have been removed */
                    pCRtpOutputPin->
                        OutPinRecvCompletion(pIMediaSample, (BYTE)pRtpHdr->pt);
                }
            }
        }
    }

    /* MAYDO repost as to keep at least a certain number, need to keep
     * track of outstanding buffers to avoid GetDeliveryBuffer from
     * blocking. If the initial choice of number of buffers is right,
     * and the maximum number of buffers held is bound, this would not
     * be needed as there would be at least one outstanding or ready
     * to post (to WS2) buffer */
    
    if (!RtpBitTest2(dwFlags, FGRECV_ISRED, FGRECV_HOLD))
    {
        /* Check if I can repost the same buffer */
        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RUNRECV))
        {
            /* repost same buffer */
        
            WSABuf.len = pIMediaSample->GetSize();
            pIMediaSample->GetPointer((unsigned char **)&WSABuf.buf);

            /* register buffer for asynchronous I/O */
            hr = RtpRecvFrom(pRtpAddr,
                             &WSABuf,
                             this,
                             pIMediaSample);
    
            if (FAILED(hr))
            {
                pIMediaSample->Release();
                
                TraceRetail((
                        CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                        _T("%s: pRtpAddr[0x%p] ")
                        _T("RtpRecvFrom failed: %u (0x%X)"),
                        _fname, pRtpAddr,
                        hr, hr
                    ));
            }
        }
        else
        {
            pIMediaSample->Release();
            
            TraceRetail((
                    CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                    _T("%s: pRtpAddr[0x%p] ")
                    _T("Buffer not reposted FGADDR_RUNRECV not set"),
                    _fname, pRtpAddr
                ));
        }
    }
    else
    {
        /* If this sample contains redundancy, or is a frame being
         * played twice, that means the same sample will be posted to
         * DShow again in the future, at that time the buffer will be
         * either reposted to WS2 or released, but right now do
         * nothing (besides delivering down stream) */
    }
}

#if USE_GRAPHEDT <= 0
HRESULT CRtpSourceFilter::PayloadTypeToMediaType(
        IN DWORD         dwRTPPayloadType, 
        IN CMediaType   *pCMediaType,
        OUT DWORD       *pdwFrequency
        )
{
    DWORD            dw;

    TraceFunctionName("CRtpSourceFilter::PayloadTypeToMediaType");

    if (m_dwNumMediaTypeMappings == 0)
    {
        /* The only failure case is when there is no mappings set */
        return(RTPERR_INVALIDSTATE);
    }

    CAutoLock Lock( &m_cRtpSrcCritSec );
    
    /* Search for a matching mapping, if none is found, use as the
     * default 0 */
    for (dw = 0; dw < m_dwNumMediaTypeMappings; dw ++)
    {
        if (m_MediaTypeMappings[dw].dwRTPPayloadType == dwRTPPayloadType)
        {
            break;
        }
    }

    if (dw >= m_dwNumMediaTypeMappings)
    {
        /* If not found, use the first one */
        dw = 0;
        
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: CRtpSourceFilter[0x%p] ")
                _T("PT:%u not found, using default mapping: ")
                _T("PT:%u Frequency:%u"),
                _fname, this, dwRTPPayloadType,
                m_MediaTypeMappings[dw].dwRTPPayloadType,
                m_MediaTypeMappings[dw].dwFrequency
            ));
    }

    if (pCMediaType)
    {
        *pCMediaType = *m_MediaTypeMappings[dw].pMediaType;
        //CopyMediaType(pCMediaType, m_MediaTypeMappings[dw].pMediaType);
    }
            
    if (pdwFrequency)
    {
        *pdwFrequency = m_MediaTypeMappings[dw].dwFrequency;
    }
            
    return(NOERROR);
}
#endif

/* Find the CRtpOutputPin that has the interface IPin */
CRtpOutputPin *CRtpSourceFilter::FindIPin(IPin *pIPin)
{
    BOOL             bOk;
    RtpQueueItem_t  *pRtpQueueItem;
    CRtpOutputPin   *pCRtpOutputPin;
    long             lCount;

    TraceFunctionName("CRtpSourceFilter::FindIPin");

    if (m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        pCRtpOutputPin = (CRtpOutputPin *)NULL;
        
        bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

        if (bOk)
        {
            for(lCount = GetQueueSize(&m_OutPinsQ),
                    pRtpQueueItem = m_OutPinsQ.pFirst;
                lCount > 0;
                lCount--, pRtpQueueItem = pRtpQueueItem->pNext)
            {
                pCRtpOutputPin =
                    CONTAINING_RECORD(pRtpQueueItem,
                                      CRtpOutputPin,
                                      m_OutputPinQItem);
            
                if (pIPin == static_cast<IPin *>(pCRtpOutputPin))
                {
                    break;
                }
            }

            if (!lCount)
            {
                TraceRetail((
                        CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                        _T("%s: pRtpAddr[0x%p] ")
                        _T("Interface IPin[0x%p] does not belong ")
                        _T("to any of the %u output pins"),
                        _fname, m_pCIRtpSession->GetpRtpAddr(),
                        pIPin, GetQueueSize(&m_OutPinsQ)
                    ));
            
                pCRtpOutputPin = (CRtpOutputPin *)NULL;
            }

            RtpLeaveCriticalSection(&m_OutPinsCritSect);
        }
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: Not initialized yet"),
                _fname
            ));
        
        pCRtpOutputPin = (CRtpOutputPin *)NULL;
    }
    
    return(pCRtpOutputPin);
}

/* Associates an RtpOutput to every DShow pin that doesn't have an
 * RtpOutput yet */
HRESULT CRtpSourceFilter::MapPinsToOutputs()
{
    HRESULT          hr;
    BOOL             bOk;
    DWORD            dwError;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    CRtpOutputPin   *pCRtpOutputPin;
    DWORD            i;

    TraceFunctionName("CRtpSourceFilter::MapPinsToOutputs");

    hr = RTPERR_CRITSECT;
    
    bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

    if (bOk)
    {
        hr = NOERROR;
        
        lCount = GetQueueSize(&m_OutPinsQ);

        if (lCount > 0)
        {
            for(pRtpQueueItem = m_OutPinsQ.pFirst;
                lCount > 0;
                pRtpQueueItem = pRtpQueueItem->pNext, lCount--)
            {
                pCRtpOutputPin = CONTAINING_RECORD(pRtpQueueItem,
                                                   CRtpOutputPin,
                                                   m_OutputPinQItem);

                if (!pCRtpOutputPin->m_pRtpOutput)
                {
                    pCRtpOutputPin->m_pRtpOutput =
                        RtpAddOutput(m_pCIRtpSession->GetpRtpSess(),
                                     (pRtpQueueItem->dwKey >> 16) & 0xffff,
                                     (IPin *)pCRtpOutputPin,
                                     &dwError);

                    if (dwError)
                    {
                        hr = dwError;

                        TraceRetail((
                                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                                _T("%s: Failed to assign an RTP output ")
                                _T("to Pin[0x%p]:%d: %u (0x%X)"),
                                _fname, pCRtpOutputPin,
                                pRtpQueueItem->dwKey & 0xffff,
                                dwError, dwError
                            ));

                        continue;
                    }

                    /* If the pin is connected, enable the RTP output */
                    if (pCRtpOutputPin->IsConnected())
                    {
                        RtpOutputEnable(pCRtpOutputPin->m_pRtpOutput, TRUE);
                    }
                    
                    /* Remove from dwKey the OutMode leaving position */
                    pRtpQueueItem->dwKey &= 0xffff;
                 }
            }
        }

        /* Now update the PT<->Frequency mappings in RtpAddr_t */
        for(i = 0; i < m_dwNumMediaTypeMappings; i++)
        {
            AddPt2FrequencyMap(m_MediaTypeMappings[i].dwRTPPayloadType,
                               m_MediaTypeMappings[i].dwFrequency);
        }

        RtpLeaveCriticalSection(&m_OutPinsCritSect);
    }

    return(hr);
}

/* Dis-associates the RtpOutput from every DShow pin and intialize the
 * pins in such a way that the next call to MapPinsToOutputs will find
 * the right information to do the same association again
 */
/*
  Fail if the filter is running
 */
HRESULT CRtpSourceFilter::UnmapPinsFromOutputs()
{
    HRESULT          hr;
    BOOL             bOk;
    DWORD            dwError;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    CRtpOutputPin   *pCRtpOutputPin;
    RtpOutput_t     *pRtpOutput;
    DWORD            i;

    TraceFunctionName("CRtpSourceFilter::UnmapPinsFromOutputs");

    if (IsActive())
    {
        /* Fail if the filter is still active */
        hr = RTPERR_INVALIDSTATE;

        goto end;
    }
    
    hr = RTPERR_CRITSECT;
    
    bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

    if (bOk)
    {
        hr = NOERROR;

        lCount = GetQueueSize(&m_OutPinsQ);

        if (lCount > 0)
        {
            for(pRtpQueueItem = m_OutPinsQ.pFirst->pPrev;
                lCount > 0;
                pRtpQueueItem = pRtpQueueItem->pPrev, lCount--)
            {
                pCRtpOutputPin = CONTAINING_RECORD(pRtpQueueItem,
                                                   CRtpOutputPin,
                                                   m_OutputPinQItem);

                pRtpOutput = pCRtpOutputPin->m_pRtpOutput;

                if (pRtpOutput)
                {
                    /* Leave encoded in the DShow pin the mode and
                     * position for the next call to MapPinsToOutputs
                     * */
                    pCRtpOutputPin->m_OutputPinQItem.dwKey =
                        (pRtpOutput->iOutMode << 16) |
                        pCRtpOutputPin->m_OutputPinQItem.dwKey;

                    pCRtpOutputPin->m_pRtpOutput = (RtpOutput_t *)NULL;

                    RtpDelOutput(m_pCIRtpSession->GetpRtpSess(), pRtpOutput);
                }
            }
        }

        RtpLeaveCriticalSection(&m_OutPinsCritSect);
    }

 end:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: CRtpSourceFilter[0x%p] failed: %s (0x%X)"),
                _fname, this, RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

    

                    
 
HRESULT CRtpSourceFilter::AddPt2FrequencyMap(
            DWORD        dwPt,
            DWORD        dwFrequency
    )
{
    HRESULT          hr;
    BOOL             bOk;
    RtpAddr_t       *pRtpAddr;
    
    hr = RTPERR_CRITSECT;
    
    bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

    if (bOk)
    {
        hr = NOERROR;

        /* Update only if already initialized */
        if (m_pRtpAddr)
        {
            hr = RtpAddPt2FrequencyMap(m_pRtpAddr,
                                       dwPt,
                                       dwFrequency,
                                       RECV_IDX);
        }
        
        RtpLeaveCriticalSection(&m_OutPinsCritSect);
    }

    return(hr);
}

/**************************************************
 * IRtpRedundancy implemented methods
 **************************************************/

/* Configures redundancy parameters */
STDMETHODIMP CRtpSourceFilter::SetRedParameters(
        DWORD            dwPT_Red, /* Payload type for redundant packets */
        DWORD            dwInitialRedDistance,/* Initial redundancy distance*/
        DWORD            dwMaxRedDistance /* default used when passing 0 */
    )
{
    HRESULT          hr;

    TraceFunctionName("CRtpSourceFilter::SetRedParameters");  

    hr = RTPERR_NOTINIT;
    
    if (m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetRedParameters(m_pRtpAddr,
                                 RtpBitPar(RECV_IDX),
                                 dwPT_Red,
                                 dwInitialRedDistance,
                                 dwMaxRedDistance);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }
    
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\msrtpapi.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    msrtpapi.h
 *
 *  Abstract:
 *
 *    Microsoft RTP API (not a DShow API)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#ifndef _msapi_h_
#define _msapi_h_

#include <rtpinit.h>
#include "gtypes.h"
#include "struct.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

RTPSTDAPI CreateRtpSess(
        RtpSess_t      **ppRtpSess
    );

RTPSTDAPI DeleteRtpSess(
        RtpSess_t       *pRtpSess
    );

RTPSTDAPI CreateRtpAddr(
        RtpSess_t       *pRtpSess,
        RtpAddr_t      **ppRtpAddr,
        DWORD            dwFlags
    );

RTPSTDAPI DeleteRtpAddr(
        RtpSess_t       *pRtpSess,
        RtpAddr_t       *pRtpAddr
    );

RTPSTDAPI RtpControl(
        RtpSess_t       *pRtpSess,
        DWORD            dwControl,
        DWORD_PTR        dwPar1,
        DWORD_PTR        dwPar2
    );

RTPSTDAPI RtpGetLastError(
        RtpSess_t       *pRtpSess
    );

RTPSTDAPI RtpRegisterRecvCallback(
        RtpAddr_t       *pRtpAddr,
        PRTP_RECVCOMPLETIONFUNC pRtpRecvCompletionFunc
    );

RTPSTDAPI RtpRecvFrom(
        RtpAddr_t       *pRtpAddr,
        WSABUF          *pWSABuf,
        void            *pvUserInfo1,
        void            *pvUserInfo2
    );

RTPSTDAPI RtpSendTo(
        RtpAddr_t       *pRtpAddr,
        WSABUF          *pWSABuf,
        DWORD            dwWSABufCount,
        DWORD            dwTimeStamp,
        DWORD            dwSendFlags
    );

RTPSTDAPI RtpStart(
        RtpSess_t       *pRtpSess,
        DWORD            dwFlags
    );

RTPSTDAPI RtpStop(
        RtpSess_t       *pRtpSess,
        DWORD            dwFlags
    );


#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _msapi_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtcpint.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpint.h
 *
 *  Abstract:
 *
 *    Computes the RTCP report interval time
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/12/07 created
 *
 **********************************************************************/

#ifndef _rtcpint_h_
#define _rtcpint_h_

#include "struct.h"

double RtcpNextReportInterval(RtpAddr_t *pRtpAddr);

#endif /* _rtcpint_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtcpband.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpband.h
 *
 *  Abstract:
 *
 *    Main data structures
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2001/01/31 created
 *
 **********************************************************************/
#ifndef _rtcpband_h_
#define _rtcpband_h_

/* Bandwidth estimation */

/* The initial count is the number of reports that will use
 * MOD_INITIAL to decide if a probe packet is sent, after that
 * MOD_FINAL will be used. */
extern DWORD            g_dwRtcpBandEstInitialCount;

/* Number or valid reports received before the estimation is posted
 * for the first time */
extern DWORD            g_dwRtcpBandEstMinReports;

/* Initial modulo */
extern DWORD            g_dwRtcpBandEstModInitial;

/* Final modulo */
extern DWORD            g_dwRtcpBandEstModNormal;

/*
 * WARNING
 *
 * Make sure to keep the number of individual bins to be
 * RTCP_BANDESTIMATION_MAXBINS+1 (same thing in rtpreg.h and rtpreg.c)
 *
 * Boundaries for each bin (note there is 1 more than the number of
 * bins) */
extern double           g_dRtcpBandEstBin[];

/* Estimation is valid if updated within this time (seconds) */
extern double           g_dRtcpBandEstTTL;

/* An event is posted if no estimation is available within this
 * seconds after the first RB has been received */
extern double           g_dRtcpBandEstWait;

/* Maximum time gap between 2 consecutive RTCP SR reports to do
 * bandwidth estimation (seconds) */
extern double           g_dRtcpBandEstMaxGap;

#endif /* _rtcpband_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtcpthrd.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpthrd.h
 *
 *  Abstract:
 *
 *    RTCP thread
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/07 created
 *
 **********************************************************************/

#ifndef _rtcpthrd_h_
#define _rtcpthrd_h_

#include "struct.h"
#include "rtpque.h"

/* Commands a RTCP worker thread accepts.
 *
 * WARNING
 *
 * This enum must match the entries in g_psRtcpThreadCommands in
 * rtcpthrd.c
 * */
typedef enum {
    RTCPTHRD_FIRST = 100,
    
    RTCPTHRD_ADDADDR,   /* Add 1 address */
    RTCPTHRD_DELADDR,   /* Remove 1 address */
    RTCPTHRD_RESERVE,   /* Do a QOS reservation */
    RTCPTHRD_UNRESERVE, /* Undo a QOS reservation */
    RTCPTHRD_SENDBYE,   /* Send RTCP BYE and may be Shutdown */
    RTCPTHRD_EXIT,      /* Exit thread */

    RTCPTHRD_LAST
} RTCPTHRD_e;

/**************************************************/
#if USE_RTCP_THREAD_POOL > 0

typedef enum {
    RTCPPOOL_FIRST = 200,

    RTCPPOOL_RTCPRECV,  /* RTCP packet received (RECV I/O completed) */
    RTCPPOOL_QOSNOTIFY, /* QOS notification (I/O completed) */

    RTCPPOOL_LAST
} RTCPOOL_e;

#define RTCP_HANDLE_OFFSET  2    /* number of handles for private use */
#define RTCP_HANDLE_SIZE    0    /* number of handles per session */
/* max number of sessions */
#define RTCP_MAX_DESC       512

#define RTCP_NUM_OF_HANDLES 2

/**************************************************/
#else /* USE_RTCP_THREAD_POOL > 0 */

/*
 * The Event handles vector for each RTCP thread is organized as
 * follows:
 *
 * 1. A number of handles for private use, e.g. to receive commands
 * (currently 1)
 *
 * 2. A set of per descriptor events (currently 2, RTCP recv, and QOS
 * notifications)
 *
 * Each descriptor has an index that positions it at vector
 * ppRtcpAddrDesc. I.e. index has values 0, 1, 2, ...
 * */

#define RTCP_HANDLE_OFFSET  1    /* number of handles for private use */
#define RTCP_HANDLE_SIZE    2    /* number of handles per session */
/* max number of sessions */
#define RTCP_MAX_DESC       ((MAXIMUM_WAIT_OBJECTS - RTCP_HANDLE_OFFSET) / \
                             RTCP_HANDLE_SIZE)

#define RTCP_NUM_OF_HANDLES \
              (RTCP_HANDLE_OFFSET + RTCP_MAX_DESC * RTCP_HANDLE_SIZE)

/**************************************************/
#endif /* USE_RTCP_THREAD_POOL > 0 */

typedef struct _RtcpContext_t {
    DWORD            dwObjectID;
    RtpCritSect_t    RtcpContextCritSect;
    
    /* RtcpAddrDesc items */
    RtpQueue_t       AddrDescFreeQ; /* Free AddrDesc items */
    RtpQueue_t       AddrDescBusyQ; /* In use AddrDesc items */
    RtpQueue_t       AddrDescStopQ; /* Those who are just waiting for
                                    * their I/O to complete to be moved
                                    * to FreeQ */
    /* QOS notifications */
    RtpQueue_t       QosStartQ;     /* To be started descriptors */
    RtpQueue_t       QosBusyQ;      /* Active descriptors */
    RtpQueue_t       QosStopQ;      /* Stopped descriptors */

    /* RTCP reports sending */
    RtpQueue_t       SendReportQ;   /* Ordered AddrDesc list (in use) */

    /* RTCP thread */
    HANDLE           hRtcpContextThread;
    DWORD            dwRtcpContextThreadID;
    long             lRtcpUsers;

    RtpChannel_t     RtcpThreadCmdChannel;
    
#if USE_RTCP_THREAD_POOL > 0
    RtpChannel_t     RtcpThreadIoChannel;
    /* Event handles and RTCP address descriptors */
    DWORD            dwMaxDesc;/* Number of next descriptor to add (or
                                * current number of descriptors), not
                                * handles */
    HANDLE           pHandle[RTCP_NUM_OF_HANDLES];
#else /* USE_RTCP_THREAD_POOL > 0 */
    /* Event handles and RTCP address descriptors */
    DWORD            dwMaxDesc;/* Number of next descriptor to add (or
                                * current number of descriptors), not
                                * handles */
    HANDLE           pHandle[RTCP_NUM_OF_HANDLES];
    RtcpAddrDesc_t  *ppRtcpAddrDesc[RTCP_MAX_DESC];
#endif /* USE_RTCP_THREAD_POOL > 0 */
} RtcpContext_t;

extern RtcpContext_t g_RtcpContext;

/*
 * Do minimal global initialization for RTCP
 * */
HRESULT RtcpInit(void);

/*
 * Do last global de-initialization for RTCP
 * */
HRESULT RtcpDelete(void);

/*
 * Start the RTCP thread
 * */
HRESULT RtcpStart(RtcpContext_t *pRtcpContext);

/*
 * Stop the RTCP thread
 * */
HRESULT RtcpStop(RtcpContext_t *pRtcpContext);

/*
 * Send a command to the RTCP thread
 * */
HRESULT RtcpThreadCmd(
        RtcpContext_t   *pRtcpContext,
        RtpAddr_t       *pRtpAddr,
        RTCPTHRD_e       eCommand,
        DWORD            dwParam,
        DWORD            dwWaitTime
    );

/*
 * Decide if we need to drop this packet or we have a collision
 * */
BOOL RtpDropCollision(
        RtpAddr_t       *pRtpAddr,
        SOCKADDR_IN     *pSockAddrIn,
        BOOL             bRtp
    );

#endif /* _rtcpthrd_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtcpsend.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpsend.h
 *
 *  Abstract:
 *
 *    Format and send RTCP reports
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/10 created
 *
 **********************************************************************/

#ifndef _rtcpsend_h_
#define _rtcpsend_h_

#include "struct.h"

#define SDES_MOD_L1 2
#define SDES_MOD_L2 4
#define SDES_MOD_L3 2

HRESULT RtcpSendReport(RtcpAddrDesc_t *pRtcpAddrDesc);

HRESULT RtcpSendBye(RtcpAddrDesc_t *pRtcpAddrDesc);

RtcpSendIO_t *RtcpSendIOAlloc(RtcpAddrDesc_t *pRtcpAddrDesc);

void RtcpSendIOFree(RtcpSendIO_t *pRtcpSendIO);

double RtcpUpdateAvgPacketSize(RtpAddr_t *pRtpAddr, DWORD dwPacketSize);

#endif /* _rtcpsend_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtcpdec.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpdec.h
 *
 *  Abstract:
 *
 *    Decode RTCP packets
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/08 created
 *
 **********************************************************************/

#ifndef _rtcpdec_h_
#define _rtcpdec_h_

#include "struct.h"

DWORD RtcpProcessSR_RR(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr,
        int              packetsize,
        SOCKADDR_IN     *FromIn
    );

DWORD RtcpProcessSDES(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    );

DWORD RtcpProcessBYE(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    );

DWORD RtcpProcessAPP(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    );

DWORD RtcpProcessDefault(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtcprecv.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcprecv.h
 *
 *  Abstract:
 *
 *    Asynchronous RTCP packet reception
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/07 created
 *
 **********************************************************************/

#ifndef _rtcprecv_h_
#define _rtcprecv_h_

#include "struct.h"
#include "rtcpthrd.h"

HRESULT StartRtcpRecvFrom(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

HRESULT ConsumeRtcpRecvFrom(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

RtcpRecvIO_t *RtcpRecvIOAlloc(
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

void RtcpRecvIOFree(
        RtcpRecvIO_t    *pRtcpRecvIO
    );

#endif /* _rtcprecv_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtcpsdes.h ===
/**********************************************************************
 *
 *  Copyright (C) 1999 Microsoft Corporation
 *
 *  File name:
 *
 *    rtcpsdes.h
 *
 *  Abstract:
 *
 *    SDES support functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/13 created
 *
 **********************************************************************/

#ifndef _rtcpsdes_h_
#define _rtcpsdes_h_

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

#include "struct.h"

#define  RTPSDES_LOCAL_DEFAULT ( \
                                 (1 << RTPSDES_CNAME) | \
                                 (1 << RTPSDES_NAME)  | \
                                 (1 << RTPSDES_EMAIL) | \
                                 (1 << RTPSDES_PHONE) | \
                                 (1 << RTPSDES_LOC)   | \
                                 (1 << RTPSDES_TOOL)  | \
                                 (1 << RTPSDES_NOTE)  | \
                                 (1 << RTPSDES_PRIV)  | \
                                  0 )

#define  RTPSDES_REMOTE_DEFAULT ( \
                                 (1 << RTPSDES_CNAME) | \
                                 (1 << RTPSDES_NAME)  | \
                                 (1 << RTPSDES_EMAIL) | \
                                 (1 << RTPSDES_PHONE) | \
                                 (1 << RTPSDES_LOC)   | \
                                 (1 << RTPSDES_TOOL)  | \
                                 (1 << RTPSDES_NOTE)  | \
                                 (1 << RTPSDES_PRIV)  | \
                                  0 )

#define RTPSDES_EVENT_RECV_DEFAULT 0

#define RTPSDES_EVENT_SEND_DEFAULT 0

extern const TCHAR_t   *g_psSdesNames[];
extern RtpSdes_t        g_RtpSdesDefault;

/* Initialize to zero and compute the data pointers */
void RtcpSdesInit(RtpSdes_t *pRtpSdes);

/*
 * Sets a specific SDES item, expects a NULL terminated UNICODE string
 * no bigger than 255 bytes when converted to UTF-8 (including the
 * NULL terminating character). The string is converted to UTF-8 to be
 * stored and used in RTCP reports.
 *
 * Returns the mask of the item set or 0 if none
 * */
DWORD RtcpSdesSetItem(
        RtpSdes_t       *pRtpSdes,
        DWORD            dwItem,
        WCHAR           *pData
    );

/* Obtain default values for the RTCP SDES items. This function
 * assumes the structure was initialized, i.e. zeroed and the data
 * pointers properly initialized.
 *
 * Data is first read from the registry and then defaults are set for
 * some items that don't have value yet
 *
 * Return the mask of items that where set */
DWORD RtcpSdesSetDefault(RtpSdes_t *pRtpSdes);

/* Creates and initializes a RtpSdes_t structure */
RtpSdes_t *RtcpSdesAlloc(void);

/* Frees a RtpSdes_t structure */
void RtcpSdesFree(RtpSdes_t *pRtpSdes);

/* Set the local SDES info for item dwSdesItem (e.g RTPSDES_CNAME,
 * RTPSDES_EMAIL), psSdesData contains the NUL terminated UNICODE
 * string to be assigned to the item */
HRESULT RtpSetSdesInfo(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSdesItem,
        WCHAR           *psSdesData
    );

/* Get a local SDES item if dwSSRC=0, otherwise gets the SDES item
 * from the participant whose SSRC was specified.
 *
 * dwSdesItem is the item to get (e.g. RTPSDES_CNAME, RTPSDES_EMAIL),
 * psSdesData is the memory place where the item's value will be
 * copied, pdwSdesDataLen contains the initial size in UNICODE chars,
 * and returns the actual UNICODE chars copied (including the NULL
 * terminating char), dwSSRC specify which participant to retrieve the
 * information from. If the SDES item is not available, dwSdesDataLen
 * is set to 0 and the call doesn't fail */
HRESULT RtpGetSdesInfo(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSdesItem,
        WCHAR           *psSdesData,
        DWORD           *pdwSdesDataLen,
        DWORD            dwSSRC
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtcpsdes_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpaddr.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpaddr.h
 *
 *  Abstract:
 *
 *    Implements the Address family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/01 created
 *
 **********************************************************************/

#ifndef _rtpaddr_h_
#define _rtpaddr_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Address functions family
 *
 **********************************************************************/

enum {
    RTPADDR_FIRST,
    RTPADDR_CREATE,     /* Create/Delete */
    RTPADDR_DEFAULT,    /* Default address */
    RTPADDR_RTP,        /* RTP address/port */
    RTPADDR_RTCP,       /* RTCP address/port */
    RTPADDR_TTL,        /* Time To Live */
    RTPADDR_MULTICAST_LOOPBACK, /* Multicast loopback */
    RTPADDR_LAST
};

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

HRESULT ControlRtpAddr(RtpControlStruct_t *pRtpControlStruct);

HRESULT RtpGetPorts(
        RtpAddr_t       *pRtpAddr,
        WORD            *pwRtpLocalPort,
        WORD            *pwRtpRemotePort,
        WORD            *pwRtcpLocalPort,
        WORD            *pwRtcpRemotePort
    );

HRESULT RtpSetPorts(
        RtpAddr_t       *pRtpAddr,
        WORD             wRtpLocalPort,
        WORD             wRtpRemotePort,
        WORD             wRtcpLocalPort,
        WORD             wRtcpRemotePort
    );

HRESULT RtpSetAddress(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwLocalAddr,
        DWORD            dwRemoteAddr
    );
    
HRESULT RtpGetAddress(
        RtpAddr_t       *pRtpAddr,
        DWORD           *pdwLocalAddr,
        DWORD           *pdwRemoteAddr
    );

HRESULT RtpGetSockets(RtpAddr_t *pRtpAddr);

HRESULT RtpDelSockets(RtpAddr_t *pRtpAddr);

void RtpSetSockOptions(RtpAddr_t *pRtpAddr);

DWORD RtpSetRecvBuffSize(
        RtpAddr_t       *pRtpAddr,
        SOCKET           Socket,
        int              iBuffSize
    );

HRESULT RtpSetMcastLoopback(
        RtpAddr_t       *pRtpAddr,
        int              iMcastLoopbackMode,
        DWORD            dwFlags /* Not used now */
    );

HRESULT RtpNetMute(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags
    );

HRESULT RtpNetUnmute(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#endif /* _rtpaddr_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpcrit.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpcrit.h
 *
 *  Abstract:
 *
 *    Wrap for the Rtl critical sections
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/24 created
 *
 **********************************************************************/

#ifndef _rtpcrit_h_
#define _rtpcrit_h_

#include "gtypes.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/* TODO (may be) add an object ID and test for it */
typedef struct _RtpCritSect_t {
    DWORD             dwObjectID; /* Object ID */
    void             *pvOwner; /* pointer to the owner */
    TCHAR            *pName;   /* Critical section's name */
    CRITICAL_SECTION  CritSect;/* critical section */
} RtpCritSect_t;

BOOL RtpInitializeCriticalSection(
        RtpCritSect_t   *pRtpCritSect,
        void            *pvOwner,
        TCHAR           *pName
    );

BOOL RtpDeleteCriticalSection(RtpCritSect_t *pRtpCritSect);

BOOL RtpEnterCriticalSection(RtpCritSect_t *pRtpCritSect);

BOOL RtpLeaveCriticalSection(RtpCritSect_t *pRtpCritSect);

#define IsRtpCritSectInitialized(pRtpCritSect) \
        ((pRtpCritSect)->dwObjectID == OBJECTID_RTPCRITSECT)

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpcrit_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpcrypt.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpcrypt.h
 *
 *  Abstract:
 *
 *    Implements the Cryptography family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtpcrypt_h_
#define _rtpcrypt_h_

#include "struct.h"

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Cryptographic services family
 *
 **********************************************************************/

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/* TODO delete this (obsolete) */
enum {
    RTPCRYPT_FIRST,
    RTPCRYPT_KEY,
    RTPCRYPT_PROVIDER,
    RTPCRYPT_ALGORITHM,
    RTPCRYPT_PASS_PHRASE,
    RTPCRYPT_CRYPT_MASK,
    RTPCRYPT_TEST_CRYPT_MASK,
    RTPCRYPT_LAST
};

HRESULT ControlRtpCrypt(RtpControlStruct_t *pRtpControlStruct);

DWORD RtpCryptSetup(RtpAddr_t *pRtpAddr);
DWORD RtpCryptCleanup(RtpAddr_t *pRtpAddr);

DWORD RtpCryptInit(RtpAddr_t *pRtpAddr, RtpCrypt_t *pRtpCrypt);
DWORD RtpCryptDel(RtpAddr_t *pRtpAddr, RtpCrypt_t *pRtpCrypt);

DWORD RtpEncrypt(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt,
        WSABUF          *pWSABuf,
        DWORD            dwWSABufCount,
        char            *pCryptBuffer,
        DWORD            dwCryptBufferLen
    );

DWORD RtpDecrypt(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt,
        char            *pEncryptedData,
        DWORD           *pdwEncryptedDataLen
    );

DWORD RtpSetEncryptionMode(
        RtpAddr_t       *pRtpAddr,
        int              iMode,
        DWORD            dwFlags
        );

DWORD RtpSetEncryptionKey(
        RtpAddr_t       *pRtpAddr,
        TCHAR           *psPassPhrase,
        TCHAR           *psHashAlg,
        TCHAR           *psDataAlg,
        DWORD            dwIndex
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpcrypt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpchan.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpchan.h
 *
 *  Abstract:
 *
 *    Implements a communication channel between the RTCP thread
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/08 created
 *
 **********************************************************************/

#ifndef _rtpchan_h_
#define _rtpchan_h_

#include "gtypes.h"
#include "rtpque.h"
#include "rtpcrit.h"

/*
 * The steps to use a channel are:
 *
 * 1. Send command with RtpChannelSend()
 *
 * 2. The thread (that waited on the channel) is awakened and gets the
 * command with RtpChannelGetCmd()
 *
 * 4. The thread makes any use it wants of the command
 *
 * 5. The thread aknowledges the command with RtpChannelAck()
 *
 * NOTE: The RtPChannelCmd_t structures are allocated from a global
 * heap
 * */


/* Some flags in RtpChanCmd_t.dwFalsgs */
enum {
    FGCHAN_FIRST,
    FGCHAN_SYNC,   /* Synchronize response */
    FGCHAN_LAST
};

typedef struct _RtpChannel_t {
    RtpQueue_t     FreeQ;
    RtpQueue_t     CommandQ;
    RtpCritSect_t  ChannelCritSect;
    HANDLE         hWaitEvent;      /* Thread waits for commands on
                                     * this event */
} RtpChannel_t;

typedef struct _RtpChannelCmd_t {
    DWORD           dwObjectID;     /* Identifies structure */
    RtpQueueItem_t  QueueItem;
    HANDLE          hSyncEvent;     /* Synchronize sender when the
                                     * command is consummed */
    DWORD           dwCommand;
    DWORD_PTR       dwPar1;
    DWORD_PTR       dwPar2;
    DWORD           dwFlags;
    HRESULT         hr;
} RtpChannelCmd_t;

#define IsRtpChannelInitialized(pCh) \
(IsRtpCritSectInitialized(&(pCh)->ChannelCritSect))

#define RtpChannelGetWaitEvent(pCh) ((pCh)->hWaitEvent)

/*
 * Initialization
 * */

/* Initializes a channel */
HRESULT RtpChannelInit(
        RtpChannel_t    *pRtpChannel,
        void            *pvOwner
    );

/* De-initializes a channel */
HRESULT RtpChannelDelete(
        RtpChannel_t    *pRtpChannel
    );

/*
 * Usage
 * */

/* Send a command to the specified channel. Wait for completion if
 * requested. The HRESULT returned is either a local failure, or the
 * result passed back from the thread if synchronous (wait time > 0)
 * */
HRESULT RtpChannelSend(
        RtpChannel_t    *pRtpChannel,
        DWORD            dwCommand,
        DWORD_PTR        dwPar1,
        DWORD_PTR        dwPar2,
        DWORD            dwWaitTime
    );

/* Once a waiting thread is awakened, it get the sent comman(s) with
 * this function */
RtpChannelCmd_t *RtpChannelGetCmd(
        RtpChannel_t    *pRtpChannel
    );

/* Used by the consumer thread to acknowledge received commands */
HRESULT RtpChannelAck(
        RtpChannel_t    *pRtpChannel,
        RtpChannelCmd_t *pRtpChannelCmd,
        HRESULT          hr
    );

#endif /* _rtpchan_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpdemux.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpdemux.h
 *
 *  Abstract:
 *
 *    Implements the Demultiplexing family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtpdemux_h_
#define _rtpdemux_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Demultiplexing services family
 *
 **********************************************************************/

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/* functions */
enum {
    RTPDEMUX_FIRST,
    RTPDEMUX_LAST
};

HRESULT ControlRtpDemux(RtpControlStruct_t *pRtpControlStruct);

/**********************************************************************
 * Users <-> Outputs assignment
 **********************************************************************/

RtpOutput_t *RtpAddOutput(
        RtpSess_t       *pRtpSess,
        int              iOutMode,
        void            *pvUserInfo,
        DWORD           *pdwError
    );

DWORD RtpDelOutput(
        RtpSess_t       *pRtpSess,
        RtpOutput_t     *pRtpOutput
    );

DWORD RtpSetOutputMode(
        RtpSess_t       *pRtpSess,
        int              iPos,
        RtpOutput_t     *pRtpOutput,
        int              iOutMode
    );

DWORD RtpOutputState(
        RtpAddr_t       *pRtpAddr,
        int              iPos,
        RtpOutput_t     *pRtpOutput,
        DWORD            dwSSRC,
        BOOL             bAssigned
    );

DWORD RtpUnmapAllOuts(
        RtpSess_t       *pRtpSess
    );

DWORD RtpFindOutput(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSSRC,
        int             *piPos,
        void           **ppvUserInfo
    );

DWORD RtpFindSSRC(
        RtpAddr_t       *pRtpAddr,
        int              iPos,
        RtpOutput_t     *pRtpOutput,
        DWORD           *pdwSSRC
    );

        
RtpOutput_t *RtpOutputAlloc(void);

RtpOutput_t *RtpOutputFree(RtpOutput_t *pRtpOutput);

RtpOutput_t *RtpGetOutput(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser
    );

DWORD RtpSetOutputMode_(
        RtpOutput_t     *pRtpOutput,
        int              iOutMode
    );

DWORD RtpOutputAssign(
        RtpSess_t       *pRtpSess,
        RtpUser_t       *pRtpUser,
        RtpOutput_t     *pRtpOutput
    );

DWORD RtpOutputUnassign(
        RtpSess_t       *pRtpSess,
        RtpUser_t       *pRtpUser,
        RtpOutput_t     *pRtpOutput
    );

DWORD RtpAddPt2FrequencyMap(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwPt,
        DWORD            dwFrequency,
        DWORD            dwRecvSend
    );

BOOL RtpLookupPT(
        RtpAddr_t       *pRtpAddr,
        BYTE             bPT
    );

DWORD RtpMapPt2Frequency(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        DWORD            dwPt,
        DWORD            dwRecvSend
    );

DWORD RtpFlushPt2FrequencyMaps(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    );

DWORD RtpOutputEnable(
        RtpOutput_t     *pRtpOutput,
        BOOL             bEnable
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpdemux_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpdejit.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpdejit.h
 *
 *  Abstract:
 *
 *    Compute delay, jitter and playout delay
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/12/03 created
 *
 **********************************************************************/

#ifndef _rtpdejit_h_
#define _rtpdejit_h_

#include "struct.h"

void RtpInitNetRState(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr, double Ai);

void RtpOnFirstPacket(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr, double Ai);

void RtpPrepareForMarker(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr, double Ai);

void RtpPrepareForShortDelay(RtpUser_t *pRtpUser, long lCount);

DWORD RtpUpdateNetRState(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpHdr_t        *pRtpHdr,
        RtpRecvIO_t     *pRtpRecvIO
    );

extern double           g_dMinPlayout;
extern double           g_dMaxPlayout;

#endif /* _rtpdejit_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpdbg.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpdbg.h
 *
 *  Abstract:
 *
 *    Debug support
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/07 created
 *
 **********************************************************************/

#ifndef _rtpdbg_h_
#define _rtpdbg_h_

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

extern const TCHAR *g_psSockIdx[];

void MSRtpTraceDebug(
        IN DWORD         dwClass,
        IN DWORD         dwGroup,
        IN DWORD         dwSelection,
        IN TCHAR        *lpszFormat,
        IN               ...
    );

#define TraceFunctionName(_Name)      static TCHAR_t *_fname = _T(_Name)
#define TraceRetailGetError(error)    (error = GetLastError())
#define TraceRetailWSAGetError(error) (error = WSAGetLastError())
/* Trace support for free AND debug versions */
#define TraceRetail(arg)              MSRtpTraceDebug arg
#define TraceRetailAdvanced(arg)      if (IsAdvancedTracingUsed()) \
                                      {\
                                          MSRtpTraceDebug arg ;\
                                      }

#define IsAdvancedTracingUsed()       (g_RtpDbgReg.dwUseAdvancedTracing)

#if DBG > 0
/**********************************************************************
 * DEBUG BUILD ONLY macros
 **********************************************************************/
#define RTPASSERT(x)                  {if (!(x)) DebugBreak();}
#define TraceDebugGetError(error)     TraceRetailGetError(error)
#define TraceDebugWSAGetError(error)  TraceRetailWSAGetError(error)
#define TraceDebug(arg)               TraceRetail(arg)
#define TraceDebugAdvanced(arg)       TraceRetailAdvanced(arg)

#else   /* DBG > 0 */
/**********************************************************************
 * FREE BUILD ONLY macros
 **********************************************************************/
#define RTPASSERT(x)

#if USE_TRACE_DEBUG > 0
#define TraceDebugGetError(error)     TraceRetailGetError(error)
#define TraceDebugWSAGetError(error)  TraceRetailWSAGetError(error)
#define TraceDebug(arg)               TraceRetailAdvanced(arg)
#define TraceDebugAdvanced(arg)       TraceRetailAdvanced(arg)
#else /* USE_TRACE_DEBUG > 0 */
#define TraceDebugGetError(error)
#define TraceDebugWSAGetError(error)
#define TraceDebug(arg)
#define TraceDebugAdvanced(arg)
#endif /* USE_TRACE_DEBUG > 0 */

#endif /* DBG > 0 */


#define RTPDBG_MODULENAME      _T("dxmrtp_rtp")

HRESULT RtpDebugInit(TCHAR *psModuleName);

HRESULT RtpDebugDeinit(void);

/*
 * WARNING
 *
 * Modifying CLASSES needs to keep matched the enum CLASS_*
 * (rtpdbg.h), the variables in RtpDbgReg_t (rtpdbg.h), the class
 * items in g_psRtpDbgInfo (rtpdbg.c) and its respective entries
 * g_dwRtpDbgRegCtrl (rtpdbg.c), as well as the printed class name
 * g_psRtpDbgClass (rtpdbg.c)
 * */
/* Class */
#define CLASS_FIRST            0
#define CLASS_ERROR            1
#define CLASS_WARNING          2
#define CLASS_INFO             3
#define CLASS_INFO2            4
#define CLASS_INFO3            5
#define CLASS_LAST             6

/*
 * WARNING
 *
 * For each group, there MUST be a variable in RtpDbgReg_t, and a name
 * (in rtpdbg.c/g_psRtpDbgInfo) to read its value from the registry
 * */
#define GROUP_FIRST            0
#define GROUP_SETUP            1
#define GROUP_CRITSECT         2
#define GROUP_HEAP             3
#define GROUP_QUEUE            4
#define GROUP_RTP              5
#define GROUP_RTCP             6
#define GROUP_CHANNEL          7
#define GROUP_NETWORK          8
#define GROUP_ADDRDESC         9
#define GROUP_DEMUX            10
#define GROUP_USER             11
#define GROUP_DSHOW            12
#define GROUP_QOS              13
#define GROUP_CRYPTO           14
#define GROUP_LAST             15

/* Selections for each group */

#define S_SETUP_SESS           0x00000001
#define S_SETUP_ADDR           0x00000002
#define S_SETUP_GLOB           0x00000004

#define S_CRITSECT_INIT        0x00000001
#define S_CRITSECT_ENTER       0x00000002

#define S_HEAP_INIT            0x00000001
#define S_HEAP_ALLOC           0x00000002
#define S_HEAP_FREE            0x00000004

#define S_QUEUE_ENQUEUE        0x00000001
#define S_QUEUE_DEQUEUE        0x00000002
#define S_QUEUE_MOVE           0x00000004

#define S_RTP_INIT             0x00000001
#define S_RTP_TRACE            0x00000002
#define S_RTP_REG              0x00000004
#define S_RTP_START            0x00000008
#define S_RTP_RECV             0x00000010
#define S_RTP_SEND             0x00000020
#define S_RTP_EVENT            0x00000040
#define S_RTP_PLAYOUT          0x00000100
#define S_RTP_DTMF             0x00000200
#define S_RTP_THREAD           0x00000400
#define S_RTP_REDINIT          0x00000800
#define S_RTP_REDRECV          0x00001000
#define S_RTP_REDSEND          0x00002000
#define S_RTP_REDRECVPKT       0x00004000
#define S_RTP_REDSENDPKT       0x00008000
#define S_RTP_REDSENDPERPKT1   0x00010000
#define S_RTP_REDSENDPERPKT2   0x00020000
#define S_RTP_SETBANDWIDTH     0x00040000
#define S_RTP_PERPKTSTAT1      0x00100000
#define S_RTP_PERPKTSTAT2      0x00200000
#define S_RTP_PERPKTSTAT3      0x00400000
#define S_RTP_PERPKTSTAT4      0x00800000
#define S_RTP_PERPKTSTAT5      0x01000000
#define S_RTP_PERPKTSTAT6      0x02000000
#define S_RTP_PERPKTSTAT7      0x04000000
#define S_RTP_PERPKTSTAT8      0x08000000
#define S_RTP_PERPKTSTAT9      0x10000000

#define S_RTCP_INIT            0x00000001
#define S_RTCP_CHANNEL         0x00000002
#define S_RTCP_CMD             0x00000004
#define S_RTCP_OBJECT          0x00000008
#define S_RTCP_SI              0x00000010
#define S_RTCP_RB              0x00000020
#define S_RTCP_RECV            0x00000040
#define S_RTCP_SEND            0x00000080
#define S_RTCP_SDES            0x00000100
#define S_RTCP_BYE             0x00000200
#define S_RTCP_THREAD          0x00000400
#define S_RTCP_TIMEOUT         0x00000800
#define S_RTCP_ALLOC           0x00001000
#define S_RTCP_RAND            0x00002000
#define S_RTCP_RTT             0x00004000
#define S_RTCP_NTP             0x00008000
#define S_RTCP_LOSSES          0x00010000
#define S_RTCP_BANDESTIMATION  0x00020000
#define S_RTCP_NETQUALITY      0x00040000
#define S_RTCP_RRSR            0x00080000
#define S_RTCP_TIMING          0x00100000
#define S_RTCP_CALLBACK        0x00200000

#define S_CHANNEL_INIT         0x00000001
#define S_CHANNEL_CMD          0x00000002

#define S_NETWORK_ADDR         0x00000001
#define S_NETWORK_SOCK         0x00000002
#define S_NETWORK_HOST         0x00000004
#define S_NETWORK_TTL          0x00000008
#define S_NETWORK_MULTICAST    0x00000010

#define S_ADDRDESC_ALLOC       0x00000001

#define S_DEMUX_ALLOC          0x00000001
#define S_DEMUX_OUTS           0x00000002
#define S_DEMUX_MAP            0x00000004

#define S_USER_INIT            0x00000001
#define S_USER_EVENT           0x00000002
#define S_USER_LOOKUP          0x00000004
#define S_USER_STATE           0x00000008
#define S_USER_INFO            0x00000010
#define S_USER_ENUM            0x00000020

#define S_DSHOW_INIT           0x00000001
#define S_DSHOW_SOURCE         0x00000002
#define S_DSHOW_RENDER         0x00000004
#define S_DSHOW_CIRTP          0x00000008
#define S_DSHOW_REFCOUNT       0x00000010
#define S_DSHOW_EVENT          0x00000020

#define S_QOS_DUMPOBJ          0x00000001
#define S_QOS_FLOWSPEC         0x00000002
#define S_QOS_NOTIFY           0x00000004
#define S_QOS_EVENT            0x00000008
#define S_QOS_PROVIDER         0x00000010
#define S_QOS_RESERVE          0x00000020
#define S_QOS_LIST             0x00000040

#define S_CRYPTO_INIT          0x00000001
#define S_CRYPTO_ALLOC         0x00000002
#define S_CRYPTO_ENCRYPT       0x00000004
#define S_CRYPTO_DECRYPT       0x00000008
#define S_CRYPTO_RAND          0x00000010

/* Options in RtpDbgReg_t.dwOptions */

/* Print time as hh:mm:ss.ms instead of the default ddddd.ddd */
#define OPTDBG_SPLITTIME         0x00000001

/* Reverse selection (instead of enabling, disable those selected) */
#define OPTDBG_UNSELECT          0x00000002

/* Make heap free the memory to the real heap (call HeapFree) */
#define OPTDBG_FREEMEMORY        0x40000000

/* Generate a DebugBreak() when printing a classs ERROR message */
#define OPTDBG_BREAKONERROR      0x80000000

#define IsSetDebugOption(op)     (g_RtpDbgReg.dwAdvancedOptions & (op))

typedef struct _RtpDbgReg_t
{
    DWORD            dwAdvancedOptions;
    DWORD            dwEnableFileTracing;
    DWORD            dwEnableConsoleTracing;
    DWORD            dwEnableDebuggerTracing;
    DWORD            dwConsoleTracingMask;
    DWORD            dwFileTracingMask;
    DWORD            dwUseAdvancedTracing;
    
    DWORD            dwERROR;
    DWORD            dwWARNING;
    DWORD            dwINFO;
    DWORD            dwINFO2;
    DWORD            dwINFO3;
    DWORD            dwDisableClass;
    DWORD            dwDisableGroup;

    /*
     * WARNING
     *
     * The GroupArray isindexed by the group, so the order for the
     * individual variables (e.g. dwSetup, dwCritSect, etc) MUST match
     * the oder in the GROUP_* definitions
     * */
    union
    {
        DWORD            dwGroupArray[GROUP_LAST];
        
        struct {
            DWORD            dwDummy;
            DWORD            dwSetup;
            DWORD            dwCritSect;
            DWORD            dwHeap;
            DWORD            dwQueue;
            DWORD            dwRTP;
            DWORD            dwRTCP;
            DWORD            dwChannel;
            DWORD            dwNetwork;
            DWORD            dwAddrDesc;
            DWORD            dwDemux;
            DWORD            dwUser;
            DWORD            dwDShow;
            DWORD            dwQOS;
            DWORD            dwCrypto;
        };
    };

    /* Not read from the registry */
    DWORD            dwGroupArray2[GROUP_LAST];
} RtpDbgReg_t;

extern RtpDbgReg_t      g_RtpDbgReg;

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpdbg_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpevent.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpevent.h
 *
 *  Abstract:
 *
 *    Post RTP/RTCP specific events
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/29 created
 *
 **********************************************************************/
#ifndef _rtpevent_h_
#define _rtpevent_h_

#include "struct.h"

BOOL RtpPostEvent(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        DWORD            dwEventKind,
        DWORD            dwEvent,
        DWORD_PTR        dwPar1,
        DWORD_PTR        dwPar2
    );

extern const TCHAR_t *g_psRtpRtpEvents[];
extern const TCHAR_t *g_psRtpPInfoEvents[];
extern const TCHAR_t *g_psRtpQosEvents[];
extern const TCHAR_t *g_psRtpSdesEvents[];

#endif /* _rtpevent_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpdtmf.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpdtmf.h
 *
 *  Abstract:
 *
 *    Implements functionality to partially support rfc2833
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/08/17 created
 *
 **********************************************************************/
#ifndef _rtpdtmf_h_
#define _rtpdtmf_h_

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

/* Flags passed in RtpSendDtmfEvent() as dwDtmfFlags parameter */
enum {
    FGDTMF_FIRST,
    
    FGDTMF_END,    /* Set end flag to 1 */
    FGDTMF_MARKER, /* Force RTP marker bit to 1 on first packet of
                    * event */

    FGDTMF_LAST
};

/* Configures DTMF parameters */
DWORD RtpSetDtmfParameters(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwPT_Dtmf
    );

/* Directs an RTP render filter to send a packet formatted according
 * to rfc2833 containing the specified event, specified volume level,
 * duration in timestamp units, and some flags (including END flag) */
DWORD RtpSendDtmfEvent(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwTimeStamp,
        DWORD            dwEvent,
        DWORD            dwVolume,
        DWORD            dwDuration, /* timestamp units */
        DWORD            dwDtmfFlags
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpglob.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpglob.h
 *
 *  Abstract:
 *
 *    Implements the Global services family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/01 created
 *
 **********************************************************************/

#ifndef _rtpglob_h_
#define _rtpglob_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Global services family
 *
 **********************************************************************/

enum {
    RTPGLOB_FIRST,
    RTPGLOB_FLAGS_MASK,
    RTPGLOB_TEST_FLAGS_MASK,
    RTPGLOB_CLASS_PRIORITY,
    RTPGLOB_VERSION,
    RTPGLOB_LAST
};

HRESULT ControlRtpGlob(RtpControlStruct_t *pRtpControlStruct);

#endif /* _rtpglob_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpglobs.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpglobs.h
 *
 *  Abstract:
 *
 *     Global heaps, etc.
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/25 created
 *
 **********************************************************************/

#ifndef _rtpglobs_h_
#define _rtpglobs_h_

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

#include "gtypes.h"
#include "struct.h"
#include "rtpheap.h"

#define MIN_ASYNC_RECVBUF 4

/* Global heaps */

/* Heap used to allocate objects for a source */
extern RtpHeap_t *g_pRtpSourceHeap;

/* Heap used to allocate media sample objects for a source */
extern RtpHeap_t *g_pRtpSampleHeap;

/* Heap used to allocate objects for a render */
extern RtpHeap_t *g_pRtpRenderHeap;

/* Heap used to obtain RtpSess_t structures */
extern RtpHeap_t *g_pRtpSessHeap;

/* Heap used to obtain RtpAddr_t structures */
extern RtpHeap_t *g_pRtpAddrHeap;

/* Heap used to obtain RtpUser_t structures */
extern RtpHeap_t *g_pRtpUserHeap;

/* Heap used to obtain RtpSdes_t structures */
extern RtpHeap_t *g_pRtpSdesHeap;

/* Heap used to obtain RtpNetCount_t structures */
extern RtpHeap_t *g_pRtpNetCountHeap;

/* Heap used to obtain RtpRecvIO_t structures */
extern RtpHeap_t *g_pRtpRecvIOHeap;

/* Heap used to obtain RtpChannelCmd_t structures */
extern RtpHeap_t *g_pRtpChannelCmdHeap;

/* Heap used to obtain RtcpAddrDesc_t structures */
extern RtpHeap_t *g_pRtcpAddrDescHeap;

/* Heap used to obtain RtcpRecvIO_t structures */
extern RtpHeap_t *g_pRtcpRecvIOHeap;

/* Heap used to obtain RtcpSendIO_t structures */
extern RtpHeap_t *g_pRtcpSendIOHeap;

/* Heap used to obtain RtpQosReserve_t structures */
extern RtpHeap_t *g_pRtpQosReserveHeap;

/* Heap used to obtain RtpQosNotify_t structures */
extern RtpHeap_t *g_pRtpQosNotifyHeap;

/* Heap used to obtain buffers used by QOS/RSVPSP */
extern RtpHeap_t *g_pRtpQosBufferHeap;

/* Heap used to obtain RtpCrypt_t structures */
extern RtpHeap_t *g_pRtpCryptHeap;

/* Heap used to obtain variable size structures structures */
extern RtpHeap_t *g_pRtpGlobalHeap;

/* Contains some general information */
extern RtpContext_t g_RtpContext;

HRESULT RtpInit(void);

HRESULT RtpDelete(void);

/*
 * Creates all the global heaps */
BOOL RtpCreateGlobHeaps(void);

/*
 * Destroys all the global heaps */
BOOL RtpDestroyGlobHeaps(void);

/* Init reference time */
void RtpInitReferenceTime(void);

/* RTP's reference time */
LONGLONG RtpGetTime(void);

/* RTP's time in seconds since midnight (00:00:00), January 1, 1970,
 * coordinated universal time (UTC) contained in structure RtpTime_t,
 * returns same time also as a double
 * */
double RtpGetTimeOfDay(RtpTime_t *pRtpTime);

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpglobs_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtperr.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtperr.h
 *
 *  Abstract:
 *
 *    Error codes
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/01 created
 *
 **********************************************************************/

#ifndef _rtperr_h_
#define _rtperr_h_

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

#include <apierror.h>

extern const TCHAR      *g_psRtpErr[];

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#define RTPERR_SEVERITY 0x3

/* FACILITY_RTPRTCPCONTROL in skywalker\inc\apierror.h */
#define RTPERR_FACILITY FACILITY_RTPRTCPCONTROL

#define MAKERTPERR(_e) \
        ((RTPERR_SEVERITY << 30) | (RTPERR_FACILITY << 16) | (_e))

#define RTPERR_TEXT(_e) (g_psRtpErr[(_e) & 0xffff])

/*
 * WARNING
 *
 * The *_ENUM_* values in rtperr.h and the array g_psRtpErr in
 * rtperr.c MUST have their entries matched
 * */
#define RTPERR_ENUM_NOERROR            0x00  /*  0 */
#define RTPERR_ENUM_FAIL               0x01  /*  1 */
#define RTPERR_ENUM_MEMORY             0x02  /*  2 */
#define RTPERR_ENUM_POINTER            0x03  /*  3 */
#define RTPERR_ENUM_INVALIDRTPSESS     0x04  /*  4 */
#define RTPERR_ENUM_INVALIDRTPADDR     0x05  /*  5 */
#define RTPERR_ENUM_INVALIDRTPUSER     0x06  /*  6 */
#define RTPERR_ENUM_INVALIDRTPCONTEXT  0x07  /*  7 */
#define RTPERR_ENUM_INVALIDRTCPCONTEXT 0x08  /*  8 */
#define RTPERR_ENUM_INVALIDOBJ         0x09  /*  9 */
#define RTPERR_ENUM_INVALIDSTATE       0x0A  /* 10 */
#define RTPERR_ENUM_NOTINIT            0x0B  /* 11 */
#define RTPERR_ENUM_INVALIDARG         0x0C  /* 12 */
#define RTPERR_ENUM_INVALIDHDR         0x0D  /* 13 */
#define RTPERR_ENUM_INVALIDPT          0x0E  /* 14 */
#define RTPERR_ENUM_INVALIDVERSION     0x0F  /* 15 */
#define RTPERR_ENUM_INVALIDPAD         0x10  /* 16 */
#define RTPERR_ENUM_INVALIDRED         0x11  /* 17 */
#define RTPERR_ENUM_INVALIDSDES        0x12  /* 18 */
#define RTPERR_ENUM_INVALIDBYE         0x13  /* 19 */
#define RTPERR_ENUM_INVALIDUSRSTATE    0x14  /* 20 */
#define RTPERR_ENUM_INVALIDREQUEST     0x15  /* 21 */
#define RTPERR_ENUM_SIZE               0x16  /* 22 */
#define RTPERR_ENUM_MSGSIZE            0x17  /* 23 */
#define RTPERR_ENUM_OVERRUN            0x18  /* 24 */
#define RTPERR_ENUM_UNDERRUN           0x19  /* 25 */
#define RTPERR_ENUM_PACKETDROPPED      0x1A  /* 26 */
#define RTPERR_ENUM_CRYPTO             0x1B  /* 27 */
#define RTPERR_ENUM_ENCRYPT            0x1C  /* 28 */
#define RTPERR_ENUM_DECRYPT            0x1D  /* 29 */
#define RTPERR_ENUM_CRITSECT           0x1E  /* 30 */
#define RTPERR_ENUM_EVENT              0x1F  /* 31 */
#define RTPERR_ENUM_WS2RECV            0x20  /* 32 */
#define RTPERR_ENUM_WS2SEND            0x21  /* 33 */
#define RTPERR_ENUM_NOTFOUND           0x22  /* 34 */
#define RTPERR_ENUM_UNEXPECTED         0x23  /* 35 */
#define RTPERR_ENUM_REFCOUNT           0x24  /* 36 */
#define RTPERR_ENUM_THREAD             0x25  /* 37 */
#define RTPERR_ENUM_HEAP               0x26  /* 38 */
#define RTPERR_ENUM_WAITTIMEOUT        0x27  /* 39 */
#define RTPERR_ENUM_CHANNEL            0x28  /* 40 */
#define RTPERR_ENUM_CHANNELCMD         0x29  /* 41 */
#define RTPERR_ENUM_RESOURCES          0x2A  /* 42 */
#define RTPERR_ENUM_QOS                0x2B  /* 43 */
#define RTPERR_ENUM_NOQOS              0x2C  /* 44 */
#define RTPERR_ENUM_QOSSE              0x2D  /* 45 */
#define RTPERR_ENUM_QUEUE              0x2E  /* 46 */
#define RTPERR_ENUM_NOTIMPL            0x2F  /* 47 */
#define RTPERR_ENUM_INVALIDFAMILY      0x30  /* 48 */
#define RTPERR_ENUM_LAST               0x31  /* 49 */


#define RTPERR_NOERROR                 MAKERTPERR(RTPERR_ENUM_NOERROR)
#define RTPERR_FAIL                    MAKERTPERR(RTPERR_ENUM_FAIL)
#define RTPERR_MEMORY                  MAKERTPERR(RTPERR_ENUM_MEMORY)
#define RTPERR_POINTER                 MAKERTPERR(RTPERR_ENUM_POINTER)
#define RTPERR_INVALIDRTPSESS          MAKERTPERR(RTPERR_ENUM_INVALIDRTPSESS)
#define RTPERR_INVALIDRTPADDR          MAKERTPERR(RTPERR_ENUM_INVALIDRTPADDR)
#define RTPERR_INVALIDRTPUSER          MAKERTPERR(RTPERR_ENUM_INVALIDRTPUSER)
#define RTPERR_INVALIDRTPCONTEXT       MAKERTPERR(RTPERR_ENUM_INVALIDRTPCONTEXT)
#define RTPERR_INVALIDRTCPCONTEXT      MAKERTPERR(RTPERR_ENUM_INVALIDRTCPCONTEXT)
#define RTPERR_INVALIDOBJ              MAKERTPERR(RTPERR_ENUM_INVALIDOBJ)
#define RTPERR_INVALIDSTATE            MAKERTPERR(RTPERR_ENUM_INVALIDSTATE)
#define RTPERR_NOTINIT                 MAKERTPERR(RTPERR_ENUM_NOTINIT)
#define RTPERR_INVALIDARG              MAKERTPERR(RTPERR_ENUM_INVALIDARG)
#define RTPERR_INVALIDHDR              MAKERTPERR(RTPERR_ENUM_INVALIDHDR)
#define RTPERR_INVALIDPT               MAKERTPERR(RTPERR_ENUM_INVALIDPT)
#define RTPERR_INVALIDVERSION          MAKERTPERR(RTPERR_ENUM_INVALIDVERSION)
#define RTPERR_INVALIDPAD              MAKERTPERR(RTPERR_ENUM_INVALIDPAD)
#define RTPERR_INVALIDRED              MAKERTPERR(RTPERR_ENUM_INVALIDRED)
#define RTPERR_INVALIDSDES             MAKERTPERR(RTPERR_ENUM_INVALIDSDES)
#define RTPERR_INVALIDBYE              MAKERTPERR(RTPERR_ENUM_INVALIDBYE)
#define RTPERR_INVALIDUSRSTATE         MAKERTPERR(RTPERR_ENUM_INVALIDUSRSTATE)
#define RTPERR_INVALIDREQUEST          MAKERTPERR(RTPERR_ENUM_INVALIDREQUEST)
#define RTPERR_SIZE                    MAKERTPERR(RTPERR_ENUM_SIZE)
#define RTPERR_MSGSIZE                 MAKERTPERR(RTPERR_ENUM_MSGSIZE)
#define RTPERR_OVERRUN                 MAKERTPERR(RTPERR_ENUM_OVERRUN)
#define RTPERR_UNDERRUN                MAKERTPERR(RTPERR_ENUM_UNDERRUN)
#define RTPERR_PACKETDROPPED           MAKERTPERR(RTPERR_ENUM_PACKETDROPPED)
#define RTPERR_CRYPTO                  MAKERTPERR(RTPERR_ENUM_CRYPTO)
#define RTPERR_ENCRYPT                 MAKERTPERR(RTPERR_ENUM_ENCRYPT)
#define RTPERR_DECRYPT                 MAKERTPERR(RTPERR_ENUM_DECRYPT)
#define RTPERR_CRITSECT                MAKERTPERR(RTPERR_ENUM_CRITSECT)
#define RTPERR_EVENT                   MAKERTPERR(RTPERR_ENUM_EVENT)
#define RTPERR_WS2RECV                 MAKERTPERR(RTPERR_ENUM_WS2RECV)
#define RTPERR_WS2SEND                 MAKERTPERR(RTPERR_ENUM_WS2SEND)
#define RTPERR_NOTFOUND                MAKERTPERR(RTPERR_ENUM_NOTFOUND)
#define RTPERR_UNEXPECTED              MAKERTPERR(RTPERR_ENUM_UNEXPECTED)
#define RTPERR_REFCOUNT                MAKERTPERR(RTPERR_ENUM_REFCOUNT)
#define RTPERR_THREAD                  MAKERTPERR(RTPERR_ENUM_THREAD)
#define RTPERR_HEAP                    MAKERTPERR(RTPERR_ENUM_HEAP)
#define RTPERR_WAITTIMEOUT             MAKERTPERR(RTPERR_ENUM_WAITTIMEOUT)
#define RTPERR_CHANNEL                 MAKERTPERR(RTPERR_ENUM_CHANNEL)
#define RTPERR_CHANNELCMD              MAKERTPERR(RTPERR_ENUM_CHANNELCMD)
#define RTPERR_RESOURCES               MAKERTPERR(RTPERR_ENUM_RESOURCES)
#define RTPERR_QOS                     MAKERTPERR(RTPERR_ENUM_QOS)
#define RTPERR_NOQOS                   MAKERTPERR(RTPERR_ENUM_NOQOS)
#define RTPERR_QOSSE                   MAKERTPERR(RTPERR_ENUM_QOSSE)
#define RTPERR_QUEUE                   MAKERTPERR(RTPERR_ENUM_QUEUE)
#define RTPERR_NOTIMPL                 MAKERTPERR(RTPERR_ENUM_NOTIMPL)
#define RTPERR_INVALIDFAMILY           MAKERTPERR(RTPERR_ENUM_INVALIDFAMILY)


/* Below this point these codes may become obsolete */

#define RTPERR_INVALIDCONTROL   E_FAIL
#define RTPERR_INVALIDFUNCTION  E_FAIL
#define RTPERR_INVALIDFLAGS     E_FAIL
#define RTPERR_INVALIDDIRECTION E_FAIL

#define RTPERR_ZEROPAR1         E_FAIL
#define RTPERR_RDPTRPAR1        E_FAIL
#define RTPERR_WRPTRPAR1        E_FAIL
#define RTPERR_ZEROPAR2         E_FAIL
#define RTPERR_RDPTRPAR2        E_FAIL
#define RTPERR_WRPTRPAR2        E_FAIL

#endif /* _rtperr_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpheap.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpheap.h
 *
 *  Abstract:
 *
 *    Implements the private heaps handling
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/24 created
 *
 **********************************************************************/

#ifndef _rtpheap_h_
#define _rtpheap_h_

#include "gtypes.h"
#include "rtpque.h"
#include "rtpcrit.h"

//#include <winbase.h>

/*
  Every block obtained from a private heap, will have the following
  layout:

  +-----------------+
  RtpHeapBlockBegin_t
  RtpQueueItem_t
  Data
  RtpHeapBlockEnd_t
  +-----------------+

  Data is variable size and DWORD aligned, the caller receives a
  pointer to the Data block and it frees the block by passing the same
  pointer.

*/

/*
 * Every item obtained from a private heap, will have this structure
 * at the begining */
typedef struct _RtpHeapBlockBegin_t {
    DWORD      InvBeginSig;
    DWORD      BeginSig;
    long       lSize;
    DWORD      dwFlag;
} RtpHeapBlockBegin_t;

/*
 * Every item obtained from a private heap, will have this structure
 * at the end */
typedef struct _RtpHeapBlockEnd_t {
    DWORD      EndSig;
    DWORD      InvEndSig;
} RtpHeapBlockEnd_t;

/*
 * Holds a private heap, this structure hides the */
typedef struct _RtpHeap_t {
    DWORD          dwObjectID;/* the tag for this kind of object */
    RtpQueueItem_t QueueItem; /* keep all heaps together */
    BYTE           bTag;      /* what kind of items will be obtained */
    BYTE           dummy1;    /* not used */
    BYTE           dummy2;    /* not used */
    BYTE           dummy3;    /* not used */
    long           lSize;     /* each block requested has this size */
    HANDLE         hHeap;     /* real heap */
    RtpQueue_t     FreeQ;     /* free items */
    RtpQueue_t     BusyQ;     /* busy items */
    RtpCritSect_t  RtpHeapCritSect; /* critical section to lock access
                                       to queues */
} RtpHeap_t;

/*
 * CAUTION: RtpCreateMasterHeap and RtpDestroyMasterHeap require the caller
 * to call these functions multi-thread safe.
 */

/*
 * The master heap must be created before any private RTP heap can be
 * created */
BOOL RtpCreateMasterHeap(void);

/*
 * The master heap is deleted when none of the memory allocated from
 * any private heap is in use. It is expected that when this function
 * is called, there will not be any heap left in the busy queue. */
BOOL RtpDestroyMasterHeap(void);

/*
 * Creates a private heap from the master heap. The structure is
 * obtained from the master heap, the real heap is created, the
 * critical section initialized, and the other fileds properly
 * initialized. */
RtpHeap_t *RtpHeapCreate(BYTE bTag, long lSize);

/*
 * Destroys a private heap. The structure is returned to the master
 * heap, the real heap is destroyed and the critical section
 * deleted. It is expected that the busy queue be empty. */
BOOL RtpHeapDestroy(RtpHeap_t *pRtpHeap);

/*
 * If the size requested is the same as the heap's initially set, then
 * look first in the free list then create a new block. If the size is
 * different, just create a new block. In both cases the block will be
 * left in the busy queue. */
void *RtpHeapAlloc(RtpHeap_t *pRtpHeap, long lSize);

/*
 * If the block is the same size as the heap's initially set, put it
 * in the free queue, otherwise destroy it. */
BOOL RtpHeapFree(RtpHeap_t *pRtpHeap, void *pvMem);

#endif /* _rtpheap_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpmask.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpmask.h
 *
 *  Abstract:
 *
 *    Used to modify or test the different masks in a RtpSess_t
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/29 created
 *
 **********************************************************************/

#ifndef _rtpmask_h_
#define _rtpmask_h_

#include "struct.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

HRESULT RtpModifyMask(
        RtpSess_t       *pRtpSess,
        DWORD            dwKind,
        DWORD            dwMask,
        DWORD            dwValue,
        DWORD           *dwModifiedMask
    );

extern const DWORD g_dwRtpSessionMask[];

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpmask_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpfwrap.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpfwrap.h
 *
 *  Abstract:
 *
 *    RTP functions wrapper. Defines the control word passed in
 *    RtpControl and the format of the test word.
 *
 *    When RtpControl is called, the following steps are followed:
 *
 *    1. validate the control word
 *
 *    2. look up another control word, the test word, that defines
 *    what are the tests to perform, validates the function and
 *    defines what flags are valid
 *
 *    3. call the proper function to do the real job
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/01 created
 *
 **********************************************************************/

#ifndef _rtpfwrap_h_
#define _rtpfwrap_h_

/*

  Control word
  ------------
  
  The control word (actually a DWORD) is one of the parameter passed
  by an application when invoking the RTP services. That dword has the
  following format:

      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Tag      | |       |       |    unused     |     Flags     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                  v \--v--/ \--v--/
                  |    |       |
                  |    |       Function in family (14)
                  |    |
                  |    Family of functions (14)
                  |
                  Direction (SET/GET)

  Test word
  ---------               
                  
  The test word defines if:

  1. the function is enabled (set/get)

  2. each of the parameters must be tested for write pointer, read
  pointer and zero value (zero value is exclusive with read/write
  pointer tests)

  3. the lock needs to be obtained

  The control word has the following format:
  
      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | |w r z| |w r z|               | |z r z| |w r z|               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v \-v-/ v \-v-/ \------v------/ v \-v-/ v \-v-/ \------v------/
    |   |   |   |          |        |   |   |   |          |
    |   |   |   |          |        |   |   |   |          |
    |   |   |   |          Flags    |   |   |   |          Flags
    |   |   |   |                   |   |   |   |
    |   |   |   Par 1               |   |   |   Par 1
    |   |   |                       |   |   |
    |   |   Lock                    |   |  Lock
    |   |                           |   |
    |   Par 2                       |   Par 2
    |                               |
    Enable set                      Enable get
   \--------------SET--------------/\-------------GET-------------/

   Each of the 3 bits in the parameters (set/get par1 and par2) are:

    2 1 0 
   +-+-+-+
   | Par |
   +-+-+-+
    v v v
    | | |
    | | Test for ZERO value
    | | 
    | Test for Read pointer (test performed over 1 DWORD)
    |
    Test for Write pointer (test performed over 1 DWORD)

    There exist an array of this words for each family, the function
    in family is then used as an index.
    
    TODO: (may be) another constant array could be defined with the
    memory size to test. This of course can be used only when that
    size if fixed (i.e. specific functions expect specific size
    structures), when a variable length user buffer is passed, that
    must be tested by the specific function in family, the number of
    these cases is expected to be small, otherwise the benefit of
    having a single place were the tests are performed is lost

*/

/* Forward declaration */
typedef struct _RtpControlStruct_t RtpControlStruct_t;

/*
 * Prototype for the functions implementing all the features */
typedef HRESULT (* RtpFamily_f)(RtpControlStruct_t *pRtpControlStruct);

/*
 * This structure is used to save the split control word */
typedef struct _RtpControlStruct_t {
    DWORD       dwFamily;        /* family of functions */
    DWORD       dwFunction;      /* function in family */
    DWORD       dwDirection;     /* direction, get/set */
    DWORD       dwControlWord;   /* control word */
    RtpSess_t  *pRtpSess;        /* RTP session */
    DWORD_PTR   dwPar1;          /* user parameter 1 passed */
    DWORD_PTR   dwPar2;          /* user parameter 2 passed */
    RtpFamily_f RtpFamilyFunc;   /* function used */
} RtpControlStruct_t;

/*
 * Validates the control word, parameters, and if all the tests
 * succeed, call the proper function that does the work */
HRESULT RtpValidateAndExecute(RtpControlStruct_t *pRtpControlStruct);

/* Act upon the direction specific control WORD (16 bits) */
#define RTPCTRL_ENABLED(ControlW)   (ControlW & 0x8000)
#define RTPCTRL_LOCK(ControlW)      (ControlW & 0x0800)
#define RTPCTRL_TEST(ControlW, bit) (ControlW & (1<<bit))

#define PAR1_ZERO  8
#define PAR1_RDPTR 9
#define PAR1_WRPTR 10

#define PAR2_ZERO  12
#define PAR2_RDPTR 13
#define PAR2_WRPTR 14


/***********************************************************************
 *
 * RTP basic enumerated types
 *
 **********************************************************************/

/* All the family functions */
enum {
    RTPF_FIRST,
    RTPF_ADDR,     /* Address */
    RTPF_GLOB,     /* Global */
    RTPF_RTP,      /* RTP specific */

    RTPF_DEMUX,    /* Demultiplexing */
    RTPF_PH,       /* Payload handling */
    RTPF_PARINFO,  /* Participants */
    RTPF_QOS,      /* QOS */

    RTPF_CRYPT,    /* Cryptogtaphy */
    RTPF_STATS,    /* Statistics */
    RTPF_LAST
};

/*
 * details on the functions for each family are in separate include
 * files */

#endif /* _rtpfwrap_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpmisc.h ===
/**********************************************************************
 *
 *  Copyright (C) 1999 Microsoft Corporation
 *
 *  File name:
 *
 *    rtpmisc.h
 *
 *  Abstract:
 *
 *    Some networking miscellaneous functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/13 created
 *
 **********************************************************************/

#ifndef _rtpmisc_h_
#define _rtpmisc_h_

#include "gtypes.h"

const TCHAR *RtpRecvSendStr(DWORD dwFlags);

const TCHAR *RtpRecvSendStrIdx(DWORD dwIdx);

const TCHAR *RtpStreamClass(DWORD dwFlags);

BOOL RtpGetUserName(TCHAR_t *pUser, DWORD dwSize);

BOOL RtpGetHostName(TCHAR_t *pHost, DWORD dwSize);

BOOL RtpGetPlatform(TCHAR_t *pPlatform);

BOOL RtpGetImageName(TCHAR_t *pImageName, DWORD *pdwSize);

TCHAR_t *RtpNtoA(DWORD dwAddr, TCHAR_t *sAddr);

DWORD RtpAtoN(TCHAR_t *sAddr);

BOOL RtpMemCmp(BYTE *pbMem0, BYTE *pbMem1, long lMemSize);

extern const TCHAR_t *g_psRtpRecvSendStr[];

extern const TCHAR_t *g_psRtpStreamClass[];

#endif /* _rtpmisc_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpncnt.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpncnt.h
 *
 *  Abstract:
 *
 *    Implements the Statistics family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtpncnt_h_
#define _rtpncnt_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Statistics family
 *
 **********************************************************************/

/* functions */
enum {
    RTPSTATS_FIRST,
    RTPSTATS_RTPSTATS_GLOBAL_STATS,
    RTPSTATS_PARTICIPANT_RECV,
    RTPSTATS_STATS_MASK,
    RTPSTATS_TEST_STATS_MASK,
    RTPSTATS_LAST
};
 
HRESULT ControlRtpStats(RtpControlStruct_t *pRtpControlStruct);

/* Helper function to update counters */
BOOL RtpUpdateNetCount(
        RtpNetCount_t   *pRtpNetCount,/* structure where to update */
        RtpCritSect_t   *pRtpCritSect,/* lock to use */
        DWORD            dwRtpRtcp,/* 0=RTP or 1=RTCP stats */
        DWORD            dwBytes,  /* bytes to update */
        DWORD            dwFlags,  /* Flags, e.g. a dropped or error packet */
        double           dTime     /* time packet recv/send */
    );

void RtpResetNetCount(
        RtpNetCount_t   *pRtpNetCount,
        RtpCritSect_t   *pRtpCritSect
        );

void RtpGetRandomInit(RtpAddr_t *pRtpAddr);

void RtpResetNetSState(
        RtpNetSState_t  *pRtpNetSState,
        RtpCritSect_t   *pRtpCritSect
    );

#if 0
/* Creates and initializes a RtpNetCount_t structure */
RtpNetCount_t *RtpNetCountAlloc(void);

/* Frees a RtpNetCount_t structure */
void RtpNetCountFree(RtpNetCount_t *pRtpNetCount);
#endif

#endif /* _rtpncnt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpph.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpph.h
 *
 *  Abstract:
 *
 *    Implements the Payload handling family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtpph_h_
#define _rtpph_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Payload handling family
 *
 **********************************************************************/

/* functions */
#define RTPPH_PLAYOUT_DELAY

/* functions */
/* TODO add the functions */
enum {
    RTPPH_FIRST,
    RTPPH_LAST
};

HRESULT ControlRtpPh(RtpControlStruct_t *pRtpControlStruct);

#endif /* _rtpph_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpqos.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpqos.h
 *
 *  Abstract:
 *
 *    Implements the Quality of Service family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtpqos_h_
#define _rtpqos_h_

#include "rtpfwrap.h"
#include "rtcpthrd.h"

/***********************************************************************
 *
 * Quality of Service family
 *
 **********************************************************************/
#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif


/* flags */
#define RTPQOS_FG_RECV 1 /* TODO */
#define RTPQOS_FG_SEND 1 /* TODO */

#if USE_GRAPHEDT > 0
#define RTPQOS_MASK_RECV_DEFAULT ( (1 << RTPQOS_SENDERS) | \
                                   (1 << RTPQOS_NO_SENDERS) | \
                                   (1 << RTPQOS_REQUEST_CONFIRMED) )

#define RTPQOS_MASK_SEND_DEFAULT ( (1 << RTPQOS_RECEIVERS) | \
                                   (1 << RTPQOS_NO_RECEIVERS) | \
                                   (1 << RTPQOS_NOT_ALLOWEDTOSEND) | \
                                   (1 << RTPQOS_ALLOWEDTOSEND) )
#else
#define RTPQOS_MASK_RECV_DEFAULT 0
#define RTPQOS_MASK_SEND_DEFAULT 0
#endif

/* Global flags for the QOS family of functions */
typedef enum {
    RTPQOS_FLAG_FIRST = 0,
    
	/* Is the RTP session QOS enabled */
    RTPQOS_FLAG_QOS_STATE = 0,

	/* Ask for permission to send */
    RTPQOS_FLAG_ASK_PERMISSION,

	/* Send only if permission is granted */
    RTPQOS_FLAG_SEND_IF_ALLOWED,

	/* Send only if there are receivers */
    RTPQOS_FLAG_SEND_IF_RECEIVERS,

	/* There are receivers (state) */
    RTPQOS_FLAG_RECEIVERS,

	/* Has been allowed to send (state) */
    RTPQOS_FLAG_ALLOWED_TO_SEND,
    
    RTPQOS_FLAG_LAST
};

/* Minimum size passed in the provider specific buffer when requesting
 * notifications */
#define QOS_BUFFER_SIZE     512

#define QOS_MAX_BUFFER_SIZE 32000

#define MAX_QOS_CLASS       8     /* Class AUDIO, VIDEO, UNKNOWN */

HRESULT ControlRtpQos(RtpControlStruct_t *pRtpControlStruct);

DWORD RtpSetQosFlowSpec(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    );

HRESULT RtpSetQosByNameOrPT(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend,
        TCHAR_t         *psQosName,
        DWORD            dwPT,
        DWORD            dwResvStyle,
        DWORD            dwMaxParticipants,
        DWORD            dwQosSendMode,
        DWORD            dwMinFrameSize,
        BOOL             bInternal
    );

HRESULT RtpSetQosParameters(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend,
        RtpQosSpec_t    *pRtpQosSpec,
        DWORD            dwMaxParticipants,
        DWORD            dwQosSendMode
    );

HRESULT RtpSetQosAppId(
        RtpAddr_t       *pRtpAddr, 
        TCHAR_t         *psAppName,
        TCHAR_t         *psAppGUID,
        TCHAR_t         *psPolicyLocator
    );

HRESULT RtpSetQosState(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSSRC,
        BOOL             bEnable
    );

HRESULT RtpModifyQosList(
        RtpAddr_t       *pRtpAddr,
        DWORD           *pdwSSRC,
        DWORD           *pdwNumber,
        DWORD            dwOperation
    );

HRESULT RtpReserve(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    );

HRESULT RtpUnreserve(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    );

RtpQosReserve_t *RtpQosReserveAlloc(
        RtpAddr_t       *pRtpAddr
    );

RtpQosReserve_t *RtpQosReserveFree(
        RtpQosReserve_t *pRtpQosReserve
    );

HRESULT RtpGetQosEnabledProtocol(
        WSAPROTOCOL_INFO *pProtoInfo
    );

BOOL ReallocateQosBuffer(
        RtpQosNotify_t  *pRtpQosNotify
    );

RtpQosNotify_t *RtpQosNotifyAlloc(
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

RtpQosNotify_t *RtpQosNotifyFree(
        RtpQosNotify_t  *pRtpQosNotify
    );

HRESULT StartRtcpQosNotify(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

HRESULT ConsumeRtcpQosNotify(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

BOOL RtcpUpdateSendState(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwEvent
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpqos_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtppt.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtppt.h
 *
 *  Abstract:
 *
 *    Specify the payload types for the AV profile
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/28 created
 *
 **********************************************************************/

#ifndef _rtppt_h_
#define _rtppt_h_

/*
  Quoted from:
  
  Internet Engineering Task Force                                   AVT WG
  Internet Draft                                               Schulzrinne
  ietf-avt-profile-new-05.txt                                  Columbia U.
  February 26, 1999
  Expires: August 26, 1999
  

        PT     encoding      media type    clock rate    channels
               name                        (Hz)
        ___________________________________________________________
        0      PCMU          A             8000          1
        1      1016          A             8000          1
        2      G726-32       A             8000          1
        3      GSM           A             8000          1
        4      G723          A             8000          1
        5      DVI4          A             8000          1
        6      DVI4          A             16000         1
        7      LPC           A             8000          1
        8      PCMA          A             8000          1
        9      G722          A             16000         1
        10     L16           A             44100         2
        11     L16           A             44100         1
        12     QCELP         A             8000          1
        13     unassigned    A
        14     MPA           A             90000         (see text)
        15     G728          A             8000          1
        16     DVI4          A             11025         1
        17     DVI4          A             22050         1
        18     G729          A             8000          1
        19     CN            A             8000          1
        20     unassigned    A
        21     unassigned    A
        22     unassigned    A
        23     unassigned    A
        dyn    GSM-HR        A             8000          1
        dyn    GSM-EFR       A             8000          1
        dyn    RED           A


   Table 4: Payload types (PT) for audio encodings


           PT        encoding      media type    clock rate
                     name                        (Hz)
           ____________________________________________________
           24        unassigned    V
           25        CelB          V             90000
           26        JPEG          V             90000
           27        unassigned    V
           28        nv            V             90000
           29        unassigned    V
           30        unassigned    V
           31        H261          V             90000
           32        MPV           V             90000
           33        MP2T          AV            90000
           34        H263          V             90000
           35-71     unassigned    ?
           72-76     reserved      N/A           N/A
           77-95     unassigned    ?
           96-127    dynamic       ?
           dyn       BT656         V             90000
           dyn       H263-1998     V             90000
           dyn       MP1S          V             90000
           dyn       MP2P          V             90000
           dyn       BMPEG         V             90000
*/


#define RTPPT_PCMU       0
#define RTPPT_1016       1
#define RTPPT_G726_32    2
#define RTPPT_GSM        3
#define RTPPT_G723       4
#define RTPPT_DVI4_8000  5
#define RTPPT_DVI4_16000 6
#define RTPPT_LPC        7
#define RTPPT_PCMA       8
#define RTPPT_G722       9
#define RTPPT_L16_44100  10
#define RTPPT_L16_8000   11
#define RTPPT_QCELP      12
#define RTPPT_MPA        14
#define RTPPT_G728       15
#define RTPPT_DVI4_11025 16
#define RTPPT_DVI4_22050 17
#define RTPPT_G729       18
#define RTPPT_H261       31
#define RTPPT_H263       34


#endif /* _rtppt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpque.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpque.h
 *
 *  Abstract:
 *
 *    Queues and Hash implementation
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/21 created
 *
 **********************************************************************/

#ifndef _rtpque_h_
#define _rtpque_h_

#include "rtpcrit.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/*
 * The queue/hash support uses the same structure to keep items in a
 * queue or a hash.
 *
 * A queue is just a circular double linked list.
 *
 * A hash includes a hash table, and each entry is either the head of
 * another hash table or a queue's head. Items in a hash will end
 * always in a queue. A queue will become a new hash when a size of
 * MAX_QUEUE2HASH_ITEMS is reached. A hash will be destroyed (become a
 * queue) once it is emptied.
 *
 * All the functions return either a pointer to the item
 * enqueud/inserted or the item just dequeued/removed. If an error
 * condition is detected, NULL is returned.
 *
 * */

#define HASH_TABLE_SIZE      32 /* entries in a hash table must be 2^n */
#define MAX_QUEUE2HASH_ITEMS 32 /* threshold size to change queue into hash */

/* Forward declarations */
typedef struct _RtpQueueItem_t RtpQueueItem_t;
typedef struct _RtpQueue_t     RtpQueue_t;
typedef struct _RtpQueueHash_t RtpQueueHash_t;

/*
 * Every object maintained in a queue or a queue/hash will include
 * this structure */
typedef struct _RtpQueueItem_t {
    struct _RtpQueueItem_t *pNext; /* next item */
    struct _RtpQueueItem_t *pPrev; /* previous item */
    struct _RtpQueue_t     *pHead; /* used for robustness, points to
                                    * queue's head */
    /* The next field is used at the programer's discretion. Can be
     * used to point back to the parent object, or as a key during
     * searches, it is the programer's responsibility to set this
     * value, it is not used by the queue/hash functions (except
     * the "Ordered queue insertion" functions) */
    union {
        void  *pvOther;        /* may be used as a general purpose ptr */
        double dKey;           /* may be used as a double key for searches */
        DWORD  dwKey;          /* may be used as DWORD key for searches */
    };
} RtpQueueItem_t;

/*
 * !!! WARNING !!!
 *
 * RtpQueue_t and RtpQueueHash can be casted to each other.
 *
 * A negative count indicates pFirst (or indeed pvTable) is a hash
 * table. This is safe because a hash is destroyed when it has zero
 * elements (becoming a regular queue) and won't be expanded to a hash
 * again but until MAX_QUEUE2HASH_ITEMS items are enqueued */

/*
 * The owner of a queue will include this structure */
typedef struct _RtpQueue_t {
    RtpQueueItem_t      *pFirst;   /* points to first item */
    long                 lCount;   /* number of items in queue (positive) */
} RtpQueue_t;

/*
 * The owner of a queue/hash will include this structure */
typedef struct _RtpQueueHash_t {
    union {
        RtpQueueItem_t  *pFirst;   /* points to first item */
        void            *pvTable;  /* points to the hash table */
    };
    long                 lCount;   /* number of items in queue
                                      (positive)/hash (negative) */
} RtpQueueHash_t;

/* Is item in a queue? */
#define InQueue(pI)      ((pI)->pHead)

/* Is queue empty? */
#define IsQueueEmpty(pQ) ((pQ)->lCount == 0)

/* Obtain queue's current size */
#define GetQueueSize(pQ) ((pQ)->lCount)

/* TODO when a hash become really a hash (currently is the same as a
 * queue), this macro must be modified accordingly */
#define GetHashCount(pH) ((pH)->lCount)

/*
 * Queue functions
 */

/* enqueue after pPos item */
RtpQueueItem_t *enqueuea(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        RtpQueueItem_t  *pPos
    );

/* enqueue before pPos item */
RtpQueueItem_t *enqueueb(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        RtpQueueItem_t  *pPos
    );

/* enqueue as first */
RtpQueueItem_t *enqueuef(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* enqueue at the end */
RtpQueueItem_t *enqueuel(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* dequeue item pItem */
RtpQueueItem_t *dequeue(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* dequeue first item */
RtpQueueItem_t *dequeuef(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect
    );

/* dequeue last item */
RtpQueueItem_t *dequeuel(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect
    );

/* move item so it becomes the first one in the queue */
RtpQueueItem_t *move2first(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* move item so it becomes the last one in the queue */
RtpQueueItem_t *move2last(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* move item from FromQ to the beginning of ToQ */
RtpQueueItem_t *move2qf(
        RtpQueue_t      *pToQ,
        RtpQueue_t      *pFromQ,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* move item from FromQ to the end of ToQ */
RtpQueueItem_t *move2ql(
        RtpQueue_t      *pToQ,
        RtpQueue_t      *pFromQ,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );


/* find first item that matches the pvOther parameter */
RtpQueueItem_t *findQO(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        void            *pvOther
    );

/* find first item that matches the dwKey parameter */
RtpQueueItem_t *findQdwK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        DWORD            dwKey
    );

/* find first item that matches the dKey parameter */
RtpQueueItem_t *findQdK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        double          dKey
    );

/* find the Nth item in the queue (items are counted 0,1,2,...) */
RtpQueueItem_t *findQN(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        long             lNth
    );


/*
 * Ordered Queue insertion
 */

/* enqueue in ascending key order */
RtpQueueItem_t *enqueuedwK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        DWORD            dwKey
    );

/* enqueue in ascending key order */
RtpQueueItem_t *enqueuedK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        double          dKey
    );

/*
 * Queue/Hash functions
 */

/* insert in hash using key */
RtpQueueItem_t *insertHdwK(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        DWORD            dwKey
    );

/* remove from hash first item matching dwKey */
RtpQueueItem_t *removeHdwK(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        DWORD            dwKey
    );

/* remove item from hash */
RtpQueueItem_t *removeH(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* remove "first" item from hash */
RtpQueueItem_t *removefH(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect
    );

/* find first item whose key matches dwKey */
RtpQueueItem_t *findHdwK(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        DWORD            dwKey
    );

/* Peek the "first" item from hash */
RtpQueueItem_t *peekH(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect
    );
      
#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpque_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtprand.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtprand.h
 *
 *  Abstract:
 *
 *    Random number generation using CAPI
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/09/12 created
 *
 **********************************************************************/

#ifndef _rtprand_h_
#define _rtprand_h_

HRESULT RtpRandInit(void);

HRESULT RtpRandDeinit(void);

/* Generate a 32bits random number */
DWORD RtpRandom32(DWORD_PTR type);

/* Generate dwLen bytes of random data */
DWORD RtpRandomData(char *pBuffer, DWORD dwLen);

#endif /* _rtprand_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtprecv.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtprecv.h
 *
 *  Abstract:
 *
 *    Implements overalapped RTP reception
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/01 created
 *
 **********************************************************************/

#ifndef _rtprecv_h_
#define _rtprecv_h_

#include "struct.h"

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

HRESULT RtpRecvFrom_(
        RtpAddr_t *pRtpAddr,
        WSABUF    *pWSABuf,
        void      *pvUserInfo1,
        void      *pvUserInfo2
    );

DWORD StartRtpRecvFrom(RtpAddr_t *pRtpAddr);

DWORD ConsumeRtpRecvFrom(RtpAddr_t *pRtpAddr);

DWORD RtpCheckReadyToPostOnTimeout(
        RtpAddr_t       *pRtpAddr
    );

DWORD RtpCheckReadyToPostOnRecv(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser
    );

DWORD FlushRtpRecvFrom(RtpAddr_t *pRtpAddr);

DWORD FlushRtpRecvUser(RtpAddr_t *pRtpAddr, RtpUser_t *pRtpUser);

void RtpRecvIOFreeAll(RtpAddr_t *pRtpAddr);

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#endif /* _rtprecv_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpred.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpred.h
 *
 *  Abstract:
 *
 *    Implements functionality to support redundant encoding (rfc2198)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/10/20 created
 *
 **********************************************************************/

#ifndef _rtpred_h_
#define _rtpred_h_

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

DWORD RtpSetRedParameters(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags,
        DWORD            dwPT_Red,
        DWORD            dwInitialRedDistance,
        DWORD            dwMaxRedDistance
    );

DWORD RtpUpdatePlayoutBounds(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpRecvIO_t     *pRtpRecvIO
    );

DWORD RtpAdjustSendRedundancyLevel(RtpAddr_t *pRtpAddr);

DWORD RtpAddRedundantBuff(
        RtpAddr_t       *pRtpAddr,
        WSABUF          *pWSABuf,
        DWORD            dwTimeStamp
    );

DWORD RtpClearRedundantBuffs(RtpAddr_t *pRtpAddr);

DWORD RtpRedAllocBuffs(RtpAddr_t *pRtpAddr);

DWORD RtpRedFreeBuffs(RtpAddr_t *pRtpAddr);

int RtpUpdateLossRate(
        int              iAvgLossRate,
        int              iCurLossRate
    );

extern double           g_dRtpRedEarlyTimeout;
extern double           g_dRtpRedEarlyPost;

#if USE_GEN_LOSSES > 0
BOOL RtpRandomLoss(DWORD dwRecvSend);
#endif /* USE_GEN_LOSSES > 0 */

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#endif/* _rtpred_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtppinfo.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtppinfo.h
 *
 *  Abstract:
 *
 *    Implements the Participant Information family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtppinfo_h_
#define _rtppinfo_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Participants information family
 *
 **********************************************************************/

/* common flags */
#define RTPPARINFO_FG_LOCAL
#define RTPPARINFO_FG_REMOTE

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/* state can be... */
#define RTPPARINFO_STATE_MUTE
#define RTPPARINFO_STATE_QOS
#define RTPPARINFO_STATE_TRAFFIC

/* User events that produce transitions, i.e. may entice a state
 * change */
enum {
    USER_EVENT_FIRST,

    /* A RTP packet was received */
    USER_EVENT_RTP_PACKET,

    /* A RTCP packet was received */
    USER_EVENT_RTCP_PACKET,

    /* A RTCP BYE packet was received */
    USER_EVENT_BYE,

    /* The current timer expired */
    USER_EVENT_TIMEOUT,

    /* Participant context is about to be deleted */
    USER_EVENT_DEL,

    USER_EVENT_LAST
};

/*
 * Timers definition
 * */

/* Time to pass from TALKING to WAS_TALING */
#define RTPPARINFO_TIMER1  3

/* Time to pass from WAS_TALKING to SILENT, 2 the RTCP interval report */
#define RTPPARINFO_TIMER2  0

/* Time to pass to STALL, 5 times the RTCP interval report */
#define RTPPARINFO_TIMER3  0

/* Time to pass from STALL or BYE to DEL, 10 times the RTCP interval */
#define RTPPARINFO_TIMER4  20*1000

/**********************************************************************
 * Control word structure (used to direct the participant's state
 * machine)
 **********************************************************************

      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E|X| Tmr | Move| State | Event |    Source     |  Destination  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v v \-v-/ \-v-/ \--v--/ \--v--/ \------v------/ \------v------/
    | |   |     |      |       |           |               |
    | |   |     |      |       |           |    Destination Queue (8)
    | |   |     |      |       |           | 
    | |   |     |      |       |     Source Queue (8)
    | |   |     |      |       |
    | |   |     |      |       Event to generate (4)
    | |   |     |      |
    | |   |     |      Next state (4)
    | |   |     |
    | |   |     Type of move in queues (3)
    | |   |
    | |   Timer to use (3)
    | |
    | Need to do extra processing (1)
    |
    Enable this word (1)

 **********************************************************************
 * Participant's states machine:
 *
 *   \_ user events: RTP, RTCP, BYE, Timeout, DEL
 *     \_  
 *       \_
 * states  \   RTP             RTCP           BYE            Timeout(T)
 *-------------------------------------------------------------------------
 * CREATED     TALKING         SILENT         X              X
 *             AliveQ->Cache1Q       
 *             T1->T           T2->T
 *             EVENT_CREATED   EVENT_CREATED
 *-------------------------------------------------------------------------
 * SILENT      TALKING                        BYE            T3:STALL
 *             AliveQ->Cache1Q AliveQ         AliveQ->ByeQ   AliveQ->ByeQ
 *             T1->T           T3->T          T4->T          T4->T
 *             EVENT_TALKING                  EVENT_BYE      EVENT_STALL
 *-------------------------------------------------------------------------
 * TALKING                                    BYE            T1:WAS_TKING
 *             Cache1Q                        Cache1Q->ByeQ  Cache1Q->Cache2Q
 *             T1->T                          T4->T          T2->T
 *                                            EVENT_BYE      EVENT_WAS_TKING
 *-------------------------------------------------------------------------
 * WAS_TKING   TALKING                        BYE            T2:SILENT
 *             Cache2Q->Cache1Q               Cache2Q->ByeQ  Cache2Q->AliveQ
 *             T1->T                          T4->T          T3->T
 *             EVENT_TALKING                  EVENT_BYE      EVENT_SILENT
 *-------------------------------------------------------------------------
 * STALL       TALKING         SILENT         BYE            T4:DEL
 *             ByeQ->Cache1Q   ByeQ->AliveQ                  ByeQ->
 *                                                           Hash->
 *             T1->T           T3->T          T4->T
 *             EVENT_TALKING   EVENT_SILENT   EVENT_BYE      EVENT_DEL
 *-------------------------------------------------------------------------
 * BYE         ---             ---            ---            T4:DEL
 *                                                           ByeQ->
 *                                                           Hash->
 *                                                           EVENT_DEL
 *-------------------------------------------------------------------------
 * DEL         ---             ---            ---            ---
 *-------------------------------------------------------------------------
 *
 * NOTE On event DEL (that event is not displayed in the chart
 * above. Don't be confused with the state DEL) for all the states,
 * remove user from Cache1Q, Cache2Q, AliveQ or ByeQ, as well as
 * removing it from Hash
 *
 * Cache1Q->AliveQ - move from Cache1Q to AliveQ
 * ByeQ->          - remove from ByeQ
 * Cache1Q         - move to head of Cache1Q
 * T1->T           - set timer to T1
 * X               - invalid
 * ---             - ignore user event
 *
 * */

/* flags mask */
#define RTPPARINFO_FLAG_START_MUTED

/*
 * !!! WARNING !!!
 *
 * The offset to Cache1Q, ..., ByeQ MUST NOT be bigger than 1023 and
 * MUST be DWORD aligned (the offset value is stored as number of
 * DWORDS in rtppinfo.c using 8 bits)
 * */
#define CACHE1Q     RTPSTRUCTOFFSET(RtpAddr_t, Cache1Q)
#define CACHE2Q     RTPSTRUCTOFFSET(RtpAddr_t, Cache2Q)
#define ALIVEQ      RTPSTRUCTOFFSET(RtpAddr_t, AliveQ)
#define BYEQ        RTPSTRUCTOFFSET(RtpAddr_t, ByeQ)

#if USE_GRAPHEDT > 0
#define RTPPARINFO_MASK_RECV_DEFAULT ( (1 << RTPPARINFO_CREATED) | \
                                     (1 << RTPPARINFO_BYE) )

#define RTPPARINFO_MASK_SEND_DEFAULT ( (1 << RTPPARINFO_CREATED) | \
                                     (1 << RTPPARINFO_BYE) )
#else
#define RTPPARINFO_MASK_RECV_DEFAULT 0
#define RTPPARINFO_MASK_SEND_DEFAULT 0
#endif

HRESULT ControlRtpParInfo(RtpControlStruct_t *pRtpControlStruct);

DWORD RtpUpdateUserState(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        DWORD            dwUserEvent
    );

/* Enum the SSRCs upto the available size (in DWORDs), if pdwSSRC is
 * NULL, return the current number of SSRCs in *pdwNumber */
HRESULT RtpEnumParticipants(
        RtpAddr_t       *pRtpAddr,
        DWORD           *pdwSSRC,
        DWORD           *pdwNumber
    );

/* Access the states machine to obtain the next state based on the
 * current state and the user event */
DWORD RtpGetNextUserState(
        DWORD            dwCurrentState,
        DWORD            dwUserEvent
    );


/*********************************************************************
 * Control word definition to set/query bits or values in a RtpUser_t
 *
 * The idea is to use a control word to define the type of operation
 * to perform in a bit of a DWORD inside a structure, or a sequence of
 * bytes inside that same structure, so a single function can be used
 * to set/query a bit/dword/structure (dword is a sequence of 4 bytes
 * and a structure is a sequence of N bytes) inside any structure.
 *
 * WARNING:
 *
 * note that the maximum bytes that can be queried/set is limited to
 * 255 bytes, and the offset is limited to 1023 bytes
 *********************************************************************

      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |S|             |s|q|F|     |    bit/size   |      offset       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v               v v v       \------v------/ \--------v---------/
    |               | | |              |                 |
    |               | | |              |           bytes offset (10)
    |               | | |              |   
    |               | | | bit if F is set,number of bytes otherwise (8)
    |               | | |
    |               | | Select Flag or bytes (1)
    |               | |
    |               | Query is enabled (1) (not used)
    |               |
    |               Set is enabled (1) (not used)
    |
    Select Set or Query (1)

 */

/*******
 * Bit S
 *******/
 
/* Position of S in the control dword */
#define RTPUSER_BIT_SET           31

/* Builds the mask to encode the S bit as query (get) */
#define RTPUSER_INFO_QUERY        (0 << RTPUSER_BIT_SET)

/* Builds the mask to encode the S bit as set */
#define RTPUSER_INFO_SET          (1 << RTPUSER_BIT_SET)

/* Test if this is a set operation (otherwise is a query) */
#define RTPUSER_IsSetting(_dwControl) \
                                  (RtpBitTest(_dwControl, RTPUSER_BIT_SET))

/*******
 * Bit F
 *******/

/* Position of F in the control dword */
#define RTPUSER_BIT_FLAG          21

/* Builds the mask to encode the F bit as flag */
#define RTPUSER_INFO_BYTES        (0 << RTPUSER_BIT_FLAG)

/* Builds the mask to encode the F bit as flag */
#define RTPUSER_INFO_FLAG         (1 << RTPUSER_BIT_FLAG)

/* Test if this operation is on a flag (otherwise is on a DWORD) */
#define RTPUSER_IsFlag(_ctrl)     (RtpBitTest(_ctrl, RTPUSER_BIT_FLAG))


/**********
 * Bit/size
 **********/

/* Builds the mask to encode the bit into the control dword */
#define RTPUSER_PAR_BIT(_bit)     (((_bit) & 0x1f) << 10)

/* Retrives the bits from the control dword */
#define RTPUSER_GET_BIT(_ctrl)    (((_ctrl) >> 10) & 0x1f)

/* Builds the mask to encode the number of bytes into the control
 * dword */
#define RTPUSER_PAR_SIZE(_size)   (((_size) & 0xff) << 10)

/* Retrives the number of bytes from the control dword */
#define RTPUSER_GET_SIZE(_ctrl)   (((_ctrl) >> 10) & 0xff)

/********
 * Offset
 ********/

/* Builds the mask to encode the offset into the control dword */
#define RTPUSER_PAR_OFF(_offset)  ((_offset) & 0x3ff))

/* Retrives the offset from the control dword */
#define RTPUSER_GET_OFF(_ctrl)    ((_ctrl) & 0x3ff)

/* Define some offsets to use */
#define RTPUSER_STATE_OFFSET      RTPSTRUCTOFFSET(RtpUser_t, dwUserState)
#define RTPUSER_FLAGS_OFFSET      RTPSTRUCTOFFSET(RtpUser_t, dwUserFlags2)
#define RTPUSER_NETINFO_OFFSET    RTPSTRUCTOFFSET(RtpUser_t, RtpNetInfo)
#define RTPADDR_FLAGS_OFFSET      RTPSTRUCTOFFSET(RtpAddr_t, dwAddrFlags)

/*
 * The following control dwords are used in RtpMofifyParticipantInfo
 * as the dwControl parameter to encode the action to take. The
 * actions include query or set flags (e.g. mute state), query or set
 * values (e.g. user state)
 *
 * The flags are defined in struct.h for the RtpUser_t structure, the
 * DWORD values are also fields inthe RtpUser_t structure, also in
 * struct.h */

/* Get the user state (e.g SILENT, TALKING) as a DWORD  */
#define RTPUSER_GET_PARSTATE    ( RTPUSER_INFO_QUERY | \
                                  RTPUSER_INFO_BYTES | \
                                  RTPUSER_PAR_SIZE(sizeof(DWORD)) | \
                                  RTPUSER_STATE_OFFSET )

/* Get the mute state */
#define RTPUSER_GET_MUTE        ( RTPUSER_INFO_QUERY | \
                                  RTPUSER_INFO_FLAG  | \
                                  RTPUSER_PAR_BIT(FGUSER2_MUTED) | \
                                  RTPUSER_FLAGS_OFFSET )

/* Set the mute state */
#define RTPUSER_SET_MUTE        ( RTPUSER_INFO_SET   | \
                                  RTPUSER_INFO_FLAG  | \
                                  RTPUSER_PAR_BIT(FGUSER2_MUTED) | \
                                  RTPUSER_FLAGS_OFFSET )


/* Get the network event state */
#define RTPUSER_GET_NETEVENT    ( RTPUSER_INFO_QUERY | \
                                  RTPUSER_INFO_FLAG  | \
                                  RTPUSER_PAR_BIT(FGUSER2_NETEVENTS) | \
                                  RTPUSER_FLAGS_OFFSET )

/* Set the network event state */
#define RTPUSER_SET_NETEVENT    ( RTPUSER_INFO_SET   | \
                                  RTPUSER_INFO_FLAG  | \
                                  RTPUSER_PAR_BIT(FGUSER2_NETEVENTS) | \
                                  RTPUSER_FLAGS_OFFSET )

/* Set the network event state for any and all SSRCs*/
#define RTPUSER_SET_NETEVENTALL ( RTPUSER_INFO_SET   | \
                                  RTPUSER_INFO_FLAG  | \
                                  RTPUSER_PAR_BIT(FGADDR_NETMETRIC) | \
                                  RTPADDR_FLAGS_OFFSET )

/* Get the network information as an RtpNetInfo_t structure */
#define RTPUSER_GET_NETINFO     ( RTPUSER_INFO_QUERY | \
                                  RTPUSER_INFO_BYTES | \
                                  RTPUSER_PAR_SIZE(sizeof(RtpNetInfo_t)) | \
                                  RTPUSER_NETINFO_OFFSET )


HRESULT RtpMofifyParticipantInfo(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSSRC,
        DWORD            dwControl,
        DWORD           *pdwValue
    );

extern const TCHAR_t        **g_psRtpUserStates;

extern const DWORD            g_dwTimesRtcpInterval[];

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtppinfo_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpsend.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpsend.h
 *
 *  Abstract:
 *
 *    RTP send
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/24 created
 *
 **********************************************************************/
#ifndef _rtpsend_h_
#define _rtpsend_h_

HRESULT RtpSendTo_(
        RtpAddr_t *pRtpAddr,
        WSABUF    *pWSABuf,
        DWORD      dwWSABufCount,
        DWORD      dwTimeStamp,
        DWORD      dwSendFlags
    );

#endif /* _rtpsend_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpreg.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2000
 *
 *  File name:
 *
 *    rtpreg.h
 *
 *  Abstract:
 *
 *    Registry initialization and configuration
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/01/21 created
 *
 **********************************************************************/

#ifndef _rtpreg_h_
#define _rtpreg_h_

#include "gtypes.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/* Flags in RtpReg_t.dwQosFlags */
enum {
    FGREGQOS_FIRST,

    /* Used to force the result of queries to allowed to send */
    FGREGQOS_FORCE_ALLOWEDTOSEND_RESULT,
    FGREGQOS_FORCE_ALLOWEDTOSEND,
    FGREGQOS_DONOTSET_BORROWMODE,
    
    FGREGQOS_LAST
};

typedef struct _RtpReg_t {
    /* Default address and port */
    TCHAR           *psDefaultIPAddress;
    DWORD            dwDefaultLocalPort;
    DWORD            dwDefaultRemotePort;
    DWORD            dwMcastLoopbackMode;
    
    /* QOS */
    DWORD            dwQosEnable; /* 10B=disable, 11B=enable */
    DWORD            dwQosFlags;
    DWORD            dwQosRsvpStyle;
    DWORD            dwQosMaxParticipants;
    DWORD            dwQosSendMode;
    TCHAR           *psQosPayloadType;

    TCHAR           *psQosAppName;
    TCHAR           *psQosAppGUID;
    TCHAR           *psQosPolicyLocator;
    
    /* Default SDES information */
    DWORD            dwSdesEnable;
    TCHAR           *psCNAME;
    TCHAR           *psNAME;
    TCHAR           *psEMAIL;
    TCHAR           *psPHONE;
    TCHAR           *psLOC;
    TCHAR           *psTOOL;
    TCHAR           *psNOTE;
    TCHAR           *psPRIV;
    TCHAR           *psBYE;

    /* Default Encryption */
    DWORD            dwCryptEnable;
    DWORD            dwCryptMode;
    TCHAR           *psCryptHashAlg;
    TCHAR           *psCryptDataAlg;
    TCHAR           *psCryptPassPhrase;

    /* Events */
    DWORD            dwEventsReceiver; /* 2=disable, 3=enable */
    DWORD            dwEventsSender;   /* 2=disable, 3=enable */
    DWORD            dwEventsRtp;
    DWORD            dwEventsPInfo;
    DWORD            dwEventsQos;
    DWORD            dwEventsSdes;

    /* Playout delay */
    DWORD            dwPlayoutEnable;
    DWORD            dwMinPlayout; /* millisecs */
    DWORD            dwMaxPlayout; /* millisecs */
    
    /* Redundancy */
    DWORD            dwRedEnable;
    /* b13,b12 enable/disable redundancy thresholds (3=enable,2=disable)
     * b9,b8   enable/disable updating the sender's redundancy distance
     * b5,b4   enable/disable redundancy for sender
     * b1,b0   enable/disable redundancy for receiver
     */
    DWORD            dwRedPT;
    DWORD            dwInitialRedDistance;
    DWORD            dwMaxRedDistance;
    DWORD            dwRedEarlyTimeout; /* ms */
    DWORD            dwRedEarlyPost;    /* ms */
    DWORD            dwLossRateThresh0; /* 16 msbits=high, 16 lsbits=low */
    DWORD            dwLossRateThresh1; /* 16 msbits=high, 16 lsbits=low */
    DWORD            dwLossRateThresh2; /* 16 msbits=high, 16 lsbits=low */
    DWORD            dwLossRateThresh3; /* 16 msbits=high, 16 lsbits=low */
    
    /* GenLosses */
    DWORD            dwGenLossEnable;
    DWORD            dwRecvLossRate;
    DWORD            dwSendLossRate;

    /* Bandwidth estimation */
    DWORD            dwBandEstEnable; /* 2=disable, 3=enable */
    DWORD            dwBandEstModulo;
    /* b24-b31 (8) Receiver's min reports
     * b23-b16 (8) Sender's initial count
     * b15-b8 (8)  Initial modulo
     * b7-b0 (8)   Normal modulo
     */
    DWORD            dwBandEstTTL; /* Estimation is reported while no
                                    * older than this (seconds) */
    DWORD            dwBandEstWait;/* An event is posted if no estimation
                                    * is available within this (seconds) */
    DWORD            dwBandEstMaxGap;/* Maximum time (milliseconds)
                                      * gap to use 2 consecutive RTCP
                                      * SR reports for bandwidth
                                      * estimation */
    union {
        DWORD            dwBandEstBin[RTCP_BANDESTIMATION_MAXBINS + 1];
        
        struct {
            /*
             * WARNING
             *
             * Make sure to keep the number of individual bins to be
             * RTCP_BANDESTIMATION_MAXBINS+1, same thing in rtpreg.c
             * and rtcpsend.c */
            DWORD        dwBandEstBin0;
            DWORD        dwBandEstBin1;
            DWORD        dwBandEstBin2;
            DWORD        dwBandEstBin3;
            DWORD        dwBandEstBin4;
        };
    };

    /* Network quality */
    DWORD            dwNetQualityEnable;
    /* b1,b0   enable/disable computing network quality */
} RtpReg_t;

#define RTPREG_NOVALUESET NO_DW_VALUESET
#define IsRegValueSet(dw) IsDWValueSet(dw)

extern RtpReg_t         g_RtpReg;

void RtpRegistryInit(RtpReg_t *pRtpReg);

void RtpRegistryDel(RtpReg_t *pRtpReg);

/* Prototype to functions that initialize some global variables that
 * depend on the registry readings. These functions are called from
 * inside RtpRegistryInit() */
void RtpSetRedParametersFromRegistry(void);
void RtpSetMinMaxPlayoutFromRegistry(void);
void RtpSetBandEstFromRegistry(void);

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpreg_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpsess.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpsess.h
 *
 *  Abstract:
 *
 *    Get, Initialize and Delete RTP sessions (RtpSess_t)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/02 created
 *
 **********************************************************************/

#ifndef _rtpsess_h_
#define _rtpsess_h_

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

HRESULT GetRtpSess(
        RtpSess_t **ppRtpSess
    );

HRESULT DelRtpSess(
        RtpSess_t *pRtpSess
    );

HRESULT GetRtpAddr(
        RtpSess_t  *pRtpSess,
        RtpAddr_t **ppRtpAddr,
        DWORD       dwFlags
    );

HRESULT DelRtpAddr(
        RtpSess_t *pRtpSess,
        RtpAddr_t *pRtpAddr
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpsess_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpstart.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpstart.h
 *
 *  Abstract:
 *
 *    Start/Stop RTP session (and allits addresses)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/24 created
 *
 **********************************************************************/
#ifndef _rtpstart_h_
#define _rtpstart_h_

HRESULT RtpStart_(
        RtpSess_t *pRtpSess,
        DWORD      dwFlags
    );

HRESULT RtpStop_(
        RtpSess_t *pRtpSess,
        DWORD      dwFlags
    );

#endif /* _rtpstart_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtprtp.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtprtp.h
 *
 *  Abstract:
 *
 *    Implements the RTP Specific family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtprtp_h_
#define _rtprtp_h_

#include "rtpfwrap.h"

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

/***********************************************************************
 *
 * RTP Specific functions family
 *
 **********************************************************************/
#if 0
enum {
    RTPRTP_FIRST,
    RTPRTP_EVENT_MASK,
    RTPRTP_TEST_EVENT_MASK,
    RTPRTP_FEATURE_MASK,
    RTPRTP_TEST_FEATURE_MASK,
    RTPRTP_DATACLOCK,
    RTPRTP_LAST
};


/* feature bits */
enum {
    RTPRTP_E_FIRST,
    RTPRTP_E_FEAT_PORT_ODDEVEN,
    RTPRTP_E_FEAT_PORT_SEQUENCE,
    RTPRTP_E_FEAT_RTCPENABLED,
    RTPRTP_E_LAST
};
    
/* feature masks */
#define RTPRTP_FEAT_PORT_ODDEVEN   fg_par(RTPRTP_E_FEAT_PORT_ODDEVEN)
#define RTPRTP_FEAT_PORT_SEQUENCE  fg_par(RTPRTP_E_FEAT_PORT_SEQUENCE)
#define RTPRTP_FEAT_RTCPENABLED    fg_par(RTPRTP_E_FEAT_RTCPENABLED)
#endif

#define RTPRTP_EVENT_RECV_DEFAULT 0
#define RTPRTP_EVENT_SEND_DEFAULT 0

HRESULT ControlRtpRtp(RtpControlStruct_t *pRtpControlStruct);

DWORD RtpSetBandwidth(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwInboundBw,
        DWORD            dwOutboundBw,
        DWORD            dwReceiversRtcpBw,
        DWORD            dwSendersRtcpBw
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#endif /* _rtprtp_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpstats.h ===
/**********************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  File name:
 *
 *    rtpstats.h
 *
 *  Abstract:
 *
 *    Implements the Statistics family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtpstats_h_
#define _rtpstats_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Statistics family
 *
 **********************************************************************/

/* functions */
enum {
    RTPSTATS_FIRST,
    RTPSTATS_RTPSTATS_GLOBAL_STATS,
    RTPSTATS_PARTICIPANT_RECV,
    RTPSTATS_STATS_MASK,
    RTPSTATS_TEST_STATS_MASK,
    RTPSTATS_LAST
};
 
/* flags */
#define RTPSTATS_FG_RECV
#define RTPSTATS_FG_SEND


#define SESS_FG_IS_JOINED
#define SESS_FG_MULTICAST_LOOPBACK
#define SESS_FG_RTCP_ENABLED
#define SESS_FG_ALLOWED_TO_SEND
#define SESS_FG_RECEIVERS
#define SESS_FG_QOS_STATE
#define SESS_FG_SHARED_STYLE
#define SESS_FG_FAIL_IF_NO_QOS
#define SESS_FG_IS_MULTICAST

HRESULT ControlRtpStats(RtpControlStruct_t *pRtpControlStruct);

/* Helper function to update counters */
BOOL UpdateRtpStat(RtpStat_t *pRtpStat,/* structure where to update */
                   DWORD      dwRtpRtcp, /* 0=RTP or 1=RTCP stats */
                   DWORD      dwBytes, /* bytes to update */
                   DWORD      dwTime); /* time packet recv/send */
#if 0
/* Creates and initializes a RtpStat_t structure */
RtpStat_t *RtpStatAlloc(void);

/* Frees a RtpStat_t structure */
void RtpStatFree(RtpStat_t *pRtpStat);
#endif

#endif /* _rtpstats_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\struct.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    struct.h
 *
 *  Abstract:
 *
 *    Main data structures
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#ifndef _struct_h_
#define _struct_h_

#include <winsock2.h>
#include <wincrypt.h>

#include "gtypes.h"
#include "rtphdr.h"
#include "rtpque.h"
#include "rtpcrit.h"
#include "rtpchan.h"

#include <qossp.h>

/*
 * Forward declarations. */
typedef struct _RtpSdesSched_t  RtpSdesSched_t;
typedef struct _RtpNetCount_t   RtpNetCount_t;
typedef struct _RtpSess_t       RtpSess_t;
typedef struct _RtpAddr_t       RtpAddr_t;
typedef struct _RtpNetRState_t  RtpNetRState_t;
typedef struct _RtpNetSState_t  RtpNetSState_t;
typedef struct _RtpUser_t       RtpUser_t;
typedef struct _RtpOutput_t     RtpOutput_t;
typedef struct _RtpSdesItem_t   RtpSdesItem_t;
typedef struct _RtpSdes_t       RtpSdes_t;
typedef struct _RtpQosNotify_t  RtpQosNotify_t;
typedef struct _RtpQosReserve_t RtpQosReserve_t;
typedef struct _RtpCrypt_t      RtpCrypt_t;
typedef struct _RtpRecvIO_t     RtpRecvIO_t;
typedef struct _RtpSendIO_t     RtpSendIO_t;
typedef struct _RtcpRecvIO_t    RtcpRecvIO_t;
typedef struct _RtcpSendIO_t    RtcpSendIO_t;
typedef struct _RtcpAddrDesc_t  RtcpAddrDesc_t;
typedef struct _RtpContext_t    RtpContext_t;
typedef struct _RtpRedEntry_t   RtpRedEntry_t;

/* Default bandwidth allocated per session (used to compute RTCP
 * bandwidth)
 * bits/sec (200 Kbits/sec) */
#define DEFAULT_SESSBW          (300 * 1000)

/* 75% out of the 5% for RTCP (bits/sec) */
#define DEFAULT_BWRECEIVERS     (DEFAULT_SESSBW * (5 * 75) / 10000)

/* 25% out of the 5% for RTCP (bits/sec) */
#define DEFAULT_BWSENDERS       (DEFAULT_SESSBW * (5 * 25) / 10000)

#define DEFAULT_RTCP_MIN_INTERVAL 5.0 /* secs */

#define SIZEOF_UDP_IP_HDR       (8+20)

#define BIG_TIME (1e12)

#define DEFAULT_ALPHA           (0.998002)
#define MIN_PLAYOUT             10          /* Milliseconds */
#define MAX_PLAYOUT             500         /* Milliseconds */
#define GAPFORTALKSPURT         200         /* Milliseconds */
#define DEFAULT_SAMPLING_FREQ   8000        /* Hz */
#define MINTIMEBETWEENMARKERBIT (0.5)       /* Seconds */

#define RELATIVE_DELAY          1.0         /* Seconds */
#define SHORTDELAYCOUNT         8

/* Receiver and sender buffer size */
#define RTCP_RECVDATA_BUFFER    1500
#define RTCP_SENDDATA_BUFFER    1500

/* Boundaries for RTP ports allocated */
#define RTPPORT_LOWER           5004

#define MAX_DROPOUT             3000
#define MAX_MISORDER            100
#define MIN_SEQUENTIAL          3


/* Redundancy */
#define RTP_RED_DEFAULTPT       97  /* Default payload */
#define RTP_RED_MAXRED          1   /* Number of redundant blocks */
#define RTP_RED_MAXDISTANCE     3   /* Maximum redundancy distance, i.e. i-3 */
#define RTP_RED_INITIALDISTANCE 0   /* Initial redundancy distance */

/* The timeout used when scheduling a received packet to be posted at
 * a later time will be decreased by this value */
#define RTP_RED_EARLY_TIMEOUT   (5e-3)
/* Will post immediatly (instead of scheduling for later) if the due
 * time is at least this close. This value can not be smaller than the
 * early timeout */
#define RTP_RED_EARLY_POST      (RTP_RED_EARLY_TIMEOUT+5e-3)

/* Multiply loss rate by this factor and do integer arithmetic */
#define LOSS_RATE_FACTOR        1000

/* Redundancy loss rate low and high thresholds for each distance
   0:   0,  5
   1:   4,  10
   2:   9,  15
   3:  14,  20
 */
#define RED_LT_0                ( 0 * LOSS_RATE_FACTOR)
#define RED_HT_0                ( 5 * LOSS_RATE_FACTOR)
#define RED_LT_1                ( 4 * LOSS_RATE_FACTOR)
#define RED_HT_1                (10 * LOSS_RATE_FACTOR)
#define RED_LT_2                ( 9 * LOSS_RATE_FACTOR)
#define RED_HT_2                (15 * LOSS_RATE_FACTOR)
#define RED_LT_3                (14 * LOSS_RATE_FACTOR)
#define RED_HT_3                (20 * LOSS_RATE_FACTOR)

/* Factor to grow the average loss rate */
#define LOSS_RATE_ALPHA_UP      2
/* Factor to decrease the average loss rate */
#define LOSS_RATE_ALPHA_DN      4


/**********************************************************************
 * Bandwidth estimation
 **********************************************************************/
/* The initial count is the number of reports that will use
 * MOD_INITIAL to decide if a probe packet is sent, after that
 * MOD_FINAL will be used. */
#define RTCP_BANDESTIMATION_INITIAL_COUNT  8

/* Number or valid reports received before the estimation is posted
 * for the first time */
#define RTCP_BANDESTIMATION_MINREPORTS     5

/* When doing bandwidth estimation, send an RTCP SR probe packet this
 * modulo (note that a probe packet also counts for the module, so
 * mod=2 means send a probe packet every RTCP SR sent; mod=5 means
 * send a probe every fourth RTCP SR sent). */
#define RTCP_BANDESTIMATION_MOD_INITIAL    2
#define RTCP_BANDESTIMATION_MOD_FINAL      5

/* Number of bins to keep */
#define RTCP_BANDESTIMATION_MAXBINS        4

/* Boundaries for each bin (note there is 1 more than the number of
 * bins) */
#define RTCP_BANDESTIMATION_BIN0       15000  /* bps */
#define RTCP_BANDESTIMATION_BIN1       70000  /* bps */
#define RTCP_BANDESTIMATION_BIN2      200000  /* bps */
#define RTCP_BANDESTIMATION_BIN3     1000000  /* bps */
#define RTCP_BANDESTIMATION_BIN4   100000000  /* bps */

/* Life time span of the bandwidth estimation validity */
#define RTCP_BANDESTIMATION_TTL         30.0 /* Seconds */

/* Time to wait after the first RB has been received to declare that
 * bandwidth estimation is not supported by the remote end and hence a
 * notification issued to the upper layer */
#define RTCP_BANDESTIMATION_WAIT        30.0 /* Seconds */

/* Maximum time gap between the sending time of two consecutive SR
 * reports to do bandwidth estimation (queueing latency) */
#define RTCP_BANDESTIMATION_MAXGAP      0.090 /* Seconds */

#define RTCP_BANDESTIMATION_NOBIN       ((DWORD)-1)

/**********************************************************************
 * Network quality metric
 **********************************************************************/
/* Minimum network quality metric change (percentage) to consider it
 * worth an update */
#define RTPNET_MINNETWORKCHANGE         10

/* Generic factor to smooth some parameters */
#define RTP_GENERIC_ALPHA               0.75

/* Maximum audio frame size allowed to use packet duplication
 * technique to recover single losses */
#define RTP_MAXFRAMESIZE_PACKETDUP      0.050    /* Seconds */

/* The following macros define the minimum and maximum values to
 * evaluate network quality, e.g. below the minimum RTT that parameter
 * is excelent, above that is the worst, in between we obtain a 0 -
 * 100 quality level */

/* Class audio */
#define NETQA_RTT_MIN                    (0.040)  /* seconds */
#define NETQA_RTT_MAX                    (0.400)  /* seconds */
#define NETQA_JITTER_MIN                 (0.015)  /* seconds */
#define NETQA_JITTER_MAX                 (0.200)  /* seconds */
#define NETQA_LOSSES_MIN                 (5.0)    /* percentage */
#define NETQA_LOSSES_MAX                 (30.0)   /* percentage */

/* Class video */
#define NETQV_RTT_MIN                    (0.040)  /* seconds */
#define NETQV_RTT_MAX                    (0.400)  /* seconds */
#define NETQV_JITTER_MIN                 (0.015)  /* seconds */
#define NETQV_JITTER_MAX                 (5.000)  /* seconds */
#define NETQV_LOSSES_MIN                 (5.0)    /* percentage */
#define NETQV_LOSSES_MAX                 (30.0)   /* percentage */


/**********************************************************************
 * SDES sending schedule
 **********************************************************************/
typedef struct _RtpSdesSched_t {
    DWORD             L1;
    DWORD             L2;
    DWORD             L3;
    DWORD             L4;
} RtpSdesSched_t;

/**********************************************************************
 * Holds the receiver/sender network counters (MAYDO would be nice
 * to have it shared memory).
 **********************************************************************/
typedef struct _RtpNetCount_t {
    /* +++ RTP +++ */
    DWORD            dwRTPBytes;      /* Number of bytes */
    DWORD            dwRTPPackets;    /* Number of packets */
    DWORD            dwRTPBadPackets; /* Number of bad packets */
    DWORD            dwRTPDrpPackets; /* Number of good packets dropped */
    double           dRTPLastTime;    /* Last time a packet was recv/send */

    /* +++ RTCP +++ */
    DWORD            dwRTCPBytes;     /* Number of bytes */
    DWORD            dwRTCPPackets;   /* Number of packets */
    DWORD            dwRTCPBadPackets;/* Number of bad packets */
    DWORD            dwRTCPDrpPackets;/* Number of good packets dropped */
    double           dRTCPLastTime;   /* Last time a packet was recv/send */
} RtpNetCount_t;

/**********************************************************************
 * Callback function to generate DShow events through
 * CBaseFilter::NotifyEvent()
 **********************************************************************/
typedef void (CALLBACK *PDSHANDLENOTIFYEVENTFUNC)(
        void            *pvUserInfo,/* pCRtpSourceFilte or pCRtpRenderFilter */
        long             EventCode,
        LONG_PTR         EventParam1,
        LONG_PTR         EventParam2
    );

/**********************************************************************
 * RTP reception callback function pass by the application (DShow)
 **********************************************************************/
typedef void (CALLBACK *PRTP_RECVCOMPLETIONFUNC)(
        void            *pvUserInfo1,
        void            *pvUserInfo2,
        void            *pvUserInfo3,
        RtpUser_t       *pRtpUser,
        double           dPlayTime,
        DWORD            dwError,
        long             lHdrSize,
        DWORD            dwTransfered,
        DWORD            dwFlags
    );

/**********************************************************************
 * RTCP reception callback function
 **********************************************************************/
typedef void (CALLBACK *PRTCP_RECVCOMPLETIONFUNC)(
        void            *pvUserInfo1,
        void            *pvUserInfo2,
        DWORD            dwError,
        DWORD            dwTransfered,
        DWORD            dwFlags
    );

/**********************************************************************
 * A full duplex RTP session which can have one or more addresses
 * either unicast or multicast. Obtained from g_pRtpSessHeap.
 **********************************************************************/

/* Some flags in RtpSess_t.dwSessFlags */
enum {
    FGSESS_FIRST,

    FGSESS_EVENTRECV,   /* Enable events as receiver */
    FGSESS_EVENTSEND,   /* Enable events as sender */

    FGSESS_LAST
};

typedef struct _RtpSess_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpQueueItem_t   SessQItem;       /* Sessions in g_RtpContext.RtpSessQ */
    long             lSessRefCount[2];/* Sessions are shared */
    RtpCritSect_t    SessCritSect;    /* Lock */
    RtpQueue_t       RtpAddrQ;        /* Addresses queue */
    DWORD            dwSessFlags;     /* RtpSess_t flags */
    void            *pvSessUser[2];   /* Pointers to users' session */
    PDSHANDLENOTIFYEVENTFUNC pHandleNotifyEvent;

    RtpQueue_t       OutputQ;         /* Outputs queue */
    RtpCritSect_t    OutputCritSect;  /* Lock to access RtpOutQ */

    /* Masks */
    DWORD            dwFeatureMask;   /* Features mask */
    DWORD            dwEventMask[2];  /* Recv/Send RTP/RTCP event mask */
    DWORD            dwPartEventMask[2];/* Recv/Send participant events mask */
    DWORD            dwQosEventMask[2];/* Recv/Send QOS event mask */
    DWORD            dwSdesEventMask[2];/* Recv/Send remote SDES event mask */
    DWORD            dwSdesMask[2];   /* 0:What SDES sent if
                                       * available, 1:What SDES stored
                                       * when received */
    /* SDES control */
    DWORD            dwSdesPresent;   /* What items are already stored */
    RtpSdes_t       *pRtpSdes;        /* local SDES information */
    RtpSdesSched_t   RtpSdesSched;    /* SDES scheduling */
    
    /* Network counters */
    RtpNetCount_t    RtpSessCount[2]; /* Recv/Send network counters */
} RtpSess_t;

/**********************************************************************
 * Per sender network state information, keeps sequence number
 * extended sequence number, as well as other counters used to compute
 * losses and jitter
 **********************************************************************/

/* Some flags used in RtpNetSState_t.dwNetSFlags */
enum {
    FGNETS_FIRST,

    FGNETS_RTCPRECVBWSET, /* The RTCP bandwidth for receivers has been set */
    FGNETS_RTCPSENDBWSET, /* The RTCP bandwidth for senders has been set */

    FGNETS_DUMMY3,
    
    FGNETS_1STBANDPOSTED, /* First bandwidth estimation posted */
    FGNETS_NOBANDPOSTED,  /* No bandwidth estimation available posted */

    FGNETS_DONOTSENDPROBE,/* Direct RTCP not to send probing packets */

    FGNETS_LAST
};

typedef struct NetSFlags_f {
    DWORD            Dummy0:1;
    /* The RTCP bandwidth for receivers has been set */
    DWORD            RtcpRecvBWSet:1;
    /* The RTCP bandwidth for senders has been set */
    DWORD            RtcpSendBWSet:1;
    DWORD            Dummy3:1;
    /* First bandwidth estimation posted */
    DWORD            FirstBandEstPosted:1;
    /* "No bandwidth estimation available" event posted */
    DWORD            NoBandEstEventPosted:1;
} NetSFlags_f;

typedef struct _RtpNetSState_t {
    /* Flags */
    union {
        DWORD            dwNetSFlags;
        NetSFlags_f      NetSFlags;
    };
    
    /* RTP Sender */
    union {
        struct {
            WORD             wSeq:16; /* Sending sequence number */
            WORD             wSeqH:16;/* High part for the sequence number */
        };
        DWORD            dwSeq;       /* 32bits sequence number */
    };
        
    BYTE             bPT;           /* Payload type used on each packet sent */
    BYTE             bPT_Dtmf;      /* Payload type in DTMF packets */
    BYTE             bPT_RedSend;   /* Payload type to send redun. encoding */
    BYTE             bMarker;       /* marker bit for next packet sent */
    DWORD            dwSendSSRC;    /* NETWORK ORDER: Packets sent
                                     * have this SSRC */
    DWORD            dwSendSamplingFreq;/* Payload's sampling frequency */

    /* Redundancy control */
    DWORD            dwSendSamplesPerPacket;/* Samples in each packet */
    DWORD            dwInitialRedDistance;/* Initial redundancy distance */
    DWORD            dwCurRedDistance;  /* Current redundancy distance */
    DWORD            dwNxtRedDistance;  /* Next redundancy distance */
    DWORD            dwMaxRedDistance;  /* Max redundancy distance */
    int              iLastLossRateS;    /* Last loss rate reported */
    int              iAvgLossRateS;     /* Average loss rate
                                         * (percent * LOSS_RATE_FACTOR) */
    DWORD            dwRedIndex;        /* Next entry where to save a frame */
    DWORD            dwRedEntries;      /* number of entries */
    RtpRedEntry_t   *pRtpRedEntry;      /* Points to array of red entries */
    
    DWORD            dwSendTimeStamp;  /* Current timestamp */
    DWORD            dwPreviousTimeStamp;
    DWORD            dwTimeStampOffset;/* Random offset to the timestamp */
    double           dTimeLastRtpSent; /* Time last RTP packet was sent */

    double           avg_rtcp_size; /* Average RTCP packet size sent (bits) */
    DWORD            dwInboundBandwidth; /* bits/second */
    DWORD            dwOutboundBandwidth;/* bits/second */
    DWORD            dwRtcpBwReceivers;  /* bits/sec */
    DWORD            dwRtcpBwSenders;  /* bits/sec */
    double           dRtcpMinInterval; /* Min interval report (secs) */
    double           dRtcpInterval;    /* Last RTCP interval report (secs) */
    BOOL             bWeSent;          /* Are we sending? */

    /* Bandwidth estimation */
    DWORD            dwBandEstMod;
    double           dwBandEstCount;
    double           dLastTimeEstimationPosted;
} RtpNetSState_t;

/**********************************************************************
 * Each address in an RTP session. Obtained from g_pRtpAddrHeap.
 **********************************************************************/

/* Some flags in RtpAddr_t.dwIRtpFlags (CIRtpSession flags) */
/*
 * WARNING
 *
 * Be aware that the RTPINITFG_* flags defined in msrtp.h, are mapped
 * to the FGADDR_IRTP_* flags below
 * */
enum {
    FGADDR_IRTP_FIRST,

    FGADDR_IRTP_INITDONE,/* Initialization done */
    FGADDR_IRTP_ISRECV,  /* Is receiver */
    FGADDR_IRTP_ISSEND,  /* Is sender */

    FGADDR_IRTP_USEPLAYOUT,
    FGADDR_IRTP_DUMMY5,
    FGADDR_IRTP_DUMMY6,
    FGADDR_IRTP_DUMMY7,
    
    FGADDR_IRTP_AUTO,    /* Auto initialize */
    FGADDR_IRTP_QOS,     /* QOS enabled session */
    FGADDR_IRTP_PERSISTSSRC,    /* Persistent SSRC */
    FGADDR_IRTP_PERSISTSOCKETS, /* Persistent sockets */

    /* Class 0,1,2 are used to define the media class */
    FGADDR_IRTP_CLASS0,
    FGADDR_IRTP_CLASS1,
    FGADDR_IRTP_CLASS2,
    FGADDR_IRTP_DUMMY15,

    FGADDR_IRTP_MATCHRADDR, /* Discard packets not comming from the
                             * remote address */
    FGADDR_IRTP_RADDRRESETDEMUX,/* Reset the demux (unmap all outputs)
                                 * when a new remote address is set */

    FGADDR_IRTP_LAST
};

typedef struct _IRtpFlags_f {
    DWORD           Dummy0:1;
    DWORD           INITDONE:1;
    DWORD           ISRECV:1;
    DWORD           ISSEND:1;
    DWORD           USEPLAYOUT:1;
    DWORD           DUMMY5:3;
    DWORD           AUTO:1;
    DWORD           QOS:1;
    DWORD           PERSISTSSRC:1;
    DWORD           PERSISTSOCKETS:1;
    DWORD           CLASS:3;
    DWORD           Dummy15:1;
    DWORD           MATCHRADDR:1;
} IRtpFlags_f;

#define RtpGetClass(dw)  ((dw >> FGADDR_IRTP_CLASS0) & 0x7)

#define FGADDR_IRTP_MASK ( RtpBitPar(FGADDR_IRTP_AUTO)   | \
                           RtpBitPar(FGADDR_IRTP_QOS)    | \
                           RtpBitPar(FGADDR_IRTP_PERSISTSSRC)   | \
                           RtpBitPar(FGADDR_IRTP_PERSISTSOCKETS)| \
                           RtpBitPar(FGADDR_IRTP_CLASS0) | \
                           RtpBitPar(FGADDR_IRTP_CLASS1) | \
                           RtpBitPar(FGADDR_IRTP_CLASS2) | \
                           RtpBitPar(FGADDR_IRTP_MATCHRADDR)      | \
                           RtpBitPar(FGADDR_IRTP_RADDRRESETDEMUX) | \
                           0 \
                         )

#define RtpGetClass(dw) ((dw >> FGADDR_IRTP_CLASS0) & 0x7)

/* Some flags in RtpAddr_t.dwAddrFlags */
enum {
    FGADDR_FIRST,
    FGADDR_RANDOMINIT,  /* Random initialization done */

    /* RtpAddr flags */
    FGADDR_ISRECV,
    FGADDR_ISSEND,
    
    FGADDR_RUNRECV,      /* RECV running */
    FGADDR_RUNSEND,      /* SEND running */
    FGADDR_RTPTHREAD,    /* RTP reception thread already started */
    FGADDR_RTCPTHREAD,   /* RTCP thread already started */

    FGADDR_QOSRECV,      /* QOS required */
    FGADDR_QOSSEND,      /* QOS required */
    FGADDR_QOSRECVON,    /* QOS enabled */
    FGADDR_QOSSENDON,    /* QOS enabled */
    
    FGADDR_LADDR,        /* Local address already set */
    FGADDR_RADDR,        /* Remote address already set */
    FGADDR_ADDED,        /* Address added to RTCP */
    FGADDR_DUMMY15,
    
    FGADDR_SOCKET,       /* Sockets are created */
    FGADDR_SOCKOPT,      /* Socket options already set */
    FGADDR_FORCESTOP,    /* Bypass persistent sockets and really stop */
    FGADDR_DUMMY19,
    
    FGADDR_LOOPBACK_WS2, /* Winsock Mcast loopback enabled */
    FGADDR_LOOPBACK_SFT, /* RTP Mcast loopback enabled */
    FGADDR_COLLISION,    /* Collision detection enabled */
    FGADDR_ISMCAST,      /* Is a multicast session */

    FGADDR_MUTERTPRECV,  /* Mute RTP network reception */
    FGADDR_MUTERTPSEND,  /* Mute RTP network sending */
    FGADDR_REGUSEDRECV,  /* Read some registry settings for receiver */
    FGADDR_REGUSEDSEND,  /* Read some registry settings for sender */

    FGADDR_REDRECV,     /* Enable receiving redundant encoding */
    FGADDR_REDSEND,     /* Enable sending redundant encoding */
    FGADDR_NETMETRIC,   /* Compute net metrics for every body */
    
    FGADDR_LAST
};

typedef struct _AddrFlags_t {
    DWORD           Dummy0:1;
    DWORD           RANDOMINIT:1;
    DWORD           ISRECV:1;
    DWORD           ISSEND:1;
    DWORD           RUNRECV:1;
    DWORD           RUNSEND:1;
    DWORD           RTPTHREAD:1;
    DWORD           RTCPTHREAD:1;
    DWORD           QOSRECV:1;
    DWORD           QOSSEND:1;
    DWORD           QOSRECVON:1;
    DWORD           QOSSENDON:1;
    DWORD           LADDR:1;
    DWORD           RADDR:1;
    DWORD           ADDED:1;
    DWORD           Dummy15:1;
    DWORD           SOCKET:1;
    DWORD           SOCKOPT:1;
    DWORD           FORCESTOP:1;
    DWORD           Dummy19,:1;
    DWORD           LOOPBACK_WS2:1;
    DWORD           LOOPBACK_SFT:1;
    DWORD           COLLISION:1;
    DWORD           ISMCAST:1;
    DWORD           MUTERTPRECV:1;
    DWORD           MUTERTPSEND:1;
    DWORD           REGUSEDRECV:1;
    DWORD           REGUSEDSEND:1;
    DWORD           REDRECV:1;
    DWORD           REDSEND:1;
    DWORD           NETMETRIC:1;
} AddrFlags_f;

/* Some flags in RtpAddr_t.dwAddrFlagsQ (QOS) */
enum {
    FGADDRQ_FIRST,
    
    FGADDRQ_QOSRECVON,    /* Recv QOS session started */
    FGADDRQ_QOSSENDON,    /* send QOS session started */
    FGADDRQ_DUMMY3,

    FGADDRQ_CHKQOSSEND,  /* Check for allowed to send */
    FGADDRQ_QOSUNCONDSEND,/* Inconditional send */
    FGADDRQ_QOSCONDSEND, /* Conditional send */
    FGADDRQ_DUMMY7,
    
    FGADDRQ_QOSSEND,     /* Allows to send */
    FGADDRQ_QOSEVENTPOSTED,/* Not allowed to send event posted */
    FGADDRQ_RECVFSPEC_DEFINED,
    FGADDRQ_SENDFSPEC_DEFINED,

    FGADDRQ_QOSREDRECVON,/* Unused: Recv QOS with redundancy is on */
    FGADDRQ_QOSREDSENDON,/* Send QOS with redundancy is on */
    FGADDRQ_DUMMY14,
    FGADDRQ_DUMMY15,
    
    FGADDRQ_REGQOSDISABLE,/* QOS disabled from registry */
    FGADDRQ_QOSNOTALLOWED,/* QOS not allowed for this user */

    FGADDRQ_LAST
};

typedef struct _AddrFlagsQ_f {
    DWORD           Dummy0:1;
    DWORD           QOSRECVON:1;
    DWORD           QOSSENDON:1;
    DWORD           Dummy3:1;
    DWORD           CHKQOSSEND:1;
    DWORD           QOSUNCONDSEND:1;
    DWORD           QOSCONDSEND:1;
    DWORD           Dummy7:1;
    DWORD           QOSSEND:1;
    DWORD           QOSEVENTPOSTED:1;
    DWORD           RECVFSPEC_DEFINED:1;
    DWORD           SENDFSPEC_DEFINED:1;
    DWORD           QOSREDRECVON:1;
    DWORD           QOSREDSENDON:1;
    DWORD           FGADDRQ_DUMMY14:1;
    DWORD           FGADDRQ_DUMMY15:1;
    DWORD           REGQOSDISABLE:1;
    DWORD           QOSNOTALLOWED:1;  
} AddrFlagsQ_f;

/* Some flags in RtpAddr_t.dwAddrFlagsC (Cryptography) */
enum {
    FGADDRC_FIRST,
    
    FGADDRC_CRYPTRECVON, /* Crypt RECV initialized */
    FGADDRC_CRYPTSENDON, /* Crypt SEND initialized */
    FGADDRC_CRYPTRTCPON, /* Crypt RTCP initialized */
    
    FGADDRC_DUMMY4,
    FGADDRC_CRYPTRECV,   /* Decrypt RTP reception */
    FGADDRC_CRYPTSEND,   /* Encrypt RTP send */
    FGADDRC_CRYPTRTCP,   /* Encrypt/Decrypt RTCP */

    FGADDRC_LAST
};

typedef struct _AddrFlagsC_f {
    DWORD           Dummy0:1;
    DWORD           CRYPTRECVON:1;
    DWORD           CRYPTSENDON:1;
    DWORD           CRYPTRTCPON:1;
    DWORD           Dummy4:1;
    DWORD           CRYPTRECV:1;
    DWORD           CRYPTSEND:1;
    DWORD           CRYPTRTCP:1;
} AddrFlagsC_f;

/* Some flags in RtpAddr_t.dwAddrFlagsR (Receiver thread) */
enum {
    FGADDRR_FIRST,

    FGADDRR_QOSREDRECV,  /* Recv QOS with redundancy was requested */
    FGADDRR_UPDATEQOS,   /* QOS reservation needs to be updated for
                          * the current PT */
    FGADDRR_RESYNCDI,    /* Resync mean delay Di */

    FGADDRR_LAST
};

typedef struct _AddrFlagsR_f {
    DWORD           Dummy0:1;
    DWORD           QOSREDRECV:1;
    DWORD           UPDATEQOS:1;
    DWORD           RESYNCDI:1; 
} AddrFlagsR_f;

/* Some flags in RtpAddr_t.dwAddrFlagsS (Sender thread) */
enum {
    FGADDRS_FIRST,

    FGADDRS_FIRSTSENT,   /* First packet sent */
    FGADDRS_FRAMESIZE,   /* Frame size was learned */
    FGADDRS_QOSREDSEND,  /* Unused: Send QOS with redundancy was requested */
    
    FGADDRS_LAST
};

typedef struct _AddrFlagsS_f {
    DWORD           Dummy0:1;
    DWORD           FIRSTSENT:1;
    DWORD           FRAMESIZE:1;
    DWORD           QOSREDSEND:1;
} AddrFlagsS_f;

/* Some flags in RtpAddr_t.dwAddrRegFlags (registry) */
enum {
    FGADDRREG_FIRST,
    
    FGADDRREG_NETQFORCEDVALUE,
    FGADDRREG_NETQFORCED,

    FGADDRREG_LAST
};

typedef struct _AddrRegFlags_f {
    DWORD           Dummy0:1;
    DWORD           NETQFORCEDVALUE:1;
    DWORD           NETQFORCED:1;
} AddrRegFlags_f;

#define MAX_PTMAP 16

typedef struct _RtpPtMap_t {
    DWORD            dwPt;
    DWORD            dwFrequency;
} RtpPtMap_t;

/*
 * !!! WARNING !!!
 *
 * The offset to Cache1Q, ..., ByeQ MUST NOT be bigger than 1023 and
 * MUST be DWORD aligned (the offset value is stored as number of
 * DWORDS in rtppinfo.c using 8 bits)
 * */

typedef struct _RtpAddr_t {
    DWORD            dwObjectID;    /* Identifies structure */
    RtpQueueItem_t   AddrQItem;     /* Addresses are in RtpSess_t.RtpAddrQ */
    RtpSess_t       *pRtpSess;      /* Session owning this address */
    RtpCritSect_t    AddrCritSect;  /* Lock */

    /* Some flags for CIRtpSession */
    union {
        DWORD            dwIRtpFlags;
        IRtpFlags_f      IRtpFlags;
    };

    /* Some flags and state information */
    union {
        DWORD            dwAddrFlags;
        AddrFlags_f      AddrFlags;
    };

    /* Some flags for QOS */
    union {
        DWORD            dwAddrFlagsQ;
        AddrFlagsQ_f     AddrFlagsQ;
    };

    /* Some flags for cryptography */
    union {
        DWORD            dwAddrFlagsC;
        AddrFlagsC_f     AddrFlagsC;
    };

    /* Some flags for the receiver thread*/
    union {
        DWORD            dwAddrFlagsR;
        AddrFlagsR_f     AddrFlagsR;
    };

    /* Some flags for the sender thread */
    union {
        DWORD            dwAddrFlagsS;
        AddrFlagsS_f     AddrFlagsS;
    };
    
    /* Some flags derived from the registry */
    union {
        DWORD            dwAddrRegFlags;
        AddrRegFlags_f   AddrRegFlags;
    };
    
    /* Participants (SSRCs) */
    RtpCritSect_t    PartCritSect;  /* Lock for participants queues */
    RtpQueue_t       Cache1Q;       /* Only current senders are here */
    RtpQueue_t       Cache2Q;       /* Only recent senders are here */
    RtpQueue_t       AliveQ;        /* All "alive" participants are here */
    RtpQueue_t       ByeQ;          /* Stalled or left participants */
    RtpQueueHash_t   Hash;          /* Same as alive but with hash table */
    long             lInvalid;      /* Not yet validated participants */
    double           dAlpha;        /* Weighting factor for delay/jitter */

    /* RTP Receiver */
    RtpChannel_t     RtpRecvThreadChan;
    HANDLE           hRtpRecvThread;
    DWORD            dwRtpRecvThreadID;

    /* Overlapped reception */
    RtpCritSect_t    RecvQueueCritSect;/* Lock for Free/Busy queues */
    RtpQueue_t       RecvIOFreeQ;     /* Pool of RtpRecvIO_t structures */
    RtpQueue_t       RecvIOReadyQ;    /* Buffers ready for overlapped I/O */
    RtpQueue_t       RecvIOPendingQ;  /* Buffers pending for completion */
    RtpQueue_t       RecvIOWaitRedQ;  /* Buffers waiting for redundancy */
    HANDLE           hRecvCompletedEvent;/* Signal I/O completed */
    PRTP_RECVCOMPLETIONFUNC pRtpRecvCompletionFunc;
    
    /* Network/Sockets information */
    RtpQueueItem_t   PortsQItem;    /* To keep track of ports */
    SOCKET           Socket[3];     /* RTP Recv, RTP Send, RTCP Recv/Send */
    DWORD            dwAddr[2];     /* NETWORK order: Local and Remote IP
                                     * address */
    WORD             wRtpPort[2];   /* NETWORK order: Local and Remote
                                     * RTP port */
    WORD             wRtcpPort[2];  /* NETWORK order: Local and Remote
                                     * RTCP port */
    DWORD            dwTTL[2];      /* TTL - Time To Live, for RTP and RTCP */

    /* Private PT <-> Frequency mappings */
    RtpPtMap_t       RecvPtMap[MAX_PTMAP]; /* Reception PT ->
                                            * Frequency mapping */

    /* Redundancy control */
    BYTE             bPT_RedRecv;   /* PT to receive redundant encoding */
    
    /* RtpNetCount and RtpNetSState lock */
    RtpCritSect_t    NetSCritSect;
    
    /* Recv and Send network counters */
    RtpNetCount_t    RtpAddrCount[2];

    /* Network Sender state */
    RtpNetSState_t   RtpNetSState;

    /* QOS reservations */
    RtpQosReserve_t *pRtpQosReserve;
    
    /* Cryptography, Recv/Send encryption descriptor */
    DWORD            dwCryptMode;
    RtpCrypt_t      *pRtpCrypt[3];
    
    DWORD            dwCryptBufferLen[2];
    char            *CryptBuffer[2]; /* RTP, RTCP encryption buffer */
} RtpAddr_t;

/**********************************************************************
 * Per source (participant) network state information, keeps sequence
 * number, and extended sequence number, as well as other counters
 * used to compute losses and jitter
 **********************************************************************/

/* Flags used in RtpNetRState_t.dwNetRStateFlags. Currently only used
 * by the RTP thread while processing packets received */
enum {
    FGNETRS_FIRST,

    FGNETRS_TIMESET,  /* Time available, time can be derived */

    FGNETRS_LAST
};

/* Flags used in RtpNetRState_t.dwNetRStateFlags2. */
enum {
    FGNETRS2_FIRST,

    FGNETRS2_BANDWIDTHUNDEF, /* Last bandwidth estimation was undefined */
    FGNETRS2_BANDESTNOTREADY, /* In the process of getting first average */

    FGNETRS2_LAST
};

typedef struct _RtpNetRState_t {
    DWORD            dwNetRStateFlags;/* Some flags used by RTP thread */
    DWORD            dwNetRStateFlags2;/* Some flags used by RTCP thread */
    WORD             max_seq;        /* highest seq. number seen */
    DWORD            cycles;         /* shifted count of seq. number cycles */
    DWORD            base_seq;       /* base seq number */
    DWORD            bad_seq;        /* last 'bad' seq number + 1 */
    DWORD            probation;      /* sequ. packets till source is valid */
    DWORD            received;       /* packets received */
    DWORD            expected_prior; /* packets expected at last interval */
    DWORD            received_prior; /* packets received at last interval */
    long             transit;        /* relative trans time for prev pkt */
    DWORD            jitter;         /* estimated jitter */
    DWORD            timestamp_prior;/* Used to detect timestamp gaps */
    DWORD            dwLastPacketSize;/* Last packet's size */
    int              iAvgLossRateR;  /* Average of the loss rate being
                                      * reported */

    DWORD            red_max_seq;    /* extended seq. number seen, incl. red */
    DWORD            red_received;   /* main + redundancy (m+r) consumed */
    DWORD            red_expected_prior;/* packets expected at last interval */
    DWORD            red_received_prior;/* m+r received at last interval */
    int              iRedAvgLossRateR;/* Average of the loss rate
                                       * after packet reconstruction */
    
    long             lBigDelay;      /* Used to detect step delay changes */

    DWORD            dwPt;
    DWORD            dwRecvSamplingFreq; /* Payload's sampling frequency */
    DWORD            dwRecvSamplesPerPacket;/* Samples in each packet */
    /* Samples per packet detection  */
    DWORD            dwRecvMinSamplesPerPacket;
    DWORD            dwPreviousTimeStamp;
    
    /* Delay and jitter computation (all time values are in seconds)
     * except t_sr */

    RtpTime_t        TimeLastXRRecv; /* Time last SR/RR was received */
    RtpTime_t        TimeLastSRRecv; /* Time last SR was received,
                                      * used to compute DLSR when
                                      * sending a RBlock reporting
                                      * this participant */
    /* Used to do bandwidth estimation */
    double           dInterSRRecvGap;/* Gap between the last 2 SR sent
                                      * as seen by the receiver */
    double           dInterSRSendGap;/* Gap between the last 2 SR sent
                                      * as indicated in the NTP field */
    double           dLastTimeEstimation;
    double           dBinBandwidth[RTCP_BANDESTIMATION_MAXBINS];
    DWORD            dwBinFrequency[RTCP_BANDESTIMATION_MAXBINS];
    DWORD            dwBestBin;
    DWORD            dwBandEstRecvCount;

    /* Used to compute RTT */
    RtpTime_t        NTP_sr_rtt;     /* NTP time in last SR received, 
                                      * used to compute LSR when
                                      * sending a RBlock reporting
                                      * this participant */
    DWORD            t_sr_rtt;       /* Timestamp in last SR report */
    
    /* Used to compute playout delay, don't care about real delay */
    double           dNTP_ts0;       /* NTP time at RTP sample 0 */
    double           dDiN;           /* Accumulated delay for N packets */
    long             lDiMax;         /* Set the initial Ni's to compute Di */
    long             lDiCount;       /* Running counter for lDiMax */
    double           Ni;             /* Packet's i delay */
    double           Di;             /* Average delay */
    double           Vi;             /* Delay's standard deviation */
    double           ViPrev;         /* Delay's standard deviation */
    double           dPlayout;       /* Playout delay for current talkspurt */

    /* Used to compute the play time */
    double           dRedPlayout;   /* Playout delay needed for redundancy */
    double           dMinPlayout;   /* Minimum playout delay */
    double           dMaxPlayout;   /* Maximum playout delay */
    DWORD            dwBeginTalkspurtTs;/* RTP ts when the talkspurt began */
    double           dBeginTalkspurtTime;/* Time at last begin of talkspurt */
    double           dLastTimeMarkerBit;/* Last time we saw a marker bit set */
    LONGLONG         llBeginTalkspurt;/* DShow time at last begin of
                                       * talkspurt */

    DWORD            dwMaxTimeStampOffset;/* Max offset in redundant block */
    DWORD            dwRedCount;     /* How many packets with same distance */
    DWORD            dwNoRedCount;   /* How many packets without redundancy */
    
    /* ... */
    double           dCreateTime;    /* Time it was created */
    double           dByeTime;       /* Time BYE was received */
} RtpNetRState_t;

/**********************************************************************
 * Each remote participants has its structure (there may be a global
 * heap for all the unicast sessions, say g_RtpUserHeap, and the
 * multicast sessions could have its own separate heap, say
 * m_UserHeap).
 **********************************************************************/
/* Some flags in RtpUser_t.dwUserFlags */
enum {
    FGUSER_FIRST,

    FGUSER_FIRST_RTP,    /* First RTP packet has been received */
    FGUSER_SR_RECEIVED,  /* SR has been received */
    FGUSER_VALIDATED,    /* This user was validated by receiving N
                          * consecutive packets or a valid RTCP report */
    FGUSER_RTPADDR,      /* RTP source address and port are learned */
    FGUSER_RTCPADDR,     /* RTCP source address and port are learned */

    FGUSER_LAST
};

/* Some flags in RtpUser_t,dwUserFlags2 */
enum {
    FGUSER2_FIRST,
    
    FGUSER2_MUTED,        /* Mute state */
    FGUSER2_NETEVENTS,    /* Generate network quality events */

    FGUSER2_LAST
};
    

typedef struct _RtpUser_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpQueueItem_t   UserQItem;       /* Shared with Cache1Q, Cache2Q,
                                       * AliveQ and ByeQ */
    DWORD            dwUserFlags;     /* User flags */
    long             lPendingPackets; /* Red or out of seq. packets */

    RtpQueueItem_t   ReportQItem;     /* To create a report list */
    RtpQueueItem_t   HashItem;        /* To be kept in Hash */
    
    RtpAddr_t       *pRtpAddr;        /* Address owning this participant */
    DWORD            dwSSRC;          /* NETWORK ORDER SSRC */
    DWORD            dwUserState;     /* Current user's state */
    DWORD            dwUserFlags2;    /* E.g. events, mute */
    RtpOutput_t     *pRtpOutput;      /* User info passed on RTP reception */
    
    RtpCritSect_t    UserCritSect;    /* Participant's lock */
    RtpNetCount_t    RtpUserCount;    /* Receiving network counters */
    RtpNetRState_t   RtpNetRState;    /* This user/SSRC's network state */
    RtpNetInfo_t     RtpNetInfo;      /* Avg RTT, jitter, losses */

    DWORD            dwSdesPresent;   /* What items are already stored */
    RtpSdes_t       *pRtpSdes;        /* Participant's SDES info */

    DWORD            dwAddr[2];       /* RTP/RTCP source addr NETWORK ORDER */
    WORD             wPort[2];        /* RTP/RTCP source port NETWORK ORDER */

    
} RtpUser_t;

/**********************************************************************
 * A receiver can have several outputs. Outputs can be assigned to
 * active senders in different ways.
 **********************************************************************/

/* Flags in RtpOutput_t.dwOutputFlags */
enum {
    RTPOUTFG_FIRST,

    /* Output is not assigned */
    RTPOUTFG_FREE,
    
    /* Can only be explicitly assigned/unassigned */
    RTPOUTFG_MANUAL,
    
    /* Can be automatically assigned */
    RTPOUTFG_AUTO,

    /* If output timeouts, it is unassigned */
    RTPOUTFG_ENTIMEOUT,   

    /* This output can be used */
    RTPOUTFG_ENABLED,
    
    RTPOUTFG_LAST
};

typedef struct _RtpOutput_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpQueueItem_t   OutputQItem;     /* RtpOutQ */
    int              iOutMode;        /* Output mode */
    DWORD            dwOutputFlags;   /* Output flags */
    RtpUser_t       *pRtpUser;        /* This output owner */
    void            *pvUserInfo;      /* Info to pass up, e.g. a DShow
                                       * pin */
} RtpOutput_t;

/**********************************************************************
 * Each participant has this structure to hold the SDES data (there
 * may be a global heap for all the unicast sessions, say,
 * g_RtpSdesHeap, and the multicast sessions could have its own
 * separate heap, say m_SDESHeap, to hold the participants SDES
 * data).
 **********************************************************************/
typedef struct _RtpSdesItem_t {
    DWORD            dwBfrLen;        /* Total buffer size  (bytes) */
    DWORD            dwDataLen;       /* Actual data length (bytes) */
    TCHAR_t         *pBuffer;         /* Pointer to buffer  */
} RtpSdesItem_t;

/*
 * TODO right now I'm assigning a static array, but for scalability,
 * this need to be changed to a dynamic mechanism where I can allocate
 * 32, 64, 128 or 256 buffer sizes */
typedef struct _RtpSdes_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpSdesItem_t    RtpSdesItem[RTCP_NUM_SDES + 1]; /* Include END:0 */
    /* TODO the following field will be removed when I change to a
     * dynamic memory allocation with different buffer sizes */
    char             SDESData[RTCP_MAX_SDES_SIZE * RTCP_NUM_SDES];
} RtpSdes_t;


/**********************************************************************
 * Each address has this structure to manage the QOS notifications.
 **********************************************************************/
typedef struct _RtpQosNotify_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtcpAddrDesc_t  *pRtcpAddrDesc;   /* Owner */
    
    double           dNextStart;      /* Scheduled to try at this time */
    
    HANDLE           hQosNotifyEvent; /* Signal QOS notification */
    
    DWORD            dwError;
    DWORD            dwTransfered;
    DWORD            dwNotifyFlags;
    WSAOVERLAPPED    Overlapped;

    DWORD            dwProviderLen;
    char            *ProviderInfo;
} RtpQosNotify_t;

/**********************************************************************
 * Each address has this structure to manage the QOS reservations.
 **********************************************************************/

#define MAX_QOS_NAME 16

typedef struct _QosInfo_t {
    TCHAR_t         *pName;
    DWORD            dwQosExtraInfo;
    FLOWSPEC         FlowSpec;
} QosInfo_t;

/* Some flags used in RtpQosReserve_t.dwReserveFlags */
typedef struct _ReserveFlags_f {
    DWORD            RecvFrameSizeValid:1;   /* Frame size is valid */
    DWORD            RecvFrameSizeWaiting:1; /* Waiting for valid frame size */
} ReserveFlags_f;
    
typedef struct _RtpQosReserve_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpAddr_t       *pRtpAddr;        /* Owner */
    DWORD            dwStyle;
    ReserveFlags_f   ReserveFlags;
    const QosInfo_t *pQosInfo[2];
    DWORD            dwFrameSizeMS[2];
  

    /* Qos App ID */
    TCHAR_t         *psAppName;
    TCHAR_t         *psAppGUID;
    TCHAR_t         *psPolicyLocator;

    /* Lower bit rate sending */
    double           dLastAddition;
    DWORD            dwTokens;
    
    /* Used for Shared Explicit style - SE */
    DWORD            dwNumFilters;
    DWORD            dwMaxFilters;
    DWORD           *pdwRsvpSSRC;     /* SSRCs in filters */
    RSVP_FILTERSPEC *pRsvpFilterSpec; /* SE Filters */
    
    QOS              qos;
} RtpQosReserve_t;

/**********************************************************************
 * Maintain the encryption/decryption information 
 **********************************************************************/

enum {
    FGCRYPT_FIRST,

    FGCRYPT_INIT, /* Initialized, enable cryptography in this context */
    FGCRYPT_KEY,  /* Key has been set */
    FGCRYPT_DUMMY3,

    FGCRYPT_DECRYPTERROR, /* Prevent multiple times issuing the same error */
    FGCRYPT_ENCRYPTERROR, /* Prevent multiple times issuing the same error */
    
    FGCRYPT_LAST,
};

typedef struct _CryptFlags_f {
    DWORD            Dummy0:1;
    DWORD            KeySet:1;
    DWORD            Dummy3:1;
    DWORD            DecryptionError:1;
    DWORD            EncryptionError:1;
} CryptFlags_f;

typedef struct _RtpCrypt_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpAddr_t       *pRtpAddr;        /* Owner */
    union {
        DWORD            dwCryptFlags;
        CryptFlags_f     CryptFlags;
    };
    long             lCryptRefCount;  /* Init/Del */

    DWORD            dwCryptLastError;
    
    /* MAYDO should I add a list of keys ? */
    DWORD            dwStyle;         /* Encryption style */
    int              iKeySize;        /* Key's size in bytes */
    /* Pass phrase to derive key */
    char             psPassPhrase[RTPCRYPT_PASSPHRASEBUFFSIZE];

    /* CryptoAPI */
    DWORD            dwProviderType;  /* Provider type */
    HCRYPTPROV       hProv;           /* Cryptographic Service Provider */

    ALG_ID           aiHashAlgId;     /* Hashing algorithm ID */
    HCRYPTHASH       hHash;           /* Hash handle */

    ALG_ID           aiDataAlgId;     /* Data algorithm ID */
    HCRYPTKEY        hDataKey;        /* Cryptographic key */ 
} RtpCrypt_t;


/**********************************************************************
 * Information needed for RTP asynchronous I/O (receive or send).
 **********************************************************************/

/* RtpIO_t, SendIo_t, RecvIo_t */
typedef struct _RtpRecvIO_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpQueueItem_t   RtpRecvIOQItem;  /* Link */

    WSABUF           WSABuf;
    RtpUser_t       *pRtpUser;

    DWORD            dwWSError;
    DWORD            dwError;

    long             lHdrSize;
    /* Redundancy control */
    long             lRedHdrSize;
    long             lRedDataSize;

    DWORD            dwWSTransfered;
    DWORD            dwTransfered;

    DWORD            dwRtpWSFlags;
    DWORD            dwRtpIOFlags;

    SOCKADDR         From;
    int              Fromlen;

    double           dRtpRecvTime;   /* Time this packet was received */

    void            *pvUserInfo1;
    void            *pvUserInfo2;

    double           dPlayTime;      /* Relative time (to first sample
                                      * in the talkspurt) at which to
                                      * play the frame */
    /* Redundancy control */
    double           dPostTime;
    DWORD            dwTimeStamp;
    DWORD            dwMaxTimeStampOffset;
    WORD             wSeq;
    DWORD            dwExtSeq;
    BYTE             bPT_Block;
    
    WSAOVERLAPPED    Overlapped;
} RtpRecvIO_t;

typedef struct _RtpSendIO_t {
    DWORD            dwObjectID;      /* Identifies structure */
    WSABUF           WSABuf;
} RtpSendIO_t;

/**********************************************************************
 * Information needed for RTCP asynchronous I/O (receive or send).
 **********************************************************************/


typedef struct _RtcpRecvIO_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtcpAddrDesc_t   *pRtcpAddrDesc;   /* Owner */

    SOCKADDR         From;
    int              Fromlen;

    double           dRtcpRecvTime;  /* Time this packet was received */
    RtpTime_t        RtcpRecvTime;
    
    HANDLE           hRtcpCompletedEvent;/* Signal Recv I/O completed */

    WSABUF           WSABuf;
    DWORD            dwError;
    DWORD            dwTransfered;
    DWORD            dwRecvIOFlags;
    WSAOVERLAPPED    Overlapped;
    
    char             RecvBuffer[RTCP_RECVDATA_BUFFER];
} RtcpRecvIO_t;

typedef struct _RtcpSendIO_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtcpAddrDesc_t   *pRtcpAddrDesc;   /* Owner */
    char             SendBuffer[RTCP_SENDDATA_BUFFER];
} RtcpSendIO_t;

/**********************************************************************
 * RtcpAddrDesc_t contains the information that the RTCP thread needs
 * to receive/send RTCP reports, as well as receive asynchronous QOS
 * notifications
 **********************************************************************/
/* Some flags in RtcpAddrDesc_t.dwFlags */
enum {
    FGADDRD_FIRST,
    
    FGADDRD_RECVPENDING,            /* Asynchronous reception pending */
    FGADDRD_NOTIFYPENDING,          /* A notification is pending */
    FGADDRD_NOTIFYBUSY,             /* Normal notifications, in QosBusyQ */

    /* Sockets are closed after FGADDRD_SHUTDOWN1 is set, but before
     * FGADDRD_SHUTDOWN2 is set */
    FGADDRD_SHUTDOWN1,              /* Address about to shut down */
    FGADDRD_SHUTDOWN2,              /* Address shutting down */
    FGADDRD_DUMMY6,
    FGADDRD_DUMMY7,
    
    FGADDRD_INVECTORRECV,           /* In the events vector */
    FGADDRD_INVECTORQOS,            /* In the events vector */
    
    FGADDRD_LAST
};

typedef struct _AddrDescFlags_f {
    DWORD           Dummy0:1;
    DWORD           RECVPENDING:1;
    DWORD           NOTIFYPENDING:1;
    DWORD           NOTIFYBUSY:1;
    DWORD           FGADDRD_SHUTDOWN1:1;
    DWORD           FGADDRD_SHUTDOWN2:1;
    DWORD           Dummy6:1;
    DWORD           Dummy7:1;
    DWORD           INVECTORRECV:1;
    DWORD           INVECTORQOS:1; 
} AddrDescFlags_f;

typedef struct _RtcpAddrDesc_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpQueueItem_t   AddrDescQItem;   /* RtcpContext queues:
                                       * AddrDescFreeQ, AddrDescBusyQ,
                                       * AddrDescStopQ */
    RtpAddr_t       *pRtpAddr;        /* Owner address */

    /* Some flags */
    union {
        DWORD            dwAddrDescFlags;
        AddrDescFlags_f  AddrDescFlags;
    };
    
    long             lRtcpPending;    /* Number of RTCP pending I/Os */
    long             lQosPending;     /* Number of QOS notifications pending */
    DWORD            dwDescIndex;     /* Position in descriptors vector */
    SOCKET           Socket[3];       /* Same as RtpAddr_t.Socket[3] */

    /* QOS notifications */
    RtpQueueItem_t   QosQItem;        /* RtcpContext queues:
                                       * QosStartQ, QosBusyQ, QosStopQ */
    RtpQosNotify_t  *pRtpQosNotify;  /* QOS notifications */

    /* Receive */
    RtpQueueItem_t   RecvQItem;       /* Link for all receivers NOT USED */
    RtcpRecvIO_t    *pRtcpRecvIO;     /* RTCP reception buffer */
    
    /* Send */
    RtpQueueItem_t   SendQItem;       /* Link for all senders */
    RtcpSendIO_t    *pRtcpSendIO;     /* RTCP sending buffer */

#if USE_RTCP_THREAD_POOL > 0
    HANDLE           hRecvWaitObject;  /* RTCP reception wait object */
    HANDLE           hQosWaitObject;   /* QOS notifications wait object */
#endif /* USE_RTCP_THREAD_POOL > 0 */
} RtcpAddrDesc_t;

/**********************************************************************
 * RtpContext_t contains some general information
 **********************************************************************/
typedef struct _RtpContext_t
{
    DWORD            dwObjectID;      /* Identifies structure */
    
    RtpQueue_t       RtpSessQ;
    RtpCritSect_t    RtpContextCritSect;

    /* Memory currently allocated by all private heaps */
    long             lMemAllocated;
    /* Maximum memory ever allocated by all private heaps */
    long             lMaxMemAllocated;

    /* Performance counter frequency (if available) */
    LONGLONG         lPerfFrequency;
    
    union {
        /* RTP's reference time in ms, initialized once and then left
         * as it is */
        DWORD            dwRtpRefTime;
        /* Another version of the same time */
        LONGLONG         lRtpRefTime;
    };

    union {
        /* Remembers last known time, used only when debugging, time
         * is relative to the reference time in ms (elapsed time) */
        DWORD            dwRtpCurTime;
        /* Another version of the same time */
        LONGLONG         lRtpCurTime;
    };
        
    /* RTP's reference time in seconds since midnight (00:00:00),
     * January 1, 1970, coordinated universal time (UTC) */
    double           dRtpRefTime;

    long             lNumSourceFilter;
    long             lMaxNumSourceFilter;
    long             lNumRenderFilter;
    long             lMaxNumRenderFilter;
    
    long             lNumRtpSessions;
    long             lMaxNumRtpSessions;
    
    long             lNumRecvRunning;
    long             lNumSendRunning;

    /* Winsock2 */
    RtpCritSect_t    RtpWS2CritSect;
    long             lRtpWS2Users;
    SOCKET           RtpQuerySocket;

    /* Ports allocation */
    RtpQueueHash_t   RtpPortsH;
    RtpCritSect_t    RtpPortsCritSect;

} RtpContext_t;

/**********************************************************************
 * RtpRedEntry_t information about a redundant frame
 **********************************************************************/
typedef struct _RtpRedEntry_t
{
    BOOL             bValid;      /* This frame can be used */
    BYTE             bRedPT;      /* Redundant block's payload type */
    /* This buffer's original seq number */
    union {
        struct {
            WORD             wSeq:16; /* Sending sequence number */
            WORD             wSeqH:16;/* High part for the sequence number */
        };
        DWORD            dwSeq;       /* 32bits sequence number */
    };
    DWORD            dwTimeStamp; /* First sample's timestamp */
    WSABUF           WSABuf;      /* Buffer description */
} RtpRedEntry_t;

/**********************************************************************
 * Some flags used in other places
 **********************************************************************/

/* Flags that can be used in parameter dwSendFlags of RtpSendTo */
enum {
    FGSEND_FIRST,
    
    FGSEND_DTMF,    /* Use DTMF payload type */
    FGSEND_USERED,  /* Use redundant data */
    FGSEND_FORCEMARKER, /* Used with first DTMF packet */
    
    FGSEND_LAST
};

/* Flags used in pRtpRecvIO->dwRtpIOFlags, also passed in
 * RtpRecvCompletionFunc when a packet is received or used during RTCP
 * reception in an analog way as used in pRtpRecvIO->dwRtpIOFlags */
enum {
    FGRECV_FIRST,
    
    FGRECV_ERROR,   /* WS2 error or invalid, reason is in dwError */
    FGRECV_DROPPED, /* Valid but need to drop it, reason is in dwError */
    FGRECV_DUMMY3,
    
    FGRECV_MUTED,   /* Packet dropped because in mute state */
    FGRECV_INVALID, /* Packet dropped because invalid */
    FGRECV_LOOP,    /* Packet dropped because loopback discard */
    FGRECV_MISMATCH,/* Packet dropped because mismatched source address */

    FGRECV_NOTFOUND,/* Packet dropped because user not found */
    FGRECV_CRITSECT,/* Packet dropped because failure to enter critsect */
    FGRECV_SHUTDOWN,/* Packet dropped because we are Shuting down */
    FGRECV_PREPROC, /* Packet dropped because pre-process failed */

    FGRECV_OBSOLETE,/* Packet dropped because it is a dup or an old one */
    FGRECV_FAILSCHED,/* Packet dropped because couldn't be scheduled */
    FGRECV_BADPT,   /* Packet dropped because an unknown PT was received */
    FGRECV_RANDLOSS,/* Packet dropped simulating random losses */

    FGRECV_USERGONE,/* User is deleted so its pending IO is dropped */
    FGRECV_DUMMY17,
    FGRECV_DUMMY18,
    FGRECV_DUMMY19,
    
    FGRECV_WS2,     /* Packet dropped because a WS2 error */
    FGRECV_DUMMY21,
    FGRECV_DUMMY22,
    FGRECV_DUMMY23,
    
    FGRECV_MAIN,    /* Contains main data, as opossed to redundant data */
    FGRECV_HASRED,  /* This (main) buffer contains redundancy */
    FGRECV_DUMMY26,
    FGRECV_MARKER,  /* Marker bit value in main packet */
    
    FGRECV_ISRED,   /* This buffer is a redundant block */
    FGRECV_HOLD,    /* Process this buffer but leave unchanged for
                     * further use */
    
    FGRECV_LAST
};

#endif /* _struct_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpuser.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpuser.h
 *
 *  Abstract:
 *
 *    Creates/initializes/deletes a RtpUser_t structure
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/10/02 created
 *
 **********************************************************************/

#ifndef _rtpuser_h_
#define _rtpuser_h_

#include "gtypes.h"
#include "struct.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

HRESULT GetRtpUser(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t      **ppRtpUser,
        DWORD            dwFlags
    );

HRESULT DelRtpUser(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser
    );

DWORD DelAllRtpUser(
        RtpAddr_t       *pRtpAddr
    );

DWORD ResetAllRtpUser(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags   /* Recv, Send */
    );
       
#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpuser_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtpthrd.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpthrd.h
 *
 *  Abstract:
 *
 *    Implement the RTP reception working thread
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/30 created
 *
 **********************************************************************/

#ifndef _rtpthrd_h_
#define _rtpthrd_h_

#include "gtypes.h"
#include "struct.h"

/* Commands a RTP source worker thread accepts */
enum {
    RTPTHRD_FIRST,
    RTPTHRD_START, /* Starts generating data */
    RTPTHRD_STOP,  /* Stops generating data and exit */
    RTPTHRD_FLUSHUSER, /* Flush all waiting IO from a user */
    RTPTHRD_LAST
};

/* Create a RTP reception thread, and initialize the communication
 * channel */
HRESULT RtpCreateRecvThread(RtpAddr_t *pRtpAddr);

/* Shut down a RTP reception thread and deletes the communication
 * channel */
HRESULT RtpDeleteRecvThread(RtpAddr_t *pRtpAddr);

/* Send a command to the RTP thread to flush all the waiting IOs
 * belonging to the specified RtpUser_t */
HRESULT RtpThreadFlushUser(RtpAddr_t *pRtpAddr, RtpUser_t *pRtpUser);

#endif /* _rtpthrd_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\inc\rtptags.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtptags.h
 *
 *  Abstract:
 *
 *    Defines the thags and object IDs for all structures/objects
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/25 created
 *
 **********************************************************************/

#ifndef _rtptags_h_
#define _rtptags_h_

#include <tchar.h>

/*
 * Each memory allocated from a private heap, will be tagged, 3 bytes
 * will be a string, and the fourth byte will be an index for which an
 * object description can be obtained.
 *
 * The following strings are used as the first 3 bytes of the tag */
#define TAGHEAP_BSY 'PTR' /* RTP */
#define TAGHEAP_END 'DNE' /* END */
#define TAGHEAP_FRE 'ERF' /* FRE */

/*
 * WARNING
 *
 * When modifying the tags, each enum TAGHEAP_* in rtptags.h MUST have
 * its own name in g_psRtpTags[], defined in rtptags.c
 * */

/*
 * Each memory allocated from a private heap, will be tagged, 3 bytes
 * will be a string, and 1 byte (byte 3) will be an index for which an
 * object description can be obtained.
 *
 * The following values are those used by byte 3 in the tag (the index
 * byte), and the byte 0 and byte 3 in the object IDs
 * */
#define TAGHEAP_FIRST          0x00  /*  0 */
#define TAGHEAP_CIRTP          0x01  /*  1 */
#define TAGHEAP_RTPOPIN        0x02  /*  2 */
#define TAGHEAP_RTPALLOCATOR   0x03  /*  3 */
#define TAGHEAP_RTPSAMPLE      0x04  /*  4 */
#define TAGHEAP_RTPSOURCE      0x05  /*  5 */
#define TAGHEAP_RTPIPIN        0x06  /*  6 */
#define TAGHEAP_RTPRENDER      0x07  /*  7 */
#define TAGHEAP_RTPHEAP        0x08  /*  8 */
#define TAGHEAP_RTPSESS        0x09  /*  9 */
#define TAGHEAP_RTPADDR        0x0A  /* 10 */
#define TAGHEAP_RTPUSER        0x0B  /* 11 */
#define TAGHEAP_RTPOUTPUT      0x0C  /* 12 */
#define TAGHEAP_RTPNETCOUNT    0x0D  /* 13 */
#define TAGHEAP_RTPSDES        0x0E  /* 14 */
#define TAGHEAP_RTPCHANNEL     0x0F  /* 15 */
#define TAGHEAP_RTPCHANCMD     0x10  /* 16 */
#define TAGHEAP_RTPCRITSECT    0x11  /* 17 */
#define TAGHEAP_RTPRESERVE     0x12  /* 18 */
#define TAGHEAP_RTPNOTIFY      0x13  /* 19 */
#define TAGHEAP_RTPQOSBUFFER   0x14  /* 20 */
#define TAGHEAP_RTPCRYPT       0x15  /* 21 */
#define TAGHEAP_RTPCONTEXT     0x16  /* 22 */
#define TAGHEAP_RTCPCONTEXT    0x17  /* 23 */
#define TAGHEAP_RTCPADDRDESC   0x18  /* 24 */
#define TAGHEAP_RTPRECVIO      0x19  /* 25 */
#define TAGHEAP_RTPSENDIO      0x1A  /* 26 */
#define TAGHEAP_RTCPRECVIO     0x1B  /* 27 */
#define TAGHEAP_RTCPSENDIO     0x1C  /* 28 */
#define TAGHEAP_RTPGLOBAL      0x1D  /* 29 */
#define TAGHEAP_LAST           0x1E  /* 30 */

/*
 * Each object will have as its first field a DWORD which is a unique
 * ID used for that kind of object, byte 2 and 3 are a unique number,
 * byte 0 and byte 3 are the TAGHEAP, an invalidated object has byte 0
 * set to 0
 * */
#define OBJECTID_B2B1       0x005aa500

#define BUILD_OBJECTID(t)       (((t) << 24) | OBJECTID_B2B1 | t)
#define INVALIDATE_OBJECTID(oi) (oi &= ~0xff)

#define OBJECTID_CIRTP         BUILD_OBJECTID(TAGHEAP_CIRTP)
#define OBJECTID_RTPOPIN       BUILD_OBJECTID(TAGHEAP_RTPOPIN)
#define OBJECTID_RTPALLOCATOR  BUILD_OBJECTID(TAGHEAP_RTPALLOCATOR)
#define OBJECTID_RTPSAMPLE     BUILD_OBJECTID(TAGHEAP_RTPSAMPLE)
#define OBJECTID_RTPSOURCE     BUILD_OBJECTID(TAGHEAP_RTPSOURCE)
#define OBJECTID_RTPIPIN       BUILD_OBJECTID(TAGHEAP_RTPIPIN)
#define OBJECTID_RTPRENDER     BUILD_OBJECTID(TAGHEAP_RTPRENDER)
#define OBJECTID_RTPHEAP       BUILD_OBJECTID(TAGHEAP_RTPHEAP)
#define OBJECTID_RTPSESS       BUILD_OBJECTID(TAGHEAP_RTPSESS)
#define OBJECTID_RTPADDR       BUILD_OBJECTID(TAGHEAP_RTPADDR)
#define OBJECTID_RTPUSER       BUILD_OBJECTID(TAGHEAP_RTPUSER)
#define OBJECTID_RTPOUTPUT     BUILD_OBJECTID(TAGHEAP_RTPOUTPUT)
#define OBJECTID_RTPNETCOUNT   BUILD_OBJECTID(TAGHEAP_RTPNETCOUNT)
#define OBJECTID_RTPSDES       BUILD_OBJECTID(TAGHEAP_RTPSDES)
#define OBJECTID_RTPCHANNEL    BUILD_OBJECTID(TAGHEAP_RTPCHANNEL)
#define OBJECTID_RTPCHANCMD    BUILD_OBJECTID(TAGHEAP_RTPCHANCMD)
#define OBJECTID_RTPCRITSECT   BUILD_OBJECTID(TAGHEAP_RTPCRITSECT)
#define OBJECTID_RTPRESERVE    BUILD_OBJECTID(TAGHEAP_RTPRESERVE)
#define OBJECTID_RTPNOTIFY     BUILD_OBJECTID(TAGHEAP_RTPNOTIFY)
#define OBJECTID_RTPQOSBUFFER  BUILD_OBJECTID(TAGHEAP_RTPQOSBUFFER)
#define OBJECTID_RTPCRYPT      BUILD_OBJECTID(TAGHEAP_RTPCRYPT)
#define OBJECTID_RTPCONTEXT    BUILD_OBJECTID(TAGHEAP_RTPCONTEXT)
#define OBJECTID_RTCPCONTEXT   BUILD_OBJECTID(TAGHEAP_RTCPCONTEXT)
#define OBJECTID_RTCPADDRDESC  BUILD_OBJECTID(TAGHEAP_RTCPADDRDESC)
#define OBJECTID_RTPRECVIO     BUILD_OBJECTID(TAGHEAP_RTPRECVIO)
#define OBJECTID_RTPSENDIO     BUILD_OBJECTID(TAGHEAP_RTPSENDIO)
#define OBJECTID_RTCPRECVIO    BUILD_OBJECTID(TAGHEAP_RTCPRECVIO)
#define OBJECTID_RTCPSENDIO    BUILD_OBJECTID(TAGHEAP_RTCPSENDIO)
#define OBJECTID_RTPGLOBAL     BUILD_OBJECTID(TAGHEAP_RTPGLOBAL)

extern const TCHAR *g_psRtpTags[];

#endif /* _rtptags_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\dsapi\dsrtpapi.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    msrtpapi.c, dsrtpapi.c
 *
 *  Abstract:
 *
 *    Contains the raw RTP implementation API, can be linked as a
 *    library (rtp.lib), linked into a DLL (msrtp.dll), or linked into
 *    a DShow DLL (dsrtp.dll).
 *
 *    This file is edited as msrtpapi.c and duplicated as dsrtpapi.c,
 *    each version is compiled with different flags
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#include <winsock2.h>

#include "gtypes.h"
#include "struct.h"
#include "rtphdr.h"
#include "rtpheap.h"
#include "rtprand.h"
#include "rtpglobs.h"
#include "rtpreg.h"
#include "rtcpsdes.h"

#include "rtpfwrap.h"
#include "rtpsess.h"

#include "rtpstart.h"
#include "rtprecv.h"
#include "rtpsend.h"

#include "rtcpthrd.h"

#include "rtpaddr.h"

#include "msrtpapi.h"

RTPSTDAPI CreateRtpSess(
        RtpSess_t **ppRtpSess
    )
{
    HRESULT hr;
    
    hr = GetRtpSess(ppRtpSess);

    return(hr);
}

RTPSTDAPI DeleteRtpSess(
        RtpSess_t *pRtpSess
    )
{
    HRESULT hr;
    
    hr = DelRtpSess(pRtpSess);

    return(hr);
}

/* TODO this two shouldn't be exposed, but I need them before I can
   use Control */

RTPSTDAPI CreateRtpAddr(
        RtpSess_t  *pRtpSess,
        RtpAddr_t **ppRtpAddr,
        DWORD       dwFlags
    )
{
    HRESULT hr;

    hr = GetRtpAddr(pRtpSess, ppRtpAddr, dwFlags);

    return(hr);
}

RTPSTDAPI DeleteRtpAddr(
        RtpSess_t *pRtpSess,
        RtpAddr_t *pRtpAddr
    )
{
    HRESULT hr;

    hr = DelRtpAddr(pRtpSess, pRtpAddr);

    return(hr);
}


RTPSTDAPI RtpControl(RtpSess_t *pRtpSess,
                     DWORD      dwControl,
                     DWORD_PTR  dwPar1,
                     DWORD_PTR  dwPar2)
{
    RtpControlStruct_t RtpControlStruct;
    
    if (!pRtpSess)
    {
        return(RTPERR_POINTER);
    }

    /*
     * TODO (may be) validate RtpSess by verifying that the memory
     * block is an item in the BusyQ in the g_pRtpSessHeap */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        return(RTPERR_INVALIDRTPSESS);
    }

    /* Initialize Control structure */
    ZeroMemory(&RtpControlStruct, sizeof(RtpControlStruct_t));
    RtpControlStruct.pRtpSess = pRtpSess;
    RtpControlStruct.dwControlWord = dwControl;
    RtpControlStruct.dwPar1 = dwPar1;
    RtpControlStruct.dwPar2 = dwPar2;

    return( RtpValidateAndExecute(&RtpControlStruct) );
}

RTPSTDAPI RtpGetLastError(RtpSess_t *pRtpSess)
{
    return(NOERROR);
}
        
RTPSTDAPI RtpRegisterRecvCallback(
        RtpAddr_t       *pRtpAddr,
        PRTP_RECVCOMPLETIONFUNC pRtpRecvCompletionFunc
    )
{
    if (!pRtpAddr)
    {
        return(RTPERR_POINTER);
    }
    
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        return(RTPERR_INVALIDRTPSESS);
    }

    pRtpAddr->pRtpRecvCompletionFunc = pRtpRecvCompletionFunc;

    return(NOERROR);
}

RTPSTDAPI RtpRecvFrom(
        RtpAddr_t *pRtpAddr,
        WSABUF    *pWSABuf,
        void      *pvUserInfo1,
        void      *pvUserInfo2
    )
{
    HRESULT hr;
    
    hr = RtpRecvFrom_(pRtpAddr,
                      pWSABuf,
                      pvUserInfo1,
                      pvUserInfo2
        );

    return(hr);
}


RTPSTDAPI RtpSendTo(
        RtpAddr_t *pRtpAddr,
        WSABUF    *pWSABuf,
        DWORD      dwWSABufCount,
        DWORD      dwTimeStamp,
        DWORD      dwSendFlags
    )
{
    HRESULT hr;
    
    hr = RtpSendTo_(pRtpAddr, pWSABuf, dwWSABufCount, dwTimeStamp,dwSendFlags);

    return(hr);
}

RTPSTDAPI RtpStart(
        RtpSess_t *pRtpSess,
        DWORD      dwFlags
    )
{
    HRESULT hr;

    hr = RtpStart_(pRtpSess, dwFlags);

    return(hr);
}

RTPSTDAPI RtpStop(
        RtpSess_t *pRtpSess,
        DWORD      dwFlags
    )
{
    HRESULT hr;

    hr = RtpStop_(pRtpSess, dwFlags);

    return(hr);
}

/*
 * Initializes all the modules that require initialization. This
 * function can be called from DllMain(PROCESS_ATTACH) if linked as a
 * DLL, or explicitly from an application initializing the RTP stack
 * if linked as a library. */
RTPSTDAPI MSRtpInit1(HINSTANCE hInstance)
{
    HRESULT          hr1;
    HRESULT          hr2;
    BOOL             bOk1;
    BOOL             bOk2;
    BOOL             bOk3;
    BOOL             bOk4;

    /* One time operation that doesn't need de-init */
    /* NOTE this function will zero g_RtpContext */
    RtpInitReferenceTime();
    
    hr1 = RtpInit();
    
    /* initialize heaps */
    bOk1 = RtpCreateMasterHeap();
    bOk2 = RtpCreateGlobHeaps();
    
    bOk3 = RtpInitializeCriticalSection(&g_RtpContext.RtpWS2CritSect,
                                        &g_RtpContext,
                                        _T("g_RtpContext.RtpWS2CritSect"));

    bOk4 = RtpInitializeCriticalSection(&g_RtpContext.RtpPortsCritSect,
                                        &g_RtpContext,
                                        _T("g_RtpContext.RtpPortsCritSect"));


    hr2 = RtcpInit();

    if (!bOk1 || !bOk2 || !bOk3 || !bOk4 ||
        (hr1 != NOERROR) || (hr2 != NOERROR))
    {
        MSRtpDelete1();
        return(RTPERR_FAIL);
    }

    return(NOERROR);
}

/*
 * This function does initialization not allowed during process
 * attach, e.g. initialize winsock2 */
RTPSTDAPI MSRtpInit2(void)
{
    HRESULT          hr;
    BOOL             bOk;
    DWORD            dwError;
    WSADATA          WSAData;
    WORD             VersionRequested;
    

    hr = RTPERR_FAIL;

    /* Critical section was initialized during process attach by
     * MSRtpInit1 */
    bOk = RtpEnterCriticalSection(&g_RtpContext.RtpWS2CritSect);

    if (bOk)
    {
        if (g_RtpContext.lRtpWS2Users <= 0)
        {
            /* Initialize some debug variables */
            hr = RtpDebugInit(RTPDBG_MODULENAME);

            /* initialize winsock */
            VersionRequested = MAKEWORD(2,0);
            
            dwError = WSAStartup(VersionRequested, &WSAData);

            if (dwError == 0)
            {
                /* socket used to query destination address */
                g_RtpContext.RtpQuerySocket = WSASocket(
                        AF_INET,    /* int af */
                        SOCK_DGRAM, /* int type */
                        IPPROTO_IP, /* int protocol */
                        NULL,       /* LPWSAPROTOCOL_INFO lpProtocolInfo */
                        0,          /* GROUP g */
                        NO_FLAGS    /* DWORD dwFlags */
                    );
        
                if (g_RtpContext.RtpQuerySocket == INVALID_SOCKET)
                {
                    WSACleanup();
                }
                else
                {
                    RtpRegistryInit(&g_RtpReg);

                    /* Needs to be called after RtpRegistryInit so the
                     * possible registry defaults are already read */
                    RtcpSdesInit(&g_RtpSdesDefault);
                    RtcpSdesSetDefault(&g_RtpSdesDefault);

                    RtpRandInit();
                    
                    g_RtpContext.lRtpWS2Users = 1;

                    hr = NOERROR;
                }
            }
        }
        else
        {
            g_RtpContext.lRtpWS2Users++;

            hr = NOERROR;
        }

        RtpLeaveCriticalSection(&g_RtpContext.RtpWS2CritSect);
    }

    return(hr);
}

            
/*
 * Complementary function of MSRtpInit(). Can be called from
 * DllMain(PROCESS_DETACH) if linked as a DLL, or explicitly from an
 * application de-initializing the RTP stack if linked as a
 * library. */
RTPSTDAPI MSRtpDelete1(void)
{
    HRESULT          hr1;
    HRESULT          hr2;
    BOOL             bOk1;
    BOOL             bOk2;
    BOOL             bOk3;
    BOOL             bOk4;

    hr1 = RtpDelete();
    hr2 = RtcpDelete();

    bOk1 = RtpDestroyGlobHeaps();
    bOk2 = RtpDestroyMasterHeap();

    bOk3 = RtpDeleteCriticalSection(&g_RtpContext.RtpWS2CritSect);

    bOk4 = RtpDeleteCriticalSection(&g_RtpContext.RtpPortsCritSect);
    
    if ((hr1 != NOERROR) || (hr2 != NOERROR) ||
        !bOk1 || !bOk2 || !bOk3 || !bOk4)
    {
        return(RTPERR_FAIL);
    }
    else
    {
        return(NOERROR);
    }
}

/*
 * Complementary function of MSRtpInit2(). */
RTPSTDAPI MSRtpDelete2(void)
{
    HRESULT          hr;
    DWORD            dwError;
    BOOL             bOk;

    dwError = NOERROR;
    
    /* Critical section was initialized during process attach by
     * MSRtpInit1 */
    bOk = RtpEnterCriticalSection(&g_RtpContext.RtpWS2CritSect);

    if (bOk)
    {
        g_RtpContext.lRtpWS2Users--;

        if (g_RtpContext.lRtpWS2Users <= 0)
        {
            if (g_RtpContext.RtpQuerySocket != INVALID_SOCKET)
            {
                closesocket(g_RtpContext.RtpQuerySocket);
                g_RtpContext.RtpQuerySocket = INVALID_SOCKET;
            }
        
            dwError = WSACleanup();

            RtpRandDeinit();

            RtpRegistryDel(&g_RtpReg);

            RtpDebugDeinit();
        }

        RtpLeaveCriticalSection(&g_RtpContext.RtpWS2CritSect);
    }

    if ((bOk == FALSE) || (dwError != NOERROR))
    {
        return(RTPERR_FAIL);
    }
    else
    {
        return(NOERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpaddr.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpaddr.c
 *
 *  Abstract:
 *
 *    Implement the RTP Address family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/01 created
 *
 **********************************************************************/

#include "struct.h"

#include <ws2tcpip.h>

#include "rtpmisc.h"
#include "rtpqos.h"
#include "rtpreg.h"
#include "rtpncnt.h"
#include "rtpdemux.h"
#include "rtpglobs.h"
#include "rtprand.h"

#include "rtpaddr.h"

DWORD   RtpGetLocalIPAddress(DWORD dwRemoteAddr);
HRESULT RtpGetSockets(RtpAddr_t *pRtpAddr);
HRESULT RtpDelSockets(RtpAddr_t *pRtpAddr);
SOCKET  RtpSocket(
        RtpAddr_t       *pRtpAddr,
        WSAPROTOCOL_INFO *pProtoInfo,
        DWORD            dwRtpRtcp
    );
BOOL RtpSetTTL(SOCKET Socket, DWORD dwTTL, BOOL bMcast);
BOOL RtpSetMcastSendIF(SOCKET Socket, DWORD dwAddr);
BOOL RtpSetWinSockLoopback(SOCKET Socket, BOOL bEnabled);
BOOL RtpJoinLeaf(SOCKET Socket, DWORD dwAddr, WORD wPort);


HRESULT ControlRtpAddr(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

/* Obtain the local and remote ports used.
 *
 * WARNING: Must be called after SetAddress
 * */
HRESULT RtpGetPorts(
        RtpAddr_t       *pRtpAddr,
        WORD            *pwRtpLocalPort,
        WORD            *pwRtpRemotePort,
        WORD            *pwRtcpLocalPort,
        WORD            *pwRtcpRemotePort
    )
{
    HRESULT          hr;
    
    TraceFunctionName("RtpGetPorts");

    if (!pRtpAddr)
    {
        hr = RTPERR_INVALIDSTATE;
        goto bail;
    }

    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        hr = RTPERR_INVALIDRTPADDR;

        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        goto bail;
    }

    if (!pwRtpLocalPort  &&
        !pwRtpRemotePort &&
        !pwRtcpLocalPort &&
        !pwRtcpRemotePort)
    {
        hr = RTPERR_POINTER;
        goto bail;
    }

    if ( (pwRtpLocalPort  && !pRtpAddr->wRtpPort[LOCAL_IDX]) ||
         (pwRtcpLocalPort && !pRtpAddr->wRtcpPort[LOCAL_IDX]) )
    {
        /* In order to get local ports I must have the sockets created
         * and have a local address to use */
        
        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_LADDR))
        {
            hr = RtpGetSockets(pRtpAddr);

            if (FAILED(hr))
            {
                goto bail;
            }
        }
        else
        {
            hr = RTPERR_INVALIDSTATE;
            goto bail;
        }
    }

    if (pwRtpLocalPort)
    {
        *pwRtpLocalPort   = pRtpAddr->wRtpPort[LOCAL_IDX];
    }

    if (pwRtpRemotePort)
    {
        *pwRtpRemotePort  = pRtpAddr->wRtpPort[REMOTE_IDX];
    }

    if (pwRtcpLocalPort)
    {
        *pwRtcpLocalPort  = pRtpAddr->wRtcpPort[LOCAL_IDX];
    }

    if (pwRtcpRemotePort)
    {
        *pwRtcpRemotePort = pRtpAddr->wRtcpPort[REMOTE_IDX];
    }

    hr = NOERROR;

    TraceRetail((
            CLASS_INFO, GROUP_NETWORK, S_NETWORK_SOCK,
            _T("%s: pRtpAddr[0x%p] RTP(L:%u, R:%u) RTCP(L:%u, R:%u)"),
            _fname, pRtpAddr,
            ntohs(pRtpAddr->wRtpPort[LOCAL_IDX]),
            ntohs(pRtpAddr->wRtpPort[REMOTE_IDX]),
            ntohs(pRtpAddr->wRtcpPort[LOCAL_IDX]),
            ntohs(pRtpAddr->wRtcpPort[REMOTE_IDX])
        ));

 bail:

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] failed: 0x%X"),
                _fname, pRtpAddr, hr
            ));
    }

    return(hr);
}

/*
 * Set the local and remote ports.
 *
 * Do nothing if passing -1, otherwise assign value (including 0)
 * */
HRESULT RtpSetPorts(
        RtpAddr_t       *pRtpAddr,
        WORD             wRtpLocalPort,
        WORD             wRtpRemotePort,
        WORD             wRtcpLocalPort,
        WORD             wRtcpRemotePort
    )
{
    HRESULT          hr;
    
    TraceFunctionName("RtpSetPorts");

    if (!pRtpAddr)
    {
        hr = RTPERR_INVALIDSTATE;
        goto bail;
    }

    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        hr = RTPERR_INVALIDRTPADDR;

        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));
        
        goto bail;
    }

    /* RTP local port */
    if ((wRtpLocalPort != (WORD)-1) &&
        pRtpAddr->wRtpPort[LOCAL_IDX] &&
        (pRtpAddr->wRtpPort[LOCAL_IDX] != wRtpLocalPort))
    {
        hr = RTPERR_INVALIDSTATE;
        goto bail;
    }
    
    if (wRtpLocalPort != (WORD)-1)
    {
        pRtpAddr->wRtpPort[LOCAL_IDX] = wRtpLocalPort;
    }

    /* RTP remote port */
    if (wRtpRemotePort != (WORD)-1)
    {
        pRtpAddr->wRtpPort[REMOTE_IDX] = wRtpRemotePort;
    }

    /* RTCP local port */
    if ((wRtcpLocalPort != (WORD)-1) &&
        pRtpAddr->wRtcpPort[LOCAL_IDX] &&
        (pRtpAddr->wRtcpPort[LOCAL_IDX] != wRtcpLocalPort))
    {
        hr = RTPERR_INVALIDSTATE;
        goto bail;
    }
    
    if (wRtcpLocalPort != (WORD)-1)
    {
        pRtpAddr->wRtcpPort[LOCAL_IDX] = wRtcpLocalPort;
    }

    /* RTCP remote port */
    if (wRtcpRemotePort != (WORD)-1)
    {
        pRtpAddr->wRtcpPort[REMOTE_IDX] = wRtcpRemotePort;
    }

    TraceRetail((
            CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
            _T("%s: RTP(L:%u, R:%u) RTCP(L:%u, R:%u)"),
            _fname, 
            ntohs(pRtpAddr->wRtpPort[LOCAL_IDX]),
            ntohs(pRtpAddr->wRtpPort[REMOTE_IDX]),
            ntohs(pRtpAddr->wRtcpPort[LOCAL_IDX]),
            ntohs(pRtpAddr->wRtcpPort[REMOTE_IDX])
        ));
    
    hr = NOERROR;
    
 bail:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: failed: 0x%X"),
                _fname, hr
            ));
    }

    return(hr);
}

HRESULT RtpGetAddress(
        RtpAddr_t       *pRtpAddr,
        DWORD           *pdwLocalAddr,
        DWORD           *pdwRemoteAddr
    )
{
    HRESULT          hr;

    TraceFunctionName("RtpGetAddress");

    if (!pRtpAddr)
    {
        return(RTPERR_INVALIDSTATE);
    }

    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        hr = RTPERR_INVALIDRTPADDR;

        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));
        
        goto bail;
    }

    if (!pdwLocalAddr && !pdwRemoteAddr)
    {
        hr = RTPERR_POINTER;
        
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] local or remote address not provided"),
                _fname, pRtpAddr
            ));
        
        goto bail;
    }
    
    hr = RTPERR_INVALIDSTATE;
    
    if (pdwLocalAddr)
    {
        *pdwLocalAddr = pRtpAddr->dwAddr[LOCAL_IDX];

        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_LADDR))
        {
            hr = NOERROR;
        }
    }

    if (pdwRemoteAddr)
    {
        *pdwRemoteAddr = pRtpAddr->dwAddr[REMOTE_IDX];        

        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RADDR))
        {
            hr = NOERROR;
        }
    }
        
bail:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] failed: 0x%X"),
                _fname, pRtpAddr, hr
            ));
    }

    return(hr);
}

/*
 * If dwLocalAddr is 0, a default local address is asigned if non has
 * been assigned before. If dwRemoteAddr is 0 no error occurs. At
 * least 1 address must be set */
HRESULT RtpSetAddress(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwLocalAddr,
        DWORD            dwRemoteAddr
    )
{
    HRESULT          hr;
    struct in_addr   iaLocalAddr;
    struct in_addr   iaRemoteAddr;
    TCHAR_t          sLocal[16];
    TCHAR_t          sRemote[16];
    
    TraceFunctionName("RtpSetAddress");

    if (!pRtpAddr)
    {
        hr = RTPERR_INVALIDSTATE;
        goto bail;
    }

    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        hr = RTPERR_INVALIDRTPADDR;

        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));
        
        goto bail;
    }

    /* Fail if both addresses are 0 */
    if (!dwLocalAddr && !dwRemoteAddr)
    {
        hr = RTPERR_INVALIDARG;
        goto bail;
    }
    
    hr = NOERROR;

    /*
     * Remote address
     */
#if 0  /* the address can be set again. */
    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RADDR))
    {
         /* If addresses were already set, verify the new setting is
          * the same */
        if (dwRemoteAddr &&
            (dwRemoteAddr != pRtpAddr->dwAddr[REMOTE_IDX]))
        {
            hr = RTPERR_INVALIDARG;
            goto bail;
        }
    }
    else
#endif
    {
        /* Remote address hasn't been set yet */
        if (dwRemoteAddr)
        {
            pRtpAddr->dwAddr[REMOTE_IDX] = dwRemoteAddr;
            
            if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RADDR) &&
                RtpBitTest(pRtpAddr->dwIRtpFlags,
                           FGADDR_IRTP_RADDRRESETDEMUX) &&
                dwRemoteAddr != pRtpAddr->dwAddr[REMOTE_IDX])
            {
                /* If the remote address is set, and a new and
                 * different remote address is being set, and the
                 * FGADDR_IRTP_RADDRRESETDEMUX flag is set, unmap all
                 * outputs */
                RtpUnmapAllOuts(pRtpAddr->pRtpSess);
            }
    
            RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_RADDR);

            if (IS_MULTICAST(dwRemoteAddr))
            {
                RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_ISMCAST);
            }
            else
            {
                RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_ISMCAST);
            }
        }
    }

    /*
     * Local address
     */
#if 0  /* the address can be set again. */
    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_LADDR))
    {
        /* If addresses were already set, verify the new setting is
         * the same */
        if (dwLocalAddr &&
            (dwLocalAddr != pRtpAddr->dwAddr[LOCAL_IDX]))
        {
            hr = RTPERR_INVALIDARG;
            goto bail;
        }
    }
    else
#endif
    {
        /* Local address hasn't been set yet */
        if (dwLocalAddr)
        {
            /* TODO might verify the address is really a local address */
            pRtpAddr->dwAddr[LOCAL_IDX] = dwLocalAddr;
        }
        else
        {
            pRtpAddr->dwAddr[LOCAL_IDX] =
                RtpGetLocalIPAddress(pRtpAddr->dwAddr[REMOTE_IDX]);

            if (!pRtpAddr->dwAddr[LOCAL_IDX])
            {
                /* Failed */
                hr = RTPERR_INVALIDARG;
                goto bail;
            }
        }

        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_LADDR);
    }
    
    TraceRetail((
            CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
            _T("%s: pRtpAddr[0x%p] Local:%s Remote:%s"),
            _fname, pRtpAddr,
            RtpNtoA(pRtpAddr->dwAddr[LOCAL_IDX], sLocal),
            RtpNtoA(pRtpAddr->dwAddr[REMOTE_IDX], sRemote)
        ));
    
 bail:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] failed: 0x%X"),
                _fname, pRtpAddr, hr
            ));
    }
    
    return(hr);
}

/* Obtain the local IP address to use based on the destination address */
DWORD RtpGetLocalIPAddress(DWORD dwRemoteAddr)
{
    DWORD            dwStatus;
    DWORD            dwError;
    DWORD            dwLocalAddr;
    SOCKADDR_IN      sRemoteAddr;
    SOCKADDR_IN      sLocalAddr;
    DWORD            dwNumBytesReturned;
    TCHAR_t          sLocalAddress[16];
    TCHAR_t          sRemoteAddress[16];
    
    TraceFunctionName("RtpGetLocalIPAddress");

    dwNumBytesReturned = 0;
    
    sRemoteAddr.sin_family = AF_INET;
    sRemoteAddr.sin_addr =  *(struct in_addr *) &dwRemoteAddr;
    sRemoteAddr.sin_port = ntohs(0);

    dwLocalAddr = INADDR_ANY;

    if (g_RtpContext.RtpQuerySocket != INVALID_SOCKET)
    {
        if ((dwStatus = WSAIoctl(
                g_RtpContext.RtpQuerySocket, // SOCKET s
                SIO_ROUTING_INTERFACE_QUERY, // DWORD dwIoControlCode
                &sRemoteAddr,        // LPVOID  lpvInBuffer
                sizeof(sRemoteAddr), // DWORD   cbInBuffer
                &sLocalAddr,         // LPVOID  lpvOUTBuffer
                sizeof(sLocalAddr),  // DWORD   cbOUTBuffer
                &dwNumBytesReturned, // LPDWORD lpcbBytesReturned
                NULL, // LPWSAOVERLAPPED lpOverlapped
                NULL  // LPWSAOVERLAPPED_COMPLETION_ROUTINE lpComplROUTINE
            )) == SOCKET_ERROR)
        {
            TraceRetailWSAGetError(dwError);
            
            TraceRetail((
                    CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                    _T("%s: WSAIoctl(SIO_ROUTING_INTERFACE_QUERY) ")
                    _T("failed: %u (0x%X)"),
                    _fname, dwError, dwError
                ));
        }
        else
        {
            dwLocalAddr = *(DWORD *)&sLocalAddr.sin_addr; 
        }
    }
    
    TraceRetail((
            CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
            _T("%s: Local IP address:%s to reach:%s"),
            _fname, RtpNtoA(dwLocalAddr, sLocalAddress),
            RtpNtoA(dwRemoteAddr, sRemoteAddress)
        ));
    
    return(dwLocalAddr);
}

/* Obtain a pair of sockets and select port to use if they haven't
 * been specified. If a local port is not specified, but the
 * destination address is multicast and we have a remote port, assign
 * the remote port to the local port */
HRESULT RtpGetSockets(RtpAddr_t *pRtpAddr)
{
    HRESULT          hr;
    BOOL             bOk;
    BOOL             bGotPorts;
    DWORD            dwError;
    BOOL             bAutoPort;
    DWORD            i;
    DWORD            j;
    DWORD            dwMaxAttempts;
    DWORD            dwRandom;
    WORD             wPort;
    WORD             wOldRtcpPort;
    RtpQueueItem_t  *pRtpQueueItem;
    WSAPROTOCOL_INFO ProtoInfo;
    WSAPROTOCOL_INFO *pProtoInfo;

    TraceFunctionName("RtpGetSockets");

    hr = NOERROR;

    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_SOCKET))
    {
        /* Sockets already created */
        TraceRetail((
                CLASS_WARNING, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] Sockets already created"),
                _fname, pRtpAddr
            ));
        
        return(hr);
    }

    /* Prepare protocol info if QOS is enabled */
    pProtoInfo = (WSAPROTOCOL_INFO *)NULL;
    
    if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_QOS) &&
        !RtpBitTest2(pRtpAddr->dwAddrFlagsQ,
                     FGADDRQ_REGQOSDISABLE, FGADDRQ_QOSNOTALLOWED))
    {
        hr = RtpGetQosEnabledProtocol(&ProtoInfo);

        if (SUCCEEDED(hr))
        {
            pProtoInfo = &ProtoInfo;
        }
    }
    
    bAutoPort = FALSE;
    
    if (!pRtpAddr->wRtpPort[LOCAL_IDX])
    {
        if (IS_MULTICAST(pRtpAddr->dwAddr[REMOTE_IDX]) &&
            pRtpAddr->wRtpPort[REMOTE_IDX])
        {
            /* Assign same port as remote */
            pRtpAddr->wRtpPort[LOCAL_IDX] = pRtpAddr->wRtpPort[REMOTE_IDX];
        }
        else
        {
            /* If local RTP port hasn't been specified, enable auto
             * ports allocation */
            bAutoPort = TRUE;
        }
    }

    if (!pRtpAddr->wRtcpPort[LOCAL_IDX])
    {
        if (IS_MULTICAST(pRtpAddr->dwAddr[REMOTE_IDX]) &&
            pRtpAddr->wRtcpPort[REMOTE_IDX])
        {
            /* Assign same port as remote */
            pRtpAddr->wRtcpPort[LOCAL_IDX] = pRtpAddr->wRtcpPort[REMOTE_IDX];
        }
        else
        {
            /* If RTCP port hasn't been assigned, either, let the
             * system assign it if the RTP port was already assigned,
             * otherwise, auto assign both ports */
        }
    }

    wOldRtcpPort = pRtpAddr->wRtcpPort[LOCAL_IDX];

    bOk = FALSE;
    
    dwMaxAttempts = 1;
    
    if (bAutoPort)
    {
        dwMaxAttempts = 16;
    }

    bOk = RtpEnterCriticalSection(&g_RtpContext.RtpPortsCritSect);

    if (!bOk)
    {
        /* Failed to grab the lock, make sure auto ports allocation is
         * disabled */
        bAutoPort = FALSE;
    }
    
    for(i = 0; i < dwMaxAttempts; i++)
    {
        bGotPorts = FALSE;
        
        for(j = 0; bAutoPort && (j < 64); j++)
        {
            /* Get an even random port */
            dwRandom = RtpRandom32((DWORD_PTR)&dwRandom) & 0xffff;

            if (dwRandom < RTPPORT_LOWER)
            {
                /* Don't want to use a modulo to give all ports the
                 * same chance (the range is not power of 2) */
                continue;
            }
            
            wPort = (WORD) (dwRandom & ~0x1);

            pRtpAddr->wRtpPort[LOCAL_IDX] = htons(wPort);

            if (wOldRtcpPort)
            {
                /* If the RTCP port was specified, do not override it */;
            }
            else
            {
                pRtpAddr->wRtcpPort[LOCAL_IDX] = htons(wPort + 1);
            }

            /* Find out if this RTP port hasn't been allocated */
            pRtpQueueItem = findHdwK(&g_RtpContext.RtpPortsH,
                                     NULL,
                                     (DWORD)wPort);

            if (!pRtpQueueItem)
            {
                /* Port not in use yet by RTP */

                TraceRetail((
                        CLASS_INFO, GROUP_NETWORK, S_NETWORK_SOCK,
                        _T("%s: pRtpAddr[0x%p] Local ports allocated: ")
                        _T("RTP:%u, RTCP:%u"),
                        _fname, pRtpAddr,
                        (DWORD)ntohs(pRtpAddr->wRtpPort[LOCAL_IDX]),
                        (DWORD)ntohs(pRtpAddr->wRtcpPort[LOCAL_IDX])
                    ));
                
                bGotPorts = TRUE;
                
                break;
            }
        }

        if (bAutoPort && !bGotPorts)
        {
            /* If I couldn't get proper port numbers, let the system
             * assign them */
            pRtpAddr->wRtpPort[LOCAL_IDX] = 0;

            if (!wOldRtcpPort)
            {
                pRtpAddr->wRtcpPort[LOCAL_IDX] = 0;
            }
        }
        
        /* RTP socket */
        pRtpAddr->Socket[SOCK_RECV_IDX] = RtpSocket(
                pRtpAddr,
                pProtoInfo,
                RTP_IDX);
    
        pRtpAddr->Socket[SOCK_SEND_IDX] = pRtpAddr->Socket[SOCK_RECV_IDX];

        if (pRtpAddr->Socket[SOCK_RECV_IDX] == INVALID_SOCKET)
        {
            hr = RTPERR_RESOURCES;
            goto end;
        }

        /* At least one socket created, set this flag to allow
         * deletion in case of failure */
        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_SOCKET);

        /* RTCP socket */
        pRtpAddr->Socket[SOCK_RTCP_IDX] = RtpSocket(
                pRtpAddr,
                (WSAPROTOCOL_INFO *)NULL,
                RTCP_IDX);

        if (pRtpAddr->Socket[SOCK_RTCP_IDX] == INVALID_SOCKET)
        {
            hr = RTPERR_RESOURCES;
            goto end;
        }

        if (bOk)
        {
            /* Update list of ports, the port used as key is either
             * the one allocated by RTP, the one assigned trhough the
             * API, or the one assigned by the system */
            insertHdwK(&g_RtpContext.RtpPortsH,
                       NULL,
                       &pRtpAddr->PortsQItem,
                       pRtpAddr->wRtpPort[LOCAL_IDX]);

            RtpLeaveCriticalSection(&g_RtpContext.RtpPortsCritSect);

            bOk = FALSE;
        }
        
        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] Created sockets: %u, %u, %u"),
                _fname, pRtpAddr,
                pRtpAddr->Socket[SOCK_RECV_IDX],
                pRtpAddr->Socket[SOCK_SEND_IDX],
                pRtpAddr->Socket[SOCK_RTCP_IDX]
            ));

        break;
        
    end:
        RtpDelSockets(pRtpAddr);

        TraceRetailWSAGetError(dwError);
    
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] failed to create sockets: %u (0x%X)"),
                _fname, pRtpAddr, dwError, dwError
            ));
    }

    if (bOk)
    {
        /* If none of the attemps to create sockets succeed, I would
         * still have the critical section here, release it */
        RtpLeaveCriticalSection(&g_RtpContext.RtpPortsCritSect);
    }
    
    return(hr);
}

HRESULT RtpDelSockets(RtpAddr_t *pRtpAddr)
{
    DWORD            dwError;
    
    TraceFunctionName("RtpDelSockets");

    /* destroy sockets */

    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_SOCKET))
    {
        /* sockets already created */

        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] Deleting sockets: %u, %u, %u"),
                _fname, pRtpAddr,
                pRtpAddr->Socket[SOCK_RECV_IDX],
                pRtpAddr->Socket[SOCK_SEND_IDX],
                pRtpAddr->Socket[SOCK_RTCP_IDX]
            ));
 
        /* RTP */
        if (pRtpAddr->Socket[SOCK_RECV_IDX] != INVALID_SOCKET)
        {
            dwError = closesocket(pRtpAddr->Socket[SOCK_RECV_IDX]);

            if (dwError)
            {
                TraceRetailWSAGetError(dwError);
                
                TraceRetail((
                        CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                        _T("%s: pRtpAddr[0x%p] closesocket(RTP:%u) ")
                        _T("failed: %u (0x%X)"),
                        _fname, pRtpAddr, pRtpAddr->Socket[SOCK_RECV_IDX],
                        dwError, dwError
                    ));
            }

            pRtpAddr->Socket[SOCK_RECV_IDX] = INVALID_SOCKET;
            pRtpAddr->Socket[SOCK_SEND_IDX] = pRtpAddr->Socket[SOCK_RECV_IDX];
        }
        
        /* RTCP */
        if (pRtpAddr->Socket[SOCK_RTCP_IDX] != INVALID_SOCKET)
        {
            dwError = closesocket(pRtpAddr->Socket[SOCK_RTCP_IDX]);
        
            if (dwError)
            {
                TraceRetailWSAGetError(dwError);
                
                TraceRetail((
                        CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                        _T("%s: pRtpAddr[0x%p] closesocket(RTCP:%u) ")
                        _T("failed: %u (0x%X)"),
                        _fname, pRtpAddr, pRtpAddr->Socket[SOCK_RTCP_IDX],
                        dwError, dwError
                    ));
            }
            
            pRtpAddr->Socket[SOCK_RTCP_IDX] = INVALID_SOCKET;
        }

        /* Address might not be in a queue if we are comming here from
         * a failure in RtpGetSockets, this would generate another
         * error in the log */
        removeH(&g_RtpContext.RtpPortsH,
                &g_RtpContext.RtpPortsCritSect,
                &pRtpAddr->PortsQItem);
        
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_SOCKET);
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_SOCKOPT);
    }

    return(NOERROR);
}    

SOCKET RtpSocket(
        RtpAddr_t       *pRtpAddr,
        WSAPROTOCOL_INFO *pProtoInfo,
        DWORD            dwRtpRtcp
    )
{
    DWORD            i;
    SOCKET           Socket;
    int              iSockFlags;
    DWORD            dwPar;
    DWORD            dwError;
    WORD            *pwPort;
    SOCKADDR_IN      LocalAddr;
    int              LocalAddrLen;
    TCHAR_t          sLocalAddr[16];
    
    TraceFunctionName("RtpSocket");

    iSockFlags = WSA_FLAG_OVERLAPPED;

    if (IS_MULTICAST(pRtpAddr->dwAddr[REMOTE_IDX]))
    {
        iSockFlags |=
            (WSA_FLAG_MULTIPOINT_C_LEAF |
             WSA_FLAG_MULTIPOINT_D_LEAF);
    }

    for(i = 0; i < 2; i++)
    {
        Socket = WSASocket(
                AF_INET,    /* int af */
                SOCK_DGRAM, /* int type */
                IPPROTO_IP, /* int protocol */
                pProtoInfo, /* LPWSAPROTOCOL_INFO lpProtocolInfo */
                0,          /* GROUP g */
                iSockFlags  /* DWORD dwFlags */
            );
        
        if (Socket == INVALID_SOCKET)
        {
            TraceRetailWSAGetError(dwError);

            TraceRetail((
                    CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                    _T("%s: pRtpAddr[0x%p] pProtoInfo[0x%p] failed: %u (0x%X)"),
                    _fname, pRtpAddr, pProtoInfo, dwError, dwError
            ));

            if (pProtoInfo && (dwError == WSASYSNOTREADY))
            {
                /* The user credentials do not allow him to start
                 * RSVP, so I get this specific error and need to
                 * disable QOS */
                TraceRetail((
                        CLASS_WARNING, GROUP_NETWORK, S_NETWORK_SOCK,
                        _T("%s: pRtpAddr[0x%p] try again with QOS disabled"),
                        _fname, pRtpAddr
                    ));

                /* Disable QOS */
                pProtoInfo = (WSAPROTOCOL_INFO *)NULL;

                RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSNOTALLOWED);
            }
        }
        else
        {
            break;
        }
    }

    if (Socket == INVALID_SOCKET)
    {
        return(Socket);
    }

    /* Need to do this before binding, otherwise it may fail if the
     * address is already in use.
     *
     * WARNING Note that option SO_REUSEADDR is used regardless of the
     * destination address (multicast or unicast). Who receives data
     * in a unicast session is unpredicted when multiple (more than 1)
     * sockets are bound to the same address and port
     * */
            
    dwPar = 1; /* Reuse */

    /* Reuse address/port */
    dwError = setsockopt(
            Socket,
            SOL_SOCKET,
            SO_REUSEADDR,
            (PCHAR)&dwPar,
            sizeof(dwPar)
        );
        
    if (dwError == SOCKET_ERROR)
    {
        TraceRetailWSAGetError(dwError);
        
        TraceRetail((
                CLASS_WARNING, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] setsockoption(SO_REUSEADDR) ")
                _T("failed: %u (0x%X)"),
                _fname, pRtpAddr, dwError, dwError
            ));
    }

    if (dwRtpRtcp == RTP_IDX)
    {
        /* Set receiver buffer size to zero for RTP socket */
        RtpSetRecvBuffSize(pRtpAddr, Socket, 0);

        pwPort = &pRtpAddr->wRtpPort[0];
    }
    else
    {
        pwPort = &pRtpAddr->wRtcpPort[0];
    }
    
    /* bind socket */
    ZeroMemory(&LocalAddr, sizeof(LocalAddr));

    LocalAddr.sin_family = AF_INET;
    LocalAddr.sin_addr = *(struct in_addr *) &pRtpAddr->dwAddr[LOCAL_IDX];
    LocalAddr.sin_port = pwPort[LOCAL_IDX];
            
    /* bind rtp socket to the local address specified */
    dwError = bind(Socket, (SOCKADDR *)&LocalAddr, sizeof(LocalAddr));

    if (dwError == 0)
    {
        /* Get the port */
        LocalAddrLen = sizeof(LocalAddr);
        dwError =
            getsockname(Socket, (struct sockaddr *)&LocalAddr, &LocalAddrLen);

        if (dwError == 0)
        {
            pwPort[LOCAL_IDX] = LocalAddr.sin_port;
            
            TraceDebug((
                    CLASS_INFO, GROUP_NETWORK, S_NETWORK_SOCK,
                    _T("%s: getsockname: %u:%u/%s/%u"),
                    _fname, Socket,
                    LocalAddr.sin_family,
                    RtpNtoA(LocalAddr.sin_addr.s_addr, sLocalAddr),
                    ntohs(LocalAddr.sin_port)
                ));
        }
        else
        {
            TraceRetailWSAGetError(dwError);
        
            TraceRetail((
                    CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                    _T("%s: getsockname socket:%u failed: %u (0x%X)"),
                    _fname, Socket, dwError, dwError
                ));
        
            closesocket(Socket);

            return(INVALID_SOCKET);
        }
    }
    else
    {
        TraceRetailWSAGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: bind socket:%u to port:%u failed: %u (0x%X)"),
                _fname, Socket,
                ntohs(LocalAddr.sin_port), dwError, dwError
            ));
        
        closesocket(Socket);

        return(INVALID_SOCKET);
    }


    return(Socket);
}

BOOL RtpSetTTL(SOCKET Socket, DWORD dwTTL, BOOL bMcast)
{
    DWORD            dwStatus;
    DWORD            dwError;
    DWORD            bOK;

    TraceFunctionName("RtpSetTTL");

    dwStatus = setsockopt( 
            Socket,
            IPPROTO_IP, 
            bMcast? IP_MULTICAST_TTL : IP_TTL,
            (PCHAR)&dwTTL,
            sizeof(dwTTL)
        );

    if (dwStatus == SOCKET_ERROR)
    {
        bOK = FALSE;

        TraceRetailWSAGetError(dwError);
            
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_TTL,
                _T("%s: Socket:%u TTL:%d failed: %u (0x%X)"),
                _fname, Socket, dwTTL, dwError, dwError
            ));
    }
    else
    {
        bOK = TRUE;

        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_TTL,
                _T("%s: Socket:%u TTL:%d"),
                _fname, Socket, dwTTL
            ));
    }
    
    return(bOK);
}

BOOL RtpSetMcastSendIF(SOCKET Socket, DWORD dwAddr)
{
    DWORD            dwStatus;
    DWORD            dwError;
    DWORD            bOK;
    TCHAR_t          sAddr[16];
    
    TraceFunctionName("RtpSetMcastSendIF");

    dwStatus = setsockopt( 
            Socket,
            IPPROTO_IP, 
            IP_MULTICAST_IF,
            (char *)&dwAddr,
            sizeof(dwAddr)
        );

    if (dwStatus == SOCKET_ERROR)
    {
        bOK = FALSE;

        TraceRetailWSAGetError(dwError);
            
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: Socket:%u IP_MULTICAST_IF(%s) failed: %u (0x%X)"),
                _fname, Socket, RtpNtoA(dwAddr, sAddr),
                dwError, dwError
            ));
    }
    else
    {
        bOK = TRUE;

        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: Socket:%u using:%s"),
                _fname, Socket, RtpNtoA(dwAddr, sAddr)
            ));
    }
    
    return(bOK);
}

BOOL RtpSetWinSockLoopback(SOCKET Socket, BOOL bEnabled)
{
    DWORD            dwStatus;
    DWORD            dwPar;
    DWORD            dwError;
    DWORD            bOK;

    TraceFunctionName("RtpSetWinSockLoopback");
    
    dwPar = bEnabled? 1:0;
    
    /* Allow own packets to come back */
    dwStatus = setsockopt(
            Socket,
            IPPROTO_IP,
            IP_MULTICAST_LOOP,
            (PCHAR)&dwPar,
            sizeof(dwPar)
        );
        
    if (dwStatus == SOCKET_ERROR)
    {
        bOK = FALSE;
        
        TraceRetailWSAGetError(dwError);
            
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: Socket:%u Loopback:%d failed: %u (0x%X)"),
                _fname, Socket, dwPar, dwError, dwError
            ));
    }
    else
    {
        bOK = TRUE;

        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: Socket:%u Loopback:%d"),
                _fname, Socket, dwPar
            ));
    }
    
    return(bOK);
}

BOOL RtpJoinLeaf(SOCKET Socket, DWORD dwAddr, WORD wPort)
{
    BOOL             bOk;
    DWORD            dwError;
    SOCKADDR_IN      JoinAddr;
    DWORD            dwJoinDirection;
    SOCKET           TmpSocket;
    TCHAR_t          sAddr[16];
                    
    TraceFunctionName("RtpJoinLeaf");

    ZeroMemory(&JoinAddr, sizeof(JoinAddr));
        
    JoinAddr.sin_family = AF_INET;
    JoinAddr.sin_addr = *(struct in_addr *) &dwAddr;
    JoinAddr.sin_port = wPort;

    /* Join in both directions */
    dwJoinDirection = JL_RECEIVER_ONLY | JL_SENDER_ONLY;
            
    TmpSocket = WSAJoinLeaf(Socket,
                            (const struct sockaddr *)&JoinAddr,
                            sizeof(JoinAddr),
                            NULL, NULL, NULL, NULL,
                            dwJoinDirection);

    if (TmpSocket == INVALID_SOCKET) {

        TraceRetailWSAGetError(dwError);
                
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: WSAJoinLeaf failed: %u:%s/%u %u (0x%X)"),
                _fname,
                Socket, RtpNtoA(dwAddr, sAddr), ntohs(wPort),
                dwError, dwError
            ));

        bOk = FALSE;
    }
    else
    {
        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: WSAJoinLeaf: %u:%s/%u"),
                _fname,
                Socket, RtpNtoA(dwAddr, sAddr), ntohs(wPort)
            ));

        bOk = TRUE;
    }

    return(bOk);
}

void RtpSetSockOptions(RtpAddr_t *pRtpAddr)
{
    TraceFunctionName("RtpSetSockOptions");

    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_SOCKOPT))
    {
        TraceRetail((
                CLASS_WARNING, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: Socket options already set"),
                _fname
            ));
        
        return;
    }
    
    if (IS_MULTICAST(pRtpAddr->dwAddr[REMOTE_IDX]))
    {
        /* Set TTL  */
        if (!pRtpAddr->dwTTL[0])
        {
            pRtpAddr->dwTTL[0] = DEFAULT_MCAST_TTL;
        }
        if (!pRtpAddr->dwTTL[1])
        {
            pRtpAddr->dwTTL[1] = DEFAULT_MCAST_TTL;
        }

        RtpSetTTL(pRtpAddr->Socket[SOCK_SEND_IDX], pRtpAddr->dwTTL[0], TRUE);
        
        RtpSetTTL(pRtpAddr->Socket[SOCK_RTCP_IDX], pRtpAddr->dwTTL[1], TRUE);

        /* Set multicast sending interface */
        RtpSetMcastSendIF(pRtpAddr->Socket[SOCK_SEND_IDX],
                          pRtpAddr->dwAddr[LOCAL_IDX]);

        RtpSetMcastSendIF(pRtpAddr->Socket[SOCK_RTCP_IDX],
                          pRtpAddr->dwAddr[LOCAL_IDX]);
        
        /* Set Mcast loopback */
        RtpSetWinSockLoopback(pRtpAddr->Socket[SOCK_RECV_IDX],
                              RtpBitTest(pRtpAddr->dwAddrFlags,
                                         FGADDR_LOOPBACK_WS2));
        
        RtpSetWinSockLoopback(pRtpAddr->Socket[SOCK_RTCP_IDX],
                              RtpBitTest(pRtpAddr->dwAddrFlags,
                                         FGADDR_LOOPBACK_WS2));
        
        /* Join leaf */
        RtpJoinLeaf(pRtpAddr->Socket[SOCK_RECV_IDX],
                    pRtpAddr->dwAddr[REMOTE_IDX],
                    pRtpAddr->wRtpPort[REMOTE_IDX]);

        RtpJoinLeaf(pRtpAddr->Socket[SOCK_RTCP_IDX],
                    pRtpAddr->dwAddr[REMOTE_IDX],
                    pRtpAddr->wRtcpPort[REMOTE_IDX]);
    }
    else
    {
        /* Set TTL  */
        if (!pRtpAddr->dwTTL[0])
        {
            pRtpAddr->dwTTL[0] = DEFAULT_UCAST_TTL;
        }
        if (!pRtpAddr->dwTTL[1])
        {
            pRtpAddr->dwTTL[1] = DEFAULT_UCAST_TTL;
        }

        RtpSetTTL(pRtpAddr->Socket[SOCK_RECV_IDX], pRtpAddr->dwTTL[0], FALSE);

        RtpSetTTL(pRtpAddr->Socket[SOCK_RTCP_IDX], pRtpAddr->dwTTL[1], FALSE);
    }

    RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_SOCKOPT);
}

/* Sets the recv buffer size */
DWORD RtpSetRecvBuffSize(
        RtpAddr_t       *pRtpAddr,
        SOCKET           Socket,
        int              iBuffSize
    )
{
    DWORD            dwError;
    
    TraceFunctionName("RtpSetRecvBuffSize");
    
    /* Set buffer size */
    dwError = setsockopt(Socket,
                         SOL_SOCKET,
                         SO_RCVBUF,
                         (char *)&iBuffSize,
                         sizeof(iBuffSize));

    if (dwError)
    {
        TraceRetailWSAGetError(dwError);

        TraceRetail((
                CLASS_WARNING, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] setsockopt(%u, SO_RCVBUF, %d) ")
                _T("failed: %u (0x%X)"),
                _fname, pRtpAddr, Socket, iBuffSize, dwError, dwError
            ));

        return(RTPERR_WS2RECV);
    }

    TraceRetail((
            CLASS_INFO, GROUP_NETWORK, S_NETWORK_SOCK,
            _T("%s: pRtpAddr[0x%p] setsockopt(%u, SO_RCVBUF, %d)"),
            _fname, pRtpAddr, Socket, iBuffSize
        ));

    return(NOERROR);
}
        
/* Set the multicast loopback mode (e.g. RTPMCAST_LOOPBACKMODE_NONE,
 * RTPMCAST_LOOPBACKMODE_PARTIAL, etc) */
HRESULT RtpSetMcastLoopback(
        RtpAddr_t       *pRtpAddr,
        int              iMcastLoopbackMode,
        DWORD            dwFlags /* Not used now */
    )
{
    HRESULT          hr;

    TraceFunctionName("RtpSetMcastLoopback");

    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_INVALIDSTATE;

        goto end;
    }
    
    if (!iMcastLoopbackMode ||
        iMcastLoopbackMode >= RTPMCAST_LOOPBACKMODE_LAST)
    {
        hr = RTPERR_INVALIDARG;

        goto end;
    }

    hr = NOERROR;

    if (IsRegValueSet(g_RtpReg.dwMcastLoopbackMode) &&
        g_RtpReg.dwMcastLoopbackMode != (DWORD)iMcastLoopbackMode)
    {
        /* If I set multicast loopback mode in the registry, USE IT!  */

        TraceRetail((
                CLASS_WARNING, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: Multicast mode:%d ignored, using the registry:%d"),
                _fname, iMcastLoopbackMode, g_RtpReg.dwMcastLoopbackMode
            ));
        
        return(hr);
    }
    
    switch(iMcastLoopbackMode)
    {
    case RTPMCAST_LOOPBACKMODE_NONE:
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_WS2);
        RtpBitSet  (pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_SFT);
        RtpBitSet  (pRtpAddr->dwAddrFlags, FGADDR_COLLISION);
        break;
    case RTPMCAST_LOOPBACKMODE_PARTIAL:
        RtpBitSet  (pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_WS2);
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_SFT);
        RtpBitSet  (pRtpAddr->dwAddrFlags, FGADDR_COLLISION);
        break;
    case RTPMCAST_LOOPBACKMODE_FULL:
        RtpBitSet  (pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_WS2);
        RtpBitSet  (pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_SFT);
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_COLLISION);
        break;
    }

 end:
    if (SUCCEEDED(hr))
    {
        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: Multicast mode:%d"),
                _fname, iMcastLoopbackMode
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: settting mode %d failed: %u (0x%X)"),
                _fname, iMcastLoopbackMode, hr, hr
            ));
    }
    
    return(hr);
}

HRESULT RtpNetMute(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags
    )
{
    RtpSess_t       *pRtpSess;

    TraceFunctionName("RtpNetMute");

    pRtpSess = pRtpAddr->pRtpSess;
    
    if (dwFlags & pRtpAddr->dwAddrFlags & RtpBitPar(FGADDR_ISRECV))
    {
        /* Discard all RTP packets received from now on */
        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_MUTERTPRECV);
        
        /* Don't want more events */
        RtpBitReset(pRtpSess->dwSessFlags, FGSESS_EVENTRECV);

        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON))
        {
            /* Unreserve QOS */
            RtcpThreadCmd(&g_RtcpContext,
                          pRtpAddr,
                          RTCPTHRD_UNRESERVE,
                          RECV_IDX,
                          0);

            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON);
        }

        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] RECV muted"),
                _fname, pRtpAddr
            ));
    }

    if (dwFlags & pRtpAddr->dwAddrFlags & RtpBitPar(FGADDR_ISSEND))
    {
        /* Don't send any more RTP packets */
        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_MUTERTPSEND);
        
        /* Don't want more events */
        RtpBitReset(pRtpSess->dwSessFlags, FGSESS_EVENTSEND);

        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSSENDON))
        {
            /* Unreserve QOS (stop sending PATH messages) */
            RtcpThreadCmd(&g_RtcpContext,
                          pRtpAddr,
                          RTCPTHRD_UNRESERVE,
                          SEND_IDX,
                          DO_NOT_WAIT);

            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_QOSSENDON);
        }
        
        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] SEND muted"),
                _fname, pRtpAddr
            ));
    }

    return(NOERROR);
}

HRESULT RtpNetUnmute(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags
    )
{
    HRESULT          hr;
    RtpSess_t       *pRtpSess;
    
    TraceFunctionName("RtpNetUnmute");

    pRtpSess = pRtpAddr->pRtpSess;

    if (dwFlags & pRtpAddr->dwAddrFlags & RtpBitPar(FGADDR_ISRECV))
    {
        /* Reset counters */
        RtpResetNetCount(&pRtpAddr->RtpAddrCount[RECV_IDX],
                         &pRtpAddr->NetSCritSect);

        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSRECV) &&
            RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_RECVFSPEC_DEFINED) &&
            !RtpBitTest2(pRtpAddr->dwAddrFlagsQ,
                         FGADDRQ_REGQOSDISABLE, FGADDRQ_QOSNOTALLOWED))
        {
            /* NOTE: the test above is also done in RtpRealStart */
            
            /* Make a QOS reservation */
            hr = RtcpThreadCmd(&g_RtcpContext,
                               pRtpAddr,
                               RTCPTHRD_RESERVE,
                               RECV_IDX,
                               DO_NOT_WAIT);

            if (SUCCEEDED(hr))
            {
                RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON);
            }
        }

        /* Re-enable events (provided the mask has some events
         * enabled) */
        RtpBitSet(pRtpSess->dwSessFlags, FGSESS_EVENTRECV);

        /* Continue processing RTP packets received */
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_MUTERTPRECV);

        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] RECV unmuted"),
                _fname, pRtpAddr
            ));
    }

    if (dwFlags & pRtpAddr->dwAddrFlags & RtpBitPar(FGADDR_ISSEND))
    {
        /* Reset counters */
        RtpResetNetCount(&pRtpAddr->RtpAddrCount[SEND_IDX],
                         &pRtpAddr->NetSCritSect);

        /* Reset sender's network state */
        RtpResetNetSState(&pRtpAddr->RtpNetSState,
                          &pRtpAddr->NetSCritSect);
        
        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSSEND) &&
            RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_SENDFSPEC_DEFINED) &&
            !RtpBitTest2(pRtpAddr->dwAddrFlagsQ,
                         FGADDRQ_REGQOSDISABLE, FGADDRQ_QOSNOTALLOWED))
        {
            /* NOTE: the test above is also done in RtpRealStart */
            
            /* Make a QOS reservation */
            hr = RtcpThreadCmd(&g_RtcpContext,
                               pRtpAddr,
                               RTCPTHRD_RESERVE,
                               SEND_IDX,
                               DO_NOT_WAIT);
            
            if (SUCCEEDED(hr))
            {
                RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_QOSSENDON);
            }
        }

        /* Re-enable events (provided the mask has some events
         * enabled) */
        RtpBitSet(pRtpSess->dwSessFlags, FGSESS_EVENTSEND);

        /* Continue processing RTP packets received */
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_MUTERTPSEND);
        
        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] SEND unmuted"),
                _fname, pRtpAddr
            ));
    }

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpcrypt.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpcrypt.c
 *
 *  Abstract:
 *
 *    Implements the Cryptography family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "rtpglobs.h"

#include "rtpcrypt.h"

RtpCrypt_t *RtpCryptAlloc(
        RtpAddr_t       *pRtpAddr
    );

void RtpCryptFree(RtpCrypt_t *pRtpCrypt);

DWORD RtpSetEncryptionKey_(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt,
        TCHAR           *psPassPhrase,
        TCHAR           *psHashAlg,
        TCHAR           *psDataAlg
    );

ALG_ID RtpCryptAlgLookup(TCHAR *psAlgName);

TCHAR *RtpCryptAlgName(ALG_ID aiAlgId);

DWORD RtpTestCrypt(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt
    );

HRESULT ControlRtpCrypt(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

typedef struct _RtpAlgId_t {
    TCHAR           *AlgName;
    ALG_ID           aiAlgId;
} RtpAlgId_t;

#define INVALID_ALGID      ((ALG_ID)-1)

const RtpAlgId_t g_RtpAlgId[] = {
   { _T("Unknown"),            -1},
   { _T("MD2"),                CALG_MD2},
   { _T("MD4"),                CALG_MD4},
   { _T("MD5"),                CALG_MD5},
   { _T("SHA"),                CALG_SHA},
   { _T("SHA1"),               CALG_SHA1},
   { _T("MAC"),                CALG_MAC},
   { _T("RSA_SIGN"),           CALG_RSA_SIGN},
   { _T("DSS_SIGN"),           CALG_DSS_SIGN},
   { _T("RSA_KEYX"),           CALG_RSA_KEYX},
   { _T("DES"),                CALG_DES},
   { _T("3DES_112"),           CALG_3DES_112},
   { _T("3DES"),               CALG_3DES},
   { _T("DESX"),               CALG_DESX},
   { _T("RC2"),                CALG_RC2},
   { _T("RC4"),                CALG_RC4},
   { _T("SEAL"),               CALG_SEAL},
   { _T("DH_SF"),              CALG_DH_SF},
   { _T("DH_EPHEM"),           CALG_DH_EPHEM},
   { _T("AGREEDKEY_ANY"),      CALG_AGREEDKEY_ANY},
   { _T("KEA_KEYX"),           CALG_KEA_KEYX},
   { _T("HUGHES_MD5"),         CALG_HUGHES_MD5},
   { _T("SKIPJACK"),           CALG_SKIPJACK},
   { _T("TEK"),                CALG_TEK},
   { _T("CYLINK_MEK"),         CALG_CYLINK_MEK},
   { _T("SSL3_SHAMD5"),        CALG_SSL3_SHAMD5},
   { _T("SSL3_MASTER"),        CALG_SSL3_MASTER},
   { _T("SCHANNEL_MASTER_HASH"),CALG_SCHANNEL_MASTER_HASH},
   { _T("SCHANNEL_MAC_KEY"),   CALG_SCHANNEL_MAC_KEY},
   { _T("SCHANNEL_ENC_KEY"),   CALG_SCHANNEL_ENC_KEY},
   { _T("PCT1_MASTER"),        CALG_PCT1_MASTER},
   { _T("SSL2_MASTER"),        CALG_SSL2_MASTER},
   { _T("TLS1_MASTER"),        CALG_TLS1_MASTER},
   { _T("RC5"),                CALG_RC5},
   { _T("HMAC"),               CALG_HMAC},
   { _T("TLS1PRF"),            CALG_TLS1PRF},
   {NULL,                      0}
};

/* Creates and initializes a ready to use RtpCrypt_t structure */
RtpCrypt_t *RtpCryptAlloc(
        RtpAddr_t       *pRtpAddr
    )
{
    DWORD            dwError;
    RtpCrypt_t      *pRtpCrypt;

    TraceFunctionName("RtpCryptAlloc");

    pRtpCrypt = RtpHeapAlloc(g_pRtpCryptHeap, sizeof(RtpCrypt_t));

    if (!pRtpCrypt)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_ALLOC,
                _T("%s: pRtpAddr[0x%p] failed to allocate memory"),
                _fname, pRtpAddr
            ));

        goto bail;
    }

    ZeroMemory(pRtpCrypt, sizeof(RtpCrypt_t));
        
    pRtpCrypt->dwObjectID = OBJECTID_RTPCRYPT;

    pRtpCrypt->pRtpAddr = pRtpAddr;
    
    /* Set default provider type */
    pRtpCrypt->dwProviderType = PROV_RSA_FULL;

    /* Set default hashing algorithm */
    pRtpCrypt->aiHashAlgId = CALG_MD5;

    /* Set default data encryption algorithm */
    pRtpCrypt->aiDataAlgId = CALG_DES;

 bail:
    return(pRtpCrypt);
}

void RtpCryptFree(RtpCrypt_t *pRtpCrypt)
{
    long             lRefCount;
    
    TraceFunctionName("RtpCryptFree");

    if (!pRtpCrypt)
    {
        /* TODO may be log */
        return;
    }

    if (pRtpCrypt->dwObjectID != OBJECTID_RTPCRYPT)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_ALLOC,
                _T("%s: pRtpCrypt[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpCrypt,
                pRtpCrypt->dwObjectID, OBJECTID_RTPCRYPT
            ));

        return;
    }

    if (pRtpCrypt->lCryptRefCount != 0)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_ALLOC,
                _T("%s: pRtpCrypt[0x%p] Invalid RefCount:%d"),
                _fname, pRtpCrypt,
                pRtpCrypt->lCryptRefCount
            ));
    }
    
    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpCrypt->dwObjectID);
    
    /* Release when count reaches 0 */
    RtpHeapFree(g_pRtpCryptHeap, pRtpCrypt);

    TraceDebug((
            CLASS_INFO, GROUP_CRYPTO, S_CRYPTO_ALLOC,
            _T("%s: pRtpCrypt[0x%p] released"),
            _fname, pRtpCrypt
        ));
}

DWORD RtpCryptInit(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt
    )
{
    BOOL             bOk;
    DWORD            dwError;
    DWORD            dwFlags;
    long             lRefCount;

    TraceFunctionName("RtpCryptInit");

    dwFlags = 0;
    dwError = NOERROR;

    lRefCount = InterlockedIncrement(&pRtpCrypt->lCryptRefCount);

    if (lRefCount > 1)
    {
        /* Initialize only once */
        goto bail;
    }

    /* Verify a pass phrase has been set */
    if (!RtpBitTest(pRtpCrypt->dwCryptFlags, FGCRYPT_KEY))
    {
        dwError = RTPERR_INVALIDSTATE;
        
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("No pass phrase has been set"),
                _fname, pRtpAddr, pRtpCrypt
            ));

        goto bail;
    }
    
    /*
     * Acquire context
     * */
    do {
        bOk = CryptAcquireContext(
                &pRtpCrypt->hProv, /* HCRYPTPROV *phProv */
                NULL,              /* LPCTSTR pszContainer */
                NULL,              /* LPCTSTR pszProvider */
                pRtpCrypt->dwProviderType,/* DWORD dwProvType */
                dwFlags            /* DWORD dwFlags */
            );
        
        if (bOk)
        {
            break;
        }
        else
        {
            if (GetLastError() == NTE_BAD_KEYSET)
            {
                /* If key doesn't exist, create it */
                dwFlags = CRYPT_NEWKEYSET;
            }
            else
            {
                /* Failed */
                TraceRetailGetError(dwError);

                TraceRetail((
                        CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                        _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                        _T("CryptAcquireContext failed: %u (0x%X)"),
                        _fname, pRtpAddr, pRtpCrypt,
                        dwError, dwError
                    ));

                goto bail;
            }
        }
    } while(dwFlags);

    /*
     * Create hash
     * */

    /* Create a hash object */
    bOk = CryptCreateHash(
            pRtpCrypt->hProv,       /* HCRYPTPROV hProv */
            pRtpCrypt->aiHashAlgId, /* ALG_ID Algid */  
            0,                      /* HCRYPTKEY hKey */
            0,                      /* DWORD dwFlags */
            &pRtpCrypt->hHash       /* HCRYPTHASH *phHash */
        );

    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("CryptCreateHash failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));
        
        goto bail;
    }
    
    /*
     * Hash the password string *
     * */
    bOk = CryptHashData(
            pRtpCrypt->hHash,       /* HCRYPTHASH hHash */
            pRtpCrypt->psPassPhrase,/* BYTE *pbData */
            pRtpCrypt->iKeySize,    /* DWORD dwDataLen */
            0                       /* DWORD dwFlags */
        );
            
    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("CryptHashData failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));
        
        goto bail;
    }

    /*
     * Create data key
     * */

    bOk = CryptDeriveKey(
            pRtpCrypt->hProv,       /* HCRYPTPROV hProv */
            pRtpCrypt->aiDataAlgId, /* ALG_ID Algid */
            pRtpCrypt->hHash,       /* HCRYPTHASH hBaseData */
            CRYPT_EXPORTABLE,       /* DWORD dwFlags */
            &pRtpCrypt->hDataKey    /* HCRYPTKEY *phKey */
        );

    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("CryptDeriveKey failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));

        goto bail;
    }

    RtpBitSet(pRtpCrypt->dwCryptFlags, FGCRYPT_INIT);
    
 bail:
    if (dwError == NOERROR)
    {
        TraceDebug((
                CLASS_INFO, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("Cryptographic context initialized %d"),
                _fname, pRtpAddr, pRtpCrypt,
                lRefCount - 1
            ));
    }
    else
    {
        RtpCryptDel(pRtpAddr, pRtpCrypt);

        dwError = RTPERR_CRYPTO;
    }
    
    return(dwError);
}

DWORD RtpCryptDel(RtpAddr_t *pRtpAddr, RtpCrypt_t *pRtpCrypt)
{
    long             lRefCount;

    TraceFunctionName("RtpCryptDel");

    lRefCount = InterlockedDecrement(&pRtpCrypt->lCryptRefCount);

    if (lRefCount > 0)
    {
        /* If there are still references to this context, do not
         * de-initialize */
        goto bail;
    }
    
    RtpBitReset(pRtpCrypt->dwCryptFlags, FGCRYPT_INIT);
    
    /* Destroy the session key */
    if(pRtpCrypt->hDataKey)
    {
        CryptDestroyKey(pRtpCrypt->hDataKey);

        pRtpCrypt->hDataKey = 0;
    }

    /* Destroy the hash object */
    if (pRtpCrypt->hHash)
    {
        CryptDestroyHash(pRtpCrypt->hHash);

        pRtpCrypt->hHash = 0;
    }
    
    /* Release the provider handle */
    if(pRtpCrypt->hProv)
    {
        CryptReleaseContext(pRtpCrypt->hProv, 0);

        pRtpCrypt->hProv = 0;
    }

 bail:
    TraceDebug((
            CLASS_INFO, GROUP_CRYPTO, S_CRYPTO_INIT,
            _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
            _T("Cryptographic context de-initialized %d"),
            _fname, pRtpAddr, pRtpCrypt,
            lRefCount
        ));
    
   return(NOERROR);
}

/* This function copies all the buffers into 1 before encrypting on
 * the same memory, I don't want to modify the original data as it
 * might be used somewhere else */
DWORD RtpEncrypt(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt,
        WSABUF          *pWSABuf,
        DWORD            dwWSABufCount,
        char            *pCryptBuffer,
        DWORD            dwCryptBufferLen
    )
{
    BOOL             bOk;
    DWORD            dwError;
    WSABUF          *pWSABuf0;
    DWORD            i;
    char            *ptr;
    DWORD            dwBufLen;
    DWORD            dwDataLen;

    TraceFunctionName("RtpEncrypt");

    dwError = RTPERR_OVERRUN;

    pWSABuf0 = pWSABuf;
    ptr = pCryptBuffer;
    dwBufLen = dwCryptBufferLen;

    for(; dwWSABufCount > 0; dwWSABufCount--)
    {
        if (pWSABuf->len > dwBufLen)
        {
            break;
        }
        
        CopyMemory(ptr, pWSABuf->buf, pWSABuf->len);

        ptr += pWSABuf->len;
        dwBufLen -= pWSABuf->len;
        pWSABuf++;
    }

    if (!dwWSABufCount)
    {
        dwError = NOERROR;
    
        dwDataLen = (DWORD) (ptr - pCryptBuffer);

        /* As build 2195 CryptEncrypt AVs with a key=0 */
#if 1
        bOk = CryptEncrypt(
                pRtpCrypt->hDataKey,           /* HCRYPTKEY hKey */
                0,                             /* HCRYPTHASH hHash */
                TRUE,                          /* BOOL Final */
                0,                             /* DWORD dwFlags */
                (BYTE *)pCryptBuffer,          /* BYTE *pbData */
                &dwDataLen,                    /* DWORD *pdwDataLen */
                dwCryptBufferLen               /* DWORD dwBufLen */
            );
#else
        dwDataLen += 31;
        bOk = TRUE;
#endif
        if (bOk)
        {
            pWSABuf0->buf = pCryptBuffer;
            pWSABuf0->len = dwDataLen;
        }
        else
        {
            TraceRetailGetError(dwError);
            
            pRtpCrypt->dwCryptLastError = dwError;

            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_ENCRYPT,
                    _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                    _T("Encryption failed: %u (0x%X)"),
                    _fname, pRtpAddr, pRtpCrypt,
                    dwError, dwError
                ));

            dwError = RTPERR_ENCRYPT;
        }
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_ENCRYPT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("Overrun error: %u > %u"),
                _fname, pRtpAddr, pRtpCrypt,
                pWSABuf->len, dwBufLen
            ));
    }

    return(dwError);
}

/* Decrypt data on same buffer, decrypted buffer will be shorter or
 * equal the encrypted one */
DWORD RtpDecrypt(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt,
        char            *pEncryptedData,
        DWORD           *pdwEncryptedDataLen
    )
{
    DWORD            dwError;
    BOOL             bOk;

    TraceFunctionName("RtpDecrypt");

    dwError = NOERROR;
#if 1
    bOk = CryptDecrypt(
            pRtpCrypt->hDataKey,   /* HCRYPTKEY hKey */
            0,                     /* HCRYPTHASH hHash */
            TRUE,                  /* BOOL Final */
            0,                     /* DWORD dwFlags */
            (BYTE *)pEncryptedData,/* BYTE *pbData */
            pdwEncryptedDataLen    /* DWORD *pdwDataLen */
        );
#else
    *pdwEncryptedDataLen -= 31;
    bOk = TRUE;
#endif
    if (!bOk)
    {
        TraceRetailGetError(dwError);

        pRtpCrypt->dwCryptLastError = dwError;
  
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_DECRYPT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("Decryption failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));

        dwError = RTPERR_DECRYPT;
    }

    return(dwError);
}

DWORD RtpCryptSetup(RtpAddr_t *pRtpAddr)
{
    DWORD            dwError;
    DWORD            last;
    DWORD            i;
    int              iMode;
    RtpCrypt_t      *pRtpCrypt;
    
    TraceFunctionName("RtpCryptSetup");

    dwError = NOERROR;

    iMode = pRtpAddr->dwCryptMode & 0xffff;
    
        
    if (iMode < RTPCRYPTMODE_ALL)
    {
        /* Create contexts for RECV and SEND */
        last = CRYPT_SEND_IDX;
    }
    else
    {
        /* Create contexts for RECV, SEND and RTCP */
        last = CRYPT_RTCP_IDX;
    }

    /* Create as many cryptographic contexts as requested */
    for(i = CRYPT_RECV_IDX; i <= last; i++)
    {
        pRtpCrypt = RtpCryptAlloc(pRtpAddr);

        if (!pRtpCrypt)
        {
            TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] failed"),
                _fname, pRtpAddr
            ));

            dwError = RTPERR_MEMORY;
            
            goto bail;
        }

        pRtpAddr->pRtpCrypt[i] = pRtpCrypt;
    }

    /* Allocate memory for encryption buffers */

    for(i = 0; i < 2; i++)
    {
        if (!i || (iMode == RTPCRYPTMODE_ALL))
        {
            pRtpAddr->CryptBuffer[i] =
                RtpHeapAlloc(g_pRtpCryptHeap, RTCP_SENDDATA_BUFFER);

            if (!pRtpAddr->CryptBuffer[i])
            {
                dwError = RTPERR_MEMORY;
                goto bail;
            }

            pRtpAddr->dwCryptBufferLen[i] = RTCP_SENDDATA_BUFFER;
        }
    }

    return(dwError);

 bail:
    for(i = CRYPT_RECV_IDX; i <= last; i++)
    {
        if (pRtpAddr->pRtpCrypt[i])
        {
            RtpCryptFree(pRtpAddr->pRtpCrypt[i]);
            pRtpAddr->pRtpCrypt[i] = NULL;
        }
    }
    
    for(i = 0; i < 2; i++)
    {
        if (pRtpAddr->CryptBuffer[i])
        {
            RtpHeapFree(g_pRtpCryptHeap, pRtpAddr->CryptBuffer[i]);
        }

        pRtpAddr->CryptBuffer[i] = NULL;
        pRtpAddr->dwCryptBufferLen[i] = 0;
    }
    
    return(dwError);
}

/* Release all memory */
DWORD RtpCryptCleanup(RtpAddr_t *pRtpAddr)
{
    DWORD            i;
    RtpCrypt_t      *pRtpCrypt;
    
    TraceFunctionName("RtpCryptCleanup");

    for(i = 0; i <= CRYPT_RTCP_IDX; i++)
    {
        pRtpCrypt = pRtpAddr->pRtpCrypt[i];

        if (pRtpCrypt)
        {
            RtpCryptFree(pRtpCrypt);

            pRtpAddr->pRtpCrypt[i] = NULL;
        }
    }

    for(i = 0; i < 2; i++)
    {
        if (pRtpAddr->CryptBuffer[i])
        {
            RtpHeapFree(g_pRtpCryptHeap, pRtpAddr->CryptBuffer[i]);

            pRtpAddr->CryptBuffer[i] = NULL;
        }

        pRtpAddr->dwCryptBufferLen[i] = 0;
    }
    
    return(NOERROR);
}

/* iMode defines what is going to be encrypted/decrypted,
 * e.g. RTPCRYPTMODE_PAYLOAD to encrypt/decrypt only RTP
 * payload. dwFlag can be RTPCRYPT_SAMEKEY to indicate that (if
 * applicable) the key used for RTCP is the same used for RTP */
DWORD RtpSetEncryptionMode(
        RtpAddr_t       *pRtpAddr,
        int              iMode,
        DWORD            dwFlags
    )
{
    DWORD            dwError;
    
    TraceFunctionName("RtpSetEncryptionMode");

    dwError = NOERROR;
    
    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        dwError = RTPERR_INVALIDSTATE;

        goto bail;
    }
    
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        dwError = RTPERR_INVALIDRTPADDR;
        goto bail;
    }

    if (iMode && (iMode > RTPCRYPTMODE_ALL))
    {
        dwError = RTPERR_INVALIDARG;

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid mode:0x%X"),
                _fname, pRtpAddr,
                iMode
            ));
        
        goto bail;
    }

    if ((dwFlags & 0xffff0000) != dwFlags)
    {
        dwError = RTPERR_INVALIDARG;
        
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid flags:0x%X"),
                _fname, pRtpAddr,
                dwFlags
            ));
        
        goto bail;
    }
        
    iMode |= dwFlags;
    
    /* If mode already set, verify the mode set is the default (0) or
     * the same */
    if (pRtpAddr->dwCryptMode)
    {
        if (!iMode || ((DWORD)iMode == pRtpAddr->dwCryptMode))
        {
            /* Same mode, do nothing */

            goto bail;
        }
        else
        {
            /* Once the mode is set, it can not be changed */

            dwError = RTPERR_INVALIDSTATE;

            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                    _T("%s: pRtpAddr[0x%p] mode already set 0x%X != 0x%X"),
                    _fname, pRtpAddr,
                    pRtpAddr->dwCryptMode, iMode
                ));
            
            goto bail;
        }
    }

    /* Mode hasn't been set, set it and create cryptographic
     * context(s) */

    if (!iMode)
    {
        /* Set default mode */
        iMode = RTPCRYPTMODE_ALL;
        iMode |= RtpBitPar(RTPCRYPTFG_SAMEKEY);
    }

    pRtpAddr->dwCryptMode = (DWORD)iMode;

    TraceDebug((
            CLASS_INFO, GROUP_CRYPTO, S_CRYPTO_INIT,
            _T("%s: pRtpAddr[0x%p] Encryption mode set: 0x%X"),
            _fname, pRtpAddr,
            iMode
        ));

    /* Note that Setup is called from a method available to the user,
     * but Cleanup is called when the RtpAddr object is been clened up
     * */
    dwError = RtpCryptSetup(pRtpAddr);

 bail:
    if (dwError != NOERROR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] ")
                _T("mode:0x%X flags:0x%X failed: %u (0x%X)"),
                _fname, pRtpAddr,
                iMode, dwFlags, dwError, dwError
            ));
    }
    
    return(dwError);
}

DWORD RtpSetEncryptionKey(
        RtpAddr_t       *pRtpAddr,
        TCHAR           *psPassPhrase,
        TCHAR           *psHashAlg,
        TCHAR           *psDataAlg,
        DWORD            dwIndex
    )
{
    DWORD            dwError;
    DWORD            i;
    RtpCrypt_t      *pRtpCrypt;
    RtpCrypt_t      *pRtpCryptTest;
    
    TraceFunctionName("RtpSetEncryptionKey");

    dwError = NOERROR;

    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        dwError = RTPERR_INVALIDSTATE;

        goto bail;
    }
    
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        dwError = RTPERR_INVALIDRTPADDR;
        goto bail;
    }

    if (dwIndex > CRYPT_RTCP_IDX)
    {
        dwError = RTPERR_INVALIDARG;

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid channel %s"),
                _fname, pRtpAddr,
                dwIndex
            ));
        
        goto bail;
    }

    pRtpCrypt = pRtpAddr->pRtpCrypt[dwIndex];

    if (!pRtpCrypt)
    {
        dwError = RTPERR_INVALIDSTATE;
        
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] Mode 0x%X doesn't support channel %s"),
                _fname, pRtpAddr,
                pRtpAddr->dwCryptMode, g_psSockIdx[dwIndex]
            ));

        goto bail;
    }
    
    pRtpCryptTest = NULL;
    
    dwError = NOERROR;
    
    if (RtpBitTest(pRtpAddr->dwCryptMode, RTPCRYPTFG_SAMEKEY))
    {
        for(i = CRYPT_RECV_IDX; i <= CRYPT_RTCP_IDX; i++)
        {
            pRtpCrypt = pRtpAddr->pRtpCrypt[i];
            
            if (pRtpCrypt)
            {
                dwError = RtpSetEncryptionKey_(pRtpAddr,
                                               pRtpCrypt,
                                               psPassPhrase,
                                               psHashAlg,
                                               psDataAlg);

                if (dwError != NOERROR)
                {
                    break;
                }

                if (!pRtpCryptTest)
                {
                    /* Will test on first crypto context */
                    pRtpCryptTest = pRtpCrypt; 
                }
            }
        }
    }
    else
    {
        pRtpCryptTest = pRtpCrypt;
        
        dwError = RtpSetEncryptionKey_(pRtpAddr,
                                       pRtpCrypt,
                                       psPassPhrase,
                                       psHashAlg,
                                       psDataAlg);
    }

 bail:
    if (dwError == NOERROR)
    {
        /* So far no error, test current parameters */
        dwError = RtpTestCrypt(pRtpAddr, pRtpCryptTest);
    }
    
    return(dwError);
}    

DWORD RtpSetEncryptionKey_(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt,
        TCHAR           *psPassPhrase,
        TCHAR           *psHashAlg,
        TCHAR           *psDataAlg
    )
{
    DWORD            dwError;
    DWORD            len;
    ALG_ID           aiAlgId;

    TraceFunctionName("RtpSetEncryptionKey_");

    if (!psPassPhrase && !psHashAlg && !psDataAlg)
    {
        return(RTPERR_POINTER);
    }
    
    dwError = NOERROR;
    
    if (psPassPhrase)
    {
        len = lstrlen(psPassPhrase);

        if (len == 0)
        {
            dwError = RTPERR_INVALIDARG;
            
            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                    _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                    _T("Invalid pass phrase length: %u"),
                    _fname, pRtpAddr, pRtpCrypt,
                    len
                ));

            goto bail;
        }
        else if (len > (sizeof(pRtpCrypt->psPassPhrase) - 1))
        {
            dwError = RTPERR_INVALIDARG;
            
            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                    _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                    _T("Pass phrase too long: %u > %u"),
                    _fname, pRtpAddr, pRtpCrypt,
                    len,
                    sizeof(pRtpCrypt->psPassPhrase) - 1
                ));

            goto bail;
        }
        else
        {
#if defined(UNICODE)
            /* Convert UNICODE to UTF-8 */
            len = WideCharToMultiByte(
                    CP_UTF8, /* UINT code page */
                    0,       /* DWORD performance and mapping flags */
                    psPassPhrase,/*LPCWSTR address of wide-character string */
                    -1,      /* int number of characters in string */
                    pRtpCrypt->psPassPhrase,
                    /* LPSTR address of buffer for new string */
                    sizeof(pRtpCrypt->psPassPhrase),
                    /* int size of buffer */
                    NULL,    /* LPCSTR lpDefaultChar */
                    NULL     /* LPBOOL lpUsedDefaultChar */
                );
            
            if (len > 0)
            {
                /* Remove from the phrase's length the null
                 * terminating character */
                len--;
            }
            else
            {
                TraceRetailGetError(dwError);
                
                TraceRetail((
                        CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                        _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                        _T("WideCharToMultiByte failed: %u (0x%X)"),
                        _fname, pRtpAddr, pRtpCrypt,
                        dwError, dwError
                    ));

                goto bail;
            }
#else
            /* Copy pass phrase */
            strcpy(pRtpCrypt->sPassPhrase, psPassPhrase);
#endif
            if (len > 0)
            {
                pRtpCrypt->iKeySize = len;
            
                RtpBitSet(pRtpCrypt->dwCryptFlags, FGCRYPT_KEY);
            }
        }
    }

    /* Set the hashing algorithm */
    if (psHashAlg)
    {
        aiAlgId = RtpCryptAlgLookup(psHashAlg);

        if (aiAlgId == INVALID_ALGID)
        {
            dwError = RTPERR_INVALIDARG;
            
            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                    _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                    _T("Invalid hashing algorithm:%s"),
                    _fname, pRtpAddr, pRtpCrypt,
                    psHashAlg
                ));

            goto bail;
        }

        pRtpCrypt->aiHashAlgId = aiAlgId;
    }
    
    /* Set the data encryption algorithm */
    if (psDataAlg)
    {
        aiAlgId = RtpCryptAlgLookup(psDataAlg);

        if (aiAlgId == INVALID_ALGID)
        {
            dwError = RTPERR_INVALIDARG;
            
            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                    _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                    _T("Invalid data algorithm:%s"),
                    _fname, pRtpAddr, pRtpCrypt,
                    psDataAlg
                ));

            goto bail;
        }

        pRtpCrypt->aiDataAlgId = aiAlgId;
    }

    TraceRetail((
            CLASS_INFO, GROUP_CRYPTO, S_CRYPTO_INIT,
            _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
            _T("Hash:%s Data:%s Key:{%u chars} succeeded"),
            _fname, pRtpAddr, pRtpCrypt,
            RtpCryptAlgName(pRtpCrypt->aiHashAlgId),
            RtpCryptAlgName(pRtpCrypt->aiDataAlgId),
            len
        ));

 bail:
    return(dwError);
}

ALG_ID RtpCryptAlgLookup(TCHAR *psAlgName)
{
    DWORD            i;
    ALG_ID           aiAlgId;

    for(i = 0;
        g_RtpAlgId[i].AlgName && lstrcmp(g_RtpAlgId[i].AlgName, psAlgName);
        i++);
    
    if (g_RtpAlgId[i].AlgName)
    {
        aiAlgId = g_RtpAlgId[i].aiAlgId;
    }
    else
    {
        aiAlgId = INVALID_ALGID;
    }
    
    return(aiAlgId);
}

TCHAR *RtpCryptAlgName(ALG_ID aiAlgId)
{
    DWORD            i;
    TCHAR           *psAlgName;

    psAlgName = g_RtpAlgId[0].AlgName;;
    
    for(i = 0;
        g_RtpAlgId[i].AlgName && (g_RtpAlgId[i].aiAlgId != aiAlgId);
        i++);
    
    if (g_RtpAlgId[i].AlgName)
    {
        psAlgName = g_RtpAlgId[i].AlgName;
    }

    return(psAlgName);
}

/* This function tests if cryptography will succeed for the current
 * parameters set so far, it will be called every time
 * RtpSetEncryptionKey is called to validate those parameters,
 * otherwise an error would be detected only later when RTP starts
 * streaming */
DWORD RtpTestCrypt(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt
    )
{
    BOOL             bOk;
    DWORD            dwError;
    DWORD            dwFlags;

    HCRYPTPROV       hProv;           /* Cryptographic Service Provider */
    HCRYPTHASH       hHash;           /* Hash handle */
    HCRYPTKEY        hDataKey;        /* Cryptographic key */ 

    TraceFunctionName("RtpTestCrypt");

    dwFlags  = 0;
    dwError  = NOERROR;
    hProv    = 0;
    hHash    = 0;
    hDataKey = 0;

    RTPASSERT(pRtpCrypt);
    
    /* Verify a pass phrase has been set */
    if (!RtpBitTest(pRtpCrypt->dwCryptFlags, FGCRYPT_KEY))
    {
        dwError = RTPERR_INVALIDSTATE;
        
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("No pass phrase has been set"),
                _fname, pRtpAddr, pRtpCrypt
            ));

        goto bail;
    }

    /*
     * Acquire context
     * */
    do {
        bOk = CryptAcquireContext(
                &hProv,            /* HCRYPTPROV *phProv */
                NULL,              /* LPCTSTR pszContainer */
                NULL,              /* LPCTSTR pszProvider */
                pRtpCrypt->dwProviderType,/* DWORD dwProvType */
                dwFlags            /* DWORD dwFlags */
            );
        
        if (bOk)
        {
            break;
        }
        else
        {
            if (GetLastError() == NTE_BAD_KEYSET)
            {
                /* If key doesn't exist, create it */
                dwFlags = CRYPT_NEWKEYSET;
            }
            else
            {
                /* Failed */
                TraceRetailGetError(dwError);

                TraceRetail((
                        CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                        _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                        _T("CryptAcquireContext failed: %u (0x%X)"),
                        _fname, pRtpAddr, pRtpCrypt,
                        dwError, dwError
                    ));

                goto bail;
            }
        }
    } while(dwFlags);

    /*
     * Create hash
     * */

    /* Create a hash object */
    bOk = CryptCreateHash(
            hProv,                  /* HCRYPTPROV hProv */
            pRtpCrypt->aiHashAlgId, /* ALG_ID Algid */  
            0,                      /* HCRYPTKEY hKey */
            0,                      /* DWORD dwFlags */
            &hHash                  /* HCRYPTHASH *phHash */
        );

    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("CryptCreateHash failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));
        
        goto bail;
    }
    
    /*
     * Hash the password string *
     * */
    bOk = CryptHashData(
            hHash,                  /* HCRYPTHASH hHash */
            pRtpCrypt->psPassPhrase,/* BYTE *pbData */
            pRtpCrypt->iKeySize,    /* DWORD dwDataLen */
            0                       /* DWORD dwFlags */
        );
            
    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("CryptHashData failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));
        
        goto bail;
    }

    /*
     * Create data key
     * */

    bOk = CryptDeriveKey(
            hProv,                  /* HCRYPTPROV hProv */
            pRtpCrypt->aiDataAlgId, /* ALG_ID Algid */
            hHash,                  /* HCRYPTHASH hBaseData */
            CRYPT_EXPORTABLE,       /* DWORD dwFlags */
            &hDataKey               /* HCRYPTKEY *phKey */
        );

    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("CryptDeriveKey failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));

        goto bail;
    }

 bail:
    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_INFO, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("Cryptographic test passed"),
                _fname, pRtpAddr, pRtpCrypt
            ));
    }
    else
    {
        dwError = RTPERR_CRYPTO;
    }
    
    /* Destroy the session key */
    if(hDataKey)
    {
        CryptDestroyKey(hDataKey);
    }

    /* Destroy the hash object */
    if (hHash)
    {
        CryptDestroyHash(hHash);
    }
    
    /* Release the provider handle */
    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpdejit.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpdejit.c
 *
 *  Abstract:
 *
 *    Compute delay, jitter and playout delay
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/12/03 created
 *
 **********************************************************************/

#include "rtpglobs.h"
#include "rtpreg.h"

#include "rtpdejit.h"

BOOL RtpDetectTalkspurt(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpHdr_t        *pRtpHdr,
        double           dTime
    );

double RtpPlayout(RtpAddr_t *pRtpAddr, RtpUser_t *pRtpUser);

double           g_dMinPlayout = MIN_PLAYOUT / 1000.0;
double           g_dMaxPlayout = MAX_PLAYOUT / 1000.0;

/*
 * Ai = Arrival time for packet i
 * Ti = Transmit time for packet i
 * Ni = Delay (transit time) for packet i, Ni = Ai - Ti
 * ti = time stamp for packet i 
 * NTP_sr = converted NTP time correponding to t_sr, sent in last SR report
 * t_sr = RTP timestamp matching NTP time sent in last SR report
 * */
 
DWORD RtpUpdateNetRState(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpHdr_t        *pRtpHdr,
        RtpRecvIO_t     *pRtpRecvIO
    )
{
    BOOL             bOk;
    BOOL             bNewTalkSpurt;
    DWORD            ti;      /* RTP timestamp */
    double           Ai;      /* Arrival time (s) */
    double           Ti;      /* Transmit time (s) */
    double           Ni;      /* Delay (s) */
    double           dDiff;
    DWORD            dwDelta;
    long             lTransit;
    RtpNetRState_t  *pRtpNetRState;

    TraceFunctionName("RtpUpdateNetRState");

    Ai = pRtpRecvIO->dRtpRecvTime;
    
    /*
     * Update variables needed to compute the playout delay
     */
    
    pRtpNetRState = &pRtpUser->RtpNetRState;

    bOk = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

    /* Don't want to get inconsistent values if a SR report arrives
     * and these variables are being modified */

    if (bOk == FALSE)
    {
        return(RTPERR_CRITSECT);
    }

    if (!pRtpNetRState->dwRecvSamplingFreq)
    {
        /* Can not update these statistical variables if I don't know
         * the sampling frequency */
        RtpLeaveCriticalSection(&pRtpUser->UserCritSect);

        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("No sampling frequency, skip jitter stats"),
                _fname, pRtpAddr, pRtpUser
            ));
       
        return(NOERROR);
    }

    /* This sample RTP timestamp */
    ti = ntohl(pRtpHdr->ts);

    /* Obtain transmit time at source (using source's time) */
    Ti = pRtpNetRState->dNTP_ts0 +
        ((double)ti / pRtpNetRState->dwRecvSamplingFreq);

    /* Compute delay */
    pRtpNetRState->Ni = Ai - Ti;

    /* Process the initial delay average for first N packets if needed */
    if (pRtpNetRState->lDiMax)
    {
        pRtpNetRState->lDiCount++;

        pRtpNetRState->dDiN += pRtpNetRState->Ni;
        
        if (pRtpNetRState->lDiCount >= pRtpNetRState->lDiMax)
        {
            TraceDebugAdvanced((
                    0, GROUP_RTP, S_RTP_PLAYOUT,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                    _T("Begin resyncing: Ni:%0.3f Di:%0.3f Vi:%0.3f ")
                    _T("sum(Ni)/%u:%0.3f"),
                    _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                    pRtpNetRState->Ni, pRtpNetRState->Di, pRtpNetRState->Vi,
                    pRtpNetRState->lDiCount,
                    pRtpNetRState->dDiN / pRtpNetRState->lDiCount
                ));
            
            RtpInitNetRState(pRtpUser, pRtpHdr, Ai);

            TraceDebugAdvanced((
                    0, GROUP_RTP, S_RTP_PLAYOUT,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                    _T("Done  resyncing: Ni:%0.3f Di:%0.3f Vi:%0.3f"),
                    _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                    pRtpNetRState->Ni, pRtpNetRState->Di, pRtpNetRState->Vi
                ));

            /* Allow the big delay detection to happen again if we had
             * been consistently with a big delay. I adjust once when
             * the big delay count is reached, but not with next
             * packets with big delay. If big delay persists, then the
             * only way to attempt another resync is by reseting to 0
             * this counter */
            pRtpNetRState->lBigDelay = 0;
        }
    }

    if (pRtpNetRState->Ni > 7200.0)
    {
        /* The RTP timestamp just had a wrap around or was reset */
        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("RTP timestamp just wrap around Ni:%0.3f ts:%u"),
                _fname, pRtpAddr, pRtpUser, pRtpNetRState->Ni, ti
            ));

        /* Resync Ni and Di to the relative delay */
        RtpOnFirstPacket(pRtpUser, pRtpHdr, Ai);

        /* Update hypothetical transmit time */
        Ti = pRtpNetRState->dNTP_ts0 +
            ((double)ti / pRtpNetRState->dwRecvSamplingFreq);

        /* Ni should be the relative delay */
        pRtpNetRState->Ni = RELATIVE_DELAY;
    }
    
    /* Compute average delay */
    pRtpNetRState->Di = pRtpAddr->dAlpha * pRtpNetRState->Di +
        (1.0 - pRtpAddr->dAlpha) * pRtpNetRState->Ni;

    /* Compute standard deviation */
    dDiff = pRtpNetRState->Di - pRtpNetRState->Ni;
    
    if (dDiff < 0)
    {
        dDiff = -dDiff;
    }

    /*
     * TOIMPROVE The algorithm used here to compute delay and
     * variance, DO NOT follow well sudden big changes in the delay
     * (those changes can occur when a machine adjusts its local time
     * by a big step). In order to adjust to those changes, I need a
     * mechanism that detect those step changes but still filters
     * random spikes */
    /* TODO this is a temporary solution to detect the jumps in the
     * delay and quickly converge the average delay to that new
     * delay. It is not that this mechanism is a bad solution but is a
     * specialized solution to deal with a specific case, the
     * improvement I'm refering to above, is a more generalized
     * algorithm that would protect against this and other anomalies
     * */
    if (dDiff > (g_dMaxPlayout / 4 ))
    {
        pRtpNetRState->lBigDelay++;

        if (pRtpNetRState->lBigDelay == 1)
        {
            /* First time the big delay is detected, save the current
             * delay variance so it can be restored later if this
             * happens to be a delay jump */
            if (!pRtpNetRState->ViPrev ||
                pRtpNetRState->Vi < pRtpNetRState->ViPrev)
            {
                pRtpNetRState->ViPrev = pRtpNetRState->Vi;
            }
        }
        else if ((pRtpNetRState->lBigDelay == SHORTDELAYCOUNT))
        {
            /* Mean delay and current delay are too far apart, start
             * the resync process. */
            /* NOTE that resyncing for big delay jumps happens after
             * twice SHORTDELAYCOUNT, once to validate the big jump,
             * second to resync to the short average */
            RtpPrepareForShortDelay(pRtpUser, SHORTDELAYCOUNT);
        }
    }
    else
    {
        pRtpNetRState->lBigDelay = 0; 
    }
    
    /* Compute delay variance */
    pRtpNetRState->Vi = pRtpAddr->dAlpha * pRtpNetRState->Vi +
        (1.0 - pRtpAddr->dAlpha) * dDiff;

    if (!(ntohs(pRtpHdr->seq) & 0x7))
    {
        TraceDebugAdvanced((
                0, GROUP_RTP, S_RTP_PERPKTSTAT1,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("Ai:%0.3f Ti:%0.3f ti:%u Ni:%0.3f Di:%0.3f Vi:%0.3f "),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                Ai, Ti, ti,
                pRtpNetRState->Ni, pRtpNetRState->Di, pRtpNetRState->Vi
            ));
    }

    if (pRtpNetRState->Ni > 5.0 || pRtpNetRState->Ni < -5.0)
    {
        TraceDebugAdvanced((
                0, GROUP_RTP, S_RTP_PERPKTSTAT2,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("Ai:%0.3f Ti:%0.3f ti:%u Ni:%0.3f Di:%0.3f Vi:%0.3f "),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                Ai, Ti, ti,
                pRtpNetRState->Ni, pRtpNetRState->Di, pRtpNetRState->Vi
            ));
    }

    /*
     * Compute playout delay if we have a new talkspurt and playout
     * delay use is enabled
     */
    if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_USEPLAYOUT))
    {
        bNewTalkSpurt = RtpDetectTalkspurt(pRtpAddr, pRtpUser, pRtpHdr, Ai);

        /* MARKER flag might need to be set to a different value than
         * it had when the packet was received */
        if (bNewTalkSpurt)
        {
            pRtpNetRState->dPlayout = RtpPlayout(pRtpAddr, pRtpUser);
            pRtpNetRState->dwBeginTalkspurtTs = ti;
            pRtpNetRState->dBeginTalkspurtTime = Ai;

            pRtpRecvIO->dPlayTime = pRtpNetRState->dPlayout;
            RtpBitSet(pRtpRecvIO->dwRtpIOFlags, FGRECV_MARKER);

            /* On each new talkspurt update reference time used to
             * compute playout delay (delay, variance). This variables
             * will be needed only on the next talkspurt */
            RtpPrepareForShortDelay(pRtpUser, SHORTDELAYCOUNT);
        }
        else
        {
            dwDelta = ti - pRtpNetRState->dwBeginTalkspurtTs;
            
            pRtpRecvIO->dPlayTime = pRtpNetRState->dPlayout +
                ((double)dwDelta / pRtpNetRState->dwRecvSamplingFreq);
            RtpBitReset(pRtpRecvIO->dwRtpIOFlags, FGRECV_MARKER);
        }

        /* This TraceDebug useful only to debug problems */
        /* Ai seq  size ts Ni  Di  Vi  Jit Playtime marker sampling_freq */
        TraceDebugAdvanced((
                0, GROUP_RTP, S_RTP_PERPKTSTAT3,
                _T("%s: pRtpUser[0x%p] SSRC:0x%X ")
                _T("@ %0.3f %u 0 %u %0.3f %0.3f %0.3f %0.3f %0.3f %u %u"),
                _fname, pRtpUser, ntohl(pRtpUser->dwSSRC),
                Ai, pRtpRecvIO->dwExtSeq, ti, pRtpNetRState->Ni,
                pRtpNetRState->Di, pRtpNetRState->Vi,
                (double)pRtpNetRState->jitter/
                pRtpNetRState->dwRecvSamplingFreq,
                pRtpRecvIO->dPlayTime,
                bNewTalkSpurt,
                pRtpNetRState->dwRecvSamplingFreq/1000
            ));
    }
    
    /*
     * Compute jitter to be used in RR reports
     */

    /* The transit time may be negative */
    lTransit = (long) (pRtpNetRState->Ni * pRtpNetRState->dwRecvSamplingFreq);

    /* Current delay difference (i.e. packet i and packet i-1) */
    if (!pRtpNetRState->transit)
    {
        /* Initialize previous transit time to be equal to current */
        pRtpNetRState->transit = lTransit;
    }

    /* Conversion: (double) (DW1 - DW2) gives a wrong big positive
     * number if DW2 > DW1 */
    if (lTransit >= pRtpNetRState->transit)
    {
        dDiff = lTransit - pRtpNetRState->transit;
    }
    else
    {
        dDiff = pRtpNetRState->transit - lTransit;
    }
    
    pRtpNetRState->transit = lTransit;
    
    pRtpNetRState->jitter +=
        (int) ((1.0/16.0) * (dDiff - pRtpNetRState->jitter));

    /* This TraceDebug useful only to debug problems */
    TraceDebugAdvanced((
            0, GROUP_RTP, S_RTP_PERPKTSTAT4,
            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
            _T("Ai:%0.3f ti:%u transit:%d diff:%0.0f ")
            _T("jitter:%u (%0.3f)"),
            _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
            Ai, ti, lTransit, dDiff,
            pRtpNetRState->jitter,
            (double)pRtpNetRState->jitter/
            pRtpNetRState->dwRecvSamplingFreq
        ));
    
    RtpLeaveCriticalSection(&pRtpUser->UserCritSect);
    
    return(NOERROR);
}

/* This is done once per RtpUser_t, and the structure is initially
 * zeroed */
void RtpInitNetRState(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr, double Ai)
{
    RtpNetRState_t  *pRtpNetRState;
    DWORD            dwRecvSamplingFreq;
    DWORD            ts;

    TraceFunctionName("RtpInitNetRState");

    pRtpNetRState = &pRtpUser->RtpNetRState;
    
    ts = ntohl(pRtpHdr->ts);

    dwRecvSamplingFreq = pRtpNetRState->dwRecvSamplingFreq;

    if (!dwRecvSamplingFreq)
    {
        dwRecvSamplingFreq = DEFAULT_SAMPLING_FREQ;

        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("sampling frequency unknown, using default:%u"),
                _fname, pRtpUser->pRtpAddr, pRtpUser, dwRecvSamplingFreq
            ));
    }

    /* Compute average delay for last N packets to be used in
     * computing the reference time */
    pRtpNetRState->Di = pRtpNetRState->dDiN / pRtpNetRState->lDiCount;
    
    /* Arbitrarily set delay to be 1s, what we really care is the
     * delay variations, so this shouldn't matter for delay jitter and
     * delay variance computations. When sending RR's RBlock (LSR,
     * DLSR), need to use NTP_sr_rtt. dNTP_ts0 is the time at RTP
     * sample 0. I don't want to use the real arrival time but the one
     * that would generate Ni = Di, because otherwise, the current
     * packet delay might be above or below the mean delay value (for
     * the last N packets) and hence establish a reference time based
     * on that exception packet */
    pRtpNetRState->dNTP_ts0 =
        (Ai - (pRtpNetRState->Ni - pRtpNetRState->Di)) -
        ((double)ts / dwRecvSamplingFreq) -
        RELATIVE_DELAY;

    /* Now update current Ni giving the new reference time */
    pRtpNetRState->Ni = pRtpNetRState->Ni - pRtpNetRState->Di + RELATIVE_DELAY;
    
    /* Now set Di to its resync'ed value which is the relative delay */
    pRtpNetRState->Di = RELATIVE_DELAY;

    /* Keep the smallest variance value */
    if (pRtpNetRState->ViPrev < pRtpNetRState->Vi)
    {
        pRtpNetRState->Vi = pRtpNetRState->ViPrev;
    }
    
    pRtpNetRState->ViPrev = 0;
    
    /* We just went through the resync process, reset this variable
     * until this computation is needed again */
    pRtpNetRState->lDiMax = 0;  
}

/* Do some initialization required only when the first RTP packet is
 * received. Init reference time, Di  */
void RtpOnFirstPacket(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr, double Ai)
{
    RtpNetRState_t  *pRtpNetRState;
    DWORD            dwRecvSamplingFreq;
    DWORD            ts;

    TraceFunctionName("RtpOnFirstPacket");

    pRtpNetRState = &pRtpUser->RtpNetRState;
    
    ts = ntohl(pRtpHdr->ts);

    dwRecvSamplingFreq = pRtpNetRState->dwRecvSamplingFreq;

    if (!dwRecvSamplingFreq)
    {
        dwRecvSamplingFreq = DEFAULT_SAMPLING_FREQ;

        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("sampling frequency unknown, using default:%u"),
                _fname, pRtpUser->pRtpAddr, pRtpUser, dwRecvSamplingFreq
            ));
    }

    /* Arbitrarily set delay to be 1s, what we really care is the
     * delay variations, so this shouldn't matter for delay and delay
     * variance computations. When sending RR's RBlock (LSR, DLSR),
     * need to use NTP_sr_rtt. dNTP_ts0 is the time at RTP sample 0
     * */
    pRtpNetRState->dNTP_ts0 =
        Ai - ((double)ts / dwRecvSamplingFreq) - RELATIVE_DELAY;

    /* Set Di to be the relative delay */
    pRtpNetRState->Di = RELATIVE_DELAY;
}

/* Modify some variables so a marker bit will be generated regardless
 * of the marker bit in the original packet */
void RtpPrepareForMarker(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr, double Ai)
{
    DWORD            dwRecvSamplingFreq;
    
    dwRecvSamplingFreq = pRtpUser->RtpNetRState.dwRecvSamplingFreq;

    if (!dwRecvSamplingFreq)
    {
        dwRecvSamplingFreq = DEFAULT_SAMPLING_FREQ;
    }
    
    /* Make sure that if the first packet received doesn't have
     * the marker bit set, we will generate it */
    pRtpUser->RtpNetRState.dLastTimeMarkerBit =
        Ai - 2 * MINTIMEBETWEENMARKERBIT;
    
    pRtpUser->RtpNetRState.timestamp_prior = ntohl(pRtpHdr->ts) -
        (GAPFORTALKSPURT * dwRecvSamplingFreq / 1000);
}

/* Prepare for the short term average delay, i.e. that computed for
 * the first N packets after the ocurrence of some events, e.g. a
 * delay jump.
 *
 * This is needed in the following conditions: 1. Packet size change;
 * 2. Sampling frequency change; 3. Begin of talkspurt; 4. Delay jumps
 * */
void RtpPrepareForShortDelay(RtpUser_t *pRtpUser, long lCount)
{
    /* A new of this process can be started again before the old one
     * has completed, in this case remeber the smallest variance */
    if (!pRtpUser->RtpNetRState.ViPrev ||
        pRtpUser->RtpNetRState.Vi < pRtpUser->RtpNetRState.ViPrev)
    {
        pRtpUser->RtpNetRState.ViPrev = pRtpUser->RtpNetRState.Vi;
    }

    pRtpUser->RtpNetRState.lDiMax = lCount;
    pRtpUser->RtpNetRState.lDiCount = 0;
    pRtpUser->RtpNetRState.dDiN = 0.0;
}

/* Detect a talkspurt, i.e. the begining of a sequence of packets
 * after a silence */
BOOL RtpDetectTalkspurt(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpHdr_t        *pRtpHdr,
        double           dTime
    )
{
    DWORD            dwTimestamp;
    DWORD            dwGap; /* timestamp gap */
    DWORD            dwRecvSamplingFreq;
    RtpNetRState_t  *pRtpNetRState;

    TraceFunctionName("RtpDetectTalkspurt");

    pRtpNetRState = &pRtpUser->RtpNetRState;

    dwTimestamp = ntohl(pRtpHdr->ts);

    dwRecvSamplingFreq = pRtpNetRState->dwRecvSamplingFreq;
    
    if (!dwRecvSamplingFreq)
    {
        dwRecvSamplingFreq = DEFAULT_SAMPLING_FREQ;
    }

    /* Gap in RTP timestamp units */
    dwGap = dwTimestamp - pRtpNetRState->timestamp_prior;

    /* Update previous timestamp */
    pRtpNetRState->timestamp_prior = dwTimestamp;

    /* Gap in millisecs */
    dwGap = (dwGap * 1000) / dwRecvSamplingFreq;

    if (!pRtpHdr->m && (dwGap >= GAPFORTALKSPURT))
    {
        /* New talkspurt when explicitly indicated by the marker bit,
         * or when there is a big enough gap in the timestamps. */
        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] Seq:%u ")
                _T("marker bit, set, timestamp gap:%u ms"),
                _fname, pRtpAddr, pRtpUser, ntohs(pRtpHdr->seq),
                dwGap
            ));
        
        pRtpHdr->m = 1;
    }

    /* Check if we have a valid marker bit */
    if ( pRtpHdr->m &&
         ( (dTime - pRtpNetRState->dLastTimeMarkerBit) <
           MINTIMEBETWEENMARKERBIT ) )
    {
        /* We don't want the marker bit to happen too ofetn, if it
         * does, then that is indeed a sender's bug, remove marker
         * bits generated within MINTIMEBETWEENMARKERBIT (2) seconds
         * */
        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] Seq:%u ")
                _T("marker bit, reset,     elapsed:%0.3f secs"),
                _fname, pRtpAddr, pRtpUser, ntohs(pRtpHdr->seq),
                dTime - pRtpNetRState->dLastTimeMarkerBit
            ));
        
        pRtpHdr->m = 0;
    }
    
    if (pRtpHdr->m)
    {
        /* Update last time we saw a marker bit */
        pRtpNetRState->dLastTimeMarkerBit = dTime;

        return(TRUE);
    }

    return(FALSE);
}

/* Compute the playout delay in seconds. The playout time is relative
 * to the present moment */
double RtpPlayout(RtpAddr_t *pRtpAddr, RtpUser_t *pRtpUser)
{
    double           dPlayout;
    double           dPlayoutCompensated;
    RtpNetRState_t  *pRtpNetRState;
    
    TraceFunctionName("RtpPlayout");

    pRtpNetRState = &pRtpUser->RtpNetRState;

    dPlayout = 4 * pRtpNetRState->Vi + pRtpNetRState->dRedPlayout;

    if (dPlayout < pRtpNetRState->dMinPlayout)
    {
        dPlayout = pRtpNetRState->dMinPlayout;
    }
    else if (dPlayout > pRtpNetRState->dMaxPlayout)
    {
        dPlayout = pRtpNetRState->dMaxPlayout;
    }

    if (pRtpNetRState->lBigDelay == 0)
    {
        /* Add compensation for the time at which this packet was
         * received, if it arrived late, may be it will have to be played
         * rigth away. There is a chance for dPlayout to be zero if the
         * difference of mean delay and current delay (for a late packet)
         * equals the playout delay (computed from variance), in this case
         * dPlayout would remain zero for the whole talkspurt, but the
         * start time will also be later than it should be, in other
         * words, the playout dalay is in dPlayout when the first packet
         * had the mean delay, or dPlayout may be zero and the playout
         * delay is implicit in the late start of talkspurt time,
         * i.e. dBeginTalkspurtTime */
        dPlayoutCompensated = dPlayout + pRtpNetRState->Di - pRtpNetRState->Ni;

        TraceRetailAdvanced((
                0, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] SSRC:0x%X ")
                _T("Di:%0.3fs Ni:%0.3fs Vi:%0.3fs compensated ")
                _T("Playout:%0.1fms (%0.1fms)"),
                _fname, pRtpAddr, ntohl(pRtpUser->dwSSRC),
                pRtpNetRState->Di, pRtpNetRState->Ni, pRtpNetRState->Vi,
                 dPlayoutCompensated * 1000, dPlayout * 1000
            ));
    }
    else
    {
        /* If we had a big delay, do not compensate but apply playout
         * delay after the arrival time */
        dPlayoutCompensated = dPlayout;

        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] SSRC:0x%X ")
                _T("Di:%0.3fs Ni:%0.3fs Vi:%0.3fs non compensated ")
                _T("Playout:%0.1fms"),
                _fname, pRtpAddr, ntohl(pRtpUser->dwSSRC),
                pRtpNetRState->Di, pRtpNetRState->Ni, pRtpNetRState->Vi,
                dPlayout * 1000
            ));
    }
    
    return(dPlayoutCompensated);
}

void RtpSetMinMaxPlayoutFromRegistry(void)
{
    if (IsRegValueSet(g_RtpReg.dwPlayoutEnable) &&
        ((g_RtpReg.dwPlayoutEnable & 0x3) == 0x3))
    {
        if (IsRegValueSet(g_RtpReg.dwMinPlayout))
        {
            g_dMinPlayout = (double)g_RtpReg.dwMinPlayout / 1000;
        }
        if (IsRegValueSet(g_RtpReg.dwMaxPlayout))
        {
            g_dMaxPlayout = (double)g_RtpReg.dwMaxPlayout / 1000;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpncnt.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpncnt.c
 *
 *  Abstract:
 *
 *    Implements the Statistics family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpheap.h"
#include "rtpglobs.h"
#include "rtprand.h"

#include "rtpncnt.h"

HRESULT ControlRtpStats(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

/* Helper function to update counters */
BOOL RtpUpdateNetCount(
        RtpNetCount_t   *pRtpNetCount,/* structure where to update */
        RtpCritSect_t   *pRtpCritSect,/* lock to use */
        DWORD            dwRtpRtcp,/* 0=RTP or 1=RTCP stats */
        DWORD            dwBytes,  /* bytes toupdate */
        DWORD            dwFlags,  /* Flags, e.g. a dropped or error packet */
        double           dTime     /* time packet recv/send */
    )
{
    BOOL             bOk;

    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (pRtpNetCount)
        {
            if (!dwRtpRtcp)
            {
                /* RTP */
                pRtpNetCount->dwRTPBytes += dwBytes;
                pRtpNetCount->dwRTPPackets++;
                if (RtpBitTest(dwFlags, FGRECV_ERROR))
                {
                    pRtpNetCount->dwRTPBadPackets++;
                }
                else if (RtpBitTest(dwFlags, FGRECV_DROPPED))
                {
                    pRtpNetCount->dwRTPDrpPackets++;
                }
                pRtpNetCount->dRTPLastTime = dTime;
            }
            else
            {
                /* RTCP */
                pRtpNetCount->dwRTCPBytes += dwBytes;
                pRtpNetCount->dwRTCPPackets++;
                if (RtpBitTest(dwFlags, FGRECV_ERROR))
                {
                    pRtpNetCount->dwRTCPBadPackets++;
                }
                else if (RtpBitTest(dwFlags, FGRECV_DROPPED))
                {
                    pRtpNetCount->dwRTCPDrpPackets++;
                }
                pRtpNetCount->dRTCPLastTime = dTime;
            }
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }

    return(pRtpNetCount != NULL);
}

void RtpResetNetCount(
        RtpNetCount_t   *pRtpNetCount,
        RtpCritSect_t   *pRtpCritSect
        )
{
    BOOL             bOk;

    /* It may have worse consequences not to reset than the minimal
     * chance of getting a value partially zeroed, so zero memory even
     * if the critical section is not obtained */

    bOk = FALSE;

    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    ZeroMemory((char *)pRtpNetCount, sizeof(RtpNetCount_t));

    if (bOk)
    {
        RtpLeaveCriticalSection(pRtpCritSect) ;
    }
}

void RtpGetRandomInit(RtpAddr_t *pRtpAddr)
{
    RtpNetSState_t  *pRtpNetSState;

    pRtpNetSState = &pRtpAddr->RtpNetSState;

    /* SSRC */
    if (!pRtpNetSState->dwSendSSRC ||
        !RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_PERSISTSSRC))
    {
        /* Update the SSRC only if the SSRC hasn't been set yet, or if
         * it was set, we are not using the Init option for persistent
         * SSRC */
        pRtpNetSState->dwSendSSRC = RtpRandom32((DWORD_PTR)pRtpAddr);
    }

    /* sequence number */
    pRtpNetSState->wSeq = (WORD)RtpRandom32((DWORD_PTR)pRtpNetSState);

    /* timestamp offset */
    pRtpNetSState->dwTimeStampOffset =
        RtpRandom32((DWORD_PTR)GetCurrentThreadId());
}

void RtpResetNetSState(
        RtpNetSState_t  *pRtpNetSState,
        RtpCritSect_t   *pRtpCritSect
    )
{
    BOOL             bOk;
    
    bOk = FALSE;

    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    pRtpNetSState->dTimeLastRtpSent = 0;
    pRtpNetSState->avg_rtcp_size = 0;

    if (bOk)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
}


#if 0
/* Creates and initializes a RtpNetCount_t structure */
RtpNetCount_t *RtpNetCountAlloc(void)
{
    RtpNetCount_t *pRtpNetCount;

    pRtpNetCount = (RtpNetCount_t *)
        RtpHeapAlloc(g_pRtpNetCountHeap, sizeof(RtpNetCount_t));

    if (pRtpNetCount) {
        
        ZeroMemory(pRtpNetCount, sizeof(RtpNetCount_t));

        pRtpNetCount->dwObjectID = OBJECTID_RTPSTAT;
    }
    
    return(pRtpNetCount);
}

/* Frees a RtpNetCount_t structure */
void RtpNetCountFree(RtpNetCount_t *pRtpNetCount)
{
    if (pRtpNetCount->dwObjectID != OBJECTID_RTPSTAT) {
        /* TODO log error */
        return;
    }
    
    RtpHeapFree(g_pRtpNetCountHeap, pRtpNetCount);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpglob.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpglob.c
 *
 *  Abstract:
 *
 *    Implements the RTP Global family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/02 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpglob.h"

HRESULT ControlRtpGlob(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpdemux.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpcrypt.c
 *
 *  Abstract:
 *
 *    Implements the Demultiplexing family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpglobs.h"
#include "rtpheap.h"
#include "rtpevent.h"
#include "rtpmisc.h"
#include "lookup.h"

#include "rtpdemux.h"

/*
 * WARNING
 *
 * The entries in this array MUST match the entries in the enum
 * RTPDMXMODE_* defined in msrtp.h */
const TCHAR_t *g_psRtpDmxMode[] = {
    _T("invalid"),
    _T("MANUAL"),
    _T("AUTO"),
    _T("AUTO_MANUAL"),
    NULL
};

HRESULT ControlRtpDemux(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

/**********************************************************************
 * Users <-> Outputs assignment
 **********************************************************************/

/* Creates and add an RtpOutput at the end of the list of outputs,
 * keeps a user information which is currently used to keep the 1:1
 * association with the DShow output pins */
RtpOutput_t *RtpAddOutput(
        RtpSess_t       *pRtpSess,
        int              iOutMode,
        void            *pvUserInfo,
        DWORD           *pdwError
    )
{
    DWORD            dwError;
    RtpOutput_t     *pRtpOutput;
    
    TraceFunctionName("RtpAddOutput");

    dwError = NOERROR;
    pRtpOutput = (RtpOutput_t *)NULL;
    
    if (iOutMode <= RTPDMXMODE_FIRST || iOutMode >= RTPDMXMODE_LAST)
    {
        dwError = RTPERR_INVALIDARG;
            
        goto end;
    }

    if (!pRtpSess)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    /* verify object ID in RtpSess_t */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        dwError = RTPERR_INVALIDRTPSESS;

        goto end;
    }

    /* Obtain new RtpOutput_t structure */
    pRtpOutput = RtpOutputAlloc();

    if (!pRtpOutput)
    {
        dwError = RTPERR_MEMORY;

        goto end;
    }

    /* Initialize output */

    /* The output, after being created is marked as free but is
     * disabled */
    pRtpOutput->dwOutputFlags = RtpBitPar(RTPOUTFG_FREE);

    RtpSetOutputMode_(pRtpOutput, iOutMode);

    pRtpOutput->pvUserInfo = pvUserInfo;

    /* Position in the queue is counted as 0,1,2,... */
    pRtpOutput->OutputQItem.dwKey = (DWORD)GetQueueSize(&pRtpSess->OutputQ);
    
    enqueuel(&pRtpSess->OutputQ,
             &pRtpSess->OutputCritSect,
             &pRtpOutput->OutputQItem);

 end:
    if (dwError == NOERROR)
    {
        TraceDebug((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpOutput[0x%p] pvUserInfo[0x%p] ")
                _T("Output added"),
                _fname, pRtpOutput, pvUserInfo
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpOutput[0x%p] pvUserInfo[0x%p] failed: %u (0x%X)"),
                _fname, pRtpOutput, pvUserInfo,
                dwError, dwError
            ));
    }

    if (pdwError)
    {
        *pdwError = dwError;
    }
    
    return(pRtpOutput);
}

/* Deletes an output, assumes outputs are unmapped and the session is
 * stopped. Update the index for the outputs that are left after the
 * one being removed */
DWORD RtpDelOutput(
        RtpSess_t       *pRtpSess,
        RtpOutput_t     *pRtpOutput
    )
{
    BOOL             bOk;
    DWORD            dwError;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("RtpDelOutput");

    dwError = NOERROR;

    bOk = FALSE;
    
    if (!pRtpSess)
    {
        /* Having pRtpSess as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        dwError = RTPERR_INVALIDSTATE;

        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpOutput[0x%p] failed: %s (0x%X)"),
                _fname, pRtpOutput,
                RTPERR_TEXT(dwError), dwError
            ));
        
        return(dwError);
    }

    if (!pRtpOutput)
    {
        dwError = RTPERR_POINTER;

        goto end;
    }
    
    bOk = RtpEnterCriticalSection(&pRtpSess->OutputCritSect);

    if (!bOk)
    {
        goto end;
    }

    /* Shift the index from the next output (if any) and upto the last
     * one */
    for(pRtpQueueItem = pRtpOutput->OutputQItem.pNext;
        pRtpSess->OutputQ.pFirst != pRtpQueueItem;
        pRtpQueueItem = pRtpQueueItem->pNext)
    {
        pRtpQueueItem->dwKey--;
    }

    /* Now remove output from the session */
    pRtpQueueItem =
        dequeue(&pRtpSess->OutputQ, NULL, &pRtpOutput->OutputQItem);

    /* We can now free the object */
    RtpOutputFree(pRtpOutput);
    
    if (!pRtpQueueItem)
    {
        dwError = RTPERR_UNEXPECTED;
    }

 end:
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpSess->OutputCritSect);
    }

    if (dwError != NOERROR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpOutput[0x%p] failed: %s (0x%X)"),
                _fname, pRtpOutput,
                RTPERR_TEXT(dwError), dwError
            ));
    }

    return(dwError);
}

DWORD RtpSetOutputMode(
        RtpSess_t       *pRtpSess,
        int              iPos,
        RtpOutput_t     *pRtpOutput,
        int              iOutMode
    )
{
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("RtpSetOutputMode");

    if (iOutMode <= RTPDMXMODE_FIRST || iOutMode >= RTPDMXMODE_LAST)
    {
        dwError = RTPERR_INVALIDARG;
            
        goto end;
    }

    if (!pRtpSess)
    {
        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    /* verify object ID in RtpSess_t */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        dwError = RTPERR_INVALIDRTPSESS;

        goto end;
    }

    if (iPos >= 0)
    {
        pRtpQueueItem = findQN(&pRtpSess->OutputQ,
                               &pRtpSess->OutputCritSect,
                               iPos);

        if (!pRtpQueueItem)
        {
            dwError = RTPERR_INVALIDARG;

            goto end;
        }

        pRtpOutput =
            CONTAINING_RECORD(pRtpQueueItem, RtpOutput_t, OutputQItem);
    }
    else if (!pRtpOutput)
    {
        dwError = RTPERR_POINTER;

        goto end;
    }

    /* Set mode */

    dwError = NOERROR;

    RtpSetOutputMode_(pRtpOutput, iOutMode);
    
 end:
    if (dwError == NOERROR)
    {
        TraceDebug((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] Out:%d Mode:%s"),
                _fname, pRtpSess, iPos, g_psRtpDmxMode[iOutMode]
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] failed: %u (0x%X)"),
                _fname, pRtpSess,
                dwError, dwError
            ));
    }
    
    return(dwError);
}

DWORD RtpOutputState(
        RtpAddr_t       *pRtpAddr,
        int              iPos,
        RtpOutput_t     *pRtpOutput,
        DWORD            dwSSRC,
        BOOL             bAssigned
    )
{
    BOOL             bOk;
    DWORD            dwError;
    BOOL             bCreate;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpSess_t       *pRtpSess;
    RtpUser_t       *pRtpUser;
    
    TraceFunctionName("RtpOutputState");

    bOk = FALSE;
    pRtpSess = (RtpSess_t *)NULL;
    
    if (!pRtpAddr)
    {
        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    /* verify object ID in RtpSess_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        dwError = RTPERR_INVALIDRTPADDR;

        goto end;
    }

    pRtpSess = pRtpAddr->pRtpSess;

    /*
     * Find RtpOutput
     */

    if (iPos >= 0)
    {
        /* Find RtpOutput by position */
        pRtpQueueItem = findQN(&pRtpSess->OutputQ,
                               &pRtpSess->OutputCritSect,
                               iPos);

        if (pRtpQueueItem)
        {
            pRtpOutput =
                CONTAINING_RECORD(pRtpQueueItem, RtpOutput_t, OutputQItem);
        }
        else
        {
            dwError = RTPERR_INVALIDARG;

            goto end;
        }
    }

    pRtpUser = (RtpUser_t *)NULL;
    
    /* If an SSRC is passed locate the user who owns it */
    if (dwSSRC)
    {
        bCreate = FALSE;
        pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

        if (!pRtpUser)
        {
            dwError = RTPERR_NOTFOUND;

            goto end;
        }
    }

    bOk = RtpEnterCriticalSection(&pRtpSess->OutputCritSect);

    if (!bOk)
    {
        dwError = RTPERR_CRITSECT;
        
        goto end;
    }

    /* Set the output state */
    if (bAssigned)
    {
        /*
         * Assigned
         */
        
        if (!pRtpUser || !pRtpOutput)
        {
            dwError = RTPERR_INVALIDARG;

            goto end;
        }
        
        /* Associate output to user */
        dwError = RtpOutputAssign(pRtpSess, pRtpUser, pRtpOutput);
    }
    else
    {
        /*
         * Unassigned
         */

        if (!pRtpUser && !pRtpOutput)
        {
            dwError = RTPERR_INVALIDARG;

            goto end;
        }
        
        dwError = RTPERR_INVALIDSTATE;

        if (!pRtpUser)
        {
            pRtpUser = pRtpOutput->pRtpUser;

            if (!pRtpUser)
            {
                goto end;
            }
        }
        else if (!pRtpOutput)
        {
            pRtpOutput = pRtpUser->pRtpOutput;

            if (!pRtpOutput)
            {
                goto end;
            }
        }
        
        /* Unassociate output from user */
        dwError = RtpOutputUnassign(pRtpSess, pRtpUser, pRtpOutput);
    }
    
 end:
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpSess->OutputCritSect);
    }

    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] pRtpOutput[0x%p]:%u ")
                _T("SSRC:0x%X output %s"),
                _fname, pRtpSess, pRtpOutput, pRtpOutput->OutputQItem.dwKey,
                ntohl(dwSSRC), bAssigned? _T("assigned") : _T("unassigned")
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] pRtpOutput[0x%p]:%u ")
                _T("SSRC:0x%X output %s failed: %u (0x%X)"),
                _fname, pRtpSess, pRtpOutput, pRtpOutput->OutputQItem.dwKey,
                ntohl(dwSSRC), bAssigned? _T("assigned") : _T("unassigned"),
                dwError, dwError
            ));
    }

    return(dwError);
}

DWORD RtpUnmapAllOuts(
        RtpSess_t       *pRtpSess
    )
{
    BOOL             bOk;
    DWORD            dwError;
    long             lCount;
    DWORD            dwUnmapped;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpOutput_t     *pRtpOutput;

    TraceFunctionName("RtpUnmapAllOuts");

    pRtpOutput = (RtpOutput_t *)NULL;

    dwUnmapped = 0;

    dwError = RTPERR_CRITSECT;
    
    bOk = RtpEnterCriticalSection(&pRtpSess->OutputCritSect);

    if (!bOk)
    {
        goto end;
    }

    pRtpQueueItem = pRtpSess->OutputQ.pFirst;
        
    for(lCount = GetQueueSize(&pRtpSess->OutputQ);
        lCount > 0;
        lCount--, pRtpQueueItem = pRtpQueueItem->pNext)
    {
        pRtpOutput =
            CONTAINING_RECORD(pRtpQueueItem, RtpOutput_t, OutputQItem);

        if (pRtpOutput->pRtpUser)
        {
            RtpOutputUnassign(pRtpSess, pRtpOutput->pRtpUser, pRtpOutput);

            dwUnmapped++;
        }
    }

    RtpLeaveCriticalSection(&pRtpSess->OutputCritSect);

    dwError = NOERROR;
    
 end:
    if (dwError)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] failed: %u (0x%X)"),
                _fname, pRtpSess, dwError, dwError
            ));
    }
    else
    {
        TraceRetail((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] unmapped %u outputs"),
                _fname, pRtpSess, dwUnmapped
            ));
    }

    return(dwUnmapped);
}

/* Find the output assigned (if any) to the SSRC, return either
 * position or user info or both */
DWORD RtpFindOutput(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSSRC,
        int             *piPos,
        void           **ppvUserInfo
    )
{
    DWORD            dwError;
    BOOL             bCreate;
    int              iPos;
    void            *pvUserInfo;
    RtpOutput_t     *pRtpOutput;
    RtpUser_t       *pRtpUser;
    
    TraceFunctionName("RtpFindOutput");

    if (!pRtpAddr)
    {
        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    /* verify object ID in RtpSess_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        dwError = RTPERR_INVALIDRTPADDR;

        goto end;
    }

    if (!piPos && !ppvUserInfo)
    {
        dwError = RTPERR_POINTER;

        goto end;
    }

    dwError = NOERROR;
    
    bCreate = FALSE;
    pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

    /* By default assume SSRC doesn't have an output assigned */
    iPos = -1;
    pvUserInfo = NULL;
    
    if (pRtpUser)
    {
        pRtpOutput = pRtpUser->pRtpOutput;
        
        if (pRtpOutput)
        {
            /* SSRC has this output assigned */
        
            iPos = (int)pRtpOutput->OutputQItem.dwKey;
            
            pvUserInfo = pRtpOutput->pvUserInfo;
        }
    }
    else
    {
        TraceRetail((
                CLASS_WARNING, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] No user found with SSRC:0x%X"),
                _fname, pRtpAddr, ntohl(dwSSRC)
            ));
    }

    if (piPos)
    {
        *piPos = iPos;
    }

    if (ppvUserInfo)
    {
        *ppvUserInfo = pvUserInfo;
    }

 end:
    if (dwError)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] failed: %u (0x%X)"),
                _fname, pRtpAddr, dwError, dwError
            ));
    }
    else
    {
        TraceRetail((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] SSRC:0x%X has pRtpOutput[0x%p]:%d"),
                _fname, pRtpAddr,
                ntohl(dwSSRC), pRtpOutput, iPos
            ));
    }
    
    return(dwError);
}

/* Find the SSRC mapped to the ooutput, if iPos >= 0 use it, otherwise
 * use pRtpOutput */
DWORD RtpFindSSRC(
        RtpAddr_t       *pRtpAddr,
        int              iPos,
        RtpOutput_t     *pRtpOutput,
        DWORD           *pdwSSRC
    )
{
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpSess_t       *pRtpSess;
    RtpUser_t       *pRtpUser;
    
    TraceFunctionName("RtpFindSSRC");

    if (!pRtpAddr)
    {
        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    if (!pdwSSRC)
    {
        dwError = RTPERR_POINTER;

        goto end;
    }

    /* verify object ID in RtpSess_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        dwError = RTPERR_INVALIDRTPADDR;

        goto end;
    }

    if (iPos < 0 && !pRtpOutput)
    {
        dwError = RTPERR_INVALIDARG;

        goto end;
    }

    dwError = NOERROR;

    pRtpSess = pRtpAddr->pRtpSess;

    if (iPos >= 0)
    {
        /* Find RtpOutput by position */
        pRtpQueueItem = findQN(&pRtpSess->OutputQ,
                               &pRtpSess->OutputCritSect,
                               iPos);

        if (pRtpQueueItem)
        {
            pRtpOutput =
                CONTAINING_RECORD(pRtpQueueItem, RtpOutput_t, OutputQItem);
        }
        else
        {
            dwError = RTPERR_INVALIDARG;

            goto end;
        }
    }
    else if (!pRtpOutput)
    {
        dwError = RTPERR_POINTER;

        goto end;
    }

    pRtpUser = pRtpOutput->pRtpUser;

    if (pRtpUser)
    {
        /* This output is assigned */
        *pdwSSRC = pRtpUser->dwSSRC;
    }
    else
    {
        *pdwSSRC = 0;
    }
    
 end:
    if (dwError)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] failed: %u (0x%X)"),
                _fname, pRtpAddr, dwError, dwError
            ));
    }
    else
    {
        TraceRetail((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] pRtpOutput[0x%p]:%d has SSRC:0x%X"),
                _fname, pRtpAddr,
                pRtpOutput, iPos, ntohl(*pdwSSRC)
            ));
    }
    
    return(dwError);
}

RtpOutput_t *RtpOutputAlloc(void)
{
    RtpOutput_t     *pRtpOutput;

    TraceFunctionName("RtpOutputAlloc");

    pRtpOutput = RtpHeapAlloc(g_pRtpGlobalHeap, sizeof(RtpOutput_t));

    if (pRtpOutput)
    {
        ZeroMemory(pRtpOutput, sizeof(RtpOutput_t));

        pRtpOutput->dwObjectID = OBJECTID_RTPOUTPUT;
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_ALLOC,
                _T("%s: pRtpOutput[0x%p] failed"),
                _fname, pRtpOutput
            ));
    }
    
    return(pRtpOutput);
}

RtpOutput_t *RtpOutputFree(RtpOutput_t *pRtpOutput)
{
    TraceFunctionName("RtpOutputFree");

    if (!pRtpOutput)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_ALLOC,
                _T("%s: pRtpOutput[0x%p] NULL pointer"),
                _fname, pRtpOutput
            ));
        
        return(pRtpOutput);
    }

    /* verify object ID in RtpOutput_t */
    if (pRtpOutput->dwObjectID != OBJECTID_RTPOUTPUT)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_ALLOC,
                _T("%s: pRtpOutput[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpOutput,
                pRtpOutput->dwObjectID, OBJECTID_RTPOUTPUT
            ));

        return((RtpOutput_t *)NULL);
    }

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpOutput->dwObjectID);
    
    RtpHeapFree(g_pRtpGlobalHeap, pRtpOutput);

    return(pRtpOutput);
}

/* Try to find and output for this user, assumes no output has been
 * assigned yet */
RtpOutput_t *RtpGetOutput(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser
    )
{
    BOOL             bOk;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpOutput_t     *pRtpOutput;
    RtpSess_t       *pRtpSess;

    TraceFunctionName("RtpGetOutput");
    
    /* Note that this function assumes no output is assigned yet */
    
    bOk = FALSE;

    pRtpSess = pRtpAddr->pRtpSess;

    pRtpOutput = (RtpOutput_t *)NULL;
    
    bOk = RtpEnterCriticalSection(&pRtpSess->OutputCritSect);

    if (!bOk)
    {
        goto end;
    }

    pRtpQueueItem = pRtpSess->OutputQ.pFirst;
        
    for(lCount = GetQueueSize(&pRtpSess->OutputQ);
        lCount > 0;
        lCount--, pRtpQueueItem = pRtpQueueItem->pNext)
    {
        pRtpOutput =
            CONTAINING_RECORD(pRtpQueueItem, RtpOutput_t, OutputQItem);

        if ( RtpBitTest(pRtpOutput->dwOutputFlags, RTPOUTFG_ENABLED)
             &&
             (RtpBitTest2(pRtpOutput->dwOutputFlags,
                          RTPOUTFG_FREE, RTPOUTFG_AUTO) ==
              RtpBitPar2(RTPOUTFG_FREE, RTPOUTFG_AUTO)) )
        {
            /* This output is enabled, is free and can be used for
             * automatic assignment */

            RtpOutputAssign(pRtpSess, pRtpUser, pRtpOutput);

            break;
        }
    }

    RtpLeaveCriticalSection(&pRtpSess->OutputCritSect);

    if (!lCount)
    {
        pRtpOutput = (RtpOutput_t *)NULL; 
    }

 end:
    if (pRtpOutput)
    {
        TraceRetail((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] got pRtpOutput[0x%p]"),
                _fname, pRtpAddr, pRtpUser, pRtpOutput
            ));
    }
    
    return(pRtpOutput);
}

DWORD RtpSetOutputMode_(
        RtpOutput_t     *pRtpOutput,
        int              iOutMode
    )
{
    pRtpOutput->iOutMode = iOutMode;
    
    switch(iOutMode)
    {
    case RTPDMXMODE_MANUAL:
        RtpBitSet  (pRtpOutput->dwOutputFlags, RTPOUTFG_MANUAL);
        RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_AUTO);
        RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_ENTIMEOUT);
        break;
    case RTPDMXMODE_AUTO:
        RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_MANUAL);
        RtpBitSet  (pRtpOutput->dwOutputFlags, RTPOUTFG_AUTO);
        RtpBitSet  (pRtpOutput->dwOutputFlags, RTPOUTFG_ENTIMEOUT);
        break;
    case RTPDMXMODE_AUTO_MANUAL:
        RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_MANUAL);
        RtpBitSet  (pRtpOutput->dwOutputFlags, RTPOUTFG_AUTO);
        RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_ENTIMEOUT);
        break;
    }

    return(pRtpOutput->dwOutputFlags);
}       

DWORD RtpOutputAssign(
        RtpSess_t       *pRtpSess,
        RtpUser_t       *pRtpUser,
        RtpOutput_t     *pRtpOutput
    )
{
    BOOL             bOk;
    DWORD            dwError;

    TraceFunctionName("RtpOutputAssign");

    bOk = RtpEnterCriticalSection(&pRtpSess->OutputCritSect);
    
    /* If the critical section fails I don't have any other choice but
     * proceed */

    dwError = RTPERR_INVALIDSTATE;

    if (!RtpBitTest(pRtpOutput->dwOutputFlags, RTPOUTFG_ENABLED))
    {
        /* This output is disabled and can not be used */
        goto end;
    }
    
    if (!RtpBitTest(pRtpOutput->dwOutputFlags, RTPOUTFG_FREE))
    {
        if ( (pRtpOutput->pRtpUser == pRtpUser) &&
             (pRtpUser->pRtpOutput == pRtpOutput) )
        {
            dwError = NOERROR;

            TraceRetail((
                    CLASS_WARNING, GROUP_DEMUX, S_DEMUX_OUTS,
                    _T("%s: pRtpSess[0x%p] pRtpUser[0x%p] pRtpOutput[0x%p] ")
                    _T("already assigned, nothing else to do"),
                    _fname, pRtpSess, pRtpUser, pRtpOutput
                ));
            
            goto end;
        }
        else
        {
            /* Output is already assigned to a different user */
            TraceRetail((
                    CLASS_WARNING, GROUP_DEMUX, S_DEMUX_OUTS,
                    _T("%s: pRtpSess[0x%p] pRtpUser[0x%p] pRtpOutput[0x%p] ")
                    _T("failed: Output already assigned to pRtpUser[0x%p] ")
                    _T("%s (0x%X) unassign requested output"),
                    _fname, pRtpSess, pRtpUser, pRtpOutput,
                    pRtpOutput->pRtpUser,
                    RTPERR_TEXT(dwError), dwError
                ));

            /* Freeing the requested output */
            RtpOutputUnassign(pRtpSess, pRtpOutput->pRtpUser, pRtpOutput);
        }
    }

    if (pRtpUser->pRtpOutput)
    {
        /* User already has an output */
        TraceRetail((
                CLASS_WARNING, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] pRtpUser[0x%p] pRtpOutput[0x%p] ")
                _T("failed: User already has an pRtpOutput[0x%p] ")
                _T("%s (0x%X) unassign current output"),
                _fname, pRtpSess, pRtpUser, pRtpOutput,
                pRtpUser->pRtpOutput,
                RTPERR_TEXT(dwError), dwError
            ));

        /* Unassig it */
        RtpOutputUnassign(pRtpSess, pRtpUser, pRtpUser->pRtpOutput);
    }

    dwError = NOERROR;
    
    /* Assign this output to this user */
    pRtpOutput->pRtpUser = pRtpUser;
                
    pRtpUser->pRtpOutput = pRtpOutput;

    /* Output is in use */
    RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_FREE);

    TraceRetail((
            CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
            _T("%s: pRtpSess[0x%p] pRtpUser[0x%p] pRtpOutput[0x%p] Out:%u %s ")
            _T("Output assigned to user"),
            _fname, pRtpSess, pRtpUser, pRtpOutput,
            pRtpOutput->OutputQItem.dwKey, RTPRECVSENDSTR(RECV_IDX)
        ));
    
    RtpPostEvent(pRtpUser->pRtpAddr,
                 pRtpUser,
                 RTPEVENTKIND_PINFO,
                 RTPPARINFO_MAPPED,
                 pRtpUser->dwSSRC,
                 (DWORD_PTR)pRtpOutput->pvUserInfo /* Pin */);

 end:
    if (bOk)
    {
        bOk = RtpLeaveCriticalSection(&pRtpSess->OutputCritSect);
    }

    return(dwError);
}

DWORD RtpOutputUnassign(
        RtpSess_t       *pRtpSess,
        RtpUser_t       *pRtpUser,
        RtpOutput_t     *pRtpOutput
    )
{
    BOOL             bOk;
    DWORD            dwError;
    
    TraceFunctionName("RtpOutputUnassign");

    bOk = RtpEnterCriticalSection(&pRtpSess->OutputCritSect);

    if (pRtpUser->pRtpOutput != pRtpOutput ||
        pRtpOutput->pRtpUser != pRtpUser)
    {
        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    dwError = NOERROR;
    
    pRtpUser->pRtpOutput = (RtpOutput_t *)NULL;

    pRtpOutput->pRtpUser = (RtpUser_t *)NULL;
    
    RtpBitSet(pRtpOutput->dwOutputFlags, RTPOUTFG_FREE);
    
    /* If the critical section fails I don't have any other choice but
     * proceed */

    RtpPostEvent(pRtpUser->pRtpAddr,
                 pRtpUser,
                 RTPEVENTKIND_PINFO,
                 RTPPARINFO_UNMAPPED,
                 pRtpUser->dwSSRC,
                 (DWORD_PTR)pRtpOutput->pvUserInfo /* Pin */);

 end:
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpSess->OutputCritSect);
    }

    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] pRtpUser[0x%p] pRtpOutput[0x%p] ")
                _T("Out:%u %s Output unassigned from user"),
                _fname, pRtpSess, pRtpUser, pRtpOutput,
                pRtpOutput->OutputQItem.dwKey, RTPRECVSENDSTR(RECV_IDX)
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] pRtpUser[0x%p] pRtpOutput[0x%p] ")
                _T("Out:%u %s failed: %u (0x%X)"),
                _fname, pRtpSess, pRtpUser, pRtpOutput,
                pRtpOutput->OutputQItem.dwKey, RTPRECVSENDSTR(RECV_IDX),
                dwError, dwError
            ));
    }
  
    return(dwError);
}

DWORD RtpAddPt2FrequencyMap(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwPt,
        DWORD            dwFrequency,
        DWORD            dwRecvSend
    )
{
    DWORD            dwError;
    DWORD            i;
    RtpPtMap_t      *pRecvPtMap;

    TraceFunctionName("RtpAddPt2FrequencyMap");

    dwError = NOERROR;
    
    if (dwRecvSend == RECV_IDX)
    {
        pRecvPtMap = &pRtpAddr->RecvPtMap[0];
        
        /* Find out if the PT already exists */
        for(i = 0;
            pRecvPtMap[i].dwPt != -1 &&
                pRecvPtMap[i].dwPt != dwPt &&
                i < MAX_PTMAP;
            i++)
        {
            /* Empty body */;
        }

        if (i >= MAX_PTMAP)
        {
            dwError = RTPERR_RESOURCES;
            
            TraceRetail((
                    CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                    _T("%s: pRtpAddr[0x%p] RECV ")
                    _T("PT:%u Frequency:%u failed: %s (0x%X)"),
                    _fname, pRtpAddr, dwPt, dwFrequency,
                    RTPERR_TEXT(dwError), dwError
                ));
        }
        else
        {
            /* New PT -or- Update existing PT */
            pRecvPtMap[i].dwPt = dwPt;
            pRecvPtMap[i].dwFrequency = dwFrequency;

            TraceRetail((
                    CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                    _T("%s: pRtpAddr[0x%p] RECV map[%u] ")
                    _T("PT:%u Frequency:%u"),
                    _fname, pRtpAddr, i, dwPt, dwFrequency
                ));
         }
    }

    return(dwError);
}

BOOL RtpLookupPT(
        RtpAddr_t       *pRtpAddr,
        BYTE             bPT
    )
{
    BOOL             bFound;
    DWORD            i;
    RtpPtMap_t      *pRecvPtMap;

    pRecvPtMap = &pRtpAddr->RecvPtMap[0];
    bFound = FALSE;
    
    /* Find out if the PT already exists */
    for(i = 0; pRecvPtMap[i].dwPt != -1 && i < MAX_PTMAP; i++)
    {
        if (pRecvPtMap[i].dwPt == bPT)
        {
            bFound = TRUE;

            break;
        }
    }

    return(bFound);
}

/* NOTE Assume the mapping doesn't have gaps, i.e. it never happens to
 * have a non assigned entry (PT=-1) between 2 valid mappings */
DWORD RtpMapPt2Frequency(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        DWORD            dwPt,
        DWORD            dwRecvSend
    )
{
    DWORD            dwError;
    DWORD            i;
    RtpPtMap_t      *pRecvPtMap;
    RtpNetRState_t  *pRtpNetRState;

    TraceFunctionName("RtpMapPt2Frequency");

    dwError = NOERROR;

    if (dwRecvSend != RECV_IDX)
    {
        return(dwError);
    }

    pRecvPtMap = &pRtpAddr->RecvPtMap[0];
    pRtpNetRState = &pRtpUser->RtpNetRState;
        
    /* Find out if the PT already exists */
    for(i = 0; pRecvPtMap[i].dwPt != -1 && i < MAX_PTMAP; i++)
    {
        if (pRecvPtMap[i].dwPt == dwPt)
        {
            /* Found it */
            pRtpNetRState->dwPt = dwPt;

            pRtpNetRState->dwRecvSamplingFreq = pRecvPtMap[i].dwFrequency;

            return(dwError);
        }
    }

    TraceRetail((
            CLASS_WARNING, GROUP_DEMUX, S_DEMUX_OUTS,
            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
            _T("Pt:%u not found"),
            _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
            dwPt
        ));

    /* Report an error so this packet is dropped */
    dwError = RTPERR_NOTFOUND;

    return(dwError);
}
  
DWORD RtpFlushPt2FrequencyMaps(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    )
{
    DWORD            i;

    if (dwRecvSend == RECV_IDX)
    {
        for(i = 0; i < MAX_PTMAP; i++)
        {
            pRtpAddr->RecvPtMap[i].dwPt = -1;
            pRtpAddr->RecvPtMap[i].dwFrequency = 0;
        }
    }

    return(NOERROR);
}

/* Set the output state to enabled or disabled. An output that is
 * enabled can be assigned to a user; an output that is disabled is
 * just skipped */
DWORD RtpOutputEnable(
        RtpOutput_t     *pRtpOutput,
        BOOL             bEnable
    )
{
    DWORD            dwError;

    TraceFunctionName("RtpOutputEnable");
    
    dwError = RTPERR_INVALIDSTATE;
    
    if (pRtpOutput)
    {
        if (bEnable)
        {
            RtpBitSet(pRtpOutput->dwOutputFlags, RTPOUTFG_ENABLED);
        }
        else
        {
            RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_ENABLED);
        }

        dwError = NOERROR;
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpOutput[0x%p] Enable:%u"),
                _fname, pRtpOutput, bEnable
            ));
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtprand.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtprand.c
 *
 *  Abstract:
 *
 *    Random number generation using CAPI
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/09/12 created
 *
 **********************************************************************/

#include "gtypes.h"
#include "rtpglobs.h"

#include <wincrypt.h>
#include <time.h>        /* clock() */

#include "rtprand.h"

HCRYPTPROV           g_hRtpRandCryptProvider = (HCRYPTPROV)0;

/*
 * WARNING

 * The call to RtpRandInit and RtpRandDeinit MUST be protected by a
 * critical section in the caller function */


HRESULT RtpRandInit(void)
{
    BOOL             bOk;
    DWORD            dwError;

    TraceFunctionName("RtpRandInit");

    if (!g_hRtpRandCryptProvider)
    {
        bOk = CryptAcquireContext(
                &g_hRtpRandCryptProvider,/* HCRYPTPROV *phProv */
                NULL,              /* LPCTSTR pszContainer */
                NULL,              /* LPCTSTR pszProvider */
                PROV_RSA_FULL,     /* DWORD dwProvType */
                CRYPT_VERIFYCONTEXT/* DWORD dwFlags */
            );
        
        if (!bOk)
        {
            g_hRtpRandCryptProvider = (HCRYPTPROV)0;
            
            TraceRetailGetError(dwError);

            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_RAND,
                    _T("%s: CryptAcquireContext(PROV_RSA_FULL, ")
                    _T("CRYPT_VERIFYCONTEXT) failed: %u (0x%X)"),
                    _fname, dwError, dwError
                ));
        
            return(RTPERR_CRYPTO);
        }
    }

    return(NOERROR);
}

HRESULT RtpRandDeinit(void)
{
    if (g_hRtpRandCryptProvider)
    {
        CryptReleaseContext(g_hRtpRandCryptProvider, 0);

        g_hRtpRandCryptProvider = (HCRYPTPROV)0;
    }

    return(NOERROR);
}

/*
 * Return random unsigned 32-bit quantity. Use 'type' argument if you
 * need to generate several different values in close succession.
 */
DWORD RtpRandom32(DWORD_PTR type)
{
    BOOL             bOk;
    DWORD           *pdw;
    DWORD            i;
    DWORD            dwError;
    
    struct {
        DWORD_PTR       type;
        RtpTime_t       RtpTime;
        clock_t         cpu;
        DWORD           pid;
        LONGLONG        ms;
    } s;

    TraceFunctionName("RtpRandom32");

    s.type = type;
    RtpGetTimeOfDay(&s.RtpTime);
    s.cpu  = clock();
    s.pid  = GetCurrentProcessId();
    s.ms   = RtpGetTime();

    pdw = (DWORD *)&s;

    bOk = FALSE;
    
    if (g_hRtpRandCryptProvider)
    {
        bOk = CryptGenRandom(g_hRtpRandCryptProvider, sizeof(s), (char *)&s);
    }

    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_WARNING, GROUP_CRYPTO, S_CRYPTO_RAND,
                _T("%s: CryptGenRandom failed: %u (0x%X)"),
                _fname, dwError, dwError
            ));
        
        /* Generate a pseudo random number */
        srand((unsigned int)pdw[0]);
        
        for(i = 1; i < (sizeof(s)/sizeof(DWORD)); i++)
        {
            pdw[0] ^= (pdw[i] ^ rand());
        }
    }

    return(pdw[0]);
}

/* Generate dwLen bytes of random data */
DWORD RtpRandomData(char *pBuffer, DWORD dwLen)
{
    BOOL             bOk;
    DWORD           *pdw;
    DWORD            i;
    DWORD            dwLen2;
    DWORD            dwError;

    struct {
        RtpTime_t       RtpTime;
        clock_t         cpu;
        DWORD           pid;
        LONGLONG        ms;
    } s;

    TraceFunctionName("RtpRandomData");

    if (!pBuffer || !dwLen)
    {
        return(RTPERR_FAIL);
    }
        
    RtpGetTimeOfDay(&s.RtpTime);
    s.cpu  = clock();
    s.pid  = GetCurrentProcessId();
    s.ms   = RtpGetTime();

    dwLen2 = dwLen;

    if (dwLen2 > sizeof(s))
    {
        dwLen2 = sizeof(s);
    }

    CopyMemory(pBuffer, (char *)&s, dwLen2);
        
    bOk = FALSE;

    if (g_hRtpRandCryptProvider)
    {
        bOk = CryptGenRandom(g_hRtpRandCryptProvider, dwLen, pBuffer);
    }

    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_WARNING, GROUP_CRYPTO, S_CRYPTO_RAND,
                _T("%s: CryptGenRandom failed: %u (0x%X)"),
                _fname, dwError, dwError
            ));

        /* Generate pseudo random numbers */
        srand(*(unsigned int *)&s);

        pdw = (DWORD *)pBuffer;
        
        for(i = 0, dwLen2 = dwLen / sizeof(DWORD); i < dwLen2; i++)
        {
            pdw[i] ^= rand();
        }
    }

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpqos.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpqos.c
 *
 *  Abstract:
 *
 *    Implements the Quality Of Service family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpheap.h"
#include "rtpglobs.h"
#include "rtpque.h"
#include "lookup.h"
#include "rtpevent.h"
#include "rtpmisc.h"
#include "rtpreg.h"
#include "rtppt.h"

#include <winsock2.h>
#include <mmsystem.h> /* timeGetTime() */
#include <qos.h>
#include <qossp.h>
#include <qospol.h>
#include <stdio.h> /* sprintf() */

#include "rtpqos.h"

void RtpSetQosSendMode(RtpAddr_t *pRtpAddr, DWORD dwQosSendMode);

HRESULT RtpScaleFlowSpec(
        FLOWSPEC *pFlowSpec,
        DWORD     dwNumParticipants,
        DWORD     dwMaxParticipants,
        DWORD     dwBandwidth
    );

DWORD RtcpOnReceiveQosNotify(RtcpAddrDesc_t *pRtcpAddrDesc);

DWORD RtpValidateQosNotification(RtpQosNotify_t *pRtpQosNotify);

DWORD RtpSetMaxParticipants(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwMaxParticipants
    );

DWORD RtpAddDeleteSSRC(
        RtpAddr_t       *pRtpAddr,
        RtpQosReserve_t *pRtpQosReserve,
        DWORD            dwSSRC,
        BOOL             bAddDel
    );

BOOL RtpIsAllowedToSend(RtpAddr_t *pRtpAddr);

#if DBG > 0
void dumpFlowSpec(TCHAR_t *str, FLOWSPEC *pFlowSpec);
void dumpQOS(const TCHAR_t *msg, QOS *pQOS);
void dumpObjectType(const TCHAR_t *msg, char *ptr, unsigned int len);
#endif

HRESULT ControlRtpQos(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

DWORD AddQosAppID(
        IN OUT  char       *pAppIdBu