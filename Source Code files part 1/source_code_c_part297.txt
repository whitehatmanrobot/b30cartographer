r = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;

        pStgRoot1 = NULL;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // Now open this docfile on Async docfile API calls.

    // Get an empty ILockBytes

    if(S_OK == hr)
    {
        pCFileBytesEmpty = new CFileBytes;

        if(NULL == pCFileBytesEmpty)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // StgGetIFillLockBytesOnILockBytes expects an empty ILockBytes passed
    // to it.

    if(S_OK == hr)
    {
        hr = StgGetIFillLockBytesOnILockBytes(
                pCFileBytesEmpty, 
                &pIFillLockBytes);
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("StgGetIFillLockBytesOnILockBytes passed ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgGetIFillLockBytesOnILockBytes failed unexp, hr=0x%lx "),
            hr));
    }

    // Now copy from original ILockBytes into pIFillBytes

    if(S_OK == hr)
    {
        pCFileBytes = pTestILockBytesDF->_pCFileBytes;
        uli = pCFileBytes->GetSize();

        DH_ASSERT(0xFFFFFFFF != uli.LowPart);

        pBuffer = new BYTE [uli.LowPart];

        if(NULL == pBuffer)
        {
            hr = E_OUTOFMEMORY;
        }

        if(S_OK == hr)
        {
            memset(&uliOffset, 0, sizeof(ULARGE_INTEGER));

            hr = pCFileBytes->ReadAt(
                    uliOffset, 
                    (void *) pBuffer, 
                    uli.LowPart, 
                    &cbRead);
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("ILockBytes::ReadAt passed as exp. ")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("ILockBytes::ReadAt failed unexp, hr=0x%lx "),
                hr));
        }

        if(S_OK == hr)
        {
            hr = pCFileBytesEmpty->Init(
                    pVirtualDFRoot->GetVirtualCtrNodeName(),
                    OF_READWRITE);

            DH_HRCHECK(hr, TEXT("CFileBytes::Init")) ;
        }

        if(S_OK == hr)
        {
            hr = pIFillLockBytes->FillAppend(
                    (void *)pBuffer, 
                    cbRead, 
                    &cbWritten);
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("IFillLockBytes::FillAppend passed as exp. ")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IFillLockBytes::FillAppend failed unexp, hr=0x%lx "),
                hr));
        }

        if(S_OK == hr)
        {
            // notify ILockBytes that all data is copied down

            hr = pIFillLockBytes->Terminate(FALSE);
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("IFillLockBytes::Terminate passed as exp. ")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IFillLockBytes::Terminate failed unexp, hr=0x%lx "),
                hr));
        }
    }


    do
    {
        if(S_OK == hr)
        {
            hr = StgOpenAsyncDocfileOnIFillLockBytes(
                    pIFillLockBytes,
                    STGM_READ | STGM_SHARE_EXCLUSIVE,
                    0, 
                    &pStgAsyncDocFile);
        }

        if(E_PENDING == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("E_PENDING")));
            Sleep(1000);
        }

    } while(E_PENDING == hr);

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1,TEXT("StgOpenAsyncDocfileOnIFillLockBytes passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenAsyncDocfileOnIFillLockBytes failed unexp,hr=0x%lx"),
            hr));
    }

    // Get the CRC of docfile now after opening on custom ILockBytes asynch-
    // ronously

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(
                pStgAsyncDocFile,
                VERIFY_INC_TOPSTG_NAME,
                &dwCRC2);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Release the pointer

    if(NULL != pStgAsyncDocFile)
    {
        ulRef = pStgAsyncDocFile->Release();
        DH_ASSERT(0 == ulRef);
        pStgAsyncDocFile = NULL;
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
        if(dwCRC1 == dwCRC2)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's match")));

            DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_101 passed.")) );
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's don't match")));

            DH_LOG((LOG_FAIL, TEXT("Test variation ILKBTEST_101 failed.")) );

            hr = E_FAIL;
        }
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_101 failed, hr=0x%lx."),
            hr) );
    }

    // Release pIFillLockBytes.  This also releases and deletes the underlying
    // pCFileBytesEmpty.  Check if behaiour expected. 

    if(NULL != pIFillLockBytes)
    {
        pIFillLockBytes->Release();
        DH_ASSERT(0 == ulRef);
        pIFillLockBytes = NULL;
    }

    if(NULL != pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
        pCFileBytes = NULL;
    }

    // Delete pBuffer

    if(NULL != pBuffer)
    {
        delete []pBuffer;
        pBuffer = NULL;
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}

//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_102 
//
// Synopsis: The test first creates a normal docfile  on OLE provided lockbytes
//          and CRC's it.
//          The root docfile is opened upon a special ILockBytes that contains
//          a method allowing the test to simulate write failure during commit.
//          The docfile is modified, simulated write failure is turned on, and
//          the docfile is committed.  The root docfile is then released,
//          reinstantiated, and CRC'd.  The CRCs should match which verifies
//          that no changed were made to the effective docfile contents
//          when the commit failed.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  31-July-1996     NarindK     Created.
//
// Notes:    This test runs in trannsacted and transacted deny write mode
//
// New Test Notes:
// 1.  Old File: LTCMFAIL.CXX
// 2.  Old name of test : LegitTransactedCommitFail Test 
//     New Name of test : ILKBTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-102 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-102 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-102 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    DWORD           dwCRCOrg                = 0;
    DWORD           dwCRCAct                = 0;
    CFileBytes      *pCFileBytes            = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_102 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes test - DocFile Commit fail test ")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Calulcate CRC on this DocFile

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(
                pVirtualDFRoot->GetIStoragePointer(),
                VERIFY_INC_TOPSTG_NAME,
                &dwCRCOrg);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // Make new ILockBytes

    if (S_OK == hr)
    {
        pCFileBytes = new CFileBytes();

        if(NULL == pCFileBytes)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Initialize new ILockBytes

    if (S_OK == hr)
    {
        hr = pCFileBytes->Init(
                pVirtualDFRoot->GetVirtualCtrNodeName(),
                OF_READWRITE);

        DH_HRCHECK(hr, TEXT("CFileBytes::Init")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("Custom ILockBytes create/init passed ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Custom ILockBytes create/init failed unexp, hr=0x%lx "),
            hr));
    }

    // ReOpen the root using StgOpenStorageOnILockBytes call.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRootOnCustomILockBytes(
                NULL,
                dwRootMode,
                NULL,
                0,
                pCFileBytes);

        DH_HRCHECK(hr, TEXT("StgOpenStorageOnILockBytes"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorageOnILockBytes passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorageOnILockBytes failed unexp, hr = 0x%lx."),
            hr));
    } 

    // Modify the DocFile

    if(S_OK == hr)
    {
        hr = ModifyDocFile(
                pTestVirtualDF,
                pVirtualDFRoot,
                pTestVirtualDF->GetDataGenInteger(),
                pTestVirtualDF->GetDataGenUnicode(),
                dwStgMode,
                FALSE);
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ModifyDocFile passed ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDocFile failed unexp, hr=0x%lx "),
            hr));
    }

    if(S_OK == hr)
    {
        pCFileBytes->FailWrite0(1);

        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("Simulated failure during Commit in ILockBytes")));
    }

    // Commit

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }
            
    if(STG_E_WRITEFAULT == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("VirtualCtrNode::Commit failed as exp, hr=0x%lx "),
            hr));

        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit return unexp hr, hr=0x%lx "),
            hr));
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    if(NULL != pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
    }
       
    // Open root agian
 
    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, NULL, 0);
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Open passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open failed unexp, hr=0x%lx "),
            hr));
    }

    // Calulcate CRC on this DocFile

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(
                pVirtualDFRoot->GetIStoragePointer(),
                VERIFY_INC_TOPSTG_NAME,
                &dwCRCAct);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
        if(dwCRCAct == dwCRCOrg)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's match. ")));

            DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_102 passed.")) );
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's don't match. ")));

            DH_LOG((LOG_FAIL, TEXT("Test variation ILKBTEST_102 failed.")) );

            hr = E_FAIL;
        }
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_102 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_103 
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.  This tests attempts illegal opeartion
//           on custom ILockBytes based docfile.  It creates the custom Ilock
//           Bytes based docfile, then destroys the custom ILOckBytes and 
//           thereafter attempts to commit the DocFile
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  3-Aug-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// THIS TEST CAUSES GPF IN OLE32.DLL, HENCE NOT PART OF AUTOMATED TEST RUN
// BUG: 52216
//
// New Test Notes:
// 1.  Old File:i -none- 
// 2.  Old name of test : -none- 
//     New Name of test : ILKBTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-103 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-103 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-103 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-103 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    CFileBytes      *pCFileBytes            = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_103 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes test - Creating DocFile on ILockBytes")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_103, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgCreateDocFileOnILockBytes passed as exp.")));

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgCreateDocFileOnILockBytes failed unexp."),
            hr));

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    if(NULL != pTestILockBytesDF->_pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        pCFileBytes = pTestILockBytesDF->_pCFileBytes;

        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);

        DH_TRACE((DH_LVL_TRACE1, TEXT("Destoryed custom ILockBytes")));
    }
        
    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release root and all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_103 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_104 
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.  This tests attempts illegal opeartion
//           while tring to open asynchronously the docfile based on custom
//           ILockBytes 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  3-Aug-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// THIS TEST CAUSES GPF IN OLE32.DLL, HENCE NOT PART OF AUTOMATED TEST RUN
// BUG: 52279
//
// New Test Notes:
// 1.  Old File: -none- 
// 2.  Old name of test : -none- 
//     New Name of test : ILKBTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-104 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-104 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-104 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-104 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_104(int argc, char *argv[])
{

#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!ILKBTEST_104 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPSTORAGE       pStgAsyncDocFile        = NULL;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    CFileBytes      *pCFileBytes            = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_104 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes test - Creating DocFile on ILockBytes")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_104, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgCreateDocFileOnILockBytes passed as exp.")));

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgCreateDocFileOnILockBytes failed unexp."),
            hr));

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release root and all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Pass a invalid pointer in first parameter IFillLockBytes pointer. For
    // test case, we are passing NULL pointer.

    if(S_OK == hr)
    {
        hr = StgOpenAsyncDocfileOnIFillLockBytes(
                NULL,
                STGM_READ | STGM_SHARE_EXCLUSIVE,
                0,
                &pStgAsyncDocFile);
    } 

    if(STG_E_INVALIDPOINTER == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenAsyncDocfileOnIFillLockBytes failed exp, hr=0x%lx"),
            hr));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenAsyncDocfileOnIFillLockBytes returned unexp hr=0x%lx"),
            hr));
    }

    // Release the pointer

    if(NULL != pStgAsyncDocFile)
    {
        ulRef = pStgAsyncDocFile->Release();
        DH_ASSERT(0 == ulRef);
        pStgAsyncDocFile = NULL;
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_104 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup

    if(NULL != pTestILockBytesDF->_pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        pCFileBytes = pTestILockBytesDF->_pCFileBytes;
        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
    }
        
    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}

//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_105 
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.  This test opens the Asynchronous
//           docfile on ILockBytes
//
//           This test attempts illegal operation on StgGetIFillBytesOnILock
//           Bytes api call. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  6-Aug-1996     NarindK     Created.
//
// THIS TEST CAUSES GPF IN OLE32.DLL, HENCE NOT PART OF AUTOMATED TEST RUN
// BUG: 52513
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: - none -  
// 2.  Old name of test : -none- 
//     New Name of test : ILKBTEST_105 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-105 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-105 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-105 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-105 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_105(int argc, char *argv[])
{
#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!ILKBTEST_105 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else

    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    CFileBytes      *pCFileBytes            = NULL;
    IFillLockBytes  *pIFillLockBytes        = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_105"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_105 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes-Attempt illegal ops StgGetIFillBytesOnILOckBytes")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_105, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // Now open this docfile on Async docfile API calls.

    if(S_OK == hr)
    {
        pCFileBytes = pTestILockBytesDF->_pCFileBytes;

        hr = StgGetIFillLockBytesOnILockBytes(pCFileBytes, NULL);
    }

    if(S_OK != hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgGetIFillLockBytesOnILockBytes failed as exp hr = 0x%lx"),
            hr));

        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgGetIFillLockBytesOnILockBytes passed unexp, hr=0x%lx "),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_105 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_105 failed, hr=0x%lx."),
            hr) );
    }

    // Release ILockBytes

    if(NULL != pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_105 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}


//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_106 
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.  This test opens the Asynchronous
//           docfile on ILockBytes
//
//           This test attempts illegal operation on StgGetIFillBytesOnILock
//           Bytes api call.  Test needs to be integrated with ILKBTEST_105
//           once the bugs are fixed. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  6-Aug-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// THIS TEST CAUSES GPF IN OLE32.DLL, HENCE NOT PART OF AUTOMATED TEST RUN
// BUG: 52522
//
// New Test Notes:
// 1.  Old File: - none -  
// 2.  Old name of test : -none- 
//     New Name of test : ILKBTEST_106 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-106 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-106 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-106 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-106 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_106(int argc, char *argv[])
{

#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!ILKBTEST_106 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    CFileBytes      *pCFileBytes            = NULL;
    IFillLockBytes  *pIFillLockBytes        = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_106"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_106 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes-Attempt illegal ops StgGetIFillBytesOnILOckBytes")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_106, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // Now get IFillLockBytes.

    if(S_OK == hr)
    {
        pCFileBytes = pTestILockBytesDF->_pCFileBytes;

        hr = StgGetIFillLockBytesOnILockBytes(NULL, &pIFillLockBytes);
    }

    /* Commented out becuase OLE passes this

    if(S_OK != hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgGetIFillLockBytesOnILockBytes failed as exp hr = 0x%lx"),
            hr));

        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgGetIFillLockBytesOnILockBytes passed unexp, hr=0x%lx "),
            hr));
    }

    */

    if(S_OK == hr)
    {
        ulRef =   pIFillLockBytes->AddRef(); 
    }
 
    if(S_OK == hr)
    {
        ulRef =   pIFillLockBytes->Release(); 
    }
 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_106 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_106 failed, hr=0x%lx."),
            hr) );
    }

    // Release ILockBytes

    if(NULL != pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_106 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}


//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_107 
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.  This test calls StgIstorageILockBytes
//           API and tests it that ILockBytes array contains a storage object.
//           Also attempts illegal operations with StgIstorageILockBytes API.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  15-Aug-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: - none -  
// 2.  Old name of test : -none- 
//     New Name of test : ILKBTEST_107 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-107 /dfdepth:0-1 /dfstg:0-1 /dfstm:0-1
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-107 /dfdepth:0-1 /dfstg:0-1 /dfstm:0-1
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-107 /dfdepth:0-1 /dfstg:0-1 /dfstm:0-1
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-107 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_107(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    CFileBytes      *pCFileBytes            = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_107"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_107 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes-Attempt StgIsStorageILockBytes ")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_107, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Call StgIsStorageILockBytes API

    if(S_OK == hr)
    {
        pCFileBytes = pTestILockBytesDF->_pCFileBytes;

        DH_ASSERT(NULL != pCFileBytes);

        hr = StgIsStorageILockBytes(pCFileBytes);

        DH_HRCHECK(hr, TEXT("StgIsStorageILockBytes"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("StgIsStorageILockBytes passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgIsStorageILockBytes failed unexp, hr=0x%lx "),
            hr));
    }

    // Call StgIsStorageILockBytes API with NULL parameter

    if(S_OK == hr)
    {
        hr = StgIsStorageILockBytes(NULL);
    }

    if(STG_E_INVALIDPOINTER == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgIsStorageILockBytes failed as exp, hr=0x%lx. "),
            hr));

        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgIsStorageILockBytes didn't failed as exp, hr=0x%lx "),
            hr));

        hr = E_FAIL;
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_107 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_107 failed, hr=0x%lx."),
            hr) );
    }

    // Release ILockBytes

    if(NULL != pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.

        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_107 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    ILKBTEST_108 
//
// Synopsis: Legit/illegit Tests for StgGetIFillLockBytesOnFile OLE API.
//
// Arguments:[ulSeed]
//
// Returns:  HRESULT
//
// History:  16-Aug-1996     NarindK     Created.
//
// Notes:   
//
// THIS TEST CAUSES GPF IN OLE32.DLL, HENCE NOT PART OF AUTOMATED TEST RUN
// OLE BUG: 53647
//
// New Test Notes:
// 1.  Old File: -none- 
// 2.  Old name of test : -none- 
//     New Name of test : ILKBTEST_108 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /t:ILKBTEST-108
//
// BUGNOTE: Conversion: ILKBTEST-108 NO - not supported in nss
//
//-----------------------------------------------------------------------------


HRESULT ILKBTEST_108(ULONG ulSeed)
{
#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!ILKBTEST_108 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else

    HRESULT         hr                      = S_OK;
    IFillLockBytes  *pIFillLockBytes        = NULL;
    DG_STRING      *pdgu                   = NULL;
    USHORT          usErr                   = NULL;
    LPTSTR          ptszRootDocFileName     = NULL;
    LPOLESTR        poszRootDocFileName     = NULL;
    ULONG           ulRef                   = 0;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ILKBTEST_108"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_108 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Attempt legit/illegit tests StgGetIFillLockBytesOnFile API")));

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        pdgu = new(NullOnFail) DG_STRING(ulSeed);

        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Log the seed value

        usErr = pdgu->GetSeed(&ulSeed);
        DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);

        DH_TRACE((DH_LVL_TRACE1, TEXT("ILKBTEST_108 Seed: %lu"), ulSeed));
    }

    // StgGetIFillLockBytesOnFile called with null file name 

    if(S_OK == hr)
    {
        hr = StgGetIFillLockBytesOnFile(NULL, &pIFillLockBytes);
    }

    // OLE creates a temp file name and will pass this call. Shuld return S_OK. 

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgGetIFillLockBytesOnFile passed as exp ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgGetIFillLockBytesOnFile failed as exp hr = 0x%lx"),
            hr));
    }

    if(S_OK == hr)
    {
        ulRef =   pIFillLockBytes->AddRef(); 

        ulRef =   pIFillLockBytes->Release(); 
    }

    // Release the pointer

    if(NULL != pIFillLockBytes)
    {
        ulRef = pIFillLockBytes->Release();
        DH_ASSERT(0 == ulRef);
        pIFillLockBytes = NULL;
    }

    // Generate a new RootDocFile name

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH,&ptszRootDocFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(ptszRootDocFileName, &poszRootDocFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // StgGetIFillLockBytesOnFile called with non empty file name parameter
    // and valid out parameter.

    if(S_OK == hr)
    {
        hr = StgGetIFillLockBytesOnFile( poszRootDocFileName, &pIFillLockBytes);
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgGetIFillLockBytesOnFile passed as exp ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgGetIFillLockBytesOnFile failed unexp, hr=0x%lx"),
            hr));
    }

    // Release the pointer

    if(NULL != pIFillLockBytes)
    {
        ulRef = pIFillLockBytes->Release();
        DH_ASSERT(0 == ulRef);
        pIFillLockBytes = NULL;
    }

    // Delete string

    if(NULL != ptszRootDocFileName)
    {
        delete ptszRootDocFileName;
        ptszRootDocFileName = NULL;
    }

    if(NULL != poszRootDocFileName)
    {
        delete poszRootDocFileName;
        poszRootDocFileName = NULL;
    }

    // StgGetIFillLockBytesOnFile called with NULL second out parameter 
    // This should fail

    // Generate a new RootDocFile name

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH,&ptszRootDocFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(ptszRootDocFileName, &poszRootDocFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = StgGetIFillLockBytesOnFile( poszRootDocFileName, NULL);
    }

    if(STG_E_INVALIDPOINTER == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgGetIFillLockBytesOnFile fail as exp, hr=0x%lx "),
            hr));

        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgGetIFillLockBytesOnFile didn't failed as exp,hr=0x%lx"),
            hr));

        hr = E_FAIL;
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_108 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_108 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup

    // Delete string

    if(NULL != ptszRootDocFileName)
    {
        delete ptszRootDocFileName;
        ptszRootDocFileName = NULL;
    }

    if(NULL != poszRootDocFileName)
    {
        delete poszRootDocFileName;
        poszRootDocFileName = NULL;
    }

    // Delete datagen object

    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_108 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
#endif //_MAC
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\ivcptsts.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      ivcptsts.cxx
//
//  Contents:  storage base tests basically pertaining to IStorage/IStream copy
//             ops 
//
//  Functions:  
//
//  History:    21-July-1996     NarindK     Created.
//              27-Mar-97        SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

//----------------------------------------------------------------------------
//
// Test:    IVCPYTEST_100 
//
// Synopsis:Create a root docfile with a child IStorage and a child IStream
//         within the child IStorage.  Commit the root docfile.  Create a
//         new root docfile with a different name.
//         Revert the child IStorage.  CopyTo() the child IStorage to the
//         second root docfile.  Now revert the original root docfile and
//         attempt the same CopyTo() operation we just tried.  This should
//         fail with STG_E_REVERTED since the child IStorage should be
//         marked invalid from the root revert.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    21-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: ICPARINV.CXX
// 2.  Old name of test : IllegitCopyParentInvalid Test 
//     New Name of test : IVCPYTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:IVCPYTEST-100
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:VCPYTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: IVCPYTEST-100
//
// Note: In this test, we are not adjusting the VirtualDF tree as 
//       result of copyto opeartions as this test checks only the return
//       error codes as result of copyto operations 
//-----------------------------------------------------------------------------

HRESULT IVCPYTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    VirtualStmNode  *pvsnChildStgNewChildStm= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    LPTSTR          pChildStgNewChildStmName= NULL;
    ChanceDF        *pNewTestChanceDF       = NULL;
    VirtualDF       *pNewTestVirtualDF      = NULL;
    VirtualCtrNode  *pNewVirtualDFRoot      = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    DG_STRING      *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    CDFD            cdfd;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("IVCPYTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IVCPYTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,TEXT("Attempt invalid copyto fm child IStg to root")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for IVCPYTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Add a child storage to root.

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.  

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                dwStgMode | STGM_CREATE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }

    //    Adds a new stream to this child storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pChildStgNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pvcnRootNewChildStorage,
                pChildStgNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                &pvsnChildStgNewChildStm);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx."),
            hr));
    }

    // Commit the root storage.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Revert the child storage

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Revert();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Revert completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Revert unsuccessful, hr=0x%lx."),
            hr));
    }

    // Create a new destination docfile with a random name

    if(S_OK == hr)
    {
        // Generate random name for new docfile

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pNewRootDocFileName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pNewTestChanceDF = new ChanceDF();
        if(NULL == pNewTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = pTestChanceDF->GetSeed();
        cdfd.dwRootMode   = dwRootMode;

        hr = pNewTestChanceDF->Create(&cdfd, pNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("pNewTestChanceDF->Create"));
    }

    if (S_OK == hr)
    {
        pNewTestVirtualDF = new VirtualDF();
        if(NULL == pNewTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pNewTestVirtualDF->GenerateVirtualDF(
                pNewTestChanceDF,
                &pNewVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pNewTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Copy source docfile child storage to destination root docfile

    if(S_OK == hr)
    {
       hr = pvcnRootNewChildStorage->CopyTo(0, NULL, NULL, pNewVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
            hr));
    }

    // Revert the root source docfile

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Revert();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Revert completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Revert unsuccessful, hr=0x%lx."),
            hr));
    }

    // Attempt Copy source docfile child storage to destination root docfile

    if(S_OK == hr)
    {
       hr = pvcnRootNewChildStorage->CopyTo(0, NULL, NULL, pNewVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }

    if (STG_E_REVERTED == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo failed as exp, hr = 0x%lx"),
            hr));

        hr = S_OK;
    }
    else
    {
        fPass = FALSE;

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo not as exp, hr=0x%lx."),
            hr));
    }

    // Copy source root docfile to dest root docfile.

    if(S_OK == hr)
    {
       hr = pVirtualDFRoot->CopyTo(0, NULL, NULL, pNewVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close the source Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close the dest Root Docfile.

    if (S_OK == hr)
    {
        hr = pNewVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass)) 
    {
          DH_LOG((LOG_PASS, TEXT("Test variation IVCPYTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation IVCPYTEST_100 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete new Chance docfile tree

    if(NULL != pNewTestChanceDF)
    {
        hr2 = pNewTestChanceDF->DeleteChanceDocFileTree(
                pNewTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pNewTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pNewTestChanceDF;
        pNewTestChanceDF = NULL;
    }

    // Delete new Virtual docfile tree

    if(NULL != pNewTestVirtualDF)
    {
        hr2 = pNewTestVirtualDF->DeleteVirtualDocFileTree(pNewVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pNewTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pNewTestVirtualDF;
        pNewTestVirtualDF = NULL;
    }

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete strings

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if(NULL != pChildStgNewChildStmName)
    {
        delete pChildStgNewChildStmName;
        pChildStgNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IVCPYTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    IVCPYTEST_101 
//
// Synopsis:Create a root docfile with a child IStorage.  Make an attempt
//          attempt to copy the root docfile into the child.  This should 
//          result in an error.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    21-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, transacted deny write modes
//
// New Test Notes:
// 1.  Old File: ICPARTOC.CXX
// 2.  Old name of test : IllegitCopyParentToChild Test 
//     New Name of test : IVCPYTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:IVCPYTEST-101
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:IVCPYTEST-101
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:IVCPYTEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: IVCPYTEST-101
//
//-----------------------------------------------------------------------------

HRESULT IVCPYTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode              = 0;
    DG_STRING      *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("IVCPYTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IVCPYTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1,TEXT("Attempt invalid copyto fm Parent stg to child")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for IVCPYTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Add a child storage to root.

    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.  

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                dwStgMode | STGM_CREATE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }

    // Copy source root docfile to child storage.

    if(S_OK == hr)
    {
       hr = pVirtualDFRoot->CopyTo(0, NULL, NULL, pvcnRootNewChildStorage);

       DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }

    if (STG_E_ACCESSDENIED == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo failed as exp, hr=0x%lx."),
            hr));
    
        hr = S_OK;
    }
    else
    {
        fPass = FALSE;

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo passed unexp, hr=0x%lx."),
            hr));
    }

    // Close child storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close Root Storage

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass)) 
    {
          DH_LOG((LOG_PASS, TEXT("Test variation IVCPYTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation IVCPYTEST_101 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp string

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IVCPYTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\init.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       init.cxx
//
//  Contents:   OLE storage base tests
//
//  Functions:  main 
//              ProcessCmdLine
//              RunAllTests
//              RunSingleTest
//              RunAllCOMTests
//              RunSingleCOMTest
//              RunAllDFTests
//              RunSingleDFTest
//              RunAllAPITests
//              RunSingleAPITest
//              RunAllROOTTests
//              RunSingleROOTTest
//              RunAllSTMTests
//              RunSingleSTMTest
//              RunAllSTGTests
//              RunSingleSTGTest
//              RunAllVCPYTests
//              RunSingleVCPYTest
//              RunAllIVCPYTests
//              RunSingleIVCPYTest
//              RunAllENUMTests
//              RunSingleENUMTest
//              RunAllIROOTSTGTests
//              RunSingleIROOTSTGTest
//              RunAllHGLOBALTests
//              RunSingleHGLOBALTest
//              RunAllSNBTests
//              RunSingleSNBTest
//              RunAllMISCTests
//              RunSingleMISCTest
//              RunAllILKBTests
//              RunSingleILKBTest
//              RunAllFlatTests
//              RunSingleFlatTest
//
//  History:    20-May-1996     NarindK     Created.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include "init.hxx"

void    CheckCurrentDirectory (int argc, char *argv[]);
HRESULT ProcessCmdLine(int argc, char *argv[]) ;
HRESULT RunSingleTest(char *pszTestName, int argc, char *argv[]) ;
HRESULT RunAllTests(int argc, char *argv[]) ;

HRESULT RunAllCOMTests(int argc, char *argv[]);
HRESULT RunAllDFTests(int argc, char *argv[]);
HRESULT RunAllAPITests(int argc, char *argv[]);
HRESULT RunAllROOTTests(int argc, char *argv[]);
HRESULT RunAllSTMTests(int argc, char *argv[]);
HRESULT RunAllSTGTests(int argc, char *argv[]);
HRESULT RunAllVCPYTests(int argc, char *argv[]);
HRESULT RunAllIVCPYTests(int argc, char *argv[]);
HRESULT RunAllENUMTests(int argc, char *argv[]);
HRESULT RunAllIROOTSTGTests(int argc, char *argv[]);
HRESULT RunAllHGLOBALTests(int argc, char *argv[]);
HRESULT RunAllSNBTests(int argc, char *argv[]);
HRESULT RunAllMISCTests(int argc, char *argv[]);
HRESULT RunAllILKBTests(int argc, char *argv[]);
HRESULT RunAllFlatTests(int argc, char *argv[]);

HRESULT RunSingleCOMTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleDFTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleAPITest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleROOTTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleSTMTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleSTGTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleVCPYTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleIVCPYTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleENUMTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleIROOTSTGTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleHGLOBALTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleSNBTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleMISCTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleILKBTest(LONG lTestNum, int argc, char *argv[]);
HRESULT RunSingleFlatTest(LONG lTestNum, int argc, char *argv[]);

// Debug object

DH_DEFINE ;

// Logs:  The log file would be stgbase.log

#define LOG_FILE_NAME "/t:stgbase"

// Misc

BOOL g_fDebugMode = FALSE ;
BOOL g_fFirstFailureExits = FALSE ;
BOOL g_fDebugBreakAtTestStart = FALSE ;
BOOL g_fRunAllMode = FALSE ;
BOOL g_fDoLargeSeekAndWrite = FALSE;
BOOL g_fUseStdBlk = FALSE ;
BOOL g_fRevert = FALSE;
BOOL g_fDeleteTestDF = TRUE;
UINT g_uOpenCreateDF = FL_DISTRIB_NONE;


// Help text
LPCTSTR lptszStgbaseUsage = {
    TEXT("StgBase command line options:\n")
    TEXT("   /t:{testname} - Run {testname} Test\n")
    TEXT("   /FFX          - First Failure Exits\n")
    TEXT("   /BTS          - Break at Test Start\n")
    TEXT("   /DM           - Debug Mode\n")
    TEXT("   /stdblock     - Use std block sizes\n")
    TEXT("   /lgseekwrite  - Do large seek and write\n")
    TEXT("   /revert       - Do revert instead of commit\n")
    TEXT("   /CWD:cwd      - Make cwd Current Directory\n")
};



//+-------------------------------------------------------------------
//  Function:  main 
//
//  Synopsis:  main for stgbase test suite 
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   -1 if main fails 
//
//  History:  20-May-1996   NarindK     Created 
//--------------------------------------------------------------------

#ifdef _MAC

int __stdcall WinMain(HINSTANCE hInstance, 
		      HINSTANCE hPrevInstance, 
		      LPSTR lpCmdLine, 
		      int nCmdShow)
{
    int argc;
    char **argv;
    // the pointer is used for retrieving the command line
    // from the Arguments file on Mac    
    LPSTR       lpszCmdLine = NULL;
    int         count;

#else

int __cdecl main(int argc, char *argv[])
{

#endif // _MAC

    HRESULT     hr          = S_OK;

    // Check if we should change CurrentDirectory, before creating the logfile
    CheckCurrentDirectory (argc, argv);

    // Initialize our log object
    DH_CREATELOGCMDLINE( LOG_FILE_NAME );
    hr = InitializeDebugObject();
    DH_ASSERT( S_OK == hr);

    if (DH_GETLOGLOC == DH_LOC_TERM)
    {
        DH_SETLOGLOC( DH_LOC_TERM | DH_LOC_LOG) ;
    }
    if (DH_GETTRACELOC == DH_LOC_TERM)
    {
        DH_SETTRACELOC( DH_LOC_TERM | DH_LOC_LOG) ;
    }

    // ProcessCmdLine() will run all the tests we
    // need to run...

    if (S_OK == hr)
    {

#ifdef _MAC

        lpszCmdLine = GetCommandLine();

        if(lpszCmdLine == NULL)
        {
            hr = E_FAIL;
            DH_LOG((LOG_INFO, TEXT("Failed to get the command line.\r")) ) ;
        }
         
        if(S_OK == hr)
        {
            hr = CmdlineToArgs(lpszCmdLine, &argc, &argv);
        }

#endif //_MAC

        // init our StgAPI wrapper - to determine whether we want to call
        //  StgAPIs or StgExAPIs for open/create.
        StgInitStgFormatWrapper (argc, argv);

        if(S_OK == hr)
        {
            hr = ProcessCmdLine(argc, argv) ;
        }
    }

    // Log our stats regarding how many tests passed, failed
    // aborted, etc, etc.

    DH_LOGSTATS ;

    // BUGBUG:  The following code that has been commented out reads from a
    // test.ini file and runs different tests as specified there.

    /*
    {
	int         targc       = 0;
	char        **targv     = NULL;
	ULONG       i           = 0;
	    char        buffer[256];
	    char        testName[20];

	for (;;)
	{
	    sprintf (testName, "Test%lu", i);

	    i++;

	    GetPrivateProfileStringA(
				"MyTests", 
								testName,  
								"Fail", 
								buffer, 
								sizeof(buffer), 
								"test.ini" );  

	    if(0 == strcmp(buffer, "EndTest"))
	    {
		break;
	    }
	
	    hr = CmdlineToArgs(buffer, &targc, &targv) ;

	    if(S_OK == hr)
	    {
		hr = RunTest(targc, targv);
	    }

	    // CmdlineToArgs allocates a bunch of strings and a table of
	    // pointers to them, so we need to free them.

	    if (NULL != targv)
	    { 
		for (i=0; i<targc; i++)
		{
		    delete targv[i] ;
		}

		delete [] targv ;
	    }

	    }
    }

    */  
 
    // End of commented code for reading from win.ini file.

#ifdef _MAC

    // cleanup for arguments strings
   if (NULL != argv)
   {
       for (count=0; count<argc; count++)
       {
	   delete argv[count] ;
       }

       delete [] argv ;
   }

#endif //_MAC
    
    return (int)hr;
}

//+-------------------------------------------------------------------
//  Function:  CheckCurrentDirectory 
//
//  Synopsis:  look at cmdline and if requested make CWD as specd
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   void
//
//  History:  27-Jul-1997   SCousens     Created 
//--------------------------------------------------------------------
void CheckCurrentDirectory (int argc, char *argv[])
{
    HRESULT   hr = S_OK;
    CBaseCmdlineObj Ccwd        (OLESTR("cwd"), 
            OLESTR("Make this Current Working Directory"), 
            OLESTR("none"));
    CBaseCmdlineObj *CArgList[] =
    {
        &Ccwd
    };
    CCmdline CCmdlineArgs(argc, argv);

    if (CMDLINE_NO_ERROR != CCmdlineArgs.QueryError())
    {
        hr = E_FAIL ;
    }

    if (S_OK == hr)
    {
        if (CMDLINE_NO_ERROR != CCmdlineArgs.Parse(CArgList,
                ARRAYSIZE (CArgList),
                FALSE))
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr && TRUE == Ccwd.IsFound ())
    {
        // Try changing current working directory
        LPTSTR  ptszCWD;
        HRESULT hr = OleStringToTString (Ccwd.GetValue(), &ptszCWD);
        if (S_OK == hr)
        {
            if (FALSE == SetCurrentDirectory (ptszCWD))
            {
                DH_TRACE ((DH_LVL_ERROR,
                        TEXT("SetCurrentDirectory to %s FAILED. hr=%#lx"),
                        ptszCWD,
                        HRESULT_FROM_WIN32 (GetLastError ())));
            }
            else
            {
                DH_TRACE ((DH_LVL_TRACE1,
                        TEXT("CurrentWorkingDirectory now:%s"),
                        ptszCWD));
            }
            delete ptszCWD;
            ptszCWD = NULL;
        }
    }
    return;
}


//+-------------------------------------------------------------------
//  Function:  RunTestAltPath 
//
//  Synopsis: -Look at cmdline for /altpath switch.
//            -If not found, call the specified test with NULL for
//             the alternate path - thus using cwd.
//            -If found with nothing specified, enumerate all local
//             drives and use the root of each drive as alternate.
//            -If found with drive letters specified, use the 
//             specified drive letters.
//            -Currently we only look at the 1st char, and ',;' are
//             the acceptible delimiters
//               eg: /altpath     enumerate and use all drives
//               eg: /altpath:c:;d,e  use C, D and E drives.
//
//  Arguments: [argc]
//             [argv]
//             [pfn]  - pointer to the test function to call
//
//  Returns:   HRESULT whatever the test returned.
//             If multiple tests ran, returns first error.
//
//  Notes:     The test functions must be modified to accept
//             a third parameter, and then optionally use 
//             it when creating a new file.
//
//  History:  14-Oct-1997   SCousens     Created 
//--------------------------------------------------------------------
HRESULT RunTestAltPath(int argc, char *argv[], 
        HRESULT (*pfnTestFunc) (int argc, char*argv[], LPTSTR ptAltPath))
{
    ULONG   ulDriveMap;
    TCHAR   szDrive[]  = {TEXT("C:\\")};
    HRESULT hr         = S_OK;
    HRESULT hrTest     = S_OK;
    LPTSTR  ptAltPath  = NULL;
    BOOL    fAltFound  = FALSE;
    
    DH_FUNCENTRY (&hr, DH_LVL_DFLIB, TEXT("RunTestAltPath"));

    // look for /altpath in commandline
    CBaseCmdlineObj Caltpath (OLESTR("AltPath"), 
            OLESTR("Use a different drive/path"), 
            OLESTR("none"));
    CBaseCmdlineObj *CArgList[] =
    {
        &Caltpath              // just for spewage
    };
    CCmdline CCmdlineArgs(argc, argv);

    ptAltPath = NULL;
    if (CMDLINE_NO_ERROR == CCmdlineArgs.QueryError())
    {
        if (CMDLINE_NO_ERROR ==
                CCmdlineArgs.Parse(CArgList, ARRAYSIZE(CArgList), FALSE))
        {
            if (Caltpath.IsFound ())
            {
                DH_TRACE ((DH_LVL_TRACE4, TEXT("/altpath option found on cmdline")));
                HRESULT hr = OleStringToTString (Caltpath.GetValue (), &ptAltPath);
                DH_HRCHECK (hr, TEXT("OleStringToTString"));
                fAltFound = TRUE;
            }
        }
    }

    // if altpath not on the cmdline, just call the test and bail.
    if (!fAltFound)
    {
        DH_TRACE ((DH_LVL_TRACE4, TEXT("no /altpath option. Using CWD")));
        hr = (*pfnTestFunc)(argc, argv, NULL);
        return hr;
    }

    //if altpath has something, get what we got.
    ulDriveMap = 0;
    if (NULL != ptAltPath)
    {
        // make upper case so math below is easier
        CharUpperBuff(ptAltPath, _tcslen(ptAltPath));
        LPTSTR ptr = _tcstok (ptAltPath, TEXT(";,"));
        // take string and fill DriveMap with specified drives
        while (NULL != ptr)
        {
            if (*ptr >= TCHAR('A') && *ptr <= TCHAR('Z'))
            {
                // c: -> 0x4, d: -> 0x8, e: -> 0x10
                ulDriveMap = ulDriveMap | (0x01 << (*ptr-TCHAR('C')));
                DH_TRACE ((DH_LVL_TRACE4, TEXT("Processed drive %C:"), *ptr));
            }
            ptr = _tcstok (NULL, TEXT(";,"));
        }
    }

    // if /altpath: not found, enum local disks and use them all.
    if (0 == ulDriveMap)
    {
        DH_TRACE ((DH_LVL_TRACE4, TEXT("Enumerating local drives")));
        ulDriveMap = EnumLocalDrives()>>2; //ignore A:, B:
    }
    DH_TRACE ((DH_LVL_TRACE4, TEXT("Drive map : %#x"), ulDriveMap));
    while (ulDriveMap)
    {
        if (ulDriveMap & 0x01)
        {
            DH_TRACE ((DH_LVL_TRACE4, TEXT("Testing to:%s"), szDrive));
            hrTest = (*pfnTestFunc)(argc, argv, szDrive);
            hr = FirstError (hr, hrTest);
        }
        ++*szDrive;
        ulDriveMap = ulDriveMap>>1;
    }

    // cleanup
    delete []ptAltPath;

    // return an error if any of the tests failed.
    return hr;
}

//+-------------------------------------------------------------------
//  Function:  ProcessCmdLine
//
//  Synopsis:  Analyzes the command line and takes appropriate action
//             depending on what is there.
//
//  Arguments: [argc]
//             [argv] -      The command line argument list.  Valid switches
//                            are:
//
//                            1.  /T:{string defining test num}
//
//                                For test num strings, see
//                                %ctolestg%\docs
//
//                                If no /T: switches are on the command
//                                line, all the tests are run.
//
//                                An unlimited number of tests can be
//                                specified on the command line using
//                                the /t: switches
//
//                            2.  /BTS - Break when each test starts
//
//                            3.  /DM  - Debug mode.  In debug mode, the
//                                       test DLL provides more debugging
//                                       information than normal about the
//                                       state of the tests.
//
//                            4.  /FFX - First test failure exits the test
//                                       suite
//
//                            5.  /stdblock - If standard block sizes from
//                                        array ausSIZE_ARRAY needs to be
//                                        used for test.
//
//                            6. /lgseekwrite - if large seek and write needs
//                                        to be done in test.
//
//                            7. /revert - Do revert operation in tests
//                                        instead of commit, if flag set.
//              
//                            NOTE: For OTHER valid switches, please
//                                  see documentation. 
//
//  Returns:   S_OK if the function succeeds, another HRESULT otherwise
//
//  History:   20-May-1996   NarindK    Enhanced for stgbase test suite
//
//--------------------------------------------------------------------

HRESULT ProcessCmdLine(int argc, char *argv[])
{
    HRESULT     hr          = S_OK ;
    INT         i           = 0;
    INT         cTestsRun   = 0 ;
    INT         cParseErrors= 0 ;
    int         targc       = 0;
    char        **targv     = NULL;

    //
    // If we are running on DEBUG OLE, set the debug flag to TRUE
    //

    if (S_OK == RunningDebugOle())
    {
        g_fDebugMode = TRUE ;
    }

    //
    // First, check for any switches
    //

    if (S_OK == hr)
    {
        CBoolCmdlineObj Cbts        (OLESTR("BTS"),        OLESTR(""), OLESTR("FALSE")) ;
        CBoolCmdlineObj Cffx        (OLESTR("FFX"),        OLESTR(""), OLESTR("FALSE")) ;
        CBoolCmdlineObj Cdm         (OLESTR("DM"),         OLESTR(""), OLESTR("FALSE")) ;
        CBoolCmdlineObj Chlp        (OLESTR("HELP"),       OLESTR("get help"), OLESTR("FALSE")) ;
        CBoolCmdlineObj Chelp       (OLESTR("?"),          OLESTR("get help"), OLESTR("FALSE")) ;
        CBoolCmdlineObj Cstdblk     (OLESTR("stdblock"),   OLESTR(""), OLESTR("FALSE")) ;
        CBoolCmdlineObj Clgseekwrite(OLESTR("lgseekwrite"),OLESTR(""), OLESTR("FALSE")) ;
        CBoolCmdlineObj Crevert     (OLESTR("revert"),     OLESTR(""), OLESTR("FALSE")) ;
        CBaseCmdlineObj COpenDF (OLESTR("Distrib"), 
                OLESTR("Distributed tests. Create/Open docfile"), 
                OLESTR("none"));
        // these are checked and dealt with in chancedf. look here so we can 
        // put some meaningful useful information into the log
        CBaseCmdlineObj Cmode (OLESTR("dfRootMode"), 
                OLESTR("Direct, Transacted modes"), 
                OLESTR("none"));
        CBaseCmdlineObj Ctest (OLESTR("t"), 
                OLESTR("Test name"), 
                OLESTR("none"));

        CBaseCmdlineObj *CArgList[] =
        {
            &Cmode,             // just for spewage
            &Ctest,             // just for spewage
            &COpenDF,           // 2 phase testing (conversion over redirector)
            &Cbts,              // Break at test start
            &Cffx,              // Break at first failure
            &Cdm,               // Debug mode
            &Chlp,              // Help
            &Chelp,             // display help?
            &Cstdblk,           // Standard block size
            &Clgseekwrite,      // Do large seek and write
            &Crevert            // Revert instead of committing 
        } ;

        CCmdline CCmdlineArgs(argc, argv);

        if (CMDLINE_NO_ERROR != CCmdlineArgs.QueryError())
        {
            hr = E_FAIL ;
        }

        if (S_OK == hr)
        {
            if (CMDLINE_NO_ERROR !=
                    CCmdlineArgs.Parse(
                    CArgList,
                    ( sizeof(CArgList) / sizeof(CArgList[0]) ),
                    FALSE))
            {
                hr = E_FAIL ;
            }

            if (S_OK == hr)
            {
                g_fDebugBreakAtTestStart = *(Cbts.GetValue()) ;
                g_fFirstFailureExits = *(Cffx.GetValue()) ;

                g_fDebugMode = FALSE;
                if (FALSE != *(Cdm.GetValue()))
                {
                    g_fDebugMode = TRUE ;
                }

                if (TRUE == Chelp.IsFound() || TRUE == Chlp.IsFound())
                {
                    // Help switch
                    // We are a console app. Dump to stdout.
                    // and debug window for good measure.
                    _tprintf (TEXT("%s\r\n"), lptszStgbaseUsage);
                    OutputDebugString ((LPTSTR)lptszStgbaseUsage);
                    _tprintf (TEXT("%s"), GetDebugHelperUsage());
                    OutputDebugString ((LPTSTR)GetDebugHelperUsage());
                    //
                    // If someone asked for help, don't run any
                    // of the tests
                    //
                    hr = S_FALSE ;
                }

                g_fUseStdBlk = FALSE;
                if (FALSE != *(Cstdblk.GetValue()))
                {
                    g_fUseStdBlk = TRUE ;
                }
                g_fDoLargeSeekAndWrite = FALSE;
                if (FALSE != *(Clgseekwrite.GetValue()))
                {
                    g_fDoLargeSeekAndWrite = TRUE ;
                }
                g_fRevert = FALSE;
                if (FALSE != *(Crevert.GetValue()))
                {
                    g_fRevert = TRUE ;
                }

                g_uOpenCreateDF = FL_DISTRIB_NONE;
                g_fDeleteTestDF = TRUE;
                if (TRUE == COpenDF.IsFound ())
                {
                    if (NULL == _olestricmp (COpenDF.GetValue (), OLESTR(SZ_DISTRIB_OPEN)))
                    {
                        g_uOpenCreateDF = FL_DISTRIB_OPEN;
                    }
                    else if (NULL == _olestricmp (COpenDF.GetValue (), OLESTR(SZ_DISTRIB_OPENNODELETE)))
                    {
                        g_uOpenCreateDF = FL_DISTRIB_OPEN;
                        g_fDeleteTestDF = FALSE;
                    }
                    else if (NULL ==_olestricmp (COpenDF.GetValue (), OLESTR(SZ_DISTRIB_CREATE)))
                    {
                        g_uOpenCreateDF = FL_DISTRIB_CREATE;
                    }
                }

#ifdef UNICODE  //dont bother with OleStringToTString if TString is ansi.
                // for spewage only
                if (TRUE == Ctest.IsFound () && TRUE == Cmode.IsFound ())
                {
                    DH_TRACE ((DH_LVL_ALWAYS, 
                            TEXT("Running %s in %s mode"), 
                            Ctest.GetValue(), 
                            Cmode.GetValue()));
                }
#endif
            }
        }
    }

    //
    // Start up the tests 
    //

    targc = argc;
    targv = argv;

    if (S_OK == hr)
    {
        for (i=0; i<argc; i++)
        {
            //
            // Switch must be in the form "{- | /}T:{test name}"
            //

            if ( ('/' != argv[i][0]) && ('-' != argv[i][0]) )
            {
                continue ;
            }

            if ( ('t' != argv[i][1]) && ('T' != argv[i][1]) )
            {
                continue ;
            }

            if (':' != argv[i][2])
            {
                continue ;
            }

            if (0 == argv[i][3])
            {
                cParseErrors++ ;
                continue ;
            }

            hr = RunSingleTest(&argv[i][3], targc, targv) ;

            // test failed. let the world know what tried to do
            if (S_OK != hr)
            {
                LPTSTR      lpszCmdLine = GetCommandLine();
                if(lpszCmdLine != NULL)
                {
                    DH_LOG((LOG_INFO, TEXT("CommandLine:%s"), lpszCmdLine ));
                }
            }

            if ( (S_OK != hr) && (FALSE != g_fFirstFailureExits) )
            {
                break ;
            }

            cTestsRun++ ;
        }
    }

    // If we did not find any tests to run and there were
    // no parse errors, then run all the tests
    //

    if (S_OK == hr)
    {
        g_fRunAllMode = FALSE;
        if ( (0 == cTestsRun) && (0 == cParseErrors) )
        {
            g_fRunAllMode = TRUE ;

            hr = RunAllTests(targc, targv) ;
        }
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllTests
//
//  Synopsis:  Runs all tests
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   S_OK if the function succeeds, another HRESULT otherwise
//
//  History:   28-Jul-1995   AlexE   Created
//             20-May-1996   NarindK Adapted for stgbase test suite
//--------------------------------------------------------------------

HRESULT RunAllTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    // Run "COM" tests

    hr = RunAllCOMTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }
    
    // Run "DF" tests

    hr = RunAllDFTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }
    
    // Run "API" tests

    hr = RunAllAPITests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "ROOT" tests

    hr = RunAllROOTTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "STM" tests

    hr = RunAllSTMTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "STG" tests

    hr = RunAllSTGTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "VCPY" tests

    hr = RunAllVCPYTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "IVCPY" tests

    hr = RunAllIVCPYTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "ENUM" tests

    hr = RunAllENUMTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "IROOTSTG" tests

    hr = RunAllIROOTSTGTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }


    // Run "HGLOBAL" tests

    hr = RunAllHGLOBALTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "SNB" tests

    hr = RunAllSNBTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "MISC" tests

    hr = RunAllMISCTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Run "FLAT" tests

    hr = RunAllFlatTests(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleTest
//
//  Synopsis:  Runs a single test
//
//  Arguments: [pszTestName] - The test name string.
//             [argc]
//             [argv] 
//
//  Returns:   S_OK if the function succeeds, another HRESULT otherwise
//
//  History:   28-Jul-1995   AlexE   Created
//             20-May-1996   NarindK Adapted for stgbase test suite
//--------------------------------------------------------------------

HRESULT RunSingleTest(char *pszTestName, int argc, char *argv[])
{
    char *pszNum = NULL ;
    LONG lNum = -1 ;

    //
    // The test name should be in the form
    //
    //     "{description string}{-}{test number}"
    //

    pszNum = pszTestName ;

    while (0 != *pszNum)
    {
	if ('-' == *pszNum)
	{
	    *pszNum++ = 0 ;

	    break ;
	}

	pszNum++ ;
    }

    if (0 == *pszNum)
    {
        DH_LOG((LOG_INFO, TEXT("No test number in test name string")) ) ;
        return E_INVALIDARG ;
    }

    //
    // Now see if the test name part is one we recognize.
    // If it is, dispatch the test.
    //

    if (S_OK != PrivAtol(pszNum, &lNum))
    {
        DH_LOG((LOG_INFO, TEXT("Invalid number in test name string")) ) ;
        return E_INVALIDARG ;
    }

    if (0 == _strcmpi(pszTestName, "COMTEST"))
    {
        return RunSingleCOMTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "DFTEST"))
    {
        return RunSingleDFTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "APITEST"))
    {
        return RunSingleAPITest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "ROOTTEST"))
    {
        return RunSingleROOTTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "STMTEST"))
    {
        return RunSingleSTMTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "STGTEST"))
    {
        return RunSingleSTGTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "VCPYTEST"))
    {
        return RunSingleVCPYTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "IVCPYTEST"))
    {
        return RunSingleIVCPYTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "ENUMTEST"))
    {
        return RunSingleENUMTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "IROOTSTGTEST"))
    {
        return RunSingleIROOTSTGTest(lNum, argc, argv) ;
    }
    if (0 == _strcmpi(pszTestName, "HGLOBALTEST"))
    {
        return RunSingleHGLOBALTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "SNBTEST"))
    {
        return RunSingleSNBTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "MISCTEST"))
    {
        return RunSingleMISCTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "ILKBTEST"))
    {
        return RunSingleILKBTest(lNum, argc, argv) ;
    }
    else
    if (0 == _strcmpi(pszTestName, "FLATTEST"))
    {
        return RunSingleFlatTest(lNum, argc, argv) ;
    }
    else
    {
        DH_LOG((LOG_INFO, TEXT("Invalid test name string")) ) ;
        return E_INVALIDARG ;
    }
}


//+-------------------------------------------------------------------
//  Function:  RunAllCOMTests
//
//  Synopsis:  Runs all "COM" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   28-May-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllCOMTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = COMTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = COMTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = COMTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = COMTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = COMTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = COMTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = COMTEST_106(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllDFTests
//
//  Synopsis:  Runs all "DF" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   3-June-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllDFTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = DFTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = DFTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = DFTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // Obtain Seed from CommandLine and call DFTEST_107

    ULONG  ulSeed  =  0;

    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

    hr = DFTEST_103(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = DFTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = DFTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = DFTEST_106(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = DFTEST_107(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }


    hr = DFTEST_108(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    
    hr = DFTEST_109(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllAPITests
//
//  Synopsis:  Runs all "API" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   18-June-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllAPITests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = APITEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = APITEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = APITEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = APITEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = APITEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllROOTTests
//
//  Synopsis:  Runs all "ROOT" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   24-June-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllROOTTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = ROOTTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ROOTTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ROOTTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ROOTTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ROOTTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllSTMTests
//
//  Synopsis:  Runs all "STM" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   28-June-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllSTMTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = STMTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STMTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STMTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STMTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STMTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

	hr = STMTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

	hr = STMTEST_106(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STMTEST_107(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

	hr = STMTEST_108(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

	hr = STMTEST_109(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllSTGTests
//
//  Synopsis:  Runs all "STG" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   10-July-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllSTGTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = STGTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_107(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_108(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_109(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = STGTEST_110(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllVCPYTests
//
//  Synopsis:  Runs all "VCPY" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   15-July-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllVCPYTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = VCPYTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = VCPYTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = VCPYTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = VCPYTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = VCPYTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = VCPYTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = VCPYTEST_106(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllIVCPYTests
//
//  Synopsis:  Runs all "IVCPY" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   21-July-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllIVCPYTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = IVCPYTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = IVCPYTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllENUMTests
//
//  Synopsis:  Runs all "ENUM" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   22-July-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllENUMTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = ENUMTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ENUMTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ENUMTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ENUMTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ENUMTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllIROOTSTGTests
//
//  Synopsis:  Runs all "IROOTSTG" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   25-July-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllIROOTSTGTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = IROOTSTGTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = IROOTSTGTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = IROOTSTGTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = IROOTSTGTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}


//+-------------------------------------------------------------------
//  Function:  RunAllHGLOBALTests
//
//  Synopsis:  Runs all "HGLOBAL" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   25-July-1996   T-ScottG  Created 
//--------------------------------------------------------------------


HRESULT RunAllHGLOBALTests(int argc, char *argv[])
{
    HRESULT             hr              =           S_OK ;
    ULONG               ulSeed           =           0;
    INT                 cFailures       =           0;

    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

    hr = HGLOBALTEST_100(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    /* OLE bugs

    hr = HGLOBALTEST_101(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    */

    hr = HGLOBALTEST_110(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = HGLOBALTEST_120(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    /* OLE bugs

    hr = HGLOBALTEST_121(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }
    */

    hr = HGLOBALTEST_130(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = HGLOBALTEST_140(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = HGLOBALTEST_150(ulSeed) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }


    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllSNBTests
//
//  Synopsis:  Runs all "SNB" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv]
//
//  Returns:   HRESULT
//
//  History:   26-July-1996   Jiminli Created
//--------------------------------------------------------------------

HRESULT RunAllSNBTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = SNBTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = SNBTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = SNBTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = SNBTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllMISCTests
//
//  Synopsis:  Runs all "MISC" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv]
//
//  Returns:   HRESULT
//
//  History:   5-Aug-1996   Jiminli Created
//--------------------------------------------------------------------

HRESULT RunAllMISCTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = MISCTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = MISCTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = MISCTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = MISCTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = MISCTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = MISCTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }
    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunAllILKBTests
//
//  Synopsis:  Runs all "ILKB" tests.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   5-Aug-1996   NarindK Created 
//--------------------------------------------------------------------

HRESULT RunAllILKBTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = ILKBTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ILKBTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = ILKBTEST_102(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }


    /* OLE BUG : 52216

    hr = ILKBTEST_103(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    */

    /* OLE Bug 52279

    hr = ILKBTEST_104(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    */

    /* OLE Bug 

    hr = ILKBTEST_105(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    */

    /* OLE Bug 

    hr = ILKBTEST_106(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    */

    hr = ILKBTEST_107(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    /* OLE Bug 

    hr = ILKBTEST_108(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    */

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}


//+-------------------------------------------------------------------
//  Function:  RunAllFlatTests
//
//  Synopsis:  Runs all "FLAT" tests.  
//
//  Arguments: [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:    22-Jan-1998    BogdanT created
//--------------------------------------------------------------------

HRESULT RunAllFlatTests(int argc, char *argv[])
{
    HRESULT hr = S_OK ;
    INT cFailures = 0 ;

    hr = FLATTEST_100(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    hr = FLATTEST_101(argc, argv) ;

    if (S_OK != hr)
    {
	if (FALSE != g_fFirstFailureExits)
	{
	    return hr ;
	}
	else
	{
	    cFailures++ ;
	}
    }

    // If the last test passed, but a previous test
    // failed, return a failure code for the whole
    // operation

    if ( (S_OK == hr) && (0 != cFailures) )
    {
	hr = E_FAIL ;
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleCOMTest
//
//  Synopsis:  Runs single "COMTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   28-May-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleCOMTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = COMTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = COMTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = COMTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = COMTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = COMTEST_104(argc, argv) ;

	    break ;
	}

	case ( 105 ) :
	{
	    hr = COMTEST_105(argc, argv) ;

	    break ;
	}

	case ( 106 ) :
	{
	    hr = COMTEST_106(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid COMTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleDFTest
//
//  Synopsis:  Runs single "DFTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   3-June-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleDFTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;
    ULONG       ulSeed  =  0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = DFTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = DFTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = DFTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

	    hr = DFTEST_103(ulSeed) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = DFTEST_104(argc, argv) ;

	    break ;
	}

	case ( 105 ) :
	{
	    hr = DFTEST_105(argc, argv) ;

	    break ;
	}

	case ( 106 ) :
	{
	    hr = DFTEST_106(argc, argv) ;

	    break ;
	}

	case ( 107 ) :
	{
	    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

	    hr = DFTEST_107(ulSeed) ;

	    break ;
	}

	case ( 108 ) :
	{
	    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

	    hr = DFTEST_108(ulSeed) ;

	    break ;
	}

	case ( 109 ) :
	{
	    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

	    hr = DFTEST_109(ulSeed) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid DFTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleAPITest
//
//  Synopsis:  Runs single "APITEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   18-June-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleAPITest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = APITEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = APITEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = APITEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = APITEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = APITEST_104(argc, argv) ;

	    break ;
	}

    case 200:
    {
        hr = APITEST_200(argc, argv) ;
        break ;
    }

    case 201:
    {
        hr = APITEST_201(argc, argv) ;
        break ;
    }

    case 202:
    {
        hr = APITEST_202(argc, argv) ;
        break ;
    }

    case 203:
    {
        hr = APITEST_203(argc, argv) ;
        break ;
    }

    case 204:
    {
        hr = APITEST_204(argc, argv) ;
        break ;
    }

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid APITEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleROOTTest
//
//  Synopsis:  Runs single "ROOTTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   24-June-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleROOTTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = ROOTTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = ROOTTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = ROOTTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = ROOTTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = ROOTTEST_104(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid ROOTTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleSTMTest
//
//  Synopsis:  Runs single "STMTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   28-June-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleSTMTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = STMTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = STMTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = STMTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = STMTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = STMTEST_104(argc, argv) ;

	    break ;
	}

		case ( 105 ) :
	{
	    hr = STMTEST_105(argc, argv) ;

	    break ;
	}

		case ( 106 ) :
	{
	    hr = STMTEST_106(argc, argv) ;

	    break ;
	}

	case ( 107 ) :
	{
	    hr = STMTEST_107(argc, argv) ;

	    break ;
	}

		case ( 108 ) :
	{
	    hr = STMTEST_108(argc, argv) ;

	    break ;
	}

		case ( 109 ) :
	{
	    hr = STMTEST_109(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid STMTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleSTGTest
//
//  Synopsis:  Runs single "STGTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   10-July-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleSTGTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = STGTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = STGTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = STGTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = STGTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = STGTEST_104(argc, argv) ;

	    break ;
	}

	case ( 105 ) :
	{
	    hr = STGTEST_105(argc, argv) ;

	    break ;
	}

	case ( 107 ) :
	{
	    hr = STGTEST_107(argc, argv) ;

	    break ;
	}

	case ( 108 ) :
	{
	    hr = STGTEST_108(argc, argv) ;

	    break ;
	}

	case ( 109 ) :
	{
	    hr = STGTEST_109(argc, argv) ;

	    break ;
	}

	case ( 110 ) :
	{
	    hr = STGTEST_110(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid STGTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleVCPYTest
//
//  Synopsis:  Runs single "VCPYTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   15-July-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleVCPYTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = VCPYTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = VCPYTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = VCPYTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = VCPYTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = VCPYTEST_104(argc, argv) ;

	    break ;
	}

	case ( 105 ) :
	{
	    hr = VCPYTEST_105(argc, argv) ;

	    break ;
	}

	case ( 106 ) :
	{
	    hr = VCPYTEST_106(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid VCPYTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleIVCPYTest
//
//  Synopsis:  Runs single "IVCPYTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   21-July-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleIVCPYTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = IVCPYTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = IVCPYTEST_101(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid IVCPYTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleENUMTest
//
//  Synopsis:  Runs single "ENUMTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   22-July-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleENUMTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = ENUMTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = ENUMTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = ENUMTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = ENUMTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = ENUMTEST_104(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid ENUMTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleIROOTSTGTest
//
//  Synopsis:  Runs single "IROOTSTGTEST" test.  For information on these testa,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   25-July-1996   NarindK    Created 
//--------------------------------------------------------------------

HRESULT RunSingleIROOTSTGTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = IROOTSTGTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = IROOTSTGTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = IROOTSTGTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = IROOTSTGTEST_103(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid IROOTSTGTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}


//+-------------------------------------------------------------------
//  Function:  RunSingleHGLOBALTest
//
//  Synopsis:  Runs single "HGLOBAL" test.  For information on these tests,
//             see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv] 
//
//  Returns:   HRESULT
//
//  History:   31-July-1996   T-ScottG    Modified 
//             25-July-1996   NarindK     Created 
//--------------------------------------------------------------------


HRESULT RunSingleHGLOBALTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT             hr              =           S_OK ;
    ULONG               ulSeed           =           0;

    // Obtain Seed from CommandLine

    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

    // Case test number

    if (S_OK == hr)
    {

	switch (lTestNum)
	{
	    case ( 100 ) :
	    {
		hr = HGLOBALTEST_100( ulSeed ) ;

		break ;
	    }

	    case ( 101 ) :
	    {
		hr = HGLOBALTEST_101( ulSeed ) ;

		break ;
	    }

	    case ( 110 ) :
	    {
		hr = HGLOBALTEST_110( ulSeed ) ;

		break ;
	    }

	    case ( 120 ) :
	    {
		hr = HGLOBALTEST_120( ulSeed ) ;

		break ;
	    }

	    case ( 121 ) :
	    {
		hr = HGLOBALTEST_121( ulSeed ) ;

		break ;
	    }

	    case ( 130 ) :
	    {
		hr = HGLOBALTEST_130( ulSeed ) ;

		break ;
	    }

	    case ( 140 ) :
	    {
		hr = HGLOBALTEST_140( ulSeed ) ;

		break ;
	    }

	    case ( 150 ) :
	    {
		hr = HGLOBALTEST_150( ulSeed ) ;

		break ;
	    }

	    default:
	    {
		//
		// Invalid test
		//

		DH_LOG((LOG_INFO,
			  TEXT("Invalid HGLOBALTEST test number: %ld"),
			  lTestNum) ) ;
	    }
	}
    }


    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleSNBTest
//
//  Synopsis:  Runs single "SNBTEST" test.  For information on these
//             tests, see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv]
//
//  Returns:   HRESULT
//
//  History:   26-July-1996   Jiminli    Created
//--------------------------------------------------------------------

HRESULT RunSingleSNBTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = SNBTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = SNBTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = SNBTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = SNBTEST_103(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid SNBTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleMISCTest
//
//  Synopsis:  Runs single "MISCTEST" test.  For information on these
//             tests, see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv]
//
//  Returns:   HRESULT
//
//  History:   5-Aug-1996   Jiminli    Created
//--------------------------------------------------------------------

HRESULT RunSingleMISCTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;

    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = MISCTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = MISCTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = MISCTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = MISCTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = MISCTEST_104(argc, argv) ;

	    break ;
	}

	case ( 105 ) :
	{
	    hr = MISCTEST_105(argc, argv) ;

	    break ;
	}

    default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid MISCTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}

//+-------------------------------------------------------------------
//  Function:  RunSingleILKBTest
//
//  Synopsis:  Runs single "ILKBTEST" test.  For information on these
//             tests, see %ctolestg%\docs\stgbase\testplan.doc
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv]
//
//  Returns:   HRESULT
//
//  History:   31-July-1996   NarindK    Created
//--------------------------------------------------------------------

HRESULT RunSingleILKBTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;
    ULONG               ulSeed           =           0;


    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = ILKBTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = ILKBTEST_101(argc, argv) ;

	    break ;
	}

	case ( 102 ) :
	{
	    hr = ILKBTEST_102(argc, argv) ;

	    break ;
	}

	case ( 103 ) :
	{
	    hr = ILKBTEST_103(argc, argv) ;

	    break ;
	}

	case ( 104 ) :
	{
	    hr = ILKBTEST_104(argc, argv) ;

	    break ;
	}

	case ( 105 ) :
	{
	    hr = ILKBTEST_105(argc, argv) ;

	    break ;
	}

	case ( 106 ) :
	{
	    hr = ILKBTEST_106(argc, argv) ;

	    break ;
	}

	case ( 107 ) :
	{
	    hr = ILKBTEST_107(argc, argv) ;

	    break ;
	}

	case ( 108 ) :
	{
	    // Obtain Seed from CommandLine

	    ulSeed = GetSeedFromCmdLineArgs(argc, argv);
	   
	    hr = ILKBTEST_108(ulSeed) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid ILKBTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}


//+-------------------------------------------------------------------
//  Function:  RunSingleFlatTest
//
//  Synopsis:  Runs single "FLATTEST" test.  
//
//  Arguments: [lTestNum]
//             [argc]
//             [argv]
//
//  Returns:   HRESULT
//
//  History:    22-Jan-1998    BogdanT created
//--------------------------------------------------------------------

HRESULT RunSingleFlatTest(LONG lTestNum, int argc, char *argv[])
{
    HRESULT     hr = E_FAIL ;
    int         i = 0;
    ULONG               ulSeed           =           0;


    switch (lTestNum)
    {
	case ( 100 ) :
	{
	    hr = FLATTEST_100(argc, argv) ;

	    break ;
	}

	case ( 101 ) :
	{
	    hr = FLATTEST_101(argc, argv) ;

	    break ;
	}

	default:
	{
	    //
	    // Invalid test
	    //

	    DH_LOG((LOG_INFO,
		      TEXT("Invalid FLATTEST test number: %ld"),
		      lTestNum) ) ;
	}
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\irootstg.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       irootstg.cxx
//
//  Contents:   storage base tests basically pertaining to IRootStorage 
//              interface. 
//
//  Functions:  
//
//  History:    25-July-1996     NarindK     Created.
//              27-Mar-97        SCousens    Conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

//Local Functions - Actual test functions.
HRESULT IROOTSTGTEST_100a(int argc, char *argv[], LPTSTR ptAlt);
HRESULT IROOTSTGTEST_101a(int argc, char *argv[], LPTSTR ptAlt);
HRESULT IROOTSTGTEST_102a(int argc, char *argv[], LPTSTR ptAlt);
HRESULT IROOTSTGTEST_103a(int argc, char *argv[], LPTSTR ptAlt);


// These stubs call a processor function for common processing
// before going on to call the actual tests.
HRESULT IROOTSTGTEST_100(int argc, char *argv[])
{
    return RunTestAltPath(argc, argv, IROOTSTGTEST_100a);
}
HRESULT IROOTSTGTEST_101(int argc, char *argv[])
{
    return RunTestAltPath(argc, argv, IROOTSTGTEST_101a);
}
HRESULT IROOTSTGTEST_102(int argc, char *argv[])
{
    return RunTestAltPath(argc, argv, IROOTSTGTEST_102a);
}
HRESULT IROOTSTGTEST_103(int argc, char *argv[])
{
    return RunTestAltPath(argc, argv, IROOTSTGTEST_103a);
}



//----------------------------------------------------------------------------
//
// Test:    IROOTSTGTEST_100a 
//
// Synopsis: A random docfile with random number of storages/streams is
//           created/committed/closed. The root docfile is instantiated 
//           and CRC'd.  QueryInterface for an IRootStorage is called and then 
//           SwitchToFile with a new file name is called.  The orignal file is 
//           released.  We then modify the switched to file, commit it, and 
//           release.  The original root docfile is then instantiated and CRC'd.
//           The CRCs are compared to verify that original file is unchanged.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  25-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LTSAVEAS.CXX
// 2.  Old name of test : LegitTransactedSaveAs 
//     New Name of test : IROOTSTGTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-100 /dfRootMode:dirReadWriteShEx 
//        /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-100 /dfRootMode:xactReadWriteShEx 
//        /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-100 /dfRootMode:xactReadWriteShDenyW 
//        /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: IROOTSTGTEST-100 NO - root stgs not suppd in nss
//
//  Note: The IRootStorage interface is used to switch the underlying disk file
//        that IStorage Objects are being saved to.  SwitchToFile makes a new
//        copy of the file underlying this Istorage and associated IStorage
//        object with this new file, rather than its current file, including
//        uncommitted changes.
//-----------------------------------------------------------------------------


HRESULT IROOTSTGTEST_100a(int argc, char *argv[], LPTSTR ptAlt)
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    LPOLESTR        poszNewRootDocFileName  = NULL;
    DWORD           dwCRCOrg                = 0;
    DWORD           dwCRCNew                = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPSTORAGE       pStgRootOrg             = NULL;
    LPSTORAGE       pStgRootNew             = NULL;
    LPROOTSTORAGE   pStgIRootStg            = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("IROOTSTGTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("IRootStorage-SwitchToFile, Save as. Modify DF, comp org DF.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for IROOTSTGTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Calculate CRC for entire DocFile without the RootDocfile name

    if(S_OK == hr)
    {
        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_INC_TOPSTG_NAME, 
                &dwCRCOrg);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Get the IRootStorage interface pointer by doing QueryInterface.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->QueryInterface(
                IID_IRootStorage,
                (LPVOID *) &pStgIRootStg); 

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::QueryInterface")) ;

    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    //  Generates a new name for DocFile that we would switch to using the
    //  IRootStorage::SwitchToFile 

    if(S_OK == hr)
    {
        // Generate random name for new docfile that we would switch to
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pNewRootDocFileName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //prepend drive so IRootStorage::SwitchToFile goes onto a different drive.
    if(S_OK == hr && NULL != ptAlt)
    {
        LPTSTR ptszNewName = new TCHAR[_tcslen ((LPTSTR)pNewRootDocFileName)+4];
        if (NULL != ptszNewName)
        {
            _stprintf (ptszNewName, TEXT("%s%s"), ptAlt, pNewRootDocFileName);
            delete []pNewRootDocFileName;
            pNewRootDocFileName = ptszNewName;
        }
    }

    if(S_OK == hr)
    {
        // Convert the new name to OLECHAR
        hr = TStringToOleString(pNewRootDocFileName, &poszNewRootDocFileName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Call IRootStorage::SwitchToFile

    if(S_OK == hr)
    {
        // Call DeleteFile just to make sure that pNewRootDocFileName doesn't
        // exist, before calling SwitchToFile
        DeleteFile(pNewRootDocFileName);

        DH_TRACE ((DH_LVL_TRACE1, TEXT("SwitchToFile: %s"), pNewRootDocFileName));
        hr = pStgIRootStg->SwitchToFile(poszNewRootDocFileName);
        DH_HRCHECK(hr, TEXT("IRootStorage::SwitchToFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release the pStgIRootStg pointer

    if(S_OK == hr)
    {
        // Release the Reference count that was added by QueryInterface call.

        ulRef = pStgIRootStg->Release();
        DH_ASSERT(1 == ulRef);
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
    }

    // ModifyDocFile call.  All the changes should be reflected to new docfile
    // (the one switched to) rather than original, since SwitchToFile asso
    // -ciated the ISotrage object with switchedto file rather than original
    // file.

    if (S_OK == hr)
    {
        hr = ModifyDocFile(
                pTestVirtualDF, 
                pVirtualDFRoot, 
                pdgi, 
                pdgu, 
                dwStgMode, 
                TRUE);

        DH_HRCHECK(hr, TEXT("ModifyDocFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destroy/Open/Close elem- passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destry/Open/Close elem- failed, hr=0x%lx"),
            hr));
    }

    // Try to open second time when flags are STGM_DENY_WRITE.  This should
    // fail with STG_E_LOCKVIOLATION error.

    if (S_OK == hr)
    {
        if(dwRootMode & STGM_SHARE_DENY_WRITE)
        {
            if(S_OK == hr)
            { 
                hr = StgOpenStorage(
                        poszNewRootDocFileName, 
                        NULL, 
                        dwRootMode, 
                        NULL, 
                        0, 
                        &pStgRootNew);
            }
        
            if(STG_E_LOCKVIOLATION == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("STGM_SHARE_DENY_WRITE:  StgOpenStg hr = 0x%lx exp"),
                    hr));

                hr = S_OK;
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("STGM_SHARE_DENY_WRITE:StgOpenStg hr = 0x%lx unexp"),
                    hr));
    
                fPass = FALSE;
            }

        }
    }

    // Close the Original DocFile

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Open the original Root DocFile again

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, NULL, 0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    // Calculate CRC for entire original DocFile without the RootDocfile name.
    // This CRC should match with CRC calculated for original DocFile since
    // all the changes being made after first CRC calculation should have been
    // to switched to file.

    if(S_OK == hr)
    {
        pStgRootOrg = NULL;

        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_INC_TOPSTG_NAME, 
                &dwCRCNew);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Compare CRC's

    if(S_OK == hr)
    {
        if(dwCRCOrg == dwCRCNew)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match, original file unchanged as expected.")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match, original file got changed unexp.")));
        }
    }

    // Close original file.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get some info about the test
    TCHAR szFileSystemInfoBuffer[10] = {TEXT(" :(")};
    GetVolumeInformation (ptAlt,
            NULL, //lpVolumeNameBuffer
            0,    //nVolumeNameSize
            NULL,
            NULL,
            NULL, //lpFileSystemFlags
            &szFileSystemInfoBuffer[3],
            sizeof (szFileSystemInfoBuffer)-4);
    _tcscat (szFileSystemInfoBuffer, TEXT(")"));
    if (NULL != ptAlt)
    {
        *szFileSystemInfoBuffer = *ptAlt;
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, 
            TEXT("Test IROOTSTGTEST_100 passed. %s"), 
            szFileSystemInfoBuffer));
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test IROOTSTGTEST_100 failed, hr = 0x%lx. %s"),
            hr,
            szFileSystemInfoBuffer));
          DH_DUMPCMD((LOG_FAIL, TEXT(" /seed:%u %s%c"), 
                pTestChanceDF->GetSeed(),
                NULL == ptAlt ? TEXT("") : TEXT("/altpath:"),
                NULL == ptAlt ? TCHAR('\0') : TCHAR(*ptAlt)));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the original docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete the new docfile on disk

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    if(NULL != poszNewRootDocFileName)
    {
        delete poszNewRootDocFileName;
        poszNewRootDocFileName = NULL;
    }

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    IROOTSTGTEST_101a 
//
// Synopsis: A random docfile with random number of storages/streams is
//          created/committed/closed. The root docfile is instantiated, 
//          modified, and then CRC' is calculated for that.  We then do
//          do QueryInterface for an IRootStorage and SwitchToFile to
//          a new root docfile.  The new docfile is CRC'd and compared to
//          the original, they should match at this point.  This docfile is
//          then modified, CRC'd, and released.  This docfile is then
//          re-instantiated, CRC'd, and the previous two CRCs are compared.
//          The original root docfile is then instantiated and CRC'd and
//          the CRC is compared against the orignal CRC.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  25-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LTSVBOTH.CXX
// 2.  Old name of test : LegitTransactedSaveAsBoth 
//     New Name of test : IROOTSTGTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-101 /dfRootMode:dirReadWriteShEx 
//        /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-101 /dfRootMode:xactReadWriteShEx 
//        /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-101 /dfRootMode:xactReadWriteShDenyW 
//        /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: IROOTSTGTEST-101 NO - root stgs not suppd in nss
//
//  Note: The IRootStorage interface is used to switch the underlying disk file
//        that IStorage Objects are being saved to.  SwitchToFile makes a new
//        copy of the file underlying this Istorage and associated IStorage
//        object with this new file, rather than its current file, including
//        uncommitted changes.
//-----------------------------------------------------------------------------

HRESULT IROOTSTGTEST_101a(int argc, char *argv[], LPTSTR ptAlt)
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    LPOLESTR        poszNewRootDocFileName  = NULL;
    DWORD           dwCRCOrg                = 0;
    DWORD           dwCRCNew                = 0;
    DWORD           dwCRCTemp               = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPSTORAGE       pStgRootOrg             = NULL;
    LPSTORAGE       pStgRootNew             = NULL;
    LPROOTSTORAGE   pStgIRootStg            = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("IROOTSTGTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("IRootStorage-SwitchToFile, Save as both. Modify both DF/cmp")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for IROOTSTGTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Modify original docfile now and then calculate CRC for it which would 
    // be the original CRC value.

    if (S_OK == hr)
    {
        hr = ModifyDocFile(
                pTestVirtualDF, 
                pVirtualDFRoot, 
                pdgi, 
                pdgu, 
                dwStgMode, 
                TRUE);

        DH_HRCHECK(hr, TEXT("ModifyDocFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destroy/Open/Close elem- passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destry/Open/Close elem- failed, hr=0x%lx"),
            hr));
    }

    // Calculate CRC for entire DocFile without the RootDocfile name for
    // original DocFile after making changes, but before calling SwitchToFile.
    // This is the original CRC value.

    if(S_OK == hr)
    {
        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCOrg);
        DH_TRACE ((DH_LVL_TRACE2, TEXT("CRC original file %#x"), dwCRCOrg));
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Get the IRootStorage interface pointer by doing QueryInterface on it.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->QueryInterface(
                IID_IRootStorage,
                (LPVOID *) &pStgIRootStg); 

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::QueryInterface")) ;

    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface unsuccessful, hr=0x%lx."),
            hr));
    }

    //  Generates a new name for DocFile that we would switch to using the
    //  IRootStorage::SwitchToFile 

    if(S_OK == hr)
    {
        // Generate random name for new docfile that we would switch to

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //prepend drive so IRootStorage::SwitchToFile goes onto a different drive.
    if(S_OK == hr && NULL != ptAlt)
    {
        LPTSTR ptszNewName = new TCHAR[_tcslen ((LPTSTR)pNewRootDocFileName)+4];
        if (NULL != ptszNewName)
        {
            _stprintf (ptszNewName, TEXT("%s%s"), ptAlt, pNewRootDocFileName);
            delete []pNewRootDocFileName;
            pNewRootDocFileName = ptszNewName;
        }
    }

    if(S_OK == hr)
    {
        // Convert the new name to OLECHAR

        hr = TStringToOleString(pNewRootDocFileName, &poszNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Call IRootStorage::SwitchToFile.  Therafter the IStorage would become
    // assocaited with new switched to file rather than original file and all
    // changes, including uncommitted ones, would be reflected to the new
    // switched to file rather than original file.

    if(S_OK == hr)
    {
        // Call DeleteFile just to make sure that pNewRootDocFileName doesn't
        // exist, before calling SwitchToFile
        DeleteFile(pNewRootDocFileName);

        DH_TRACE ((DH_LVL_TRACE1, TEXT("SwitchToFile: %s"), pNewRootDocFileName));
        hr = pStgIRootStg->SwitchToFile(poszNewRootDocFileName);
        DH_HRCHECK(hr, TEXT("IRootStorage::SwitchToFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release the pStgIRootStg pointer

    if(S_OK == hr)
    {
        // Release the Reference count that was added by QueryInterface call.

        ulRef = pStgIRootStg->Release();
        DH_ASSERT(1 == ulRef);
    }

    // Get the new root DocFile CRC after switching to File, should be the 
    // same as original root DocFile CRC at this point.  Calculate CRC and
    // compare to make sure.

    if(S_OK == hr)
    {
        pStgRootOrg = NULL;

        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);
        DH_TRACE ((DH_LVL_TRACE2, TEXT("CRC switched file %#x"), dwCRCTemp));
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Compare CRC's at this point, these should match

    if(S_OK == hr)
    {
        if(dwCRCOrg == dwCRCTemp)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match of org & switched to file as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match of org & switched to file unexp")));
        }
    }

    // Call ModifyDocFile call.  All the canges are being getting reflected to
    // the new root DocFile since SwitchToFile associated IStorage with switch
    // to file rather than original file.

    if (S_OK == hr)
    {
        hr = ModifyDocFile(
                pTestVirtualDF, 
                pVirtualDFRoot, 
                pdgi, 
                pdgu, 
                dwStgMode, 
                TRUE);

        DH_HRCHECK(hr, TEXT("ModifyDocFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destroy/Open/Close elem- passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destry/Open/Close elem- failed, hr=0x%lx"),
            hr));
    }

    // Get new root DocFile CRC after making changes to new DocFile and commit
    // ing them.  This will be compared to the new docfile CRC after release
    // and reinstantiation.

    if(S_OK == hr)
    {
        pStgRootOrg = NULL;

        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCNew);
        DH_TRACE ((DH_LVL_TRACE2, TEXT("CRC switched/modified file %#x"), dwCRCNew));
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Close the Original DocFile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Open the new Root DocFile.  The CRC will be computed on it, this
    // is expected to match dwCRCNew that was calculated before.

    if(S_OK == hr)
    { 
        hr = StgOpenStorage(
                poszNewRootDocFileName, 
                NULL, 
                dwRootMode, 
                NULL, 
                0, 
                &pStgRootNew);

        DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
    }

    // Calculate the CRC on this new root DocFile

    if(S_OK == hr)
    {
        dwCRCTemp = 0;

        hr = CalculateCRCForDocFile(    
                pStgRootNew, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);
        DH_TRACE ((DH_LVL_TRACE2, TEXT("CRC new (after switch) file %#x"), dwCRCTemp));
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }
    
    // Compare CRC's at this point.  The CRC of this new docfile and the
    // DocFile that was switched to and then modified should match.
    
    if(S_OK == hr)
    {
        if(dwCRCNew == dwCRCTemp)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match of new & switched to file as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match of new & switched to file unexp")));
        }
    }

    // Close the new root DocFile

    if(S_OK == hr)
    {
        ulRef = pStgRootNew->Release();
        DH_ASSERT(0 == ulRef);
        pStgRootNew = NULL;
    }

    // Open the original Root DocFile again.  The CRC would be calculated on
    // this, it is expected to match dwCRCOrg, thereby verifying that because
    // of SwitchToFile, the original file remained unchanged.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, NULL, 0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    // Calculate CRC for entire DocFile without the RootDocfile name

    if(S_OK == hr)
    {
        pStgRootOrg = NULL;

        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        dwCRCTemp = 0;

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);
        DH_TRACE ((DH_LVL_TRACE2, TEXT("CRC original file again %#x"), dwCRCTemp));
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Compare CRC's of the this orginal docfile after reinstantiation and
    // the original value before SwitchToFile was done. These should match.

    if(S_OK == hr)
    {
        if(dwCRCTemp == dwCRCOrg)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match, original file unchanged as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match, original file changed unexp")));
        }
    }

    // Close original root docfile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get some info about the test
    TCHAR szFileSystemInfoBuffer[10] = {TEXT(" :(")};
    GetVolumeInformation (ptAlt,
            NULL, //lpVolumeNameBuffer
            0,    //nVolumeNameSize
            NULL,
            NULL,
            NULL, //lpFileSystemFlags
            &szFileSystemInfoBuffer[3],
            sizeof (szFileSystemInfoBuffer)-4);
    _tcscat (szFileSystemInfoBuffer, TEXT(")"));
    if (NULL != ptAlt)
    {
        *szFileSystemInfoBuffer = *ptAlt;
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, 
            TEXT("Test variation IROOTSTGTEST_101 passed. %s"),
            szFileSystemInfoBuffer) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation IROOTSTGTEST_101 failed, hr = 0x%lx. %s"),
            hr,
            szFileSystemInfoBuffer) );
          DH_DUMPCMD((LOG_FAIL, TEXT(" /seed:%u %s%c"), 
                pTestChanceDF->GetSeed(),
                NULL == ptAlt ? TEXT("") : TEXT("/altpath:"),
                NULL == ptAlt ? TCHAR('\0') : TCHAR(*ptAlt)));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the original docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete the new docfile on disk

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    if(NULL != poszNewRootDocFileName)
    {
        delete poszNewRootDocFileName;
        poszNewRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    IROOTSTGTEST_102 
//
// Synopsis: A random docfile with random number of storages/streams is
//          created/committed/closed. The root docfile is instantiated,
//          and CRC is calculated for the docfile.  It is then modified & 
//          CRC'd again.  The test then calls QueryInterface to get an
//          IRootStorage and SwitchesToFile on a new name.  The new docfile
//          is committed, released, reinstantiated, and CRC'd.  This CRC
//          should match the CRC of the modified original root docfile.
//          The original docfile is then instantiated and CRC'd.  This
//          CRC should match the *first* CRC of the original root docfile
//          since we called SwitchToFile() before committing the changes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  26-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes.
//
// New Test Notes:
// 1.  Old File: LTSVNEW.CXX
// 2.  Old name of test : LegitTransactedSaveAsNew 
//     New Name of test : IROOTSTGTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-102 /dfRootMode:xactReadWriteShEx 
//        /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-102 /dfRootMode:xactReadWriteShDenyW 
//        /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: IROOTSTGTEST-102 NO - root stgs not suppd in nss
//
//  Note: The IRootStorage interface is used to switch the underlying disk file
//        that IStorage Objects are being saved to.  SwitchToFile makes a new
//        copy of the file underlying this Istorage and associated IStorage
//        object with this new file, rather than its current file, including
//        uncommitted changes.
//-----------------------------------------------------------------------------

HRESULT IROOTSTGTEST_102a(int argc, char *argv[], LPTSTR ptAlt)
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    LPOLESTR        poszNewRootDocFileName  = NULL;
    DWORD           dwCRCOrg                = 0;
    DWORD           dwCRCNew                = 0;
    DWORD           dwCRCTemp               = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPSTORAGE       pStgRootOrg             = NULL;
    LPSTORAGE       pStgRootNew             = NULL;
    LPROOTSTORAGE   pStgIRootStg            = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("IROOTSTGTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("IRootStorage-SwitchToFile,  Save as new.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for IROOTSTGTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Calculate CRC for entire DocFile without the RootDocfile name for
    // original DocFile before making changes.  Then modify DocFile, but
    // don't commit the changes.  Get a new CRC reflecting  these changes 
    // and then switch to a new file *but* don't commit first.

    if(S_OK == hr)
    {
        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCOrg);
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        DH_TRACE ((DH_LVL_TRACE4, 
                TEXT("CRC for docfile: %#lx"), dwCRCOrg));
    }

    // Modify original docfile now, but don't commit the changes to root.

    if (S_OK == hr)
    {
        hr = ModifyDocFile(
                pTestVirtualDF, 
                pVirtualDFRoot, 
                pdgi, 
                pdgu, 
                dwStgMode, 
                FALSE);

        DH_HRCHECK(hr, TEXT("ModifyDocFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destroy/Open/Close elem- passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destry/Open/Close elem- failed, hr=0x%lx"),
            hr));
    }

    // Calculate CRC for entire DocFile without the RootDocfile name for
    // original DocFile after making changes, but not commiting these to
    // root. Let this be the new CRC value.

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCNew);
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        DH_TRACE ((DH_LVL_TRACE4, 
                TEXT("CRC for docfile: %#lx"), dwCRCNew));
    }

    // Get the IRootStorage interface pointer by doing QueryInterface on it.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->QueryInterface(
                IID_IRootStorage,
                (LPVOID *) &pStgIRootStg); 

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::QueryInterface")) ;

    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface unsuccessful, hr=0x%lx."),
            hr));
    }

    //  Generates a new name for DocFile that we would switch to using the
    //  IRootStorage::SwitchToFile 

    if(S_OK == hr)
    {
        // Generate random name for new docfile that we would switch to

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //prepend drive so IRootStorage::SwitchToFile goes onto a different drive.
    if(S_OK == hr && NULL != ptAlt)
    {
        LPTSTR ptszNewName = new TCHAR[_tcslen ((LPTSTR)pNewRootDocFileName)+4];
        if (NULL != ptszNewName)
        {
            _stprintf (ptszNewName, TEXT("%s%s"), ptAlt, pNewRootDocFileName);
            delete []pNewRootDocFileName;
            pNewRootDocFileName = ptszNewName;
        }
    }

    // Call IRootStorage::SwitchToFile.  Therafter the IStorage would become
    // assocaited with new switched to file rather than original file and all
    // changes, including uncommitted ones, would be reflected to the new
    // switched to file rather than original file.

    if (S_OK == hr)
    {
        //  Convert name to OLECHAR 

        hr =TStringToOleString(pNewRootDocFileName,&poszNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Call DeleteFile just to make sure that pNewRootDocFileName doesn't
        // exist, before calling SwitchToFile
        DeleteFile(pNewRootDocFileName);

        DH_TRACE ((DH_LVL_TRACE1, TEXT("SwitchToFile: %s"), pNewRootDocFileName));
        hr = pStgIRootStg->SwitchToFile(poszNewRootDocFileName);
        DH_HRCHECK(hr, TEXT("IRootStorage::SwitchToFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release the pStgIRootStg pointer

    if(S_OK == hr)
    {
        // Release the Reference count that was added by QueryInterface call.

        ulRef = pStgIRootStg->Release();
        DH_ASSERT(1 == ulRef);
    }

    // Commit the Original DocFile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),   
            hr));
    }

    // Close the Original DocFile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Open the new Root DocFile.  The CRC will be computed on it, this
    // is expected to match dwCRCNew that was calculated before.

    if(S_OK == hr)
    { 
        hr = StgOpenStorage(
                poszNewRootDocFileName, 
                NULL, 
                dwRootMode, 
                NULL, 
                0, 
                &pStgRootNew);

        DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
    }

    // Calculate the CRC on this new root DocFile

    if(S_OK == hr)
    {
        dwCRCTemp = 0;

        hr = CalculateCRCForDocFile(    
                pStgRootNew, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        DH_TRACE ((DH_LVL_TRACE4, 
                TEXT("CRC for docfile: %#lx"), dwCRCTemp));
    }
    
    // Compare CRC's at this point.  The CRC of this new docfile and the
    // DocFile that was switched to and then modified should match.
    
    if(S_OK == hr)
    {
        if(dwCRCNew == dwCRCTemp)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match of new & switched to file as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match of new & switched to file unexp")));
        }
    }

    // Close the new root DocFile

    if(S_OK == hr)
    {
        ulRef = pStgRootNew->Release();
        DH_ASSERT(0 == ulRef);
        pStgRootNew = NULL;
    }

    // Open the original Root DocFile again.  The CRC would be calculated on
    // this, it is expected to match dwCRCOrg, thereby verifying that because
    // of SwitchToFile, the original file remained unchanged.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, NULL, 0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    // Calculate CRC for original DocFile without the RootDocfile name

    if(S_OK == hr)
    {
        pStgRootOrg = NULL;

        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        dwCRCTemp = 0;

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);
        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        DH_TRACE ((DH_LVL_TRACE4, 
                TEXT("CRC for docfile: %#lx"), dwCRCTemp));
    }

    // Compare CRC's of the this orginal docfile after reinstantiation and
    // the original value before SwitchToFile was done. These should match.

    if(S_OK == hr)
    {
        if(dwCRCTemp == dwCRCOrg)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match, original file unchanged as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match, original file changed unexp")));
        }
    }

    // Close original root docfile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get some info about the test
    TCHAR szFileSystemInfoBuffer[10] = {TEXT(" :(")};
    GetVolumeInformation (ptAlt,
            NULL, //lpVolumeNameBuffer
            0,    //nVolumeNameSize
            NULL,
            NULL,
            NULL, //lpFileSystemFlags
            &szFileSystemInfoBuffer[3],
            sizeof (szFileSystemInfoBuffer)-4);
    _tcscat (szFileSystemInfoBuffer, TEXT(")"));
    if (NULL != ptAlt)
    {
        *szFileSystemInfoBuffer = *ptAlt;
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, 
            TEXT("Test variation IROOTSTGTEST_102 passed. %s"),
            szFileSystemInfoBuffer) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation IROOTSTGTEST_102 failed, hr = 0x%lx. %s"),
            hr,
            szFileSystemInfoBuffer) );
          DH_DUMPCMD((LOG_FAIL, TEXT(" /seed:%u %s%c"), 
                pTestChanceDF->GetSeed(),
                NULL == ptAlt ? TEXT("") : TEXT("/altpath:"),
                NULL == ptAlt ? TCHAR('\0') : TCHAR(*ptAlt)));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the original docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete the new docfile on disk

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    if(NULL != poszNewRootDocFileName)
    {
        delete poszNewRootDocFileName;
        poszNewRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    IROOTSTGTEST_103 
//
// Synopsis: A random docfile with random number of storages/streams is
//          created/committed/closed. The root docfile is instantiated,
//          and CRC is calculated for the docfile.  It is then modified & 
//          CRC'd again.  The test then calls QueryInterface to get an
//          IRootStorage and SwitchesToFile on a new name.  The new docfile
//          is reverted, released, reinstantiated, and CRC'd.  This CRC
//          should match the *first* CRC of the original root DocfFile, 
//          rather than the CRC of the modified original root docfile.
//          The original docfile is then instantiated and CRC'd.  This
//          CRC should match the *first* CRC of the original root docfile
//          since we called SwitchToFile() before committing the changes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  26-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes.
//
// New Test Notes:
// 1.  Old File: LTSVREV.CXX
// 2.  Old name of test : LegitTransactedSaveAsRevert 
//     New Name of test : IROOTSTGTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-103 /dfRootMode:xactReadWriteShEx 
//        /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:0-3 
//        /t:IROOTSTGTEST-103 /dfRootMode:xactReadWriteShDenyW 
//        /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: IROOTSTGTEST-103 NO - root stgs not suppd in nss
//
//  Note: The IRootStorage interface is used to switch the underlying disk file
//        that IStorage Objects are being saved to.  SwitchToFile makes a new
//        copy of the file underlying this Istorage and associated IStorage
//        object with this new file, rather than its current file, including
//        uncommitted changes.
//-----------------------------------------------------------------------------

HRESULT IROOTSTGTEST_103a(int argc, char *argv[], LPTSTR ptAlt)
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    LPOLESTR        poszNewRootDocFileName  = NULL;
    DWORD           dwCRCOrg                = 0;
    DWORD           dwCRCNew                = 0;
    DWORD           dwCRCTemp               = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPSTORAGE       pStgRootOrg             = NULL;
    LPSTORAGE       pStgRootNew             = NULL;
    LPROOTSTORAGE   pStgIRootStg            = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("IROOTSTGTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_103 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("IRootStorage-SwitchToFile, Save as Revert")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for IROOTSTGTEST_103, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Calculate CRC for entire DocFile without the RootDocfile name for
    // original DocFile before making changes.  Then modify DocFile, but
    // don't commit the changes to root.  Get new CRC reflecting these changes 
    // and then switch to a new file *but* don't commit first.

    if(S_OK == hr)
    {
        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCOrg);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Modify original docfile now, but dont commit the changes to root.

    if (S_OK == hr)
    {
        hr = ModifyDocFile(
                pTestVirtualDF, 
                pVirtualDFRoot, 
                pdgi, 
                pdgu, 
                dwStgMode, 
                FALSE);

        DH_HRCHECK(hr, TEXT("ModifyDocFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destroy/Open/Close elem- passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ModifyDF-Rename/Destry/Open/Close elem- failed, hr=0x%lx"),
            hr));
    }

    // Calculate CRC for entire DocFile without the RootDocfile name for
    // original DocFile after making changes, but not commiting these to
    // root. Let this be the new CRC value.

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCNew);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Get the IRootStorage interface pointer by doing QueryInterface on it.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->QueryInterface(
                IID_IRootStorage,
                (LPVOID *) &pStgIRootStg); 

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::QueryInterface")) ;

    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface unsuccessful, hr=0x%lx."),
            hr));
    }

    //  Generates a new name for DocFile that we would switch to using the
    //  IRootStorage::SwitchToFile 

    if(S_OK == hr)
    {
        // Generate random name for new docfile that we would switch to

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //prepend drive so IRootStorage::SwitchToFile goes onto a different drive.
    if(S_OK == hr && NULL != ptAlt)
    {
        LPTSTR ptszNewName = new TCHAR[_tcslen ((LPTSTR)pNewRootDocFileName)+4];
        if (NULL != ptszNewName)
        {
            _stprintf (ptszNewName, TEXT("%s%s"), ptAlt, pNewRootDocFileName);
            delete []pNewRootDocFileName;
            pNewRootDocFileName = ptszNewName;
        }
    }

    // Call IRootStorage::SwitchToFile.  Therafter the IStorage would become
    // assocaited with new switched to file rather than original file and all
    // changes, including uncommitted ones, would be reflected to the new
    // switched to file rather than original file.

    if (S_OK == hr)
    {
        //  Convert name to OLECHAR 

        hr =TStringToOleString(pNewRootDocFileName,&poszNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Call DeleteFile just to make sure that pNewRootDocFileName doesn't
        // exist, before calling SwitchToFile
        DeleteFile(pNewRootDocFileName);

        DH_TRACE ((DH_LVL_TRACE1, TEXT("SwitchToFile: %s"), pNewRootDocFileName));
        hr = pStgIRootStg->SwitchToFile(poszNewRootDocFileName);
        DH_HRCHECK(hr, TEXT("IRootStorage::SwitchToFile")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IRootStorage::SwitchToFile unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release the pStgIRootStg pointer

    if(S_OK == hr)
    {
        // Release the Reference count that was added by QueryInterface call.

        ulRef = pStgIRootStg->Release();
        DH_ASSERT(1 == ulRef);
    }

    // Revert the Original DocFile.  This revert will revert all the changes
    // made by the ModifyDocFile call.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Revert();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Revert completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Revert unsuccessful, hr=0x%lx."),   
            hr));
    }

    // Close the Original DocFile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Open the new Root DocFile.  The CRC will be computed on it, this
    // is expected to match dwCRCOrg that was calculated on original
    // DocFile before changes were made to it, because all the changes
    // were reverted by doing revert on root.

    if(S_OK == hr)
    { 
        hr = StgOpenStorage(
                poszNewRootDocFileName, 
                NULL, 
                dwRootMode, 
                NULL, 
                0, 
                &pStgRootNew);

        DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
    }

    // Calculate the CRC on this new root DocFile

    if(S_OK == hr)
    {
        dwCRCTemp = 0;

        hr = CalculateCRCForDocFile(    
                pStgRootNew, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }
    
    // Compare CRC's at this point.  The CRC of this new docfile and the
    // original DocFile before any changes were made to it should match,    
    // since the changes made were reverted.
    
    if(S_OK == hr)
    {
        if((dwCRCNew != dwCRCTemp) && (dwCRCOrg == dwCRCTemp))
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("crc's match of new and org before changes as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match of new & org before changes unexp")));
        }
    }

    // Close the new root DocFile

    if(S_OK == hr)
    {
        ulRef = pStgRootNew->Release();
        DH_ASSERT(0 == ulRef);
        pStgRootNew = NULL;
    }

    // Open the original Root DocFile again.  The CRC would be calculated on
    // this, it is expected to match dwCRCOrg, thereby verifying that because
    // of SwitchToFile, the original file remained unchanged.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, NULL, 0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    // Calculate CRC for original DocFile without the RootDocfile name

    if(S_OK == hr)
    {
        pStgRootOrg = NULL;

        pStgRootOrg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOrg);

        dwCRCTemp = 0;

        hr = CalculateCRCForDocFile(    
                pStgRootOrg, 
                VERIFY_EXC_TOPSTG_NAME, 
                &dwCRCTemp);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Compare CRC's of the this orginal docfile after reinstantiation and
    // the original value before SwitchToFile was done. These should match.

    if(S_OK == hr)
    {
        if(dwCRCTemp == dwCRCOrg)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's match, original file unchanged as exp")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's don't match, original file changed unexp")));
        }
    }

    // Close original root docfile.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get some info about the test
    TCHAR szFileSystemInfoBuffer[10] = {TEXT(" :(")};
    GetVolumeInformation (ptAlt,
            NULL, //lpVolumeNameBuffer
            0,    //nVolumeNameSize
            NULL,
            NULL,
            NULL, //lpFileSystemFlags
            &szFileSystemInfoBuffer[3],
            sizeof (szFileSystemInfoBuffer)-4);
    _tcscat (szFileSystemInfoBuffer, TEXT(")"));
    if (NULL != ptAlt)
    {
        *szFileSystemInfoBuffer = *ptAlt;
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, 
            TEXT("Test variation IROOTSTGTEST_103 passed. %s"),
            szFileSystemInfoBuffer) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation IROOTSTGTEST_103 failed, hr = 0x%lx. %s"),
            hr,
            szFileSystemInfoBuffer) );
          DH_DUMPCMD((LOG_FAIL, TEXT(" /seed:%u %s%c"), 
                pTestChanceDF->GetSeed(),
                NULL == ptAlt ? TEXT("") : TEXT("/altpath:"),
                NULL == ptAlt ? TCHAR('\0') : TCHAR(*ptAlt)));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the original docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete the new docfile on disk

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    if(NULL != poszNewRootDocFileName)
    {
        delete poszNewRootDocFileName;
        poszNewRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation IROOTSTGTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\misctsts.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      misctsts.cxx
//
//  Contents:  miscellaneous tests pertaining to storage base tests
//
//  Functions:  
//
//  History:    5-Aug-1996     Jiminli     Created.
//              27-Mar-97      SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

extern BOOL     g_fUseStdBlk;
extern USHORT   ausSIZE_ARRAY[];

ULONG       ulStreamSize    = 0;
USHORT      usIterations    = 2;

LPTSTR      ptszNames[MAX_DOCFILES];
ULONG       *ulSeekOffset;

TIMEINFO    Time[] = {
                TEXT("FIRST_TIMING           "), FIRST_TIMING, 0, 0,
                TEXT("CREATE_STREAM_NO_EXIST "), CREATE_STREAM_NO_EXIST, 0, 0,
                TEXT("CREATE_STREAM_EXIST    "), CREATE_STREAM_EXIST, 0, 0,
                TEXT("CREATE_DOCFILE_NO_EXIST"), CREATE_DOCFILE_NO_EXIST, 0, 0,
                TEXT("CREATE_DOCFILE_EXIST   "), CREATE_DOCFILE_EXIST, 0, 0,
                TEXT("CREATE_NONAME_DOCFILE  "), CREATE_NONAME_DOCFILE, 0, 0,
                TEXT("OPEN_STORAGE_AND_STREAM"), OPEN_STORAGE_AND_STREAM, 0, 0,
                TEXT("OPEN_STREAM_ONLY       "), OPEN_STREAM_ONLY, 0, 0,
                TEXT("SEQUENTIAL_WRITE       "), SEQUENTIAL_WRITE, 0, 0,
                TEXT("SEQUENTIAL_READ        "), SEQUENTIAL_READ, 0, 0,
                TEXT("RANDOM_WRITE           "), RANDOM_WRITE, 0, 0,
                TEXT("RANDOM_READ            "), RANDOM_READ, 0, 0 };
 
//----------------------------------------------------------------------------
//
// Test:    MISCTEST_100 
//
// Synopsis: A root docfile is created and an IStream created in it. A random
//           number of bytes are written to the IStream and the IStream is
//           released. The root docfile is committed and released. This is
//           a particularly useful way to discover memory leaks as scratch
//           objects are created and (hopefully) released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  5-Aug-1996     JiminLi     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: MEMLEAK.CXX
// 2.  Old name of test : MiscMemLeak Test 
//     New Name of test : MISCTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-100
//        /dfRootMode:dirReadWriteShEx /logloc:2 /traceloc:2 /labmode
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-100 
//        /dfRootMode:xactReadWriteShEx /logloc:2 /traceloc:2 /labmode
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-100
//        /dfRootMode:xactReadWriteShDenyW /logloc:2 /traceloc:2 /labmode
// 
// BUGNOTE: Conversion: MISCTEST-100
//
//-----------------------------------------------------------------------------

HRESULT MISCTEST_100(int argc, char *argv[])
{
    HRESULT         hr                          = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    VirtualStmNode  *pvsnRootNewChildStream     = NULL;
    LPTSTR          pRootNewChildStmName        = NULL;
    DG_STRING      *pdgu                       = NULL;
    DG_INTEGER      *pdgi                       = NULL;
    USHORT          usErr                       = 0;
    LPTSTR          ptcsBuffer                  = NULL;
    ULONG           culBytesLeftToWrite         = 0;
    ULONG           culWritten                  = 0;
    ULONG           culRandIOBytes              = 0;
    DWORD           dwRootMode                  = 0;
    
    
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("MISCTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_100 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt memory leaks checking as objects are created")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for MISCTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        // Generate random size for stream between 4L, and MIN_SIZE * 1.5

        usErr = pdgi->Generate(&culBytesLeftToWrite,4L,(ULONG)(MIN_SIZE * 1.5));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        // Generate random number of bytes to write per chunk b/w  
        // RAND_IO_MIN and RAND_IO_MAX

        usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
 
    // Loop to write new IStream in culRandIOBytes size chunks unless size 
    // remaining to write is less than culRandIOBytes, then write the 
    // remaining bytes. CRC is not important for this test, so no check for it.

    while ((S_OK == hr) && (0 != culBytesLeftToWrite))
    {
        if (culBytesLeftToWrite > culRandIOBytes)
        {
            culBytesLeftToWrite = culBytesLeftToWrite - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToWrite;
            culBytesLeftToWrite = 0;
        }

        // Call VirtualStmNode::Write to create random bytes in the stream.  For
        // our test purposes, we generate a random string of size culRandIOBytes
        // using GenerateRandomString function.

        if (S_OK == hr)
        {
            hr = GenerateRandomString(
                    pdgu, 
                    culRandIOBytes,
                    culRandIOBytes, 
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr =  pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culWritten);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }

        // Delete temp buffer

        if(NULL != ptcsBuffer)
        {
            delete []ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }

    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
            hr));
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtulaStmNode::Close unsuccessful, hr=0x%lx."), 
            hr));
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation MISCTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation MISCTEST_100 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    MISCTEST_101 
//
// Synopsis: Create a docfile over the net using READWRITE|TRANSACTED|
//           DENYWRITE. 50% chance this docfile will be committed. Then 
//           open the same file again over the net using READ|TRANSACTED|
//           DENYNONE. This test doesn't need to be run across the net, but
//           for what we are testing, this is the interesting variation. 
//           (from old test)
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  5-Aug-1996     JiminLi     Created.
//
// Notes:    There are no special parameterized operation modes for this 
//           test.
//
// New Test Notes:
// 1.  Old File: DFWFWOP.CXX
// 2.  Old name of test : MiscWindowForWorkGroupsOpen Test 
//     New Name of test : MISCTEST_101
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-101
//        /dfRootMode:xactReadWriteShDenyW /logloc:2 /traceloc:2 /labmode 
// 
// BUGNOTE: Conversion: MISCTEST-101
//
//-----------------------------------------------------------------------------

HRESULT MISCTEST_101(int argc, char *argv[])
{
    HRESULT         hr                  = S_OK;
    ChanceDF        *pTestChanceDF      = NULL;
    VirtualDF       *pTestVirtualDF     = NULL;
    VirtualCtrNode  *pVirtualDFRoot     = NULL;
    DG_INTEGER      *pdgi               = NULL;
    USHORT          usErr               = 0;
    LPTSTR          pRootDocFileName    = NULL;
    LPOLESTR        pOleStrTemp         = NULL;
    LPSTORAGE       pStgDFRoot1         = NULL;
    LPSTORAGE       pStgDFRoot2         = NULL;
    DWORD           dwRootMode          = 0;
    ULONG           culRandomCommit     = 0;
    ULONG           ulRef               = 0;
    
    
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("MISCTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("MiscWindowsForWorkGroupOpen test.")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for MISCTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }
	
    // 50% chance commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&culRandomCommit, 1, 100);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Get the _pstg of the root storage, for later release

    if (S_OK == hr)
    {
        pStgDFRoot1 = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgDFRoot1);
    }

    if ((S_OK == hr) && (culRandomCommit > 50))
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
                hr));
        }
    }

    // Open same docfile again using READ|TRANSACTED|DENYNONE.

    if (S_OK == hr)
    {
        if (NULL != pVirtualDFRoot)
        {
            pRootDocFileName= new TCHAR[_tcslen (pTestVirtualDF->GetDocFileName ())+1];
            if (pRootDocFileName != NULL)
            {
                _tcscpy (pRootDocFileName, pTestVirtualDF->GetDocFileName());
            }
            else
            {
                hr = E_FAIL;
                DH_TRACE ((DH_LVL_ERROR, TEXT("unable to get/copy DocFilename")));
            }
        }
    }

    if(S_OK == hr)
    {
        // Convert the name of the docfile to OLECHAR

        hr = TStringToOleString(pRootDocFileName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if (S_OK == hr)
    {
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                STGM_READ | STGM_TRANSACTED | STGM_SHARE_DENY_NONE,
                NULL,
                0,
                &pStgDFRoot2);
        DH_ASSERT(NULL != pStgDFRoot2);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release root, here since we opened the docfile twice, we should
    // release both instances of it so that we can finally delete the 
    // docfile from disk.

    if (S_OK == hr)
    {
        ulRef = pStgDFRoot2->Release();
        DH_ASSERT(0 == ulRef);
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation MISCTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation MISCTEST_101 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if (NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    if (NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    MISCTEST_102 
//
// Synopsis: This test measures performance for various docfile operations
//           as compared to the equivalent C runtime operations.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  6-Aug-1996     JiminLi     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: PERFTIME.CXX
// 2.  Old name of test : PerformanceTiming Test 
//     New Name of test : MISCTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-102
//        /dfRootMode:dirReadWriteShEx /logloc:2 /traceloc:2 /labmode
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-102 
//        /dfRootMode:xactReadWriteShEx /logloc:2 /traceloc:2 /labmode
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-102
//        /dfRootMode:xactReadWriteShDenyW /logloc:2 /traceloc:2 /labmode
//     d. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-102
//        /dfRootMode:dirReadWriteShEx /stdblock /logloc:2 /traceloc:2 /labmode
//     e. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-102 
//        /dfRootMode:xactReadWriteShEx /stdblock /logloc:2 /traceloc:2 /labmode
//     f. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-102
//        /dfRootMode:xactReadWriteShDenyW /stdblock /logloc:2 /traceloc:2 
//        /labmode
//
// BUGNOTE: Conversion: MISCTEST-102
//
//-----------------------------------------------------------------------------

HRESULT MISCTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    ULONG           ulChunkSize             = 0;  
    ULONG           culArrayIndex           = 0;
    ULONG           cStartIndex             = 6;
    ULONG           ulNumofChunks           = 0;
    ULONG           culBytesLeft            = 0;
    USHORT          usIndex1                = 0;
    USHORT          usIndex2                = 0;
    LONG            lAvgDocfileTime         = 0;
    LONG            lAvgRuntimeTime         = 0;
    double          dSDDocfile, dSDRuntime, *pdDocRunDiff;
    double          dAvgDocfileTime, dTotalDocfileTime, dTotalRuntimeTime;
    double          dDocDiffTime;
    
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("MISCTEST_102"));

    pdDocRunDiff = NULL;

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_102 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt measure performance for various docfile operations")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for MISCTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Generate stream size b/w MIN_SIZE and MIN_SIZE*1.5
   
    if (S_OK == hr)
    {
        usErr = pdgi->Generate(
                    &ulStreamSize, 
                    (ULONG)MIN_SIZE, 
                    (ULONG) (MIN_SIZE * 1.5));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
 
    // Generate chunk size for each WRITE/READ operation

    if (S_OK == hr)
    {
        if (TRUE == g_fUseStdBlk)
        {
            // Pick up a random array element.  Choosing cStartIndex of the
            // array (with random blocks) as 6 because do not want to write
            // byte by byte or in too small chunks a large docfile. 

            usErr = pdgi->Generate(&culArrayIndex, cStartIndex, MAX_SIZE_ARRAY);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
            else
            {
                ulChunkSize = ausSIZE_ARRAY[culArrayIndex];
            }
        }
        else
        {
            // Generate random number of bytes to write per chunk b/w 
            // RAND_IO_MIN and RAND_IO_MAX.

            usErr = pdgi->Generate(&ulChunkSize, RAND_IO_MIN, RAND_IO_MAX);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }
    }

    // Calculate how many chunks be written

    if (S_OK == hr)
    {
        culBytesLeft = ulStreamSize;

        if (0 == ulChunkSize) 
        {
            hr = E_FAIL;
        }
        else
        {
            while (0 != culBytesLeft)
            {
                ulNumofChunks++;

                if (culBytesLeft >= ulChunkSize)
                {
                    culBytesLeft -= ulChunkSize;
                }
                else
                {				
                    culBytesLeft = 0;
                }
            }
        }
    }

    if (S_OK == hr)
    {
        ulSeekOffset = new ULONG[ulNumofChunks];

        // Generate the seek offsets for the random READ/WRITE operations

        for (usIndex1=0; usIndex1<ulNumofChunks; usIndex1++)
        {
            usErr = pdgi->Generate(
                        &ulSeekOffset[usIndex1],
                        0L,
                        ulStreamSize - ulChunkSize);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }   

            if (S_OK != hr)
            {
                break;
            }
        }
    }

    if (S_OK == hr)
    {
        // Allocate the array for storing times
        
        for (usIndex1=FIRST_TIMING+1; usIndex1<LAST_TIMING; usIndex1++)
        {
            Time[usIndex1].plDocfileTime = (LONG *) new 
                                            LONG[(usIterations)*sizeof(LONG)];
            Time[usIndex1].plRuntimeTime = (LONG *) new 
                                            LONG[(usIterations)*sizeof(LONG)];

            if ((NULL == Time[usIndex1].plDocfileTime) ||
                (NULL == Time[usIndex1].plRuntimeTime))
            {
                hr = E_OUTOFMEMORY;
            }
            else
            { 
                memset(
                    Time[usIndex1].plDocfileTime, 
                    -1, 
                    usIterations*sizeof(LONG));

                memset(
                    Time[usIndex1].plDocfileTime, 
                    -1, 
                    usIterations*sizeof(LONG)); 
            }

            if (S_OK != hr)
            {
                break;
            }
        }

        if (S_OK == hr)
        {
            pdDocRunDiff = new double[usIterations];

            if (NULL == pdDocRunDiff)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Test for StreamCreate
        
        if (S_OK == hr)
        {
            hr = StreamCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_STREAM_NO_EXIST, 
                    DOCFILE | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = StreamCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_STREAM_NO_EXIST, 
                    RUNTIME | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = StreamCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_STREAM_EXIST, 
                    DOCFILE | EXIST | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = StreamCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_STREAM_EXIST, 
                    RUNTIME | EXIST | COMMIT, 
                    usIterations);          
        }

        if (S_OK != hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Error in StreamCreate")));
        }

        // Test for DocfileCreate
        
        if (S_OK == hr)
        {
            hr = DocfileCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_DOCFILE_NO_EXIST, 
                    DOCFILE | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = DocfileCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_DOCFILE_NO_EXIST, 
                    RUNTIME | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = DocfileCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_DOCFILE_EXIST, 
                    DOCFILE | EXIST | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = DocfileCreate(
                    dwRootMode,
                    pdgu,
                    CREATE_NONAME_DOCFILE, 
                    DOCFILE | NONAME | COMMIT, 
                    usIterations);          
        }

        if (S_OK != hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Error in DocfileCreate")));
        }

        // Test for StreamOpen
        
        if (S_OK == hr)
        {
            hr = StreamOpen(
                    dwRootMode,
                    pdgu,
                    OPEN_STORAGE_AND_STREAM, 
                    DOCFILE | COMMIT | OPENBOTH, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = StreamOpen(
                    dwRootMode,
                    pdgu,
                    OPEN_STORAGE_AND_STREAM, 
                    RUNTIME | COMMIT | OPENBOTH, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = StreamOpen(
                    dwRootMode,
                    pdgu,
                    OPEN_STREAM_ONLY, 
                    DOCFILE | COMMIT, 
                    usIterations);
        }

        if (S_OK == hr)
        {
            hr = StreamOpen(
                    dwRootMode,
                    pdgu,
                    OPEN_STREAM_ONLY, 
                    RUNTIME | COMMIT, 
                    usIterations);          
        }

        if (S_OK != hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Error in StreamOpen")));
        }

        // Generate an array of file names to use for the test

        if (S_OK == hr)
        {
            for (usIndex1=0; usIndex1<MAX_DOCFILES; usIndex1++)
            {
                hr = GenerateRandomName(
                        pdgu,
                        MINLENGTH,
                        MAXLENGTH,
                        &ptszNames[usIndex1]);

                DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;  

                if (S_OK != hr)
                {
                    break;
                }
            }
        }

        // Sequential operations

        if (S_OK == hr)
        {
            for (usIndex1=0; usIndex1<usIterations; usIndex1++)
            {
                hr = WriteStreamInSameSizeChunks(
                        dwRootMode,
                        pdgu,
                        SEQUENTIAL_WRITE, 
                        DOCFILE,
                        ulChunkSize,
                        usIndex1);

                if (S_OK == hr)
                {
                    hr = ReadStreamInSameSizeChunks(
                            dwRootMode,
                            SEQUENTIAL_READ,
                            DOCFILE,
                            ulChunkSize,
                            usIndex1);
                }

                if (S_OK == hr)
                {
                    hr = WriteStreamInSameSizeChunks(
                            dwRootMode,
                            pdgu,
                            SEQUENTIAL_WRITE,
                            RUNTIME,
                            ulChunkSize,
                            usIndex1);
                }

                if (S_OK == hr)
                {
                    hr = ReadStreamInSameSizeChunks(
                            dwRootMode,
                            SEQUENTIAL_READ,
                            RUNTIME,
                            ulChunkSize,
                            usIndex1);
                }

                if (S_OK != hr)
                {
                    DH_TRACE((DH_LVL_TRACE1, TEXT("Error in seq. write/read")));
                    break;
                }
            }
        }

        // Random operations

        if (S_OK == hr)
        {
            for (usIndex1=0; usIndex1<usIterations; usIndex1++)
            {
                hr = WriteStreamInSameSizeChunks(
                        dwRootMode,
                        pdgu,
                        RANDOM_WRITE, 
                        DOCFILE,
                        ulChunkSize,
                        usIndex1);

                if (S_OK == hr)
                {
                    hr = ReadStreamInSameSizeChunks(
                            dwRootMode,
                            RANDOM_READ, 
                            DOCFILE,
                            ulChunkSize,
                            usIndex1);
                }

                if (S_OK == hr)
                {
                    hr = WriteStreamInSameSizeChunks(
                            dwRootMode,
                            pdgu,
                            RANDOM_WRITE,
                            RUNTIME,
                            ulChunkSize,
                            usIndex1);
                }

                if (S_OK == hr)
                {
                    hr = ReadStreamInSameSizeChunks(
                            dwRootMode,
                            RANDOM_READ,
                            RUNTIME,
                            ulChunkSize,
                            usIndex1);
                }

                if (S_OK != hr)
                {
                    DH_TRACE((DH_LVL_TRACE1, TEXT("Error in random write/read")));
                    break;
                }
            }            
        }
        
        // Delete all files on disk

        if (S_OK == hr)
        {
            for (usIndex1=0; usIndex1<MAX_DOCFILES; usIndex1++)
            {
                if (NULL != ptszNames[usIndex1])
                {
                    if(FALSE == DeleteFile(ptszNames[usIndex1]))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError()) ;

                        DH_HRCHECK(hr, TEXT("DeleteFile")) ;
                    }
                }

                if (S_OK != hr)
                {
                    break;
                }
            }
        }

        // Delete temp strings

        for (usIndex1=0; usIndex1<MAX_DOCFILES; usIndex1++)
        {
            if (NULL != ptszNames[usIndex1])
            {
                delete []ptszNames[usIndex1];
                ptszNames[usIndex1] = NULL;
            }
        }

        if (NULL != ulSeekOffset)
        {
            delete []ulSeekOffset;
            ulSeekOffset = NULL;
        }
    }

    // Report statistics result for this run

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("\n\nTest was run %u iterations"), usIterations));
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("Test Type\t\tDocFile\t\tRuntime\t\tDocFile-RunTime\t\tDocFile\tRuntime")));
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("         \t\tavg (SD)\tavg (SD)\taverage (X) (SD)\ttotal\ttotal")));
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("=========\t\t=======\t\t=======\t\t===============\t\t=======\t=======")));

        for (usIndex1=FIRST_TIMING+1; usIndex1<LAST_TIMING; usIndex1++)
        {
            Statistics(
                Time[usIndex1].plDocfileTime,
                usIterations,
                &lAvgDocfileTime,
                &dTotalDocfileTime,
                &dSDDocfile);

            Statistics(
                Time[usIndex1].plRuntimeTime,
                usIterations,
                &lAvgRuntimeTime,
                &dTotalRuntimeTime,
                &dSDRuntime);

            DH_TRACE((DH_LVL_TRACE1, TEXT("%s"), Time[usIndex1].Text));
            DH_TRACE((DH_LVL_TRACE1, TEXT("\t%6.1ld"), lAvgDocfileTime));
            DH_TRACE((DH_LVL_TRACE1, TEXT(" (%3.1f)"), dSDDocfile));

            if (0 > dTotalRuntimeTime)
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("\t")));
                DH_TRACE((DH_LVL_TRACE1, TEXT("\t")));
                DH_TRACE((DH_LVL_TRACE1, TEXT("\t")));                
            }
            else
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("\t%6.1ld"), lAvgRuntimeTime));
                DH_TRACE((DH_LVL_TRACE1, TEXT(" (%2.1f)"), dSDRuntime));
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("\t%6.1f"), 
                    (dTotalDocfileTime - dTotalRuntimeTime)/usIterations));
            }

            if (0 < dTotalRuntimeTime)
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT(" (%2.1fx)"), dTotalDocfileTime / dTotalRuntimeTime));

                for (usIndex2=0; usIndex2<usIterations; usIndex2++)
                {
                    pdDocRunDiff[usIndex2] = 
                        ((float) Time[usIndex1].plDocfileTime[usIndex2]) / 
                                (Time[usIndex1].plRuntimeTime[usIndex2] + 1);
                }

                Statistics(
                    pdDocRunDiff,
                    usIterations,
                    &dAvgDocfileTime,
                    &dDocDiffTime,
                    &dSDDocfile);

                DH_TRACE((DH_LVL_TRACE1, TEXT(" (+- %2.1f)"), dSDDocfile));
            }
            else
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("   \t")));
            }

            DH_TRACE((DH_LVL_TRACE1, TEXT("\t%6.1f"), dTotalDocfileTime));

            if (0 <= dTotalRuntimeTime)
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("\t%6.1f "), dTotalRuntimeTime));
            }
            else
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("\t")));
            }

            if (NULL != Time[usIndex1].plDocfileTime)
            {
                delete Time[usIndex1].plDocfileTime;
                Time[usIndex1].plDocfileTime = NULL;
            }

            if (NULL != Time[usIndex1].plRuntimeTime)
            {
                delete Time[usIndex1].plRuntimeTime;
                Time[usIndex1].plRuntimeTime = NULL;
            }
        }

        if (NULL != pdDocRunDiff)
        {
            delete []pdDocRunDiff;
            pdDocRunDiff = NULL;
        }

        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("\nNote: All times are measured in milliseconds(accuracy of +- 55)."))); 
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation MISCTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation MISCTEST_102 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    MISCTEST_103
//
// Synopsis: Coverage for NTbug 117010. Test that we can't create a storage
//           if a stream with the same name already exists.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  9-Dec-1997     BogdanT     Created.
//
//-----------------------------------------------------------------------------
HRESULT MISCTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    LPTSTR          ptszFileName            = NULL;
    LPOLESTR        poleFileName            = NULL;
    LPTSTR          ptszStmName             = NULL;
    LPOLESTR        poleStmName             = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    ULONG           ulSeed                  = 0;
    LPSTORAGE       pRootStg                = NULL;
    LPSTORAGE       pStg                    = NULL;
    LPSTREAM        pStm                    = NULL;
    BOOL            fTransacted             = FALSE;
    DWORD           dwMode                  = STGM_CREATE          |
                                              STGM_READWRITE       |
                                              STGM_SHARE_EXCLUSIVE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("MISCTEST_103"));
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_103 started.")) );

    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

    pdgu = new(NullOnFail) DG_STRING(ulSeed);

    ulSeed = pdgu->GetSeed();

    if (NULL == pdgu)
    {
        hr = E_OUTOFMEMORY;
        DH_HRCHECK(hr, TEXT("new DG_STRING")) ;
    }

    pdgi = new(NullOnFail) DG_INTEGER(ulSeed);

    if (NULL == pdgi)
    {
        hr = E_OUTOFMEMORY;
        DH_HRCHECK(hr, TEXT("new DG_INTEGER")) ;
    }

    pdgi->Generate(&fTransacted, 0, 1);

    if(fTransacted)
    {
        DH_TRACE((DH_LVL_ALWAYS,
                  TEXT("Transacted mode")));
        dwMode |= STGM_TRANSACTED;
    }

    if(S_OK == hr)
    {
        // Generate random filename

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName pFileName")) ;
    }

    if(S_OK == hr)
    {
        hr = TStringToOleString(ptszFileName, &poleFileName);
        DH_HRCHECK(hr, TEXT("TStringToOleString poleFileName"));
    }

    if(S_OK == hr)
    {
        hr = StgCreateDocfile(poleFileName,
                              dwMode | STGM_DELETEONRELEASE,
                              0,
                              &pRootStg);

        DH_HRCHECK(hr, TEXT("StgCreateDocfile")) ;
    }

    if(S_OK == hr)
    {
        // Generate random name for stream&storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName pStmName")) ;
    }

    if(S_OK == hr)
    {
        hr = TStringToOleString(ptszStmName, &poleStmName);
        DH_HRCHECK(hr, TEXT("TStringToOleString poleStmName"));
    }

    if(S_OK == hr)
    {
        hr = pRootStg->CreateStream(poleStmName,
                                    STGM_CREATE    |
                                    STGM_READWRITE |
                                    STGM_SHARE_EXCLUSIVE,
                                    0,
                                    0,
                                    &pStm);
        DH_HRCHECK(hr, TEXT("CreateStream")) ;
    }

    if(S_OK == hr)
    {
        hr = pRootStg->CreateStorage(poleStmName,
                                     dwMode,
                                     0,
                                     0,
                                     &pStg);
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("Storage over stream succeeded!!!")));
            hr = E_FAIL;
        }
        else
        {
            hr = S_OK;
        }
    }

    if(S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("MISCTEST_103")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("MISCTEST_103")) );   
        DH_DUMPCMD((LOG_FAIL, TEXT(" /seed:%u"), ulSeed));
    }
    
    if(NULL != pStg)
    {
        pStg->Release();
    }

    if(NULL != pRootStg)
    {
        pRootStg->Release();
    }

    delete[] ptszFileName;
    delete[] poleFileName;
    delete[] ptszStmName;
    delete[] poleStmName;

    delete pdgu;
    delete pdgi;
 
    return hr;

}
//----------------------------------------------------------------------------
//
// Test:    MISCTEST_104
//
// Synopsis: Coverage for NTbug 117010. Test that we can't create a stream
//           if a storage with the same name already exists.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  9-Dec-1997     BogdanT     Created.
//
//-----------------------------------------------------------------------------
HRESULT MISCTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    LPTSTR          ptszFileName            = NULL;
    LPOLESTR        poleFileName            = NULL;
    LPTSTR          ptszStmName             = NULL;
    LPOLESTR        poleStmName             = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    ULONG           ulSeed                  = 0;
    LPSTORAGE       pRootStg                = NULL;
    LPSTORAGE       pStg                    = NULL;
    LPSTREAM        pStm                    = NULL;
    BOOL            fTransacted             = FALSE;
    DWORD           dwMode                  = STGM_CREATE          |
                                              STGM_READWRITE       |
                                              STGM_SHARE_EXCLUSIVE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("MISCTEST_104"));
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_104 started.")) );

    ulSeed = GetSeedFromCmdLineArgs(argc, argv);

    pdgu = new(NullOnFail) DG_STRING(ulSeed);

    ulSeed = pdgu->GetSeed();

    if (NULL == pdgu)
    {
        hr = E_OUTOFMEMORY;
        DH_HRCHECK(hr, TEXT("new DG_STRING")) ;
    }

    pdgi = new(NullOnFail) DG_INTEGER(ulSeed);

    if (NULL == pdgi)
    {
        hr = E_OUTOFMEMORY;
        DH_HRCHECK(hr, TEXT("new DG_INTEGER")) ;
    }

    pdgi->Generate(&fTransacted, 0, 1);

    if(fTransacted)
    {
        DH_TRACE((DH_LVL_ALWAYS,
                  TEXT("Transacted mode")));
        dwMode |= STGM_TRANSACTED;
    }

    if(S_OK == hr)
    {
        // Generate random filename

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName pFileName")) ;
    }

    if(S_OK == hr)
    {
        hr = TStringToOleString(ptszFileName, &poleFileName);
        DH_HRCHECK(hr, TEXT("TStringToOleString poleFileName"));
    }

    if(S_OK == hr)
    {
        hr = StgCreateDocfile(poleFileName,
                              dwMode | STGM_DELETEONRELEASE,
                              0,
                              &pRootStg);

        DH_HRCHECK(hr, TEXT("StgCreateDocfile")) ;
    }

    if(S_OK == hr)
    {
        // Generate random name for stream&storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName pStmName")) ;
    }

    if(S_OK == hr)
    {
        hr = TStringToOleString(ptszStmName, &poleStmName);
        DH_HRCHECK(hr, TEXT("TStringToOleString poleStmName"));
    }

    if(S_OK == hr)
    {
        hr = pRootStg->CreateStorage(poleStmName,
                                     dwMode,
                                     0,
                                     0,
                                     &pStg);
        DH_HRCHECK(hr, TEXT("CreateStorage")) ;
    }

    if(S_OK == hr)
    {
        hr = pRootStg->CreateStream(poleStmName,
                                    STGM_CREATE    |
                                    STGM_READWRITE |
                                    STGM_SHARE_EXCLUSIVE,
                                    0,
                                    0,
                                    &pStm);

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("Stream over storage succeeded!!!")));
            hr = E_FAIL;
        }
        else
        {
            hr = S_OK;
        }
    }

    if(S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("MISCTEST_104")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("MISCTEST_104")) );   
        DH_DUMPCMD((LOG_FAIL, TEXT(" /seed:%u"), ulSeed));
    }
    
    if(NULL != pStg)
    {
        pStg->Release();
    }

    if(NULL != pRootStg)
    {
        pRootStg->Release();
    }

    delete[] ptszFileName;
    delete[] poleFileName;
    delete[] ptszStmName;
    delete[] poleStmName;

    delete pdgu;
    delete pdgi;
 
    return hr;

}

//----------------------------------------------------------------------------
//
// Test:    MISCTEST_105
//
// Synopsis: Coverage for NTbug 144547. Test that if we open STGM_READ we
//           don't get other privileges; for that, before opening the
//           storage we're opening the underlying file with read&deny write.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  2-Mar-1998     BogdanT     Created.
//
//-----------------------------------------------------------------------------
HRESULT MISCTEST_105(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
/*    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    UINT            ulSeed                  = 0;
    LPTSTR          pRootDocFileName        = NULL;
    LPOLESTR        poleFileName            = NULL;
    LPSTORAGE       pRootStg                = NULL;
    DWORD           stgfmtOpen              = 0;
    HANDLE          hFile                   = INVALID_HANDLE_VALUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("MISCTEST_105"));
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation MISCTEST_105 started.")) );

    stgfmtOpen = STGFMT_DOCFILE;
    
    if(StorageIsFlat())
    {
        stgfmtOpen = STGFMT_FILE;
    }

    if(DoingOpenNssfile())
    {
        stgfmtOpen = STGFMT_NATIVE;
    }

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    if (S_OK == hr)
    {
        ulSeed = pTestChanceDF->GetSeed (); // for repro line

        if(NULL != pTestVirtualDF->GetDocFileName())
        {
            pRootDocFileName =
                new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

            if (pRootDocFileName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(pRootDocFileName, pTestVirtualDF->GetDocFileName());
            }
            DH_HRCHECK(hr, TEXT("new TCHAR"));
        }
        else
        {
            hr = TESTSTG_E_ABORT;
            DH_HRCHECK(hr, TEXT("VirtualDF::GetDocFileName")) ;
        }
        
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR
        hr = TStringToOleString(pRootDocFileName, &poleFileName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Now do a valid commit
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    if(S_OK == hr)
    {
        hFile = CreateFile(pRootDocFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if(INVALID_HANDLE_VALUE == hFile)
        {
            hr = TESTSTG_E_ABORT;
            DH_HRCHECK (hr, TEXT("CreateFile"));
        }
    }

    if(S_OK == hr)
    {
        hr = StgOpenStorageEx(poleFileName,
                              STGM_READ |
                              STGM_SHARE_DENY_WRITE,
                              stgfmtOpen,
                              0,
                              0,
                              0,
                              IID_IStorage,
                              (void**)&pRootStg);

        DH_HRCHECK(hr, TEXT("StgOpenStorageEx")) ;
    }

    if(S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("MISCTEST_105")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("MISCTEST_105")) );   
    }
    
    if(NULL != pRootStg)
    {
        pRootStg->Release();
    }

    if(INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }

     // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    delete[] pRootDocFileName;
    delete[] poleFileName;
*/ 
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\snbtests.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      snbtests.cxx
//
//  Contents:  storage base tests basically pertaining to String Name
//             Block (SNB) and STGM_PRIORITY mode.
//
//  Functions:  
//
//  History:    26-July-1996    Jiminli     Created.
//              27-Mar-97       SCousens    Conversionified
//
// BUGBUG: right now no snb params for nss apis.
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"
 
//----------------------------------------------------------------------------
//
// Test:    SNBTEST_100 
//
// Synopsis: The created root docfile is instantiated and traversed and the 
//           child objects found are selected at random for inclusion in an 
//           snbExclude structure. The docfile is commit and released. Then
//           the docfile is now re-instantiated with the just built SNB passed
//           in, indicating that the objects found in the SNB should be
//           returned as empty IStorages or zero length IStreams. The root 
//           docfile is then traversed and each object returned that matches
//           a name in the SNB is verified to determine that it's empty or
//           zero length.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  1-Aug-1996     JiminLi     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LLNORM.CXX
// 2.  Old name of test : LegitLimitedInstNormal Test 
//     New Name of test : SNBTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:1-2 /dfstg:1-3 /dfstm:0-3 /t:SNBTEST-100
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx /logloc:2 
//        /traceloc:2 /labmode
//     b. stgbase /seed:0 /dfdepth:1-2 /dfstg:3-5 /dfstm:8-10 /t:SNBTEST-100 
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /logloc:2 
//        /traceloc:2 /labmode
//     c. stgbase /seed:0 /dfdepth:1-2 /dfstg:1-3 /dfstm:6-9 /t:SNBTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//        /logloc:2 /traceloc:2 /labmode
// 
// BUGNOTE: Conversion: SNBTEST-100 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT SNBTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    SNB             snbNamesToExclude       = NULL;
    SNB             snbDelIndex             = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("SNBTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,TEXT("Attempt legitimate SNB tests on a docfile")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for SNBTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step. The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));

    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }
  
    // Release root and all open IStorages/IStreams pointers under it

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }

    // instantiate root docfile with snbExclude param = NULL
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }
    
    // exclude up to MAX_NAMES_TO_EXCLUDE names

    if (S_OK == hr)
    {
        snbNamesToExclude = (OLECHAR **) new OLECHAR[sizeof(OLECHAR *) * 
                            MAX_NAMES_TO_EXCLUDE];

        if (NULL == snbNamesToExclude)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            *snbNamesToExclude = NULL;
        }
    }

    // Traverse docfile(one level) and randomly select names to exclude upon
    // re-instantiation

    if (S_OK == hr)
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                FALSE,
                TRUE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }
 
    // Since no actual operations on child storages and streams, only need 
    // commit and release root storage.

    // Commit root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // instantiate root docfile with snbExclude set to our SNB of names
    // to exclude
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, snbNamesToExclude, 0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }

    // Traverse docfile(one level) and check names returned against names
    // in exclude block

    if ((S_OK == hr) && (NULL != *snbNamesToExclude))
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                FALSE,
                FALSE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release root and all open IStorages/IStreams pointers under it

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }
  
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation SNBTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation SNBTEST_100 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    
    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pRootDocFileName= new TCHAR[_tcslen(
                            pTestVirtualDF->GetDocFileName())+1];

        if (NULL != pRootDocFileName)
        {
            _tcscpy(pRootDocFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Free SNB 

    if (NULL != snbNamesToExclude)
    {
        snbDelIndex = snbNamesToExclude;

        while (NULL != *snbDelIndex)
        {
            delete [] *snbDelIndex;
            *snbDelIndex = NULL;
      
            snbDelIndex++;
        }

        delete [] snbNamesToExclude;
        snbNamesToExclude = NULL;
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings

    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    SNBTEST_101 
//
// Synopsis: The created root docfile is instantiated and traversed and the 
//           child objects found are selected at random for inclusion in an 
//           snbExclude structure. 50% of the time, a bogus name is placed in 
//           the snbExclude block instead. The test should verify that the
//           valid names were properly zeroed out, and that the bogus names in 
//           the SNB block are ignored, i.e. don't cause an error.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  30-July-1996     JiminLi     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: ILNORM.CXX
// 2.  Old name of test : IllegitLimitedInstNormal Test 
//     New Name of test : SNBTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:1-2 /dfstg:1-3 /dfstm:0-3 /t:SNBTEST-101 
//        /dfRootMode:dirReadWriteShEx  /logloc:2 /traceloc:2 /labmode
//     b. stgbase /seed:0 /dfdepth:1-2 /dfstg:3-5 /dfstm:8-10 /t:SNBTEST-101 
//        /dfRootMode:xactReadWriteShEx /logloc:2 /traceloc:2 /labmode
//     c. stgbase /seed:0 /dfdepth:1-2 /dfstg:1-3 /dfstm:6-9 /t:SNBTEST-101 
//        /dfRootMode:xactReadWriteShDenyW /logloc:2 /traceloc:2 /labmode
// 
// BUGNOTE: Conversion: SNBTEST-101 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT SNBTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    SNB             snbNamesToExclude       = NULL;
    SNB             snbDelIndex             = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("SNBTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1,TEXT("Attempt illegitimate SNB tests on a docfile")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for SNBTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step. The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }
  
    // Release root and all open IStorages/IStreams pointers under it

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }

    // instantiate root docfile with snbExclude param = NULL
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }
    
    // exclude up to MAX_NAMES_TO_EXCLUDE names

    if (S_OK == hr)
    {
        snbNamesToExclude = (OLECHAR **) new OLECHAR[sizeof(OLECHAR *) *
                            MAX_NAMES_TO_EXCLUDE];

        if (NULL == snbNamesToExclude)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            *snbNamesToExclude = NULL;
        }
    }

    // Traverse docfile(one level) and randomly select names to exclude upon
    // re-instantiation

    if (S_OK == hr)
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                TRUE,
                TRUE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }
 
    // Since no actual operations on child storages and streams, only need 
    // commit and release root storage.

    // Commit root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // instantiate root docfile with snbExclude set to our SNB of names
    // to exclude
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(NULL, dwRootMode, snbNamesToExclude, 0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }

    // Traverse docfile(one level) and check names returned against names
    // in exclude block

    if ((S_OK == hr) && (NULL != *snbNamesToExclude))
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                TRUE,
                FALSE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release root and all open IStorages/IStreams pointers under it

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }
  
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation SNBTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation SNBTEST_101 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    
    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pRootDocFileName= new TCHAR[_tcslen(
                            pTestVirtualDF->GetDocFileName())+1];

        if (NULL != pRootDocFileName)
        {
            _tcscpy(pRootDocFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Free SNB 

    if (NULL != snbNamesToExclude)
    {
        snbDelIndex = snbNamesToExclude;

        while (NULL != *snbDelIndex)
        {
            delete [] *snbDelIndex;
            *snbDelIndex = NULL;
      
            snbDelIndex++;
        }

        delete [] snbNamesToExclude;
        snbNamesToExclude = NULL;
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings

    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    SNBTEST_102
//
// Synopsis: The created root docfile is instantiated with STGM_PRIORITY 
//           specified and then it is traversed and the child objects found 
//           are selected at random for inclusion in an snbExclude structure.
//           Then the docfile is now re-instantiated using the just built SNB
//           and the original root IStorage passed as pstgPriority parameter.
//           This effectively removes the PRIORITY classification of this 
//           docfile while excluding the possibility of an opening of the root
//           docfile by another process. The SNB that was passed in indicates 
//           that the objects found in the SNB should be returned as empty 
//           IStorages or zero length IStreams. The root docfile is then 
//           traversed and each object returned that matches a name in the SNB
//           is verified to determine that it's empty or zero length.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  1-Aug-1996     JiminLi     Created.
//
// Notes:    This test runs in DIRECT mode only since DIRECT is the only
//           valid mode for a root instantiation with STGM_PRIORITY specified.
//
// New Test Notes:
// 1.  Old File: LLPRIOR.CXX
// 2.  Old name of test : LegitLimitedInstPriority Test 
//     New Name of test : SNBTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:1-2 /dfstg:3-5 /dfstm:6-8 /t:SNBTEST-102
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx /logloc:2 
//        /traceloc:2 /labmode
// 
// BUGNOTE: Conversion: SNBTEST-102 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT SNBTEST_102(int argc, char* argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualDF       *pTestVirtualCopyDF     = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pVirtualCopyDFRoot     = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          pRootDocFileName        = NULL;
    LPTSTR          pRootCopyDocFileName    = NULL;
    LPSTORAGE       pStgRootDF              = NULL;
    LPSTORAGE       pStgRootCopyDF          = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    SNB             snbNamesToExclude       = NULL;
    SNB             snbDelIndex             = NULL;
 
    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("SNBTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1,TEXT("Attempt legitimate SNB tests on a docfile")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for SNBTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step. The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pRootDocFileName = new TCHAR[_tcslen(pTestVirtualDF
                                     ->GetDocFileName())+1];

        if (NULL != pRootDocFileName)
        {
            _tcscpy(pRootDocFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Release root and all open IStorages/IStreams pointers under it

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }

    // instantiate root docfile with snbExclude param = NULL
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(
                NULL, 
                STGM_READ  | STGM_DIRECT | STGM_PRIORITY, 
                NULL, 
                0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }

    if (S_OK == hr)
    {
        pStgRootDF = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootDF);
    }

    // exclude up to MAX_NAMES_TO_EXCLUDE names

    if (S_OK == hr)
    {
        snbNamesToExclude = (OLECHAR **) new OLECHAR[sizeof(OLECHAR *) * 
                            MAX_NAMES_TO_EXCLUDE];

        if (NULL == snbNamesToExclude)
        {
            hr = E_OUTOFMEMORY;
        }

        *snbNamesToExclude = NULL;
    }

    // Traverse docfile(one level) and randomly select names to exclude upon
    // re-instantiation

    if (S_OK == hr)
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                FALSE,
                TRUE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }

    // Generate a copy of the original docfile

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->CopyVirtualDocFileTree(
                pVirtualDFRoot,
                NEW_STGSTM,
                &pVirtualCopyDFRoot);

        DH_ASSERT(NULL != pVirtualCopyDFRoot);

        DH_HRCHECK(hr, TEXT("VirtualDF::CopyVirtualDocFileTree"));
    }

    // Create a new VirtualDF tree

    if (S_OK == hr)
    {
        pTestVirtualCopyDF = new VirtualDF();

        if(NULL == pTestVirtualCopyDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    // instantiate root docfile with snbExclude set to our SNB of names
    // to exclude and also pass in previous opening of this root docfile
    // as parameter pstgPriority.

    // The reason of AddRefCount is Ole code just release pStgRootDF once, 
    // and it's user's responsibility to release all references to it and 
    // finally set it to NULL.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->AddRefCount();
        
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::AddRefCount"));
    }
   
    if (S_OK == hr)
    {
        hr = pVirtualCopyDFRoot->Open(
                pStgRootDF, 
                STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_DENY_NONE, 
                snbNamesToExclude, 
                0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        pStgRootCopyDF = pVirtualCopyDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootCopyDF);
    }

    // Assocaies a VirtualDF tree with a VirtualCtrNode and its _pstg
    // The purpose it later on we can delete the related space taken 
    // by the copied docfile.

    if (S_OK == hr)
    {
        hr = pTestVirtualCopyDF->Associate(pVirtualCopyDFRoot, pStgRootCopyDF);

        DH_HRCHECK(hr, TEXT("pTestVirtualCopyDF::Associate"));
    }

    // Traverse docfile(one level) and check names returned against names
    // in exclude block

    if ((S_OK == hr) && (NULL != *snbNamesToExclude))
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualCopyDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                FALSE,
                FALSE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }

    // Release the copied root and all open IStorages/IStreams 
    // pointers under it. Note: now the original VirtualDFRoot is
    // not valid any more.
  
    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualCopyDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation SNBTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation SNBTEST_102 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    
    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualCopyDFRoot && pTestVirtualCopyDF->GetDocFileName())
    {
        pRootCopyDocFileName = new TCHAR[_tcslen(pTestVirtualCopyDF
                                         ->GetDocFileName())+1];

        if (NULL != pRootCopyDocFileName)
        {
            _tcscpy(pRootCopyDocFileName, pTestVirtualCopyDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    if(NULL != pTestVirtualCopyDF)
    {
        hr2 = pTestVirtualCopyDF->DeleteVirtualDocFileTree(pVirtualCopyDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualCopyDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualCopyDF;
        pTestVirtualCopyDF = NULL;
    }

    // Free SNB 

    if (NULL != snbNamesToExclude)
    {
        snbDelIndex = snbNamesToExclude;

        while (NULL != *snbDelIndex)
        {
            delete [] *snbDelIndex;
            *snbDelIndex = NULL;
      
            snbDelIndex++;
        }

        delete [] snbNamesToExclude;
        snbNamesToExclude = NULL;
    }

    // Delete the docfile on disk

    if ((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }
 
    // Delete temp strings

    if (NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    if (NULL != pRootCopyDocFileName)
    {
        delete pRootCopyDocFileName;
        pRootCopyDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr; 
}


//----------------------------------------------------------------------------
//
// Test:    SNBTEST_103
//
// Synopsis: The created root docfile is instantiated with STGM_PRIORITY 
//           specified and then it is traversed and the child objects found 
//           are selected at random for inclusion in an snbExclude structure.
//           50% of the time, a bogus name is placed in the snbExclude block
//           instead. The docfile is then re-instantiated using the just built
//           SNB and the original root IStorage passed as pstgPriority 
//           parameter. The root docfile is then traversed and the test should
//           verify that the valid names were properly zeroed out, and that 
//           the bogus names in the SNB block are ignored, i.e. do not cause 
//           an error.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  3-Aug-1996     JiminLi     Created.
//
// Notes:    This test runs in DIRECT mode only since DIRECT is the only
//           valid mode for a root instantiation with STGM_PRIORITY specified.
//
// New Test Notes:
// 1.  Old File: ILPRIOR.CXX
// 2.  Old name of test : IllegitLimitedInstPriority Test 
//     New Name of test : SNBTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:1-2 /dfstg:3-5 /dfstm:6-8 /t:SNBTEST-103
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx /logloc:2 
//        /traceloc:2 /labmode
// 
// BUGNOTE: Conversion: SNBTEST-103 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT SNBTEST_103(int argc, char* argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualDF       *pTestVirtualCopyDF     = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pVirtualCopyDFRoot     = NULL;
    VirtualCtrNode  *pVirtualChildStg       = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          pRootDocFileName        = NULL;
    LPTSTR          pRootCopyDocFileName    = NULL;
    LPSTORAGE       pStgRootDF              = NULL;
    LPSTORAGE       pStgChild               = NULL;
    LPSTORAGE       pStgRootCopyDF          = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    SNB             snbNamesToExclude       = NULL;
    SNB             snbDelIndex             = NULL;  
 
    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("SNBTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_103 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt legitimate STGM_PRIORITY related test on a docfile")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for SNBTEST_103, Access mode: %lx"),
            dwRootMode));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step. The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pRootDocFileName = new TCHAR[_tcslen(
                            pTestVirtualDF->GetDocFileName())+1];

        if (NULL != pRootDocFileName)
        {
            _tcscpy(pRootDocFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Get the first child storage pointer for later illegitmate test,

    if (S_OK == hr)
    {
        pVirtualChildStg = pVirtualDFRoot->GetFirstChildVirtualCtrNode();
        DH_ASSERT(NULL != pVirtualChildStg);

        pStgChild = pVirtualChildStg->GetIStoragePointer();
        DH_ASSERT(NULL != pStgChild);
    }
 
    // Release root and all open IStorages/IStreams pointers under it

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }

    // instantiate root docfile with snbExclude param = NULL, and also
    // STGM_PRIORITY is set in grfMode.
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                STGM_READ | STGM_DIRECT | STGM_PRIORITY, 
                NULL,
                0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }

    if (S_OK == hr)
    {
        pStgRootDF = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootDF);
    }
  
    // exclude up to MAX_NAMES_TO_EXCLUDE names

    if (S_OK == hr)
    {
        snbNamesToExclude = (OLECHAR **) new OLECHAR[sizeof(OLECHAR *) * 
                            MAX_NAMES_TO_EXCLUDE];

        if (NULL == snbNamesToExclude)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            *snbNamesToExclude = NULL;
        }
    }

    // Traverse docfile(one level) and randomly select names to exclude upon
    // re-instantiation. The sixth param == TRUE shows that this is an
    // illegit test, i.e. 50% chance we will add bogus names into SNB.

    if (S_OK == hr)
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                TRUE,
                TRUE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }
 
    // Generate a copy of the original docfile

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->CopyVirtualDocFileTree(
                pVirtualDFRoot,
                NEW_STGSTM,
                &pVirtualCopyDFRoot);

        DH_ASSERT(NULL != pVirtualCopyDFRoot);

        DH_HRCHECK(hr, TEXT("VirtualDF::CopyVirtualDocFileTree"));
    }

    // Create a new VirtualDF tree

    if (S_OK == hr)
    {
        pTestVirtualCopyDF = new VirtualDF();

        if(NULL == pTestVirtualCopyDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // instantiate root docfile with snbExclude set to our SNB of names
    // to exclude and also pass in previous opening of this root docfile
    // as parameter pstgPriority.
 
    // First we passed in the substorage pointer as pstgPriority parameter,
    // it is closed, so it should fail.

#ifdef _MAC 

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!Opening a VirtualCtrNode with invalid substorage ptr. skipped")) );

#else
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(
                pStgChild, 
                dwRootMode, 
                snbNamesToExclude, 
                0);
     
        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open failed as expected, hr=0x%lx."),
                hr));
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open should have failed.")));
            hr = E_FAIL;
        }
    }
#endif //_MAC

    // Now we passed in correct storage pointer and have illegimate
    // SNB test. The reason of AddRefCount is Ole code just release
    // pStgRootDF once, and it's user's responsibility to release all
    // references to it and finally set it to NULL.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->AddRefCount();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::AddRefCount"));
    }
   
    if (S_OK == hr)
    {
        hr = pVirtualCopyDFRoot->Open(
                pStgRootDF, 
                STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_DENY_NONE,
                snbNamesToExclude, 
                0);
     
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
    }
    
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        pStgRootCopyDF = pVirtualCopyDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootCopyDF);
    }

    // Assocaies a VirtualDF tree with a VirtualCtrNode and its _pstg
    // The purpose it later on we can delete the related space taken 
    // by the copied docfile.

    if (S_OK == hr)
    {
        hr = pTestVirtualCopyDF->Associate(pVirtualCopyDFRoot, pStgRootCopyDF);

        DH_HRCHECK(hr, TEXT("pTestVirtualCopyDF::Associate"));
    }

    // Traverse docfile(one level) and check names returned against names
    // in exclude block

    if ((S_OK == hr) && (NULL != *snbNamesToExclude))
    {
        hr = TraverseDocfileAndWriteOrReadSNB(
                pVirtualCopyDFRoot,
                pdgi,
                pdgu,
                dwStgMode,
                snbNamesToExclude,
                FALSE,
                FALSE);

        DH_HRCHECK(hr, TEXT("TraverseDocfileAndWriteOrReadSNB"));
    }

    // Release the copied root and all open IStorages/IStreams 
    // pointers under it. Note: now the original VirtualDFRoot is
    // not valid any more.
  
    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualCopyDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms completed Ok.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseOpenStgsStms not Ok, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation SNBTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation SNBTEST_103 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    
    // Get the name of file, will be used later to delete the file

    if ((S_OK == hr) && (NULL != pVirtualCopyDFRoot))
    {
        pRootCopyDocFileName = new TCHAR[_tcslen(pTestVirtualCopyDF
                                         ->GetDocFileName())+1];

        if (NULL != pRootCopyDocFileName)
        {
            _tcscpy(pRootCopyDocFileName, pTestVirtualCopyDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    if ((S_OK == hr) && (NULL != pTestVirtualCopyDF))
    {
        hr2 = pTestVirtualCopyDF->DeleteVirtualDocFileTree(pVirtualCopyDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualCopyDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualCopyDF;
        pTestVirtualCopyDF = NULL;
    }

    // Free SNB 

    if (NULL != snbNamesToExclude)
    {
        snbDelIndex = snbNamesToExclude;

        while (NULL != *snbDelIndex)
        {
            delete [] *snbDelIndex;
            *snbDelIndex = NULL;
      
            snbDelIndex++;
        }

        delete [] snbNamesToExclude;
        snbNamesToExclude = NULL;
    }

    // Delete the docfile on disk

    if ((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }
 
    // Delete temp strings

    if (NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    if (NULL != pRootCopyDocFileName)
    {
        delete pRootCopyDocFileName;
        pRootCopyDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation SNBTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\roottsts.cxx ===
-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      roottsts.cxx
//
//  Contents:  storage base tests basically pertaining to root tests in general 
//
//  Functions:  
//
//  History:    24-June-1996     NarindK     Created.
//              27-Mar-97        SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include <sys/stat.h>
#include <share.h>
#include  "init.hxx"

//----------------------------------------------------------------------------
//
// Test:    ROOTTEST_100 
//
// Synopsis: A randomly named file is created and random data is written 
//           into it.The file is converted to a root docfile, then new IStorage
//           (root docfile) is committed and enumerated to ensure that only
//           a single IStream named "CONTENTS" (STG_CONVERTED_NAME) exists.
//           The CONTENTS IStream is instantiated, read, verified, and released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:   24-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LRCONV.CXX
// 2.  Old name of test : LegitRootConvert test 
//     New Name of test : ROOTTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-100
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-100
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-100
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: ROOTTEST-100 NO
//
//-----------------------------------------------------------------------------

HRESULT ROOTTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = NULL;
    LPSTORAGE       pIStorage               = NULL;
    LPOLESTR        pOleStrTemp             = NULL;
    ULONG           ulRef                   = 0;
    FILE            *hFile                  = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPTSTR          ptszRandomDataBuffer    = NULL;
    ULONG           cMin                    = 512;
    ULONG           cMax                    = 4096;
    ULONG           cRandom                 = 0;
    ULONG           culBytesWritten         = 0;
    DWORD           dwMemCRC                = 0;
    DWORD           dwActCRC                = 0;
    LPENUMSTATSTG   penumWalk               = NULL;
    LPTSTR          ptszConvName            = NULL;
    STATSTG         statStg;
    ULONG           cItemsInConvertedDocFile= 0;
    LPMALLOC        pMalloc                 = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ROOTTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt legitimate ops on Root conversion.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new ChanceDF")) ;
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);
        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        DH_TRACE((DH_LVL_TRACE1,
            TEXT("Run Mode for ROOTTEST_100, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.
        pdgu = new(NullOnFail) DG_STRING(pTestChanceDF->GetSeed());
        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new DG_STRING")) ;
    }

    // Generate RootDocFile name
    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &pRootDocFileName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR
        hr = TStringToOleString(pRootDocFileName, &pOleStrTemp);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Try calling StgCreateDocFile with mode as per dwRootFlags | STGM_CONVERT
    // This tests the case of CONVERT specified, but no file exists to convert.
    // This shouldn't fail.

    // Just make sure no DocFile of the name exists.  Delete if it does.
    if(NULL != pRootDocFileName)
    {
        DeleteFile(pRootDocFileName);
    }

    if (S_OK == hr)
    {
        pIStorage = NULL;
        HRESULT hr2 = StgCreateDocfile(
                pOleStrTemp,
                pTestChanceDF->GetRootMode() | STGM_CONVERT,
                0,
                &pIStorage);

        if(S_OK == hr2 && NULL != pIStorage)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("StgCreateDocFile passed as expected.")));
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, 
                TEXT("StgCreateDocFile failed unexpectedly, hr = 0x%lx ."), hr));
            hr = (S_OK==hr2)?E_FAIL:hr2;
        }
    }
    
    // Now do a valid commit
    if (S_OK == hr)
    {
        hr = pIStorage->Commit(STGC_DEFAULT);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, 
                TEXT("IStorage::Commit unsuccessful, hr=0x%lx."), hr));
        }
    }


    // Close the root docfile
    if (NULL != pIStorage)
    {
        ulRef = pIStorage->Release();
        DH_ASSERT(0 == ulRef);
        pIStorage = NULL;
    }

    //Now actually prepare the file and then attempt conversion.
    if (S_OK == hr)
    {
        hFile = _tfopen(pRootDocFileName, TEXT("w+"));
        if(NULL == hFile)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("_tfopen")) ;
    } 
  
    if(S_OK == hr)
    {
        // Create a new DataGen object to create random INTEGER.
        pdgi = new(NullOnFail) DG_INTEGER(pTestChanceDF->GetSeed());
        if (NULL == pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new DG_INTEGER")) ;
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("Generate")) ;
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu,cRandom, cRandom, &ptszRandomDataBuffer);
        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if(S_OK == hr)
    {
        // Calculate CRC on this buffer ptszRandomDataBuffer
        hr = CalculateCRCForDataBuffer(
                ptszRandomDataBuffer,
                cRandom,
                &dwMemCRC);
        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer")) ;
    }

    if(S_OK == hr)
    {
        // Write to file using fwrite with above data and close the file.
        culBytesWritten = fwrite((void *) ptszRandomDataBuffer,
                             (size_t) 1,
                             (size_t) cRandom,
                             hFile);
        DH_ASSERT(culBytesWritten == cRandom);
    }

    if (NULL != hFile)
    {
        fclose(hFile);
    }

    // Call StgCreateDocfile with STGM_CONVERT now.
    if (S_OK == hr)
    {
        pIStorage = NULL;

        HRESULT hr2 = StgCreateDocfile(
                pOleStrTemp,
                pTestChanceDF->GetRootMode() | STGM_CONVERT,
                0,
                &pIStorage);

        if(STG_S_CONVERTED == hr2 && pIStorage!=NULL)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("StgCreateDocFile passed as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgCreateDocFile failed unexpectedly, hr = 0x%lx ."), hr));

            hr = (hr2==S_OK)?E_FAIL:hr2;
        }
    }

    // Commit the Root DocFile
    if (S_OK == hr)
    {
        hr = pIStorage->Commit(STGC_DEFAULT);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit unsuccessful, hr=0x%lx."), hr));
        }
    }

    // Close the root docfile
    if (NULL != pIStorage)
    {
        ulRef = pIStorage->Release();
        DH_ASSERT(0 == ulRef);
        pIStorage = NULL;
    }

    // Verify the CRC by opening Root DocFile, reading its CONTENTS stream,
    // calculating CRC on that and comparing that against the earlier CRC.
    if (S_OK == hr)
    {
        pIStorage = NULL;
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                pTestChanceDF->GetRootMode(),
                NULL,
                0,
                &pIStorage);

        if(S_OK == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("StgOpenStorage passed as expected.")));

            if(NULL == pIStorage)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("StgCreateDocfile failed to return IStorage"),
                    hr));

                hr = E_FAIL;
            }
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgOpenStorage failed unexpectedly, hr = 0x%lx."), hr));
        }
    }
   
    if(S_OK == hr)
    {
        hr =  pIStorage->EnumElements(0, NULL, 0, &penumWalk);
        DH_HRCHECK(hr, TEXT("IStorage::EnumElements")) ;
    }

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);
        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }
 
    // Call Next with celt equal to zero
    while((S_OK == hr) && (S_OK == penumWalk->Next(1, &statStg , NULL)))
    {
        cItemsInConvertedDocFile++;

        //Convert OLECHAR to TCHAR
        hr = OleStringToTString(statStg.pwcsName, &ptszConvName);
        DH_HRCHECK(hr, TEXT("OleStringToTString")) ;

        if(S_OK == hr)
        {
            if((statStg.type != STGTY_STREAM) ||
               (0 != _tcscmp(ptszConvName, STG_CONVERTED_NAME))) 
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("Converted DocFile containes other than %s stream"),
                     STG_CONVERTED_NAME));

                hr = E_FAIL;
            }
        }
    
        if(S_OK == hr)
        {
            hr = CalculateCRCForDocFileStmData(
                    pIStorage,
                    STG_CONVERTED_NAME,
                    statStg.cbSize.LowPart,
                    &dwActCRC);
            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFileStmData")) ;
        }

        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;        
        }
    }

    // Release LPENUMSTATSTG pointer
    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT(0 == ulRef);
        penumWalk = NULL;
    }

    // Release pMalloc
    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // Close the root docfile
    if (NULL != pIStorage)
    {
        ulRef = pIStorage->Release();
        DH_ASSERT(0 == ulRef);
        pIStorage = NULL;
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr)                    &&
        (1 == cItemsInConvertedDocFile) &&
        (dwMemCRC == dwActCRC)) 
    {
        DH_TRACE((DH_LVL_TRACE1,
           TEXT("CRC of ordinary file & converted DocFile equal as exp.")));
        DH_TRACE((DH_LVL_TRACE1,
           TEXT("Ordinary file contents converted to CONTENTS stm as exp.")));
        DH_LOG((LOG_PASS, TEXT("Test variation ROOTTEST_100 passed.")) );
    }
    else
    {
        DH_TRACE((DH_LVL_TRACE1,
           TEXT("CRC don't match or docfile not correctly cpnverted unexp")));

        DH_LOG((LOG_FAIL, 
            TEXT("Test variation ROOTTEST_100 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Delete Chance docfile tree
    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());
        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete temp string
    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    if(NULL != ptszRandomDataBuffer)
    {
        delete ptszRandomDataBuffer;
        ptszRandomDataBuffer = NULL;
    }

    if(NULL != ptszConvName)
    {
        delete ptszConvName;
        ptszConvName = NULL;
    }

    // Delete DataGen object
    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    if(NULL != pdgi)
    {
        delete pdgi;
        pdgi = NULL;
    }

    // Delete the docfile on disk
    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;
            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string
    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    ROOTTEST_101 
//
// Synposis: From 4 to 16 temporary (NULL name) root docfiles are created,
//       committed, Stat'ed, determined to be a storage object, released,
//       and instantiated with STG_E_FAILIFTHERE to prove that the temporary
//       docfile remained persistent.  The docfile is then deleted.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:   24-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LRCONV.CXX
// 2.  Old name of test : LegitRootNull test 
//     New Name of test : ROOTTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-101
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-101
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-101
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: ROOTTEST-101 NO
//
//-----------------------------------------------------------------------------

HRESULT ROOTTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    DWORD           dwRootMode              = NULL;
    LPSTORAGE       pIStorage               = NULL;
    ULONG           ulRef                   = 0;
    DG_INTEGER      *pdgi                   = NULL;
    STATSTG         statStg;
    LPMALLOC        pMalloc                 = NULL;
    LPTSTR          ptszRootTempName        = NULL;
    LPOLESTR        poszRootTempName        = NULL;
    BOOL            fPass                   = TRUE;
    ULONG           cNumVars                = 0;
    ULONG           cRandomMinVar           = 4;
    ULONG           cRandomMaxVar           = 16;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ROOTTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt legitimate ops on temporaray root docfile.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new ChanceDF")) ;
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);
        DH_HRCHECK(hr, TEXT("ChanceDF::CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ROOTTEST_101, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random numbers.
        pdgi = new(NullOnFail) DG_INTEGER(pTestChanceDF->GetSeed());
        if (NULL == pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new DG_INTEGER")) ;
    }

    // Generate RootDocFile name

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&cNumVars, cRandomMinVar, cRandomMaxVar);
        DH_HRCHECK(hr, TEXT("Generate")) ;
    }

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);
        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    while((0 != cNumVars) && (S_OK == hr) && (TRUE == fPass))
    {
        cNumVars--;
        DH_TRACE((DH_LVL_TRACE1, TEXT("cNumVars = %ld "), cNumVars));

        // Try calling StgCreateDocFile with NULL name - temporary root DocFile 
        if (S_OK == hr)
        {
            pIStorage = NULL;
            hr = StgCreateDocfile(
                    NULL,
                    pTestChanceDF->GetRootMode() | STGM_CREATE,
                    0,
                    &pIStorage);
            DH_HRCHECK(hr, TEXT(" StgCreateDocfile")) ;
        }

        // Now do a valid commit.  BUGBUG: Use random modes..
        if (S_OK == hr)
        {
            hr = pIStorage->Commit(STGC_DEFAULT);
            DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
        }

        // Do a Stat on root Docfile
        if (S_OK == hr)
        {
            hr = pIStorage->Stat(&statStg, STATFLAG_DEFAULT);
            DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
        }

        if(S_OK == hr)
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(statStg.pwcsName, &ptszRootTempName);
            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            // Convert TCHAR name to OLECHAR
            hr = TStringToOleString(ptszRootTempName, &poszRootTempName);
            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        // Check with StgIsStorage
        if(S_OK == hr)
        {
            hr = StgIsStorageFile(poszRootTempName);
            DH_HRCHECK(hr, TEXT("StgIsStorageFile"));
        }

        // Close the root docfile
        if (S_OK == hr)
        {
            ulRef = pIStorage->Release();
            DH_ASSERT(0 == ulRef);
        }

        // Again call StgIsStorage now

        if(S_OK == hr)
        {
            hr = StgIsStorageFile(poszRootTempName);
            DH_HRCHECK(hr, TEXT("StgIsStorageFile"));
        }

        // Call StgCreateDocFile with STGM_FAILIFTHERE flag.  This should fail.
        if (S_OK == hr)
        {
            pIStorage = NULL;
            HRESULT hr2 = StgCreateDocfile(
                    poszRootTempName,
                    pTestChanceDF->GetRootMode() | STGM_FAILIFTHERE,
                    0,
                    &pIStorage);

            if((S_OK != hr2) && (NULL == pIStorage))
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("StgCreateDocFile failed as expected, hr = 0x%lx."),hr2));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_ERROR, 
                    TEXT("StgCreateDocFile passed unexpectedly,hr=0x%lx "), hr2));

                hr = (hr2==S_OK)?E_FAIL:hr2;
                fPass = FALSE;
            }

        }

        // Try calling StgCreateDocFile with STGM_CREATE| STGM_DELETEONRELEASE 
        if (S_OK == hr)
        {
            pIStorage = NULL;
            hr = StgCreateDocfile(
                    poszRootTempName,
                    pTestChanceDF->GetRootMode()|
                    STGM_CREATE                 |
                    STGM_DELETEONRELEASE,
                    0,
                    &pIStorage);
            DH_HRCHECK(hr, TEXT(" StgCreateDocfile")) ;
        }

        // Now do a valid commit.  BUGBUG: Use random modes..
        if (S_OK == hr)
        {
            hr = pIStorage->Commit(STGC_DEFAULT);
            DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
        }

        // Delete temp string
        if(NULL != ptszRootTempName)
        {
            delete ptszRootTempName;
            ptszRootTempName = NULL;
        }

        if(NULL != poszRootTempName)
        {
            delete poszRootTempName;
            poszRootTempName = NULL;
        }

        // Free the statStg.pwcsName
        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        // Stat the root IStorage
        if (S_OK == hr)
        {
            hr = pIStorage->Stat(&statStg, STATFLAG_DEFAULT);
            DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
        }

        if(S_OK == hr)
        {
           //Convert OLECHAR to TCHAR
            hr = OleStringToTString(statStg.pwcsName, &ptszRootTempName);
            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            // Convert TCHAR name to OLECHAR
            hr = TStringToOleString(ptszRootTempName, &poszRootTempName);
            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        // Check with StgIsStorage
        if(S_OK == hr)
        {
            hr = StgIsStorageFile(poszRootTempName);
            DH_HRCHECK(hr, TEXT("StgIsStorageFile")) ;
        }

        // Close the root docfile
        if (S_OK == hr)
        {
            ulRef = pIStorage->Release();
            DH_ASSERT(0 == ulRef);
        }

        // Again call StgIsStorage now
        if(S_OK == hr)
        {
            HRESULT hr2 = StgIsStorageFile(poszRootTempName);
            if(STG_E_FILENOTFOUND == hr2)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("StgIsStorage returned hr = 0x%lx as expected."), hr2));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_ERROR,
                    TEXT("StgIsStorage returned hr = 0x%lx unexpectedly."), hr2));

                hr = (hr2==S_OK)?E_FAIL:hr2;
                fPass = FALSE;
            }
        }

        // Delete temp string
        if(NULL != ptszRootTempName)
        {
            delete ptszRootTempName;
            ptszRootTempName = NULL;
        }

        if(NULL != poszRootTempName)
        {
            delete poszRootTempName;
            poszRootTempName = NULL;
        }

        // Free the statStg.pwcsName
        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))                  
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ROOTTEST_101 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation ROOTTEST_101 failed, hr=0x%lx; fPass=%d."),
            hr,
            fPass));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Delete Chance docfile tree
    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());
        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Release pMalloc
    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // Delete DataGen object
    if(NULL != pdgi)
    {
        delete pdgi;
        pdgi = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    ROOTTEST_102 
//
// Synposis: From 4 to 16 times, a root docfile with a random name is created,
//       committed, Stat'ed, tested to see if it is a storage object,
//       released, tested to see if we still think it's a storage object,
//       and finally deleted from the file system.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LRNORM.CXX
// 2.  Old name of test : LegitRootNull test 
//     New Name of test : ROOTTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-102
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-102
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-102
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: ROOTTEST-102 NO
//
//-----------------------------------------------------------------------------

HRESULT ROOTTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    DWORD           dwRootMode              = NULL;
    LPSTORAGE       pIStorage               = NULL;
    ULONG           ulRef                   = 0;
    DG_INTEGER      *pdgi                   = NULL;
    DG_STRING      *pdgu                   = NULL;
    STATSTG         statStg;
    LPMALLOC        pMalloc                 = NULL;
    LPTSTR          ptszRootTempName        = NULL;
    LPOLESTR        poszRootTempName        = NULL;
    LPTSTR          ptszRootName            = NULL;
    LPOLESTR        poszRootName            = NULL;
    BOOL            fPass                   = TRUE;
    ULONG           cNumVars                = 0;
    ULONG           cRandomMinVar           = 4;
    ULONG           cRandomMaxVar           = 16;
    FILE            *hFileRootNonDocFile    = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ROOTTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt legitimate ops on random root docfile.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ROOTTEST_102, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random numbers.

        pdgi = new(NullOnFail) DG_INTEGER(pTestChanceDF->GetSeed());

        if (NULL == pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Generate RootDocFile name

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&cNumVars, cRandomMinVar, cRandomMaxVar);

        DH_HRCHECK(hr, TEXT("Generate")) ;
    }
    
    // Create DataGen

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        pdgu = new(NullOnFail) DG_STRING(pTestChanceDF->GetSeed());

        if (NULL == pdgu)
        {
           hr = E_OUTOFMEMORY;
        }
    }

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    while((0 != cNumVars) && (S_OK == hr) && (TRUE == fPass))
    {
        cNumVars--;

        DH_TRACE((DH_LVL_TRACE1, TEXT("cNumVars = %ld "), cNumVars));
        
        // Generate RootDocFile name

        if(S_OK == hr)
        {
            hr=GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &ptszRootName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if(S_OK == hr)
        {
            // Convert TCHAR name to OLECHAR

            hr = TStringToOleString(ptszRootName, &poszRootName);

            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        // Try calling StgCreateDocFile with above random name 

        if (S_OK == hr)
        {
            pIStorage = NULL;

            hr = StgCreateDocfile(
                    poszRootName,
                    dwRootMode | STGM_CREATE,
                    0,
                    &pIStorage);

            DH_HRCHECK(hr, TEXT(" StgCreateDocfile")) ;
        }

        if(S_OK == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("StgCreateDocFile passed as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgCreateDocFile failed unexpectedly, hr=0x%lx"), hr));
        }

        // Now do a valid commit.  BUGBUG: Use random modes..

        if (S_OK == hr)
        {
            hr = pIStorage->Commit(STGC_DEFAULT);

            DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit unsuccessful, hr=0x%lx."),
                hr));
        }

        // Do a Stat on root Docfile

        if (S_OK == hr)
        {
            hr = pIStorage->Stat(&statStg, STATFLAG_DEFAULT);

            DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Stat unsuccessful, hr=0x%lx."),
                hr));
        }

        if(S_OK == hr)
        {
            //Convert OLECHAR to TCHAR

            hr = OleStringToTString(statStg.pwcsName, &ptszRootTempName);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            // Convert TCHAR name to OLECHAR

            hr = TStringToOleString(ptszRootTempName, &poszRootTempName);

            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        // Check with StgIsStorage

        if(S_OK == hr)
        {
            hr = StgIsStorageFile(poszRootTempName);
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorage hr = 0x%lx as exp before root release."), 
                hr));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorage hr = 0x%lx unexp before root release."), 
                hr));
        }

        // Close the root docfile

        if (S_OK == hr)
        {
            ulRef = pIStorage->Release();
            DH_ASSERT(0 == ulRef);
        }

        // Again call StgIsStorage now

        if(S_OK == hr)
        {
            hr = StgIsStorageFile(poszRootTempName);
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorage hr = 0x%lx as exp after releasing rootDF"),
                hr));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorage hr=0x%lx unexp after releasing root DF."),
                hr));
        }

        // Call StgCreateDocFile with STGM_FAILIFTHERE flag.  This should fail.

        if (S_OK == hr)
        {
            pIStorage = NULL;

            HRESULT hr2 = StgCreateDocfile(
                    poszRootTempName,
                    dwRootMode | STGM_FAILIFTHERE,
                    0,
                    &pIStorage);

            DH_HRCHECK(hr2, TEXT(" StgCreateDocfile")) ;

            if((S_OK != hr2) && (NULL == pIStorage))
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("StgCreateDocFile failed as expected, hr = 0x%lx."),hr2));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("StgCreateDocFile passed unexpectedly,hr=0x%lx "), hr2));

                hr = (S_OK==hr2)?E_FAIL:hr2;
                fPass = FALSE;
            }
        }


        // Delete temp string

        if(NULL != ptszRootTempName)
        {
            delete ptszRootTempName;
            ptszRootTempName = NULL;
        }

        if(NULL != poszRootTempName)
        {
            delete poszRootTempName;
            poszRootTempName = NULL;
        }

        // Change the mode to READ_ONLY and then try.

        if(S_OK ==  hr)
        {
            _tchmod(ptszRootName, _S_IREAD);
        }
        
        // Now call StgOpenStorage on it.  It should fail.

        if(S_OK ==  hr)
        {
            pIStorage = NULL;

            HRESULT hr2 = StgOpenStorage(
                    poszRootTempName,
                    NULL,
                    dwRootMode,
                    NULL,
                    0,
                    &pIStorage);

            DH_HRCHECK(hr2, TEXT("StgOpenStorage")) ;

            if((S_OK != hr2) && (NULL == pIStorage))
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("StgOpenStorage fail exp with Read Only mode, hr=0x%lx"),
                    hr2));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("StgOpenStorage pass unexp with readonly mode,hr=0x%lx"),
                    hr2));

                hr = (S_OK==hr2)?E_FAIL:hr2;
                fPass = FALSE;
            }
        }

        // Change back the mode to read/write. 

        if(S_OK ==  hr)
        {
            _tchmod(ptszRootName, _S_IREAD | _S_IWRITE);
        }
        
        // Try calling StgCreateDocFile with STGM_CREATE| STGM_DELETEONRELEASE 

        if (S_OK == hr)
        {
            pIStorage = NULL;

            hr = StgCreateDocfile(
                    poszRootTempName,
                    pTestChanceDF->GetRootMode()|
                    STGM_CREATE                 |
                    STGM_DELETEONRELEASE,
                    0,
                    &pIStorage);

            DH_HRCHECK(hr, TEXT(" StgCreateDocfile")) ;
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgCreateDocFile pass exp with mode \
                      STGM_CREATE|STGM_DELETEONRELEASE.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgCreateDocFile failed unexp with mode \
                      STGM_CREATE | STGM_DELETEONRELEASE, hr=0x%lx"), hr));
        }

        // Now do a valid commit.  BUGBUG: Use random modes..

        if (S_OK == hr)
        {
            hr = pIStorage->Commit(STGC_DEFAULT);

            DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit unsuccessful, hr=0x%lx."),
                hr));
        }

        // Free the statStg.pwcsName

        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        // Stat the root IStorage

        if (S_OK == hr)
        {
            hr = pIStorage->Stat(&statStg, STATFLAG_DEFAULT);

            DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Stat unsuccessful, hr=0x%lx."),
                hr));
        }

        if(S_OK == hr)
        {
           //Convert OLECHAR to TCHAR

            hr = OleStringToTString(statStg.pwcsName, &ptszRootTempName);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            // Convert TCHAR name to OLECHAR

            hr = TStringToOleString(ptszRootTempName, &poszRootTempName);

            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        // Check with StgIsStorage

        if(S_OK == hr)
        {
            hr = StgIsStorageFile(poszRootTempName);
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorage hr = 0x%lx as exp before root release."), 
                hr));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorage hr=0x%lx unexp before root release."), 
                hr));
        }

        // Close the root docfile

        if (S_OK == hr)
        {
            ulRef = pIStorage->Release();
            DH_ASSERT(0 == ulRef);
        }

        // Again call StgIsStorage now

        if(S_OK == hr)
        {
            HRESULT hr2 = StgIsStorageFile(poszRootTempName);

            if(STG_E_FILENOTFOUND == hr2)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("StgIsStorage hr=0x%lx as exp after root reelase."), 
                    hr2));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("StgIsStorage hr = 0x%lx unexp after root release."), 
                    hr2));

                hr = (S_OK==hr2)?E_FAIL:hr2;
                fPass = FALSE;
            }
        }

        // Check if a non docfile fails StgIsStorage 

        hFileRootNonDocFile = _tfopen(ptszRootName, TEXT("w+"));

        if(NULL == hFileRootNonDocFile)
        {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("fopen unexpectedly failed %s "),
                ptszRootName));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("fopen passed as expected of file %s "),
                ptszRootName));

            fclose(hFileRootNonDocFile);
        }


        // Delete temp string

        if(NULL != ptszRootTempName)
        {
            delete ptszRootTempName;
            ptszRootTempName = NULL;
        }

        if(NULL != poszRootTempName)
        {
            delete poszRootTempName;
            poszRootTempName = NULL;
        }

        if(NULL != poszRootName)
        {
            delete poszRootName;
            poszRootName = NULL;
        }

        // Free the statStg.pwcsName

        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if((S_OK == hr) && (NULL != ptszRootName))
        {
            if(FALSE == DeleteFile(ptszRootName))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;

                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }

            delete ptszRootName;
            ptszRootName = NULL;
        }
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass))                  
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ROOTTEST_102 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation ROOTTEST_102 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Release pMalloc

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // Delete DataGen object
    
    if(NULL != pdgi)
    {
        delete pdgi;
        pdgi = NULL;
    }

    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    ROOTTEST_103 
//
// Synopsis:A root docfile with a random name is created, committed, and release
//       For each of the access mode combinations listed in the table, the
//       the root docfile is instantiated with the permissions, and then
//       for each of the access mode combinations, a 2nd instantiation of
//       the root docfile is attempted.  After the 2nd instantiation call,
//       a check is made to determine whether the instantiation should have
//       worked or failed depending upon the 1st instantiation mode.  The
//       second instantiation is released if necessary.  Once all modes
//       have been attempted for the 2nd instantiation, the 1st instantiation
//       is released, and the test goes on the the next access mode entry
//       in the array.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  26-June-1996     NarindK     Created
//           12-Aug-1996      JiminLi     Updated
//
// Notes:    This test runs in direct, transacted modes
//
// New Test Notes:
// 1.  Old File: LRMULTAC.CXX
// 2.  Old name of test : LegitRootMultAccess test 
//     New Name of test : ROOTTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-103
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:ROOTTEST-103
//        /dfRootMode:xactReadWriteShEx 
// 
// BUGNOTE: Conversion: ROOTTEST-103 NO
//
//-----------------------------------------------------------------------------

HRESULT ROOTTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = NULL;
    DWORD           dwOpenMode              = NULL;
    LPSTORAGE       pIStorageFirst          = NULL;
    LPSTORAGE       pIStorageSecond         = NULL;
    LPOLESTR        pOleStrTemp             = NULL;
    ULONG           ulRef                   = 0;
    DG_STRING       *pdgu                   = NULL;
    BOOL            fShouldWork             = FALSE;
    ULONG           count                   = 0;
    ULONG           subcount                = 0;
    BOOL            fPass                   = TRUE;
    struct
    {
        DWORD       usMode;
        BOOL        afPermsOk[30];
    } aPerms[15]={ STGM_READ,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,  
                       T,T,T,T,F,T,F,T,F,T,F,T,F,T,F,
                   STGM_WRITE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,T,T,T,F,F,F,T,T,F,F,T,T,F,F,
                   STGM_READWRITE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,T,T,T,F,F,F,T,F,F,F,T,F,F,F,
                   STGM_READ | STGM_SHARE_DENY_NONE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,T,T,T,F,T,F,T,F,T,F,T,F,T,F,
                   STGM_READ | STGM_SHARE_DENY_READ,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F, 
                       F,T,F,F,F,F,F,T,F,T,F,F,F,F,F,
                   STGM_READ | STGM_SHARE_DENY_WRITE,
                       F,F,F,F,F,T,F,F,F,F,F,F,F,F,F,
                       T,F,F,T,F,T,F,F,F,F,F,F,F,F,F,
                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                   STGM_WRITE | STGM_SHARE_DENY_NONE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,T,T,T,F,F,F,T,T,F,F,T,T,F,F,
                   STGM_WRITE | STGM_SHARE_DENY_READ,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       F,T,F,F,F,F,F,T,T,F,F,F,F,F,F,
                   STGM_WRITE | STGM_SHARE_DENY_WRITE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,F,F,T,F,F,F,F,F,F,F,F,F,F,F,
                   STGM_WRITE | STGM_SHARE_EXCLUSIVE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                   STGM_READWRITE | STGM_SHARE_DENY_NONE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,T,T,T,F,F,F,T,F,F,F,T,F,F,F,
                   STGM_READWRITE | STGM_SHARE_DENY_READ,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       F,T,F,F,F,F,F,T,F,F,F,F,F,F,F,
                   STGM_READWRITE | STGM_SHARE_DENY_WRITE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       T,F,F,T,F,F,F,F,F,F,F,F,F,F,F,
                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,
                       F,F,F,F,F,F,F,F,F,F,F,F,F,F,F
                   };

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ROOTTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_103 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt multiple accesses on a root docfile.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ROOTTEST_103, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        pdgu = new(NullOnFail) DG_STRING(pTestChanceDF->GetSeed());

        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Generate RootDocFile name

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &pRootDocFileName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(pRootDocFileName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Try calling StgCreateDocFile with mode as per dwRootFlags

    // Just make sure no DocFile of the name exists.  Delete if it does.

    if (S_OK == hr)
    {
        pIStorageFirst = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp,
                dwRootMode | STGM_CREATE,
                0,
                &pIStorageFirst);
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("StgCreateDocFile passed as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgCreateDocFile failed unexpectedly, hr = 0x%lx ."), hr));
    }

    // Now do a valid commit

    if (S_OK == hr)
    {
        hr = pIStorageFirst->Commit(STGC_ONLYIFCURRENT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStorage::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStorage::Commit couldn't complete successfully.")));
    }

    // Close the root docfile

    if (S_OK == hr)
    {
        ulRef = pIStorageFirst->Release();
        DH_ASSERT(0 == ulRef);
        pIStorageFirst = NULL;
    }
    
    for ( count=0; count<15; count++)
    {
        DH_ASSERT(count < 15);

        // For the first open:
        // if instantiation mode contains STGM_TRANSACTED, then always 
        // instantiated; otherwise, if read-only(STGM_READ) is specified in the
        // mode, then only instantiated when STGM_SHARE_DENY_WRITE or 
        // STGM_SHARE_EXCLUSIVE is also set; if STGM_WRITE is specified in the
        // mode, then only instantiated when STGM_SHARE_EXCLUSIVE is also set.

        if ((dwRootMode & STGM_TRANSACTED)                                   || 
            ((aPerms[count].usMode & STGM_RW) == STGM_READ && 
             ((aPerms[count].usMode & STGM_SHARE) == STGM_SHARE_DENY_WRITE ||
              (aPerms[count].usMode & STGM_SHARE) == STGM_SHARE_EXCLUSIVE))  ||
            (((aPerms[count].usMode & STGM_RW) == STGM_WRITE || 
              (aPerms[count].usMode & STGM_RW) == STGM_READWRITE) &&
             (aPerms[count].usMode & STGM_SHARE) == STGM_SHARE_EXCLUSIVE))
        { 
            pIStorageFirst = NULL;

            if (dwRootMode & STGM_TRANSACTED)
            {
                dwOpenMode = STGM_TRANSACTED | aPerms[count].usMode;
            }
            else
            {
                dwOpenMode = STGM_DIRECT | aPerms[count].usMode;
            }

            hr = StgOpenStorage(
                    pOleStrTemp,
                    NULL,
                    dwOpenMode,
                    NULL,
                    0,
                    &pIStorageFirst);

            if (S_OK != hr)
            {
                DH_TRACE((DH_LVL_ERROR, 
                        TEXT("Error in first open (mode=%#lx), hr=0x%lx"),
                        dwOpenMode,
                        hr));
                break;
            }
            else 
            {
                for (subcount=0;subcount<15;subcount++)
                {
                    DH_ASSERT(subcount < 15);

                    // For the second open:
                    // if the mode contains STGM_TRANSACTED then always
                    // instantiates; otherwise only instantiates if 
                    // STGM_SHARE_DENY_WRITE or STGM_SHARE_EXCLUSIVE
                    // is set for this index in the table because for
                    // direct mode, both STGM_READ or STGM_WRITE need
                    // combined with at least STGM_SHARE_DENY_WRITE.

                    if ((dwRootMode & STGM_TRANSACTED)          ||
                        ((aPerms[subcount].usMode & STGM_SHARE) == 
                                                    STGM_SHARE_DENY_WRITE ||
                         (aPerms[subcount].usMode & STGM_SHARE) ==
                                                    STGM_SHARE_EXCLUSIVE))
                    {
                        pIStorageSecond = NULL;

                        if (dwRootMode & STGM_TRANSACTED)
                        {
                            dwOpenMode = STGM_TRANSACTED 
                                            | aPerms[subcount].usMode;
                            fShouldWork = aPerms[count].afPermsOk[subcount+15];
                        }
                        else
                        {
                            dwOpenMode = STGM_DIRECT 
                                            | aPerms[subcount].usMode;
                            fShouldWork = aPerms[count].afPermsOk[subcount];
                        }

                        hr = StgOpenStorage(
                                pOleStrTemp,
                                NULL,
                                dwOpenMode,
                                NULL,
                                0,
                                &pIStorageSecond);

                        //  determine whether or not the instantiation should
                        //  have worked.  For every 'F' in the access modes
                        //  table, the 2nd instantion should fail.
                        if (((fShouldWork == FALSE) && (S_OK == hr)) ||
                            ((fShouldWork == TRUE)  && (S_OK != hr)))
                        {
                            DH_TRACE((
                                DH_LVL_TRACE1, 
                                TEXT("\t i=%u, j=%u "),
                                count,
                                subcount));
                            DWORD dwMode = dwRootMode & STGM_TRANSACTED ? 
                                        STGM_TRANSACTED : STGM_DIRECT;
                            DH_TRACE((DH_LVL_ERROR, 
                                    TEXT("Mode1:%#lx, Mode2:%lx; hr=%#lx; Expect %s"),
                                    aPerms[count].usMode | dwMode,
                                    aPerms[subcount].usMode | dwMode,
                                    hr,
                                    (LPTSTR)(FALSE == fShouldWork ? 
                                            TEXT("failure"):TEXT("success"))));
                            fPass = FALSE;
                            hr = S_OK;
                        }
                        else
                        {
                            // Success or fail as expected

                            hr = S_OK;
                        }

                        if(NULL != pIStorageSecond)
                        {
                            ulRef = pIStorageSecond->Release();
                            DH_ASSERT(0 == ulRef);
                            pIStorageSecond = NULL;
                        }
                    }
                } 
 
                if(NULL != pIStorageFirst)
                {
                    ulRef = pIStorageFirst->Release();
                    DH_ASSERT(0 == ulRef);
                    pIStorageFirst = NULL;
                }
            }
        }

        if (S_OK != hr)
        {
            break;
        }
    }

    // if everything goes well, log test as passed else failed.

    if (fPass && (S_OK == hr))
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ROOTTEST_103 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation ROOTTEST_103 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete temp string

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    // Delete DataGen object
    
    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if ((S_OK == hr) && fPass && (NULL != pRootDocFileName))
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    ROOTTEST_104 
//
// Synopsis: This test first creates a root docfile.  An IStream is created
//        inside the root docfile and a random number of bytes are
//        written to it.  The stream is released, the root docfile is
//        committed, and the root docfile is released.
//        The root docfile is instantiated in STGM_TRANSACTED mode and
//        and then released.  A count of the files in the current directory
//        is then made and saved.  The root docfile is then instantiated
//        in STGM_TRANSACTED | STGM_SHARE_DENY_WRITE mode and another count is
//        made.  We then verify that only 1 scratch file was created,
//        indicating that for STGM_DENY_WRITE mode, no copy is made of
//        the instantiated IStorage.  (Note: if in the second time, the
//        file is opened in STGM_TRANSACTED mode only, not STGM_SHARE_DENY_
//        WRITE mode, two scratch files would be made.)
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  26-June-1996     NarindK     Created.
//
// Notes:    This test runs in transacted modes
//
// New Test Notes:
// 1.  Old File: LRTWWDW.CXX
// 2.  Old name of test : LegitRootTwwDenyWrite test 
//     New Name of test : ROOTTEST_104 
// 3.  To run the test, do the following at command prompt. 
//       stgbase /t:ROOTTEST-104
//
// BUGNOTE: Conversion: ROOTTEST-104 NO
//
//-----------------------------------------------------------------------------

HRESULT ROOTTEST_104(int /* UNREF argc */, char * * /* UNREF argv*/)
{
#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!!ROOTTEST_104 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    DWORD           dwRootMode              = STGM_READWRITE | STGM_TRANSACTED;
    LPSTORAGE       pIStorage               = NULL;
    ULONG           ulRef                   = 0;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPTSTR          ptszRootName            = NULL;
    LPOLESTR        poszRootName            = NULL;
    LPTSTR          ptszStreamName          = NULL;
    LPOLESTR        poszStreamName          = NULL;
    BOOL            fPass                   = TRUE;
    ULONG           culSeed                 = 0;
    ULONG           cRandom                 = 0;
    LPSTREAM        pIStream                = NULL;
    LPTSTR          ptcsBuffer              = NULL;
    LPOLESTR        pocsBuffer              = NULL;
    ULONG           culWritten              = 0;
    ULONG           culFilesInDirectory     = 0;
    BOOL            fNssfile                = FALSE;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ROOTTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_104 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt operations on root docfile in transacted mode.")));

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        pdgu = new(NullOnFail) DG_STRING(culSeed);

        if (NULL == pdgu)
        {
           hr = E_OUTOFMEMORY;
        }
    }
        
    // Generate RootDocFile name

    if(S_OK == hr)
    {
        hr=GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &ptszRootName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert TCHAR name to OLECHAR

        hr = TStringToOleString(ptszRootName, &poszRootName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Try calling StgCreateDocFile with above random name 

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                    poszRootName,
                    dwRootMode | STGM_FAILIFTHERE,
                    0,
                    &pIStorage);

        DH_HRCHECK(hr, TEXT(" StgCreateDocfile")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("StgCreateDocFile passed as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgCreateDocFile failed unexpectedly, hr=0x%lx"), hr));
    }

    // Generate random name for stream

    if(S_OK == hr)
    {
        hr=GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &ptszStreamName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert TCHAR name to OLECHAR

        hr = TStringToOleString(ptszStreamName, &poszStreamName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Create a stream

    if (S_OK == hr)
    {
        hr = pIStorage->CreateStream(
                poszStreamName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE,
                0,
                0,
                &pIStream);
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("IStorage::CreateStream passed as expected")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("IStorage::CreateStream failed unexpectedly,hr=0x%lx"), hr));
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random integers.

        pdgi = new(NullOnFail) DG_INTEGER(culSeed);

        if (NULL == pdgi)
        {
           hr = E_OUTOFMEMORY;
        }
    }
        
    // Write random size data into stream

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, 1, USHRT_MAX);

        DH_HRCHECK(hr, TEXT("Generate")) ;
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cRandom, cRandom, &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if(S_OK == hr)
    {
        // Convert data to OLECHAR

        hr = TStringToOleString(ptcsBuffer, &pocsBuffer);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = pIStream->Write(pocsBuffer, cRandom, &culWritten);

        DH_HRCHECK(hr, TEXT("IStream::Write")) ;
    }

    // Release stream

    if (NULL != pIStream)
    {
       ulRef = pIStream->Release();
       DH_ASSERT(0 == ulRef);
       pIStream = NULL;
    }

    // Now do a valid commit.  BUGBUG: Use random modes..

    if (S_OK == hr)
    {
        hr = pIStorage->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStorage::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStorage::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close the root docfile

    if (NULL != pIStorage)
    {
       ulRef = pIStorage->Release();
       DH_ASSERT(0 == ulRef);
       pIStorage = NULL;
    }

    // Open the root docfile

    if (S_OK == hr)
    {
       pIStorage = NULL;

       hr = StgOpenStorage(
                 poszRootName,
                 NULL,
                 dwRootMode,
                 NULL,
                 0,
                 &pIStorage);

       DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorage couldn't complete successfully, hr = 0x%lx"),
            hr));
    }

    // Close the root docfile

    if (NULL != pIStorage)
    {
        ulRef = pIStorage->Release();
        DH_ASSERT(0 == ulRef);
        pIStorage = NULL;
    }

    // count number of files in directory

    if (S_OK == hr)
    {
        culFilesInDirectory = CountFilesInDirectory(WILD_MASK);
        //If opening as nssfile, decrement # tempfiles, (uses a stream)
        if (DoingOpenNssfile ())
        {
            //VerifyNssfile returns S_OK if valid nssfile - else an error
            if (S_OK == VerifyNssfile (ptszRootName))
            {
                //nssfiles use a stream in file, not temp file.
                culFilesInDirectory--;
            }
        }
    }

    // Open the root docfile

    if (S_OK == hr)
    {
       pIStorage = NULL;

       hr = StgOpenStorage(
                 poszRootName,
                 NULL,
                 dwRootMode | STGM_SHARE_DENY_WRITE,
                 NULL,
                 0,
                 &pIStorage);

       DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorage with STGM_SHARE_DENY_WRITE passed.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorage with STGM_SHARE_DENY_WRITE fail, hr=0x%lx"),
            hr));
    }

    // Check number of files

    if((culFilesInDirectory + 1) != CountFilesInDirectory(WILD_MASK))
    {
        DH_TRACE((
         DH_LVL_TRACE1,
         TEXT(">1 scratch file unexp STGM_SHARE_DENY_WRITE instantiation.")));

        hr = S_FALSE;
    }
    else
    {
        DH_TRACE((
         DH_LVL_TRACE1,
         TEXT("1 scratchfile exp with STGM_SHARE_DENY_WRITE instantiation")));

    }

    // Close the root docfile

    if (NULL != pIStorage)
    {
       ulRef = pIStorage->Release();
       DH_ASSERT(0 == ulRef);
       pIStorage = NULL;
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)           
    {
        DH_LOG((LOG_PASS, TEXT("Test variation ROOTTEST_104 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation ROOTTEST_104 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup

    // Delete DataGen object
    
    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    if(NULL != pdgi)
    {
        delete pdgi;
        pdgi = NULL;
    }

    // Delete temp string

    if(NULL != ptszStreamName)
    {
        delete ptszStreamName;
        ptszStreamName = NULL;
    }

    if(NULL != poszStreamName)
    {
        delete poszStreamName;
        poszStreamName = NULL;
    }

    if(NULL != poszRootName)
    {
        delete poszRootName;
        poszRootName = NULL;
    }

    if(NULL != ptcsBuffer)
    {
        delete ptcsBuffer;
        ptcsBuffer = NULL;
    }

    if(NULL != pocsBuffer)
    {
        delete pocsBuffer;
        pocsBuffer = NULL;
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != ptszRootName))
    {
        if(FALSE == DeleteFile(ptszRootName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != ptszRootName)
    {
        delete ptszRootName;
        ptszRootName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ROOTTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
#endif //_MAC
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgdrt\drtguid.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	drtguid.cxx
//
//  Contents:	Define GUIDs needed by the DRT
//
//  History:	04-Nov-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <initguid.h>

#if WIN32 == 100 || WIN32 == 200
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgdrt\headers.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       headers.cxx
//
//  Contents:   Precompiled headers
//
//  History:    05-Nov-92 AlexT    Created
//
//--------------------------------------------------------------------------

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>


#include <windows.h>
#include <ole2.h>

#ifdef _CAIRO_
#define _DCOM_
#define _CAIROSTG_
#include <oleext.h>
#endif

#include <debnot.h>

#include <drt.hxx>
#include <wrap.hxx>
#include <util.hxx>
#include <strlist.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgdrt\drt.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       drt.cxx
//
//  Contents:   DRT main routine
//
//  History:    22-Sep-92       DrewB   Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include "tests.hxx"
#include "illeg.hxx"

// Test flags and type
typedef ULONG FLAGS;

#define TF_NONE                 0x00000000

// Suppression flags
#define TF_SUPPRESS             0x0000FFFF
#define TFS_ILLEGITIMATE        0x00000001
#define TFS_16BIT               0x00000002

// Enabling flags
#define TF_ENABLE               0xFFFF0000
#define TFE_DIRECT              0x00010000
#define TFE_TRANSACTED          0x00020000
#define TFE_INDEPENDENT         0x00040000
#define TFE_ANY                 (TFE_DIRECT | TFE_TRANSACTED | TFE_INDEPENDENT)

// Pointer to a test function
typedef void (*TestFn)(void);

static struct
{
    char *pszName;
    char *pszDesc;
    TestFn tfn;
    FLAGS flags;
} tests[] =
{
    "Create",   "Creation",
        t_create, TFE_ANY,
    "Open",     "Opening",
        t_open, TFE_ANY,
    "AddRef",   "AddRef/Release",
        t_addref, TFE_ANY,
    "TModify",  "Transacted modify/Commit/Revert",
        t_tmodify, TFE_TRANSACTED | TFE_INDEPENDENT,
    "DModify",  "Direct modifications",
        t_dmodify, TFE_DIRECT,
    "Stat",     "Stat",
        t_stat, TFE_ANY,
    "Stream",   "Stream operations",
        t_stream, TFE_ANY,
    "Enum",     "Enumerator operations",
        t_enum, TFE_ANY,
    "StgCopyTo", "IStorage::CopyTo",
        t_stgcopyto, TFE_ANY,
    "MoveCopy", "IStorage::MoveElementTo",
        t_movecopy, TFE_ANY,
    "Marshal",  "IMarshal operations",
        t_marshal, TFE_ANY,
    "ILockBytes", "ILockBytes usage",
        t_ilb, TFE_ANY,
    "StgMisc",  "Miscellaneous Stg functions",
        t_stgmisc, TFE_ANY,

    "IllStg", "Illegitimate IStorage calls",
        i_storage, TFE_ANY | TFS_ILLEGITIMATE,
    "IllStm", "Illegitimate IStream calls",
        i_stream, TFE_ANY | TFS_ILLEGITIMATE,
    "IllEnum", "Illegitimate enumerator calls",
        i_enum, TFE_ANY | TFS_ILLEGITIMATE
};
#define NTESTS (sizeof(tests)/sizeof(tests[0]))

DWORD dwTransacted = 0;
DWORD dwRootDenyWrite = STGM_SHARE_DENY_WRITE;
BOOL fVerbose = FALSE;
BOOL fOfs = FALSE;
OLECHAR atcDrtDocfile[_MAX_PATH];

static BOOL fRun[NTESTS];
#ifdef FLAT
static FLAGS flTests = TF_NONE;
#else
static FLAGS flTests = TF_NONE | TFS_16BIT;
#endif

static void Initialize(void)
{
    SCODE sc;

    SetData();
#if WIN32 == 300
    if (FAILED(sc = DfGetScode(CoInitializeEx(NULL, COINIT_MULTITHREADED))))
        error(EXIT_UNKNOWN,
              "CoInitializeEx failed with sc = 0x%lX\n", sc);
#else
    if (FAILED(sc = DfGetScode(CoInitialize(NULL))))
        error(EXIT_UNKNOWN,
              "CoInitialize failed with sc = 0x%lX\n", sc);
#endif
}

static void Uninitialize(void)
{
    UnsetData();
    CoUninitialize();
}

static int FindTest(char *pszName)
{
    int i, cchName;

    cchName = strlen(pszName);
    for (i = 0; i<NTESTS; i++)
        if (!_strnicmp(pszName, tests[i].pszName, cchName))
            return i;
    return -1;
}

static void RunTests(void)
{
    int i;

    for (i = 0; i<NTESTS; i++)
        // For a test to run:
        // 1)  fRun[test] must be TRUE
        // 2)  No suppression flags can be set that are not set in flTests
        // 3)  At least one enabling flag must be set that is set in flTests
        if (fRun[i] &&
            (tests[i].flags & ~flTests & TF_SUPPRESS) == 0 &&
            (tests[i].flags & flTests & TF_ENABLE) != 0)
        {
            out("\n----- Test #%2d - %s -----\n", i+1, tests[i].pszDesc);
            tests[i].tfn();
            CheckMemory();
            CleanData();
        }
}

static void Usage(void)
{
    int i;

    printf("Usage: drt [options]\n");
    printf("Options are:\n");
    printf("  -h        - This message\n");
    printf("  -d        - Suppress direct tests\n");
    printf("  -t        - Suppress transacted tests\n");
    printf("  -w        - Suppress independent tests\n");
    printf("  -i        - Enable illegitimate tests\n");
    printf("  -v        - Display test output\n");
#if WIN32 == 300
    printf("  -o        - Enable tests to run on OFS\n");
#endif
    printf("  -y<kind>  - Control debug output (a, d, m, i, M, L)\n");
    printf("  -#[+|-]<number>   - Turn test <number> on (+) or off (-)\n");
    printf("                      No number means all\n");
    printf("  -n[+|-]<prefix>   - Turn test <prefix> on or off\n");
    printf("  -N<file>  - Set file to use for tests\n");
    printf("Prefix can be any prefix of:\n");
    for (i = 0; i<NTESTS; i++)
        printf("  %s\n", tests[i].pszName);
    exit(1);
}

int __cdecl main(int argc, char **argv)
{
    int i, iTest;
    BOOL fDirect = TRUE, fTrans = TRUE, fIndep = TRUE;

    SetDebug(0x101, 0x101);
    for (i = 0; i<NTESTS; i++)
        fRun[i] = TRUE;
    ATOOLE("drt.dfl", atcDrtDocfile, _MAX_PATH);
    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case '#':
                if (sscanf(argv[0]+3, "%d", &iTest) != 1)
                    iTest = -1;
                else
                    iTest--;
                for (i = 0; i<NTESTS; i++)
                    if (iTest == -1 || iTest == i)
                        fRun[i] = argv[0][2] == '+';
                break;
            case 'd':
                fDirect = FALSE;
                break;
            case 'i':
                flTests |= TFS_ILLEGITIMATE;
                break;
            case 'n':
                iTest = FindTest(argv[0]+3);
                if (iTest >= 0)
                    fRun[iTest] = argv[0][2] == '+';
                break;
            case 'N':
                ATOOLE(argv[0]+2, atcDrtDocfile, _MAX_PATH);
                break;
            case 't':
                fTrans = FALSE;
                break;
            case 'v':
                fVerbose = TRUE;
                break;
            case 'w':
                fIndep = FALSE;
                break;
            case 'y':
                switch(argv[0][2])
                {
                case 'a':
                    SetDebug(0xffffffff, 0xffffffff);
                    break;
                case 'd':
                    SetDebug(0xffffffff, 0x101);
                    break;
                case 'm':
                    SetDebug(0x101, 0xffffffff);
                    break;
                case 'i':
                    SetDebug(0x101, 0x101);
                    break;
                case 'M':
                    SetDebug(0x01100000, 0);
                    break;
                case 'L':
                    SetDebug(0x00100000, 0);
                    break;
                }
                break;
#if WIN32 == 300
            case 'o':
                fOfs = TRUE;
                break;
#endif
            case 'h':
            default:
                Usage();
            }
        }
        else
            Usage();
    }

    Initialize();

    if (fDirect)
    {
        out("\n---------- Direct ----------\n");
        dwTransacted = 0;
        dwRootDenyWrite = STGM_SHARE_EXCLUSIVE;
        flTests |= TFE_DIRECT;
        RunTests();
        flTests &= ~TFE_DIRECT;
    }

#if WIN32 == 300
    if (fTrans && !fOfs)  // turn off transacted tests for OFS
#else
    if (fTrans)
#endif
    {
        out("\n---------- Transacted ----------\n");
        dwTransacted = STGM_TRANSACTED;
        dwRootDenyWrite = STGM_SHARE_DENY_WRITE;
        flTests |= TFE_TRANSACTED;
        RunTests();
        flTests &= ~TFE_TRANSACTED;
    }

#if WIN32 == 300
    if (fIndep && !fOfs)  // turn off transacted tests for OFS
#else
    if (fIndep)
#endif
    {
        out("\n---------- Independent ----------\n");
        dwTransacted = STGM_TRANSACTED;
        dwRootDenyWrite = STGM_SHARE_DENY_NONE;
        flTests |= TFE_INDEPENDENT;
        RunTests();
        flTests &= ~TFE_INDEPENDENT;
    }

    printf("Storage DRT - PASSED\n");

    Uninitialize();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\stmtests.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      stmtsts.cxx
//
//  Contents:  storage base tests basically pertaining to IStream interface 
//
//  Functions:  
//
//  History:    28-June-1996     NarindK     Created.
//              27-Mar-97        SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

// externs
extern BOOL     g_fDoLargeSeekAndWrite;
extern BOOL     g_fUseStdBlk;
extern USHORT   ausSIZE_ARRAY[];

#define SECTORSIZE  512
#define SMALL_OBJ_SIZE  4096

//----------------------------------------------------------------------------
//
// Test:    STMTEST_100 
//
// Synopsis:  Creates a root docfile with a random name.
//       Creates an IStream in the root docfile and writes and CRCs a
//       random number of bytes then releases the IStream.  The root
//       is then committed and released.  The root docfile and child IStream
//       are then instantiated.  CRC's are compared to verify.
//       A random offset is chosen within the child IStream and a random number
//       of bytes are written to the IStream, taking care *NOT* to grow the 
//       length of the IStream. The IStream and root are then released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    28-June-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LSCHANGE.CXX
// 2.  Old name of test : LegitStreamChange test 
//     New Name of test : STMTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-100
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-100
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-100
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: STMTEST-100
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    ULONG           cb                      = 0;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    ULONG           culRandomPos            = 0;
    ULONG           culRemWritten           = 0;
    DWORD           dwRootMode              = 0;
    BOOL            fPass                   = TRUE;
    LARGE_INTEGER   liStreamPos;
    ULONG           cRandomMinSize          = 10;
    ULONG           cRandomMaxSize          = 100;
    DWCRCSTM        dwMemCRC;
    DWCRCSTM        dwActCRC;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt stream change operations")) );

    // Initialize CRC values to zero

    dwMemCRC.dwCRCSum = dwActCRC.dwCRCSum = 0;

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
                hr));
        }
    }

    // Call VirtualStmNode::Write to create random bytes in the stream.  For
    // our test purposes, we generate a random string of size 1 to cb using
    // GenerateRandomString function.

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Write(
                ptcsBuffer,
                cb,
                &culWritten);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }
    }

    // Calculate the CRC for stream name and data

    if(S_OK == hr)
    {
        hr = CalculateInMemoryCRCForStm(
                pvsnRootNewChildStream,
                ptcsBuffer,
                cb,
                &dwMemCRC);

        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStm")) ;
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx.")));
        }
    }

    // Delete temp buffer

    if(NULL != ptcsBuffer)
    {
        delete ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Commit root.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
   
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Open root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Open stream
  
    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE  ,
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open unsuccessful,hr=0x%lx."),
            hr));
        }
    }

    // Read and verify

    if(S_OK == hr)
    {
        hr = ReadAndCalculateDiskCRCForStm(pvsnRootNewChildStream,&dwActCRC);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("ReadAndCalculateDiskCRCForStm function successful.")));

            if(dwActCRC.dwCRCSum == dwMemCRC.dwCRCSum)
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's for pvsnNewChildStream match.")));

            }
            else
            {
                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's for pvsnNewChildStream don't match.")));

                fPass = FALSE;
            }
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("ReadAndCalculateDiskCRCForStm not successful, hr=0x%lx."),
                hr));
        } 
    }

    // If it is ok till now, then all the bytes were written correctly into 
    // stream and read correctly from there, so choose any postion b/w 1 and
    // culWritten - number of bytes written and therafter read.

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&culRandomPos, 1, culWritten);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Now seek to this position

    if(S_OK == hr)
    {
        LISet32(liStreamPos, culRandomPos);

        //  Position the stream header to the postion from begining

        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek")) ;

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek function wasn't successful, hr=0x%lx."),
                hr));
        }
    }

    // Now write into this part of stream with random data w/o growing the
    // stream

    if(S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu, 
                culWritten - culRandomPos, 
                culWritten - culRandomPos, 
                &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Write(
                ptcsBuffer,
                culWritten - culRandomPos,
                &culRemWritten);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }
    }

    // Check length of stream not grown if stream written to correctly.

    if(S_OK == hr)
    {
        if(culRemWritten == culWritten - culRandomPos)
        {
            DH_TRACE((
               DH_LVL_TRACE1, 
               TEXT("Stream data changed okay w/o changing stream len.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1, 
               TEXT("Stream data change not okay.")));
            
            fPass = FALSE;
        }
    }

    // Commit root.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
   
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STMTEST_100 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Delete temp buffer

    if(NULL != ptcsBuffer)
    {
        delete ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_101 
//
// Synopsis: The test creates a root docfile and a child IStream.  A random
//       number of bytes are written to the IStream and then the IStream
//       is cloned.
//       From 1 to 5 times, either the ORIGINAL or CLONE IStream is
//       randomly chosen as the operation target.  The current seek
//       pointer positions of both IStreams are saved.  There is then a
//       33% chance each that the target stream will be used for a
//       seek, write, or read operation.  Next, the stream that was
//       *NOT* the target IStream is seeked upon to determine the
//       current pointer position.  Verify that the *non target*
//       IStream pointer hasn't changed.  Repeat.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    28-June-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LSCLONE.CXX
// 2.  Old name of test : LegitStreamClone test 
//     New Name of test : STMTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-101
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-101
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-101
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: STMTEST-101
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    ULONG           cb                      = 0;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    DWORD           dwRootMode              = 0;
    BOOL            fPass                   = TRUE;
    BOOL            fFindSeekPosition       = FALSE;
    LARGE_INTEGER   liStreamPos;
    ULONG           culRandIOBytes          = 0;
    ULONG           culBytesLeftToWrite     = 0;
    LPSTREAM        pIStreamClone           = NULL;
    ULONG           ulCurPosition[2];
    ULONG           ulOldPosition[2];
    ULONG           culRandomVar            = 0;
    ULONG           culRandomPos            = 0;
    ULONG           culRandomCommit         = 0;
    ULONG           cStreamInUse            = 0;
    ULONG           cStreamNotInUse         = 0;
    ULONG           cOpInUse                = 0;
    ULONG           ulRef                   = 0;
    LPSTREAM        pIStream[2];
    ULARGE_INTEGER  uli;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt stream clone operations")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_101, Access mode: %lx"),
            dwRootMode));
    }


    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu);
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream between 4L, and MIN_SIZE * 1.5
        // (range taken from old test).

        usErr = pdgi->Generate(&cb, 4,  (ULONG) (MIN_SIZE * 1.5));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;

        if(S_OK == hr)
        {
            culBytesLeftToWrite = cb;

            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
        }
    }

    // Loop to write new IStream in RAND_IO size chunks unless size
    // remaining to write is less than RAND_IO, then write the remaining bytes

    while((S_OK == hr) && (0 != culBytesLeftToWrite))
    {
        if (S_OK == hr)
        {
            // Generate random number of bytes to write b/w RAND_IO_MIN ,
            // RAND_IO_MAX  (range taken from old test).

            usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }
    
        if(culBytesLeftToWrite > culRandIOBytes)
        {
            culBytesLeftToWrite = culBytesLeftToWrite - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToWrite;
            culBytesLeftToWrite = 0;
        }

        // Call VirtualStmNode::Write to create random bytes in the stream.  For
        // our test purposes, we generate a random string of size 1 to cb using
        // GenerateRandomString function.

        if(S_OK == hr)
        {
            hr = GenerateRandomString(
                    pdgu, 
                    culRandIOBytes,
                    culRandIOBytes, 
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr =  pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culWritten);

            if (S_OK == hr)
            {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function completed successfully.")));
            }
            else
            {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
            }
        }

        // Delete temp buffer

        if(NULL != ptcsBuffer)
        {
            delete ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }

    // Commit root.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
   
        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
        }
    }

    // Now seek to the current stream to end of stream

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        //  Position the stream header to the postion from begining

        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulCurPosition[ORIGINAL] = ULIGetLow(uli);

        if(S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
        }
    }

    // Clone the stream

    if(S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Clone(&pIStreamClone);

        DH_HRCHECK(hr, TEXT("IStream::Clone")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Clone completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Clone not successful, hr=0x%lx."),
            hr));
        }
    }

    //clone IStream should really already be positioned to the end since
    //the original IStream was there.  The seek below simply ensures
    //this plus gets the seek position into the Clone current position
    //array element

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        //  Position the stream header to the postion from begining

        hr = pIStreamClone->Seek(liStreamPos, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("IStream::Seek")) ;

        ulCurPosition[CLONE] = ULIGetLow(uli);

        if(S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
        }
    }

    // Copy the ulCurPosition array to ulOldPosition array.  Now in a loop,
    // in a random fashion, select either the original stream or Clone stream,
    // do either seek, read or write operation on it.  Check that the unused
    // stream's seek pointer hasn't changed.  Update the ulOldPosition array
    // with ulCurPostion araay and repeat the loop random number of times.

    if (S_OK == hr)
    {
        // Generate random variations for while loop 

        usErr = pdgi->Generate(&culRandomVar, 1, 5);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }

        // Also fill up stream pointer array

        pIStream[0] = pvsnRootNewChildStream->GetIStreamPointer();
        pIStream[1] = pIStreamClone;
    }
 
    while ((S_OK == hr) && (culRandomVar--))
    {
        //save current seek pointer positions

        ulOldPosition[ORIGINAL] = ulCurPosition[ORIGINAL];
        ulOldPosition[CLONE] = ulCurPosition[CLONE];

        // pick an IStream to use (either ORIGINAL or CLONE) then
        // decide whether to seek on it, write it, or read it

        usErr = pdgi->Generate(&cStreamInUse, ORIGINAL, CLONE);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }

        //pick an operation to do on the stream (either SEEK, WRITE, READ) 

        if(S_OK == hr)
        {
            usErr = pdgi->Generate(&cOpInUse, SEEK, READ);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }

        if(S_OK == hr)
        {
            //Seek to a random position in stream

            usErr = pdgi->Generate(&culRandomPos, 0, culWritten);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }

            if(S_OK == hr)
            {
                LISet32(liStreamPos, culRandomPos);

                //  Position stream header to the postion from begining

                hr = pIStream[cStreamInUse]->Seek(
                         liStreamPos, 
                         STREAM_SEEK_SET, 
                         &uli);

                DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("IStream::Seek completed successfully.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("IStream::Seek not successful.")));
                }
            }
        }


        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("cOpInUse %d on cStreamInUse %d"),
                cOpInUse,
                cStreamInUse));
                
            switch(cOpInUse)
            {
                case SEEK:
                {
                    ulCurPosition[cStreamInUse] = ULIGetLow(uli);
                    fFindSeekPosition = FALSE;
                    break;
                }

                case WRITE:
                {
                    hr = GenerateRandomString(
                            pdgu, 
                            0,
                            STM_BUFLEN, 
                            &ptcsBuffer);

                    DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;

                    if (S_OK == hr)
                    {
                        hr =  pIStream[cStreamInUse]->Write(
                                ptcsBuffer,
                                _tcslen(ptcsBuffer),
                                NULL);
                    }
 
                    fFindSeekPosition = TRUE;
                    break;
                }

                case READ:
                {
                    ptcsBuffer = new TCHAR [STM_BUFLEN];

                    if (ptcsBuffer == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                   
                    if(S_OK == hr)
                    {
                        // Initialize buffer
                        memset(ptcsBuffer, '\0', STM_BUFLEN);
 
                        hr =  pIStream[cStreamInUse]->Read(
                                ptcsBuffer,
                                STM_BUFLEN,
                                NULL);
                    }
 
                    fFindSeekPosition = TRUE;
                
                    break;
                }
            }

            if(S_OK != hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("cOpInUse %d on cStreamInUse %d failed, hr = 0x%lx"),
                    cOpInUse,
                    cStreamInUse,
                    hr));

                fPass = FALSE;

                // Break out of while loop
                break;
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("cOpInUse %d on cStreamInUse %d passed. "),
                    cOpInUse,
                    cStreamInUse));
            }
        }

        // Determine current seek position if above operation might have change
        // it on the stream operated upon by seeking on it.

        if((S_OK == hr) && (TRUE == fFindSeekPosition))
        {
            memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

            hr = pIStream[cStreamInUse]->Seek(
                    liStreamPos, 
                    STREAM_SEEK_CUR, 
                    &uli);

            DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
        
            if(S_OK == hr)
            {
                ulCurPosition[cStreamInUse] = ULIGetLow(uli);

                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek completed successfully.")));
            }
            else
            {
                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek not successful.")));
            }
        }

        // Determine the seek pointer of the stream that was NOT operated upon
        // hasn't changed.

        if(S_OK == hr)
        {
            cStreamNotInUse = (cStreamInUse == ORIGINAL) ? CLONE : ORIGINAL;

            memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

            hr = pIStream[cStreamNotInUse]->Seek(
                    liStreamPos, 
                    STREAM_SEEK_CUR, 
                    &uli);

            DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
        
            if(S_OK == hr)
            {
                ulCurPosition[cStreamNotInUse] = ULIGetLow(uli);

                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek completed successfully.")));
            }
            else
            {
                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful.")));
            }
        }

        if((S_OK == hr) && 
           (ulCurPosition[cStreamNotInUse] == ulOldPosition[cStreamNotInUse]))
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Old & new seek ptr for unused stream same as exp.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Old & new seek ptr for unused stream different unexp")));
            fPass = FALSE;
            break;
        }

        // Commit the root storage half of time.

        if(S_OK == hr)
        {
            usErr = pdgi->Generate(&culRandomCommit, 1, 100);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }

        if((S_OK == hr) && (culRandomCommit > 50))
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
   
            if (S_OK == hr)
            {
                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
            }
            else
            {
                DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit not successful.")));

                fPass = FALSE;
                break;
            }
        }
    }

    // Release original stream

    if (NULL != pvsnRootNewChildStream)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close unsuccessful.")));
        }
    }

    // Release Clone stream

    if (NULL != pIStreamClone)
    {
        ulRef = pIStreamClone->Release();
        DH_ASSERT(0 == ulRef);

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Close unsuccessful.")));
        }
    }

    // Release root 

    if (NULL != pVirtualDFRoot)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful.")));
        }

    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, TEXT("Test variation STMTEST_101 failed.")) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Delete temp buffer

    if(NULL != ptcsBuffer)
    {
        delete ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_102 
//
// Synopsis: Create a root docfile with a child IStream.  Write a random number
//        of bytes to the IStream and commit the root docfile.  Do the same
//        with a child IStorage inside of the root docfile.
//        The root docfile is instantiated and the IStream is instantiated.
//        MAX_SIZE_ARRAY SetSize calls are made on the IStream, the size for
//        the setsize is a random ulong. After each setsize, there is a 50% 
//        chance that change will be immediately commited.After all setsizes are
//        complete, the IStream is released, the root docfile is commited
//        and then the root docfile is deleted.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    1-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LSETSIZE.CXX
// 2.  Old name of test : LegitStreamSetSize test 
//     New Name of test : STMTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-102
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-102
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-102
//        /dfRootMode:xactReadWriteShDenyW 
//     d. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-102
//        /dfRootMode:dirReadWriteShEx  /stdblock
//     e. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-102
//        /dfRootMode:xactReadWriteShEx /stdblock
//     f. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-102
//        /dfRootMode:xactReadWriteShDenyW /stdblock 
//
// BUGNOTE: Conversion: STMTEST-102
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    VirtualStmNode  *pvsnChildStgNewChildStm= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPTSTR          pChildStgNewChildStmName= NULL;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    DWORD           dwRootMode              = 0;
    ULONG           ulThisSetSize           = 0;
    ULONG           culRandIOBytes          = 0;
    ULONG           culBytesLeftToWrite     = 0;
    ULONG           culRandomCommit         = 0;
    ULONG           culArrayIndex           = 0;
    ULONG           i                       = 0;
    ULONG           j                       = 0;
    VirtualCtrNode  *pvcnInUse              = NULL; 
    VirtualStmNode  *pvsnInUse              = NULL; 
    LARGE_INTEGER   liStreamPos;
    ULARGE_INTEGER  uli;
    ULARGE_INTEGER  uliCopy;
    ULARGE_INTEGER  uliSet;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt stream SetSize operations")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
                hr));
        }
    }

    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    //    Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE |
                STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }
// ----------- flatfile change ---------------
    }
    else
    {
        pvcnRootNewChildStorage = pVirtualDFRoot;
    }
// ----------- flatfile change ---------------

    // Create a stream inside this child storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pChildStgNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pvcnRootNewChildStorage,
                pChildStgNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnChildStgNewChildStm);

        DH_HRCHECK(hr, TEXT("AddStream")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
                hr));
        }
    }

    if (S_OK == hr)
    {
        // Generate random size for stream between 0L, and MIN_SIZE * 1.5
        // (range taken from old test).

        usErr = pdgi->Generate(&culBytesLeftToWrite, 0,(ULONG)(MIN_SIZE * 1.5));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Loop to write new IStream in RAND_IO size chunks unless size
    // remaining to write is less than RAND_IO, then write the remaining bytes

    while((S_OK == hr) && (0 != culBytesLeftToWrite))
    {
        culRandIOBytes = RAND_IO_MIN;

        if(culBytesLeftToWrite > culRandIOBytes)
        {
            culBytesLeftToWrite = culBytesLeftToWrite - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToWrite;
            culBytesLeftToWrite = 0;
        }

        // Call VirtualStmNode::Write to create random bytes in the stream.  For
        // our test purposes, we generate a random string of size culRandomBytes
        // using GenerateRandomString function.

        if(S_OK == hr)
        {
            hr = GenerateRandomString(
                    pdgu, 
                    culRandIOBytes,
                    culRandIOBytes, 
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr =  pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culWritten);

            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream::Write function completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                    hr));
            }
        }

        // Delete temp buffer

        if(NULL != ptcsBuffer)
        {
            delete ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }

    // Now seek to the start of this stream

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        //  Position the stream header to the postion from begining

        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_SET, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek not successful.")));
        }
    }

    //Copy this stream pvsnRootNewChildStream to pvsnChildStgNewChildStm

    if(S_OK == hr)
    {
        ULISet32(uliCopy, ULONG_MAX);

        hr = pvsnRootNewChildStream->CopyTo(
                pvsnChildStgNewChildStm,
                uliCopy,  
                0,
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::CopyTo")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::CopyTo completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::CopyTo not successful.")));
        }
    }

    // Commit child storage.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Commit(STGC_DEFAULT);
       
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit couldn't complete successfully.")));
        }
    }

    // Commit root.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
   
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit couldn't complete successfully.")));
        }
    }


    //do MAX_SIZE_ARRAY setsize calls on just created IStreams.  Size
    //to use in SetSize call for each iteration through the loop is
    //a random ulong. 

    if(S_OK == hr)
    {
     for (j=0; j <= 1; j++)
     {
        if (j == 0)
        {
            pvsnInUse = pvsnRootNewChildStream;
            pvcnInUse = pVirtualDFRoot;
        }
        else
        {
            pvsnInUse = pvsnChildStgNewChildStm;
            pvcnInUse = pvcnRootNewChildStorage;
        }

        for(i=0; i<=MAX_SIZE_ARRAY; i++)
        {
            if(TRUE == g_fUseStdBlk)
            {
                // Pick up a random array element.

                usErr = pdgi->Generate(&culArrayIndex, 0, MAX_SIZE_ARRAY);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
                else
                {
                    ulThisSetSize= ausSIZE_ARRAY[culArrayIndex];
                }
            }
            else
            {
                usErr = pdgi->Generate(&ulThisSetSize, 0, MIN_SIZE * 3);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }

            if(S_OK == hr)
            {
                ULISet32(uliSet, ulThisSetSize);

                hr = pvsnInUse->SetSize(uliSet);

                if (S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("VirtualStmNode::SetSize completed successfully.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("VirtualStmNode::SetSize not successful, hr=0x%lx."),
                        hr));
                }
            }

            // Commit the storage in use, half of time.

            if(S_OK == hr)
            {
                usErr = pdgi->Generate(&culRandomCommit, 1, 100);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }

            if((S_OK == hr) && (culRandomCommit > 50))
            {
                hr = pvcnInUse->Commit(STGC_DEFAULT);
       
                if (S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("VirtualCtrNode::Commit completed successfully.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("VirtualCtrNode::Commit not successful, hr =0x%lx"),
                        hr));
                }
            }

            if (S_OK == hr)
            {
                memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

                //  Position the stream header to the end of stream 

                hr = pvsnInUse->Seek(liStreamPos, STREAM_SEEK_END, &uli);

                DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

                if (S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("VirtualStmNode::Seek completed successfully.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("VirtualStmNode::Seek not successful, hr = 0x%lx."),
                        hr));
                }
            }

            if(S_OK != hr)
            {
                break;
            }
        }
     }
    }

    // Release root's child stream

    if (NULL != pvsnRootNewChildStream)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful.")));
        }
    }

    // Release child stg's child stream 

    if (NULL != pvsnChildStgNewChildStm)
    {
        hr = pvsnChildStgNewChildStm->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful.")));
        }
    }

    // Commit child storage.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Commit(STGC_DEFAULT);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit couldn't complete successfully.")));
        }
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Release child storage

    if (NULL != pvcnRootNewChildStorage)
    {
        hr = pvcnRootNewChildStorage->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful.")));
        }
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Commit root.  BUGBUG: Use random modes

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit couldn't complete successfully.")));
        }
    }

    // Release root 

    if (NULL != pVirtualDFRoot)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful.")));
        }
    }

    // if everything goes well, log test as passed else failed.
    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, TEXT("Test variation STMTEST_102 failed.")) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    if(NULL != pChildStgNewChildStmName)
    {
        delete pChildStgNewChildStmName;
        pChildStgNewChildStmName = NULL;
    }

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // Delete temp buffer

    if(NULL != ptcsBuffer)
    {
        delete ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_103 
//
// Synopsis: The test create a root docfile with a child IStream. Writes and 
//           CRCs a random number of bytes to the IStream in random block 
//           size chunks, or if the /stdblock (use size array) option is 
//           specified in cmdline, then in random block size from 
//           ausSIZE_ARRAY[] chunks, then releases the IStream. The root 
//           docfile is then committed and released. 
//           The root docfile is instantiated and the IStream is instantiated.
//           The IStream is read in same random block size chunks as written,
//           and CRCs are compared to verify. The stream and the root docfile 
//           are then released and the root file is deleted.
//  
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File(s): LSREAD.CXX LSWRITE.CXX
// 2.  Old name of test(s) : LegitStreamRead LegitStreamWrite tests 
//     New Name of test(s) : STMTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-103
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-103
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-103
//        /dfRootMode:xactReadWriteShDenyW 
//     d. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-103
//        /dfRootMode:dirReadWriteShEx /stdblock
//     e. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-103
//        /dfRootMode:xactReadWriteShEx /stdblock
//     f. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-103
//        /dfRootMode:xactReadWriteShDenyW /stdblock
//
// History:  Jiminli	08-July-96	Created
//
// BUGNOTE: Conversion: STMTEST-103
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    ULONG           culRead                 = 0;
    DWORD           dwRootMode              = 0; 
    ULONG           culRandIOBytes          = 0;
    ULONG           culBytesLeftToWrite     = 0;
    ULONG           culBytesLeftToRead      = 0;
    ULONG           tmpBytes                = 0;
    ULONG           culArrayIndex           = 0;
    ULONG           cStartIndex             = 6;
    DWCRCSTM        *dwMemCRC               = NULL;
    DWCRCSTM        *dwActCRC               = NULL;
    ULONG           numofchunks             = 0;
    ULONG           index                   = 0;
    BOOL            fPass                   = TRUE; 

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_103 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt stream Read operations")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_103, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
        }
    }
 
    if (S_OK == hr)
    {
        // Generate random size for stream between 0L, and MIN_SIZE * 2 

        usErr = pdgi->Generate(&culBytesLeftToWrite, 0,  MIN_SIZE * 2);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        // Record for later use.

        culBytesLeftToRead = culBytesLeftToWrite;
        tmpBytes = culBytesLeftToWrite;
    }

    if (S_OK == hr)
    {
        if (TRUE == g_fUseStdBlk)
        {
            // Pick up a random array element.  Choosing cStartIndex of the
            // array (with random blocks) as 6 because do not want to write
            // byte by byte or in too small chunks a large docfile. 

            usErr = pdgi->Generate(&culArrayIndex, cStartIndex, MAX_SIZE_ARRAY);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
            else
            {
                culRandIOBytes = ausSIZE_ARRAY[culArrayIndex];
            }
        }
        else
        {
            // Generate random number of bytes to write per chunk b/w 
            // RAND_IO_MIN and RAND_IO_MAX.

            usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }
    }

    // Calculate how many chunks be written, i.e how many CRC's be calculated

    if (S_OK == hr)
    {
        if (0 == culRandIOBytes) 
        {
            hr = E_FAIL;
        }
        else
        {
            while (0 != culBytesLeftToWrite)
            {
                numofchunks++;

                if (culBytesLeftToWrite >= culRandIOBytes)
                {
                    culBytesLeftToWrite -= culRandIOBytes;
                }
                else
                {				
                    culBytesLeftToWrite = 0;
                }
            }
        }
    }

    if (S_OK == hr)
    {
        culBytesLeftToWrite = tmpBytes;

        tmpBytes = culRandIOBytes;
    }

    // Allocate memory

    if (S_OK == hr)
    {
        dwMemCRC = new DWCRCSTM[numofchunks];
        dwActCRC = new DWCRCSTM[numofchunks];

        if ((NULL == dwMemCRC) || (NULL == dwActCRC))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Initilize each CRC to zero

    if (S_OK == hr)
    {
        for (index=0; index<numofchunks; index++)
        {
            (*(dwMemCRC + index)).dwCRCSum = 0;
            (*(dwActCRC + index)).dwCRCSum = 0;
        }
    }

    // Loop to write new IStream in RAND_IO size chunks unless size
    // remaining to write is less than RAND_IO, then write the remaining bytes

    index = 0;

    while ((S_OK == hr) && (0 != culBytesLeftToWrite))
    {
        if (culBytesLeftToWrite > culRandIOBytes)
        {
            culBytesLeftToWrite = culBytesLeftToWrite - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToWrite;
            culBytesLeftToWrite = 0;
        }

        // Call VirtualStmNode::Write to create random bytes in the stream. For
        // our test purposes, we generate a random string of size culRandIOBytes
        // using GenerateRandomString function.

        if (S_OK == hr)
        {
            hr = GenerateRandomString(
                    pdgu, 
                    culRandIOBytes,
                    culRandIOBytes, 
                    &ptcsBuffer);
        }

        if (S_OK == hr)
        {
            hr =  pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culWritten);
        }

        if(S_OK != hr) 
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }

        // Calculate the CRC for stream name and data

        if (S_OK == hr)
        {
            hr = CalculateInMemoryCRCForStm(
                    pvsnRootNewChildStream,
                    ptcsBuffer,
                    culRandIOBytes,
                    (dwMemCRC+index));
        }

        // Delete temp buffer

        if(NULL != ptcsBuffer)
        {
            delete []ptcsBuffer;
            ptcsBuffer = NULL;
        }

        index++;
    }

    // Log while loop result

    DH_HRCHECK(hr, TEXT("While loop - GenrateRandomName/IStream::Write,CRC"));
	
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write completed successfully.")));
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtulaStmNode::Close unsuccessful, hr=0x%lx."), 
                hr));
        }
    }

    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successfully, hr=0x%lx."),
            hr));
        }
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Open root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open wasn't successfully, hr=0x%lx."),
            hr));
    }

    // Open stream
  
    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE  ,
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open wasn't successfully, hr=0x%lx."),
            hr));
    }

    // Read and verify

    index = 0;

    culRandIOBytes = tmpBytes;

    while ((S_OK == hr) && (0 != culBytesLeftToRead))
    {

        if (culBytesLeftToRead > culRandIOBytes)
        {
            culBytesLeftToRead = culBytesLeftToRead - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToRead;
            culBytesLeftToRead = 0;
        }

        // Allocate a buffer of required size

        if (S_OK == hr)
        {
            ptcsBuffer = new TCHAR [culRandIOBytes];

            if (NULL == ptcsBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (S_OK == hr)
        {
            memset(ptcsBuffer, '\0',  culRandIOBytes*sizeof(TCHAR));

            hr =  pvsnRootNewChildStream->Read(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culRead);
        }

        if (S_OK != hr) 
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Read function wasn't successful, hr=0x%lx."),
                hr));
        }

        // Calculate the CRC for stream name and data

        if (S_OK == hr)
        {
            hr = CalculateInMemoryCRCForStm(
                    pvsnRootNewChildStream,
                    ptcsBuffer,
                    culRandIOBytes,
                    (dwActCRC+index));

            DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStm"));
        }

        // Compare corresponding dwMemCRC and dwActCRC and verify

        if (S_OK == hr)
        {
            if ( (*(dwActCRC+index)).dwCRCSum != (*(dwMemCRC+index)).dwCRCSum )
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC's for pvsnNewChildStream don't match. ")));
				
                fPass = FALSE;
                break;
            }
        }

        // Delete temp buffer

        if (NULL != ptcsBuffer)
        {
            delete []ptcsBuffer;
            ptcsBuffer = NULL;
        }

        index++;
    }

    // Log results of while loop

    DH_HRCHECK(hr, TEXT("While loop - GenrateRandomName/IStream::Write,CRC"));
	
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write completed successfully.")));
    }

    if (S_OK == hr)
    {
        if (TRUE == fPass)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's for pvsnNewChildStream all matched.")));
        }
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release Root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STMTEST_103 failed, hr=0x%lx."),
            hr));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    if (NULL != dwMemCRC)
    {
        delete []dwMemCRC;
        dwMemCRC = NULL;
    }

    if (NULL != dwActCRC)
    {
        delete []dwActCRC;
        dwActCRC = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_104 
//
// Synopsis: Create a root docfile and an IStream in that. Write to IStream.
//       The test seeks to the end of the IStream to determine the size
//       and then makes 4 seek passes through the IStream:
//       
//          1)  Seek cumulative offset from STREAM_SEEK_SET (beginning)
//              to end, then rewind IStream to beginning
//          2)  Seek relative offset from STREAM_SEEK_CUR (current)
//              to end, then seek IStream to end
//          3)  Seek negative cumulative offset from STREAM_SEEK_END (end)
//              to beginning, then seek IStream to end
//          4)  Seek negative relative offset from STREAM_SEEK_CUR (current)
//              to beginning
//          5)  Perform several random large offset seeks from
//              STREAM_SEEK_SET (beginning)
//          6)  Attempt to write one byte at the current position in stream
//
//          The root docfile and stream are then releases and root docfile
//          deleted
//
//          Note: It is an error to seek before beginning of stream (tested
//          in part 4, but it is not an error to seek past end of stream.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    2-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LSSEEK.CXX
// 2.  Old name of test : LegitStreamSeek test 
//     New Name of test : STMTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:dirReadWriteShEx  /labmode
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:xactReadWriteShEx /labmode
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:xactReadWriteShDenyW /labmode 
//     d. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:dirReadWriteShEx  /labmode /stdblock
//     e. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:xactReadWriteShEx /labmode /stdblock
//     f. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:xactReadWriteShDenyW /labmode /stdblock 
//     g. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:dirReadWriteShEx  /labmode /stdblock /lgseekwrite
//     h. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:xactReadWriteShEx /labmode /stdblock /lgseekwrite
//     i. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-104
//        /dfRootMode:xactReadWriteShDenyW /labmode /stdblock /lgseekwrite
//
// BUGNOTE: Conversion: STMTEST-104
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    DWORD           dwRootMode              = 0;
    ULONG           culRandIOBytes          = 0;
    ULONG           culBytesLeftToWrite     = 0;
    ULONG           ulStreamSize            = 0;
    LONG            lSeekThisTime           = 0;
    ULONG           cArrayIndex             = 0;
    ULONG           ulCurrentPosition       = 0;
    ULONG           cNumVars                = 0;
    ULONG           cMinVars                = 5;
    ULONG           cMaxVars                = 10;
    BOOL            fPass                   = TRUE;
    LARGE_INTEGER   liStreamPos;
    LARGE_INTEGER   liSeekThisTime;
    ULARGE_INTEGER  uli;
    
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_104 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt stream Seek operations")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_104, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        // Generate random size for stream between 0L, and MIN_SIZE * 1.5
        // (range taken from old test).

        usErr = pdgi->Generate(&culBytesLeftToWrite, 0,(ULONG)(MIN_SIZE * 1.5));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Loop to write new IStream in RAND_IO size chunks unless size
    // remaining to write is less than RAND_IO, then write the remaining bytes

    while((S_OK == hr) && (0 != culBytesLeftToWrite))
    {
        culRandIOBytes = RAND_IO_MIN;

        if(culBytesLeftToWrite > culRandIOBytes)
        {
            culBytesLeftToWrite = culBytesLeftToWrite - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToWrite;
            culBytesLeftToWrite = 0;
        }

        // Call VirtualStmNode::Write to create random bytes in the stream.  For
        // our test purposes, we generate a random string of size culRandomBytes
        // using GenerateRandomString function.

        if(S_OK == hr)
        {
            hr = GenerateRandomString(
                    pdgu, 
                    culRandIOBytes,
                    culRandIOBytes, 
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr =  pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culWritten);
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }

        // Delete temp buffer

        if(NULL != ptcsBuffer)
        {
            delete ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }

    // Now seek to the end of this stream and determine its size

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        // Seek to end of stream and determine size of stream 

        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;
    }

    if(S_OK == hr)
    {
        ulStreamSize = ULIGetLow(uli);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // loop through the entire IStream, each time seeking relative to the
    // beginning of the IStream (STREAM_SEEK_SET).  The amount to add to
    // the offset from the beginning is a random number or a random array
    // element of ausSIZE_ARRAY if command line option specifies that. 

    memset(&uli, 0, sizeof(LARGE_INTEGER));

    while ((ulCurrentPosition < ulStreamSize) && (S_OK == hr))
    {
        hr = GetRandomSeekOffset(&lSeekThisTime, pdgi);

        DH_HRCHECK(hr, TEXT("GetRandomSeekOffset")) ;

        if(S_OK == hr)
        {
            LISet32(liSeekThisTime, lSeekThisTime);
            hr = pvsnRootNewChildStream->Seek(
                    liSeekThisTime, 
                    STREAM_SEEK_SET, 
                    &uli);

            DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

            ulCurrentPosition = ULIGetLow(uli);
        }
    }

    DH_TRACE((
        DH_LVL_TRACE1, 
        TEXT("Current position is now %lu"), 
        ulCurrentPosition));

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        hr = pvsnRootNewChildStream->Seek(
                liStreamPos, 
                STREAM_SEEK_SET, 
                &uli);

        ulCurrentPosition = ULIGetLow(uli);
    
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // loop through the entire IStream, each time seeking relative to the
    // current seek pointer (STREAM_SEEK_CUR).  The distance to seek is a
    // random ushort.

    lSeekThisTime = 0;

    memset(&uli, 0, sizeof(LARGE_INTEGER));

    while ((ulCurrentPosition < ulStreamSize) && (S_OK == hr))
    {
        hr = GetRandomSeekOffset(&lSeekThisTime, pdgi);

        DH_HRCHECK(hr, TEXT("GetRandomSeekOffset")) ;

        if(S_OK == hr)
        {    
            LISet32(liSeekThisTime, lSeekThisTime);

            hr = pvsnRootNewChildStream->Seek(
                    liSeekThisTime, 
                    STREAM_SEEK_CUR, 
                    &uli);

            ulCurrentPosition = ULIGetLow(uli);
    
            DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;
        }
    }

    DH_TRACE((
        DH_LVL_TRACE1, 
        TEXT("Current position is now %lu"), 
        ulCurrentPosition));

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // Seek to the end of Stream.  Then we would seek negative cumulative 
    // offset from the STREAM_SEEK_END.

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
        memset(&uli, 0, sizeof(LARGE_INTEGER));

        hr = pvsnRootNewChildStream->Seek(
                liStreamPos, 
                STREAM_SEEK_END, 
                &uli);
    
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulCurrentPosition = ULIGetLow(uli);
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // loop through the entire IStream, each time seeking relative to the
    // end of the IStream (STREAM_SEEK_END).  The amount to add to
    // the offset from the end is a random ushort
 
    lSeekThisTime = 0;

    memset(&uli, 0, sizeof(LARGE_INTEGER));
    
    while ((ulCurrentPosition != 0) && (S_OK == hr))
    {
        hr = GetRandomSeekOffset(&lSeekThisTime, pdgi);

        DH_HRCHECK(hr, TEXT("GetRandomSeekOffset")) ;

        // if generated seek offset would cause a seek to before beginning 
        // of file, ensure that it won't do that by enforcing to seek to
        // the beginnining.

        if(S_OK == hr)
        {
            if(lSeekThisTime > (LONG) ulStreamSize)
            {
                lSeekThisTime = (LONG) ulStreamSize;
            }

            // Unary minus opeartion is applied to seek offset to cause a neg
            // seek opeartion
 
            LISet32(liSeekThisTime, -lSeekThisTime);

            hr = pvsnRootNewChildStream->Seek(
                    liSeekThisTime, 
                    STREAM_SEEK_END, 
                    &uli);
    
            DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

            ulCurrentPosition = ULIGetLow(uli);
        }
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
        memset(&uli, 0, sizeof(LARGE_INTEGER));

        hr = pvsnRootNewChildStream->Seek(
                liStreamPos, 
                STREAM_SEEK_END, 
                &uli);
    
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulCurrentPosition = ULIGetLow(uli);
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    //loop through the entire IStream, each time seeking relative to the
    //current seek pointer (STREAM_SEEK_CUR).  The distance to seek is a
    //random ushort or a random block size chosen from ausSIZE_ARRAY[].
    //This loop seeks in a negative direction.

    lSeekThisTime = 0;

    memset(&uli, 0, sizeof(LARGE_INTEGER));
    
    while ((ulCurrentPosition != 0) && (S_OK == hr))
    {
        hr = GetRandomSeekOffset(&lSeekThisTime, pdgi);

        DH_HRCHECK(hr, TEXT("GetRandomSeekOffset")) ;

        // if generated seek offset would cause a seek to before beginning 
        // of file, ensure that it won't do that by enforcing to seek to
        // the beginnining.

        if(S_OK == hr)
        {
            if(lSeekThisTime > (LONG) ulCurrentPosition)
            {
                lSeekThisTime = (LONG) ulCurrentPosition;
            }

            // Unary minus operation is applied to seek offset to cause a neg
            // seek opeartion
 
            LISet32(liSeekThisTime, -lSeekThisTime);

            hr = pvsnRootNewChildStream->Seek(
                    liSeekThisTime, 
                    STREAM_SEEK_CUR, 
                    &uli);
    
            DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

            ulCurrentPosition = ULIGetLow(uli);
        }
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
        memset(&uli, 0, sizeof(LARGE_INTEGER));

        hr = pvsnRootNewChildStream->Seek(
                liStreamPos, 
                STREAM_SEEK_SET, 
                &uli);
    
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulCurrentPosition = ULIGetLow(uli);
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // Peform random number of seeks before beginning of the stream.

    if (S_OK == hr)
    {
        // Generate random number of variations to be done.

        usErr = pdgi->Generate(&cNumVars, cMinVars, cMaxVars);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        while((cNumVars--) && (S_OK == hr))
        {
            hr = GetRandomSeekOffset(&lSeekThisTime, pdgi);

            DH_HRCHECK(hr, TEXT("GetRandomSeekOffset")) ;

            if(S_OK == hr)
            {
                // Unary minus operation is applied to seek offset to cause a
                // negative seek opeartion
 
                LISet32(liSeekThisTime, -lSeekThisTime);

                hr = pvsnRootNewChildStream->Seek(
                        liSeekThisTime, 
                        STREAM_SEEK_CUR, 
                        &uli);
    
                ulCurrentPosition = ULIGetLow(uli);

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Seek to pos - %ld on IStream should have failed."),
                        lSeekThisTime));

                    fPass = FALSE;
                    break;
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Seek pos -%ld on IStream failed as exp, hr=0x%lx."),
                        lSeekThisTime,
                        hr));

                    hr = S_OK;
                }
            }
        }
    }

    // Now perform large offset seeks on IStream and the try to write 1 byte
    // at the last offset if g_fDoLargeSeekAndWrite is set.

    if (S_OK == hr)
    {
        // Generate random number of variations to be done.

        usErr = pdgi->Generate(&cNumVars, cMinVars, cMaxVars);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        while((cNumVars--) && (S_OK == hr))
        {
            hr = GetRandomSeekOffset(&lSeekThisTime, pdgi);

            DH_HRCHECK(hr, TEXT("GetRandomSeekOffset")) ;

            if(S_OK == hr)
            {    
                LISet32(liSeekThisTime, lSeekThisTime);

                hr = pvsnRootNewChildStream->Seek(
                        liSeekThisTime, 
                        STREAM_SEEK_SET, 
                        &uli);
    
                ulCurrentPosition = ULIGetLow(uli);
            }   
        }
    }
    
    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // Now atempt to write

    LPTSTR  ptszSample = TEXT("Test");

    if((TRUE == g_fDoLargeSeekAndWrite) && (S_OK == hr))
    {
        hr =  pvsnRootNewChildStream->Write(
                ptszSample,
                1,
                NULL);

        if((S_OK == hr)             || 
           (STG_E_MEDIUMFULL == hr) || 
           (STG_E_INSUFFICIENTMEMORY == hr))
        {
            DH_TRACE((DH_LVL_TRACE1,
                    TEXT("Attempt to write 1 byte at offset %lu, hr = 0x%lx"),
                    ulCurrentPosition,  
                    hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1,
                    TEXT("Attempt to write 1 byte ar offset %lu, hr = 0x%lx"),
                    ulCurrentPosition,  
                    hr));
        }
    }

    // Release root's child stream

    if (NULL != pvsnRootNewChildStream)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
        }
    }

    // Release root 

    if (NULL != pVirtualDFRoot)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
        }
    }

    // if everything goes well, log test as passed else failed.
    if((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
              TEXT("Test variation STMTEST_104 failed, hr=0x%lx."),
              hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    STMTEST_105 
//
// Synopsis: The test create a root docfile with a child IStream. Write a
//           random number of bytes to the IStream and commit the root
//           docfile. 
//
//           The test seeks to a position before the end of the IStream,
//           SetSizes() the IStream to a size less than the current seek
//           pointer position. The root docfile is committed. Verify that 
//           the seek pointer didn't change during the SetSize() call. Now
//           write 0 bytes at the current seek pointer position(which is 
//           beyond the end of the IStream). The seek pointer still should 
//           not move and no error should occur. Finally, seek to the end of
//           the IStream and verify the correct IStream size, then stream and 
//           the root docfile are released and the root file is deleted upon 
//           success.
//  
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File(s): LSETSIZA.CXX
// 2.  Old name of test(s) : LegitStreamSetSizeAbandon test 
//     New Name of test(s) : STMTEST_105 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-105
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-105
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-105
//        /dfRootMode:xactReadWriteShDenyW 
//
// History:  Jiminli	16-July-96	Created
//
// BUGNOTE: Conversion: STMTEST-105
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_105(int argc, char *argv[])
{

    HRESULT         hr                          = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    DG_STRING      *pdgu                       = NULL;
    DG_INTEGER      *pdgi                       = NULL;
    USHORT          usErr                       = 0;
    VirtualStmNode  *pvsnRootNewChildStream     = NULL;
    LPTSTR          pRootNewChildStmName        = NULL;
    LPTSTR          ptcsBuffer                  = NULL;
    ULONG           culBytesLeftToWrite         = 0;
    ULONG           culWritten                  = 0;
    ULONG           culRead                     = 0;
    DWORD           dwRootMode                  = 0; 
    ULONG           culRandIOBytes              = 0;
    ULONG           ulRandOffset                  = 0;  
    ULONG           ulOriginalPosition          = 0;
    ULONG           ulNewPosition               = 0;
    ULONG           ulSizeParam                 = 0;
    BOOL            fPass                       = TRUE;
    ULARGE_INTEGER  uli;
    ULARGE_INTEGER  uliOffset;
    LARGE_INTEGER   liStreamPos;
    LARGE_INTEGER   liOffset;


    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_105"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_105 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt SetSize using the IStream interface.")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_105, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi);
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    // Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        // Generate random size for stream between 4L, and MIN_SIZE * 1.5
        // (from old test)

        usErr = pdgi->Generate(&culBytesLeftToWrite,4L,(ULONG)(MIN_SIZE * 1.5));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        // Generate random number of bytes to write per chunk b/w 
        // RAND_IO_MIN and RAND_IO_MAX.
		
        usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
 
    // Loop to write new IStream in culRandIOBytes size chunks unless size 
    // remaining to write is less than culRandIOBytes, then write the 
    // remaining bytes. CRC is not important for this test, so no check for it.

    while ((S_OK == hr) && (0 != culBytesLeftToWrite))
    {
        if (culBytesLeftToWrite > culRandIOBytes)
        {
            culBytesLeftToWrite = culBytesLeftToWrite - culRandIOBytes;
        }
        else
        {
            culRandIOBytes = culBytesLeftToWrite;
            culBytesLeftToWrite = 0;
        }

        // Call VirtualStmNode::Write to create random bytes in the stream.  For
        // our test purposes, we generate a random string of size culRandIOBytes
        // using GenerateRandomString function.

        if (S_OK == hr)
        {
            hr = GenerateRandomString(
                    pdgu, 
                    culRandIOBytes,
                    culRandIOBytes, 
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr =  pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culRandIOBytes,
                    &culWritten);
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }

        // Delete temp buffer

        if(NULL != ptcsBuffer)
        {
            delete []ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }
	
    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
            hr));
    }

    // Seek to the end of stream

    if (S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulOriginalPosition = ULIGetLow(uli);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed Ok. EndofStream = %lu"),
			ulOriginalPosition));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not Ok, hr=0x%lx. EndofStream = %lu"),
            hr, 
			ulOriginalPosition));
    }

    // Seeking to a negative value from end

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&ulRandOffset, 1L, ulOriginalPosition / 2);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Seek to end of IStream - %lu bytes"),
                ulRandOffset));
        }
    }
 
    if(S_OK == hr)
    {
        LISet32(liOffset, (- (LONG)ulRandOffset));

        hr = pvsnRootNewChildStream->Seek(liOffset, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulOriginalPosition = ULIGetLow(uli);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed Ok. New seek ptr=%lu"),
			ulOriginalPosition));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Seek wasn't Ok, hr=0x%lx. New seek ptr=%lu"),
            hr, 
			ulOriginalPosition));
    }

    // Generate number of bytes less than current seek pointer to 
    // SetSize the stream to.

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&ulRandOffset, 1L, ulOriginalPosition / 2);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Random offset(i.e. new size of stream) = %lu bytes"),
                ulRandOffset));
        }
    }

    if (S_OK == hr)
    {
        ulSizeParam = ulOriginalPosition - ulRandOffset;

        ULISet32(uliOffset, ulSizeParam);

        hr = pvsnRootNewChildStream->SetSize(uliOffset);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::SetSize")) ;
    }
	
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::SetSize completed successfully. Size=%lu"),
            ulSizeParam));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::SetSize unsuccessful, hr=0x%lx, Size=%lu"),
            hr,
            ulSizeParam));
    }

    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
            hr));
    }

    // Get current seek pointer, should be same as ulOriginalPosition

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_CUR, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulNewPosition = ULIGetLow(uli);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully. Seek ptr=%lu"),
			ulNewPosition));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not Ok, hr=0x%lx, seek ptr=%lu"),
            hr, 
			ulNewPosition));
    }	

    if (S_OK == hr)
    {
        if (ulOriginalPosition != ulNewPosition)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::SetSize changed seek ptr position.")));

            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Ok, VirtualCtrNode::SetSize not change seek ptr.")));
        }
    }

    // Tset 0 byte write beyond end of IStream, shouldn't move seek pointer

    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu, 
                0,
                0, 
                &ptcsBuffer);	 

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Write(
                ptcsBuffer,
                0,
                &culWritten);
    } 

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
            hr));
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Get current seek pointer, should be same as ulOriginalPosition

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_CUR, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulNewPosition = ULIGetLow(uli);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully. Seek ptr=%lu"),
            ulNewPosition));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not Ok, hr=0x%lx, Seek ptr=%lu"),
            hr, 
            ulNewPosition));
    }	

    if (S_OK == hr)
    {
        if (ulOriginalPosition != ulNewPosition)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("0 byte write changed seek pointer position.")));

            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Ok, 0 byte write not change seek pointer position.")));
        }
    }

    // Verify correct end of IStream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulNewPosition = ULIGetLow(uli);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully. EndofStm=%lu"),
			ulNewPosition));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not Ok, hr=0x%lx, EndofStm=%lu"),
            hr, 
            ulNewPosition));
    }	

    if (S_OK == hr)
    {
        if (ulSizeParam != ulNewPosition)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Seek to end is not same position as SetSize().")));

            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Ok, Seek to end is the same position as SetSize().")));
        }
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release Root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
        DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_105 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STMTEST_105 failed, hr=0x%lx."),
            hr));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_105 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_106 
//
// Synopsis: The test create a root docfile with a child IStream. 3 random 
//           SECTORSIZE byte blocks are generated and the CRC is computed. 
//           The data is written to the IStream. then the IStream is 
//           rewound and read back, and the CRC returned from the read is
//           compared with the CRC when written. The seek pointer is changed
//           to an offset somewhere in the first sector, but not the first
//           or last byte. A SECTORSIZE block of the in-memory buffer is 
//           changed starting at the same offset used for the seek. The CRC
//           is computed for the entire memory buffer. The block is written
//           to the IStream, the IStream is rewound, read, and the CRCs are
//           again compared. Finally, the root docfile is committed and the
//           read/CRC compare is repeated. Then stream and the root docfile 
//           are released and the root file is deleted upon success.
//           
//  
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File(s): LSECTSPN.CXX
// 2.  Old name of test(s) : LegitStreamSectorSpan test 
//     New Name of test(s) : STMTEST_106 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-106
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-106
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-106
//        /dfRootMode:xactReadWriteShDenyW 
//
// History:  Jiminli	18-July-96	Created
//
// BUGNOTE: Conversion: STMTEST-106
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_106(int argc, char *argv[])
{

    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPTSTR          ptTempBuf1              = NULL;
    LPTSTR          ptTempBuf2              = NULL;
    LPBYTE          ptcsBuffer              = NULL;
    LPBYTE          ptcsDataBuffer          = NULL;
    ULONG           culNumBytes             = 0;
    ULONG           culWritten              = 0;
    ULONG           ulRandOffset            = 0; 
    ULONG           culRead                 = 0;
    ULONG           index1                  = 0;
    ULONG           index2                  = 0;
    DWORD           dwRootMode              = 0; 
    DWORD           dwBufCRC                = 0;
    DWORD           dwActCRC                = 0; 
    BOOL            fPass                   = TRUE; 
    LARGE_INTEGER   liZero;
    LARGE_INTEGER   liOffset;
    ULARGE_INTEGER  uli;
    ULONG           ulOriginalPosition      = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_106"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_106 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt SectorSpan using the Stm interface.")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_106, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    // Adds a new stream to the root storage.

    if (S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    // Generate three sectors worth of random bytes and compute CRC
    // then write the bytes to the IStream, rewind IStream, then read
    // back the data and compare CRCs to ensure valid write/read

    if (S_OK == hr)
    {
        // Generate a random string of size culNumBytes

        culNumBytes = SECTORSIZE * 3;

        hr = GenerateRandomString(
                pdgu, 
                culNumBytes,
                culNumBytes, 
                &ptTempBuf1);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }
 
    if (S_OK == hr)
    {
        // Let ptcsBuffer point to temporary buffer(for purpose of 
        // type casting, because IStream:Seek proceeds by BYTE)

        ptcsBuffer = (LPBYTE)ptTempBuf1;

        hr = CalculateCRCForDataBuffer(
                (LPTSTR)ptcsBuffer,
                culNumBytes,
                &dwBufCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Write(
                ptcsBuffer,
                culNumBytes,
                &culWritten);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write function not successful, hr=0x%lx."),
            hr));
    }

    // Allocate required space

    if (S_OK == hr)
    {
        ptcsDataBuffer = new BYTE[culNumBytes];

        if (NULL == ptcsDataBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        memset(ptcsDataBuffer, '\0', culNumBytes * sizeof(BYTE));

        while (culNumBytes--)
        {
           ptcsDataBuffer[index1] = ptcsBuffer[index1];
           index1++;
        }

        culNumBytes = SECTORSIZE * 3;
    }
    
    // delete temp buffer (ptcsBuffer and ptTempBuf1 point to the same memory)

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
        ptTempBuf1 = NULL;
    }

    if (S_OK == hr)
    {
		LISet32(liZero, 0L);

		hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek function not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        ptcsBuffer = new BYTE[culNumBytes];

        if (NULL == ptcsBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (S_OK == hr)
    {
        memset(ptcsBuffer, '\0', culNumBytes * sizeof(BYTE));

        hr = pvsnRootNewChildStream->Read(
                ptcsBuffer,
                culNumBytes,
                &culRead);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Read function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Read function not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                (LPTSTR)ptcsBuffer,
                culNumBytes,
                &dwActCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    // Compare CRCs 

    if (S_OK == hr)
    {
        if (dwBufCRC != dwActCRC)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream write/read mismatch before change, hr=0x%lx."),
                hr));

            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream write/read matched before change.")));
        }
    }
 
    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }
  
    // Pick a random offset somewhere in the first sector, but not the first
    // or last byte. Seek to the new position. Starting at the same offset in 
    // the in-memory buffer, replace 1 SECTORSIZE block with new random data.
    // After the replace, re-compute the CRC for the entire buffer.
 
    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&ulRandOffset, 1, (SECTORSIZE - 1));

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Seek to position of the first SECTOR: %lu"),
                (ULONG)ulRandOffset));
        }
    }
 
	if (S_OK == hr)
    {
        LISet32(liOffset, ulRandOffset);

        hr = pvsnRootNewChildStream->Seek(liOffset, STREAM_SEEK_SET, &uli);
 
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulOriginalPosition = ULIGetLow(uli);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Seekpos = %lu"),
            ulOriginalPosition));         
 	}

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Seek wasn't successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        // Generate a random string of size SECTORSIZE

        hr = GenerateRandomString(
                pdgu, 
                SECTORSIZE,
                SECTORSIZE, 
                &ptTempBuf2);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }
  
    if (S_OK == hr)
    {
        // Let ptcsBuffer point to the temporary buffer(for purpose of 
        // typecasting, because IStream::Seek proceeds by BYTE)

        ptcsBuffer = (LPBYTE)ptTempBuf2;

        // Change the memory buffer ptcsDataBuffer

        culNumBytes = SECTORSIZE;
        index1 = ulRandOffset;
        index2 = 0;

        while (culNumBytes--)
        {
            ptcsDataBuffer[index1++] = ptcsBuffer[index2++];            
        }

        culNumBytes = SECTORSIZE * 3;

        // Calculate CRC for the changed buffer

        hr = CalculateCRCForDataBuffer(
                (LPTSTR)ptcsDataBuffer,
                culNumBytes,
                &dwBufCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }
 
    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Write(
                ptcsBuffer,
                SECTORSIZE,
                &culWritten);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write function not successful, hr=0x%lx."),
            hr));
    }
 
    // delete temp buffer (ptcsBuffer and ptTempBuf2 point to the same memory)

    if ( NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
        ptTempBuf2 = NULL;
    }

    if (S_OK == hr)
    { 
        memset(&liZero, 0, sizeof(LARGE_INTEGER));

		hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek function not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        ptcsBuffer = new BYTE[culNumBytes];

        if (NULL == ptcsBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (S_OK == hr)
    {
        memset(ptcsBuffer, '\0', culNumBytes * sizeof(BYTE));

        hr = pvsnRootNewChildStream->Read(
                ptcsBuffer,
                culNumBytes,
                &culRead);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Read function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Read function not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                (LPTSTR)ptcsBuffer,
                culNumBytes,
                &dwActCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    // Compare CRCs 

    if (S_OK == hr)
    {
        if (dwBufCRC != dwActCRC)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream write/read mismatch after change, hr=0x%lx."),
                hr));
 
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream write/read matched after change.")));
        }
    }

    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
            hr));
    }

    if ( NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    if (S_OK == hr)
    { 
        memset(&liZero, 0, sizeof(LARGE_INTEGER));

		hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek function not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        ptcsBuffer = new BYTE[culNumBytes];

        if (NULL == ptcsBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (S_OK == hr)
    {
        memset(ptcsBuffer, '\0', culNumBytes * sizeof(BYTE));

        hr = pvsnRootNewChildStream->Read(
                ptcsBuffer,
                culNumBytes,
                &culRead);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Read function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Read function not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                (LPTSTR)ptcsBuffer,
                culNumBytes,
                &dwActCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    // Compare CRCs 

    if (S_OK == hr)
    {
        if (dwBufCRC != dwActCRC)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream write/read mismatch after commit, hr=0x%lx."),
                hr));

            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream write/read matched after commit.")));
        }
    }
    
    // Delete temp buffers

    if (NULL != ptcsDataBuffer)
    {
        delete []ptcsDataBuffer;
        ptcsDataBuffer = NULL;
    }
 
    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release Root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_106 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
              TEXT("Test variation STMTEST_106 failed, hr=0x%lx."),
              hr));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

	DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_106 finished")) );
	DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

	return hr;
}


//----------------------------------------------------------------------------
//
// Test:    STMTEST_107 
//
// Synopsis: The test create a root docfile with a child IStream. Then perform
//           various illegitimate operating using the IStream interface. The 
//           stream and the root docfile are then released and the root file 
//           is deleted upon success.
//  
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File(s): ISNORM.CXX
// 2.  Old name of test(s) : IllegitStreamNorm test 
//     New Name of test(s) : STMTEST_107 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-107
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-107
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-107
//        /dfRootMode:xactReadWriteShDenyW 
//
// History:  Jiminli	14-July-96	Created
//
// BUGNOTE: Conversion: STMTEST-107
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_107(int argc, char *argv[])
{
    HRESULT         hr                          = S_OK;
    HRESULT         hr1                         = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    DG_STRING      *pdgu                       = NULL;
    DG_INTEGER      *pdgi                       = NULL;
    USHORT          usErr                       = 0;
    VirtualStmNode  *pvsnRootNewChildStream0    = NULL;
    VirtualStmNode  *pvsnRootNewChildStream1    = NULL;
    LPSTREAM        pstm0                       = NULL;
    LPSTREAM        pstm1                       = NULL;
    LPSTREAM        pCloneStm                   = NULL;
    LPTSTR          pRootNewChildStmName0       = NULL;
    LPTSTR          pRootNewChildStmName1       = NULL;
    LPTSTR          ptcsBuffer                  = NULL;
    ULONG           culWritten                  = 0;
    ULONG           culRead                     = 0;
    DWORD           dwRootMode                  = 0; 
    ULONG           culRandIOBytes              = 0;
    ULONG           ulRef                       = 0;
    BOOL            fPass                       = TRUE; 
    ULARGE_INTEGER  uliCopy;
    LARGE_INTEGER   liOffset;
    LARGE_INTEGER   liZero;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_107"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_107 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt illegitimate operations on IStream.")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_107, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi);
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    // Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootNewChildStmName0);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName0,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream0);

        DH_HRCHECK(hr, TEXT("AddFirstStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode0::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode0::AddStream not successful, hr=0x%lx."),
            hr));
    }

    // Generate random number of bytes to write to stream b/w
    // RAND_IO_MIN and RAND_IO_MAX.

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Call Virtual::Write to create random bytes in the stream. For our test
    // purposes, we generate a random string of size culRandIOBytes using
    // GenerateRandomString function.

    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu,
                culRandIOBytes,
                culRandIOBytes,
                &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString"));
    }

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream0->Write(
                ptcsBuffer,
                culRandIOBytes,
                &culWritten);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
            hr));
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Adds another new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootNewChildStmName1);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName1,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream1);

        DH_HRCHECK(hr, TEXT("AddSecondStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode1::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode1::AddStream not successful, hr=0x%lx."),
            hr));
    }
	
    // Pass NULL pv to read call, should fail

    if (S_OK == hr)
    {
        pstm0 = pvsnRootNewChildStream0->GetIStreamPointer();
        pstm1 = pvsnRootNewChildStream1->GetIStreamPointer();

        DH_ASSERT(NULL != pstm0);
        DH_ASSERT(NULL != pstm1);
    }

    if (S_OK == hr)
    {
        hr1 = pstm0->Read(
                NULL,
                culRandIOBytes,
                &culRead);

        if (STG_E_INVALIDPOINTER != hr1)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Read should return STG_E_INVALIDPOINTER, hr=0x%lx."),
                hr1));
		
            fPass = FALSE;
		
        }
        else 
        {	
            // Reset hr value for other tests

            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Read failed as expected, hr=0x%lx."),
                hr1));

            hr1 = S_OK;
        }
    }

    //
    // coverage for bug# 143546
    // 
    
    //
    // commented out to avoid av'ing;
    // we should activate it when bug it's fixed
    //

/*
    if (S_OK == hr)
    {
        const char *szDummy = "foo"; // readonly        
        
        // make stream nonempty

         HRESULT hr2 = pstm0->Write(szDummy, strlen(szDummy), &culWritten);
        DH_HRCHECK(hr2, TEXT("IStream::Write"));

        if (S_OK == hr2)
        {
            LARGE_INTEGER li;
            LISet32(li, 0L);
            hr2 = pstm0->Seek(li, SEEK_SET,NULL);
            DH_HRCHECK(hr2, TEXT("IStream::Seek SEEK_SET"));
        }

        if(S_OK == hr2)
        {
        
            hr1 = pstm0->Read((void*)szDummy,
                              strlen(szDummy),
                              &culRead);
            if (STG_E_INVALIDPOINTER != hr1)
            {
                DH_TRACE((
                    DH_LVL_ERROR,
                    TEXT("Read should return STG_E_INVALIDPOINTER when in buffer is readonly, hr=0x%lx."),
                    hr1));
		    
                fPass = FALSE;
		    
            }
            else 
            {	
                // Reset hr value for other tests

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Read failed as expected, hr=0x%lx."),
                    hr1));

                hr1 = S_OK;
            }
        }

        if(S_OK == hr2)
        {
            // restore empty stream

            ULARGE_INTEGER uli;
            LISet32(uli, 0L);
            hr = pstm1->SetSize(uli);
            DH_HRCHECK(hr, TEXT("IStream::SetSize 0"));
        }
    }

*/

    // Pass NULL pv to write call, should fail

    if (S_OK == hr)
    {
        hr1 = pstm1->Write(
                NULL,
                culRandIOBytes,
                &culWritten);

        if (STG_E_INVALIDPOINTER != hr1)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Write should return STG_E_INVALIDPOINTER, hr=0x%lx."),
            hr1));
		
            fPass = FALSE;
        }
        else 
        { 	
            // Reset hr value for other tests
		
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Write failed as expected, hr=0x%lx."),
            hr1));

            hr1 = S_OK;
        }
    }

    // Pass NULL ppstm to clone call, should fail

    if (S_OK == hr)
    {
        hr1 = pstm0->Clone(
                NULL);

        if (STG_E_INVALIDPOINTER != hr1)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Clone should have failed, hr=0x%lx."),
            hr1));

            fPass = FALSE;
        }
        else 
        {	
            // Reset hr value for other tests

            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Clone failed as expected, hr=0x%lx."),
            hr1));

            hr1 = S_OK;
        }
    }
	
    // Pass NULL pstm to CopyTo call, should fail
    
    if(S_OK == hr)
    {
        ULISet32(uliCopy, culRandIOBytes);

        hr1 = pstm0->CopyTo(NULL, uliCopy, NULL, NULL);

        if (STG_E_INVALIDPOINTER != hr1)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CopyTo should have failed, hr=0x%lx."),
                hr1));
		
            fPass = FALSE;
        }
        else 
        {	
            // Reset hr value for other tests

            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("CopyTo failed as expected, hr=0x%lx."),
            hr1));

            hr1 = S_OK;
        }
    }

    // Pass 'cb' > length of stream to CopyTo(), should pass

    if (S_OK == hr)
    {
        ULISet32(uliCopy, ULONG_MAX);

        hr1 = pvsnRootNewChildStream0->CopyTo(
                pvsnRootNewChildStream1,
                uliCopy,
                NULL,
                NULL);

        if (S_OK == hr1)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::CopyTo completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::CopyTo not successful, hr=0x%lx."),
            hr1));
        }
    }

    // Release Stream1

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream1->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode1::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode1::Close unsuccessful, hr=0x%lx."),
            hr));
        }
    }

    // Pass 'cb' > length of stream to CopyTo() w/dest Clone() of Istream,
    // should pass

    if(S_OK == hr)
    {
        LISet32(liZero, 0L);

        hr1 = pvsnRootNewChildStream0->Seek(liZero, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr1, TEXT("IStream::Seek")) ;
        if (S_OK == hr1)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream0::Seek function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream0::Seek function wasn't successful, hr=0x%lx."),
                hr1));
        }
    }

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream0->Clone(&pCloneStm);

        DH_HRCHECK(hr, TEXT("IStream::Clone"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Clone function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Clone function wasn't successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pstm0->CopyTo(pCloneStm, uliCopy, NULL, NULL);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::CopyTo completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::CopyTo not successful, hr=0x%lx."),
            hr));
    }

    // Pass 'cb' > length of stream to CopyTo() w/dest Clone() of IStream,
    // and seek pointer in source stream past end of file, should pass
    // This also tests seek function in case of seeking past end of stream

    if(S_OK == hr)
    {
        LISet32(liOffset, culRandIOBytes);

        hr = pvsnRootNewChildStream0->Seek(liOffset, STREAM_SEEK_CUR, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::Seeking past the end of stream successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::Seek past end of stream not Ok, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pstm0->CopyTo(pCloneStm, uliCopy, NULL, NULL);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::CopyTo completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream0::CopyTo not successful, hr=0x%lx."),
            hr));
    }

    // Pass invalid dwOrigin(from old test) to seek call, should fail

    if (S_OK == hr)
    {
        hr1 = pstm0->Seek(
                liZero, 
                STREAM_SEEK_SET | STREAM_SEEK_CUR | STREAM_SEEK_END, 
                NULL);

        if (STG_E_INVALIDFUNCTION != hr1)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Seek should have failed, hr=0x%lx."),
            hr1));
		
            fPass = FALSE;
        }
        else 
        {	
            // Reset hr value for other tests

            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Seek failed as expected, hr=0x%lx."),
            hr1));

            hr1 = S_OK;
        }
    }

    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
	    DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
            hr));
    }

    //Release streams

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream0->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode0::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode0::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release Clone stream

    if (NULL != pCloneStm)
    {
        ulRef = pCloneStm->Release();

        DH_ASSERT(0 == ulRef);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream1::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream1::Close unsuccessful.")));
    }
	
    // Release Root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
        DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_107 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation STMTEST_107 failed, hr=0x%lx."),
            hr));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if (NULL != pRootNewChildStmName0)
    {
        delete pRootNewChildStmName0;
        pRootNewChildStmName0 = NULL;
    }

    if (NULL != pRootNewChildStmName1)
    {
        delete pRootNewChildStmName1;
        pRootNewChildStmName1 = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_107 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_108 
//
// Synopsis: The test create a root docfile with an IStream inside of it.   
//           A random block small object size block is generated and the CRC 
//           is computed. The data is written to the IStream. The IStream is
//           rewound and read back. The CRC returned from the read is compared
//           with the CRC computed during generation. A new random block bigger
//           larger than small object size is generated at a random offset
//           in the data buffer, and then the block is written to the IStream
//           at that offset.  This has the effect of transforming the small
//           object into a regular object.  The IStream is then rewound, read,
//           and the read/write CRCs are compared.  After a commit of the root
//           docfile, the rewind, read, CRC compare is repeated.  A random
//           small object size is then chosen and the IStream is SetSized
//           back to that size.  The CRC is computed for the in-memory data
//           buffer up to the new size.  The IStream is rewound, read back,
//           and CRC'd.  The read/write CRCs are again compared to verify
//           that the shrink back to small object size retained the correct
//           data.  After the root docfile is committed, we rewind, read,
//           and compare read/write CRCs again.  From 10 to 20 small objects
//           are processed this way.
//           Then stream and the root docfile are released and the root file 
//           is deleted upon success.
//           
//  
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File(s): LSSMALLO.CXX
// 2.  Old name of test(s) : LegitStreamSmallObjects test 
//     New Name of test(s) : STMTEST_108 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-108
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-108
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-108
//        /dfRootMode:xactReadWriteShDenyW 
//
// History:  Jiminli	23-July-96	Created
//
// BUGNOTE: Conversion: STMTEST-108
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_108(int argc, char *argv[])
{

    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPTSTR          ptTempBuf1              = NULL;
    LPTSTR          ptTempBuf2              = NULL;
    LPBYTE          ptcsBuffer              = NULL;
    LPBYTE          ptcsReadBuffer          = NULL;
    LPBYTE          ptChangeBuf             = NULL;
    USHORT          cusNumSmallObjects      = 0;
    USHORT          cusMinSmallObjects      = 10;
    USHORT          cusMaxSmallObjects      = 20;
    ULONG           culNumBytes             = 0;
    ULONG           culIOBytes              = 0;
    ULONG           culWritten              = 0;
    ULONG           ulRandOffset            = 0; 
    ULONG           culRead                 = 0;
    ULONG           index                   = 0;
    DWORD           dwRootMode              = 0; 
    DWORD           dwBufCRC                = 0;
    DWORD           dwActCRC                = 0; 
    BOOL            fPass                   = TRUE; 
    LARGE_INTEGER   liZero;
    LARGE_INTEGER   liOffset;
    ULARGE_INTEGER  uliOffset;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_108"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_108 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt IStream operations on small objects.")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_108, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    // Adds a new stream to the root storage.

    if (S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        // Generate random # of small objects for test between  
        // cusMinSmallObjects and cusMaxSmallObjects

        usErr = pdgi->Generate(
                   &cusNumSmallObjects, 
                   cusMinSmallObjects,
                   cusMaxSmallObjects);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
    
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Random # of small objects to test is: %d"),
            cusNumSmallObjects));
    }

    // Loop for testing each small object

    while ((cusNumSmallObjects--) && (S_OK == hr))
    {
        // Pick a random size for this small object, generate data to 
        // write in memory, compute CRC for databuffer, and write it.

        usErr = pdgi->Generate(&culIOBytes, 0L, SMALL_OBJ_SIZE);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }     

        if (S_OK == hr)
        {
            culNumBytes = SMALL_OBJ_SIZE * 4 + 1;

            hr = GenerateRandomString(
                    pdgu, 
                    culNumBytes,
                    culNumBytes, 
                    &ptTempBuf1);
        }
 
        if (S_OK == hr)
        {
            // Let ptcsBuffer point to temporary buffer(for purpose of 
            // type casting, because IStream:Seek proceeds by BYTE)

            ptcsBuffer = (LPBYTE)ptTempBuf1;
            culNumBytes = culIOBytes;

            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsBuffer,
                    culNumBytes,
                    &dwBufCRC);
        }

        if (S_OK == hr)
        {
            hr = pvsnRootNewChildStream->Write(
                    ptcsBuffer,
                    culNumBytes,
                    &culWritten);
        }

        if (S_OK != hr)
        {            
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Write wasn't successful, hr=0x%lx."),
                hr));
        }
 
        if (S_OK == hr)
        {
		    LISet32(liZero, 0L);
		    hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        {  
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek wasn't successful, hr=0x%lx."),
                hr));
        }

        // read all data in the IStream(SMALL_OBJ_SIZE * 4) and compute CRC. 
        // We attempt to read SMALL_OBJ_SIZE * 4 instead of the number of bytes
        // actually written so we catch the case of extra data pegged onto the 
        // end of the stream. IStream::Read() returns the number of bytes 
        // actually read, which in this case should be culIOBytes. Next, 
        // compare r/w CRCs.

        if (S_OK == hr)
        {
            culNumBytes = SMALL_OBJ_SIZE * 4;
            ptcsReadBuffer = new BYTE[culNumBytes];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culNumBytes * sizeof(BYTE));

            hr = pvsnRootNewChildStream->Read(
                    ptcsReadBuffer,
                    culNumBytes,
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwActCRC);
        }

        // Compare CRCs 

        if (S_OK == hr)
        {
            if (dwBufCRC != dwActCRC)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Small object w/r mismatch before grow, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }         
        }
 
        // Delete temp buffer

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }
 
        // Pick a random offset somewhere in the small object to begin changing
        // data at. Position the IStream pointer to this location. Generate a
        // random number of bytes into the in-memory buffer starting at this
        // position, we generate enough new bytes to replace some that were
        // already in the IStream and to expand the IStream beyond small object
        // size.

        if (S_OK == hr)
        {
            usErr = pdgi->Generate(&ulRandOffset, 0L, culIOBytes);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }     
        }
 
        // Seek to the random offset

        if(S_OK == hr)
        {
            LISet32(liOffset, ulRandOffset);
            hr = pvsnRootNewChildStream->Seek(liOffset, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek wasn't successful, hr=0x%lx"),
                hr)); 
	    }

        // Generate random nubmer of bytes to grow

        if(S_OK == hr)
        {
            usErr = pdgi->Generate(
                    &culIOBytes, SMALL_OBJ_SIZE+1, SMALL_OBJ_SIZE*3);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }     

        if (S_OK == hr)
        {
            culNumBytes = culIOBytes;

            hr = GenerateRandomString(
                    pdgu, 
                    culNumBytes,
                    culNumBytes, 
                    &ptTempBuf2);
        }

        if (S_OK == hr)
        {
            ptChangeBuf = (LPBYTE)ptTempBuf2;

            for (index = 0; index < culIOBytes; index++)
            {
                ptcsBuffer[ulRandOffset+index] = ptChangeBuf[index];
            }
        }

        if (S_OK == hr)
        {
            // Calculate the new length of the object, and compute CRC for the
            // whole buffer

            culNumBytes = culIOBytes + ulRandOffset;

            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsBuffer,
                    culNumBytes,
                    &dwBufCRC);
        }

        if (S_OK == hr)
        {
            // Write growing data from seek pointer

            hr = pvsnRootNewChildStream->Write(
                    ptChangeBuf,
                    culIOBytes,
                    &culWritten);
        }

        if (S_OK != hr)
        {            
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Write wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
		    LISet32(liZero, 0L);
		    hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        {  
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek wasn't successful, hr=0x%lx."),
                hr));
        }
 
        // Read back the entire IStream, compute the CRC, and compare r/w CRCs
        // Commit the root docfile and repeat this step

        if (S_OK == hr)
        {
            culNumBytes = SMALL_OBJ_SIZE * 4;
            ptcsReadBuffer = new BYTE[culNumBytes];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culNumBytes * sizeof(BYTE));

            hr = pvsnRootNewChildStream->Read(
                    ptcsReadBuffer,
                    culNumBytes,
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwActCRC);
        }

        // Compare CRCs 

        if (S_OK == hr)
        {
            if (dwBufCRC != dwActCRC)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Small object w/r mismatch after grow, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }         
        }
 
        // Delete temp buffer

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        // Commit root. BUGBUG: Use random modes

        if (S_OK == hr)
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        }

        if (S_OK != hr)
        {             
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        { 
            memset(&liZero, 0, sizeof(LARGE_INTEGER));
		    hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL); 
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            ptcsReadBuffer = new BYTE[culNumBytes];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culNumBytes * sizeof(BYTE));

            hr = pvsnRootNewChildStream->Read(
                    ptcsReadBuffer,
                    culNumBytes,
                    &culRead);
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwActCRC);
        }

        // Compare CRCs 

        if (S_OK == hr)
        {
            if (dwBufCRC != dwActCRC)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream w/r mismatch after grow/commit, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }
         }
    
        // Delete temp buffers

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        // Pick a random small object size to set the IStream to. Shrink the 
        // IStream with SetSize. Compute the CRC for the in-memory data buffer
        // up to the new size of the IStream.

        if(S_OK == hr)
        {
            usErr = pdgi->Generate(&culIOBytes, 1L, SMALL_OBJ_SIZE);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }     

        if (S_OK == hr)
        { 
            ULISet32(uliOffset, culIOBytes);
            hr = pvsnRootNewChildStream->SetSize(uliOffset);
        }
	
        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::SetSize unsuccessful, hr=0x%lx"),
                hr));
        }
 
        if (S_OK == hr)
        { 
            culNumBytes = culIOBytes;  

            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsBuffer,
                    culNumBytes,
                    &dwBufCRC);
        }

        // Seek to beginning of IStream we just shrank, read the whole thing 
        // back, compute CRC, and compare r/w CRCs. Finally, commit the root 
        // docfile and repeat this step.

        if (S_OK == hr)
        {
		    LISet32(liZero, 0L);
		    hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        {  
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek wasn't successful, hr=0x%lx."),
                hr));
        }
 
        if (S_OK == hr)
        {
            culNumBytes = SMALL_OBJ_SIZE * 4;
            ptcsReadBuffer = new BYTE[culNumBytes];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culNumBytes * sizeof(BYTE));

            hr = pvsnRootNewChildStream->Read(
                    ptcsReadBuffer,
                    culNumBytes,
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwActCRC);
        }

        // Compare CRCs 

        if (S_OK == hr)
        {
            if (dwBufCRC != dwActCRC)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Small object w/r mismatch after shrink, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }         
        }
 
        // Delete temp buffer

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        // Commit root. BUGBUG: Use random modes

        if (S_OK == hr)
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        }

        if (S_OK != hr)
        {             
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        { 
            memset(&liZero, 0, sizeof(LARGE_INTEGER));
		    hr = pvsnRootNewChildStream->Seek(liZero, STREAM_SEEK_SET, NULL); 
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            ptcsReadBuffer = new BYTE[culNumBytes];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culNumBytes * sizeof(BYTE));

            hr = pvsnRootNewChildStream->Read(
                    ptcsReadBuffer,
                    culNumBytes,
                    &culRead);
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwActCRC);
        }

        // Compare CRCs 

        if (S_OK == hr)
        {
            if (dwBufCRC != dwActCRC)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream w/r mismatch after shrink/commit,hr=0x%lx"),
                    hr));

                fPass = FALSE;
            }
         }
    
        // Delete temp buffers 
        // ptcsBuffer and ptTempBuf1 point to the same memory chunk
        // ptChangeBuf and ptTempBuf2 point to the same memory chunk

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        if (NULL != ptcsBuffer)
        {
            delete []ptcsBuffer;
            ptcsBuffer = NULL;
            ptTempBuf1 = NULL;
        }

        if (NULL != ptTempBuf1)
        {
            delete []ptTempBuf1;
            ptTempBuf1 = NULL;
            ptcsBuffer = NULL;
        }

        if (NULL != ptTempBuf2)
        {
            delete []ptTempBuf2;
            ptTempBuf2 = NULL;
            ptChangeBuf = NULL;
        }

        // Reset IStream for next iteration of the loop

        if (S_OK == hr)
        {    
            ULISet32(uliOffset, 0L);
            hr = pvsnRootNewChildStream->SetSize(uliOffset);
        }
        
        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::SetSize unsuccessful, hr=0x%lx"),
                hr));   
        }
            
        if (S_OK == hr)
        {
            LISet32(liOffset, 0L);
            hr = pvsnRootNewChildStream->Seek(liOffset, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Seek unsuccessful, hr=0x%lx"),
                hr));   
        }
        
        if ((S_OK != hr) || (TRUE != fPass))
        {
            break;
        }            
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release Root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_108 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
              TEXT("Test variation STMTEST_108 failed, hr=0x%lx."),
              hr));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_108 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STMTEST_109 
//
// Synopsis:  Creates a root docfile with a random name. Creates an IStream in 
//       the root docfile and writes random number of bytes.  ILockRegion,
//       IUnlockRegion and Stat operations are attempted on stream.
//       The IStream and root are then released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    13-Aug-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: -part of common.cxx-
// 2.  Old name of test : 
//     New Name of test : STMTEST_109 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-109
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-109
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STMTEST-109
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: STMTEST-109
//
//-----------------------------------------------------------------------------

HRESULT STMTEST_109(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    ULONG           cb                      = 0;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    DWORD           dwRootMode              = 0;
    ULONG           cRandomMinSize          = 10;
    ULONG           cRandomMaxSize          = 100;
    BOOL            fPass                   = TRUE;
    LPMALLOC        pMalloc                 = NULL;
    STATSTG         statStg;
    ULARGE_INTEGER  uliOffset;
    ULARGE_INTEGER  uliBytes;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STMTEST_109"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_109 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt stm LockRegion/UnLockRegion/Stat ops")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STMTEST_109, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE, 
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
                hr));
        }
    }

    // Call VirtualStmNode::Write to create random bytes in the stream.  For
    // our test purposes, we generate a random string of size 1 to cb using
    // GenerateRandomString function.

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Write(
                ptcsBuffer,
                cb,
                &culWritten);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
                hr));
        }
    }

    // Attemp IStream::LockRegion.  Ole's implementation doesn't have this
    // function implemented and returns STG_E_INVALIDFUNCTION for the call.
 
    if (S_OK == hr)
    {
        ULISet32(uliOffset, 0);
        ULISet32(uliBytes, 20);

        hr =  pvsnRootNewChildStream->LockRegion(
                uliOffset,
                uliBytes,
                LOCK_WRITE);
  
        // Check STG_E_INVALIDFUNCTION returned as expected.
        if (STG_E_INVALIDFUNCTION == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::LockRegion return STG_E_INVALIDFUNCTION as exp")));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::LockRegion didn't return hr as exp, hr=0x%lx."),
                hr));

            hr = E_FAIL;
        }
    }

    // Attempt IStream::Stat and check the locks supported.

    // First get pMalloc that would be used to free up the name string from
    // STATSTG.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    if (S_OK == hr)
    {
        statStg.pwcsName = NULL;
        hr =  pvsnRootNewChildStream->Stat(&statStg, STATFLAG_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Stat")) ;
    }

    // Check that locks suupported are zero.

    if (S_OK == hr)
    {
        if(0 == statStg.grfLocksSupported)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Locks supported zero as exp.")));
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Locks supported not zero as exp.")));

            hr = E_FAIL;
        }
    }
	
	// Release resources

    if (( NULL != statStg.pwcsName) && ( NULL != pMalloc))
    {
        pMalloc->Free(statStg.pwcsName);
        statStg.pwcsName = NULL;
    }

    // Attempt IStream::UnlockRegion.  Ole's implementation doesn't have this
    // function implemented and returns STG_E_INVALIDFUNCTION for the call.
    
    if (S_OK == hr)
    {
        ULISet32(uliOffset, 0);
        ULISet32(uliBytes, 20);

        hr =  pvsnRootNewChildStream->UnlockRegion(
                uliOffset,
                uliBytes,
                LOCK_WRITE);

        // Check STG_E_INVALIDFUNCTION returned as expected.
        if (STG_E_INVALIDFUNCTION == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStm::UnlockRegion return STG_E_INVALIDFUNCTION as exp")));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::UnlockRegion didn't return hr as exp, hr=0x%lx."),
                hr));

            hr = E_FAIL;
        }
    }

    // Attempt IStream::Stat again and check the locks supported.

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Stat(&statStg, STATFLAG_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Stat")) ;
    }

    // Check that locks suupported are zero.

    if (S_OK == hr)
    {
        DH_ASSERT(statStg.type == STGTY_STREAM);

        if(0 == statStg.grfLocksSupported)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Locks supported zero as exp.")));
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("Locks supported not zero as exp.")));

            fPass = FALSE;
        }
    }

    // Release resources

    if ((NULL != statStg.pwcsName) && (NULL != pMalloc))
    {
        pMalloc->Free(statStg.pwcsName);
        statStg.pwcsName = NULL;
    }

     
	// Release stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx.")));
        }
    }

    // Commit root.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
   
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
        DH_LOG((LOG_PASS, TEXT("Test variation STMTEST_109 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation STMTEST_109 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Release pMalloc

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // Delete strings

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Delete temp buffer

    if(NULL != ptcsBuffer)
    {
        delete [] ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STMTEST_109 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\dll\dllinit.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       dllinit.cxx
//
//  Contents:   OLE storage base tests
//
//  Functions:  dllinit 
//              RunTests
//
//  History:    22-Jan-1998    SCousens     Created.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include "init.hxx"

extern int __cdecl main(int argc, char *argv[]);

#define STGBASE_INI "stgbase.ini"

HINSTANCE ghinstDll;


__declspec(dllexport) BOOL WINAPI DllMain( 
    HINSTANCE  hinstDLL, 
    DWORD  fdwReason,  
    LPVOID  lpvReserved)  
{ 
    if(fdwReason == DLL_PROCESS_ATTACH) 
    { 
        ghinstDll = hinstDLL; 
    } 
    return TRUE; 
} 

// read all the commandlines in from a .ini file and call main with them.
extern "C" __declspec(dllexport) void RunTest (void)
{
    HRESULT hr;
    FILE*   fp;
    CHAR    szLine[2048];
    int     count;
    int     argc;
    char  **argv;

    DH_FUNCENTRY (&hr, DH_LVL_TRACE1, TEXT("RunTests"));

    //Open the .ini file
    if (NULL == (fp = fopen (STGBASE_INI, "r")))
    {
        DH_TRACE ((DH_LVL_ERROR, 
                TEXT("Error opening stgbase.ini  Err=%ld"),
                GetLastError ()));
        MessageBox (NULL, 
                TEXT("Error Occured while opening stgbase.ini"), 
                TEXT("Sandbox Test"), 
                MB_ICONERROR | MB_ICONSTOP);
        return;
    }
    
    // read a line
    while (fgets (szLine, sizeof(szLine), fp) != NULL)
    {
        // safety check - if 1st char is alphanum assume ok.
        if (*szLine >= 'A' && *szLine <= 'Z' ||
            *szLine >= 'a' && *szLine <= 'z' ||
            *szLine >= '1' && *szLine <= '0')
        {
            // convert to argc argv and call main
            hr = CmdlineToArgs (szLine, &argc, &argv);
            DH_HRCHECK (hr, TEXT("CmdlineToArgs"));
            if (S_OK == hr)
            {
                hr = main (argc, argv);
                DH_HRCHECK (hr, TEXT("Call to Stgbase::main"));
            }

           // cleanup for arguments strings
           if (NULL != argv)
           {
               for (count=0; count<argc; count++)
                   delete argv[count];
               delete [] argv;
           }
        }
    }
    fclose (fp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\stgtests.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      stgtsts.cxx
//
//  Contents:  storage base tests basically pertaining to IStorage interface 
//
//  Functions:  
//
//  History:    10-July-1996     NarindK     Created.
//              27-Mar-97        SCousens    conversionified
//              06-Aug-97        FarzanaR    cleaned up tests for stress
//  BUGBUG : this file still requires to be cleaned up for stress.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

// externs
extern BOOL     g_fRevert;

//----------------------------------------------------------------------------
//
// Test:    STGTEST_100 
//
// Synopsis: A root docfile and child IStorage are created and committed.
//       The child IStorage is released and then destroyed.  The root is
//       then committed and a new child IStorage is created with the same
//       name as the original one.  The child IStorage and root docfile
//       are then released without committing.  The root docfile is then
//       reinstantiated.  The test attempts to instantiate a child
//       IStorage with the name used for the original one.  The test
//       verifies that no such IStorage exists because it should have been
//       deleted.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    10-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: DFCOMREL.CXX
// 2.  Old name of test : MiscCommitRelease Test 
//     New Name of test : STGTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-100
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: STGTEST-100
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt storage commit/release operations")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
       
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    //    Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,   
                dwStgMode,
                &pvcnRootNewChildStg);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
       
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Release child storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx.")));
        }
    }

    // Destroy child storage

    if (S_OK == hr)
    {
        hr = DestroyStorage(pTestVirtualDF, pvcnRootNewChildStg);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("DestroyStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("DestroyStorage unsuccessful, hr=0x%lx.")));
        }
    }

    // Commit root.  

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
       
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Add a child storage to root with same name

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,   
                dwStgMode,
                &pvcnRootNewChildStg);
        DH_HRCHECK(hr, TEXT("AddStorage")) ;

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }

    // Release root w/o commiting 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Release child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx.")));
        }
    }

    // Open root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // Open child storage that was deleted first time, and second time when
    // created wasn't committed. 
  
    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Open(
                NULL,
                dwStgMode, 
                NULL,
                0);

        if (STG_E_FILENOTFOUND == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful as exp,hr=0x%lx."),
                hr));
        }
        else
        {
            HRESULT hr2;
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Open should fail with STG_E_FILENOTFOUND, hr=0x%lx."),
                hr));
            fPass = FALSE; 

            // close it coz we found & opened it
            if (S_OK == hr)
            {
                hr2 = pvcnRootNewChildStg->Close();  
                DH_HRCHECK(hr2, TEXT("VirtualStgNode::Close")) ;
            }
        }
        hr = S_OK;
    }

    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_100 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_101 
//
// Synopsis: Creates a root docfile, stats, and verifies that the CLSID == NULL
//       and state bits = 0.  The test tries various random combinations
//       of setting state bits, changing class ids, committing changes
//       sometimes, reverting at others.  After every event, the test
//       checks to ensure that the state bits and class id are set
//       correctly.  It then creates a child IStorage and repeats the
//       above actions.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    14-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: DFSET.CXX
// 2.  Old name of test : MiscSetItems Test 
//     New Name of test : STGTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-101
//        /dfRootMode:dirReadWriteShEx  
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-101
//        /dfRootMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-3 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-101
//        /dfRootMode:xactReadWriteShDenyW 
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//
// BUGNOTE: Conversion: STGTEST-101
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          pRootNewChildStgName    = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    STATSTG         statStg;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt Misc setting state bits/class id'")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Call Stat on  root.

    if (S_OK == hr)
    {
        statStg.grfStateBits = 0;
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    	if (S_OK == hr)
    	{
           DH_TRACE((
           	DH_LVL_TRACE1,
           	TEXT("VirtualCtrNode::Stat completed successfully.")));
    	}
    	else
    	{
           DH_TRACE((
           	DH_LVL_TRACE1,
           	TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
           	hr));
    	}

        // Check CLSID from STATSTG structure

        if((S_OK == hr) && (IsEqualCLSID(statStg.clsid, CLSID_NULL)))
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Root DocFile has CLSID_NULL as expected.")));

        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Root DocFile doesn't have CLSID_NULL unexpectedly.")));
    
            fPass = FALSE;
        }

        // Check state bits from STATSTG structure.

        if((S_OK == hr) && (0 == statStg.grfStateBits))
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Root DocFile has grfStateBits equal to 0 as expected.")));

        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Root DocFile doesn't have grfStateBits = 0 unexpectedly.")));
    
            fPass = FALSE;
        }
    
    }


    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
               hr));
        }
    }
   

    // Call SetItemsInStorage on Root

    if (S_OK == hr)
    {
        hr = SetItemsInStorage(pVirtualDFRoot, pdgi);

        DH_HRCHECK(hr, TEXT("SetItemsInStorage")) ;
    }

    //    Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,   
                dwStgMode,
                &pvcnRootNewChildStg);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }


    // Call Stat on  new child storage.

    if (S_OK == hr)
    {
        statStg.grfStateBits = 0;
        hr = pvcnRootNewChildStg->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
               hr));
        }
        // Check CLSID from STATSTG structure

        if((S_OK == hr) && (IsEqualCLSID(statStg.clsid, CLSID_NULL)))
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Child Storage has CLSID_NULL as expected.")));

        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Child storage doesn't have CLSID_NULL unexpectedly.")));
    
            fPass = FALSE;
        }

        // Check state bits from STATSTG structure.

        if((S_OK == hr) && (0 == statStg.grfStateBits))
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Child Storage has grfStateBits equal to 0 as expected.")));

        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Child Storage doesn't have grfStateBits=0 unexpectedly.")));
    
            fPass = FALSE;
        }
    }



    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
               hr));
        }
    }
   

    // Call SetItemsInStorage on Child storage

    if (S_OK == hr)
    {
        hr = SetItemsInStorage(pvcnRootNewChildStg, pdgi);

        DH_HRCHECK(hr, TEXT("SetItemsInStorage")) ;
    }

    // Release child storage.  

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Release root.  

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr)  && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_101 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_102 
//
// Synopsis: The test attempts various illegitimate operations regarding the
//           renaming and deletion of contained IStorages. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    10-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: IRENDEST.CXX
// 2.  Old name of test : IllegitRenDest Test 
//     New Name of test : STGTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-102
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx /labmode 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-102
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /labmode 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-102
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//        /labmode 
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//
// BUGNOTE: Conversion: STGTEST-102
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg0   = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg1   = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    LPTSTR          ptszNonExist            = TEXT("NonExistStg");
    LPTSTR          ptszNonExistNew         = TEXT("NonExistStgNew");
    LPOLESTR        poszNonExist            = NULL;
    LPOLESTR        poszNonExistNew         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    ULONG           i                       = 0;
    LPSTORAGE       pStgRoot                = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt illegitimate storage rename/del ops")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // create two new IStorages and save their names.

    for (i=0;i<2;i++)
    {
        // Adds a new storage to the root storage.

        if(S_OK == hr)
        {
            // Generate random name for storage

            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &pRootNewChildStgName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if(S_OK == hr)
        {
            hr = AddStorage(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootNewChildStgName,   
                    dwStgMode,
                    &pvcnRootNewChildStg);

            DH_HRCHECK(hr, TEXT("AddStorage")) ;

            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::AddStorage completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::AddStorage not successful, hr=0x%lx."),
                    hr));
            }
        }

        // Commit root. 

        if(S_OK == hr)
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
       
            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Commit completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                    hr));
            }
        }

        // Release child storage

        if (S_OK == hr)
        {
            hr = pvcnRootNewChildStg->Close();

            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Close completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx.")));
            }
        }

        if(S_OK == hr)
        {
            if(i == 0)
            {
                pvcnRootNewChildStg0 = pvcnRootNewChildStg;
            }
            else
            {
                pvcnRootNewChildStg1 = pvcnRootNewChildStg;
            }
        }

        // Delete temp strings

        if(NULL != pRootNewChildStgName)
        {
            delete pRootNewChildStgName;
            pRootNewChildStgName = NULL;
        }
    
        // Break out of loop under failure conditions
        
        if(S_OK != hr)
        {
            break;
        }
    }

    // verify that the IStorages have been created by attempting to
    // instantiate them
    // Break out of loop under failure conditions
    for (i=0; i<2 && S_OK == hr; i++)
    {
        if(i == 0)
        {
           pvcnRootNewChildStg = pvcnRootNewChildStg0;
        }
        else
        {
           pvcnRootNewChildStg = pvcnRootNewChildStg1;
        }

        hr = pvcnRootNewChildStg->Open(
                    NULL,
                    dwStgMode | STGM_FAILIFTHERE,
                    NULL,
                    0);

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }

        // Release child storage

        if (S_OK == hr)
        {
            hr = pvcnRootNewChildStg->Close();

            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Close completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx.")));
            }
        }
    }

    // Attempt to rename the storage to a name that already exists.

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStg0->Rename(
                pvcnRootNewChildStg1->GetVirtualCtrNodeName()); 
        if(STG_E_ACCESSDENIED == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename failed as exp, hr = 0x%lx."),
                hr));
         
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename didn't fail as exp, hr = 0x%lx."),
                hr));
        
            fPass = FALSE;
        }
    }


    // Attempt to rename an element that doesn't exist.

    // Covert the names to OLECHAR

    if(S_OK == hr)
    {
        // Convert test name to OLECHAR

        hr = TStringToOleString(ptszNonExist, &poszNonExist);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Convert test name to OLECHAR

        hr = TStringToOleString(ptszNonExistNew, &poszNonExistNew);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // First get IStorage pointer for root

    if(S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();  

        DH_ASSERT(NULL != pStgRoot); 
    
        hr = pStgRoot->RenameElement(
                poszNonExist,
                poszNonExistNew); 
        if(STG_E_FILENOTFOUND == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Rename failed as exp, hr = 0x%lx."),
                hr));
         
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Rename didn't fail as exp, hr = 0x%lx."),
                hr));
        
            fPass = FALSE;
        }
    }


    // Attempt to delete an element that doesn't exist.

    if(S_OK == hr)
    {
        hr = pStgRoot->DestroyElement(poszNonExist);
        if(STG_E_FILENOTFOUND == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Destroy failed as exp, hr = 0x%lx."),
                hr));
         
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Destroy didn't fail as exp, hr = 0x%lx."),
                hr));
        
            fPass = FALSE;
        }
    }


    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_102 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != poszNonExist)
    {
        delete poszNonExist;
        poszNonExist = NULL;
    }

    if(NULL != poszNonExistNew)
    {
        delete poszNonExistNew;
        poszNonExistNew = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_103 
//
// Synopsis: A random docfile with some storages and some streams is generated.
//       The root docfile is commited and closed.  
//       The root docfile is then instantiated & an enumerator is obtained.  For
//       each object found, the object is renamed to a new name but the old
//       name is saved.  An attempt is made to instantiate the object with
//       the old name, this attempt should fail.  The renamed object is then
//       instantiated with the new name to verify that the rename worked.  The
//       object is then destroyed.  This occurs for every object returned by
//       the enumerator.  The root docfile is then committed, the enumerator
//       is released, and a new enumerator is obtained.  The root docfile
//       is enumerated to verify that no elements exist. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    11-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LDRENDES.CXX
// 2.  Old name of test : LegitRenDestNormal Test 
//     New Name of test : STGTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-103
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-103
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-103
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//
// BUGNOTE: Conversion: STGTEST-103
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPENUMSTATSTG   penumWalk               = NULL;
    LPMALLOC        pMalloc                 = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgChild               = NULL;
    LPSTREAM        pStmChild               = NULL;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;
    BOOL            fRenamedOK              = TRUE;
    LPTSTR          ptszNewName             = NULL;
    LPOLESTR        poszNewName             = NULL;
    LPTSTR          ptszOldName             = NULL;
    LPOLESTR        poszOldName             = NULL;
    STATSTG         statStg;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_103 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt legit rename/deleted ops on stgs/stms")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_103, Access mode: %lx"),
            dwRootMode));
    }

    // Commit substorages BUGBUG df already commited

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
               hr));
        }
    }
   

    // Release root and all substorages/streams too 

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Release root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Reopen the root.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Call EnumElements to get a enumerator 

    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements(0, NULL, 0, &penumWalk);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements passed as expected")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements unexpectedly failed hr=0x%lx"),
                hr));
        }
    }


    // First get pMalloc that would be used to free up the name string from
    // STATSTG.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    if(S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();  

        DH_ASSERT(NULL != pStgRoot); 

        // Get DG_STRING object pointer

        if (S_OK == hr)
        {
            pdgu = pTestVirtualDF->GetDataGenUnicode();

            DH_ASSERT(NULL != pdgu) ;
        }
    }

    while(S_OK == hr && S_OK == penumWalk->Next(1, &statStg, NULL))
    {
        // loop to rename object until a unique name is found, typically
        // this will happen the first time and we'll fall out of the loop,
        // but in the event of a duplicate name we have to keep trying.

        fRenamedOK = FALSE;

        while ((fRenamedOK == FALSE) && (S_OK == hr))
        {
            if(S_OK == hr)
            {
                // Generate random name for the element 

                hr = GenerateRandomName(
                        pdgu,
                        MINLENGTH,
                        MAXLENGTH,
                        &ptszNewName);

                DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
            }

            if(S_OK == hr)
            {
                // Convert above name to OLECHAR
                hr = TStringToOleString(ptszNewName, &poszNewName);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            // Convert old name as retrieved from STATSTG structure to OLECHAR
            // by first converting it to TSTR and then to OLECHAR.

            if(S_OK == hr)
            {
                // Convert old name statStg.pwcsName to TCHAR
                hr = OleStringToTString(statStg.pwcsName, &ptszOldName);

                DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
            }

            if(S_OK == hr)
            {
                // Now Convert old name to OLECHAR
                hr = TStringToOleString(ptszOldName, &poszOldName);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                // Rename the element to new name
        
                hr = pStgRoot->RenameElement(
                        poszOldName,
                        poszNewName); 
            }

            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::RenameElement successful as exp.")));
                
                fRenamedOK = TRUE;
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::RenameElement failed unexp, hr = 0x%lx."),
                    hr));

                break;
            }
        } // ((fRenamedOK == FALSE) && (S_OK == hr))
   
        // verify that the rename worked by first trying to instantiate
        // the object with the original name (this should fail) and
        // then instantiate it with the new name.

        if((S_OK == hr) && (statStg.type == STGTY_STORAGE))
        {
            hr = pStgRoot->OpenStorage(
                    poszOldName,
                    NULL,
                    dwStgMode,
                    NULL,
                    0,
                    &pStgChild);

            if((NULL == pStgChild) && (STG_E_FILENOTFOUND == hr))
            {
                DH_TRACE((
                   DH_LVL_TRACE1,
                   TEXT("Instantiation with old name fail exp, hr = 0x%lx "),
                   hr));

                hr = S_OK;
            }
            else
            {
                DH_TRACE((
                   DH_LVL_TRACE1,
                   TEXT("Instantiation with old name pass unexp, hr = 0x%lx"),
                   hr));

                hr = S_FALSE;
            }
        
            if(S_OK == hr)  
            {
                hr = pStgRoot->OpenStorage(
                        poszNewName,
                        NULL,
                        dwStgMode,
                        NULL,
                        0,
                        &pStgChild);

                DH_HRCHECK(hr, TEXT("IStorage::OpenStorage")) ;
                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Instantiation with new name pass as exp")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Instantiation with new name fail unexp, hr=0x%lx"),
                        hr));
                }
            }
            

            // Release the element
            
            if(NULL != pStgChild)
            {
                ulRef = pStgChild->Release();
                DH_ASSERT(0 == ulRef);
                pStgChild = NULL;
            }
        } // ((S_OK == hr) && (statStg.type == STGTY_STORAGE))
        
        if ((S_OK == hr) && (statStg.type == STGTY_STREAM))
        {
            //element is a stream

            hr = pStgRoot->OpenStream(
                    poszOldName,
                    NULL,
                    STGM_READ | STGM_SHARE_EXCLUSIVE,
                    0,
                    &pStmChild);

            if((NULL == pStmChild) && (STG_E_FILENOTFOUND == hr))
            {
                DH_TRACE((
                   DH_LVL_TRACE1,
                   TEXT("Instantiation with old name fail exp, hr = 0x%lx "),
                   hr));

                hr = S_OK;
            }
            else
            {
                DH_TRACE((
                   DH_LVL_TRACE1,
                   TEXT("Instantiation with old name pass unexp,hr = 0x%lx "),
                   hr));

                hr = S_FALSE;
            }
        
            if(S_OK == hr)  
            {
                hr = pStgRoot->OpenStream(
                        poszNewName,
                        NULL,
                        STGM_READ | STGM_SHARE_EXCLUSIVE,
                        0,
                        &pStmChild);

                DH_HRCHECK(hr, TEXT("IStorage::OpenStream")) ;
                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Instantiation with new name pass as exp")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Instantiation with new name fail unexp, hr=0x%lx"),
                        hr));
                }
            }
            

            // Release the element
            
            if(NULL != pStmChild)
            {
                ulRef = pStmChild->Release();
                DH_ASSERT(0 == ulRef);
                pStmChild = NULL;
            }
        } // if ((S_OK == hr) && (statStg.type == STGTY_STREAM))

        // Destroy the element

        if(S_OK == hr)  
        {
            hr = pStgRoot->DestroyElement(poszNewName);

            DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::DestoryElement succeeded as expected.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::DestoryElement fail unexp, hr = 0x%lx."),
                    hr));
            }
        }


        // Release resources

        if ( NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if(NULL != ptszNewName)
        {
            delete ptszNewName;
            ptszNewName = NULL;
        }

        if(NULL != poszNewName)
        {
            delete poszNewName;
            poszNewName = NULL;
        }

        if(NULL != ptszOldName)
        {
            delete ptszOldName;
            ptszOldName = NULL;
        }

        if(NULL != poszOldName)
        {
            delete poszOldName;
            poszOldName = NULL;
        }
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }
   

    // Release penumWalk

    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT(0 == ulRef);
        penumWalk = NULL;
    }

    // Call EnumElements to get a enumerator again

    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements(0, NULL, 0, &penumWalk);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements passed as expected")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements unexpectedly failed hr=0x%lx"),
                hr));
        }
    }


    // Try to call next on it.  All elements should have been deleted

    while(S_OK == hr && S_OK == penumWalk->Next(1, &statStg, NULL))
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("All elements should have been deleted.")));
        
        fPass = FALSE;
    }

    // Release root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Release pMalloc

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // Release penumWalk

    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT(0 == ulRef);
        penumWalk = NULL;
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_103 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_104 
//
// Synopsis: This test first creates a root docfile.  Two child IStorages
//       are created inside of it.
//       Child IStorage A is renamed to name C, child IStorage B is
//       renamed to name A, child IStorage C (was originally A) is
//       renames to B.  The root docfile is committed.  Verify
//       proper renaming and no errors.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    11-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LDRENSWP.CXX
// 2.  Old name of test : LegitRenDestSwap Test 
//     New Name of test : STGTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-104
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-104
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-104
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//
// BUGNOTE: Conversion: STGTEST-104
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    VirtualCtrNode  *pvcnRootNewChildStg0   = NULL;
    LPTSTR          pRootNewChildStgName0   = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg1   = NULL;
    LPTSTR          pRootNewChildStgName1   = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_104 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt rename swap operations on child stgs")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_104, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Adds first new child storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for first child storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootNewChildStgName0);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName0,   
                dwStgMode,
                &pvcnRootNewChildStg0);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }


    // Adds second new child storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for first child storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootNewChildStgName1);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName1,   
                dwStgMode,
                &pvcnRootNewChildStg1);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }


    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
               hr));
        }
    }
   

    // Can't rename open storages so release the child storages

    // Release first child storage.

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg0->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx.")));
        }
    }


    // Release second child storage.

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg1->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx.")));
        }
    }


    // Attempt to rename the first child storage to RootDocFile's name

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("pvcnRootNewChildStg0's old name, %s."),
            pvcnRootNewChildStg0->GetVirtualCtrNodeName()));

        hr = pvcnRootNewChildStg0->Rename(
                pVirtualDFRoot->GetVirtualCtrNodeName()); 
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename passed as exp, new name %s."),
                pvcnRootNewChildStg0->GetVirtualCtrNodeName()));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename failed unexp, hr = 0x%lx."),
                hr));
        }
    }


    // Attempt to rename the second child storage to first child stg's name

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("pvcnRootNewChildStg1's old name, %s."),
            pvcnRootNewChildStg1->GetVirtualCtrNodeName()));

        hr = pvcnRootNewChildStg1->Rename(pRootNewChildStgName0); 
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename passed as exp, new name %s."),
                pvcnRootNewChildStg1->GetVirtualCtrNodeName()));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename failed unexp, hr = 0x%lx."),
                hr));
        }
    }


    // Attempt to rename third child storage (was originally first child 
    // storage) to second child stg's name

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("pvcnRootNewChildStg0's old name, %s."),
            pvcnRootNewChildStg0->GetVirtualCtrNodeName()));

        hr = pvcnRootNewChildStg0->Rename(pRootNewChildStgName1); 
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename passed as exp, new name %s."),
                pvcnRootNewChildStg0->GetVirtualCtrNodeName()));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Rename failed unexp, hr = 0x%lx."),
                hr));
        }
    }


    // Release root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_104 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStgName0)
    {
        delete pRootNewChildStgName0;
        pRootNewChildStgName0 = NULL;
    }

    if(NULL != pRootNewChildStgName1)
    {
        delete pRootNewChildStgName1;
        pRootNewChildStgName1 = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_105 
//
// Synopsis: A random docfile with random number of storages and streams is
//          generated.  Root is committed and closed.
//          The root docfile is instantiated and the CRC is computed for the
//          entire docfile.  A new root docfile with a random name is then
//          created and a CRC is generated for the empty root docfile.  An
//          enumerator is obtained on the source docfile, each element returned
//          is MoveElementTo()'d the destination docfile.  If fRevertAfterMove
//          equals TRUE, the dest is reverted, else the dest is committed.
//          The dest is released and reinstantiated and CRC'd.  If the dest
//          was reverted, the CRC is compared against the empty CRC for a match.
//          Otherwise, we compare against the original root docfile CRC.  The
//          original file is CRC'd again to verify that STGMOVE_COPY didn't
//          move the elements from orginal position but copied them, the CRC
//          now computed should match with the one calculated originally. 
//
//          This tests differs from STGTEST-107 in the way that MoveElementTo
//          is called with STGMOVE_COPY flag instead of STGMOVE_MOVE.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    12-July-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: LVROOT.CXX
// 2.  Old name of test : LegitMoveDFToRootDF Test 
//     New Name of test : STGTEST_105 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-105
//        /dfRootMode:dirReadWriteShEx  
//     b. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-105
//        /dfRootMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-105
//        /dfRootMode:xactReadWriteShDenyW 
//     d. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-105
//        /dfRootMode:xactReadWriteShEx /frevertaftermove
//     e. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-105
//        /dfRootMode:xactReadWriteShDenyW /frevertaftermove 
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//     BUGBUG: dont have /stdblock up yet. -scousens
//     BUGBUG: note this fails sometimes for nssfiles need to dig deeper -scousens working seed=21590084
//
//  In case of direct mode, the flag revertaftermove is not meaningful since
//  changes are always directly written to disk doc file.
//
// BUGNOTE: Conversion: STGTEST-105
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_105(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          ptszRootNewDocFile      = NULL;
    LPOLESTR        poszRootNewDocFile      = NULL;
    DWORD           dwRootMode              = 0;
    LPSTORAGE       pStgRoot1               = NULL;
    LPSTORAGE       pStgRoot2               = NULL;
    LPSTORAGE       pStgRoot11              = NULL;
    ULONG           ulRef                   = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    DWORD           dwCRC3                  = 0;
    DWORD           dwCRC4                  = 0;
    LPMALLOC        pMalloc                 = NULL;
    LPENUMSTATSTG   penumWalk               = NULL;
    LPTSTR          ptszElementName         = NULL;
    LPOLESTR        poszElementName         = NULL;
    BOOL            fPass                   = TRUE;
    STATSTG         statStg;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_105"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_105 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt MoveElementTo-STGMOVE_COPY operations")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_105, Access mode: %lx"),
            dwRootMode));
    }

    // Commit substorages 

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
               hr));
        }
    }
   

    // Release root and all substorages/streams too 

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Open the root only

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Calculate CRC for entire DocFile without the RootDocfile name

    if(S_OK == hr)
    {
        pStgRoot1 = pVirtualDFRoot->GetIStoragePointer();  

        DH_ASSERT(NULL != pStgRoot1); 

        hr = CalculateCRCForDocFile(pStgRoot1, VERIFY_EXC_TOPSTG_NAME, &dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }


    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    if(S_OK == hr)
    {
        // Generate random name for first child storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &ptszRootNewDocFile);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(ptszRootNewDocFile, &poszRootNewDocFile);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if (S_OK == hr)
    {
        hr = StgCreateDocfile(
                poszRootNewDocFile,
                dwRootMode,
                0,
                &pStgRoot2);

        DH_HRCHECK(hr, TEXT("StgCreateDocFile")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgCreateDocfile successful as exp.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgCreateDocfile not successful, hr=0x%lx."),
                hr));
        }
    }


    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(pStgRoot2, VERIFY_EXC_TOPSTG_NAME, &dwCRC2);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Call EnumElements to get a enumerator for first DocFile

    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements(0, NULL, 0, &penumWalk);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements passed as expected")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements unexpectedly failed hr=0x%lx"),
                hr));
        }
    }


    // First get pMalloc that would be used to free up the name string from
    // STATSTG.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    while((S_OK == hr) && (S_OK == penumWalk->Next(1, &statStg, NULL)))
    {
        if(S_OK == hr)
        {
            // Convert statStg.pwcsName to TCHAR
            hr = OleStringToTString(statStg.pwcsName, &ptszElementName);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            // Now Convert old name to OLECHAR
            hr = TStringToOleString(ptszElementName, &poszElementName);

            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        if(S_OK == hr)
        {
            // Move the element to second DocFile

            hr = pStgRoot1->MoveElementTo(
                    poszElementName,
                    pStgRoot2,
                    poszElementName,
                    STGMOVE_COPY);
    
            DH_HRCHECK(hr, TEXT("IStorage::MoveElementTo")) ;
            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::MoveElementTo passed as expected")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::MoveElementTo unexpectedly failed hr=0x%lx"),
                    hr));
            }
        }


        // Release resources

        if ( NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if(NULL != ptszElementName)
        {
            delete ptszElementName;
            ptszElementName = NULL;
        }

        if(NULL != poszElementName)
        {
            delete poszElementName;
            poszElementName = NULL;
        }

        // Break out of loop in error case

        if(S_OK != hr)
        {
            break;
        }
    }
 
    // Commit or Revert the second docfile as the case may be. 

    if((S_OK == hr) && (FALSE == g_fRevert))
    {
        hr = pStgRoot2->Commit(STGC_DEFAULT);

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }
    else
    if((S_OK == hr) && (TRUE == g_fRevert))
    {
        hr = pStgRoot2->Revert();

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Revert completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Revert unsuccessful, hr=0x%lx."),
                hr));
        }
    }
   
    // Close the second DocFile

    if(NULL != pStgRoot2)
    {
        ulRef = pStgRoot2->Release();
        DH_ASSERT(0 == ulRef);
        pStgRoot2 = NULL;
    }

    // Open it again and do StgIsStorageFile to verify.

    if(S_OK == hr)
    {
        hr = StgOpenStorage(
                poszRootNewDocFile,
                NULL,
                dwRootMode,
                NULL,
                0,
                &pStgRoot2);

       DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorage completed successfully.")));

            DH_ASSERT(NULL != pStgRoot2);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorage unsuccessful, hr=0x%lx."),
                hr));
        }
    }
        

    // Do StgIsStorageFile to verify

    if(S_OK == hr)
    {
        hr = StgIsStorageFile(poszRootNewDocFile);

        DH_HRCHECK(hr, TEXT("StgIsStorageFile")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorageFile completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorageFile unsuccessful, hr=0x%lx."),
                hr));
        }
    }
        

    // Calculate CRC on this second Root DocFile.

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(pStgRoot2, VERIFY_EXC_TOPSTG_NAME, &dwCRC3);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        // Compare CRC's

        if((S_OK == hr) && ( FALSE == g_fRevert))
        {
            if (dwCRC3 == dwCRC1)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC's for docfile1 & docfile2 after commit match.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC for docfile1 & docfile2 aftr commit don't match")));
            
                fPass = FALSE;
            }
        }
        else
        if((S_OK == hr) && ( TRUE == g_fRevert))
        {
            if (dwCRC3 == dwCRC2)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC's for docfile2 before & after Revert match.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC for docfile2 before & after Revert don't match")));
            
                fPass = FALSE;
            }
        }
    }


    // Close the second DocFile

    if(NULL != pStgRoot2)
    {
        ulRef = pStgRoot2->Release();
        DH_ASSERT(0 == ulRef);
        pStgRoot2 = NULL;
    }
        
    // Release penumWalk

    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT(0 == ulRef);
        penumWalk = NULL;
    }

    // Release root  

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Open the Root DocFile again to verify the STGMOVE_COPY flags specified
    // while doing MoveElementTo

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Now get the CRC again on the original DocFile to verify that flag
    // STGMOVE_COPY copied the elements and not moved them, so this CRC
    // should match with CRC originally  obtained on this DocFile.

    if(S_OK == hr)
    {
        pStgRoot11 = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRoot11);

        hr = CalculateCRCForDocFile(pStgRoot11, VERIFY_EXC_TOPSTG_NAME,&dwCRC4);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        if(S_OK == hr)
        {
            if (dwCRC4 == dwCRC1)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC's for original docfle match after move as copy.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC for original DF don't match after move as copy.")));
            
                fPass = FALSE;
            }
        }
    }


    // Release the first root docfile 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr)  && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_105 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_105 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Release pMalloc

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // Delete strings

    if(NULL != poszRootNewDocFile)
    {
        delete poszRootNewDocFile;
        poszRootNewDocFile = NULL;
    }

    // Delete the second docfile on disk

    if((S_OK == hr) && (NULL != ptszRootNewDocFile))
    {
        if(FALSE == DeleteFile(ptszRootNewDocFile))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != ptszRootNewDocFile)
    {
        delete ptszRootNewDocFile;
        ptszRootNewDocFile = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_105 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:  STGTEST_106 
//
// Synopsis: This test first creates a root docfile.  A child IStorage is
//        then created with STGM_DENY_WRITE set.  An IStream is created
//        inside the child IStorage and a random number of bytes are
//        written to it.  The stream is released, the child and root
//        IStorages are committed, and the child IStorage is released.
//        The child IStorage is instantiated in STGM_TRANSACTED mode
//        and then released.  A count of the files in the current directory
//        is then made and saved.  The child IStorage is then instantiated
//        in STGM_TRANSACTED | STGM_DENY_WRITE mode and another count is
//        made.  We then verify that only 1 scratch file was created,
//        indicating that for STGM_DENY_WRITE mode, no copy is made of
//        the instantiated IStorage.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  26-July-1996     NarindK     Created.
//
// Notes:   THIS TEST IS NOT APPLICABLE WITH PRESENT STORAGE CODE, PRESENT
//          ONLY FOR DOCUMENTATION/REFERENCE PURPOSES.  BY DESIGN, THE PRESENT
//          DOCFILE REQUIRES THAT ALL SUBSTORAGES/SUBSTREAMS BE CREATED/OPENED 
//          WITH STGM_SHARE_EXCLUSIVE FLAG. 
//
// This test runs in transacted modes
//
// New Test Notes:
// 1.  Old File: LITWWDW.CXX
// 2.  Old name of test : LegitInstRootTwwDenyWrite test 
//     New Name of test : STGTEST_106 
// 3.  To run the test, do the following at command prompt. 
//       stgbase /t:STGTEST-106
// 4.  To run for conversion, add /dfStgType:conversion to the above
// 5.  To run for nssfile, add /dfStgType:nssfile to the above
//
// BUGNOTE: Conversion: STGTEST-106
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_106(ULONG ulSeed)
{
#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!STGTEST_106 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    VirtualStmNode  *pvsnNewChildStream     = NULL;
    DWORD           dwRootMode              = STGM_READWRITE | STGM_TRANSACTED;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          ptszRootName            = NULL;
    LPTSTR          ptszRootNewChildStgName = NULL;
    LPTSTR          ptszStreamName          = NULL;
    BOOL            fPass                   = TRUE;
    LPTSTR          ptcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    ULONG           culFilesInDirectory     = 0;
    ULONG           cb                      = 0;
    DWCRCSTM        dwMemCRC;
    DWCRCSTM        dwActCRC;
    CDFD            cdfd;

    dwMemCRC.dwCRCSum = dwActCRC.dwCRCSum = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_106"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_106 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt operations on child storage in transacted mode.")));

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        pdgu = new(NullOnFail) DG_STRING(ulSeed);

        if (NULL == pdgu)
        {
           hr = E_OUTOFMEMORY;
        }
        else
        {
            //want to create only one seed. Once that has been done, 
            //use what we created from now on.
            ulSeed = pdgu->GetSeed ();
        }
    }
        
    // Generate RootDocFile name

    if(S_OK == hr)
    {
        hr=GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &ptszRootName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = ulSeed;
        cdfd.dwRootMode   = dwRootMode | STGM_CREATE;

        hr = CreateTestDocfile (&cdfd, 
                ptszRootName,
                &pVirtualDFRoot,
                &pTestVirtualDF,
                &pTestChanceDF);

        DH_HRCHECK(hr, TEXT("CreateTestDocfile"));
    }

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    //    Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &ptszRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                ptszRootNewChildStgName,
                dwRootMode | STGM_SHARE_DENY_WRITE | STGM_FAILIFTHERE,
                &pvcnRootNewChildStg);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }


    // Now add a stream to this child storage

    // Generate random name for stream

    if(S_OK == hr)
    {
        hr=GenerateRandomName(pdgu, MINLENGTH,MAXLENGTH, &ptszStreamName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, 1, USHRT_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pvcnRootNewChildStg,
                ptszStreamName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
                hr));
        }
    }


    // Write random data into stream

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if(S_OK == hr)
    {
        hr = pvsnNewChildStream->Write(
                ptcsBuffer, 
                cb, 
                &culWritten);

        DH_HRCHECK(hr, TEXT("IStream::Write")) ;
    }

    // Calculate the CRC for stream name and data

    if(S_OK == hr)
    {
        hr = CalculateInMemoryCRCForStm(
                pvsnNewChildStream,
                ptcsBuffer,
                cb,
                &dwMemCRC);

        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStm")) ;
    }

    // Release stream

    if (S_OK == hr)
    {
        hr = pvsnNewChildStream->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx.")));
        }
    }


    // Now do a commit of child storage with STGC_ONLYIFCURRENT.

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Commit(STGC_ONLYIFCURRENT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Now do a commit of root storage with STGC_ONLYIFCURRENT.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_ONLYIFCURRENT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Close the child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Open the child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Open(
                NULL, 
                dwRootMode | STGM_SHARE_EXCLUSIVE, 
                NULL, 
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Close the child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // count number of files in directory

    if (S_OK == hr)
    {
        culFilesInDirectory = CountFilesInDirectory(WILD_MASK);
    }

    // Open the with STGM_SHARE_DENY_WRITE

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Open(
                NULL, 
                dwRootMode | STGM_SHARE_DENY_WRITE, 
                NULL, 
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Check number of files

    if(S_OK == hr)
    {
        if((culFilesInDirectory + 1) != CountFilesInDirectory(WILD_MASK))
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT(">1 scratch file unexp STGM_SHARE_DENY_WRITE inst.")));

            hr = S_FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("1 scratchfile as exp STGM_SHARE_DENY_WRITE inst")));

        }
    }

    // OpenStream

    if (S_OK == hr)
    {
        hr = pvsnNewChildStream->Open(
                NULL, 
                dwRootMode | STGM_SHARE_DENY_WRITE, 
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Read stream, CRC and verify

    if(S_OK == hr)
    {
        hr = ReadAndCalculateDiskCRCForStm(pvsnNewChildStream,&dwActCRC);

        DH_HRCHECK(hr, TEXT("ReadAndCalculateDiskCRCForStm")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("ReadAndCalculateDiskCRCForStm function successful.")));

            if(dwActCRC.dwCRCSum == dwMemCRC.dwCRCSum)
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's for pvsnNewChildStream match.")));

            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC's for pvsnNewChildStream don't match.")));

                fPass = FALSE;
            }
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("ReadAndCalculateDiskCRCForStm not successful, hr=0x%lx."),
                hr));
        }
    }


    // Close the stream in child storage 

    if (S_OK == hr)
    {
        hr = pvsnNewChildStream->Close();

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Close the child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Close the root 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)           
    {
        DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_106 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_106 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup

    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete DataGen object
    
    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Delete temp string

    if(NULL != ptszRootNewChildStgName)
    {
        delete ptszRootNewChildStgName;
        ptszRootNewChildStgName = NULL;
    }

    if(NULL != ptszStreamName)
    {
        delete ptszStreamName;
        ptszStreamName = NULL;
    }

    if(NULL != ptcsBuffer)
    {
        delete ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Delete temp string

    if(NULL != ptszRootName)
    {
        delete ptszRootName;
        ptszRootName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_106 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
#endif //_MAC
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_107 
//
// Synopsis: A random docfile with random number of storages and streams is
//          generated.  Root is committed and closed.
//          The root docfile is instantiated and the CRC is computed for the
//          entire docfile.  A new root docfile with a random name is then
//          created and a CRC is generated for the empty root docfile.  An
//          enumerator is obtained on the source docfile, each element returned
//          is MoveElementTo()'d with STGM_MOVE to the destination docfile.  
//          If fRevertAfterMove equals TRUE, the dest is reverted, else the 
//          dest is committed. The dest is released and reinstantiated and 
//          CRC'd.  If the dest was reverted, the CRC is compared against the 
//          empty CRC for a match. Otherwise, we compare against the original 
//          root docfile CRC. Original file is CRC'd again to verify that 
//          STGMOVE_MOVE moved the elements from orginal position instead of
//          copying, the CRC now computed should differ from the one calculated
//          originally. 
//
//          This tests differs from STGTEST-105 in the way that MoveElementTo
//          is called with STGMOVE_MOVE flag instead of STGMOVE_COPY.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    8-Aug-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File:  A part of STORAGE.CXX
// 2.  Old name of test : A part of STORAGE_TEST Test 
//     New Name of test : STGTEST_107 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-107
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-107
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-107
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//     d. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-107
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//        /frevertaftermove
//     e. stgbase /seed:2 /dfdepth:1-3 /dfstg:1-3 /dfstm:2-3 /t:STGTEST-107
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//        /frevertaftermove 
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//     BUGBUG: dont have /stdblock up yet. -scousens
//
//  In case of direct mode, the flag revertaftermove is not meaningful since
//  changes are always directly written to disk doc file.
//
// BUGNOTE: Conversion: STGTEST-107
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_107(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          ptszRootNewDocFile      = NULL;
    LPOLESTR        poszRootNewDocFile      = NULL;
    DWORD           dwRootMode              = 0;
    LPSTORAGE       pStgRoot1               = NULL;
    LPSTORAGE       pStgRoot2               = NULL;
    LPSTORAGE       pStgRoot11              = NULL;
    ULONG           ulRef                   = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    DWORD           dwCRC3                  = 0;
    DWORD           dwCRC4                  = 0;
    LPMALLOC        pMalloc                 = NULL;
    LPENUMSTATSTG   penumWalk               = NULL;
    LPTSTR          ptszElementName         = NULL;
    LPOLESTR        poszElementName         = NULL;
    BOOL            fPass                   = TRUE;
    STATSTG         statStg;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_107"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_107 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt MoveElementTo-STGMOVE_MOVE operations")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_107, Access mode: %lx"),
            dwRootMode));
    }

    // Commit all substgs BUGBUG df already commited

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
               hr));
        }
    }
   

    // Release root and all substorages/streams too 

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Open the root only

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Calculate CRC for entire DocFile without the RootDocfile name

    if(S_OK == hr)
    {
        pStgRoot1 = pVirtualDFRoot->GetIStoragePointer();  

        DH_ASSERT(NULL != pStgRoot1); 

        hr = CalculateCRCForDocFile(pStgRoot1, VERIFY_EXC_TOPSTG_NAME, &dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }


    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    if(S_OK == hr)
    {
        // Generate random name for first child storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &ptszRootNewDocFile);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(ptszRootNewDocFile, &poszRootNewDocFile);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if (S_OK == hr)
    {
        hr = StgCreateDocfile(
                poszRootNewDocFile,
                dwRootMode,
                0,
                &pStgRoot2);

        DH_HRCHECK(hr, TEXT("StgCreateDocFile")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgCreateDocfile successful as exp.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgCreateDocfile not successful, hr=0x%lx."),
                hr));
        }
    }


    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(pStgRoot2, VERIFY_EXC_TOPSTG_NAME, &dwCRC2);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Call EnumElements to get a enumerator for first DocFile

    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements(0, NULL, 0, &penumWalk);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements passed as expected")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::EnumElements unexpectedly failed hr=0x%lx"),
                hr));
        }
    }


    // First get pMalloc that would be used to free up the name string from
    // STATSTG.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    while(S_OK == hr && S_OK == penumWalk->Next(1, &statStg, NULL))
    {
        if(S_OK == hr)
        {
            // Convert statStg.pwcsName to TCHAR
            hr = OleStringToTString(statStg.pwcsName, &ptszElementName);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            // Now Convert old name to OLECHAR
            hr = TStringToOleString(ptszElementName, &poszElementName);

            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        if(S_OK == hr)
        {
            // Move the element to second DocFile

            hr = pStgRoot1->MoveElementTo(
                    poszElementName,
                    pStgRoot2,
                    poszElementName,
                    STGMOVE_COPY);
    
            DH_HRCHECK(hr, TEXT("IStorage::MoveElementTo")) ;
            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::MoveElementTo passed as expected")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStorage::MoveElementTo unexpectedly failed hr=0x%lx"),
                    hr));
            }
        }


        // Release resources

        if ( NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if(NULL != ptszElementName)
        {
            delete ptszElementName;
            ptszElementName = NULL;
        }

        if(NULL != poszElementName)
        {
            delete poszElementName;
            poszElementName = NULL;
        }
    }
 
    // Commit or Revert the second docfile as the case may be. 

    if((S_OK == hr) && (FALSE == g_fRevert))
    {
        hr = pStgRoot2->Commit(STGC_DEFAULT);

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }
    else
    if((S_OK == hr) && (TRUE == g_fRevert))
    {
        hr = pStgRoot2->Revert();

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Revert completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Revert unsuccessful, hr=0x%lx."),
                hr));
        }
    }
   
    // Close the second DocFile

    if(NULL != pStgRoot2)
    {
        ulRef = pStgRoot2->Release();
        DH_ASSERT(0 == ulRef);
        pStgRoot2 = NULL;
    }

    // Open it again and do StgIsStorageFile to verify.

    if(S_OK == hr)
    {
        hr = StgOpenStorage(
                poszRootNewDocFile,
                NULL,
                dwRootMode,
                NULL,
                0,
                &pStgRoot2);

       DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorage unsuccessful, hr=0x%lx."),
                hr));
        }
    }
        

    // Do StgIsStorageFile to verify

    if(S_OK == hr)
    {
        hr = StgIsStorageFile(poszRootNewDocFile);

       DH_HRCHECK(hr, TEXT("StgIsStorageFile")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorageFile completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgIsStorageFile unsuccessful, hr=0x%lx."),
                hr));
        }
    }
        

    // Calculate CRC on this second Root DocFile.

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(pStgRoot2, VERIFY_EXC_TOPSTG_NAME, &dwCRC3);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Compare CRC's

    if((S_OK == hr) && ( FALSE == g_fRevert))
    {
        if (dwCRC3 == dwCRC1)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's for docfile1 & docfile2 after commit match.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC for docfile1 & docfile2 aftr commit don't match")));
            
            fPass = FALSE;
        }
    }
    else
    if((S_OK == hr) && ( TRUE == g_fRevert))
    {
        if (dwCRC3 == dwCRC2)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's for docfile2 before & after Revert match.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC for docfile2 before & after Revert don't match")));
            
            fPass = FALSE;
        }
    }

    // Close the second DocFile

    if(NULL != pStgRoot2)
    {
        ulRef = pStgRoot2->Release();
        DH_ASSERT(0 == ulRef);
        pStgRoot2 = NULL;
    }
        
    // Release penumWalk

    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT(0 == ulRef);
        penumWalk = NULL;
    }

    // Release the first root docfile 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Open the Root DocFile again to verify the STGMOVE_MOVE flags specified
    // while doing MoveElementTo

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Now get the CRC again on the original DocFile to verify that flag
    // STGMOVE_COPY copied the elements and not moved them, so this CRC
    // should match with CRC originally  obtained on this DocFile.

    if(S_OK == hr)
    {
        pStgRoot11 = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRoot11);

        hr = CalculateCRCForDocFile(pStgRoot11, VERIFY_EXC_TOPSTG_NAME,&dwCRC4);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        if(S_OK == hr)
        {
            if (dwCRC4 == dwCRC1)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC for org docfile don't match as exp-move as move")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CRC for org docfile match unexp -move as move")));
            
                fPass = FALSE;
            }
        }
    }


    // Release the first root docfile 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Release pMalloc
    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr)  && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_107 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_107 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != poszRootNewDocFile)
    {
        delete poszRootNewDocFile;
        poszRootNewDocFile = NULL;
    }

    // Delete the second docfile on disk

    if((S_OK == hr) && (NULL != ptszRootNewDocFile))
    {
        if(FALSE == DeleteFile(ptszRootNewDocFile))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != ptszRootNewDocFile)
    {
        delete ptszRootNewDocFile;
        ptszRootNewDocFile = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_107 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    STGTEST_108
//
// Synopsis: A root docfile with a child storage is created, then check if 
//           Set/GetConvertStorage APIs work correctly as expected by passed 
//           in a storage pointer(here, we test both root storage and child
//           storage pointer). Also have some illegitmate tests by passing 
//           invalid arguments to these APIs.           
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    14-Aug-1996     JiminLi     Created.
//
// New Test Notes:
// 1.  Old File:  A part of STORAGE.CXX
// 2.  Old name of test : A part of STORAGE_TEST Test 
//     New Name of test : STGTEST_108 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-108
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-108
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-108
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//
// BUGNOTE: Conversion: STGTEST-108
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_108(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPSTORAGE       pRootStg                = NULL;
    LPSTORAGE       pChildStg               = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_108"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_108 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt legit and illegit tests on Set/GetConvertStg APIs")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_108, Access mode: %lx"),
            dwRootMode));
    }

    // Get root storage pointer
    if (NULL != pVirtualDFRoot)
    {
        pRootStg = pVirtualDFRoot->GetIStoragePointer();
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                dwStgMode,
                &pvcnRootNewChildStg);

        pChildStg = pvcnRootNewChildStg->GetIStoragePointer();

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }


    // Legit tests of Set/GetConvertStg on the root storage

    if (S_OK == hr)
    {
        hr = SetConvertStg(pRootStg, TRUE);
        if (S_OK == hr)
        {
            hr = GetConvertStg(pRootStg);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("SetConvertStg did not return S_OK as expected.")));
        }
        if (S_OK == hr)
        {
            hr = SetConvertStg(pRootStg, FALSE);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetConvertStg did not return S_OK as expected.")));
        }
        if (S_OK == hr)
        {
            hr = GetConvertStg(pRootStg);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("SetConvertStg did not return S_OK as expected.")));
        }
        if (S_FALSE == hr)
        {
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetConvertStg did not return S_FALSE as expected.")));

            hr = E_FAIL;
        }
    }


    // Legit tests of Set/GetConvertStg on the child storage

    if (S_OK == hr)
    {
        hr = SetConvertStg(pChildStg, TRUE);
        if (S_OK == hr)
        {
            hr = GetConvertStg(pChildStg);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("SetConvertStg did not return S_OK as expected.")));
        }

        if (S_OK == hr)
        {
            hr = SetConvertStg(pChildStg, FALSE);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetConvertStg did not return S_OK as expected.")));
        }

        if (S_OK == hr)
        {
            hr = GetConvertStg(pChildStg);
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("SetConvertStg did not return S_OK as expected.")));
        }

        if (S_FALSE == hr)
        {
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetConvertStg did not return S_FALSE as expected.")));

            hr = E_FAIL;
        }
    }


    // Illegit tests

#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!SetConvertStg with NULL IStorage skipped")) );

#else
    
    // Pass NULL as IStorage pointer, it should fail

    if (S_OK == hr)
    {
        hr = SetConvertStg(NULL, TRUE);
        if (E_INVALIDARG == hr)
        {
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("SetConvertStg did not return E_INVALIDARG as expected")));

            hr = E_FAIL;
        }

        if (S_OK == hr)
        {
            hr = GetConvertStg(NULL);
        }

        if (E_INVALIDARG == hr)
        {
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("GetConvertStg did not return E_INVALIDARG as expected")));

            hr = E_FAIL;
        }
    }


#endif //_MAC
    
    // Commit the root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Release child and root storages

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_108 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_108 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);
    
    // Delete temp strings

    if (NULL != pRootNewChildStgName)
    {
        delete []pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_108 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_109
//
// Synopsis: A root docfile is created with a child storage. Check StgSetTimes 
//           API work as expected to set times on root Storage and IStorage::
//           SetElementTimes on child storage. Verify by stat'ng on Storages 
//           and comparing stat'd times.  Then attempt setting times with NULL
//           time parameters.  Verify that earlier time set on storage remain
//           untouched.  Attempt illegitmate ops on the API. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    15-Aug-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File:  A part of OLECMN.CXX
// 2.  Old name of test : TestStgSetTime 
//     New Name of test : STGTEST_109 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-109
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-109
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-109
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
// 4.  To run for conversion, NA (add /dfStgType:conversion to each of the above)
// 5.  To run for nssfile, NA (add /dfStgType:nssfile to each of the above)
//     BUGBUG: -scousens  StgSetTimes not supported for nssfiles????
//
// BUGNOTE: Conversion: STGTEST-109
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_109(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    LPOLESTR        poszVirtualDFRootName   = NULL;
    DG_STRING       *pdgu                   = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fRet                    = FALSE;
    BOOL            fPass                   = TRUE;
    FILETIME        cNewRootStgFileTime     = {dwDefLowDateTime,
                                              dwDefHighDateTime};
    FILETIME        cNewChildStgFileTime    = {dwDefLowDateTime,
                                              dwDefHighDateTime};
    SYSTEMTIME      cCurrentSystemTime;    
    STATSTG         statStg;
    STATSTG         statStgChild;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_109"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_109 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt legit/illegit tests on StgSetTimes API")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_109, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                dwStgMode,
                &pvcnRootNewChildStg);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("AddStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("AddStorage not successful, hr=0x%lx."),
                hr));
        }
    }


    // Commit the root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // StgSetTimes on Root stg

    if(S_OK == hr)
    {
        // Convert test name to OLECHAR

        hr = TStringToOleString(
                pVirtualDFRoot->GetVirtualCtrNodeName(), 
                &poszVirtualDFRootName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        GetSystemTime(&cCurrentSystemTime);

        fRet = SystemTimeToFileTime(&cCurrentSystemTime, &cNewRootStgFileTime);

        DH_ASSERT(TRUE == fRet);
        DH_ASSERT(dwDefLowDateTime != cNewRootStgFileTime.dwLowDateTime);
        DH_ASSERT(dwDefHighDateTime != cNewRootStgFileTime.dwHighDateTime);

        hr = StgSetTimes(
                poszVirtualDFRootName,
                &cNewRootStgFileTime,
                &cNewRootStgFileTime,
                &cNewRootStgFileTime);

        DH_HRCHECK(hr, TEXT("StgSetTimes")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgSetTimes API passed as exp.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgSetTimes API failed unexp, hr = 0x%lx."),
                hr));
        }
    }


    // Now stat on root storage to see times are set correctly.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
               hr));
        }
    }


    // Compare times from  STATSTG structure.  FAT doesn't have enough 
    // resolution, so we would retrict to comapring dwHighDateTime part only
    // for mtime and ctime.

    if(S_OK == hr) 
    {
        if(cNewRootStgFileTime.dwHighDateTime == statStg.mtime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile mtime set as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile mtime didn't set unexpectedly.")));
    
            fPass = FALSE;
        }

        if(cNewRootStgFileTime.dwHighDateTime == statStg.ctime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile ctime set as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile ctime didn't set unexpectedly.")));
    
            fPass = FALSE;
        }
    }

    // Release child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // SetElementTimes on Child Storage

    if(S_OK == hr)
    {
        GetSystemTime(&cCurrentSystemTime);

        fRet = SystemTimeToFileTime(&cCurrentSystemTime, &cNewChildStgFileTime);

        DH_ASSERT(TRUE == fRet);
        DH_ASSERT(dwDefLowDateTime != cNewChildStgFileTime.dwLowDateTime);
        DH_ASSERT(dwDefHighDateTime != cNewChildStgFileTime.dwHighDateTime);

        hr = pvcnRootNewChildStg->SetElementTimes(
                &cNewChildStgFileTime,
                &cNewChildStgFileTime,
                &cNewChildStgFileTime);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::SetElementTimes")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::SetElementTimes passed as exp.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::SetElementTimes failed unexp, hr = 0x%lx."),
                hr));
        }
    }


    // Now open and stat on child storage to see times are set correctly.

    // Open child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Open(NULL, dwStgMode, NULL, 0);
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Stat on child storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Stat(&statStgChild, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
               hr));
        }
    }


    // Compare times from  STATSTG structure.  FAT doesn't have enough 
    // resolution, so we would retrict to comapring dwHighDateTime part only
    // for mtime and ctime.

    if(S_OK == hr) 
    {
        if(cNewChildStgFileTime.dwHighDateTime == 
            statStgChild.mtime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child Stg mtime set as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child stg mtime didn't set unexpectedly.")));
    
            fPass = FALSE;
        }

        if(cNewChildStgFileTime.dwHighDateTime == 
            statStgChild.ctime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child stg ctime set as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child Stg ctime didn't set unexpectedly.")));
    
            fPass = FALSE;
        }
    }

    // Release child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // StgSetTimes on Root stg with all NULL time elements.  Verify that the
    // time doesn't change,

    if(S_OK == hr)
    {
        hr = StgSetTimes(
                poszVirtualDFRootName,
                NULL,
                NULL,
                NULL);

        DH_HRCHECK(hr, TEXT("StgSetTimes with NULL time parameters")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgSetTimes API with NULL time param passed as exp.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgSetTimes API with NULL time param fail unexp, hr=0x%lx"),
                hr));
        }
    }


    // Now stat on root storage to seeearlier times have remain untouched. 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
               hr));
        }
    }


    // Compare times from  STATSTG structure.  FAT doesn't have enough 
    // resolution, so we would retrict to comapring dwHighDateTime part only
    // for mtime and ctime.

    if(S_OK == hr) 
    {
        if(cNewRootStgFileTime.dwHighDateTime == statStg.mtime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile mtime unchanged as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile mtime changed unexpectedly.")));
    
            fPass = FALSE;
        }

        if(cNewRootStgFileTime.dwHighDateTime == statStg.ctime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile ctime unchanged as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Root DocFile ctime changed unexpectedly.")));
    
            fPass = FALSE;
        }
    }

    // SetElementTimes on Child Storage with all NULL times.  Verify that
    // the times remain unchanged.

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStg->SetElementTimes(NULL,NULL,NULL);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::SetElementTimes")) ;
        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VCN::SetElementTimes with NULL times passed as exp.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VCN:SetElementTimes with NULL times failed unexp,hr=0x%lx"),
                hr));
        }
    }


    // Now open and stat on child storage to see times are set correctly.

    // Open child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Open(NULL, dwStgMode, NULL, 0);
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Stat on child storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Stat(&statStgChild, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        if (S_OK == hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat completed successfully.")));
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
               hr));
        }
    }


    // Compare times from  STATSTG structure.  FAT doesn't have enough 
    // resolution, so we would retrict to comapring dwHighDateTime part only
    // for mtime and ctime.

    if(S_OK == hr) 
    {
        if(cNewChildStgFileTime.dwHighDateTime == 
            statStgChild.mtime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child Stg mtime unchanged as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child stg mtime changed unexpectedly.")));
    
            fPass = FALSE;
        }

        if(cNewChildStgFileTime.dwHighDateTime == 
            statStgChild.ctime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child stg ctime unchanged as expected.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Child Stg ctime changed unexpectedly.")));
    
            fPass = FALSE;
        }
    }

    // Release child storage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Attempt calling StgSetTimes with NULL name.

    if(S_OK == hr)
    {
        GetSystemTime(&cCurrentSystemTime);

        fRet = SystemTimeToFileTime(&cCurrentSystemTime, &cNewRootStgFileTime);

        DH_ASSERT(TRUE == fRet);
        DH_ASSERT(dwDefLowDateTime != cNewRootStgFileTime.dwLowDateTime);
        DH_ASSERT(dwDefHighDateTime != cNewRootStgFileTime.dwHighDateTime);

        hr = StgSetTimes(
                NULL,
                &cNewRootStgFileTime,
                &cNewRootStgFileTime,
                &cNewRootStgFileTime);

        DH_HRCHECK(hr, TEXT("StgSetTimes")) ;
        if(STG_E_INVALIDNAME == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgSetTimes API with NULL name failed as exp, hr = 0x%lx."),
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgSetTimes with NULL name didn't fail as exp, hr=0x%lx"),
                hr));
        }
    }


    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

    
    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
        DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_109 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_109 failed, hr = 0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if (NULL != poszVirtualDFRootName)
    {
        delete poszVirtualDFRootName;
        poszVirtualDFRootName = NULL;
    }

    if (NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_109 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    STGTEST_110
//
// Synopsis: A root docfile is created, then add a random number of streams
//           under the root storage, make sure the last stream's size is
//           less than 4K(ministream), then commit and release the docfile.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:    29-Oct-1996     JiminLi     Created.
//
// Notes:
//   To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-110
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-110
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:STGTEST-110
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
// 4.  To run for conversion, add /dfStgType:conversion to each of the above
// 5.  To run for nssfile, add /dfStgType:nssfile to each of the above
//
// BUGNOTE: Conversion: STGTEST-110
//
//-----------------------------------------------------------------------------

HRESULT STGTEST_110(int argc, char *argv[])
{
    HRESULT         hr                          = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    VirtualStmNode  **pvsnRootNewChildStream    = NULL;
    LPTSTR          *pRootNewChildStmName       = NULL;
    ULONG           culBytesWrite               = 0;
    DG_INTEGER      *pdgi                       = NULL;
    LPTSTR          ptcsBuffer                  = NULL;
    DG_STRING       *pdgu                       = NULL;
    DWORD           dwRootMode                  = 0;
    ULONG           ulIndex                     = 0;
    ULONG           ulStmNum                    = 0;
    ULONG           ulMinStm                    = 2;
    ULONG           ulMaxStm                    = 5;
    ULONG           culWritten                  = 0;
    USHORT          usErr                       = 0;


    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("STGTEST_110"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_110 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Test on adding a ministream into the root storage")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
 
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for STGTEST_110, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_UNICODE object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi) ;
    }

    // Generate the number of streams to create

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&ulStmNum, ulMinStm, ulMaxStm);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Initialization

    if (S_OK == hr)
    {
        pvsnRootNewChildStream = new VirtualStmNode*[ulStmNum];
        pRootNewChildStmName = new LPTSTR[ulStmNum];
 
        if ((NULL == pvsnRootNewChildStream) || (NULL == pRootNewChildStmName))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        for (ulIndex = 0; ulIndex < ulStmNum; ulIndex++)
        {
            pvsnRootNewChildStream[ulIndex] = NULL;
            pRootNewChildStmName[ulIndex] = NULL;
         }
    }

    // Create ulStmNum streams under the root storage

    for (ulIndex = 0; ulIndex < ulStmNum; ulIndex++)
    {
        if (S_OK == hr)
        {
            // Generate random name for stream

            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &pRootNewChildStmName[ulIndex]);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if (S_OK == hr)
        {
            hr = AddStream(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootNewChildStmName[ulIndex],
                    0,
                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                    &pvsnRootNewChildStream[ulIndex]);

            DH_HRCHECK(hr, TEXT("AddStream")) ;
            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::AddStream completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx"),
                    hr));
            }
        }


        if (S_OK == hr)
        {
            // Generate random size for stream between MIN_STMSIZE and
            // MAX_STMSIZE if it's not the last stream, otherwise generate a 
            // size between 0 and MAXSIZEOFMINISTM(4k).
 
            if (ulStmNum-1 == ulIndex)
            {
                usErr = pdgi->Generate(&culBytesWrite,0L,MAXSIZEOFMINISTM);
            }
            else
            {
                usErr = pdgi->Generate(&culBytesWrite,MIN_STMSIZE,MAX_STMSIZE);
            }

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }

        if (S_OK == hr)
        {
            // Generate a random string of size culBytesWrite

            hr = GenerateRandomString(
                    pdgu,
                    culBytesWrite,
                    culBytesWrite,
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr = pvsnRootNewChildStream[ulIndex]->Write(
                    ptcsBuffer,
                    culBytesWrite,
                    &culWritten);
            if (S_OK != hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::Write not successful, hr=0x%lx."),
                    hr));
            }
        }


        // Delete the temp buffer

        if (NULL != ptcsBuffer)
        {
            delete ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }

    // Commit the root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                hr));
        }
    }


    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }
    }

 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("Test variation STGTEST_110 passed.")) );
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("Test variation STGTEST_110 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);
    
    // Delete temp strings

    if (NULL != pvsnRootNewChildStream)
    {
        delete []pvsnRootNewChildStream;
        pvsnRootNewChildStream = NULL;
    }

    for (ulIndex = 0; ulIndex < ulStmNum; ulIndex++)
    {
        if (NULL != pRootNewChildStmName[ulIndex])
        {
            delete pRootNewChildStmName[ulIndex];
            pRootNewChildStmName[ulIndex] = NULL;
        }
    }

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation STGTEST_110 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\vcpytsts.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      vcpytsts.cxx
//
//  Contents:  storage base tests basically pertaining to IStorage/IStream copy
//             ops 
//
//  Functions:  
//
//  History:    15-July-1996     NarindK     Created.
//              27-Mar-97        SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

//externs
extern BOOL     g_fRevert;

//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_100 
//
// Synopsis: A random root DF is created with random storages/stms, committed 
//       The root docfile is searched to find a VirtualCtrNode node in tree 
//       that is a child of the root IStorage.  The child IStorage
//       is then copied with the destination being the root docfile itself.
//       If the 'RevertAfterCopy' switch was specified, the root docfile
//       is then reverted and the CRC is recomputed on the root docfile
//       and compared to the before copy CRC to verify that no changes
//       occurred in the docfile hierarchy.  Also it is verified by enum
//       rating the docfile before and after opeartion and testing the total
//       number of storages and streams in file remain unchanged.
//       If case of Revert being FALSE, the contents of the child IStorage 
//       should be merged in with the contents of the root level of the docfile.
//       Verify this case by enumerating the docfile before and after
//       CopyTo is done and test that the resulting number of storages &
//       streams in the DocFile is as expected. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    15-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LCCTOP.CXX
// 2.  Old name of test : LegitCopyChildDFToParentDF Test 
//     New Name of test : VCPYTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:2-4 /dfstm:2-3 /t:VCPYTEST-100
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:2-4 /dfstm:2-3 /t:VCPYTEST-100
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:2-4 /dfstm:2-3 /t:VCPYTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//     d. stgbase /seed:2 /dfdepth:1-1 /dfstg:2-4 /dfstm:2-3 /t:VCPYTEST-100
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /revert 
//     e. stgbase /seed:2 /dfdepth:1-1 /dfstg:2-4 /dfstm:2-3 /t:VCPYTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /revert
//
// BUGNOTE: Conversion: VCPYTEST-100
//
//-----------------------------------------------------------------------------

HRESULT VCPYTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRandomChild        = NULL;
    VirtualCtrNode  *pvcnTrav               = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgChild               = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    ULONG           cChildren               = 0;
    ULONG           cRandomChild            = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    ULONG           cTotalStg               = 0;
    ULONG           cTotalStm               = 0;
    ULONG           cChildStg               = 0;
    ULONG           cChildStm               = 0;
    ULONG           cResStg                 = 0;
    ULONG           cResStm                 = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,TEXT("Attempt valid copyto op fm child IStg to root")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG whole df already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Get IStorage pointer for Root

    if(S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRoot) ;
        if(NULL == pStgRoot)
        {
            hr = E_FAIL;
        }
    }
   
    // Calulcate CRC for entire docfile.

    if((S_OK == hr) && (TRUE == g_fRevert))
    {
       hr = CalculateCRCForDocFile(pStgRoot,VERIFY_INC_TOPSTG_NAME,&dwCRC1);

       DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }
   
    // Find the total number of VirtualCtrNodes and VirtualStmNodes in the
    // DocFile

    if(S_OK == hr)
    {
       hr = EnumerateDiskDocFile(pStgRoot, VERIFY_SHORT,&cTotalStg, &cTotalStm);

       DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
    }
  
    // Find a random child VirtualCtrNode in the file.  First verify there
    // are child storages in the tree.

    if(S_OK == hr)
    {
        cChildren = pVirtualDFRoot->GetVirtualCtrNodeChildrenCount();

        if(0 == cChildren)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Max original tree depth inadequate to find a child")));

            hr = S_FALSE;
        }
    }
    
    if(S_OK == hr)
    {
        // Find a random child storage to pick from

        usErr = pdgi->Generate(&cRandomChild, 1, cChildren);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Pick up the random child node.

    if(S_OK == hr)
    {
        pvcnTrav = pVirtualDFRoot->GetFirstChildVirtualCtrNode();

        DH_ASSERT(NULL != pvcnTrav);

        while((0 != --cRandomChild) && 
              (NULL != pvcnTrav->GetFirstSisterVirtualCtrNode()))
        {
            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
        }
        pvcnRandomChild = pvcnTrav;
    }

    if(S_OK == hr)
    {
        hr = OpenRandomVirtualCtrNodeStg(pvcnRandomChild, dwStgMode);

        DH_HRCHECK(hr, TEXT("OpenRandomVirtualCtrNodeStg")) ;
    }

    if(S_OK == hr)
    {
        pStgChild = pvcnRandomChild->GetIStoragePointer();

        DH_ASSERT(NULL != pStgChild) ;
    }
   
    // Find the total number of VirtualCtrNode(s) and VirtualStmNode(s) under
    // this node.

    if(S_OK == hr)
    {
       hr = EnumerateDiskDocFile(pStgChild,VERIFY_SHORT,&cChildStg,&cChildStm);

       DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
    }

    // Copy everything under this child node to the Root node.

    if(S_OK == hr)
    {
       hr = pvcnRandomChild->CopyTo(0, NULL, NULL, pVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
            hr));
    }

    // Adjust the virtual tree as a result of above operation.

    if((S_OK == hr) && (FALSE == g_fRevert))
    {
       hr = pTestVirtualDF->AdjustTreeOnCopyTo(pvcnRandomChild, pVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualDF::AdjustTreeOnCopyTo")) ;
    }

    // Commit if g_fRevert is false, else revert

    if(S_OK == hr)
    {
        if(FALSE == g_fRevert)
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
   
            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Commit completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                    hr));
            }
        }
        else
        {
            hr = pVirtualDFRoot->Revert();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;
   
            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Revert completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Revert unsuccessful, hr=0x%lx."),
                    hr));
            }
        }
    }

    if(S_OK == hr)
    {
        hr = CloseRandomVirtualCtrNodeStg(pvcnRandomChild);

        DH_HRCHECK(hr, TEXT("CloseRandomVirtualCtrNodeStg")) ;
    }

    // Calculate the CRC now for the docfile

    if((S_OK == hr) && (TRUE == g_fRevert))
    {
       hr = CalculateCRCForDocFile(pStgRoot,VERIFY_INC_TOPSTG_NAME,&dwCRC2);

       DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Enumerate the DocFile now

    if(S_OK == hr)
    {
       hr = EnumerateDiskDocFile(pStgRoot,VERIFY_SHORT,&cResStg, &cResStm);

       DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
    }
   
    // For verification, if this was a commit opeartion, then CRC's won't match
    // ,verify by checking total number of VirtualCtrNodes and VirtualStmNodes
    // expected as result of copy opeartion, therby number of IStorages/IStreams 
    if(S_OK == hr)
    {
        if(FALSE == g_fRevert)
        {
            if(cResStg == cTotalStg + (cChildStg-1))
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & commit as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & Commit not as exp")));
            } 

            if(cResStm == cTotalStm + cChildStm)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & commit as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & commit not as exp.")));
            } 
        }
        else
        {
            if(cResStg == cTotalStg)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & Revert as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & Revert not as exp.")));
            } 

            if(cResStm == cTotalStm)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & Revert as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & Revert not as exp.")));
            }
        }
    }

    // If revert operations, the CRC's should match.

    if((S_OK == hr) && (TRUE == g_fRevert))
    {
        if(dwCRC1 == dwCRC2)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's match as exp after CopyTo & Revert Ops")));
        }
        else
        {
            fPass = FALSE;
        
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's don't match as exp after CopyTo & Revert Ops")));
        }
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation VCPYTEST_100 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_101 
//
// Synopsis: A random root DF is created with random storages/stms, committed 
//       The root docfile is tree is then searched for, and for each child
//       IStorage found, the CRC is computed for that IStorage (only
//       if Revert wasn't specified on the command line).  A new child IStorage
//       is then created in the root docfile with a unique, random name.  
//       If Revert was specified in command line,this new empty stg is CRC'd
//       The IStorage is then copied to the new child IStorage via CopyTo(). If
//       Revert was *not* speficied, the new child IStorage and the root 
//       docfile are committed, else the dest IStorage is Reverted().  The CRC 
//       is then computed for the dest IStorage and the CRCs are compared.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    17-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LCCWPAR.CXX
// 2.  Old name of test : LegitCopyChildDFWithinParent Test 
//     New Name of test : VCPYTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-3 /dfstg:2-5 /dfstm:2-3 /t:VCPYTEST-101
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-3 /dfstg:2-5 /dfstm:2-3 /t:VCPYTEST-101
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-3 /dfstg:2-5 /dfstm:2-3 /t:VCPYTEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//     d. stgbase /seed:2 /dfdepth:1-3 /dfstg:2-5 /dfstm:2-3 /t:VCPYTEST-101
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /revert 
//     e. stgbase /seed:2 /dfdepth:1-3 /dfstg:2-5 /dfstm:2-3 /t:VCPYTEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /revert
//
// BUGNOTE: Conversion: VCPYTEST-101
//
//-----------------------------------------------------------------------------

HRESULT VCPYTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnTravChild          = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    LPSTORAGE       pStgChild               = NULL;
    DG_STRING      *pdgu                   = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_101 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt valid copyto fm childstg to new child stg of parent")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG whole df already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Go in a loop and for each child storage (child VirtualCtrNode) found,
    // do a CopyTo operation.  Verify with CRC mechanism usnder both commit/
    // Rvert conditions.

    if (S_OK == hr)
    {
        pvcnTravChild = pVirtualDFRoot->GetFirstChildVirtualCtrNode();

        if(NULL == pvcnTravChild)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualDF tree depth inadeuate to have a child.")));
            
            hr = S_FALSE;
        }
    }

    while((NULL != pvcnTravChild) && (S_OK == hr))
    {
        if(S_OK == hr)
        {
            hr = ParseVirtualDFAndCloseOpenStgsStms(
                    pvcnTravChild, 
                    NODE_EXC_TOPSTG);
        }

        // Calculate CRC for this child VirtualCtrNode

        if((S_OK == hr) && (FALSE == g_fRevert))
        {
            pStgChild = pvcnTravChild->GetIStoragePointer();

            hr = CalculateCRCForDocFile(
                    pStgChild,
                    VERIFY_EXC_TOPSTG_NAME,
                    &dwCRC1);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        }

        // Now add a new storage
    
        if(S_OK == hr)
        {
            // Generate random name for storage

            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &pRootNewChildStgName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if(S_OK == hr)
        {
            hr = AddStorage(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootNewChildStgName,
                    dwStgMode | STGM_FAILIFTHERE,
                    &pvcnRootNewChildStg);

            DH_HRCHECK(hr, TEXT("AddStorage")) ;
            DH_ASSERT(S_OK == hr);
        }

        if(S_OK == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("AddStorage successful.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("AddStorage unsuccessful, hr=0x%lx."),
                hr));
        }

        if((S_OK == hr) && (TRUE == g_fRevert))
        {
            pStgChild = pvcnRootNewChildStg->GetIStoragePointer();

            hr = CalculateCRCForDocFile(
                    pStgChild,
                    VERIFY_EXC_TOPSTG_NAME,
                    &dwCRC1);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        }


        if(S_OK == hr)
        {
            hr = pvcnTravChild->CopyTo(0, NULL, NULL, pvcnRootNewChildStg);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
        }
        
        if(S_OK == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::CopyTo successful.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
                hr));
        }

        if(S_OK == hr) 
        {
            if(FALSE == g_fRevert)
            {
                // Commit the new VirtualCtrNode and Root Node

                hr = pvcnRootNewChildStg->Commit(STGC_DEFAULT);

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Child VirtualCtrNode::Commit successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Child VCN::Commit unsuccessful,hr=0x%lx"),
                        hr));
                }

                if(S_OK == hr)
                {
                    hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
                }

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Root VirtualCtrNode::Commit successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Root VCN::Commit unsuccessful,hr=0x%lx"),
                        hr));
                }
            }
            else
            {
                // Revert the new child storage
                
                hr = pvcnRootNewChildStg->Revert();

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Child VirtualCtrNode::Revert successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Child VCN::Revert unsuccessful,hr=0x%lx"),
                        hr));
                }
            }
        }

        // Calculate CRC for the destination storage now

        if(S_OK == hr)
        {
            pStgChild = pvcnRootNewChildStg->GetIStoragePointer();

            if(NULL == pStgChild)
            {
                hr = E_FAIL;
            }
        }

        if(S_OK == hr)
        {
            hr = CalculateCRCForDocFile(
                    pStgChild,
                    VERIFY_EXC_TOPSTG_NAME,
                    &dwCRC2);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        }

        // Verify CRC

        if((S_OK == hr) && (dwCRC1 == dwCRC2))
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's of source and dest copied to Stg match.")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's of source and dest copied to Stg don't match.")));
            
            break;
        }

        // Release source child stg
        
        if(NULL != pvcnTravChild) 
        {
            hr = pvcnTravChild->Close();
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        }

        // Release new child stg
        
        if(NULL != pvcnRootNewChildStg) 
        {
            hr = pvcnRootNewChildStg->Close();
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        }

        // Destory new child stg since we are done with it.  Also the while
        // loop condition depends upon original number of VirtualCtrNodes

        if(NULL !=  pvcnRootNewChildStg)
        {
            hr =  DestroyStorage(pTestVirtualDF, pvcnRootNewChildStg);
            DH_HRCHECK(hr, TEXT("DestroyStorage")) ;
        }

        // Release temp string

        if(NULL != pRootNewChildStgName)
        {
            delete pRootNewChildStgName;
            pRootNewChildStgName = NULL;
        }

        // Advance pvcnTravChild to next and reset pointers to NULL. 

        pvcnTravChild = pvcnTravChild->GetFirstSisterVirtualCtrNode();
        pStgChild = NULL;
        pvcnRootNewChildStg = NULL;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation VCPYTEST_101 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_102 
//
// Synopsis: A random root DF is created with random storages/stms. 
//       The root docfile is searched for until an IStorage is found that is 
//       a grandchild of the root IStorage. The docfile is commited.
//       The grandchild IStorage is then copied with the destination being 
//       the root docfile itself.
//       If the 'Rever' switch was specified, the root docfile
//       is then reverted and the CRC is recomputed on the root docfile
//       and compared to the before copy CRC to verify that no changes
//       occurred in the docfile hierarchy.  Also it is verified by enum
//       rating the docfile before and after opeartion and testing the total
//       number of storages and streams in file remain unchanged.
//       If case of Revert being FALSE, the contents of the grandchild IStorage 
//       should be merged in with the contents of the root level of the docfile.
//       Verify this case by enumerating the docfile before and after
//       CopyTo is done and test that the resulting number of storages &
//       streams in the DocFile is as expected. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    17-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LCGCTANC.CXX
// 2.  Old name of test : LegitCopyChildDFToAncestorDF Test 
//     New Name of test : VCPYTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:2-3 /t:VCPYTEST-102
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:2-3 /t:VCPYTEST-102
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:2-3 /t:VCPYTEST-102
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//     d. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:2-3 /t:VCPYTEST-102
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /revert 
//     e. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:2-3 /t:VCPYTEST-102
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /revert
//
// BUGNOTE: Conversion: VCPYTEST-102
//
// This test is almost same as VCPYTEST-100 with difference being that the
// root's grandchild's contents are copied to the root. The difference in
// code is in picking up the random child and in command line parameters. 
//-----------------------------------------------------------------------------

HRESULT VCPYTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnTrav               = NULL;
    VirtualCtrNode  *pvcnRandomParent       = NULL;
    VirtualCtrNode  *pvcnRandomGrandChild   = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgGrandChild          = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    ULONG           cTotalStg               = 0;
    ULONG           cTotalStm               = 0;
    ULONG           cChildStg               = 0;
    ULONG           cChildStm               = 0;
    ULONG           cResStg                 = 0;
    ULONG           cResStm                 = 0;
    ULONG           cDepth                  = 0;
    BOOL            fPass                   = TRUE;
    ULONG           cChildren               = 0;
    ULONG           cGrandChildren          = 0;
    ULONG           cParentOfGrandChild     = 0;
    ULONG           cRandomGrandChild       = 0;
    ULONG           cRandomParent           = 0;
    ULONG           counter                 = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_102 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt valid copyto operatons from grandchild to root stg")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }
   
    // Find a random grandchild VirtualCtrNode in the file.  

    // For that first find a random child storage in tree that has grandchild
    // storages in tree

    if(S_OK == hr)
    {
        cChildren = pVirtualDFRoot->GetVirtualCtrNodeChildrenCount();

        if(0 == cChildren)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Max tree depth inadequate to find a child")));

            hr = S_FALSE;
        }
    }

    // Find child nodes with grandchildren.

    if(S_OK == hr)
    {
        pvcnTrav = pVirtualDFRoot->GetFirstChildVirtualCtrNode();

        DH_ASSERT(NULL != pvcnTrav);

        while(NULL != pvcnTrav)
        {
            if(0 != pvcnTrav->GetVirtualCtrNodeChildrenCount())
            {
                cParentOfGrandChild++;
            }
            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
        }

        if(0 == cParentOfGrandChild)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Max tree depth inadequate to find grandchild")));

            hr = S_FALSE;
        }
    }

    // Pick up a random Parent VirtualCtrNode whos have Grand children
    // Generate random number
    
    if(S_OK == hr)
    {
        // Find a random child storage to pick from

        usErr = pdgi->Generate(&cRandomParent, 1, cParentOfGrandChild);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Pick up the random parent
    if(S_OK == hr)
    {
        pvcnTrav = pVirtualDFRoot->GetFirstChildVirtualCtrNode();
        while(NULL != pvcnTrav)
        {
            if(0 != pvcnTrav->GetVirtualCtrNodeChildrenCount())
            {
                counter++;
            }
            if(counter == cRandomParent)
            {
                pvcnRandomParent = pvcnTrav;
                break;
            }
            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
        }
    }

    // Now pick up a random GrandChild storage node from the above random
    // parent 

    if(S_OK == hr)
    {
        cGrandChildren = pvcnRandomParent->GetVirtualCtrNodeChildrenCount();
        DH_ASSERT(0 != cGrandChildren);
 
        // Find a random grandchild storage to pick from

        usErr = pdgi->Generate(&cRandomGrandChild, 1, cGrandChildren);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }

        if(S_OK == hr)
        {
            pvcnRandomGrandChild = 
                pvcnRandomParent->GetFirstChildVirtualCtrNode();

            while((0 != --cRandomGrandChild) && (NULL != pvcnRandomGrandChild))
            {
                pvcnRandomGrandChild = 
                    pvcnRandomGrandChild->GetFirstSisterVirtualCtrNode();
            }
        }
    }

    // Commit the storages from here upto root.

    if(S_OK == hr)
    {
        hr = pvcnRandomGrandChild->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    if(S_OK == hr)
    {
        hr = pvcnRandomParent->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close all  open stgs/stms except root

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Get IStorage pointer for Root

    if(S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRoot) ;
        if(NULL == pStgRoot)
        {
            hr = E_FAIL;
        }
    }
   
    // Calulcate CRC for entire docfile.

    if((S_OK == hr) && (TRUE == g_fRevert))
    {
       hr = CalculateCRCForDocFile(pStgRoot,VERIFY_INC_TOPSTG_NAME,&dwCRC1);

       DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Find the total number of VirtualCtrNodes and VirtualStmNodes in the
    // DocFile

    if(S_OK == hr)
    {
       hr = EnumerateDiskDocFile(pStgRoot, VERIFY_SHORT,&cTotalStg, &cTotalStm);

       DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
    }
  
    // Open the grandChildStg from where CopyTo would be done to root.
 
    if(S_OK == hr)
    {
        hr = OpenRandomVirtualCtrNodeStg(pvcnRandomGrandChild, dwStgMode);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    // get its istorage pointer.

    if(S_OK == hr)
    {
        pStgGrandChild = pvcnRandomGrandChild->GetIStoragePointer();

        DH_ASSERT(NULL != pStgGrandChild) ;
        if(NULL == pStgGrandChild)
        {
            hr = E_FAIL;
        }
    }
   
    // Find the total number of VirtualCtrNode(s) and VirtualStmNode(s) under
    // this node. Used for verification of copyto operation.

    if(S_OK == hr)
    {
       hr = EnumerateDiskDocFile(
                pStgGrandChild,
                VERIFY_SHORT,
                &cChildStg,
                &cChildStm);

       DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
    }

    // Copy everything under this child node to the Root node.

    if(S_OK == hr)
    {
       hr = pvcnRandomGrandChild->CopyTo(0, NULL, NULL, pVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
            hr));
    }

    // Adjust the virtual tree as a result of above operation.

    if((S_OK == hr) && (FALSE == g_fRevert))
    {
       hr = pTestVirtualDF->AdjustTreeOnCopyTo(
                pvcnRandomGrandChild, 
                pVirtualDFRoot);

       DH_HRCHECK(hr, TEXT("VirtualDF::AdjustTreeOnCopyTo")) ;
    }

    // Commit if g_fRevert is false, else revert

    if(S_OK == hr)
    {
        if(FALSE == g_fRevert)
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
   
            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Commit completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
                    hr));
            }
        }
        else
        {
            hr = pVirtualDFRoot->Revert();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;
   
            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Revert completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualCtrNode::Revert unsuccessful, hr=0x%lx."),
                    hr));
            }
        }
    }

    if(S_OK == hr)
    {
        hr = CloseRandomVirtualCtrNodeStg(pvcnRandomGrandChild);

        DH_HRCHECK(hr, TEXT("CloseRandomVirtualCtrNodeStg")) ;
    }

    // Calculate the CRC now for the docfile

    if((S_OK == hr) && (TRUE == g_fRevert))
    {
       hr = CalculateCRCForDocFile(pStgRoot,VERIFY_INC_TOPSTG_NAME,&dwCRC2);

       DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Enumerate the DocFile now

    if(S_OK == hr)
    {
       hr = EnumerateDiskDocFile(pStgRoot,VERIFY_SHORT,&cResStg, &cResStm);

       DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
    }
   
    // For verification, if this was a commit opeartion, then CRC's won't match
    // ,verify by checking total number of VirtualCtrNodes and VirtualStmNodes
    // expected as result of copy opeartion, therby number of IStorages/IStreams 
    if(S_OK == hr)
    {
        if(FALSE == g_fRevert)
        {
            if(cResStg == cTotalStg + (cChildStg-1))
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & commit as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & Commit not as exp")));
            } 

            if(cResStm == cTotalStm + cChildStm)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & commit as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & commit not as exp.")));
            } 
        }
        else
        {
            if(cResStg == cTotalStg)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & Revert as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stg's after CopyTo & Revert not as exp.")));
            } 

            if(cResStm == cTotalStm)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & Revert as exp.")));
            }
            else
            {
                fPass = FALSE;

                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enum of Stm's after CopyTo & Revert not as exp.")));
            }
        }
    }

    // If revert operations, the CRC's should match.

    if((S_OK == hr) && (TRUE == g_fRevert))
    {
        if(dwCRC1 == dwCRC2)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's match as exp after CopyTo & Revert Ops")));
        }
        else
        {
            fPass = FALSE;
        
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's don't match as exp after CopyTo & Revert Ops")));
        }
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation VCPYTEST_102 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_103 
//
// Synopsis: A random root DF is created with random storages/stms, committed 
//       The root docfile is tree is then searched for, and for each grandchild
//       IStorage found, the CRC is computed for that IStorage (only
//       if Revert wasn't specified on the command line).  A new child IStorage
//       is then created in the root docfile with a unique, random name.  
//       If Revert was specified in command line,this new empty stg is CRC'd
//       The GrandChild IStorage is copied to new child IStorage via CopyTo().If
//       Revert was *not* speficied, the new child IStorage and the root 
//       docfile are committed, else the dest IStorage is Reverted().  The CRC 
//       is then computed for the dest IStorage and the CRCs are compared.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LCGCWANC.CXX
// 2.  Old name of test : LegitCopyGrandChildDFWithinAncestorDF Test 
//     New Name of test : VCPYTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:1-3 /t:VCPYTEST-103
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:1-3 /t:VCPYTEST-103
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:1-3 /t:VCPYTEST-103
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//     d. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:1-3 /t:VCPYTEST-103
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /revert 
//     e. stgbase /seed:2 /dfdepth:3-4 /dfstg:4-6 /dfstm:1-3 /t:VCPYTEST-103
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /revert
//
// BUGNOTE: Conversion: VCPYTEST-103
//
// This test is almost same as VCPYTEST-101 with difference being that the
// root's grandchild's contents are copied to the root's new child stg. 
//-----------------------------------------------------------------------------

HRESULT VCPYTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnTravGrandChild     = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    LPSTORAGE       pStgGrandChild          = NULL;
    DG_STRING      *pdgu                   = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_103 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt copyto fm grandchild stg to new childstg of grandparent")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_103, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Go in a loop and for each grandchild storage (grandchild VirtualCtrNode)
    // found, do a CopyTo operation.  Verify with CRC mechanism under both 
    // commit/Revert conditions.

    if (S_OK == hr)
    {
        VirtualCtrNode* pNode = pVirtualDFRoot->GetFirstChildVirtualCtrNode();

        //keep looking till we think we find one
        while (NULL != pNode && NULL == pNode->GetFirstChildVirtualCtrNode())
        {
            pNode = pNode->GetFirstSisterVirtualCtrNode();
        }
        //this one has the the grandchild        
        if (NULL != pNode)
        {
            pvcnTravGrandChild = pNode->GetFirstChildVirtualCtrNode();
        }

        if (NULL == pvcnTravGrandChild)
        {
            hr = S_FALSE;
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualDF tree depth inadequate to have grandChild.")));
        }
    }

    while((NULL != pvcnTravGrandChild) && (S_OK == hr))
    {
        if(S_OK == hr)
        {
            hr = ParseVirtualDFAndCloseOpenStgsStms(
                    pvcnTravGrandChild, 
                    NODE_EXC_TOPSTG);
        }

        // Calculate CRC for this grandchild VirtualCtrNode

        if((S_OK == hr) && (FALSE == g_fRevert))
        {
            pStgGrandChild = pvcnTravGrandChild->GetIStoragePointer();

            hr = CalculateCRCForDocFile(
                    pStgGrandChild,
                    VERIFY_EXC_TOPSTG_NAME,
                    &dwCRC1);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        }

        // Now add a new storage
    
        if(S_OK == hr)
        {
            // Generate random name for storage

            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &pRootNewChildStgName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if(S_OK == hr)
        {
            hr = AddStorage(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootNewChildStgName,
                    dwStgMode | STGM_FAILIFTHERE,
                    &pvcnRootNewChildStg);

            DH_HRCHECK(hr, TEXT("AddStorage")) ;
            DH_ASSERT(S_OK == hr);
        }

        if(S_OK == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("AddStorage successful.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("AddStorage unsuccessful, hr=0x%lx."),
                hr));
        }

        if((S_OK == hr) && (TRUE == g_fRevert))
        {
            pStgGrandChild = pvcnRootNewChildStg->GetIStoragePointer();

            hr = CalculateCRCForDocFile(
                    pStgGrandChild,
                    VERIFY_EXC_TOPSTG_NAME,
                    &dwCRC1);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        }


        if(S_OK == hr)
        {
            hr = pvcnTravGrandChild->CopyTo(0, NULL, NULL, pvcnRootNewChildStg);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
        }
        
        if(S_OK == hr)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::CopyTo successful.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
                hr));
        }

        if(S_OK == hr) 
        {
            if(FALSE == g_fRevert)
            {
                // Commit the new VirtualCtrNode and Root Node

                hr = pvcnRootNewChildStg->Commit(STGC_DEFAULT);

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Child VirtualCtrNode::Commit successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Child VCN::Commit unsuccessful,hr=0x%lx"),
                        hr));
                }

                if(S_OK == hr)
                {
                    hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
                }

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Root VirtualCtrNode::Commit successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Root VCN::Commit unsuccessful,hr=0x%lx"),
                        hr));
                }
            }
            else
            {
                // Revert the new child storage
                
                hr = pvcnRootNewChildStg->Revert();

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Child VirtualCtrNode::Revert successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Child VCN::Revert unsuccessful,hr=0x%lx"),
                        hr));
                }
            }
        }

        // Calculate CRC for the destination storage now

        if(S_OK == hr)
        {
            pStgGrandChild = pvcnRootNewChildStg->GetIStoragePointer();
            if(NULL == pStgGrandChild)
            {
                hr = E_FAIL;
            }
        }

        if(S_OK == hr)
        {
            hr = CalculateCRCForDocFile(
                    pStgGrandChild,
                    VERIFY_EXC_TOPSTG_NAME,
                    &dwCRC2);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
        }

        // Verify CRC

        if((S_OK == hr) && (dwCRC1 == dwCRC2))
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's of source and dest copied to Stg match.")));
        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC's of source and dest copied to Stg don't match.")));
            
            break;
        }

        // Release source child stg
        
        if(NULL != pvcnTravGrandChild) 
        {
            hr = pvcnTravGrandChild->Close();
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        }

        // Release new child stg
        
        if(NULL != pvcnRootNewChildStg) 
        {
            hr = pvcnRootNewChildStg->Close();
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        }

        // Destory new child stg since we are done with it.  Also the while
        // loop condition depends upon original number of VirtualCtrNodes

        if(NULL !=  pvcnRootNewChildStg)
        {
            hr =  DestroyStorage(pTestVirtualDF, pvcnRootNewChildStg);
            DH_HRCHECK(hr, TEXT("DestroyStorage")) ;
        }

        // Release temp string

        if(NULL != pRootNewChildStgName)
        {
            delete pRootNewChildStgName;
            pRootNewChildStgName = NULL;
        }

        // Advance pvcnTravGrandChild to next and reset pointers to NULL. 

        pvcnTravGrandChild = pvcnTravGrandChild->GetFirstSisterVirtualCtrNode();
        pStgGrandChild = NULL;
        pvcnRootNewChildStg = NULL;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation VCPYTEST_103 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_104 
//
// Synopsis: A random root DF is created with random storages/stms, committed .
//       Then CRC is computed for entire entire docfile.  A new root docfile 
//       with a random name is then created.  The original root docfile is next
//       copied to the new root docfile via CopyTo() and the new root docfile 
//       is committed.  The CRC is computed for the new docfile and the CRCs 
//       are compared. If revert flag given, the new root docfile is reverted
//       instead of committed and the CRC of the new tree is compared
//       against the CRC of the empty tree.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LCROOT.CXX
// 2.  Old name of test : LegitCopyDFToRootDF Test 
//     New Name of test : VCPYTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-104
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-104
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-104
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//     d. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-104
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /revert 
//     e. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-104
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /revert
//
// BUGNOTE: Conversion: VCPYTEST-104
//
//-----------------------------------------------------------------------------

HRESULT VCPYTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    ChanceDF        *pNewTestChanceDF       = NULL;
    VirtualDF       *pNewTestVirtualDF      = NULL;
    VirtualCtrNode  *pNewVirtualDFRoot      = NULL;
    DG_STRING      *pdgu                   = NULL;
    LPSTORAGE       pStgRootFirstDF         = NULL;
    LPSTORAGE       pStgRootSecondDF        = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    BOOL            fPass                   = TRUE;
    CDFD            cdfd;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_104 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt copyto from one Root DocFile to new DocFile root")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_104, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close all  open stgs/stms except root

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    if ((S_OK == hr) && (FALSE == g_fRevert))
    {
        pStgRootFirstDF = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootFirstDF);

        hr = CalculateCRCForDocFile(
                pStgRootFirstDF,
                VERIFY_EXC_TOPSTG_NAME,
                &dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }
    
    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pNewRootDocFileName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Now Create a new DocFile with random name.

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pNewTestChanceDF = new ChanceDF();
        if(NULL == pNewTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = pTestChanceDF->GetSeed();
        cdfd.dwRootMode   = dwRootMode;

        hr = pNewTestChanceDF->Create(&cdfd, pNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("pNewTestChanceDF->Create"));
    }

    if (S_OK == hr)
    {
        pNewTestVirtualDF = new VirtualDF();
        if(NULL == pNewTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pNewTestVirtualDF->GenerateVirtualDF(
                pNewTestChanceDF, 
                &pNewVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pNewTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        pStgRootSecondDF = pNewVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootSecondDF);
        if(NULL == pStgRootSecondDF)
        {
            hr = E_FAIL;
        }
    }
    
    if((S_OK == hr) && (TRUE == g_fRevert))
    {
        hr = CalculateCRCForDocFile(
                pStgRootSecondDF,
                VERIFY_EXC_TOPSTG_NAME,
                &dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->CopyTo(0, NULL, NULL, pNewVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }
        
    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::CopyTo successful.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr) 
    {
        if(FALSE == g_fRevert)
        {
            // Commit the new Root Node

            hr = pNewVirtualDFRoot->Commit(STGC_DEFAULT);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("Child VirtualCtrNode::Commit successful.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Child VCN::Commit unsuccessful,hr=0x%lx"),
                    hr));
            }
        }
        else
        {
            // Revert the new root storage
                
            hr = pNewVirtualDFRoot->Revert();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;

            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("Child VirtualCtrNode::Revert successful.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Child VCN::Revert unsuccessful,hr=0x%lx"),
                    hr));
            }
        }
    }

    // Calculate CRC for the destination root storage now

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(
                pStgRootSecondDF,
                VERIFY_EXC_TOPSTG_NAME,
                &dwCRC2);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Verify CRC

    if((S_OK == hr) && (dwCRC1 == dwCRC2))
    {
        DH_TRACE((
           DH_LVL_TRACE1, 
           TEXT("CRC's of source docfile and dest docfile match.")));
    }
    else
    {
        fPass = FALSE;

        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("CRC's of source docfile and dest docfile don't match.")));
            
    }

    // Close first Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close second Root Docfile.

    if (S_OK == hr)
    {
        hr = pNewVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation VCPYTEST_104 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete Chance docfile tree for second DocFile

    if(NULL != pNewTestChanceDF)
    {
        hr2 = pNewTestChanceDF->DeleteChanceDocFileTree(
                pNewTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pNewTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pNewTestChanceDF;
        pNewTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree for second docfile

    if(NULL != pNewTestVirtualDF)
    {
        hr2 = pNewTestVirtualDF->DeleteVirtualDocFileTree(pNewVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pNewTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pNewTestVirtualDF;
        pNewTestVirtualDF = NULL;
    }

    // Delete the second docfile on disk

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_105 
//
// Synopsis: A random root DF is created with random storages/stms, committed .
//       Then CRC is computed for entire entire docfile.  A new root docfile 
//       with a random name is then created and a child storage is created
//       inside that.  The original root docfile is next copied to the child
//       storage of new root docfile via CopyTo() and the new child & root  
//       is committed.  The CRC is computed for child storage of new docfile 
//       and the CRCs are compared. If revert flag given, the new root docfile 
//       child stg is reverted instead of committed and the CRC of the new 
//       tree's child stg is compared against the CRC of the child stg before
//       revert.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  19-July-1996     NarindK     Created.
//
// Notes:    This test runs in transacted, and transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LCNEWPAR.CXX
// 2.  Old name of test : LegitCopyDFWithinNewPar Test 
//     New Name of test : VCPYTEST_105 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-105
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-105
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-105
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//     d. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-105
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /revert 
//     e. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-2 /t:VCPYTEST-105
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /revert
//
// BUGNOTE: Conversion: VCPYTEST-105
//
//-----------------------------------------------------------------------------

HRESULT VCPYTEST_105(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    ChanceDF        *pNewTestChanceDF       = NULL;
    VirtualDF       *pNewTestVirtualDF      = NULL;
    VirtualCtrNode  *pNewVirtualDFRoot      = NULL;
    VirtualCtrNode  *pvcnNewRootNewChildStg = NULL;
    DG_STRING      *pdgu                   = NULL;
    LPSTORAGE       pStgRootFirstDF         = NULL;
    LPTSTR          pNewRootDocFileName     = NULL;
    LPTSTR          pNewRootNewChildStgName = NULL;
    LPSTORAGE       pStgChildRootSecondDF   = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    BOOL            fPass                   = TRUE;
    CDFD            cdfd;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_105"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_105 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Do copyto fm one Root DocFile to new DocFile's child stg")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_105, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close all  open stgs/stms except root

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    if ((S_OK == hr) && (FALSE == g_fRevert))
    {
        pStgRootFirstDF = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootFirstDF);

        hr = CalculateCRCForDocFile(
                pStgRootFirstDF,
                VERIFY_EXC_TOPSTG_NAME,
                &dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }
    
    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pNewRootDocFileName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Now Create a new DocFile with random name.

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pNewTestChanceDF = new ChanceDF();
        if(NULL == pNewTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = pTestChanceDF->GetSeed();
        cdfd.dwRootMode   = dwRootMode;

        hr = pNewTestChanceDF->Create(&cdfd, pNewRootDocFileName);

        DH_HRCHECK(hr, TEXT("pNewTestChanceDF->Create"));
    }

    if (S_OK == hr)
    {
        pNewTestVirtualDF = new VirtualDF();
        if(NULL == pNewTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pNewTestVirtualDF->GenerateVirtualDF(
                pNewTestChanceDF, 
                &pNewVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pNewTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Create a new child storage in this new root docfile.

    if(S_OK == hr)
    {
        // Generate random name for this child stg 

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pNewRootNewChildStgName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pNewVirtualDFRoot,
                pNewRootNewChildStgName,
                dwStgMode | STGM_FAILIFTHERE,
                &pvcnNewRootNewChildStg);
    }

    if(S_OK == hr)
    {
       DH_TRACE((DH_LVL_TRACE1, TEXT("AddStorage successful.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("AddStorage unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        pStgChildRootSecondDF = pvcnNewRootNewChildStg->GetIStoragePointer();

        DH_ASSERT(NULL != pStgChildRootSecondDF);
        if(NULL == pStgChildRootSecondDF)
        {
            hr = E_FAIL;
        }
    }
    
    if((S_OK == hr) && (TRUE == g_fRevert))
    {
        hr = CalculateCRCForDocFile(
                pStgChildRootSecondDF,
                VERIFY_EXC_TOPSTG_NAME,
                &dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->CopyTo(0, NULL, NULL, pvcnNewRootNewChildStg);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::CopyTo")) ;
    }
        
    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::CopyTo successful.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::CopyTo unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr) 
    {
        if(FALSE == g_fRevert)
        {
            // Commit the new VirtualCtrNode and Root Node

            hr = pvcnNewRootNewChildStg->Commit(STGC_DEFAULT);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("Child VirtualCtrNode::Commit successful.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Child VCN::Commit unsuccessful,hr=0x%lx"),
                    hr));
            }

            if(S_OK == hr)
            {
                hr = pNewVirtualDFRoot->Commit(STGC_DEFAULT);

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

                if(S_OK == hr)
                {
                    DH_TRACE((
                        DH_LVL_TRACE1, 
                        TEXT("Root VirtualCtrNode::Commit successful.")));
                }
                else
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Root VCN::Commit unsuccessful,hr=0x%lx"),
                        hr));
                }
            }
        }
        else
        {
            // Revert the new child storage
                
            hr = pvcnNewRootNewChildStg->Revert();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;

            if(S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1, 
                    TEXT("Child VirtualCtrNode::Revert successful.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Child VCN::Revert unsuccessful,hr=0x%lx"),
                    hr));
            }
        }
    }

    // Calculate CRC for the destination storage now

    if(S_OK == hr)
    {
        hr = CalculateCRCForDocFile(
                pStgChildRootSecondDF,
                VERIFY_EXC_TOPSTG_NAME,
                &dwCRC2);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Verify CRC

    if((S_OK == hr) && (dwCRC1 == dwCRC2))
    {
        DH_TRACE((
           DH_LVL_TRACE1, 
           TEXT("CRC's of source docfile and dest docfile's stg match.")));
    }
    else
    {
        fPass = FALSE;

        DH_TRACE((
           DH_LVL_TRACE1, 
           TEXT("CRC's of source docfile &dest docfile's stg don't match.")));
            
    }

    // Close first Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Close second Root Docfile's child stg.

    if (S_OK == hr)
    {
        hr = pvcnNewRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."), 
            hr));
    }

    // Close second Root Docfile.

    if (S_OK == hr)
    {
        hr = pNewVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_105 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation VCPYTEST_105 failed, hr=0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete Chance docfile tree for second DocFile

    if(NULL != pNewTestChanceDF)
    {
        hr2 = pNewTestChanceDF->DeleteChanceDocFileTree(
                pNewTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pNewTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pNewTestChanceDF;
        pNewTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree for second docfile

    if(NULL != pNewTestVirtualDF)
    {
        hr2 = pNewTestVirtualDF->DeleteVirtualDocFileTree(pNewVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pNewTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pNewTestVirtualDF;
        pNewTestVirtualDF = NULL;
    }

    // Delete the second docfile on disk

    if((S_OK == hr) && (NULL != pNewRootDocFileName))
    {
        if(FALSE == DeleteFile(pNewRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings

    if(NULL != pNewRootDocFileName)
    {
        delete pNewRootDocFileName;
        pNewRootDocFileName = NULL;
    }

    if(NULL != pNewRootNewChildStgName)
    {
        delete pNewRootNewChildStgName;
        pNewRootNewChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_105 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    VCPYTEST_106 
//
// Synopsis: A root docfile is created and two streams are created within it,
//           a SOURCE IStream and a DEST IStream. A clone is made of the DEST
//           IStream. A random number of bytes are written to the SOURCE
//           IStream.
//           From 10 to 20 times, a random starting position and number of
//           bytes to copy is chosen in the SOURCE IStream.  These bytes are
//           read and CRC'd and the SOURCE IStream seek pointer is then
//           repositoned to the intended copy source offset. A random copy
//           destination offset is chosen in either the DEST or CLONE IStream.
//           The non-target regions of the destination IStream (those bytes
//           before and after the copy target region) are read and CRC'd
//           and the destination seek pointer is re-positioned to the
//           destination offset.  The SOURCE IStream region is then copied to
//           destination (DEST or CLONE) IStream.  The entire destination
//           stream is then read and CRCs are verified to ensure that the copy
//           was successful.
//          
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File(s): LCSTREAM.CXX
// 2.  Old name of test(s) : LegitCopyStream test 
//     New Name of test(s) : VCPYTEST_106 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:VCPYTEST-106
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:VCPYTEST-106
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:VCPYTEST-106
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: VCPYTEST-106
//
// History:  Jiminli	24-July-96	Created
//-----------------------------------------------------------------------------
 
HRESULT VCPYTEST_106(int argc, char *argv[])
{

    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          ptcsBuffer              = NULL;
    LPBYTE          ptcsReadBuffer          = NULL;
    USHORT          usNumIterations         = 0;
    USHORT          usMinIteration          = 10;
    USHORT          usMaxIteration          = 20;
    ULONG           culBytesLeftToWrite     = 0;
    ULONG           culBytesRead            = 0;
    ULONG           ulIStreamSize           = 0;
    ULONG           culIOBytes              = 0;
    ULONG           culWritten              = 0; 
    ULONG           culRead                 = 0;
    ULONG           culRandomCommit         = 0;
    ULONG           ulRef                   = 0;
    DWORD           dwRootMode              = 0; 
    DWORD           dwCRC[3][3];
    DWORD           dwTempCRC               = 0; 
    DWORD           dwSourceCRC             = 0;
    BYTE            biIStream               = 0;
    BYTE            biInUse                 = 0;
    BOOL            fPass                   = TRUE; 
    ULONG           ulPosition[3];
    ULONG           ulNewPosition[3];
    VirtualStmNode  *pvsnRootNewChildStream[2];        
    LPTSTR          pRootNewChildStmName[2];
    LPSTREAM        pIStream[3];
    LARGE_INTEGER   liStreamPos;
    ULARGE_INTEGER  uliCopy;
    ULARGE_INTEGER  uli;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("VCPYTEST_106"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_106 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Attempt valid CopyTo operation b/w streams.")) );

    // Initialize pointers
    pIStream[SOURCESTM] = pIStream[DESTSTM] = pIStream[CLONESTM] = NULL;
    pRootNewChildStmName[SOURCESTM] = pRootNewChildStmName[DESTSTM] = NULL;
    pvsnRootNewChildStream[SOURCESTM] = pvsnRootNewChildStream[DESTSTM] = NULL;

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for VCPYTEST_106, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu) ;
        if(NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
        if(NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    // Adds source and destination IStreams to the root storage.

    if (S_OK == hr)
    {
        // Generate random names for streams

        for (biIStream=SOURCESTM; biIStream <= DESTSTM; biIStream++)
        {
            pRootNewChildStmName[biIStream] = NULL;
            hr = GenerateRandomName(
                    pdgu, 
                    MINLENGTH, 
                    MAXLENGTH, 
                    &pRootNewChildStmName[biIStream]);

            if(S_OK != hr)
            {
                break;
            }
        }

        DH_HRCHECK(hr, TEXT("GenerateRandomName"));
    }

    if (S_OK == hr)
    {
        for (biIStream=SOURCESTM; biIStream <= DESTSTM; biIStream++)
        {
            // Initialize

            pIStream[biIStream] = NULL;
            ulPosition[biIStream] = 0L;

            hr = AddStream(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootNewChildStmName[biIStream],
                    0,
                    STGM_READWRITE  |
                    STGM_SHARE_EXCLUSIVE |
                    STGM_FAILIFTHERE,
                    &pvsnRootNewChildStream[biIStream]);

            if(S_OK != hr)
            {
                break;
            }

            // Get IStream pointers

            if(S_OK == hr)
            {
                pIStream[biIStream] = pvsnRootNewChildStream[biIStream]->
                                        GetIStreamPointer();
            }
        }

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }
    
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    // 
    // Generate Cloned IStream

    if(S_OK == hr)
    {
        hr = pvsnRootNewChildStream[SOURCESTM]->Clone(&pIStream[CLONESTM]);
        ulPosition[CLONESTM] = 0L;

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Clone")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Clone completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Clone not successful, hr=0x%lx."),
            hr));
    }

    // Pick a size for the source IStream

    if (S_OK == hr)
    {
        // Generate random size for stream between 1L, and MIN_SIZE * 1.5
        // (from old test)

        usErr = pdgi->Generate(&ulIStreamSize, 1L,  (ULONG) (MIN_SIZE * 1.5));
        culIOBytes = ulIStreamSize;

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
 
    // Call VirtualStmNode::Write to create random bytes in the stream.  
    // For our test purposes, we generate a random string of size 
    // culIOBytes using GenerateRandomString function.
 
    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu, 
                culIOBytes,
                culIOBytes, 
                &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream[SOURCESTM]->Write(
                (LPBYTE)ptcsBuffer,
                culIOBytes,
                &culWritten);
    }

    if (S_OK != hr)
    { 
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Write wasn't successful, hr=0x%lx."),
            hr));
    }

    // Calculate dwSourceCRC to be used in the first pass of the loop

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                ptcsBuffer,
                culIOBytes,
                &dwSourceCRC);
    }

    if (S_OK != hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("CalculateCRCForDataBuffer wasn't successful, hr=0x%lx."),
            hr));
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }
    
    // Commit root. BUGBUG: Use random modes

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit wasn't successfully, hr=0x%lx."),
            hr));
    }

    // Reposition to start offset of the source IStream

    if (S_OK == hr)
    {
        memset(&liStreamPos, ulPosition[SOURCESTM], sizeof(LARGE_INTEGER));

        hr = pvsnRootNewChildStream[SOURCESTM]->Seek(
                liStreamPos, 
                STREAM_SEEK_SET, 
                NULL);
        
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Seek not successful, hr=0x%lx."),
            hr));
    }

    // For the first pass of the loop, we'll specify that the DEST IStream
    // (as opposed to the CLONE) IStream will be the copy destination.
    // Also, for the first pass, we'll copy the whole source IStream to 
    // dest/clone IStream, so the length of bytes before/after CopyTo both
    // are 0L, i.e. ulPosition[biInUse].

    biInUse = DESTSTM;
    
    if (S_OK == hr)
    {
        // Generate random # of small objects for test between 
        // usMinIteration and usMaxIteration 

        usErr = pdgi->Generate(
                    &usNumIterations, 
                    usMinIteration, 
                    usMaxIteration);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
    
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Random # of small objects to test is: %d"),
            usNumIterations));
    }

    // Before doing a copy, we read and CRC the bytes in the destinaiton
    // IStream(DEST or CLONE) that *won't* be overwritten by the copy
    // call because we'll later need to ensure that these bytes weren't
    // inadvertently changed by the copy - because that would be a bug.

    while ((S_OK == hr) && (0 != usNumIterations))
    {
        // ***BEFORE COPY***

        // Read & CRC bytes in dest/clone before intended CopyTo() start
        // Offset
           
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
        hr = pIStream[biInUse]->Seek(liStreamPos, STREAM_SEEK_SET, NULL);
   
        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            culBytesRead = ulIStreamSize;
            ptcsReadBuffer = new BYTE[culBytesRead];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culBytesRead * sizeof(BYTE));

            hr = pIStream[biInUse]->Read(
                    ptcsReadBuffer,
                    ulPosition[biInUse],
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwCRC[biInUse][BYTES_BEFORE]);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CalculateCRCForDataBuffer not successful, hr=0x%lx."),
                hr));
        }

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        // read & CRC bytes in dest/clone after intended CopyTo() start offset

        if (S_OK == hr)
        {
            LISet32(liStreamPos, (ulPosition[biInUse] + culIOBytes));

            hr = pIStream[biInUse]->Seek(
                    liStreamPos, 
                    STREAM_SEEK_SET, 
                    NULL);
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            culBytesRead = ulIStreamSize;
            ptcsReadBuffer = new BYTE[culBytesRead];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culBytesRead * sizeof(BYTE));

            hr = pIStream[biInUse]->Read(
                    ptcsReadBuffer,
                    culBytesRead,
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwCRC[biInUse][BYTES_AFTER]);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CalculateCRCForDataBuffer not successful, hr=0x%lx."),
                hr));
        }

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        // Position to dest/clone intended start offset, ready for CopyTo().

        if (S_OK == hr)
        {
            LISet32(liStreamPos, ulPosition[biInUse]);
            hr = pIStream[biInUse]->Seek(liStreamPos, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful, hr=0x%lx."),
                hr));
        }

        // Copy from current position of SOURCE IStream to the specified 
        // position in the dest/clone IStream

        if (S_OK == hr)
        {
            ULISet32(uliCopy, culIOBytes);

            hr = pIStream[SOURCESTM]->CopyTo(
                    pIStream[biInUse],
                    uliCopy,
                    NULL,
                    NULL);
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::CopyTo not successful, hr=0x%lx."),
                hr));
        }

        // For variety, only commit to the root 50% of the time

        if (S_OK == hr)
        {
            usErr = pdgi->Generate(&culRandomCommit, 1, 100);

            if (DG_RC_SUCCESS != usErr)
            {
               hr = E_FAIL;
            }
        }

        if ((S_OK == hr) && (culRandomCommit > 50))
        {
            hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit wasn't successfully, hr=0x%lx."),
                hr));
        }

        // ***AFTER COPY***

        // After the copy, verify that the source and destination seek pointers
        // are set correctly

        if (S_OK == hr)
        {
            memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
            hr = pIStream[SOURCESTM]->Seek(liStreamPos, STREAM_SEEK_CUR, &uli);

            ulNewPosition[SOURCESTM] = ULIGetLow(uli);
        }

        if (S_OK != hr)
        {         
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful, hr=0x%lx."),
                hr));
        }
        
        if ((S_OK == hr) && 
            (ulNewPosition[SOURCESTM] != (ulPosition[SOURCESTM] + culIOBytes)))
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Source seek pointer incorrect after copy.")));

            fPass = FALSE;
        }

        if (S_OK == hr)
        {
            memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
            hr = pIStream[biInUse]->Seek(liStreamPos, STREAM_SEEK_CUR, &uli);

            ulNewPosition[biInUse] = ULIGetLow(uli);
        }

        if (S_OK != hr)
        {         
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful, hr=0x%lx."),
                hr));
        }

        if ((S_OK == hr) && 
            (ulNewPosition[biInUse] != (ulPosition[biInUse] + culIOBytes)))
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Destination seek pointer incorrect after copy.")));

            fPass = FALSE;
        }

        // After copy, read & CRC bytes in dest/clone before CopyTo() start 
        // offset and compare CRCs to ensure that these bytes haven't changed

        if (S_OK == hr)
        {
            memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
            hr = pIStream[biInUse]->Seek(liStreamPos, STREAM_SEEK_SET, NULL);
        }

        if (S_OK != hr)
        { 
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Seek not successful, hr=0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            culBytesRead = ulIStreamSize;
            ptcsReadBuffer = new BYTE[culBytesRead];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culBytesRead * sizeof(BYTE));

            hr = pIStream[biInUse]->Read(
                    ptcsReadBuffer,
                    ulPosition[biInUse],
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwTempCRC);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CalculateCRCForDataBuffer not successful, hr=0x%lx."),
                hr));
        }

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        if (dwCRC[biInUse][BYTES_BEFORE] != dwTempCRC)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC mismatched at bytes before CopyTo start offset.")));

            fPass = FALSE;
        }

        // Read & CRC bytes in dest/clone that were target of CopyTo()

        if (S_OK == hr)
        {
            culBytesRead = culIOBytes;
            ptcsReadBuffer = new BYTE[culBytesRead];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culBytesRead * sizeof(BYTE));

            hr = pIStream[biInUse]->Read(
                    ptcsReadBuffer,
                    culBytesRead,
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwCRC[biInUse][BYTES_COPIED]);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CalculateCRCForDataBuffer not successful, hr=0x%lx."),
                hr));
        }

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        if (dwCRC[biInUse][BYTES_COPIED] != dwSourceCRC)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC mismatched at bytes of CopyTo() target.")));

            fPass = FALSE;
        }

        // Read & CRC bytes in dest/clone after CopyTo() start offset

        if (S_OK == hr)
        {
            culBytesRead = ulIStreamSize;
            ptcsReadBuffer = new BYTE[culBytesRead];

            if (NULL == ptcsReadBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    
        if (S_OK == hr)
        {
            memset(ptcsReadBuffer, '\0', culBytesRead * sizeof(BYTE));

            hr = pIStream[biInUse]->Read(
                    ptcsReadBuffer,
                    culBytesRead,
                    &culRead);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStream::Read wasn't successful, hr=0x%lx."),
                hr));
        }

        // culRead is the actual number of bytes read from IStream
 
        if (S_OK == hr)
        {
            hr = CalculateCRCForDataBuffer(
                    (LPTSTR)ptcsReadBuffer,
                    culRead,
                    &dwTempCRC);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CalculateCRCForDataBuffer not successful, hr=0x%lx."),
                hr));
        }

        if (NULL != ptcsReadBuffer)
        {
            delete []ptcsReadBuffer;
            ptcsReadBuffer = NULL;
        }

        if (dwCRC[biInUse][BYTES_AFTER] != dwTempCRC)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC mismatched at bytes after CopyTo() target.")));

            fPass = FALSE;
        }

        if (--usNumIterations)
        {
            // if we'll be looping again, pick a random copy starting position
            // in the source IStream and a random number of bytes to copy.

            if (S_OK == hr)
            {
                usErr = pdgi->Generate(
                            &ulPosition[SOURCESTM], 
                            0L, 
                            ulIStreamSize);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }

            if (S_OK == hr)
            {		
                if((ulIStreamSize - ulPosition[SOURCESTM]) > 0)
                {
                    usErr = pdgi->Generate(
                            &culIOBytes, 
                            1L, 
                            ulIStreamSize - ulPosition[SOURCESTM]);
                }
                else
                {
                    culIOBytes = 1L; 
                }

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }

            // Now seek, read and CRC the source bytes and then seek back to
            // the intended copy start position

            if (S_OK == hr)
            {
                LISet32(liStreamPos, ulPosition[SOURCESTM]);

                hr = pIStream[SOURCESTM]->Seek(
                        liStreamPos, 
                        STREAM_SEEK_SET, 
                        NULL);
            }

            if (S_OK != hr)
            { 
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream::Seek not successful, hr=0x%lx."),
                    hr));
            }

            if (S_OK == hr)
            {
                culBytesRead = culIOBytes;
                ptcsReadBuffer = new BYTE[culBytesRead];

                if (NULL == ptcsReadBuffer)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
    
            if (S_OK == hr)
            {
                memset(ptcsReadBuffer, '\0', culBytesRead * sizeof(BYTE));

                hr = pIStream[SOURCESTM]->Read(
                        ptcsReadBuffer,
                        culIOBytes,
                        &culRead);
            }

            if (S_OK != hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream::Read wasn't successful, hr=0x%lx."),
                    hr));
            }

            // culRead is the actual number of bytes read from IStream
 
            if (S_OK == hr)
            {
                hr = CalculateCRCForDataBuffer(
                        (LPTSTR)ptcsReadBuffer,
                        culRead,
                        &dwSourceCRC);
            }

            if (S_OK != hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("CalculateCRCForDataBuffer not Ok, hr=0x%lx."),
                    hr));
            }

            if (NULL != ptcsReadBuffer)
            {
                delete []ptcsReadBuffer;
                ptcsReadBuffer = NULL;
            }

            if (S_OK == hr)
            {
                LISet32(liStreamPos, ulPosition[SOURCESTM]);

                hr = pIStream[SOURCESTM]->Seek(
                        liStreamPos, 
                        STREAM_SEEK_SET, 
                        NULL);
            }

            if (S_OK != hr)
            { 
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("IStream::Seek not successful, hr=0x%lx."),
                    hr));
            }

            // Pick an IStream for the copy destination and a destination
            // offset within that IStream

            if (S_OK == hr)
            {
                usErr = pdgi->Generate(&biInUse, DESTSTM, CLONESTM);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }

            if (S_OK == hr)
            {
                usErr = pdgi->Generate(&ulPosition[biInUse], 0L, ulIStreamSize);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }
        }

        if ((S_OK != hr) || (TRUE != fPass))
        { 
            break;
        }
    }

    // Release Clone stream

    if (NULL != pIStream[CLONESTM])
    {
        ulRef = pIStream[CLONESTM]->Release();

        DH_ASSERT(0 == ulRef);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Close unsuccessful.")));
    }

    // Release all streams, irrespective of result

    if (S_OK == hr)
    {
        for (biIStream=SOURCESTM; biIStream <= DESTSTM; biIStream++)
        {
            hr = pvsnRootNewChildStream[biIStream]->Close();

            if (S_OK == hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::Close completed successfully.")));
            }
            else
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
                    hr));
            }
        }
    }

    // Release Root

    if (NULL != pVirtualDFRoot)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
        }
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation VCPYTEST_106 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
              TEXT("Test variation VCPYTEST_106 failed, hr=0x%lx."),
              hr));
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    for (biIStream=SOURCESTM; biIStream <= DESTSTM; biIStream++)
    {
        if (NULL != pRootNewChildStmName[biIStream])
        {
            delete pRootNewChildStmName[biIStream];
            pRootNewChildStmName[biIStream] = NULL;
        }
    }

    // Stop logging the test

	DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation VCPYTEST_106 finished")) );
	DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\util.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       utl.cxx
//
//  Contents:   utilities for OLE storage base tests
//
//  Functions:   
//
//  History:    NarindK     Created.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include "init.hxx"

//global array of interesting file sizes for IStream read/writes

USHORT ausSIZE_ARRAY[] =
    {0,1,2,255,256,257,511,512,513,2047,2048,2049,4095,4096,4097};

// externs
extern BOOL g_fUseStdBlk;
extern  ULONG           ulStreamSize;
extern  USHORT          usIterations;
extern  LPTSTR          ptszNames[MAX_DOCFILES];
extern  ULONG           *ulSeekOffset;
extern  TIMEINFO        Time[];

//----------------------------------------------------------------------------
//
// Function: CountFilesInDirectory
//
// Synopsis: count number of files in directory matching wildcard mask
//
// Arguments: [pszWildMask] - wild card mask string of files to find
//
// Returns: number of files found
//
// History: 2-Jul-1996   Narindk   Created
//
//-----------------------------------------------------------------------------

ULONG CountFilesInDirectory(LPTSTR  ptszWildMask)
{
#ifdef _MAC
    DH_LOG((
           LOG_INFO,
           TEXT("!!!!!!!!!!!!!!CountFilesInDirectory not implemented yet.\n")));
      return 0;
#else
    
    ULONG           culFilesInDirectory     = 0;
    DWORD           cChar                   = 0;
    HANDLE          hFind                   = NULL;
    TCHAR           ptszTmpFileDir[_MAX_PATH];
    TCHAR           ptszTmpFilePath[_MAX_PATH];
    WIN32_FIND_DATA wfd;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CountFilesInDirectory"));

    cChar = GetEnvironmentVariable(
                TEXT("TMP"), 
                ptszTmpFileDir, 
                sizeof(ptszTmpFileDir));

    DH_ASSERT(0 != cChar);

    if (0 != cChar)
    {
        _tcscpy(ptszTmpFilePath, ptszTmpFileDir);
        _tcscat(ptszTmpFilePath, TEXT("\\"));
    }
    else
    {
        _tcscpy(ptszTmpFilePath, TEXT("C:\\"));
    }

    _tcscat(ptszTmpFilePath, ptszWildMask);

    DH_LOG((
        LOG_INFO,
        TEXT("Counting %s files in %s directory\n"),
        ptszWildMask,
        ptszTmpFileDir == NULL ? TEXT("C:\\") : ptszTmpFileDir));

    hFind = FindFirstFile(ptszTmpFilePath, &wfd);

    if(INVALID_HANDLE_VALUE != hFind)
    {
        do
        {
            if(wfd.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE)
            {
                culFilesInDirectory++;
            }
        } while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }

    DH_LOG((
        LOG_INFO,
        TEXT("Number of %s files in %s directory = %lu\n"),
        ptszWildMask,
        ptszTmpFileDir == NULL ? TEXT("C:\\") : ptszTmpFileDir,
        culFilesInDirectory));

    return culFilesInDirectory;
#endif //_MAC
}

//----------------------------------------------------------------------------
//
// Function: GetRandomSeekOffset 
//
// Synopsis: Gets a random seek offset from either standard array or a random
//           number 
//
// Arguments: [plSeekPosition] - Pointer to seek position
//            [pdgi]           - Pointer to data generator object
//
// Returns: HResult 
//
// History: 5-Jul-1996    Narindk  Created
//
//-----------------------------------------------------------------------------

HRESULT GetRandomSeekOffset(LONG  *plSeekPosition, DG_INTEGER *pdgi)
{
    HRESULT hr              =   S_OK;
    ULONG   cArrayIndex     =   0;
    USHORT  usErr           =   0;
    LONG    lSeekPosition   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GetRandomSeekOffset"));

    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(plSeekPosition, LONG ) ;

    DH_ASSERT(NULL != pdgi);

    if(TRUE == g_fUseStdBlk)
    {
       // Pick up a random array element.

        usErr = pdgi->Generate(&cArrayIndex, 0, MAX_SIZE_ARRAY);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        else
        {
            *plSeekPosition = *plSeekPosition + ausSIZE_ARRAY[cArrayIndex];
        }
    }
    else
    {
        // Pick up a random offset
        usErr = pdgi->Generate(
                     &lSeekPosition,
                     0,
                     ausSIZE_ARRAY[MAX_SIZE_ARRAY] * MAX_SIZE_MULTIPLIER );

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        else
        {
            *plSeekPosition = *plSeekPosition + lSeekPosition;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// Function: SetItemsInStorage 
//
// Synopsis: Does random SetClass / SetStateBits/ Commit / Revert operations
//          on passed IStorage.
//
// Arguments: [pvcn] - Pointer to VirtualCtrNode 
//            [pdgi] - Pointer to data generator object
//
// Returns: HResult 
//
// History: 15-Jul-1996   Narindk   Created
//
//-----------------------------------------------------------------------------

HRESULT SetItemsInStorage(VirtualCtrNode *pvcn, DG_INTEGER *pdgi)
{
    HRESULT hr                  =   S_OK;
    USHORT  usErr               =   0;
    ULONG   cRandomVar          =   0;
    ULONG   cRandomClsid        =   0;
    ULONG   cMinVar             =   16;
    ULONG   cMaxVar             =   32;
    DWORD   grfStateBits        =   0;
    DWORD   grfMask             =   0;
    DWORD   grfDesiredStateBits =   0;
    BOOL    fStateBitsChanged   =   FALSE;
    BOOL    fPass               =   TRUE;
    STATSTG statStgCommited;
    STATSTG statStgCurrent;
    STATSTG statStgNew;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("SetItemsInStorage"));

    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdgi);

    if (S_OK == hr)
    {
        // Generate random number of variations.

        usErr = pdgi->Generate(&cRandomVar, cMinVar, cMaxVar);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    //initialize STATSTG containing info about what is on persistent store

    if(S_OK == hr)
    {
        hr = pvcn->Stat(&statStgCommited, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
           LOG_INFO,
           TEXT("VirtualCtrNode::Stat completed successfully.\n")));
    }
    else
    {
        DH_LOG((
           LOG_INFO,
           TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx.\n"),
           hr));
    }

    // Start while loop

    while((S_OK == hr) && (0 != cRandomVar))
    {
        if(S_OK == hr)
        {
            hr = pvcn->Stat(&statStgCurrent, STATFLAG_NONAME);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        }

        if(S_OK == hr)
        {
            // Randomly either change the CLSID or State Bits.

            if(0 == cRandomVar%2)
            {
                usErr = pdgi->Generate(&cRandomClsid, 1, 3);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
               
                if(S_OK == hr)
                {
                    // Call Set Class to change CLSID

                    switch(cRandomClsid)
                    {
                        case 1:
                        {
                            hr = pvcn->SetClass(IID_IUnknown); 
                            
                            break;
                        }
                        case 2:
                        {
                            hr = pvcn->SetClass(IID_IStorage); 
                            
                            break;
                        }
                        case 3:
                        {
                            hr = pvcn->SetClass(IID_IStream); 
                            
                            break;
                        }
                    }

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::SetClass")) ;
                }
            }
            else 
            {
                // Set boolean to true indicatinng changing state bits

                fStateBitsChanged = TRUE;

                usErr = pdgi->Generate(&grfStateBits, 0, ULONG_MAX);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
              
                if(S_OK == hr)
                {
                    usErr = pdgi->Generate(&grfMask, 0, ULONG_MAX);

                    if (DG_RC_SUCCESS != usErr)
                    {
                        hr = E_FAIL;
                    }
                }

                if(S_OK == hr)
                {
                    grfDesiredStateBits = (grfStateBits & grfMask) |
                                    (statStgCurrent.grfStateBits & ~grfMask); 

                    // Call SetStateBits to change State Bits

                    hr = pvcn->SetStateBits(grfStateBits, grfMask); 

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::SetStateBits")) ;
                }
            }
        }

        if(S_OK == hr)
        {
            // Get information about new state

            hr = pvcn->Stat(&statStgNew, STATFLAG_NONAME);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
        }

        // Verify the new State

        // Verify state bits

        if((S_OK == hr) && (TRUE == fStateBitsChanged))
        {
            if(statStgNew.grfStateBits != grfDesiredStateBits)
            {
                fPass = FALSE;

                DH_LOG((
                    LOG_INFO,
                    TEXT("State Bits not changed correctly.\n")));

                DH_LOG((
                    LOG_INFO,
                    TEXT("State Bits Actual: 0x%lx, Exp: 0x%lx.\n"),
                    statStgNew.grfStateBits,
                    grfDesiredStateBits));
            }
            else
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("State Bits changed correctly.\n")));

                DH_LOG((
                    LOG_INFO,
                    TEXT("State Bits Actual: 0x%lx, Exp: 0x%lx.\n"),
                    statStgNew.grfStateBits,
                    grfDesiredStateBits));
            }
        }

        // Verify CLSID
    
        if(S_OK == hr)
        {
            switch(cRandomClsid)
            {
                case 1:
                {
                    if(!IsEqualCLSID(statStgNew.clsid, IID_IUnknown))
                    {
                        fPass = FALSE;

                        DH_LOG((
                            LOG_INFO,
                            TEXT("SetClass didn't set CLSID IID_IUnknown.\n")));
                    }
                    else
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("SetClass set CLSID to IID_IUnknown.\n")));
                    }

                    break;
                }
                case 2:
                {
                    if(!IsEqualCLSID(statStgNew.clsid, IID_IStorage))
                    {
                        fPass = FALSE;

                        DH_LOG((
                            LOG_INFO,
                            TEXT("SetClass didn't set CLSID IID_IStorage.\n")));
                    }
                    else
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("SetClass set CLSID to IID_IStorage.\n")));
                    }
                    break;
                }
                case 3:
                {
                    if(!IsEqualCLSID(statStgNew.clsid, IID_IStream))
                    {
                        fPass = FALSE;

                        DH_LOG((
                            LOG_INFO,
                            TEXT("SetClass didn't set CLSID IID_IStream.\n")));
                    }
                    else
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("SetClass set CLSID to IID_IStream.\n")));
                    }
                    break;
                }
            }
        }

        // Modify hr if required based on fPass Value so that we can fall
        // out of this loop in error.

        if((S_OK == hr) && (FALSE == fPass))
        {
            hr = S_FALSE;
        }

        // Do random commit or revert operations and verify the State then

        if(S_OK == hr)
        {
            // Randomly either commit or Revert.

            if(0 == cRandomVar%2)
            {
                // Commit the changes

                DH_LOG((
                    LOG_INFO,
                    TEXT("Random Commit operation chosen.\n")));
    
                hr = pvcn->Commit(STGC_DEFAULT);

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

                if(S_OK == hr)
                {
                    // Store the information in statStgCommited

                    hr = pvcn->Stat(&statStgCommited, STATFLAG_NONAME);

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;

                }
            }
            else if(statStgNew.grfMode & STGM_TRANSACTED)
            {
                // Revert the changes

                DH_LOG((
                    LOG_INFO,
                    TEXT("Random Revert operation chosen.\n")));

                hr = pvcn->Revert();

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert")) ;

                // Do Stat

                if(S_OK == hr)
                {
                    hr = pvcn->Stat(&statStgNew, STATFLAG_NONAME);

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
                }

                // Verify values after Revert

                if(S_OK == hr)
                {
                    if(statStgNew.grfStateBits != statStgCommited.grfStateBits)
                    {
                        fPass = FALSE;

                        DH_LOG((
                            LOG_INFO,
                            TEXT("State Bits after Revert not correct.\n")));

                        DH_LOG((
                            LOG_INFO,
                            TEXT("State Bits Actual: 0x%lx, Exp: 0x%lx.\n"),
                            statStgNew.grfStateBits,
                            statStgCommited.grfStateBits));
                    }
                    else
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("State Bits after Revert correct.\n")));
                    }

                    if(!IsEqualCLSID(statStgNew.clsid, statStgCommited.clsid))
                    {
                        fPass = FALSE;

                        DH_LOG((
                            LOG_INFO,
                            TEXT("CLSID after Revert not correct.\n")));
                    }
                    else
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("CLSID after Revert correct.\n")));
                    }
                }

                // Modify hr if reqd based on fPass Value so that we can fall
                // out of this loop in error.

                if((S_OK == hr) && (FALSE == fPass))
                {
                    hr = S_FALSE;
                }
            }
        }

        // Reset the variables

        fStateBitsChanged = FALSE; 
        cRandomClsid = 0;
   
        // Decrement counter
 
        cRandomVar--;
    }

    return hr;
}


//----------------------------------------------------------------------------
//
// Function: EnumerateDocFileInRandomChunks 
//
// Synopsis: Enumerate DocFile in Random chunks and counts all the objects in
//           DocFile 
//
// Arguments: [pvcn] - Pointer to VirtualCtrNode 
//            [pdgi] - Pointer to data generator object
//            [dwStgMode] - Mode for storage objects
//            [uNumObjs] - Max number of objs in DocFile to choose random 
//                         chunk number from
//            [pNumStg] - Out paramemter - Pointer to number of storages enum
//            [pNumStm] - Out paramemter - Pointer to number of streams enum
//
// Returns: HResult 
//
// History: 23-Jul-1996   Narindk   Created
//
//-----------------------------------------------------------------------------

HRESULT EnumerateDocFileInRandomChunks(
    VirtualCtrNode  *pvcn,
    DG_INTEGER      *pdgi,  
    DWORD           dwStgMode,
    ULONG           uNumObjs,
    ULONG           *pNumStg,
    ULONG           *pNumStm )
{
    HRESULT         hr                  =   S_OK;
    ULONG           cChildStg           =   0;
    ULONG           cChildStm           =   0;
    USHORT          usErr               =   0;  
    ULONG           cRandomObjs         =   0;
    VirtualCtrNode  *pvcnTrav           =   NULL;
    LPENUMSTATSTG   lpEnumStatStg       =   NULL;
    LPMALLOC        pMalloc             =   NULL;
    ULONG           celtFetched         =   0;
    STATSTG         *pstatStgEnum       =   NULL;
    ULONG           ulRef               =   0;
    ULONG           counter             =   0;
    LPTSTR          ptszStatStgEnumName =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("EnumerateDocFileInRandomChunks"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    DH_VDATEPTROUT(pdgi, DG_INTEGER) ;
    DH_VDATEPTROUT(pNumStg, ULONG) ;
    DH_VDATEPTROUT(pNumStm, ULONG) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pNumStg);
    DH_ASSERT(NULL != pNumStm);

    if(S_OK == hr)
    {
        // Count the storage passed in.

        *pNumStg = 1;
        *pNumStm = 0;

        // Get enumerator 

        hr = pvcn->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Get random number of objects to be asked from through Next

    if(S_OK == hr)
    {
        // Generate random number 

        usErr = pdgi->Generate(&cRandomObjs, 1, uNumObjs);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Allocate memory for STATSTG strcuture

    if(S_OK == hr)
    {
        pstatStgEnum = (STATSTG *) new STATSTG [cRandomObjs];
        
        if(NULL == pstatStgEnum)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // if successful to get enumerator, get the random element of the 
    // enumeration sequence.

    if(S_OK == hr)
    {
        hr = lpEnumStatStg->Next(cRandomObjs, pstatStgEnum, &celtFetched);

        if(S_FALSE == hr)
        {
            hr = S_OK;
        }
    }

    while(0 < celtFetched)
    {
        for (counter = 0; counter < celtFetched; counter++)
        {
            if (STGTY_STORAGE == pstatStgEnum[counter].type)
            {
                hr = OleStringToTString(
                        pstatStgEnum[counter].pwcsName,
                        &ptszStatStgEnumName);

                // Find the respective VirtualCtrNode with the name and recurse
                // into it after opening it.
           
                if(S_OK == hr)
                { 
                    pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();

                    while((NULL != pvcnTrav) &&
                          ( 0 != _tcscmp(
                                    ptszStatStgEnumName, 
                                    pvcnTrav->GetVirtualCtrNodeName())))
                    {
                        pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
                    } 

                    DH_ASSERT(NULL != pvcnTrav);

                    if(NULL != pvcnTrav)
                    {
                        hr = pvcnTrav->Open(NULL, dwStgMode, NULL, 0);
                    }
                }

                // Delete temp string
                
                if(NULL != ptszStatStgEnumName)
                {
                    delete ptszStatStgEnumName;
                    ptszStatStgEnumName = NULL;
                }

                if(S_OK == hr)
                {
                    hr = EnumerateDocFileInRandomChunks(
                            pvcnTrav, 
                            pdgi, 
                            dwStgMode, 
                            uNumObjs, 
                            &cChildStg, 
                            &cChildStm);
                }

                if(S_OK == hr)
                {
                    hr = pvcnTrav->Close();
                }
 
                // Update number of nodes on basis of child nodes as found

                if(0 != cChildStg)
                {
                    *pNumStg = *pNumStg + cChildStg;
                }

                if(0 != cChildStm)
                {
                    *pNumStm = *pNumStm + cChildStm;
                }

            }
            else
            if (STGTY_STREAM == pstatStgEnum[counter].type)
            {
                (*pNumStm)++;
            }
            else
            // The element is neither IStorage nor IStream, report error.
            {
                hr = E_UNEXPECTED;
            }

            // Clean up

            if(NULL != pstatStgEnum[counter].pwcsName)
            {
                pMalloc->Free(pstatStgEnum[counter].pwcsName);
                pstatStgEnum[counter].pwcsName = NULL;
            }

            // Break out of loop in error

            if(S_OK != hr)
            {
                break;
            }
        }

        // Get the next random elements from the enumeration sequence

        if(S_OK == hr)
        {
            // Generate random number.

            usErr = pdgi->Generate(&cRandomObjs, 1, uNumObjs);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }
        
        if (NULL != pstatStgEnum)
        {
            delete [] pstatStgEnum;
            pstatStgEnum = NULL;
        }

        if(S_OK == hr)
        {
            pstatStgEnum = (STATSTG *) new STATSTG [cRandomObjs];
        
            if(NULL == pstatStgEnum)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if(S_OK == hr)
        {
            hr = lpEnumStatStg->Next(cRandomObjs, pstatStgEnum, &celtFetched);

            if(S_FALSE == hr)
            {
                hr = S_OK;
            }
        }

        // Reinitialize the variables

        cChildStg = 0;
        cChildStm = 0;
    }

    // Clean up

    if (NULL != pstatStgEnum)
    {
        delete [] pstatStgEnum;
        pstatStgEnum = NULL;
    }

    if (NULL != lpEnumStatStg)
    {
        ulRef = lpEnumStatStg->Release();
        DH_ASSERT(NULL == ulRef);
        lpEnumStatStg = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return  hr;
}

//----------------------------------------------------------------------------
//
// Function: CompareSTATSTG
//
// Synopsis: Compares contents of two STATSTG structs
//
// Arguments: [sstg1] - first STATSTG struct to be compared
//            [sstg2] - second STATSTG struct to be compared
//
// Returns:  TRUE if storage buffers are the same; FALSE otherwise.
//
// History:  24-Jul-1996   Narindk   Enhanced 
//
//-----------------------------------------------------------------------------

BOOL CompareSTATSTG(STATSTG sstg1, STATSTG sstg2)
{
    HRESULT hr                  =   S_OK;
    LPTSTR  ptszStatStg1Name    =   NULL;
    LPTSTR  ptszStatStg2Name    =   NULL;
    BOOL    fEqual              =   FALSE;

    hr = OleStringToTString(sstg1.pwcsName, &ptszStatStg1Name);

    if(S_OK == hr)
    {
        hr = OleStringToTString(sstg2.pwcsName, &ptszStatStg2Name);
    }

    if(S_OK == hr)
    {
        fEqual=((!(_tcscmp(ptszStatStg1Name, ptszStatStg2Name))       &&
           (sstg1.type == sstg2.type)                                 &&
           (ULIGetLow(sstg1.cbSize) == ULIGetLow(sstg2.cbSize))       &&
           (sstg1.mtime.dwLowDateTime == sstg2.mtime.dwLowDateTime)   &&
           (sstg1.mtime.dwHighDateTime == sstg2.mtime.dwHighDateTime) &&
           (sstg1.ctime.dwLowDateTime == sstg2.ctime.dwLowDateTime)   &&
           (sstg1.ctime.dwHighDateTime == sstg2.ctime.dwHighDateTime) &&
           (sstg1.atime.dwLowDateTime == sstg2.atime.dwLowDateTime)   &&
           (sstg1.atime.dwHighDateTime == sstg2.atime.dwHighDateTime) &&
           (sstg1.grfMode == sstg2.grfMode)                           &&
           (sstg1.grfLocksSupported == sstg2.grfLocksSupported)       &&
           (sstg1.grfStateBits == sstg2.grfStateBits)                 &&
           IsEqualCLSID(sstg1.clsid, sstg2.clsid)));

    }

    DH_ASSERT(S_OK == hr);

    // Delete temp strings

    if(NULL != ptszStatStg1Name)
    {
        delete ptszStatStg1Name;
        ptszStatStg1Name = NULL;
    }

    if(NULL != ptszStatStg2Name)
    {
        delete ptszStatStg2Name;
        ptszStatStg1Name = NULL;
    }

    return fEqual;
}

//----------------------------------------------------------------------------
//
// Function: EnumerateDocFileAndVerifyEnumCloneResetSkipNext 
//
// Synopsis: Enumerate DocFile all at one level, Gets a clone of enumerator,
//           Uses Clone/Reset/Skip/Next method to get a Storage and verify that
//           with one obtained from original enumerator and counts all the 
//           objects ath the level.  If object is a storage, it is recursed
//           into and operation repeated. 
//
// Arguments: [pvcn] - Pointer to VirtualCtrNode 
//            [dwStgMode] - Mode for storage objects
//            [uNumObjs] - Max number of objs in DocFile to choose random 
//                         chunk number from
//            [pNumStg] - Out paramemter - Pointer to number of storages enum
//            [pNumStm] - Out paramemter - Pointer to number of streams enum
//
// Returns: HResult 
//
// History: 24-Jul-1996   Narindk   Created
//
//-----------------------------------------------------------------------------

HRESULT EnumerateDocFileAndVerifyEnumCloneResetSkipNext(
    VirtualCtrNode  *pvcn,
    DWORD           dwStgMode,
    ULONG           uNumObjs,
    ULONG           *pNumStg,
    ULONG           *pNumStm )
{
    HRESULT         hr                  =   S_OK;
    ULONG           cChildStg           =   0;
    ULONG           cChildStm           =   0;
    VirtualCtrNode  *pvcnTrav           =   NULL;
    LPENUMSTATSTG   lpEnumStatStg       =   NULL;
    LPENUMSTATSTG   lpEnumStatStgClone  =   NULL;
    LPMALLOC        pMalloc             =   NULL;
    ULONG           celtFetched         =   0;
    STATSTG         *pstatStgEnum       =   NULL;
    ULONG           ulRef               =   0;
    LPTSTR          ptszStatStgEnumName =   NULL;
    BOOL            fPass               =   FALSE;
    STATSTG         statStgEnumClone;

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("EnumerateDocFileAndVerifyEnumCloneResetSkipNext"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    DH_VDATEPTROUT(pNumStg, ULONG) ;
    DH_VDATEPTROUT(pNumStm, ULONG) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pNumStg);
    DH_ASSERT(NULL != pNumStm);

    if(S_OK == hr)
    {
        // Count the storage passed in.

        *pNumStg = 1;
        *pNumStm = 0;

        // Get enumerator 

        hr = pvcn->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }

    // Make a clone of the enumerator

    if(S_OK == hr)
    {
        hr = lpEnumStatStg->Clone(&lpEnumStatStgClone);
    
        DH_ASSERT((S_OK == hr) && (NULL != lpEnumStatStgClone));
    }

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Allocate memory for STATSTG strcuture

    if(S_OK == hr)
    {
        // We are allocating memory for more number of STATSTG objects than
        // what might be required, but is safer.

        pstatStgEnum = (STATSTG *) new STATSTG [uNumObjs];
        
        if(NULL == pstatStgEnum)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // if successful to get enumerator, get all the element at same level of 
    // the enumeration sequence.

    if(S_OK == hr)
    {
        hr = lpEnumStatStg->Next(uNumObjs, pstatStgEnum, &celtFetched);

        if(S_FALSE == hr)
        {
            hr = S_OK;
        }
    }

    while((0 < celtFetched--) && (S_OK == hr))
    {
        // for each element, ->Skip() from beginning of enumeration
        // sequence (of clone) and check that it is the same as
        // was returned with the original ->Next()

        // The Reset call always returns S_OK, so need to check hr

        hr = lpEnumStatStgClone->Reset();

        DH_ASSERT(S_OK == hr);

        // Skip celtFetched elements with Clone enumerator

        hr = lpEnumStatStgClone->Skip(celtFetched);

        DH_ASSERT(S_OK == hr);

        // Retrieve next element from this clone enumerator

        if(S_OK == hr)
        {
            hr = lpEnumStatStgClone->Next(1, &statStgEnumClone, NULL);

            DH_ASSERT(S_OK == hr);
        }

        if(S_OK == hr)
        {
            // Compare the STATSTG structures of one that is retrieved through
            // Clone and the one returned from original enumerator

            fPass = CompareSTATSTG(
                        pstatStgEnum[celtFetched], 
                        statStgEnumClone);
        }
   
        if(FALSE == fPass)
        {
            hr = S_FALSE;

            DH_LOG((LOG_INFO, TEXT("The two STATSTG's don't match\n")));
        }   
        else
        {
            DH_LOG((
                LOG_INFO, 
                TEXT("IEnum org and Clone enumerator: two STATSTG's match\n")));
        }
 
        if(S_OK == hr)
        {
            if (STGTY_STORAGE == pstatStgEnum[celtFetched].type)
            {
                hr = OleStringToTString(
                        pstatStgEnum[celtFetched].pwcsName,
                        &ptszStatStgEnumName);

                // Find the respective VirtualCtrNode with the name and recurse
                // into it after opening it.
           
                if(S_OK == hr)
                { 
                    pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();

                    while((NULL != pvcnTrav) &&
                          ( 0 != _tcscmp(
                                    ptszStatStgEnumName, 
                                    pvcnTrav->GetVirtualCtrNodeName())))
                    {
                        pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
                    } 

                    DH_ASSERT(NULL != pvcnTrav);

                    if(NULL != pvcnTrav)
                    {
                        hr = pvcnTrav->Open(NULL, dwStgMode, NULL, 0);
                    }
                }

                // Delete temp string
                
                if(NULL != ptszStatStgEnumName)
                {
                    delete ptszStatStgEnumName;
                    ptszStatStgEnumName = NULL;
                }

                if(S_OK == hr)
                {
                    hr = EnumerateDocFileAndVerifyEnumCloneResetSkipNext(
                            pvcnTrav, 
                            dwStgMode, 
                            uNumObjs, 
                            &cChildStg, 
                            &cChildStm);
                }

                if(S_OK == hr)
                {
                    hr = pvcnTrav->Close();
                }
 
                // Update number of nodes on basis of child nodes as found

                if(0 != cChildStg)
                {
                    *pNumStg = *pNumStg + cChildStg;
                }

                if(0 != cChildStm)
                {
                    *pNumStm = *pNumStm + cChildStm;
                }

            }
            else
            if (STGTY_STREAM == pstatStgEnum[celtFetched].type)
            {
                (*pNumStm)++;
            }
            else
            // The element is neither IStorage nor IStream, report error.
            {
                hr = E_UNEXPECTED;
            }

        }

        // Clean up

        if(NULL != pstatStgEnum[celtFetched].pwcsName)
        { 
            pMalloc->Free(pstatStgEnum[celtFetched].pwcsName);
            pstatStgEnum[celtFetched].pwcsName = NULL;
        }

        if(NULL != statStgEnumClone.pwcsName)
        {
            pMalloc->Free(statStgEnumClone.pwcsName);
            statStgEnumClone.pwcsName = NULL;
        }
    }

    // Clean up

    if (NULL != pstatStgEnum)
    {
        delete [] pstatStgEnum;
        pstatStgEnum = NULL;
    }

    if (NULL != lpEnumStatStg)
    {
        ulRef = lpEnumStatStg->Release();
        DH_ASSERT(NULL == ulRef);
        lpEnumStatStg = NULL;
    }

    if (NULL != lpEnumStatStgClone)
    {
        ulRef = lpEnumStatStgClone->Release();
        DH_ASSERT(NULL == ulRef);
        lpEnumStatStgClone = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return  hr;
}

//----------------------------------------------------------------------------
//
// Function: ModifyDocFile 
//
// Synopsis: Enumerate DocFile and randomly recurses into child storages, or
//           randomly destroys or renames elements.
//
// Arguments: [pVirtualDF] - Pointer to VirtualDF tree
//            [pvcn] - Pointer to VirtualCtrNode 
//            [pdgi] - Pointer to Data Integer object
//            [pdgu] - Pinter to Data Unicode objext
//            [fCommitRoot] - Bool to commit a root DocFile storage or not 
//
// Returns: HResult 
//
// History: 25-Jul-1996   Narindk   Created
//
//----------------------------------------------------------------------------

HRESULT ModifyDocFile(
    VirtualDF       *pVirtualDF,
    VirtualCtrNode  *pvcn,
    DG_INTEGER      *pdgi,
    DG_STRING      *pdgu,
    DWORD           dwStgMode,
    BOOL            fCommitRoot)    
{
    HRESULT         hr              =   S_OK;
    VirtualCtrNode  *pvcnTrav       =   NULL;
    VirtualStmNode  *pvsnTrav       =   NULL;
    LPENUMSTATSTG   lpEnumStatStg   =   NULL;
    LPMALLOC        pMalloc         =   NULL;
    ULONG           celtFetched     =   0;
    ULONG           ulRef           =   0;
    USHORT          usErr           =   0;
    LPTSTR          ptszStatStgName =   NULL;
    LPTSTR          ptszNewName     =   NULL;
    UINT            cRandVal0       =   0;
    UINT            cRandVal1       =   0;
    UINT            cRandRange0     =   0;
    UINT            cRandRange1     =   1;
    UINT            cRandRange2     =   2;
    STATSTG         statStg;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ModifyDocFile"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pdgu, DG_STRING) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pdgu);

    if(S_OK == hr)
    {
        // Get enumerator 

        hr = pvcn->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    while((S_OK == lpEnumStatStg->Next(1, &statStg, &celtFetched)) &&
          (S_OK == hr))
    {
       hr = OleStringToTString(statStg.pwcsName, &ptszStatStgName);

        // If the element is an IStorage, randmly either open this and make a 
        // recursive call to ModifyDocFile function or randomly choose to
        // either rename or destory this element.

        if ((STGTY_STORAGE == statStg.type) && (S_OK == hr))
        {
            // Find the respective VirtualCtrNode with the name and recurse
            // into it after opening it.
           
            if(S_OK == hr)
            { 
                pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();

                while((NULL != pvcnTrav) &&
                      ( 0 != _tcscmp( 
                                ptszStatStgName,  
                                pvcnTrav->GetVirtualCtrNodeName())))
                {
                    pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
                } 

                DH_ASSERT(NULL != pvcnTrav);

            }

            // Cloose random number

            if(S_OK == hr)
            { 
                usErr = pdgi->Generate(&cRandVal0, cRandRange0, cRandRange2);

                if (DG_RC_SUCCESS != usErr)
                {
                    hr = E_FAIL;
                }
            }

            // Randomly choose either to open/recurse and Modify the Storage
            // or choose to either randomly rename or destory the storage

            if((S_OK == hr) && (0 == cRandVal0))
            {
                if(NULL != pvcnTrav)
                {
                    hr = pvcnTrav->Open(NULL, dwStgMode, NULL, 0);

                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
                }

                // Call ModifyDocFile recursively on this node
           
                if(S_OK == hr)
                {
                    hr = ModifyDocFile(
                            pVirtualDF,
                            pvcnTrav, 
                            pdgi, 
                            pdgu, 
                            dwStgMode,
                            fCommitRoot);
                }

                // Close this storage

                if(S_OK == hr)
                {
                    hr = pvcnTrav->Close();
                }
            }
 
            if((S_OK == hr) && (0 != cRandVal0))
            {
                // choose random number either to rename or destory this 
                // element

                if(S_OK == hr)
                { 
                    usErr = pdgi->Generate(&cRandVal1,cRandRange1,cRandRange2);

                    if (DG_RC_SUCCESS != usErr)
                    {
                        hr = E_FAIL;
                    }
                }

                if(S_OK == hr)
                {
                    switch(cRandVal1)
                    {
                        case 1:
                        {
                            hr = DestroyStorage(pVirtualDF, pvcnTrav);
    
                            DH_HRCHECK(hr, TEXT("DestoryStorage")) ;

                            break;
                        }
                        case 2:
                        {
                            // Generate random new name

                            hr = GenerateRandomName(pdgu,
                                    MINLENGTH,
                                    MAXLENGTH,
                                    &ptszNewName);

                            if(S_OK == hr)
                            {
                                hr = pvcnTrav->Rename(ptszNewName);  
    
                                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Rename")) ;
                            }
                            break;
                        }
                    }
                }
            }

        }

        // If the element is an IStream,  randomly choose to either rename 
        // or destory this element.

        else if ((STGTY_STREAM == statStg.type) && (S_OK == hr))
        {
            // Find the respective VirtualStmNode with the name 
           
            if(S_OK == hr)
            { 
                pvsnTrav = pvcn->GetFirstChildVirtualStmNode();

                while((NULL != pvsnTrav) &&
                      ( 0 != _tcscmp( 
                                ptszStatStgName,  
                                pvsnTrav->GetVirtualStmNodeName())))
                {
                    pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode();
                } 

                DH_ASSERT(NULL != pvsnTrav);
            }

            // choose random number either to rename or destory this element

            if(S_OK == hr)
            { 
                usErr = pdgi->Generate(&cRandVal1, cRandRange1, cRandRange2);

                if (DG_RC_SUCCESS != usErr)
                {
                   hr = E_FAIL;
                }
            }

            if(S_OK == hr)
            { 
                switch(cRandVal1)
                {
                    case 1:
                    {
                        hr = DestroyStream(pVirtualDF, pvsnTrav);

                        DH_HRCHECK(hr, TEXT("DestroyStream")) ;

                        break;
                    }
                    case 2:
                    {
                        // Generate random new name

                        hr = GenerateRandomName(pdgu,
                                MINLENGTH,
                                MAXLENGTH,
                                &ptszNewName);

                        if(S_OK == hr)
                        {
                            hr = pvsnTrav->Rename(ptszNewName);  

                            DH_HRCHECK(hr, TEXT("VirtualStmNode::Rename")) ;
                        }
                        break;
                    }
                }
            }
        }

        // Clean up

        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if(NULL != ptszStatStgName)
        {
            delete ptszStatStgName;
            ptszStatStgName = NULL;
        }

        if(NULL != ptszNewName)
        {
            delete ptszNewName;
            ptszNewName = NULL;
        }
    }

    // Commit the passed in storage as case might be

    if((S_OK == hr) && 
       ((pvcn != pVirtualDF->GetVirtualDFRoot()) || (TRUE == fCommitRoot)))
    {
        hr = pvcn->Commit(STGC_DEFAULT);
    }

    // Clean up

    if (NULL != lpEnumStatStg)
    {
        ulRef = lpEnumStatStg->Release();
        DH_ASSERT(0 == ulRef);
        lpEnumStatStg = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return  hr;
}

//----------------------------------------------------------------------------
//
// Function: EnumerateAndWalkDocFile
//
// Synopsis: Enumerate /walks DocFile by either randomly skipping random
//           number of elements or getting random number of elements, recursing
//           if a child storage is found. 
//
// Arguments: [pvcn] - Pointer to VirtualCtrNode 
//            [pdgi] - Pointer to data generator object
//            [dwStgMode] - Mode for storage objects
//            [uNumObjs] - Max number of objs in DocFile to choose random 
//                         chunk number from
//
// Returns: HResult 
//
// History: 29-Jul-1996   Narindk   Created
//
// Notes: This doesn't provide any form of verification, but checks for any
//        unexpected errors/faults from ole while walking the docfile tree.
//-----------------------------------------------------------------------------

HRESULT EnumerateAndWalkDocFile(
    VirtualCtrNode  *pvcn,
    DG_INTEGER      *pdgi,  
    DWORD           dwStgMode,
    ULONG           uNumObjs)
{
    HRESULT         hr                  =   S_OK;
    USHORT          usErr               =   0;  
    ULONG           cRandomObjs         =   0;
    VirtualCtrNode  *pvcnTrav           =   NULL;
    LPENUMSTATSTG   lpEnumStatStg       =   NULL;
    LPMALLOC        pMalloc             =   NULL;
    ULONG           celtFetched         =   0;
    STATSTG         *pstatStgEnum       =   NULL;
    ULONG           ulRef               =   0;
    ULONG           counter             =   0;
    LPTSTR          ptszStatStgEnumName =   NULL;
    UINT            cWhichOp            =   0;
    UINT            cRandomOpMin        =   1;
    UINT            cRandomOpMax        =   3;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("EnumerateAndWalkDocFile"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    DH_VDATEPTROUT(pdgi, DG_INTEGER) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdgi);

    if(S_OK == hr)
    {
        // Get enumerator 

        hr = pvcn->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Get random number of objects to be asked from through Next or Skip

    if(S_OK == hr)
    {
        // Generate random number 

        usErr = pdgi->Generate(&cRandomObjs, 1, uNumObjs);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Get random number to determine whether to do skip or next operation.
    // 67% Next operation would be done and 33% skip would be done. 

    if(S_OK == hr)
    {
        // Generate random number 

        usErr = pdgi->Generate(&cWhichOp, cRandomOpMin, cRandomOpMax);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Allocate memory for STATSTG strcuture

    if(S_OK == hr)
    {
        pstatStgEnum = (STATSTG *) new STATSTG [cRandomObjs];
        
        if(NULL == pstatStgEnum)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // if successful to get enumerator, get the random element of the 
    // enumeration sequence.  33% do skip and 67% do Next.

    if(S_OK == hr)
    {
        if(cRandomOpMin == cWhichOp)
        {
            hr = lpEnumStatStg->Skip(cRandomObjs);

            if(S_OK == hr)
            {
                hr = lpEnumStatStg->Next(1, pstatStgEnum, &celtFetched);
            }
        }
        else
        {
            hr = lpEnumStatStg->Next(cRandomObjs, pstatStgEnum, &celtFetched);
        }

        if(S_FALSE == hr)
        {
            hr = S_OK;
        }
    }

    while(0 < celtFetched)
    {
        for (counter = 0; counter < celtFetched; counter++)
        {
            if (STGTY_STORAGE == pstatStgEnum[counter].type)
            {
                hr = OleStringToTString(
                        pstatStgEnum[counter].pwcsName,
                        &ptszStatStgEnumName);

                // Find the respective VirtualCtrNode with the name and recurse
                // into it after opening it.
           
                if(S_OK == hr)
                { 
                    pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();

                    while((NULL != pvcnTrav) &&
                          ( 0 != _tcscmp(
                                    ptszStatStgEnumName, 
                                    pvcnTrav->GetVirtualCtrNodeName())))
                    {
                        pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
                    } 

                    DH_ASSERT(NULL != pvcnTrav);

                    if(NULL != pvcnTrav)
                    {
                        hr = pvcnTrav->Open(NULL, dwStgMode, NULL, 0);
                    }
                }

                // Delete temp string
                
                if(NULL != ptszStatStgEnumName)
                {
                    delete ptszStatStgEnumName;
                    ptszStatStgEnumName = NULL;
                }

                if(S_OK == hr)
                {
                    hr = EnumerateAndWalkDocFile(
                            pvcnTrav, 
                            pdgi, 
                            dwStgMode, 
                            uNumObjs); 
                }

                if(S_OK == hr)
                {
                    hr = pvcnTrav->Close();
                }
            }

            // Clean up

            if(NULL != pstatStgEnum[counter].pwcsName)
            {
                pMalloc->Free(pstatStgEnum[counter].pwcsName);
                pstatStgEnum[counter].pwcsName = NULL;
            }

            // Break out of loop in error

            if(S_OK != hr)
            {
                break;
            }
        }

        // Reset the variables

        cWhichOp = 0;
        cRandomObjs = 0;
        celtFetched = 0;

        // Get random number to determine whether to do skip or next operation.
        // 67% Next operation would be done and 33% skip would be done. 

        if(S_OK == hr)
        {
            // Generate random number 

            usErr = pdgi->Generate(&cWhichOp, cRandomOpMin, cRandomOpMax);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }

        // Get the random number of elements from the enumeration sequence to
        // skip or get.

        if(S_OK == hr)
        {
            // Generate random number.

            usErr = pdgi->Generate(&cRandomObjs, 1, uNumObjs);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }
        
        if (NULL != pstatStgEnum)
        {
            delete [] pstatStgEnum;
            pstatStgEnum = NULL;
        }

        if(S_OK == hr)
        {
            pstatStgEnum = (STATSTG *) new STATSTG [cRandomObjs];
        
            if(NULL == pstatStgEnum)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if(S_OK == hr)
        {
            if(cRandomOpMin == cWhichOp)
            {
                hr = lpEnumStatStg->Skip(cRandomObjs);

                if(S_OK == hr)
                {
                    hr = lpEnumStatStg->Next(1, pstatStgEnum, &celtFetched);
                }
            }
            else
            {
                hr = lpEnumStatStg->Next(cRandomObjs,pstatStgEnum,&celtFetched);
            }

            if(S_FALSE == hr)
            {
                hr = S_OK;
            }
        }
    }

    // Clean up

    if (NULL != pstatStgEnum)
    {
        delete [] pstatStgEnum;
        pstatStgEnum = NULL;
    }

    if (NULL != lpEnumStatStg)
    {
        ulRef = lpEnumStatStg->Release();
        DH_ASSERT(NULL == ulRef);
        lpEnumStatStg = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return  hr;
}


//----------------------------------------------------------------------------
//
// Function: CreateNewObject 
//
// Synopsis: Randomly creates a new storage or stream object in a DocFile 
//
// Arguments: [pVirtualDF] - Pointer to VirtualDF tree
//            [pvcn] - Pointer to VirtualCtrNode
//            [dwStgMode] - Used for random creation of storage object
//            [pdgi] - Pointer to data generator integer object
//            [pdgu] - Pointer to data generator unicode object
//
// Returns: HResult 
//
// History: 29-Jul-1996   Narindk   Created
//
//----------------------------------------------------------------------------

HRESULT CreateNewObject(
    LPSTORAGE       pIStorage,
    DWORD           dwStgMode, 
    DG_INTEGER      *pdgi,
    DG_STRING      *pdgu)
{
    HRESULT         hr              =   S_OK;
    USHORT          usErr           =   0;
    UINT            cRandom         =   0;
    LPTSTR          ptszNewName     =   NULL;
    LPTSTR          ptszNewData     =   NULL;
    LPOLESTR        poszNewName     =   NULL;
    LPOLESTR        poszNewData     =   NULL;
    ULONG           cb              =   0;
    ULONG           culWritten      =   0;
    LPSTORAGE       pIStorageNew    =   NULL;
    LPSTREAM        pIStreamNew     =   NULL;
    ULONG           ulRef           =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CreateNewObject"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pdgu, DG_STRING) ;

    DH_ASSERT(NULL != pIStorage);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pdgu);

    // Pick up a random number.  33% chance to generate a new IStorage element,
    // and 67% chance to generate a new IStream element. 

    usErr = pdgi->Generate(&cRandom, 0, 2);

    if (DG_RC_SUCCESS != usErr)
    {
        hr = E_FAIL;
    }

    // flatfile only: storages are not allowed
    if(StorageIsFlat())
    {
        cRandom = 2; // force it to create only streams
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu, MINLENGTH, MAXLENGTH, &ptszNewName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert ptcsName to OLECHAR

        hr = TStringToOleString(ptszNewName, &poszNewName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        if(0 == cRandom)
        {
            // Create a new storage
            
            hr = pIStorage->CreateStorage(
                    poszNewName, 
                    dwStgMode | STGM_CREATE, 
                    0,
                    0,
                    &pIStorageNew);

            DH_HRCHECK(hr, TEXT("IStorage::CreateStorage")) ;

            if(S_OK == hr)
            {
                // Close the new storage

                ulRef = pIStorageNew->Release();
                DH_ASSERT(0 == ulRef);
                pIStorageNew = NULL;
            }
        }
        else
        {
            usErr = pdgi->Generate(&cb, 1, SHRT_MAX);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }

            if(S_OK == hr)
            {
                // Create a new stream

                hr = pIStorage->CreateStream(
                        poszNewName,
                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE, 
                        0,
                        0,
                        &pIStreamNew);

                DH_HRCHECK(hr, TEXT("IStorage::CreateStream")) ;
            }

            // Write into stream

            if(S_OK == hr)
            {
                hr = GenerateRandomName(pdgu, cb, cb, &ptszNewData);

                DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
            }

            if(S_OK == hr)
            {
                // Convert ptcsName to OLECHAR

                hr = TStringToOleString(ptszNewData, &poszNewData);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                hr = pIStreamNew->Write(poszNewData, cb, &culWritten);
            
                DH_HRCHECK(hr, TEXT("VirtualStmNode::Write")) ;
            }

            // Close the stream

            if(S_OK == hr)
            {
                ulRef = pIStreamNew->Release();
                DH_ASSERT(0 == ulRef);
                pIStreamNew = NULL;
            }
        }
    }

    // Clean up

    if(NULL != ptszNewName)
    {
        delete ptszNewName;
        ptszNewName = NULL;
    }

    if(NULL != poszNewName)
    {
        delete poszNewName;
        poszNewName = NULL;
    }

    if(NULL != ptszNewData)
    {
        delete ptszNewData;
        ptszNewData = NULL;
    }

    if(NULL != poszNewName)
    {
        delete poszNewName;
        poszNewName = NULL;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// Function: ChangeStreamData
//
// Synopsis: Randomly changes size or data of an IStream object in a DocFile 
//
// Arguments: [pIStorage] - Pointer to parent storage
//            [pStatStg] - Pointer to STATSTG structure 
//            [pdgi] - Pointer to data generator integer object
//            [pdgu] - Pointer to data generator unicode object
//
// Returns: HResult 
//
// History: 29-Jul-1996   Narindk   Created
//
//----------------------------------------------------------------------------

HRESULT ChangeStreamData(
    LPSTORAGE       pIStorage,
    STATSTG         *pStatStg,
    DG_INTEGER      *pdgi,
    DG_STRING      *pdgu)
{
    HRESULT         hr              =   S_OK;
    USHORT          usErr           =   0;
    LPTSTR          ptszName        =   NULL;
    LPOLESTR        poszName        =   NULL;
    LPTSTR          ptszNewData     =   NULL;
    LPOLESTR        poszNewData     =   NULL;
    ULONG           cb              =   0;
    ULONG           culWritten      =   0;
    ULONG           ulStreamOffset  =   0;
    LONG            lOffset         =   0;
    INT             cSign           =   0;
    UINT            cRandomVar      =   0;
    LPSTREAM        pIStream        =   NULL;
    ULONG           ulRef           =   0;
    LARGE_INTEGER   liStreamPos;
    LARGE_INTEGER   liSeek;
    ULARGE_INTEGER  uli;
    ULARGE_INTEGER  uliSetSize;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChangeStreamData"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    DH_VDATEPTRIN(pStatStg, STATSTG) ;
    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pdgu, DG_STRING) ;

    DH_ASSERT(NULL != pIStorage);
    DH_ASSERT(NULL != pStatStg);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pdgu);

    if(S_OK == hr)
    {
        // Convert WCHAR to TCHAR

        hr = OleStringToTString(pStatStg->pwcsName, &ptszName);

        DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
    }

    if(S_OK == hr)
    {
        // Convert TCHAR to OLECHAR

        hr = TStringToOleString(ptszName, &poszName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Open the stream if it is not open

    if(S_OK == hr)
    {
        hr = pIStorage->OpenStream(
                poszName,
                NULL, 
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                0,
                &pIStream);

        DH_HRCHECK(hr, TEXT("IStorage::OpenStream")) ;
    }

    // Seek to end of stream and get its size

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));

        //  Position the stream header to the postion from begining

        hr = pIStream->Seek(liStreamPos, STREAM_SEEK_END, &uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;

        ulStreamOffset = ULIGetLow(uli);
    }

    // Generate size and direction of change.  Magnitude is 1- SHRT_MAX bytes
    // or 1 - streamsize if SHRT_MAX is greater than stream size. 50 % of time,
    // direction will be positive, and rest times negative.

    if(S_OK == hr)
    {
        usErr = pdgi->Generate(&lOffset, 1, SHRT_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if((S_OK == hr) && ((ULONG) lOffset > ulStreamOffset))
    {
        usErr = pdgi->Generate(&lOffset, 1, ulStreamOffset);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        usErr = pdgi->Generate(&cSign, 1, 2);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }

        if(S_OK == hr) 
        {
            cSign = (cSign == 1) ? 1 : -1;
        }
    }

    // Generate Random number to do wither a SetSize or Seek/Write operation 
    // to change stream data

    if(S_OK == hr)
    {
        usErr = pdgi->Generate(&cRandomVar, 1, 2);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        switch (cRandomVar)
        {
            case 1:
            {
                ulStreamOffset = ulStreamOffset + (lOffset * cSign);

                ULISet32(uliSetSize, ulStreamOffset);

                hr = pIStream->SetSize(uliSetSize);

                break;
            }
            case 2:
            {

                // Seek either beyond or before the curretn seek position and
                // write a random number of bytes from there.

                LISet32(liSeek, lOffset*cSign);

                hr = pIStream->Seek(liSeek, STREAM_SEEK_CUR, &uli);

                if(S_OK == hr)
                {
                    hr = GenerateRandomName(pdgu, 1, SHRT_MAX, &ptszNewData);

                    DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
                }

                if(S_OK == hr)
                {
                    // Convert ptcsName to OLECHAR

                    hr = TStringToOleString(ptszNewData, &poszNewData);

                    DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
                }

                if(S_OK == hr)
                {
                    hr = pIStream->Write(poszNewData, cb, &culWritten);
            
                    DH_HRCHECK(hr, TEXT("VirtualStmNode::Write")) ;
                }
        
                break;
            }
        } 
    }

    // Close the stream

    if(S_OK == hr)
    {
        ulRef = pIStream->Release();
        DH_ASSERT(0 == ulRef);
        pIStream = NULL;
    }

    // Clean up

    if(NULL != ptszName)
    {
        delete ptszName;
        ptszName = NULL;
    }

    if(NULL != poszName)
    {
        delete poszName;
        poszName = NULL;
    }

    if(NULL != ptszNewData)
    {
        delete ptszNewData;
        ptszNewData = NULL;
    }

    if(NULL != poszNewData)
    {
        delete poszNewData;
        poszNewData = NULL;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// Function: ChangeExistingObject 
//
// Synopsis: Randomly destorys/renames a stream or storage object in a DocFile.
//           Randomly changes data of object if it is a stream.  This impl.
//           is for case when it a storage object that needs to be changed 
//
// Arguments: [pIStorage] - Pointer to parent storage
//            [pStatStg] - Pointer to STATSTG structure 
//            [pdgi] - Pointer to data generator integer object
//            [pdgu] - Pointer to data generator unicode object
//            [fStgDeleted] - Out value to indicate storage is deleted
//
// Returns: HResult 
//
// History: 29-Jul-1996   Narindk   Created
//
//----------------------------------------------------------------------------

HRESULT ChangeExistingObject(
    LPSTORAGE       pIStorage,
    STATSTG         *pStatStg,
    DG_INTEGER      *pdgi,
    DG_STRING      *pdgu,
    BOOL            *pfStgDeleted)
{
    HRESULT         hr              =   S_OK;
    USHORT          usErr           =   0;
    UINT            cRandomAction   =   0;
    LPTSTR          ptszNewName     =   NULL;
    LPOLESTR        poszNewName     =   NULL;
    LPTSTR          ptszName        =   NULL;
    LPOLESTR        poszName        =   NULL;
    LPSTORAGE       pIStorageRenamed=   NULL;
    LPMALLOC        pMalloc         =   NULL;
    ULONG           ulRef           =   0;
    BOOL            fRenamed        =   FALSE;
    STATSTG         statStgRenamed;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChangeExistingObject"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    DH_VDATEPTRIN(pStatStg, STATSTG) ;
    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pdgu, DG_STRING) ;

    DH_ASSERT(NULL != pIStorage);
    DH_ASSERT(NULL != pStatStg);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pdgu);

    if(S_OK == hr)
    {
        // Convert WCHAR to TCHAR

        hr = OleStringToTString(pStatStg->pwcsName, &ptszName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Convert TCHAR to OLECHAR

        hr = TStringToOleString(ptszName, &poszName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }


    if(S_OK == hr)
    {
        usErr = pdgi->Generate(&cRandomAction, 1, 3);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        switch (cRandomAction)
        {
            case 1:
            {
                hr = pIStorage->DestroyElement(poszName);

                DH_HRCHECK(hr, TEXT("IStorage::DestoryElement")) ;

                if(S_OK == hr)
                {
                    *pfStgDeleted = TRUE;
                }

                if (S_OK != hr)
                {    
                    DH_LOG((
                        LOG_INFO,
                        TEXT("IStorage::DestroyElement failed, hr=0x%lx.\n"),
                        hr));
                }
                break;
            }
            case 2:
            case 3:
            {
                // Generate random new name

                hr = GenerateRandomName(
                        pdgu,
                        MINLENGTH,
                        MAXLENGTH,
                        &ptszNewName);

                if(S_OK == hr)
                {
                    // Convert TCHAR to OLECHAR

                    hr = TStringToOleString(ptszNewName, &poszNewName);

                    DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
                }

                if(S_OK == hr)
                {
                    hr = pIStorage->RenameElement(
                            poszName,
                            poszNewName);

                    DH_HRCHECK(hr, TEXT("IStorage::Rename")) ;

                    if (S_OK != hr)
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("IStorage::RenameElem failed, hr=0x%lx.\n"),
                            hr));
                    }
                }
            
                if(S_OK == hr)
                {
                    fRenamed = TRUE; 
                }

                break;
            }
            case 4:
            case 5:
            case 6:
            {
                hr = ChangeStreamData(pIStorage, pStatStg, pdgi, pdgu);

                DH_HRCHECK(hr, TEXT("ChangeStreamData")) ;
 
                break;
            }
        }
    }

// ----------- flatfile change ---------------
    if( StorageIsFlat() && 
        (0 == _wcsicmp(poszName, L"CONTENTS")) &&
        (STG_E_ACCESSDENIED == hr))
    {
        DH_LOG((
            LOG_INFO,
            TEXT("ChangeExistingObject on %ws failed as exp, hr=0x%lx.\n"),
            pStatStg->pwcsName,
            hr));
        hr = S_OK; 
    }
// ----------- flatfile change ---------------

    if((S_OK == hr)         &&
       (TRUE == fRenamed)   &&
       (STGTY_STORAGE == pStatStg->type))
    {
        // Get pMalloc to free pwcsName of STATSTG struct.

        if ( S_OK == hr )
        {
            hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

            DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
        }
    
        // Free the pStatStg->pwcsName

        if((S_OK == hr) && (NULL != pStatStg->pwcsName))
        {
            pMalloc->Free(pStatStg->pwcsName);
            pStatStg->pwcsName = NULL;
        }

        // Open the storage and stat it, copy name and close it.

        if(S_OK == hr)
        {
            hr = pIStorage->OpenStorage(
                    poszNewName,
                    NULL,
                    STGM_SHARE_EXCLUSIVE | STGM_READ,
                    NULL,
                    0,
                    &pIStorageRenamed);

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("IStorage::OpenStorage failed, hr=0x%lx.\n"),
                    hr));
            }
        }

        if(S_OK == hr)
        {
            hr = pIStorageRenamed->Stat(&statStgRenamed, STATFLAG_DEFAULT);

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("IStorage::Stat failed, hr=0x%lx.\n"),
                    hr));
            }
        }

        if(S_OK == hr)
        {
            pStatStg->pwcsName = statStgRenamed.pwcsName;
        }

        if(S_OK == hr)
        {
            ulRef = pIStorageRenamed->Release();
            DH_ASSERT(0 == ulRef);
            pIStorageRenamed = NULL;
        }
    }

    // Clean up
    
    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }
 
    if(NULL != ptszName)
    {
        delete ptszName;
        ptszName = NULL;
    }

    if(NULL != poszName)
    {
        delete poszName;
        poszName = NULL;
    }

    if(NULL != ptszNewName)
    {
        delete ptszNewName;
        ptszNewName = NULL;
    }

    if(NULL != poszNewName)
    {
        delete poszNewName;
        poszNewName = NULL;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// Function: EnumerateAndProcessIStorage 
//
// Synopsis: Iterates through a  supplied IStorage, recursing and changing
//           objects.
//
// Arguments: [pVirtualDF] - Pointer to VirtualDF tree.
//            [pvcn] - Pointer to VirtualCtrNode
//            [pdgi] - Pointer to data generator integer object
//            [pdgu] - Pointer to data generator unicode object
//
// Returns: HResult 
//
// History: 29-Jul-1996   Narindk   Created
//
// Notes:   The VirtualDF tree is not used in this function, because of over
//          head of maintaining the tree as in several recursions of the
//          DocFile, there will be several random reverts and commits.
//----------------------------------------------------------------------------

HRESULT EnumerateAndProcessIStorage(
    LPSTORAGE       pIStorage,
    DWORD           dwStgMode,
    DG_INTEGER      *pdgi,
    DG_STRING      *pdgu)
{
    HRESULT         hr              =   S_OK;
    USHORT          usErr           =   0;
    LPSTORAGE       pIStorageChild  =   NULL;
    LPMALLOC        pMalloc         =   NULL;
    LPENUMSTATSTG   lpEnumStatStg   =   NULL; 
    BOOL            fStorageDeleted =   FALSE;
    BOOL            fCommit         =   FALSE;
    UINT            cRandomAction   =   0;
    ULONG           ulRef           =   0;
    static  USHORT  usNumElementEnum=   0;
    LPTSTR          ptszName        =   NULL;
    LPOLESTR        poszName        =   NULL;
    STATSTG         statStg;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("EnumerateAndProcessIStorage"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pdgu, DG_STRING) ;

    DH_ASSERT(NULL != pIStorage);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pdgu);

    if(S_OK == hr)
    {
        // Get enumerator

        hr = pIStorage->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }

    if (S_OK != hr)
    {
        DH_LOG((
           LOG_INFO,
           TEXT("IStorage::EnumElements unsuccessful, hr=0x%lx.\n"),
           hr));
    }

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Stat on passed storage

    if(S_OK == hr)
    {
        hr = pIStorage->Stat(&statStg, STATFLAG_DEFAULT);

        DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_LOG((
           LOG_INFO,
           TEXT("IStorage::Stat unsuccessful, hr=0x%lx.\n"),
           hr));
    }

    // Free the statStg.pwcsName

    if(NULL != statStg.pwcsName)
    {
        pMalloc->Free(statStg.pwcsName);
        statStg.pwcsName = NULL;
    }

    // Loop to get next element

    while((S_OK == lpEnumStatStg->Next(1, &statStg, NULL)) &&
          (S_OK == hr))
    {
        // approx 10% chance of changing an element

        if(S_OK == hr)
        {
            usErr = pdgi->Generate(&cRandomAction, 1, 10);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }

        if((S_OK == hr) && (cRandomAction == 1))
        {
            hr = ChangeExistingObject(
                    pIStorage, 
                    &statStg, 
                    pdgi, 
                    pdgu, 
                    &fStorageDeleted);

            DH_HRCHECK(hr, TEXT("ChangeExistingObject")) ;

            fCommit = TRUE;

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("ChangeExistingObject unsuccessful, hr=0x%lx.\n"),
                    hr));
            }
        }

        // every 1 to 64 objects enumerated, create a new object in current 
        // storage

        if((S_OK == hr) && (0 == usNumElementEnum--))
        {
            usErr = pdgi->Generate(&usNumElementEnum, 1, 64);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        
            if(S_OK == hr)
            {
                hr = CreateNewObject(pIStorage, dwStgMode, pdgi, pdgu);

                DH_HRCHECK(hr, TEXT("CreateNewObject")) ;

                fCommit = TRUE;
            }

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("CreateNewObject unsuccessful, hr=0x%lx.\n"),
                    hr));
            }
        }

        // Randomly commit the storage 50 % of time if it is not deleted

        if((S_OK == hr) && (TRUE == fCommit))
        {
            usErr = pdgi->Generate(&cRandomAction, 1, 2);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }

            if((S_OK == hr) && (cRandomAction == 1))
            {
                // Commit

                hr = pIStorage->Commit(STGC_DEFAULT);

                // Reset variable
            
                fCommit = FALSE;
            }

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("IStorage::Commit unsuccessful, hr=0x%lx.\n"),
                    hr));
            }
        }

        // if current storage is an IStorage and it wasn't deleted, then
        // recurse into it and process it.

        if((S_OK == hr)                     && 
           (STGTY_STORAGE == statStg.type)  && 
           (FALSE == fStorageDeleted))
        {
            // Convert WCHAR to TCHAR

            hr = OleStringToTString(statStg.pwcsName, &ptszName);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;

            if(S_OK == hr)
            {
                // Convert TCHAR to OLECHAR

                hr = TStringToOleString(ptszName, &poszName);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                // Open storage

                hr = pIStorage->OpenStorage(
                    poszName,
                    NULL, 
                    dwStgMode, 
                    NULL, 
                    0,
                    &pIStorageChild);

                if (S_OK != hr)
                {
                    DH_LOG((
                        LOG_INFO,
                        TEXT("IStorage::OpenStorage unsuccessful, hr=0x%lx.\n"),
                        hr));
                }
            }

            if(S_OK == hr)
            {
                // Recurse into child storage and process it recursively.

                hr = EnumerateAndProcessIStorage(
                        pIStorageChild, 
                        dwStgMode, 
                        pdgi, 
                        pdgu);

                if (S_OK != hr)
                {
                    DH_LOG((
                        LOG_INFO,
                        TEXT("EnumerateAndProcessIStorage failed, hr=0x%lx.\n"),
                        hr));
                }
            }

            // Close the storage

            if(S_OK == hr)
            {
                ulRef = pIStorageChild->Release();
                DH_ASSERT(0 == ulRef);
                pIStorageChild = NULL;
            }
        }
        
        // Free the statStg.pwcsName

        if(NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if(NULL != ptszName)
        {
            delete ptszName;
            ptszName = NULL;
        }

        if(NULL != poszName)
        {
            delete poszName;
            poszName = NULL;
        }

        // Reset variables

        fStorageDeleted = FALSE;
    }

    // Randomly commit changes

    if(S_OK == hr)
    {
        usErr = pdgi->Generate(&cRandomAction, 0, 3);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        if(0 != cRandomAction)
        {
            hr = pIStorage->Commit(STGC_DEFAULT);

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("IStorage::Commit unsuccessful, hr=0x%lx.\n"),
                    hr));
            }
        }
        else
        {
            hr = pIStorage->Revert();

            if (S_OK != hr)
            {
                DH_LOG((
                    LOG_INFO,
                    TEXT("IStorage::Revert unsuccessful, hr=0x%lx.\n"),
                    hr));
            }
        }
    }

    // Cleanup
   
    if (NULL != lpEnumStatStg)
    {
        ulRef = lpEnumStatStg->Release();
        DH_ASSERT(NULL == ulRef);
        lpEnumStatStg = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }
 
    return hr;
}

//  Function:   IsEqualStream
//
//  Synopsis:   Determines whether the two streams passed as arguments
//              are identical in length and content.
//
//  Arguments:  [pIOrigional]  -  Origional Stream
//              [pICompare]    -  The stream to compare with Origional 
//                                Stream 
//
//  Returns:    HRESULT
//
//  History:    July 31, 1996       T-Scottg        Created
//
//  Note:       Although a more elegent solution can be created using
//              CRCs, this particular implementation has been designed
//              so that it better tests the HGLOBAL implementation
//              of IStream
//
//+-------------------------------------------------------------------------

HRESULT IsEqualStream(IStream * pIOrigional, IStream * pICompare) 
{
    HRESULT             hr              =   S_OK;
    BYTE *              pbOrigionalBuf  =   NULL;
    BYTE *              pbCompareBuf    =   NULL;
    STATSTG             statOrigional;  
    STATSTG             statCompare;
    LARGE_INTEGER       liSeek;


    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("IsEqualStream"));

    DH_VDATEPTRIN(pIOrigional, IStream *);
    DH_VDATEPTRIN(pICompare, IStream *);

    DH_ASSERT(NULL != pIOrigional);
    DH_ASSERT(NULL != pICompare);


    // Note: STATFLAG_NONAME is passed to IStream::Stat(...).  
    // This requests that the statistics not include the pwcsName member 
    // of the STATSTG structure. Hence, there is no need for pwcsName to
    // be freed after use.


    if (S_OK == hr) 
    {
        hr = pIOrigional->Stat(&statOrigional, STATFLAG_NONAME);
        DH_HRCHECK(hr, TEXT("IsEqualStream: pIOrigional->Stat Failure"));
    }

    if (S_OK == hr) 
    {
        hr = pICompare->Stat(&statCompare, STATFLAG_NONAME);
        DH_HRCHECK(hr, TEXT("IsEqualStream: pICompare->Stat Failure"));
    }


    // If the size of the two streams is not equal, then the streams
    // can't be equal.  

    if (S_OK == hr) 
    {
        if (statOrigional.cbSize.LowPart != statCompare.cbSize.LowPart) 
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("Stream Sizes Not Equal"));
        }
    }


    // Allocate buffer to hold the stream contents

    if (S_OK == hr) 
    {
        pbOrigionalBuf = new BYTE [statOrigional.cbSize.LowPart];

        if (NULL == pbOrigionalBuf) 
        {    
            hr = E_OUTOFMEMORY;
        }

        DH_HRCHECK(hr, TEXT("IsEqualStream: new pbOrigionalBuf failed"));
    }

    
    // Initialize Buffer

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pbOrigionalBuf);

        memset(pbOrigionalBuf, '\0', statOrigional.cbSize.LowPart);
    }


    // Allocate buffer to hold the stream contents

    if (S_OK == hr) 
    {
        pbCompareBuf = new BYTE [statCompare.cbSize.LowPart];
                
        if (NULL == pbCompareBuf) 
        {
            hr = E_OUTOFMEMORY;
        }

        DH_HRCHECK(hr, TEXT("IsEqualStream: new pbCompareBuf failed"));
    }


    // Initialize Buffer

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pbOrigionalBuf);

        memset(pbOrigionalBuf, '\0', statOrigional.cbSize.LowPart);
    }


    // Set Origional Seek pointer back to beginning of stream

    if (S_OK == hr)
    {
        LISet32(liSeek, 0);

        hr = pIOrigional->Seek(liSeek, STREAM_SEEK_SET, NULL);
        DH_HRCHECK(hr, TEXT("IStream::Seek Failed"));
    }


    // Set Compare Seek pointer back to beginning of stream

    if (S_OK == hr)
    {
        LISet32(liSeek, 0);

        hr = pICompare->Seek(liSeek, STREAM_SEEK_SET, NULL);
        DH_HRCHECK(hr, TEXT("IStream::Seek Failed"));
    }

        
    // Read pIOrigional Stream data into buffer.  

    if (S_OK == hr)
    {
        hr = pIOrigional->Read( pbOrigionalBuf, 
                                statOrigional.cbSize.LowPart, 
                                NULL );

        DH_HRCHECK(hr, TEXT("IsEqualStream: pIOrigional->Read Failure"));
    }


    // Read pICompare Stream data into buffer.  

    if (S_OK == hr) 
    {
        hr = pICompare->Read( pbCompareBuf, 
                              statCompare.cbSize.LowPart, 
                              NULL );

        DH_HRCHECK(hr, TEXT("IsEqualStream: pICompare->Read Failure"));
    }


    // Compare memory buffers.  If they are not equal, set hr to S_FALSE;

    if (S_OK == hr)
    {
        if (0 != memcmp( pbOrigionalBuf, 
                         pbCompareBuf, 
                         statOrigional.cbSize.LowPart )) 
        {               
            hr = S_FALSE;
        }

        DH_HRCHECK(hr, TEXT("Buffer data not equal"));
    }


    // Cleanup dynamic memory

    if (NULL != pbOrigionalBuf)
    {
        delete [] pbOrigionalBuf;
        pbOrigionalBuf = NULL;
    }


    if (NULL != pbCompareBuf) 
    {
        delete [] pbCompareBuf;
        pbCompareBuf = NULL;
    }


    // Log if errors occur

    if (S_OK != hr)
    {
        DH_LOG((LOG_FAIL, TEXT("IsEqualStream Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:  ILockBytesWriteTest
//
//  Synopsis:  Writes data to the provided ILockBytes (calling 
//             ILockBytes::Flush in between writes).  When all data
//             is written, the function verifies that the ILockBytes
//             is of the correct length.
//
//  Arguments: [pILockBytes]  - ILockBytes to Write Data to
//             [dwSeed]       - Seed to Randomizer
//             [dwSize]       - Byte count of data to write to ILockBytes
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
//+-------------------------------------------------------------------------

HRESULT ILockBytesWriteTest ( ILockBytes *  pILockBytes, 
                              DWORD         dwSeed, 
                              DWORD         dwSize )
{
    HRESULT             hr              =       S_OK;
    CHAR *              pbBuffer        =       NULL;    
    DWORD               dwWritten       =       0;
    DWORD               dwIdx           =       0;
    ULARGE_INTEGER      li;
    STATSTG             LockBytesStat;
    DG_ASCII            dga(dwSeed);


    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("ILockBytesWriteTest"));

    DH_VDATEPTRIN(pILockBytes, ILockBytes *);
    DH_ASSERT(NULL != pILockBytes);


    // Create Data Buffer with Random Data in It

    if (0 != (dga.Generate( &pbBuffer, 
                            DG_APRINT_MIN, 
                            DG_APRINT_MAX,  
                            dwSize,
                            dwSize )))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
    }


    // Write Data into ILockBytes

    if (S_OK == hr)
    {
        for (dwIdx = 0; (dwIdx + HGLOBAL_PACKET_SIZE) <= dwSize; dwIdx += HGLOBAL_PACKET_SIZE)
        {

            ULISet32(li, dwIdx);

            hr = pILockBytes->WriteAt( li,
                                       pbBuffer,
                                       HGLOBAL_PACKET_SIZE,
                                       &dwWritten );

            DH_HRCHECK(hr, TEXT("pILockBytes->WriteAt Failed"));

            
            // Verify that all of the data was written

            if ((S_OK == hr) && (HGLOBAL_PACKET_SIZE != dwWritten))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("Written Data length mismatch"));
            }

            
            // Flush ILockBytes to Memory

            if (S_OK == hr)
            {
                hr = pILockBytes->Flush();
                DH_HRCHECK(hr, TEXT("pILockBytes->Flush Failed"));
            }


            // Break out of loop if error occurs

            if (S_OK != hr)
            {
                break;
            }
        }
    }

    
    // Obtain STATSTG structure from ILockBytes

    if (S_OK == hr)
    {
        hr = pILockBytes->Stat( &LockBytesStat, 
                                STATFLAG_NONAME );

        DH_HRCHECK(hr, TEXT("pILockBytes->Stat Failed"));
    }


    // Verify that the ILockBytes is of the correct length

    if (S_OK == hr)
    {
        if (LockBytesStat.cbSize.LowPart != dwSize)
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("ILockBytes not of correct length"));
        }
    }


    // Free dynamic memory

    if (NULL != pbBuffer)
    {
        delete [] pbBuffer;
        pbBuffer = NULL;
    }


    // Log if errors occur

    if (S_OK != hr)
    {
        DH_LOG((LOG_FAIL, TEXT("ILockBytesWriteTest Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:  ILockBytesReadTest
//
//  Synopsis:  Reads data from the provided ILockBytes
//
//  Arguments: [pILockBytes]  - ILockBytes to Read Data from
//             [dwSize]       - Byte count of data to read from ILockBytes
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
//+-------------------------------------------------------------------------

HRESULT ILockBytesReadTest (ILockBytes * pILockBytes, DWORD dwSize)
{
    HRESULT             hr              =       S_OK;
    BYTE *              pbBuffer        =       NULL;    
    DWORD               dwRead          =       0;
    DWORD               dwIndex         =       0;
    ULARGE_INTEGER      li;


    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("ILockBytesReadTest"));

    DH_VDATEPTRIN(pILockBytes, ILockBytes *);
    DH_ASSERT(NULL != pILockBytes);


    // Create buffer to hold data

    if (S_OK == hr)
    {
        pbBuffer = new BYTE[HGLOBAL_PACKET_SIZE];

        if (NULL == pbBuffer)
        {
            hr = E_OUTOFMEMORY;
        }

        DH_HRCHECK(hr, TEXT("new BYTE call failed"));
    }


    // Initialize Buffer

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pbBuffer);

        memset(pbBuffer, '\0', HGLOBAL_PACKET_SIZE);
    }


    // Read Data from ILockBytes

    if (S_OK == hr)
    {
        for (dwIndex = 0; (dwIndex+HGLOBAL_PACKET_SIZE) <= dwSize; dwIndex+=HGLOBAL_PACKET_SIZE)
        {

            ULISet32(li, dwIndex);

            hr = pILockBytes->ReadAt( li,
                                      pbBuffer,
                                      HGLOBAL_PACKET_SIZE,
                                      &dwRead );

            DH_HRCHECK(hr, TEXT("pILockBytes->ReadAt Failed"));

            
            // Verify that all of the data was written

            if ((S_OK == hr) && (HGLOBAL_PACKET_SIZE != dwRead))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("Read Data length mismatch"));
            }


            // Break out of loop if error occurs

            if (S_OK != hr)
            {
                break;
            }
        }
    }

    
    // Free dynamic memory

    if (NULL != pbBuffer)
    {
        delete [] pbBuffer;
        pbBuffer = NULL;
    }


    // Log if errors occur

    if (S_OK != hr)
    {
        DH_LOG((LOG_FAIL, TEXT("ILockBytesReadTest Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:  IStreamWriteTest
//
//  Synopsis:  Writes data to the provided IStream
//
//  Arguments: [pIStream]     - IStream to Write Data to
//             [dwSize]       - Byte count of data to write to IStream
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
//+-------------------------------------------------------------------------

HRESULT IStreamWriteTest ( IStream *    pIStream, 
                           DWORD        dwSeed,
                           DWORD        dwSize )
{
    HRESULT             hr              =       S_OK;
    CHAR *              pbBuffer        =       NULL;    
    DWORD               dwWritten       =       0;
    DWORD               dwIndex         =       0;
    LARGE_INTEGER       li;
    STATSTG             StreamStat;
    DG_ASCII            dga(dwSeed);


    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("IStreamWriteTest"));

    DH_VDATEPTRIN(pIStream, IStream *);
    DH_ASSERT(NULL != pIStream);


    // Create Data Buffer with Random Data in It

    if (0 != (dga.Generate( &pbBuffer, 
                            DG_APRINT_MIN, 
                            DG_APRINT_MAX,  
                            dwSize,
                            dwSize )))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
    }


    // Write Data into IStream

    if (S_OK == hr)
    {
        for (dwIndex = 0; (dwIndex+HGLOBAL_PACKET_SIZE) <= dwSize; dwIndex+=HGLOBAL_PACKET_SIZE)
        {
        
            // Assign seek index to Large Integer Structure

            LISet32(li, dwIndex);


            // Seek to correct position in stream

            if (S_OK == hr)
            {
                hr = pIStream->Seek( li,
                                     STREAM_SEEK_SET,
                                     NULL );

                DH_HRCHECK(hr, TEXT("pIStream->Seek Failed"));
            }


            // Write Data to stream

            if (S_OK == hr)
            {
                hr = pIStream->Write( pbBuffer,
                                      HGLOBAL_PACKET_SIZE,
                                      &dwWritten );

                DH_HRCHECK(hr, TEXT("pIStream->Write Failed"));
            }

            
            // Verify that all of the data was written

            if ((S_OK == hr) && (HGLOBAL_PACKET_SIZE != dwWritten))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("Written Data length mismatch"));
            }


            // Break out of loop if error occurs

            if (S_OK != hr)
            {
                break;
            }
        }
    }


    // Obtain STATSTG structure from ILockBytes

    if (S_OK == hr)
    {
        hr = pIStream->Stat( &StreamStat, 
                             STATFLAG_NONAME );

        DH_HRCHECK(hr, TEXT("pIStream->Stat Failed"));
    }


    // Verify that the IStream is of the correct length

    if (S_OK == hr)
    {
        if (StreamStat.cbSize.LowPart != dwSize)
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("IStream not of correct length"));
        }
    }

    
    // Free dynamic memory

    if (NULL != pbBuffer)
    {
        delete [] pbBuffer;
        pbBuffer = NULL;
    }


    // Log if errors occur

    if (S_OK != hr)
    {
        DH_LOG((LOG_FAIL, TEXT("IStreamWriteTest Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:  IStreamReadTest
//
//  Synopsis:  Reads data from the provided IStream
//
//  Arguments: [pIStream]     - IStream to Read Data From
//             [dwSize]       - Byte count of data to read from IStream
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
//+-------------------------------------------------------------------------

HRESULT IStreamReadTest (IStream * pIStream, DWORD dwSize)
{
    HRESULT             hr              =       S_OK;
    BYTE *              pbBuffer        =       NULL;    
    DWORD               dwWritten       =       0;
    DWORD               dwIndex         =       0;
    LARGE_INTEGER       li;


    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("IStreamReadTest"));

    DH_VDATEPTRIN(pIStream, IStream *);
    DH_ASSERT(NULL != pIStream);


    // Create buffer to hold data

    if (S_OK == hr)
    {
        pbBuffer = new BYTE[HGLOBAL_PACKET_SIZE];

        if (NULL == pbBuffer)
        {
            hr = E_OUTOFMEMORY;
        }

        DH_HRCHECK(hr, TEXT("new BYTE call failed"));
    }


    // Initialize Buffer

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pbBuffer);

        memset(pbBuffer, '\0', HGLOBAL_PACKET_SIZE);
    }


    // Read Data from IStream

    if (S_OK == hr)
    {
        for (dwIndex = 0; (dwIndex+HGLOBAL_PACKET_SIZE) <= dwSize; dwIndex+=HGLOBAL_PACKET_SIZE)
        {
        
            // Assign seek index to Large Integer Structure

            LISet32(li, dwIndex);


            // Seek to correct position in stream

            if (S_OK == hr)
            {
                hr = pIStream->Seek( li,
                                     STREAM_SEEK_SET,
                                     NULL );

                DH_HRCHECK(hr, TEXT("pIStream->Seek Failed"));
            }


            // Read Data from stream

            if (S_OK == hr)
            {
                hr = pIStream->Read( pbBuffer,
                                     HGLOBAL_PACKET_SIZE,
                                     &dwWritten );

                DH_HRCHECK(hr, TEXT("pIStream->Read Failed"));
            }

            
            // Verify that all of the data was written

            if ((S_OK == hr) && (HGLOBAL_PACKET_SIZE != dwWritten))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("Written Data length mismatch"));
            }


            // Break out of loop if error occurs

            if (S_OK != hr)
            {
                break;
            }
        }
    }

    
    // Free dynamic memory

    if (NULL != pbBuffer)
    {
        delete [] pbBuffer;
        pbBuffer = NULL;
    }


    // Log if errors occur

    if (S_OK != hr)
    {
        DH_LOG((LOG_FAIL, TEXT("IStreamReadTest Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}

//----------------------------------------------------------------------------
//
// Function: TraverseDocFileAndWriteOrReadSNB 
//
// Synopsis: Traverse DocFile one level and either writes/reads SNB
//
// Effects: Traverse the children storages and streams of root storage,
//          when fSelectObjectsToExclude == TRUE, then for each object
//          returned, there is a 50% chance that the object name will
//          be added to an SNB block of names to exclude upon reinstantiation,
//          when fIllegitFlag == TRUE, then there is a 50% change that a
//          bogus name instead of ture object name will be generated and 
//          be added into SNB block. When fSelectObjectsToExclude == FALSE, 
//          then each object name returned is checked to see if it exists in 
//          the SNB.  If an object name is returned that *is* in the SNB, 
//          that object is checked to ensure that its contents are empty.
//
// Arguments: [pvcn] - Pointer to VirtualCtrNode
//            [pdgi] - Pointer to Data Integer object
//            [pdgu] - Pointer to Data Unicode object
//            [dwStgMode] - Access Mode for the storage
//            [snbNamesToExclude] - SNB specifying elements to be excluded
//            [fIllegitFlag] - Indicating whether it's a legit or illegit 
//                             limited test: if TRUE, it is a illegit one, 
//                             otherwise, it is a legit one.
//            [fSelectObjectsToExclude] - if TRUE, the function builds the
//                                        SNB, otherwise the function checks
//                                        names against the SNB.
//
// Returns: HResult
//
// History: 29-Jul-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

HRESULT TraverseDocfileAndWriteOrReadSNB(
    VirtualCtrNode  *pvcn, 
    DG_INTEGER      *pdgi,
    DG_STRING      *pdgu,
    DWORD           dwStgMode,
    SNB             snbNamesToExclude,
    BOOL            fIllegitFlag,
    BOOL            fSelectObjectsToExclude)
{
    HRESULT         hr                  =   S_OK;
    ULONG           culRandomExclude    =   0;
    ULONG           culRandomBogus      =   0;
    ULONG           culThisName         =   0;
    ULONG           ulRef               =   0;  
    ULONG           ulStmLength         =   0;
    USHORT          usErr               =   0;
    LPTSTR          ptszStgName         =   NULL;
    LPTSTR          ptszBogusName       =   NULL;
    LPTSTR          ptszStmName         =   NULL;
    LPTSTR          pTStr               =   NULL;
    VirtualCtrNode  *pvcnTrav           =   NULL;
    VirtualStmNode  *pvsnTrav           =   NULL;
    LPENUMSTATSTG   lpEnumStatStg       =   NULL;
    STATSTG         *pstatStgEnum       =   NULL;       
    BOOL            fLocalPass          =   TRUE;
    LARGE_INTEGER   liZero;
    ULARGE_INTEGER  uli;
    SNB             snbIndex;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("TraverseDocfileAndWriteOrReadSNB"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode);
    DH_VDATEPTRIN(pdgi, DG_INTEGER);
    DH_VDATEPTRIN(pdgu, DG_STRING);
    
    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pdgu);

    // pointer SNB to start of global SNB

    snbIndex = snbNamesToExclude;
    
    // First traverse the child storages of the root storage

    pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();

    while ((S_OK == hr) && (NULL != pvcnTrav))
    {
        if (TRUE == fSelectObjectsToExclude)
        {
            // 50% chance of adding name to SNB for exclude on reinstantiation
            // when a name is added to the SNB, memory is allocated for that
            // name, the name of current VirtualCtrNode name is copied in, and
            // the SNB index is incremented to point to the location for the
            // next OLECHAR string.

            usErr = pdgi->Generate(&culRandomExclude, 1, 100);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        
            if ((S_OK == hr) && (culRandomExclude > 50))
            {
                // 50% chance of placing a bogus name in the snbExclude block

                ptszStgName = pvcnTrav->GetVirtualCtrNodeName();
                DH_ASSERT(NULL != ptszStgName);

                culThisName = _tcslen(ptszStgName);
 
                if (S_OK == hr)
                {              
                    if (TRUE == fIllegitFlag)
                    {
                        // if it is a illegit test, then 50% chance that
                        // a bogus name will generated instead of true 
                        // object name

                        usErr = pdgi->Generate(&culRandomBogus, 1, 100);

                        if (DG_RC_SUCCESS != usErr)
                        {
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        // if it is a legit test, then make sure culRandomBogus
                        // greater than 50,i.e. use the true object name

                        culRandomBogus = 100;
                    }
                }

                if (S_OK == hr) 
                {
                    if (culRandomBogus > 50)
                    {                  
                        hr = TStringToOleString(ptszStgName, snbIndex);
                        DH_HRCHECK(hr, TEXT("TStringToOleString"));
                    }
                    else
                    { 
                        hr = GenerateRandomString(
                                pdgu,
                                culThisName,
                                culThisName,
                                &ptszBogusName);
                        
                        DH_HRCHECK(hr, TEXT("GenerateRandomString"));
                         
                        if (S_OK == hr)
                        {
                            hr = TStringToOleString(ptszBogusName, snbIndex);
                            DH_HRCHECK(hr, TEXT("TStringToOleString"));
                        }

                        if (NULL != ptszBogusName)
                        {
                            delete []ptszBogusName;
                            ptszBogusName = NULL;
                        }
                    }
                }

                snbIndex++;
            }
        }
        else
        {
            // Starting with the first entry in the SNB, loop through and
            // compare the current name of the VirtualCtrNode against
            // each name in the SNB. If there is a match, check the
            // storage and verify that its contents are empty.
             
            ptszStgName = pvcnTrav->GetVirtualCtrNodeName();
            snbIndex = snbNamesToExclude;

            hr = OleStringToTString(*snbIndex, &pTStr);
            DH_HRCHECK(hr, TEXT("OleStringToTString"));

            while ((S_OK == hr) && (*snbIndex))
            {
                if (0 == _tcscmp(pTStr, ptszStgName))
                {
                    hr = pvcnTrav->Open(NULL, dwStgMode, NULL, 0);
                    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));
                    
                    if (S_OK == hr)
                    {
                        hr = pvcnTrav->EnumElements(0, NULL, 0, &lpEnumStatStg);
                        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements"));
                    }

                    // Allocate memory for STASTG structure

                    if (S_OK == hr)
                    {
                        pstatStgEnum = (STATSTG *) new STATSTG;

                        if (NULL == pstatStgEnum)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if (S_OK == hr)
                    {
                        if (S_OK == lpEnumStatStg->Next(1, pstatStgEnum, NULL))
                        {
                            DH_LOG((
                                LOG_INFO,
                                TEXT("Should no objects in excluded Stg.\n")));

                            fLocalPass = FALSE;
                        }
                    }

                    if (NULL != pstatStgEnum)
                    {
                        delete [] pstatStgEnum;
                        pstatStgEnum = NULL;
                    }

                    if (NULL != lpEnumStatStg)
                    {
                        ulRef = lpEnumStatStg->Release();
                        DH_ASSERT(NULL == ulRef);
                        lpEnumStatStg = NULL;
                    }

                    break;
                } 

                snbIndex++;
            }
        }        
 
        if (NULL != pTStr)
        {
            delete []pTStr;
            pTStr = NULL;
        }
        
        if ((S_OK == hr) && (TRUE == fLocalPass))
        {
            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
        }
        else
        {
            break;
        }
    }

    // Now, traverse the child streams of the root storage

    pvsnTrav = pvcn->GetFirstChildVirtualStmNode();

    while ((S_OK == hr) && (TRUE == fLocalPass) && (NULL != pvsnTrav))
    {
        if (TRUE == fSelectObjectsToExclude)
        {
            // 50% chance of adding name to SNB for exclude on reinstantiation
            // when a name is added to the SNB, memory is allocated for that
            // name, the name of current VirtualStmNode name is copied in, and
            // the SNB index is incremented to point to the location for the
            // next OLECHAR string.

            usErr = pdgi->Generate(&culRandomExclude, 1, 100);

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        
            if ((S_OK == hr) && (culRandomExclude > 50))
            {
                // 50% chance of placing a bogus name in the snbExclude block

                ptszStmName = pvsnTrav->GetVirtualStmNodeName();
                DH_ASSERT(NULL != ptszStmName);

                culThisName = _tcslen(ptszStmName);
 
                if (S_OK == hr)
                {              
                    if (TRUE == fIllegitFlag)
                    {
                        // if it is a illegit test, then 50% chance that
                        // a bogus name will generated instead of true 
                        // object name

                        usErr = pdgi->Generate(&culRandomBogus, 1, 100);

                        if (DG_RC_SUCCESS != usErr)
                        {
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        // if it is a legit test, then make sure culRandomBogus
                        // greater than 50,i.e. use the true object name

                        culRandomBogus = 100;
                    }
                }

                if (S_OK == hr) 
                {
                    if (culRandomBogus > 50)
                    {                  
                        hr = TStringToOleString(ptszStmName, snbIndex);
                        DH_HRCHECK(hr, TEXT("TStringToOleString"));
                    }
                    else
                    { 
                        hr = GenerateRandomString(
                                pdgu,
                                culThisName,
                                culThisName,
                                &ptszBogusName);
                        
                        DH_HRCHECK(hr, TEXT("GenerateRandomString"));

                        if (S_OK == hr)
                        {
                            hr = TStringToOleString(ptszBogusName, snbIndex);
                            DH_HRCHECK(hr, TEXT("TStringToOleString"));
                        }
 
                        if (NULL != ptszBogusName)
                        {
                            delete []ptszBogusName;
                            ptszBogusName = NULL;
                        } 
                    }
                }

                snbIndex++;
            }
        }
        else
        {
            // Starting with the first entry in the SNB, loop through and
            // compare the current name of the VirtualStmNode against
            // each name in the SNB. If there is a match, check the
            // stream and verify that its length is zero.
             
            snbIndex = snbNamesToExclude;
            ptszStmName = pvsnTrav->GetVirtualStmNodeName();

            hr = OleStringToTString(*snbIndex, &pTStr);
            DH_HRCHECK(hr, TEXT("OleStringToTString"));

            while ((S_OK == hr) && (*snbIndex))
            {
                if (0 == _tcscmp(pTStr, ptszStmName))
                {
                    LISet32(liZero, 0L);
                    
                    hr = pvsnTrav->Open(
                            NULL, 
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                            0);

                    DH_HRCHECK(hr, TEXT("VirutalStmNode::Open"));

                    if (S_OK == hr)
                    {            
                        hr = pvsnTrav->Seek(liZero, STREAM_SEEK_END, &uli);
                        ulStmLength = ULIGetLow(uli);

                        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;
                    }
                
                    if (S_OK != hr)
                    { 
                        DH_LOG((
                            LOG_INFO,
                            TEXT("VirtualStmNode::Seek not Ok, hr=0x%lx\n"),
                            hr));
                    }

                    if (0 != ulStmLength)                    
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("The length of excluded Stm should be 0.\n")));

                        fLocalPass = FALSE;
                    }

                    break;
                } 

                snbIndex++;
            }
        }        

        if (NULL != pTStr)
        {
            delete []pTStr;
            pTStr = NULL;
        }
        
        if ((S_OK == hr) && (TRUE == fLocalPass))
        {
            pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode();
        }
        else
        {
            break;
        }
    }

    if ((S_OK == hr) && (TRUE == fSelectObjectsToExclude))
    {
        // Last entry in SNB block is NIL to designate the end

        *snbIndex = NULL;
    }
    
    if (FALSE == fLocalPass)
    {
        hr = E_FAIL;
    }

    return hr;
}

 
//----------------------------------------------------------------------------
//
// Function: GetSeedFromCmdLineArgs 
//
// Synopsis: Gets the seed value from command line args if required for test 
//
// Arguments: [argc] - arg count
//            [argv] - arg list
//
// Returns: ULONG 
//
// History: 2-Aug-1996   Narindk   Made into separate func. 
//
//-----------------------------------------------------------------------------

ULONG GetSeedFromCmdLineArgs(int argc, char *argv[])
{
    HRESULT             hr      = S_OK ;
    ULONG               ulSeed  = 0;
    CCmdline            CCmdlineArgs(argc, argv);
    CUlongCmdlineObj    Seed(OLESTR("seed"), OLESTR(""), OLESTR("0")) ;
    CBaseCmdlineObj     *CArgList[] = {&Seed} ;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GetSeedFromCmdLineArgs"));

    // Verify that the CCmdlineArgs object was constructed without
    // problems

    if (CMDLINE_NO_ERROR != CCmdlineArgs.QueryError()) 
    {   
        hr = E_FAIL ;
    }

    // Parse Commandline Arguments 

    if (S_OK == hr) 
    {
        if (CMDLINE_NO_ERROR != CCmdlineArgs.Parse(CArgList,
                                    sizeof(CArgList) / sizeof(CArgList[0]),
                                    FALSE) ) 
        {
            hr = E_FAIL ;
        }
    }

    // Obtain Seed from CommandLine

    if (S_OK == hr) 
    {
        if ( ulSeed != *(Seed.GetValue()) ) 
        {
            ulSeed = *(Seed.GetValue());
        }
    }

    return ulSeed; 
}


//----------------------------------------------------------------------------
//
// Function: StreamCreate
//
// Synopsis: Create a stream or a file in a docfile or C-runtime condition,
//           and record the time of creation in both cases: the stream or
//           file existing and not existing.
//
// Arguments: [dwRootMode] - Access modes to root storage
//            [pdgu] - Pointer to Data Unicode object
//            [usTimeIndex] - Indicate which category this test is
//            [dwFlags] - Indicate DOCFILE or RUNTIME file and also 
//                        the stream or file exists or not
//            [usNumCreates] - Indicate this is usNumCreates'th creation
//
// Returns: HResult
//
// History: 8-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

HRESULT StreamCreate(
    DWORD       dwRootMode,
    DG_STRING  *pdgu,
    USHORT      usTimeIndex, 
    DWORD       dwFlags, 
    USHORT      usNumCreates)
{
    HRESULT     hr              = S_OK; 
    LPSTORAGE   pstgRoot        = NULL;
    LPSTREAM    pstmStream      = NULL;
    LPOLESTR    pOleName        = NULL;
    ULONG       bufferSize      = 0;
    FILE        *fileFile       = NULL;
    DWORD       StartTime       = 0;
    DWORD       EndTime         = 0;
    DWORD       dwModifiers     = 0;
    ULONG       ulRef           = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("StreamCreate"));
    
    DH_VDATEPTRIN(pdgu, DG_STRING);

    DH_ASSERT(NULL != pdgu);

    while ((S_OK == hr) && (0 < usNumCreates))
    {
        usNumCreates--;

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &ptszNames[0]);

        DH_HRCHECK(hr, TEXT("GenerateRandomName"));

        if ((S_OK == hr) && (dwFlags & DOCFILE))
        {
            // Create a docfile
            
            hr = TStringToOleString(ptszNames[0], &pOleName);
            DH_HRCHECK(hr, TEXT("TStringToOleString"));

            if (S_OK == hr)
            {
                hr = StgCreateDocfile(
                        pOleName,
                        dwRootMode | STGM_CREATE,
                        0,
                        &pstgRoot);

                DH_HRCHECK(hr, TEXT("StgCreateDocfile"));
            }
        }

        if ((S_OK == hr) && (dwFlags & EXIST))
        {
            dwFlags |= CREATE;

            if (dwFlags & DOCFILE)
            {
                // Create existing stream

                if (S_OK == hr)
                {
                    hr = pstgRoot->CreateStream(
                            pOleName,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                            0,
                            0,
                            &pstmStream);
                    
                    DH_HRCHECK(hr, TEXT("IStorage::CreateStream"));
                }

                if (S_OK == hr)
                {
                    ulRef = pstmStream->Release();
                    DH_ASSERT(0 == ulRef);
                    pstmStream = NULL;
                }
            }
            else
            {

#if  (defined _NT1X_ && !defined _MAC)
                // Create existing file
                
                fileFile = _wfopen(ptszNames[0],TEXT("w"));

                if (NULL == fileFile)
                {
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                    hr = E_FAIL;
                }                

#else
                fileFile = fopen(ptszNames[0],"w");

                if (NULL == fileFile)
                {
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                    hr = E_FAIL;                   
                }
#endif
                if (S_OK == hr)
                {
                    fclose(fileFile);
                }
            }
        }

        if (S_OK == hr)
        {
            dwModifiers |= (dwFlags & CREATE ? STGM_CREATE : STGM_FAILIFTHERE);

            if (dwFlags & DOCFILE)
            {                
                if (S_OK == hr)
                {
                    GET_TIME(StartTime);

                    hr = pstgRoot->CreateStream(
                            pOleName,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE | dwModifiers,
                            0,
                            0,
                            &pstmStream);
                    
                    GET_TIME(EndTime);
                    
                    Time[usTimeIndex].plDocfileTime[usNumCreates] = 
                        DiffTime(EndTime, StartTime);
                    
                    DH_HRCHECK(hr, TEXT("IStorage::CreateStream"));
                }
 
                if ((S_OK == hr) && (dwFlags & COMMIT))
                {
                    hr = pstgRoot->Commit(STGC_DEFAULT);

                    DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                }

                if (S_OK == hr)
                {
                    ulRef = pstmStream->Release();
                    DH_ASSERT(0 == ulRef);
                    pstmStream = NULL;

                    ulRef = pstgRoot->Release();
                    DH_ASSERT(0 == ulRef);
                    pstgRoot = NULL;
                }

                if (NULL != pOleName)
                {
                    delete []pOleName;
                    pOleName = NULL;
                }

            }
            else
            {
#if (defined _NT1X_ && !defined _MAC)
                GET_TIME(StartTime);
                fileFile = _wfopen(ptszNames[0], TEXT("w+b"));
                GET_TIME(EndTime);
#else
                GET_TIME(StartTime);                
                fileFile = fopen(ptszNames[0], "w+b");
                GET_TIME(EndTime);
#endif
                Time[usTimeIndex].plRuntimeTime[usNumCreates] = 
                    DiffTime(EndTime,StartTime);

                if (NULL == fileFile)
                {      
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    hr = E_FAIL;
                }

                if (S_OK == hr)
                {
                    fclose(fileFile);
                }
            }
        }

        if (NULL != ptszNames[0])
        {
            if(FALSE == DeleteFile(ptszNames[0]))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;

                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }
        }

        if (NULL != ptszNames[0])
        {
            delete []ptszNames[0];
            ptszNames[0] = NULL;
        }
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
// Function: DocfileCreate
//
// Synopsis: Create a docfile is similar to creating a directory in C-runtime,
//           this test measures the time in several cases of creating a docfile, 
//           like create a existing or non-exist or NULL docfile. RUNTIME only 
//           support creating a non-exist directory.
//
// Arguments: [dwRootMode] - Access modes to root storage
//            [pdgu] - Pointer to Data Unicode object
//            [usTimeIndex] - Indicate which category this test is
//            [dwFlags] - Indicate DOCFILE or RUNTIME file and also 
//                        the stream or file exists or not
//            [usNumCreates] - Indicate this is usNumCreates'th creation
//
// Returns: HResult
//
// History: 6-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

HRESULT DocfileCreate(
    DWORD       dwRootMode,
    DG_STRING  *pdgu,
    USHORT      usTimeIndex, 
    DWORD       dwFlags, 
    USHORT      usNumCreates)
{
    HRESULT     hr              = S_OK; 
    LPSTORAGE   pstgRoot        = NULL;
    LPSTREAM    pstmStream      = NULL;
    LPOLESTR    pOleName        = NULL;
    LPTSTR      ptTmpName       = NULL;
    LPTSTR      ptszCurDir      = NULL;
    int         Temp            = 0;      
    ULONG       bufferSize      = 0;
    DWORD       StartTime       = 0;
    DWORD       EndTime         = 0;
    DWORD       dwModifiers     = 0;
    ULONG       ulRef           = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DocfileCreate"));
    
    DH_VDATEPTRIN(pdgu, DG_STRING);

    DH_ASSERT(NULL != pdgu);
 
    while ((S_OK == hr) && (0 < usNumCreates))
    {
        usNumCreates--;

        if ((dwFlags & DOCFILE) && (dwFlags & NONAME))
        {
            ptszNames[0] = NULL;
        }
        else
        {
            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &ptszNames[0]);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")); 

            if (S_OK == hr)
            {
                hr = TStringToOleString(ptszNames[0], &pOleName);
                DH_HRCHECK(hr, TEXT("TStringToOleString"));
            }
        }

        if ((S_OK == hr) && (dwFlags & DOCFILE) && (dwFlags & EXIST)
                && ~(dwFlags & NONAME))
        {
            // Create a existing docfile
         
            dwFlags |= CREATE;

            hr = StgCreateDocfile(
                    pOleName,
                    dwRootMode | STGM_CREATE,
                    0,
                    &pstgRoot);

            DH_HRCHECK(hr, TEXT("StgCreateDocfile"));       

            if (S_OK == hr)
            {
                ulRef = pstgRoot->Release();
                DH_ASSERT(0 == ulRef);
                pstgRoot = NULL;
            }
        }

        if (S_OK == hr)
        {
            dwModifiers |= (dwFlags & CREATE ? STGM_CREATE : STGM_FAILIFTHERE);

            if (dwFlags & DOCFILE)
            {
                GET_TIME(StartTime);

                hr = StgCreateDocfile(
                        pOleName,
                        dwRootMode | dwModifiers,
                        0,
                        &pstgRoot);

                GET_TIME(EndTime);
                
                Time[usTimeIndex].plDocfileTime[usNumCreates] = 
                    DiffTime(EndTime, StartTime);

                DH_HRCHECK(hr, TEXT("StgCreateDocfile"));

                if ((S_OK == hr) && (dwFlags & COMMIT))
                {
                    hr = pstgRoot->Commit(STGC_DEFAULT);

                    DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                }

                // if NONAME, we need to get the name so we can
                // delete the file when we are done.
                if (S_OK == hr && (dwFlags & NONAME))
                {
                    STATSTG statstg;
                    hr = pstgRoot->Stat (&statstg, STATFLAG_DEFAULT);
                    DH_HRCHECK (hr, TEXT("IStorage::Stat"));

                    if (S_OK == hr)
                    {
                        //retrieve the filename
                        OleStringToTString (statstg.pwcsName, &ptTmpName);
                        DH_HRCHECK (hr, TEXT("OleStringToTString"));

                        //now that we have the name, it up from statstg
                        CoTaskMemFree (statstg.pwcsName);
                    }
                }

                if (S_OK == hr)
                {
                    ulRef = pstgRoot->Release();
                    DH_ASSERT(0 == ulRef);
                    pstgRoot = NULL;
                }
            }
            else
            {
                if (~(dwFlags & NONAME) && ~(dwFlags & EXIST))
                {
#if (defined _NT1X_ && !defined _MAC)
                    ptszCurDir = (TCHAR *) new TCHAR[MAX_PATH_LENGTH];
                    
                    if (NULL == ptszCurDir)
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if (S_OK == hr)
                    {
                        memset(ptszCurDir,'\0',MAX_PATH_LENGTH*sizeof(TCHAR));

                        if (NULL == _wgetcwd(ptszCurDir, MAX_PATH_LENGTH))
                        {
                            DH_LOG((
                                LOG_INFO, 
                                TEXT("Error in getting Current directory\n")));

                            hr = E_FAIL;
                        }
                    }

                    if (S_OK == hr)
                    {
                        GET_TIME(StartTime);

                        Temp = _wmkdir(ptszNames[0]);

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plRuntimeTime[usNumCreates] = 
                            DiffTime(EndTime, StartTime);

                        if (0 != Temp)
                        {
                            DH_LOG((
                                LOG_INFO, 
                                TEXT("Error in creating a directory\n")));

                            hr = E_FAIL;
                        }
                    }

                    // Clean up

                    if (S_OK == hr)
                    {
                        if (0 != _wchdir(ptszCurDir))
                        {
                            DH_LOG((
                                LOG_INFO, 
                                TEXT("Error in changing directory\n")));

                            hr = E_FAIL;
                        }

                        if (S_OK == hr)
                        {
                            if (0 != _wrmdir(ptszNames[0]))
                            {
                                DH_LOG((
                                    LOG_INFO,
                                    TEXT("Error in removing directory\n")));

                                hr = E_FAIL;
                            }
                        }
                        
                        if (NULL != ptszCurDir)
                        {
                            delete []ptszCurDir;
                            ptszCurDir = NULL;
                        }
                    }
#else
                    ptszCurDir = (TCHAR *) new TCHAR[MAX_PATH_LENGTH];
                    
                    if (NULL == ptszCurDir)
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if (S_OK == hr)
                    {
                        memset(ptszCurDir,'\0',MAX_PATH_LENGTH*sizeof(TCHAR));

                        if (NULL == _getcwd(ptszCurDir, MAX_PATH_LENGTH))
                        {
                            DH_LOG((
                                LOG_INFO, 
                                TEXT("Error in getting Current directory\n")));

                            hr = E_FAIL;
                        }
                    }

                    if (S_OK == hr)
                    {
                        GET_TIME(StartTime);

                        Temp = _mkdir(ptszNames[0]);

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plRuntimeTime[usNumCreates] = 
                            DiffTime(EndTime, StartTime);

                        if (0 != Temp)
                        {
                            DH_LOG((
                                LOG_INFO, 
                                TEXT("Error in creating a directory\n")));

                            hr = E_FAIL;
                        }
                    }

                    // Clean up

                    if (S_OK == hr)
                    {
                        if (0 != _chdir(ptszCurDir))
                        {
                            DH_LOG((
                                LOG_INFO, 
                                TEXT("Error in changing directory\n")));

                            hr = E_FAIL;
                        }

                        if (S_OK == hr)
                        {
                            if (0 != _rmdir(ptszNames[0]))
                            {
                                DH_LOG((
                                    LOG_INFO,
                                    TEXT("Error in removing directory\n")));

                                hr = E_FAIL;
                            }
                        }
                        
                        if (NULL != ptszCurDir)
                        {
                            delete []ptszCurDir;
                            ptszCurDir = NULL;
                        }
                    }
#endif
                }
                else
                {
                    DH_LOG((
                        LOG_INFO, 
                        TEXT("RUNTIME not supported this function\n")));

                    hr = E_FAIL;
                }
            }
        }

        // Clean up

        if (NULL != pOleName)
        {
            delete []pOleName;
            pOleName = NULL;
        }

        if ((NULL != ptszNames[0]) && (dwFlags & DOCFILE))
        {
            if (FALSE == DeleteFile(ptszNames[0]))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;

                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }
        }
        else if (NULL != ptTmpName)
        {
            if (FALSE == DeleteFile(ptTmpName))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;
                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }
            delete []ptTmpName;
            ptTmpName = NULL;
        }


        if (NULL != ptszNames[0])
        {
            delete []ptszNames[0];
            ptszNames[0] = NULL;
        }
    }

    return hr;
}


//----------------------------------------------------------------------------
//
// Function: StreamOpen
//
// Synopsis: Open a stroage and its child stream is similar to find a directory
//           and open a file in this directory in C-runtime. This test measures
//           the time in opening both storage and stream or opening stream only
//           and also the time in corresponding C-runtime operations.
//
// Arguments: [dwRootMode] - Access modes to root storage
//            [pdgu] - Pointer to Data Unicode object
//            [usTimeIndex] - Indicate which category this test is
//            [dwFlags] - Indicate DOCFILE or RUNTIME file and also 
//                        open both storage and stream or not.
//            [usNumOpens] - Indicate this is usNumOpens'th opening
// 
// Returns: HResult
//
// History: 9-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

HRESULT StreamOpen(
    DWORD       dwRootMode,
    DG_STRING  *pdgu,
    USHORT      usTimeIndex, 
    DWORD       dwFlags, 
    USHORT      usNumOpens)
{
    HRESULT     hr              = S_OK; 
    LPSTORAGE   pstgRoot        = NULL;
    LPSTREAM    pstmStream      = NULL;
    LPOLESTR    pOleName        = NULL;
    LPTSTR      ptszCurDir      = NULL;
    LPTSTR      ptszNewDir      = NULL;
    ULONG       bufferSize      = 0;
    DWORD       StartTime       = 0;
    DWORD       EndTime         = 0;
    FILE        *fileFile       = NULL;
    ULONG       ulRef           = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("StreamOpen"));
    
    DH_VDATEPTRIN(pdgu, DG_STRING);

    DH_ASSERT(NULL != pdgu);
 
    while ((S_OK == hr) && (0 < usNumOpens))
    {
        usNumOpens--;

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &ptszNames[0]);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")); 

        if (S_OK == hr)
        {
            hr = TStringToOleString(ptszNames[0], &pOleName);
            DH_HRCHECK(hr, TEXT("TStringToOleString"));
        }
        
        if (S_OK == hr)
        {
            if (dwFlags & DOCFILE)
            {
                // Create a root storage and a stream inside it.
 
                hr = StgCreateDocfile(
                        pOleName,
                        dwRootMode | STGM_CREATE,
                        0,
                        &pstgRoot);

                DH_HRCHECK(hr, TEXT("StgCreateDocfile"));
            
                if (S_OK == hr)
                {
                    hr = pstgRoot->CreateStream(
                            pOleName,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                            0,
                            0,
                            &pstmStream);
                    
                    DH_HRCHECK(hr, TEXT("IStorage::CreateStream"));
                }

                if ((S_OK == hr) && (dwFlags & COMMIT))
                {
                    hr = pstgRoot->Commit(STGC_DEFAULT);

                    DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                }

                if (S_OK == hr)
                {
                    ulRef = pstmStream->Release();
                    DH_ASSERT(0 == ulRef);
                    pstmStream = NULL;

                    ulRef = pstgRoot->Release();
                    DH_ASSERT(0 == ulRef);
                    pstgRoot = NULL;
                }
            }
            else
            {
                // Create a directory and a file under it.

                ptszCurDir = (TCHAR *) new TCHAR[MAX_PATH_LENGTH];
                ptszNewDir = (TCHAR *) new TCHAR[MAX_PATH_LENGTH];    

                if ((NULL == ptszCurDir) || (NULL == ptszNewDir))
                {
                    hr = E_OUTOFMEMORY;
                }

                if (S_OK == hr)
                {
                    memset(ptszCurDir,'\0',MAX_PATH_LENGTH * sizeof(TCHAR));
                    memset(ptszNewDir,'\0',MAX_PATH_LENGTH * sizeof(TCHAR));
                }

#if (defined _NT1X_ && !defined _MAC)
 
                if (NULL == _wgetcwd(ptszCurDir, MAX_PATH_LENGTH))
                {
                    DH_LOG((
                        LOG_INFO, 
                        TEXT("Error in getting Current directory\n")));

                    hr = E_FAIL;
                }

                if (S_OK == hr)
                { 
                    if (0 != _wmkdir(ptszNames[0]))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in creating a directory\n")));

                        hr = E_FAIL;
                    }
                }

                if (S_OK == hr)
                {                    
                    _tcscpy(ptszNewDir, ptszCurDir);
                    _tcscat(ptszNewDir, TEXT("\\"));
                    _tcscat(ptszNewDir, ptszNames[0]);
                }

                if (S_OK == hr)
                { 
                    if (0 != _wchdir(ptszNewDir))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in changing directory\n")));

                        hr = E_FAIL;
                    }
                }

                if (S_OK == hr)
                {
                    fileFile = _wfopen(ptszNames[0],TEXT("w"));

                    if (NULL == fileFile)
                    {
                        DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                        hr = E_FAIL;
                    }
                }          

#else                 
                if (NULL == _getcwd(ptszCurDir, MAX_PATH_LENGTH))
                {
                    DH_LOG((
                        LOG_INFO, 
                        TEXT("Error in getting Current directory\n")));

                    hr = E_FAIL;
                }

                if (S_OK == hr)
                {                        
                    if (0 != _mkdir(ptszNames[0]))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in creating a directory\n")));

                        hr = E_FAIL;
                    }
                } 

                if (S_OK == hr)
                {                    
                    _tcscpy(ptszNewDir, ptszCurDir);
                    _tcscat(ptszNewDir, TEXT("\\"));
                    _tcscat(ptszNewDir, ptszNames[0]);
                }

                if (S_OK == hr)
                { 
                    if (0 != _chdir(ptszNewDir))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in changing directory\n")));

                        hr = E_FAIL;
                    }
                }

                if (S_OK == hr)
                {
                    fileFile = fopen(ptszNames[0],"w");

                    if (NULL == fileFile)
                    {
                        DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                        hr = E_FAIL;                   
                    }
                }
#endif
                if (S_OK == hr)
                {
                    fclose(fileFile);
                }
            }
        }

        if (S_OK == hr)
        {
            if (dwFlags & DOCFILE)
            {
                if (dwFlags & OPENBOTH)
                {
                    GET_TIME(StartTime);
                
                    hr = StgOpenStorage(
                            pOleName,
                            NULL,
                            dwRootMode,
                            NULL,
                            0,
                            &pstgRoot);
              
                    if (S_OK == hr)
                    {
                        hr = pstgRoot->OpenStream(
                                pOleName,
                                NULL,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                0,
                                &pstmStream);

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plDocfileTime[usNumOpens] = 
                            DiffTime(EndTime, StartTime);

                    }

                    if (S_OK != hr)
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("Open storage or stream, hr=0x%lx\n"),
                            hr));
                    }
                }
                else
                {
                    hr = StgOpenStorage(
                            pOleName,
                            NULL,
                            dwRootMode,
                            NULL,
                            0,
                            &pstgRoot);
              
                    if (S_OK == hr)
                    {
                        GET_TIME(StartTime);

                        hr = pstgRoot->OpenStream(
                                pOleName,
                                NULL,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                0,
                                &pstmStream);

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plDocfileTime[usNumOpens] = 
                            DiffTime(EndTime, StartTime);

                    }

                    if (S_OK != hr)
                    {
                        DH_LOG((
                            LOG_INFO,
                            TEXT("Open storage or stream, hr=0x%lx\n"),
                            hr));
                    }
                }

                if (S_OK == hr)
                {
                    ulRef = pstmStream->Release();
                    DH_ASSERT(0 == ulRef);
                    pstmStream = NULL;

                    ulRef = pstgRoot->Release();
                    DH_ASSERT(0 == ulRef);
                    pstgRoot = NULL;
                }
            }
            else
            {
                if (dwFlags & OPENBOTH)
                {
#if (defined _NT1X_ && !defined _MAC)
                    GET_TIME(StartTime);
                     
                    if (0 != _wchdir(ptszNewDir))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in changing directory\n")));

                        hr = E_FAIL;
                    }
                
                    if (S_OK == hr)
                    {               
                        fileFile = _wfopen(ptszNames[0],TEXT("r+"));

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plRuntimeTime[usNumOpens] = 
                            DiffTime(EndTime, StartTime);

                        if (NULL == fileFile)
                        {
                            DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                            hr = E_FAIL;
                        }
                    }          
#else

                    GET_TIME(StartTime);
                     
                    if (0 != _chdir(ptszNewDir))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in changing directory\n")));

                        hr = E_FAIL;
                    }
                
                    if (S_OK == hr)
                    {               
                        fileFile = fopen(ptszNames[0],"r+");

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plRuntimeTime[usNumOpens] = 
                            DiffTime(EndTime, StartTime);

                        if (NULL == fileFile)
                        {
                            DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                            hr = E_FAIL;
                        }
                    }          
#endif
                    if (S_OK == hr)
                    {
                        fclose(fileFile);
                    }
                }
                else
                {

#if (defined _NT1X_ && !defined _MAC)
                    if (0 != _wchdir(ptszNewDir))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in changing directory\n")));

                        hr = E_FAIL;
                    }
                
                    if (S_OK == hr)
                    {  
                        GET_TIME(StartTime);

                        fileFile = _wfopen(ptszNames[0],TEXT("r+"));

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plRuntimeTime[usNumOpens] = 
                            DiffTime(EndTime, StartTime);

                        if (NULL == fileFile)
                        {
                            DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                            hr = E_FAIL;
                        }
                    }          
#else
                     
                    if (0 != _chdir(ptszNewDir))
                    {
                        DH_LOG((
                            LOG_INFO, 
                            TEXT("Error in changing directory\n")));

                        hr = E_FAIL;
                    }
                
                    if (S_OK == hr)
                    {               
                        GET_TIME(StartTime);
                        
                        fileFile = fopen(ptszNames[0],"r+");

                        GET_TIME(EndTime);

                        Time[usTimeIndex].plRuntimeTime[usNumOpens] = 
                            DiffTime(EndTime, StartTime);

                        if (NULL == fileFile)
                        {
                            DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                            hr = E_FAIL;
                        }
                    }          
#endif
                    if (S_OK == hr)
                    {
                        fclose(fileFile);
                    }
                }
            }
        }

        // Clean up

        if ((S_OK == hr) && (dwFlags & RUNTIME))
        {
            // Remove the directory and the file under it

            if ((S_OK == hr) && (NULL != ptszNames[0]))
            {
                if (FALSE == DeleteFile(ptszNames[0]))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError()) ;

                    DH_HRCHECK(hr, TEXT("DeleteFile")) ;
                }
            }

#if (defined _NT1X_ && !defined _MAC)
            
            if (0 != _wchdir(ptszCurDir))
            {
                DH_LOG((
                    LOG_INFO, 
                    TEXT("Error in changing directory\n")));

                hr = E_FAIL;
            }

            if (S_OK == hr)
            {
                if (0 != _wrmdir(ptszNames[0]))
                {
                    DH_LOG((
                        LOG_INFO,
                        TEXT("Error in removing directory\n")));

                    hr = E_FAIL;
                }
            }
                        
#else
            if (0 != _chdir(ptszCurDir))
            {
                DH_LOG((
                    LOG_INFO, 
                    TEXT("Error in changing directory\n")));

                hr = E_FAIL;
            }

            if (S_OK == hr)
            {
                if (0 != _rmdir(ptszNames[0]))
                {
                    DH_LOG((
                        LOG_INFO,
                        TEXT("Error in removing directory\n")));

                    hr = E_FAIL;
                }
            }
#endif                        
            if (NULL != ptszNewDir)
            {
                delete []ptszNewDir;
                ptszNewDir = NULL;
            }

            if (NULL != ptszCurDir)
            {
                delete []ptszCurDir;
                ptszCurDir = NULL;
            }
        }

        if (NULL != pOleName)
        {
            delete []pOleName;
            pOleName = NULL;
        }

        if ((NULL != ptszNames[0]) && (dwFlags & DOCFILE))
        {
            if (FALSE == DeleteFile(ptszNames[0]))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;

                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }
        }

        if (NULL != ptszNames[0])
        {
            delete []ptszNames[0];
            ptszNames[0] = NULL;
        }
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
// Function: WriteStreamInSameSizeChunks
//
// Synopsis: Create and open all the docfiles or C-runtime files, and then
//           write data in the same size chunks to docfiles or C-runtime
//           files, also record the time of the all the write operations
//           in Time[]. Each WRITE could be RANDOM_WRITE or SEQUENTIAL_WRITE.
//
// Arguments: [dwRootMode] - The access mode for the root docfile
//            [pdgu] - Pointer to Data Unicode object
//            [usTimeIndex] - Indicate it is RANDOM_WRITE or SEQUENTIAL_WRITE
//            [dwFlags] - Indicate write to DOCFILE or RUNTIME file
//            [ulChunkSize] - The size of each chunk to write
//            [usIteration] - Indicate this is the usIteration'th write
//
// Returns: HResult
//
// History: 6-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

HRESULT WriteStreamInSameSizeChunks(
    DWORD       dwRootMode,
    DG_STRING  *pdgu,
    USHORT      usTimeIndex,
    DWORD       dwFlags,
    ULONG       ulChunkSize,
    USHORT      usIteration)
{
    HRESULT         hr                  = S_OK;
    DWORD           StartTime           = 0;
    DWORD           EndTime             = 0;
    ULONG           culBytesLeftToWrite = 0;
    LPTSTR          ptcsBuffer          = NULL;
    LPOLESTR        pOleName            = NULL;
    ULONG           pcbCount            = 0;
    USHORT          usSeekIndex         = 0;
    USHORT          usIndex             = 0;
    ULONG           ulUserChunk         = 0;
    ULONG           bufferSize          = 0;
    DWORD           dwWriteCRC          = 0;
    DWORD           dwReadCRC           = 0;
    ULONG           ulRef               = 0;
    LPSTORAGE       pstgRoot[MAX_DOCFILES];
    LPSTREAM        pstmStream[MAX_DOCFILES];
    FILE            *fileFile[MAX_DOCFILES];
    LARGE_INTEGER   liStreamPos;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("WriteStreamInSameSizeChunks"));
    
    DH_VDATEPTRIN(pdgu, DG_STRING);

    DH_ASSERT(NULL != pdgu);

    // Initialization

    culBytesLeftToWrite = ulStreamSize;
    ulUserChunk = ulChunkSize;

    // Create & open all the docfiles or C-runtime files

    if (S_OK == hr)
    {
        for (usIndex=0; usIndex<MAX_DOCFILES; usIndex++)
        {
            if (dwFlags & DOCFILE)
            {
                hr = TStringToOleString(ptszNames[usIndex], &pOleName);
                DH_HRCHECK(hr, TEXT("TStringToOleString"));

                if (S_OK == hr)
                {
                    hr = StgCreateDocfile(
                            pOleName,
                            dwRootMode | STGM_CREATE,
                            0,
                            &pstgRoot[usIndex]);

                    DH_HRCHECK(hr, TEXT("StgCreateDocfile"));
                }

                if (S_OK == hr)
                {
                    hr = pstgRoot[usIndex]->CreateStream(
                            pOleName,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            0,
                            0,
                            &pstmStream[usIndex]);

                    DH_HRCHECK(hr, TEXT("IStorage::CreateStream"));
                }

                if (S_OK == hr)
                {
                    hr = pstgRoot[usIndex]->Commit(STGC_DEFAULT);

                    DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                }
                
                if (NULL != pOleName)
                {
                    delete []pOleName;
                    pOleName = NULL;
                }

                if (S_OK != hr)
                {
                    break;
                }
            }
            else
            {

#if (defined _NT1X_ && !defined _MAC)
                 
                fileFile[usIndex] = _wfopen(ptszNames[usIndex],TEXT("w+b"));

                if (NULL == fileFile[usIndex])
                {
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                    hr = E_FAIL;
                    break;
                }
                
#else
                fileFile[usIndex] = fopen(ptszNames[usIndex],"w+b");

                if (NULL == fileFile[usIndex])
                {
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                    hr = E_FAIL;
                    break;
                }
#endif
            }
        }
    }

    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu,
                ulChunkSize,
                ulChunkSize,
                &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString"));
    }

    if (S_OK == hr)
    {
        GET_TIME(StartTime);

        // Perform write operations on each of the MAX_DOCFILES files

        for (usIndex=0; usIndex<MAX_DOCFILES; usIndex++)
        {
            culBytesLeftToWrite = ulStreamSize;
            usSeekIndex = 0;
            ulChunkSize = ulUserChunk;

            while (0 != culBytesLeftToWrite)
            {
                if (ulChunkSize > culBytesLeftToWrite)
                {
                    ulChunkSize = culBytesLeftToWrite;
                }
                culBytesLeftToWrite -= ulChunkSize;

                if (dwFlags & DOCFILE)
                {
                    if (RANDOM_WRITE == usTimeIndex)
                    {
                        LISet32(liStreamPos,ulSeekOffset[usSeekIndex]);
                        usSeekIndex++;

                        hr = pstmStream[usIndex]->Seek(
                                liStreamPos,
                                STREAM_SEEK_SET,
                                NULL);

                        DH_HRCHECK(hr, TEXT("IStream::Seek"));
                    }

                    if (S_OK == hr)
                    {
                        hr = pstmStream[usIndex]->Write(
                                (LPBYTE)ptcsBuffer,
                                ulChunkSize,
                                &pcbCount);

                        DH_HRCHECK(hr, TEXT("IStream::Write"));
                    }
                }
                else 
                {
                    if (RANDOM_WRITE == usTimeIndex)
                    {
                        fseek(
                            fileFile[usIndex], 
                            (LONG) ulSeekOffset[usSeekIndex++],
                            SEEK_SET);

                        if (ferror(fileFile[usIndex]))
                        {
                            DH_LOG((LOG_INFO, TEXT("Error seeking file\n")));

                            hr = E_FAIL;
                        }
                    }
                    
                    if (S_OK == hr)
                    {
                        fwrite(
                            (LPBYTE)ptcsBuffer, 
                            (size_t)ulChunkSize, 
                            1,
                            fileFile[usIndex]);

                        if (ferror(fileFile[usIndex]))
                        {
                            DH_LOG((LOG_INFO, TEXT("Error writing file\n")));

                            hr = E_FAIL;
                        }
                    }
                }
                
                if (S_OK != hr)
                {
                    break;
                }
            }

            if (S_OK == hr)
            {
                if (dwFlags & DOCFILE)
                {
                    if (dwFlags & COMMIT)
                    {
                        hr = pstgRoot[usIndex]->Commit(STGC_DEFAULT);

                        DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                    }

                    if (S_OK == hr)
                    {
                        ulRef = pstmStream[usIndex]->Release();
                        DH_ASSERT(0 == ulRef);
                        pstmStream[usIndex] = NULL;

                        ulRef = pstgRoot[usIndex]->Release();
                        DH_ASSERT(0 == ulRef);
                        pstgRoot[usIndex] = NULL;
                    }
                }
                else
                {
                    fclose(fileFile[usIndex]);
                }               
            }

            if (S_OK != hr)
            {
                break;
            }
        }

        if (S_OK == hr)
        {
            GET_TIME(EndTime);
 
            if (dwFlags & DOCFILE)
            {
                Time[usTimeIndex].plDocfileTime[usIteration] = 
                    DiffTime(EndTime, StartTime) / MAX_DOCFILES;
            }
            else
            {
                Time[usTimeIndex].plRuntimeTime[usIteration] = 
                    DiffTime(EndTime, StartTime) / MAX_DOCFILES;
            }
        }
    }

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// Function: ReadStreamInSameSizeChunks
//
// Synopsis: Open all the docfiles or C-runtime files created before, then
//           read data in the same size chunks from docfiles or C-runtime
//           files, also record the time of the all the read operations
//           in Time[]. Each READ could be RANDOM_READ or SEQUENTIAL_READ.
//
// Arguments: [dwRootMode] - Access Mode for the root storage
//            [usTimeIndex] - Indicate it is RANDOM_WRITE or SEQUENTIAL_WRITE
//            [dwFlags] - Indicate reading from DOCFILE or RUNTIME file
//            [ulChunkSize] - The size of each chunk to read
//            [usIteration] - Indicate this is the usIteration'th read
//
// Returns: HResult
//
// History: 8-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------


HRESULT ReadStreamInSameSizeChunks(
    DWORD   dwRootMode,
    USHORT  usTimeIndex,
    DWORD   dwFlags,
    ULONG   ulChunkSize,
    USHORT  usIteration)
{
    HRESULT         hr                  = S_OK;
    DWORD           StartTime           = 0;
    DWORD           EndTime             = 0;
    ULONG           culBytesLeftToRead  = 0;
    LPBYTE          pbBuffer            = NULL;
    LPOLESTR        pOleName            = NULL;
    ULONG           pcbCount            = 0;
    USHORT          usSeekIndex         = 0;
    USHORT          usIndex             = 0;
    ULONG           ulUserChunk         = 0;
    ULONG           bufferSize          = 0;
    DWORD           dwWriteCRC          = 0;
    DWORD           dwReadCRC           = 0;
    ULONG           ulRef               = 0;
    LPSTORAGE       pstgRoot[MAX_DOCFILES];
    LPSTREAM        pstmStream[MAX_DOCFILES];
    FILE            *fileFile[MAX_DOCFILES];
    LARGE_INTEGER   liStreamPos;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ReadStreamInSameSizeChunks"));
    
    // Initialization

    culBytesLeftToRead = ulStreamSize;
    ulUserChunk = ulChunkSize;

    // Open all the docfiles or C-runtime files

    if (S_OK == hr)
    {
        for (usIndex=0; usIndex<MAX_DOCFILES; usIndex++)
        {
            if (dwFlags & DOCFILE)
            {
                hr = TStringToOleString(ptszNames[usIndex], &pOleName);
                DH_HRCHECK(hr, TEXT("TStringToOleString"));

                if (S_OK == hr)
                {
                    hr = StgOpenStorage(
                            pOleName,
                            NULL,
                            dwRootMode,
                            NULL,
                            0,
                            &pstgRoot[usIndex]);

                    DH_HRCHECK(hr, TEXT("StgOpenStorage"));
                }

                if (S_OK == hr)
                {
                    hr = pstgRoot[usIndex]->OpenStream(
                            pOleName,
                            NULL,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            0,
                            &pstmStream[usIndex]);

                    DH_HRCHECK(hr, TEXT("IStorage::OpenStream"));
                }
                
                if (NULL != pOleName)
                {
                    delete []pOleName;
                    pOleName = NULL;
                }

                if (S_OK != hr)
                {
                    break;
                }
            }
            else
            {

#if (defined _NT1X_ && !defined _MAC)
  
                fileFile[usIndex] = _wfopen(ptszNames[usIndex], TEXT("r+b"));

                if (NULL == fileFile[usIndex])
                {
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                    hr = E_FAIL;
                    break;
                }
                
#else
                fileFile[usIndex] = fopen(ptszNames[usIndex],"r+b");

                if (NULL == fileFile[usIndex])
                {
                    DH_LOG((LOG_INFO, TEXT("Error in opening file\n")));
                    
                    hr = E_FAIL;
                    break;
                }
#endif
            }
        }
    }

    if (S_OK == hr)
    {
        GET_TIME(StartTime);

        // Perform write operations on each of the MAX_DOCFILES files

        for (usIndex=0; usIndex<MAX_DOCFILES; usIndex++)
        {
            culBytesLeftToRead = ulStreamSize;
            usSeekIndex = 0;
            ulChunkSize = ulUserChunk;

            while (0 != culBytesLeftToRead)
            {
                if (ulChunkSize > culBytesLeftToRead)
                {
                    ulChunkSize = culBytesLeftToRead;
                }
                culBytesLeftToRead -= ulChunkSize;

                pbBuffer = new BYTE[ulChunkSize];

                if (NULL == pbBuffer)
                {
                    hr = E_OUTOFMEMORY;
                }

                if (S_OK == hr)
                {
                    memset(pbBuffer, '\0', ulChunkSize * sizeof(BYTE));
                }

                if ((S_OK == hr) && (dwFlags & DOCFILE))
                {
                    if (RANDOM_READ == usTimeIndex)
                    {
                        LISet32(liStreamPos,ulSeekOffset[usSeekIndex]);
                        usSeekIndex++;

                        hr = pstmStream[usIndex]->Seek(
                                liStreamPos,
                                STREAM_SEEK_SET,
                                NULL);

                        DH_HRCHECK(hr, TEXT("IStream::Seek"));
                    }

                    if (S_OK == hr)
                    {
                        hr = pstmStream[usIndex]->Read(
                                pbBuffer,
                                ulChunkSize,
                                &pcbCount);

                        DH_HRCHECK(hr, TEXT("IStream::Read"));
                    }
                }
                else 
                {
                    if ((S_OK == hr) && (RANDOM_READ == usTimeIndex))
                    {
                        fseek(
                            fileFile[usIndex], 
                            (LONG) ulSeekOffset[usSeekIndex++],
                            SEEK_SET);

                        if (ferror(fileFile[usIndex]))
                        {
                            DH_LOG((LOG_INFO, TEXT("Error seeking file\n")));

                            hr = E_FAIL;
                        }
                    }
                    
                    if (S_OK == hr)
                    {
                        fread(
                            pbBuffer, 
                            (size_t)ulChunkSize, 
                            1,
                            fileFile[usIndex]);

                        if (ferror(fileFile[usIndex]))
                        {
                            DH_LOG((LOG_INFO, TEXT("Error reading file\n")));

                            hr = E_FAIL;
                        }
                    }
                }
            
                if (NULL != pbBuffer)
                {
                    delete []pbBuffer;
                    pbBuffer = NULL;
                }

                if (S_OK != hr)
                {
                    break;
                }
            }

            if (S_OK != hr)
            {
                break;
            }
        }

        if (S_OK == hr)
        {
            GET_TIME(EndTime);

            for (usIndex=0; usIndex<MAX_DOCFILES; usIndex++)
            {
                if (dwFlags & DOCFILE)
                {
                    ulRef = pstmStream[usIndex]->Release();
                    DH_ASSERT(0 == ulRef);
                    pstmStream[usIndex] = NULL;
                    
                    ulRef = pstgRoot[usIndex]->Release();
                    DH_ASSERT(0 == ulRef);
                    pstgRoot[usIndex] = NULL;
                }
                else
                {
                    fclose(fileFile[usIndex]);
                }
            }
        }

        if (S_OK == hr)
        {
            if (dwFlags & DOCFILE)
            {
                Time[usTimeIndex].plDocfileTime[usIteration] = 
                    DiffTime(EndTime, StartTime) / MAX_DOCFILES;
            }
            else
            {
                Time[usTimeIndex].plRuntimeTime[usIteration] = 
                    DiffTime(EndTime, StartTime) / MAX_DOCFILES;
            }
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// Function: Statistics
//
// Synopsis: Generate statistics data: average, total and square difference.
//
// Arguments: [pdData] - pointer to data
//            [usItems] - Number of data items
//            [pdAverage] - Average value of data
//            [pdTotal] - Total value of data
//            [pdSD] - Square difference of data
//
// Returns: None
//
// History: 6-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

void    Statistics(
    double  *pdData, 
    USHORT  usItems, 
    double  *pdAverage, 
    double  *pdTotal,
    double  *pdSD)
{
    USHORT  usIndex = 0;
    double  dTemp;

    *pdTotal = 0;

    for (usIndex=0; usIndex<usItems; usIndex++)
    {
        *pdTotal += pdData[usIndex];
    }

    *pdAverage = *pdTotal / usItems;
    *pdSD = 0;

    for (usIndex=0; usIndex<usItems; usIndex++)
    {
        dTemp = (pdData[usIndex] - *pdAverage);
        *pdSD += (dTemp * dTemp);
    }

    if (usItems > 1)
    {
        *pdSD = *pdSD / (usItems - 1);
    }

    *pdSD = sqrt(*pdSD); 
}

//----------------------------------------------------------------------------
//
// Function: Statistics
//
// Synopsis: Generate statistics data: average, total and square difference.
//
// Arguments: [pdData] - pointer to data
//            [usItems] - Number of data items
//            [pdAverage] - Average value of data
//            [pdTotal] - Total value of data
//            [pdSD] - Square difference of data
//
// Returns: None
//
// History: 6-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------
 
void    Statistics(
    LONG    *plData, 
    USHORT  usItems, 
    LONG    *plAverage, 
    double  *pdTotal,
    double  *pdSD)
{
    USHORT  usIndex     = 0;
    double  dAverage;
    double  *pdData;

    pdData = new double[usItems];

    for (usIndex=0; usIndex<usItems; usIndex++)
    {
        pdData[usIndex] = plData[usIndex];
    }

    Statistics(pdData, usItems, &dAverage, pdTotal, pdSD);

    *plAverage = (LONG)dAverage;

    delete [] pdData;
}

//----------------------------------------------------------------------------
//
// Function: DiffTime
//
// Synopsis: Calculate and return the difference of two time.
//
// Arguments: [EndTime] - the time when an operation ended
//            [StartTime] - the time when an operation started
//   
// Returns:  LONG
//
// History:  6-Aug-1996    JiminLi     Created
//           
//-----------------------------------------------------------------------------

LONG DiffTime(DWORD EndTime, DWORD StartTime)
{
    LONG lResult    = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DiffTime"));
    
    DH_ASSERT(StartTime <= EndTime);

    lResult = EndTime - StartTime;

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgdrt\illeg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	illeg.cxx
//
//  Contents:	Illegitimate tests
//
//  History:	17-Nov-92	DrewB	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "illeg.hxx"

void i_storage(void)
{
    WStorage *pwstg;
    IStorage *pstg, *pstg2;
    IStream *pstm;

    IllResult("StgCreateDocfile with NULL ppstg",
             StgCreateDocfile(NULL, 0, 0, NULL));
    IllResult("StgCreateDocfile with non-zero reserved",
             StgCreateDocfile(NULL, 0, 1, &pstg));
    IllResult("StgCreateDocfile with illegal permissions",
             StgCreateDocfile(NULL, 0, 0, &pstg));

    int fd;
    fd = _creat(OlecsOut(DRTDF), _S_IREAD);
    if (fd<0)
        error(EXIT_BADSC, "Unable to create file '%s'\n", OlecsOut(DRTDF));
    _close(fd);
    IllResult("StgCreateDocfile with STGM_WRITE over read-only file",
             StgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pstg));
    _chmod(OlecsOut(DRTDF), _S_IREAD | _S_IWRITE);

    IllResult("StgOpenStorage with NULL ppstg",
             StgOpenStorage(NULL, NULL, 0, NULL, 0, NULL));
    IllResult("StgOpenStorage with NULL name",
             StgOpenStorage(NULL, NULL, 0, NULL, 0, &pstg));
    IllResult("StgOpenStorage with illegal permissions",
             StgOpenStorage(DRTDF, NULL, 0xffffffff, NULL, 0, &pstg));
    IllResult("StgOpenStorage with non-zero reserved",
             StgOpenStorage(DRTDF, NULL, ROOTP(STGM_READWRITE), NULL,
                            1, &pstg));
#if WIN32 != 300
    // This will work on Cairo because it will open a file storage
    IllResult("StgOpenStorage on non-docfile",
             StgOpenStorage(DRTDF, NULL, ROOTP(STGM_READWRITE), NULL,
                            0, &pstg));
#endif
    
    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE) | STGM_CREATE, 0, &pwstg);
    pstg = pwstg->GetI();
    IllResult("OpenStream that doesn't exist",
             pstg->OpenStream(STR("NoName"), 0, STMP(STGM_READWRITE),
                              0, &pstm));
    IllResult("OpenStorage that doesn't exist",
             pstg->OpenStorage(STR("NoName"), NULL, STGP(STGM_READWRITE),
                               NULL, 0, &pstg2));
    pwstg->Unwrap();
}

#define STREAMSIZE 128

void i_stream(void)
{
    WStorage *pwstg;
    WStream *pwstm;
    IStream *pstm;
    BYTE bBuffer[STREAMSIZE];
    ULONG cbRead;
    LARGE_INTEGER liSeek;
    ULARGE_INTEGER uliPos;
    ULARGE_INTEGER uliSize;
    ULARGE_INTEGER cb;

    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pwstg);
    pwstg->CreateStream(STR("Stream"), STMP(STGM_READ), 0, 0, &pwstm);
    pstm = pwstm->GetI();
    
    IllResult("Read with NULL buffer",
             pstm->Read(NULL, STREAMSIZE, NULL));
    fExitOnFail = FALSE;
    pwstm->Read(bBuffer, STREAMSIZE, &cbRead);
    fExitOnFail = TRUE;
    if (cbRead != 0)
        error(EXIT_BADSC, "Read %lu bytes on zero-length stream\n", cbRead);

    IllResult("Write with NULL buffer",
             pstm->Write(NULL, STREAMSIZE, NULL));
    IllResult("Write on read-only stream",
             pstm->Write(bBuffer, STREAMSIZE, NULL));

    LISet32(liSeek, 0);
    IllResult("Seek with invalid origin",
             pstm->Seek(liSeek, (DWORD)(~STREAM_SEEK_SET), NULL));
#pragma warning(disable:4245)
    // LISet32 in objbase.h has a bug that issues warning for negative values
    LISet32(liSeek, -1);
#pragma warning(default:4245)
    IllResult("Seek before beginning",
             pstm->Seek(liSeek, STREAM_SEEK_CUR, NULL));

    ULISet32(uliSize, STREAMSIZE);
    IllResult("SetSize on read-only stream",
             pstm->SetSize(uliSize));

    ULISet32(uliPos, 0);
    ULISet32(cb, STREAMSIZE);
    IllResult("LockRegion attempt",
             pstm->LockRegion(uliPos, cb, LOCK_ONLYONCE));
    IllResult("UnlockRegion attempt",
             pstm->UnlockRegion(uliPos, cb, LOCK_ONLYONCE));
    
    pwstm->Unwrap();
    pwstg->Unwrap();
}

void i_enum(void)
{
    WStorage *pwstg;
    IStorage *pstg;
    IEnumSTATSTG *penm;
    
    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pwstg);
    pstg = pwstg->GetI();
    
    IllResult("EnumElements with NULL ppenm",
             pstg->EnumElements(0, NULL, 0, NULL));
    IllResult("EnumElements with non-zero reserved1",
             pstg->EnumElements(1, NULL, 0, &penm));
    IllResult("EnumElements with non-zero reserved2",
             pstg->EnumElements(0, (void *)1, 0, &penm));
    IllResult("EnumElements with non-zero reserved3",
             pstg->EnumElements(0, NULL, 1, &penm));
    
    pwstg->Unwrap();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgdrt\ilb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	ilbmem.cx
//
//  Contents:	ILockBytes memory implementation
//
//  Classes:	CMapBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <memory.h>
#include <ilb.hxx>

#if DBG == 1

DECLARE_INFOLEVEL(ol);

#endif

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::CMapBytes, public
//
//  Synopsis:   constructor
//
//  Effects:    initialize member variables
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//  Notes:      Returns a fully initialized CMapBytes (ref count == 1)
//
//--------------------------------------------------------------------------

CMapBytes::CMapBytes(void)
{
    _ulSize = 0;
    _pv = 0;

    _ulRef = 1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::QueryInterface, public
//
//  Arguments:	[riid] - interface id
//		[ppvObj] - place holder for interface
//
//  Returns:    Always fails
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//  Notes:      Not used in tests
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::AddRef, public
//
//  Synopsis:	add reference
//
//  Returns:    post reference count
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMapBytes::AddRef(void)
{
    AtomicInc(&_ulRef);
    return(_ulRef);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Release, public
//
//  Synopsis:	release reference
//
//  Effects:	deletes object when reference count reaches zero
//
//  Returns:	post reference count
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMapBytes::Release(void)
{
    AtomicDec(&_ulRef);

    if (_ulRef > 0)
        return(_ulRef);

    free(_pv);

    delete this;

    return(0);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::ReadAt
//
//  Synopsis:   Reads bytes from memory
//
//  Arguments:  [ulOffset] - byte offset
//		[pv]       - input buffer
//		[cb]       - count of bytes to read
//		[pcbRead]  - count of bytes read
//
//  Returns:    SCODE
//
//  Modifies:   pv, pcbRead
//
//  Derivation: ILockBytes
//
//  History:    30-Oct-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::ReadAt(ULARGE_INTEGER uliOffset,
			       VOID HUGEP *pv,
			       ULONG cb,
			       ULONG *pcbRead)
{
    olAssert(ULIGetHigh(uliOffset) == 0);

    ULONG ulOffset = ULIGetLow(uliOffset);
    if (ulOffset >= _ulSize)
    {
        //  truncate read
        cb = 0;
    }
    else if (cb > (_ulSize - ulOffset))
    {
        //  truncate range that exceeds size
        cb = _ulSize - ulOffset;
    }

    memcpy(pv, (void*)(((BYTE*)_pv) + ulOffset), (size_t) cb);
    *pcbRead = cb;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::WriteAt, public
//
//  Synopsis:	Writes bytes to memory
//
//  Effects:	May change memory size
//
//  Arguments:	[uliOffset]  - byte offset
//		[pv]         - output buffer
//		[cb]         - count of bytes to write
//		[pcbWritten] - count of bytes written
//
//  Returns:	SCODE
//
//  Modifies:	pcbWritten
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//  Notes:	This implementation doesn't write partial buffers.
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::WriteAt(ULARGE_INTEGER uliOffset,
				VOID const HUGEP *pv,
				ULONG cb,
				ULONG FAR *pcbWritten)
{
    olAssert(ULIGetHigh(uliOffset) == 0);

    ULONG ulOffset = ULIGetLow(uliOffset);
    HRESULT hr;

    if (ulOffset + cb > _ulSize)
    {
        //  increase memory buffer to accomodate write

        ULARGE_INTEGER uliSize;

        ULISetHigh(uliSize, 0);
        ULISetLow(uliSize, ulOffset + cb);
        hr = SetSize(uliSize);

        if (FAILED(DfGetScode(hr)))
        {
            //  don't bother writing partial buffers

            *pcbWritten = 0;
            return hr;
        }
    }

    memcpy((void *)(((BYTE*)_pv) + ulOffset), pv, (size_t) cb);
    *pcbWritten = cb;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Flush, public
//
//  Synopsis:	flushes memory - not appropriate for this implementation
//
//  Effects:	none
//
//  Returns:    SUCCESS_SUCCESS
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::Flush(void)
{
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::GetSize, public
//
//  Synopsis:	gets memory buffer size
//
//  Arguments:	[pcb] - size place holder
//
//  Returns:	SUCCESS_SUCCESS
//
//  Modifies:	pcb
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::GetSize(ULARGE_INTEGER FAR *pcb)
{
    ULISetHigh(*pcb, 0);
    ULISetLow(*pcb, _ulSize);
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::SetSize, public
//
//  Synopsis:	sets memory buffer size
//
//  Effects:	may change buffer size
//
//  Arguments:	[ulicb] - new memory size
//
//  Returns:	SCODE
//
//  Derivation: ILockBytes
//
//  Algorithm:  realloc the buffer
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::SetSize(ULARGE_INTEGER ulicb)
{
    olAssert(ULIGetHigh(ulicb) == 0);

    ULONG cb = ULIGetLow(ulicb);

    if (cb == _ulSize)
        return NOERROR;

    void *pv = realloc(_pv, (size_t) cb);

    if ((cb > 0) && (pv == NULL))
    {
        //  Unable to allocate memory
        //  Leave current memory and size alone

        return ResultFromScode(E_OUTOFMEMORY);
    }

    _pv = pv;
    _ulSize = cb;

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::LockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Effects:	asserts if called
//
//  Arguments:	[libOffset]  - lock range offset
//		[cb]         - lock range size
//		[dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::LockRegion(ULARGE_INTEGER libOffset,
				   ULARGE_INTEGER cb,
				   DWORD dwLockType)
{
    olAssert(0 && "Can't lock CMapBytes");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::UnLockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Effects:	asserts if called
//
//  Arguments:	[libOffset]  - lock range offset
//		[cb]         - lock range size
//		[dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::UnlockRegion(ULARGE_INTEGER libOffset,
				     ULARGE_INTEGER cb,
				     DWORD dwLockType)
{
    olAssert(0 && "Can't unlock CMapBytes");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Stat, public
//
//  Synopsis:	Provide instance information
//
//  Arguments:	[pstatstg]    - status buffer
//		[grfStatFlag] - status flags
//
//  Returns:	SCODE
//
//  Modifies:	pstatstg
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//  Notes:	No time stamps
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    memset(pstatstg, 0, sizeof(STATSTG));

    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        static char const abName[] = "Memory";

        HRESULT hr;

        if (FAILED(DfGetScode(hr = drtMemAlloc(sizeof(abName),
                                             (void **) &pstatstg->pwcsName))))
            return hr;

        memcpy(pstatstg->pwcsName, abName, sizeof(abName));
    }

    pstatstg->type = STGTY_LOCKBYTES;

    ULISetHigh(pstatstg->cbSize, 0);
    ULISetLow(pstatstg->cbSize, _ulSize);

    pstatstg->grfMode = STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgdrt\tests.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	tests.cxx
//
//  Contents:	DRT tests
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include "tests.hxx"
#include "ilb.hxx"

void t_create(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(STR("Child"), STGP(WSTG_READWRITE), 0, 0,
			    &pstgChild);
    pstgChild->CreateStorage(STR("Child2"), STGP(WSTG_READWRITE), 0, 0,
			     &pstgChild2);
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild2->Commit(0);
    pstgChild2->Unwrap();
    pstgChild->Commit(0);
    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dChild2(sStream))");
    pstgRoot->Unwrap();
}

void t_open(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		     0, &pstgRoot);
    CreateStructure(pstgRoot->GetI(), "dChild(dChild2(sStream))");
    pstgRoot->Commit(0);
    pstgRoot->Unwrap();

    WStgOpenStorage(DRTDF, NULL, ROOTP(WSTG_READWRITE), NULL,
		    0, &pstgRoot);
    pstgRoot->OpenStorage(STR("Child"), NULL, STGP(WSTG_READWRITE), NULL, 0,
			  &pstgChild);
    pstgChild->OpenStorage(STR("Child2"), NULL, STGP(WSTG_READWRITE), NULL, 0,
			   &pstgChild2);
    pstgChild2->OpenStream(STR("Stream"), NULL, STMP(WSTG_READWRITE), 0,
			   &pstm);
    pstm->Unwrap();
    pstgChild2->Unwrap();
    pstgChild->Unwrap();
    pstgRoot->Unwrap();
}

void t_addref(void)
{
    WStorage *pstg;
    WStream *pstm;
    ULONG ul;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstg);
    pstg->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
#ifndef FLAT
    if ((ul = pstm->AddRef()) != 2)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstm->Release()) != 1)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    pstm->Unwrap();
    if ((ul = pstg->AddRef()) != 2)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstg->Release()) != 1)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
#else
    if ((ul = pstm->AddRef()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstm->Release()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    pstm->Unwrap();
    if ((ul = pstg->AddRef()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstg->Release()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
#endif
    pstg->Unwrap();
}

void t_tmodify(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;

    // This test must use transacted mode to reproduce the
    // expected behavior
    ForceTransacted();

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(STR("Child"), STGP(WSTG_READWRITE), 0,
                            0, &pstgChild);
    pstgChild->CreateStorage(STR("Child2"), STGP(WSTG_READWRITE), 0,
			     0, &pstgChild2);
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Unwrap();
    pstgChild2->Commit(0);
    VerifyStructure(pstgChild2->GetI(), "sStream");

    // Test renaming a closed stream
    pstgChild2->RenameElement(STR("Stream"), STR("RenamedStream"));
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");

    // Test rename reversion
    pstgChild2->Revert();
    VerifyStructure(pstgChild2->GetI(), "sStream");

    // Test destruction of closed object
    pstgChild2->DestroyElement(STR("Stream"));
    pstgChild2->Commit(0);

    // Test create of previously deleted object
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstgChild2->Commit(0);
    VerifyStructure(pstgChild2->GetI(), "sStream");

#if 0
    // 08/11/93 - Renaming open children no longer allowed
    // Test renaming an open stream
    pstgChild2->RenameElement(STR("Stream"), STR("RenamedStream"));
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");
#endif

    pstgChild2->Revert();
    VerifyStructure(pstgChild2->GetI(), "sStream");
    pstgChild2->DestroyElement(STR("Stream"));
    pstgChild2->Commit(0);
    pstm->Unwrap();

    pstgChild2->Unwrap();
    VerifyStructure(pstgChild->GetI(), "dChild2()");

    // Test rename of storage
    pstgChild->RenameElement(STR("Child2"), STR("RenamedChild"));
    pstgChild->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild->DestroyElement(STR("Stream"));
    pstgChild->Commit(0);

    // Test SetElementTimes
    FILETIME tm;
    STATSTG stat;

    tm.dwLowDateTime = 0x12345678;
    tm.dwHighDateTime = 0x01bcdef0;

    // Set when element not open
    pstgChild->SetElementTimes(STR("RenamedChild"), &tm, NULL, NULL);
    pstgChild->SetElementTimes(STR("RenamedChild"), NULL, &tm, NULL);
    pstgChild->SetElementTimes(STR("RenamedChild"), NULL, NULL, &tm);

    pstgChild->OpenStorage(STR("RenamedChild"), NULL, STGP(WSTG_READWRITE),
                           NULL, 0, &pstgChild2);
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualTime(stat.ctime, tm) ||
        !IsEqualTime(stat.mtime, tm))
        error(EXIT_BADSC, "Times don't match those set by SetElementTimes\n");

    // Test SetClass and SetStateBits
    pstgChild2->SetClass(IID_IStorage);
    fExitOnFail = FALSE;
    pstgChild2->SetStateBits(0xff00ff00, 0xffffffff);
    pstgChild2->SetStateBits(0x00880088, 0xeeeeeeee);
    fExitOnFail = TRUE;
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualCLSID(stat.clsid, IID_IStorage))
        error(EXIT_BADSC, "Class ID set to %s\n", GuidText(&stat.clsid));
    if (stat.grfStateBits != 0x11881188)
        errorprint("State bits set improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0x11881188);
    pstgChild2->Revert();
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualCLSID(stat.clsid, CLSID_NULL))
        error(EXIT_BADSC, "Class ID reverted to %s\n", GuidText(&stat.clsid));
    if (stat.grfStateBits != 0)
        errorprint("State bits reverted improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0);
    pstgChild2->Unwrap();

    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Revert();
    VerifyStructure(pstgRoot->GetI(), "");
    pstgRoot->Commit(0);
    VerifyStructure(pstgRoot->GetI(), "");
    pstgRoot->Unwrap();
    Unforce();
}

void t_dmodify(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;
    ULONG cbSize1, cbSize2;

    // This test must use direct mode to reproduce the
    // expected behavior
    ForceDirect();

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(STR("Child"), STGP(WSTG_READWRITE), 0,
                            0, &pstgChild);
    pstgChild->CreateStorage(STR("Child2"), STGP(WSTG_READWRITE), 0,
			     0, &pstgChild2);
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Unwrap();
    VerifyStructure(pstgChild2->GetI(), "sStream");

    // Test renaming a closed stream
    pstgChild2->RenameElement(STR("Stream"), STR("RenamedStream"));
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");

    // Test destroying a stream
    pstgChild2->DestroyElement(STR("RenamedStream"));

#if 0
    // 08/11/93 - Renaming open child no longer allowed
    // Test renaming an open stream
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    VerifyStructure(pstgChild2->GetI(), "sStream");
    pstgChild2->RenameElement(STR("Stream"), STR("RenamedStream"));
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");
    pstgChild2->DestroyElement(STR("RenamedStream"));
    pstm->Unwrap();
#endif

    pstgChild2->Unwrap();
    VerifyStructure(pstgChild->GetI(), "dChild2()");

    // Test renaming a storage
    pstgChild->RenameElement(STR("Child2"), STR("RenamedChild"));
    pstgChild->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild->DestroyElement(STR("Stream"));

    // Test SetElementTimes
    FILETIME tm;
    STATSTG stat;

    tm.dwLowDateTime = 0x12345678;
    tm.dwHighDateTime = 0x01bcdef0;

    // Set when element not open
    pstgChild->SetElementTimes(STR("RenamedChild"), &tm, NULL, NULL);
    pstgChild->SetElementTimes(STR("RenamedChild"), NULL, &tm, NULL);
    pstgChild->SetElementTimes(STR("RenamedChild"), NULL, NULL, &tm);

    pstgChild->OpenStorage(STR("RenamedChild"), NULL, STMP(WSTG_READWRITE),
                           NULL, 0, &pstgChild2);
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualTime(stat.ctime, tm) ||
        !IsEqualTime(stat.mtime, tm))
        error(EXIT_BADSC, "Times don't match those set by SetElementTimes\n");

    // Test SetClass and SetStateBits
    pstgChild2->SetClass(IID_IStorage);
    fExitOnFail = FALSE;
    pstgChild2->SetStateBits(0xff00ff00, 0xffffffff);
    pstgChild2->SetStateBits(0x00880088, 0xeeeeeeee);
    fExitOnFail = TRUE;
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualCLSID(stat.clsid, IID_IStorage))
        error(EXIT_BADSC, "Class ID set improperly\n");
    if (stat.grfStateBits != 0x11881188)
        errorprint("State bits set improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0x11881188);
    pstgChild2->Unwrap();

    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Revert();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Commit(0);
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->DestroyElement(STR("Child"));
    VerifyStructure(pstgRoot->GetI(), "");

    // Verify that space is reclaimed after modifications
    pstgRoot->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->SetSize(65536);
    pstm->Unwrap();
    cbSize1 = Length(DRTDF);
    pstgRoot->DestroyElement(STR("Stream"));
    pstgRoot->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->SetSize(65536);
    pstm->Unwrap();
    cbSize2 = Length(DRTDF);
    if (cbSize1 != cbSize2)
        error(EXIT_BADSC, "Space is not being reclaimed, original %lu, "
              "now %lu\n", cbSize1, cbSize2);

    pstgRoot->Unwrap();

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgRoot);

    //  removal cases
    //    1) no right child

    CreateStructure(pstgRoot->GetI(), "d64,d32");
    VerifyStructure(pstgRoot->GetI(), "d64,d32");
    pstgRoot->DestroyElement(STR("64"));
    VerifyStructure(pstgRoot->GetI(), "d32");

    //    2) right child has no left child

    CreateStructure(pstgRoot->GetI(), "d64");
    VerifyStructure(pstgRoot->GetI(), "d32,d64");
    pstgRoot->DestroyElement(STR("32"));
    VerifyStructure(pstgRoot->GetI(), "d64");

    //    3) right child has left child

    CreateStructure(pstgRoot->GetI(), "d96,d80");
    VerifyStructure(pstgRoot->GetI(), "d64,d80,d96");
    pstgRoot->DestroyElement(STR("64"));
    VerifyStructure(pstgRoot->GetI(), "d80,d96");

    //    4) right child's left child has children

    CreateStructure(pstgRoot->GetI(), "d88,d84,d92");
    VerifyStructure(pstgRoot->GetI(), "d80,d84,d88,d92,d96");
    pstgRoot->DestroyElement(STR("80"));
    VerifyStructure(pstgRoot->GetI(), "d84,d88,d92,d96");

    pstgRoot->Unwrap();

    Unforce();
}

void t_stat(void)
{
    WStorage *pstgRoot, *pstgChild;
    WStream *pstm;
    STATSTG stat;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(STR("Child"), STGP(WSTG_READWRITE), 0, 0,
			    &pstgChild);
    pstgChild->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);

    pstm->Stat(&stat, 0);
    VerifyStat(&stat, STR("Stream"), STGTY_STREAM, STMP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstm->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STREAM, STMP(WSTG_READWRITE));

    pstm->Unwrap();

    pstgChild->Stat(&stat, 0);
    VerifyStat(&stat, STR("Child"), STGTY_STORAGE, STGP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstgChild->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STORAGE, STGP(WSTG_READWRITE));

    pstgChild->Unwrap();

    pstgRoot->Stat(&stat, 0);
    OLECHAR atcFullPath[_MAX_PATH];
    GetFullPath(DRTDF, atcFullPath);
    VerifyStat(&stat, atcFullPath, STGTY_STORAGE, ROOTP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstgRoot->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STORAGE, ROOTP(WSTG_READWRITE));

    pstgRoot->Unwrap();
}

static char NUMBERS[] = "12345678901234567890123456789012345678901234567890";

void t_stream(void)
{
    WStorage *pstg;
    WStream *pstm, *pstmC;
    char buf[sizeof(NUMBERS)*2];
    ULONG cb, ulPos;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE, 0, &pstg);
    pstg->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Write(NUMBERS, sizeof(NUMBERS), &cb);
    pstm->Commit(0);
    pstm->Seek(0, WSTM_SEEK_SET, &ulPos);
    if (ulPos != 0)
	error(EXIT_BADSC, "Incorrect seek, ptr is %lu\n", ulPos);
    pstm->Read(buf, sizeof(NUMBERS), &cb);
    if (strcmp(buf, NUMBERS))
	error(EXIT_BADSC, "Incorrect stream contents\n");
    pstm->SetSize(sizeof(NUMBERS)/2);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    fExitOnFail = FALSE;
    pstm->Read(buf, sizeof(NUMBERS), &cb);
    fExitOnFail = TRUE;
    if (cb != sizeof(NUMBERS)/2)
	error(EXIT_BADSC, "SetSize failed to size stream properly\n");
    if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2))
	error(EXIT_BADSC, "SetSize corrupted contents\n");
    pstm->Clone(&pstmC);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->CopyTo(pstmC, sizeof(NUMBERS)/2, NULL, NULL);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->CopyTo(pstmC, sizeof(NUMBERS)&~1, NULL, NULL);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->Read(buf, (sizeof(NUMBERS)&~1)*2, &cb);
    if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+sizeof(NUMBERS)/2, NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+(sizeof(NUMBERS)&~1), NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+3*(sizeof(NUMBERS)/2), NUMBERS, sizeof(NUMBERS)/2))
	error(EXIT_BADSC, "Stream contents incorrect\n");
    pstmC->Unwrap();
    pstm->Unwrap();
    pstg->Unwrap();
}

// Number of entries for enumeration test
#define ENUMENTRIES 10

// Flag indicating a name has already shown up in enumeration,
// must not conflict with STGTY_*
#define ENTRY_SEEN 0x100

// Check the validity of an enumeration element
static void elt_check(STATSTG *pstat, CStrList *psl)
{
    SStrEntry *pse;

    pse = psl->Find(pstat->pwcsName);
    if (pse == NULL)
        error(EXIT_BADSC, "Spurious element '%s'\n", pstat->pwcsName);
    else if ((pse->user.dw & ~ENTRY_SEEN) != pstat->type)
        error(EXIT_BADSC, "Element '%s' has wrong type - "
              "has %lX vs. %lX\n", pstat->pwcsName, pstat->type,
              pse->user.dw & ~ENTRY_SEEN);
    else if (pse->user.dw & ENTRY_SEEN)
        error(EXIT_BADSC, "Element '%s' has already been seen\n",
              pstat->pwcsName);
    pse->user.dw |= ENTRY_SEEN;
}

// Do final validity checks for enumeration
static void enum_list_check(CStrList *psl)
{
    SStrEntry *pse;

    for (pse = psl->GetHead(); pse; pse = pse->pseNext)
    {
        if ((pse->user.dw & ENTRY_SEEN) == 0)
            error(EXIT_BADSC, "Element '%s' not found\n", pse->atc);
        pse->user.dw &= ~ENTRY_SEEN;
    }
}

void t_enum(void)
{
    int i;
    OLECHAR atcName[CWCSTORAGENAME];
    WStorage *pstg, *pstg2;
    WStream *pstm;
    SStrEntry *pse;
    CStrList sl;

    // Create some entries to enumerate
    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE, 0, &pstg);
    for (i = 0; i<ENUMENTRIES; i++)
    {
	olecsprintf(atcName, STR("Name%d"), rand());
	pse = sl.Add(atcName);
	if (rand()%100 < 50)
	{
	    pse->user.dw = STGTY_STORAGE;
	    pstg->CreateStorage(atcName, STGP(WSTG_READWRITE), 0, 0, &pstg2);
	    pstg2->Unwrap();
	}
	else
	{
	    pse->user.dw = STGTY_STREAM;
	    pstg->CreateStream(atcName, STMP(WSTG_READWRITE), 0, 0, &pstm);
	    pstm->Unwrap();
	}
    }

    WEnumSTATSTG *penm;
    STATSTG stat[2*ENUMENTRIES];
    SCODE sc;

    // Test plain, single element enumeration
    pstg->EnumElements(0, NULL, 0, &penm);
    for (;;)
    {
	sc = DfGetScode(penm->Next(1, stat, NULL));
	if (sc == S_FALSE)
	    break;
        elt_check(stat, &sl);
        drtMemFree(stat->pwcsName);

    }
    enum_list_check(&sl);

    ULONG cFound;

    // Test rewind and multiple element enumeration with too many elements
    penm->Reset();
    sc = DfGetScode(penm->Next(ENUMENTRIES*2, stat, &cFound));
    if (sc != S_FALSE)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_FALSE\n", ScText(sc), sc);
    if (cFound != ENUMENTRIES)
        error(EXIT_BADSC, "Enumerator found %lu entries instead of "
              "%d entries\n", cFound, ENUMENTRIES);
    for (; cFound > 0; cFound--)
    {
        elt_check(&stat[cFound-1], &sl);
        drtMemFree(stat[cFound-1].pwcsName);
    }
    enum_list_check(&sl);

    // Test skip and multiple enumeration with exact number of elements
    penm->Reset();
    penm->Skip(ENUMENTRIES/2);
    sc = DfGetScode(penm->Next(ENUMENTRIES-ENUMENTRIES/2, stat, &cFound));
    if (sc != S_OK)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_OK\n", ScText(sc), sc);
    if (cFound != ENUMENTRIES-ENUMENTRIES/2)
        error(EXIT_BADSC, "Enumerator found %lu entries instead of "
              "%d entries\n", cFound, ENUMENTRIES-ENUMENTRIES/2);
    for (; cFound > 0; cFound--)
    {
        elt_check(&stat[cFound-1], &sl);
        drtMemFree(stat[cFound-1].pwcsName);
    }
    sc = DfGetScode(penm->Next(1, stat, NULL));
    if (sc != S_FALSE)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_FALSE\n", ScText(sc), sc);

    penm->Unwrap();
    pstg->Unwrap();
}

#define SCT_CLASSID IID_ILockBytes
#define SCT_STATEBITS 0xfef1f0f0

void t_stgcopyto(void)
{
    WStorage *pstgFrom, *pstgTo;
    STATSTG statFrom, statTo;

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgFrom);
    pstgFrom->Stat(&statFrom, 0);

    // Set some interesting values to make sure they're copied
    pstgFrom->SetClass(SCT_CLASSID);
    fExitOnFail = FALSE;
    pstgFrom->SetStateBits(SCT_STATEBITS, 0xffffffff);
    fExitOnFail = TRUE;

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgTo);
    CreateStructure(pstgFrom->GetI(), "dA(dB(dC(sA,sB,sC),sCs),sBs),sAs");
    CreateStructure(pstgTo->GetI(), "dA(dY(sZ),sBs)");

    pstgFrom->CopyTo(0, NULL, NULL, pstgTo);

    VerifyStructure(pstgTo->GetI(),
		    "dA(dB(dC(sA,sB,sC),sCs),dY(sZ),sBs),sAs");
    pstgTo->Stat(&statTo, 0);
    if (!IsEqualCLSID(statTo.clsid, SCT_CLASSID))
        error(EXIT_BADSC, "Class ID mismatch after copy\n");
    if (statTo.grfStateBits != SCT_STATEBITS)
        errorprint("State bits mismatch: has %lX vs. %lX\n",
              statTo.grfStateBits, SCT_STATEBITS);

    pstgFrom->Unwrap();
    pstgTo->Unwrap();
    if (Exists(statFrom.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statFrom.pwcsName);
    drtMemFree(statFrom.pwcsName);
    if (Exists(statTo.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statTo.pwcsName);
    drtMemFree(statTo.pwcsName);
}

#define MARSHAL_STM STR("Marshal")

void do_marshal(WStorage *pstg, WStream *pstm)
{
    WStorage *pstgMarshal;
    WStream *pstmMarshal;

    WStgCreateDocfile(MARSHALDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgMarshal);
    pstgMarshal->CreateStream(MARSHAL_STM, STMP(WSTG_READWRITE), 0, 0,
			      &pstmMarshal);
    WCoMarshalInterface(pstmMarshal, IID_IStorage, pstg->GetI(), 0, NULL,
                        MSHLFLAGS_NORMAL);
    WCoMarshalInterface(pstmMarshal, IID_IStream, pstm->GetI(), 0, NULL,
                        MSHLFLAGS_NORMAL);
    WCoMarshalInterface(pstmMarshal, IID_IUnknown, pstg->GetI(), 0, NULL,
                        MSHLFLAGS_NORMAL);
    WCoMarshalInterface(pstmMarshal, IID_IUnknown, pstm->GetI(), 0, NULL,
                        MSHLFLAGS_NORMAL);
    pstmMarshal->Unwrap();
    pstgMarshal->Commit(0);
    pstgMarshal->Unwrap();
}

static char STREAM_DATA[] = "This is data to be written";

void do_unmarshal(WStorage **ppstg, WStream **ppstm,
                  IUnknown **ppstg2, IUnknown **ppstm2)
{
    IStorage *pistg;
    WStorage *pstgMarshal;
    WStream *pstmMarshal;
    IStream *pistm;

    WStgOpenStorage(MARSHALDF, NULL, ROOTP(WSTG_READWRITE), NULL, 0,
		    &pstgMarshal);
    pstgMarshal->OpenStream(MARSHAL_STM, NULL, STMP(WSTG_READWRITE), 0,
			    &pstmMarshal);
    WCoUnmarshalInterface(pstmMarshal, IID_IStorage, (void **)&pistg);
    *ppstg = WStorage::Wrap(pistg);
    WCoUnmarshalInterface(pstmMarshal, IID_IStream, (void **)&pistm);
    *ppstm = WStream::Wrap(pistm);
    WCoUnmarshalInterface(pstmMarshal, IID_IUnknown, (void **)ppstg2);
    WCoUnmarshalInterface(pstmMarshal, IID_IUnknown, (void **)ppstm2);
    pstmMarshal->Unwrap();
    pstgMarshal->Unwrap();
}

void t_marshal(void)
{
    WStorage *pstg, *pstgM;
    WStream *pstm, *pstmM;
    IUnknown *pstgM2, *pstmM2;
    ULONG cbRead, cbWritten;
    char buf[sizeof(STREAM_DATA)];

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstg);
    pstg->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Write(STREAM_DATA, sizeof(STREAM_DATA), &cbWritten);
    CreateStructure(pstg->GetI(), "dChild(dChild(sStream))");

    do_marshal(pstg, pstm);
    do_unmarshal(&pstgM, &pstmM, &pstgM2, &pstmM2);
    pstm->Unwrap();
    pstg->Unwrap();

    pstmM->Seek(0, WSTM_SEEK_SET, NULL);
    pstmM->Read(buf, sizeof(STREAM_DATA), &cbRead);
    if (strcmp(buf, STREAM_DATA))
	error(EXIT_BADSC, "Stream data mismatch\n");
    pstmM->Unwrap();
    pstmM2->Release();

    VerifyStructure(pstgM->GetI(), "dChild(dChild(sStream)),sStream");
    pstgM->Unwrap();
    pstgM2->Release();
}

void t_stgmisc(void)
{
    WStorage *pstg;
    SCODE sc;
    STATSTG stat;

    // Can't make this call in transacted mode because we want
    // the storage signature to make it into the file right away
    WStgCreateDocfile(DRTDF, WSTG_READWRITE | WSTG_CREATE |
	WSTG_SHARE_EXCLUSIVE, 0, &pstg);
    if (!fOfs)
    {
    sc = DfGetScode(WStgIsStorageFile(DRTDF));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Open file - Should be a storage object\n");
    pstg->Unwrap();
    sc = DfGetScode(WStgIsStorageFile(DRTDF));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Closed file - Should be a storage object\n");
    }
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
	    WSTG_DELETEONRELEASE, 0, &pstg);
    pstg->Stat(&stat, 0);
    if (!Exists(stat.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not created\n", stat.pwcsName);
    pstg->Unwrap();
    if (Exists(stat.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted on release\n",
	    stat.pwcsName);
    drtMemFree(stat.pwcsName);
}

void t_ilb(void)
{
    WStorage *pstg;
    SCODE sc;
    //  create an ILockBytes

    ILockBytes *pilb = new CMapBytes();
    if (pilb == NULL)
	error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");

    //  create a storage on the ILockBytes

    WStgCreateDocfileOnILockBytes(pilb,
				  WSTG_READWRITE |
                                  WSTG_CREATE    |
                                  WSTG_SHARE_EXCLUSIVE,
                                  0, &pstg);

    //  verify the ILockBytes

    sc = DfGetScode(WStgIsStorageILockBytes(pilb));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Open ILockBytes - Should be a storage object\n");

    //  release the storage

    pstg->Unwrap();

    //  verify the ILockBytes

    sc = DfGetScode(WStgIsStorageILockBytes(pilb));

    if (sc == S_FALSE)
	error(EXIT_BADSC, "Released ILockBytes - Should be a storage object\n");

    //  open the ILockBytes

    WStgOpenStorageOnILockBytes(pilb, NULL, ROOTP(WSTG_READWRITE),
				NULL, 0, &pstg);


    //  release the storage

    pstg->Unwrap();

    //  release the ILockBytes

    pilb->Release();
}

void t_movecopy(void)
{
    WStorage *pstgFrom, *pstgTo;
    STATSTG statFrom, statTo;

    //  create a source
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgFrom);
    pstgFrom->Stat(&statFrom, 0);

    //  create a destination
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgTo);
    pstgTo->Stat(&statTo, 0);

    //  populate source
    CreateStructure(pstgFrom->GetI(), "dA(dB(dC(sA,sB,sC),sCs),sBs),sAs");

    //  move a storage
    pstgFrom->MoveElementTo(STR("A"), pstgTo, STR("M"), STGMOVE_MOVE);
    VerifyStructure(pstgFrom->GetI(),
                    "sAs");
    VerifyStructure(pstgTo->GetI(),
                    "dM(dB(dC(sA,sB,sC),sCs),sBs)");

    //  copy a stream
    pstgFrom->MoveElementTo(STR("As"), pstgTo, STR("Bs"), STGMOVE_COPY);
    VerifyStructure(pstgFrom->GetI(),
                    "sAs");
    VerifyStructure(pstgTo->GetI(),
                    "dM(dB(dC(sA,sB,sC),sCs),sBs),sBs");

    pstgFrom->Unwrap();
    pstgTo->Unwrap();
    if (Exists(statFrom.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statFrom.pwcsName);
    drtMemFree(statFrom.pwcsName);
    if (Exists(statTo.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statTo.pwcsName);
    drtMemFree(statTo.pwcsName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgdrt\util.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	util.cxx
//
//  Contents:	DRT support routines
//
//  History:	22-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <stdarg.h>
#include <direct.h>
#include <io.h>

#if DBG == 1
#include <dfdeb.hxx>
#endif

#define DEFAULT_DATA_DIR "."

BOOL fExitOnFail = TRUE;

char szOrigDir[_MAX_PATH] = ".";

// Preserve the current directory and change
// directory into the data directory
void SetData(void)
{
    char *pszDataDir;

    _getcwd(szOrigDir, _MAX_PATH);
    pszDataDir = getenv("DRTDATA");
    if (pszDataDir == NULL)
	pszDataDir = DEFAULT_DATA_DIR;
    _chdir(pszDataDir);
}

// Clean up the data directory
void CleanData(void)
{
    _unlink(OlecsOut(DRTDF));
    _unlink(OlecsOut(MARSHALDF));
}

// Restore the original directory
void UnsetData(void)
{
    _chdir(szOrigDir);
}

// Output a message if fVerbose is true
void out(char *fmt, ...)
{
    va_list args;

    if (fVerbose)
    {
	va_start(args, fmt);
	vprintf(fmt, args);
	va_end(args);
    }
}

//  internal error print
void _errorprint (char *fmt, va_list args)
{
#if !defined(FLAT) || defined(FPRINTF_WORKS)
    fprintf(stderr, "** Fatal error **: ");
    vfprintf(stderr, fmt, args);
#else
    printf("** Fatal error **: ");
    vprintf(fmt, args);
#endif
}

//  error print
void errorprint (char *fmt, ...)
{
    va_list args;

    va_start (args, fmt);

    _errorprint (fmt, args);

    va_end (args);
}

// Print out an error message and terminate the DRT
void error(int code, char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);

    _errorprint (fmt, args);

    va_end(args);
    CleanData();
    UnsetData();
    exit(code);
}


// Converts a TCHAR string to a char pointer in a temporary buffer
// This implementation treats the conversion buffer as a circular
// buffer so more than one string can be held (depending on the size
// of the strings)

#define BUFSIZE 1024

char *OlecsOut(OLECHAR const *ptcs)
{
#ifdef OLEWIDECHAR
    static char szBuffer[BUFSIZE];
    static char *pszBuf = szBuffer;
    char *pszTmp;

    if (ptcs == NULL)
        return NULL;
    if (wcslen(ptcs) >= (size_t)(BUFSIZE-(pszBuf-szBuffer)))
        pszBuf = szBuffer;
    wcstombs(pszBuf, ptcs, BUFSIZE);
    szBuffer[BUFSIZE-1] = 0;
    pszTmp = pszBuf;
    pszBuf += strlen(pszBuf)+1;
    return pszTmp;
#else
    return (char *)ptcs;
#endif
}

typedef struct
{
    SCODE sc;
    char *text;
} StatusCodeText;

static StatusCodeText scodes[] =
{
    S_OK, "S_OK",
    S_FALSE, "S_FALSE",
    STG_E_INVALIDFUNCTION, "STG_E_INVALIDFUNCTION",
    STG_E_FILENOTFOUND, "STG_E_FILENOTFOUND",
    STG_E_PATHNOTFOUND, "STG_E_PATHNOTFOUND",
    STG_E_TOOMANYOPENFILES, "STG_E_TOOMANYOPENFILES",
    STG_E_ACCESSDENIED, "STG_E_ACCESSDENIED",
    STG_E_INVALIDHANDLE, "STG_E_INVALIDHANDLE",
    STG_E_INSUFFICIENTMEMORY, "STG_E_INSUFFICIENTMEMORY",
    STG_E_INVALIDPOINTER, "STG_E_INVALIDPOINTER",
    STG_E_NOMOREFILES, "STG_E_NOMOREFILES",
    STG_E_DISKISWRITEPROTECTED, "STG_E_DISKISWRITEPROTECTED",
    STG_E_SEEKERROR, "STG_E_SEEKERROR",
    STG_E_WRITEFAULT, "STG_E_WRITEFAULT",
    STG_E_READFAULT, "STG_E_READFAULT",
    STG_E_SHAREVIOLATION, "STG_E_SHAREVIOLATION",
    STG_E_LOCKVIOLATION, "STG_E_LOCKVIOLATION",
    STG_E_FILEALREADYEXISTS, "STG_E_FILEALREADYEXISTS",
    STG_E_INVALIDPARAMETER, "STG_E_INVALIDPARAMETER",
    STG_E_MEDIUMFULL, "STG_E_MEDIUMFULL",
    STG_E_ABNORMALAPIEXIT, "STG_E_ABNORMALAPIEXIT",
    STG_E_INVALIDHEADER, "STG_E_INVALIDHEADER",
    STG_E_INVALIDNAME, "STG_E_INVALIDNAME",
    STG_E_UNKNOWN, "STG_E_UNKNOWN",
    STG_E_UNIMPLEMENTEDFUNCTION, "STG_E_UNIMPLEMENTEDFUNCTION",
    STG_E_INVALIDFLAG, "STG_E_INVALIDFLAG",
    STG_E_INUSE, "STG_E_INUSE",
    STG_E_NOTCURRENT, "STG_E_NOTCURRENT",
    STG_E_REVERTED, "STG_E_REVERTED",
    STG_E_CANTSAVE, "STG_E_CANTSAVE",
    STG_E_OLDFORMAT, "STG_E_OLDFORMAT",
    STG_E_OLDDLL, "STG_E_OLDDLL",
    STG_E_SHAREREQUIRED, "STG_E_SHAREREQUIRED",
    STG_E_NOTFILEBASEDSTORAGE, "STG_E_NOTFILEBASEDSTORAGE",
    STG_E_EXTANTMARSHALLINGS, "STG_E_EXTANTMARSHALLINGS",
    STG_S_CONVERTED, "STG_S_CONVERTED"
};
#define NSCODETEXT (sizeof(scodes)/sizeof(scodes[0]))

// Convert a status code to text
char *ScText(SCODE sc)
{
    int i;

    for (i = 0; i<NSCODETEXT; i++)
	if (scodes[i].sc == sc)
	    return scodes[i].text;
    return "?";
}

// Output a call result and check for failure
HRESULT Result(HRESULT hr)
{
    SCODE sc;

    sc = DfGetScode(hr);
    out(" - %s (0x%lX)\n", ScText(sc), sc);
    if (FAILED(sc) && fExitOnFail)
        error(EXIT_BADSC, "Unexpected call failure\n");
    return hr;
}

// Perform Result() when the expectation is failure
HRESULT IllResult(char *pszText, HRESULT hr)
{
    SCODE sc;

    sc = DfGetScode(hr);
    out("%s - %s (0x%lX)\n", pszText, ScText(sc), sc);
    if (SUCCEEDED(sc) && fExitOnFail)
        error(EXIT_BADSC, "Unexpected call success\n");
    return hr;
}

// DEBUG - Check for memory leaks
void CheckMemory(void)
{
#if DBG == 1
    if (fVerbose || DfGetMemAlloced() != 0)
    {
	out("Memory held: %lu bytes\n", DfGetMemAlloced());
	if (DfGetMemAlloced() != 0)
	{
	    DfPrintAllocs();
            error(EXIT_BADSC, "Memory leak\n");
	}
    }
#endif
}

// DEBUG - Set the debugging level
void SetDebug(ULONG ulDf, ULONG ulMsf)
{
#if DBG == 1
    DfDebug(ulDf, ulMsf);
#endif
}

// Check whether a given storage has a certain
// structure or not
// Structure is given as a string with elements:
//   <Type><Name><Options>[,...]
//   Type - d for docfile and s for stream
//   Name - Characters up to a '(' or ','
//   Options - For a docfile, you can specify a recursive check
//     in parentheses
//
// Example:  dDocfile(sStream,dDocfile)
char *VerifyStructure(IStorage *pstg, char *pszStructure)
{
    char szName[CWCSTORAGENAME], *psz;
    IStorage *pstgChild;
    char chType;
    SCODE sc;
    CStrList sl;
    SStrEntry *pse;
    IEnumSTATSTG *penm;
    STATSTG stat;
    OLECHAR atcName[CWCSTORAGENAME];

    if (FAILED(sc = DfGetScode(pstg->EnumElements(0, NULL, 0, &penm))))
	error(EXIT_BADSC, "VerifyStructure: Unable to create enumerator - "
	      "%s (0x%lX)\n", ScText(sc), sc);
    for (;;)
    {
	sc = DfGetScode(penm->Next(1, &stat, NULL));
	if (sc == S_FALSE)
	    break;
	else if (FAILED(sc))
	    error(EXIT_BADSC, "VerifyStructure: Unable to enumerate - "
	      "%s (0x%lX)\n", ScText(sc), sc);
	pse = sl.Add(stat.pwcsName);
	if (pse == NULL)
	    error(EXIT_OOM, "VerifyStructure: Unable to allocate string\n");
	pse->user.dw = stat.type;
	drtMemFree(stat.pwcsName);
    }
    penm->Release();
    while (*pszStructure && *pszStructure != ')')
    {
	chType = *pszStructure++;
	psz = szName;
	while (*pszStructure && *pszStructure != '(' &&
	       *pszStructure != ')' && *pszStructure != ',')
	    *psz++ = *pszStructure++;
	*psz = 0;
        ATOOLE(szName, atcName, CWCSTORAGENAME);
	pse = sl.Find(atcName);
	if (pse == NULL)
	    error(EXIT_BADSC, "VerifyStructure: '%s' not found\n", szName);
	switch(chType)
	{
	case 'd':
	    if (pse->user.dw != STGTY_STORAGE)
		error(EXIT_BADSC, "VerifyStructure: '%s' is not a storage\n",
		      szName);
	    sc = DfGetScode(pstg->OpenStorage(atcName, NULL,
                                              STGP(STGM_READWRITE), NULL,
                                              0, &pstgChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "VerifyStructure: can't open storage "
		      "'%s' - %s\n", szName, ScText(sc));
	    if (*pszStructure == '(')
		pszStructure = VerifyStructure(pstgChild, pszStructure+1)+1;
	    pstgChild->Release();
	    break;
	case 's':
	    if (pse->user.dw != STGTY_STREAM)
		error(EXIT_BADSC, "VerifyStructure: '%s' is not a stream\n",
		      szName);
	    break;
	}
	sl.Remove(pse);
	if (*pszStructure == ',')
	    pszStructure++;
    }
    for (pse = sl.GetHead(); pse; pse = pse->pseNext)
	error(EXIT_BADSC, "VerifyStructure: additional member '%s'\n",
	      OlecsOut(pse->atc));
    return pszStructure;
}

// Creates a structure using the same syntax
// as VerifyStructure
char *CreateStructure(IStorage *pstg, char *pszStructure)
{
    char szName[CWCSTORAGENAME], *psz;
    IStorage *pstgChild;
    IStream *pstmChild;
    char chType;
    SCODE sc;
    OLECHAR atcName[CWCSTORAGENAME];

    while (*pszStructure && *pszStructure != ')')
    {
	chType = *pszStructure++;
	psz = szName;
	while (*pszStructure && *pszStructure != '(' &&
	       *pszStructure != ')' && *pszStructure != ',')
	    *psz++ = *pszStructure++;
	*psz = 0;
        ATOOLE(szName, atcName, CWCSTORAGENAME);
	switch(chType)
	{
	case 'd':
	    sc = DfGetScode(pstg->CreateStorage(atcName, STGP(STGM_READWRITE),
                                                0, 0, &pstgChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "CreateStructure: can't create storage "
		      "'%s' - %s\n", szName, ScText(sc));
	    if (*pszStructure == '(')
		pszStructure = CreateStructure(pstgChild, pszStructure+1)+1;
	    pstgChild->Release();
	    break;
	case 's':
	    sc = DfGetScode(pstg->CreateStream(atcName, STMP(STGM_READWRITE),
                                               0, 0, &pstmChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "CreateStructure: can't create stream "
		      "'%s' - %s\n", szName, ScText(sc));
	    pstmChild->Release();
	    break;
	}
	if (*pszStructure == ',')
	    pszStructure++;
    }
    pstg->Commit(0);
    return pszStructure;
}

// Verifies the fields of a STATSTG
void VerifyStat(STATSTG *pstat, OLECHAR *ptcsName, DWORD type, DWORD grfMode)
{
    if (ptcsName == NULL)
    {
        if (pstat->pwcsName != NULL)
	    error(EXIT_BADSC, "Stat name should be NULL - is %p\n",
                  pstat->pwcsName);
    }
    else if (olecscmp(pstat->pwcsName, ptcsName))
	error(EXIT_BADSC, "Stat name mismatch - has '%s' vs. '%s'\n",
	      OlecsOut(pstat->pwcsName), OlecsOut(ptcsName));
    if (pstat->type != type)
	error(EXIT_BADSC, "Stat type mismatch - has %lu vs. %lu\n",
	      pstat->type, type);
    if (pstat->grfMode != grfMode)
	error(EXIT_BADSC, "Stat mode mismatch - has 0x%lX vs. 0x%lX\n",
	      pstat->grfMode, grfMode);
}

// Checks on a file's existence
BOOL Exists(OLECHAR *file)
{
    OFSTRUCT of;

#ifndef OLEWIDECHAR
    return OpenFile(file, &of, OF_EXIST | OF_SHARE_DENY_NONE) !=
	HFILE_ERROR ? TRUE : FALSE;
#else
    char szName[_MAX_PATH];
    wcstombs(szName, file, _MAX_PATH);
    return OpenFile(szName, &of, OF_EXIST | OF_SHARE_DENY_NONE) !=
	HFILE_ERROR ? TRUE : FALSE;
#endif
}

// Gets a file's length
ULONG Length(OLECHAR *file)
{
    ULONG cb;

#ifndef WIN32

    OFSTRUCT of;
    int hf;
    hf = OpenFile(file, &of, OF_READ | OF_SHARE_DENY_NONE);
    if (hf == HFILE_ERROR)
        error(EXIT_BADSC, "Length: Unable to open '%s'\n", OlecsOut(file));
    cb = (ULONG)_llseek(hf, 0, SEEK_END);
    if (cb == (ULONG)HFILE_ERROR)
        error(EXIT_BADSC, "Length: Unable to get length for '%s'\n",
              OlecsOut(file));
    _lclose(hf);

#else

    // use WIN32 APIs

    HANDLE hf;

#if !defined(UNICODE)

    // Chicago - call ANSI CreateFile

    char szName[_MAX_PATH];
    if (wcstombs(szName, file, _MAX_PATH) == (size_t)-1)
        return 0;

    hf = CreateFile (
        szName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

#else

    hf = CreateFile (
        file,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

#endif // !defined(UNICODE)

    if (hf == INVALID_HANDLE_VALUE)
        error(EXIT_BADSC, "Length: Unable to open '%s'\n", OlecsOut(file));
    cb = (ULONG)GetFileSize(hf, NULL);
    if (cb == (ULONG)0xFFFFFFFF)
        error(EXIT_BADSC, "Length: Unable to get length for '%s'\n",
              OlecsOut(file));
    CloseHandle(hf);

#endif // !WIN32

    return cb;
}

// Original mode when a new mode is forced
// Used by ForceDirect, ForceTransacted and Unforce
static DWORD dwTransOld;
static DWORD dwRDWOld;

// Forces direct mode to be active
// Note:  this uses a static variable so it can\'t be nested
void ForceDirect(void)
{
    dwTransOld = dwTransacted;
    dwTransacted = STGM_DIRECT;
    dwRDWOld = dwRootDenyWrite;
    dwRootDenyWrite = STGM_SHARE_EXCLUSIVE;
}

// Forces transacted mode similarly to ForceDirect
void ForceTransacted(void)
{
    dwTransOld = dwTransacted;
    dwRDWOld = dwRootDenyWrite;
    dwTransacted = STGM_TRANSACTED;
}

// Returns to the original mode after a ForceDirect or ForceTransacted
void Unforce(void)
{
    dwTransacted = dwTransOld;
    dwRootDenyWrite = dwRDWOld;
}

// Equality for FILETIME
BOOL IsEqualTime(FILETIME ttTime, FILETIME ttCheck)
{
    //  File times can be off by as much as 2 seconds due to FAT rounding
    LONGLONG tmTime = *(LONGLONG *)&ttTime;
    LONGLONG tmCheck = *(LONGLONG *)&ttCheck;
    LONGLONG tmDelta = tmTime - tmCheck;

    return tmDelta < 20000000i64 && tmDelta > -2i64 ;
}

// Get a fully qualified path for a file name
void GetFullPath(OLECHAR *file, OLECHAR *path)
{
#ifndef UNICODE
    char buf[_MAX_PATH];
    OFSTRUCT of;

    OLETOA(file, buf, _MAX_PATH);
    OpenFile(buf, &of, OF_PARSE);
    ATOOLE((char *)of.szPathName, path, _MAX_PATH);
#else
    OLECHAR *ptcsFile;

    GetFullPathName(file, _MAX_PATH, path, &ptcsFile);
#endif
}

//  Memory helper functions

HRESULT drtMemAlloc(ULONG ulcb, void **ppv)
{
    HRESULT hr;
    IMalloc *pMalloc = NULL;

    if (SUCCEEDED(DfGetScode(hr = CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        *ppv = pMalloc->Alloc(ulcb);
        pMalloc->Release();

        if (*ppv == NULL)
            return ResultFromScode(E_OUTOFMEMORY);
    }

    return hr;
}

void drtMemFree(void *pv)
{
    IMalloc FAR* pMalloc;
    if (SUCCEEDED(GetScode(CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        pMalloc->Free(pv);
        pMalloc->Release();
    }
}

#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

char *GuidText(GUID const *pguid)
{
    static char buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    sprintf(buf, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\ole2ui\res\usa\verlocal.h ===
/*
 * VERLOCAL.H
 *
 * Version resource file for the OLE 2.0 UI Support DLL.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved.
 *
 * This file contains the text that needs to be translated in the version
 * resource.  All of the following variables must be localized:
 *
 * wLanguage
 * szTranslation
 * szzCompanyName
 * szzProductName
 * szzLegalCopyright
 */

/* wLanguage comes from the table of "langID" values on page 218 of
   the Windows 3.1 SDK Programmer's Reference, Volume 4: Resources.
   This page is in Chapter 13, "Resource-Definition Statements", in the
   description of the "VERSIONINFO" statment.

   For example, 
   0x0407  German
   0x0409  U.S. English
   0x0809  U.K. English
   0x040C  French
   0x040A  Castilian Spanish
*/
#define wLanguage 0x0409           /* U.S. English */

/* The first 4 characters of szTranslation must be the same as wLanguage,
   without the "0x".  The last 4 characters of szTranslation MUST be
   04E4.  Note that any alphabetic characters in szTranslation must
   be capitalized. */
#define szTranslation "040904E4"   /* U.S. English */


/* The following szz strings must all end with the two characters "\0" */
/* Note that the "\251" in szzLegalCopyright stands for the "circle c"
   copyright symbol, and it should be left as \251 rather than
   substituting the actual ANSI copyright character in the string. */
#define szzCompanyName     "Microsoft Corporation\0"
#define szzFileDescription "Microsoft Windows(TM) OLE 2.0 User Interface Support\0"
#define szzLegalCopyright  "Copyright \251 1992-1993 Microsoft Corp.  All rights reserved.\0"

#ifdef PUBLISHER
#define szzProductName "Microsoft Publisher for Windows 2.0\0"
#else
#define szzProductName szzFileDescription
#endif


/* DO NOT CHANGE ANY LINES BELOW THIS POINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgdrt\strlist.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	strlist.cxx
//
//  Contents:	CStrList implementation
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <string.h>

//+--------------------------------------------------------------
//
//  Member:	CStrList::CStrList, public
//
//  Synopsis:	Ctor
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

CStrList::CStrList(void)
{
    _pseHead = NULL;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::~CStrList, public
//
//  Synopsis:	Dtor
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

CStrList::~CStrList(void)
{
    Empty();
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Add, public
//
//  Synopsis:	Adds a string to the list
//
//  Arguments:	[ptcs] - String
//
//  Returns:	Pointer to entry or NULL
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

SStrEntry *CStrList::Add(OLECHAR *ptcs)
{
    SStrEntry *pse;

    // One char of string already counted in sizeof
    pse = (SStrEntry *)new
        char[sizeof(SStrEntry)+olecslen(ptcs)*sizeof(OLECHAR)];
    if (pse == NULL)
	return NULL;
    pse->pseNext = _pseHead;
    pse->psePrev = NULL;
    if (_pseHead)
	_pseHead->psePrev = pse;
    _pseHead = pse;
    olecscpy(pse->atc, ptcs);
    return pse;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Remove, public
//
//  Synopsis:	Removes an entry from the list
//
//  Arguments:	[pse] - Entry
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

void CStrList::Remove(SStrEntry *pse)
{
    if (pse->psePrev)
	pse->psePrev->pseNext = pse->pseNext;
    else
	_pseHead = pse->pseNext;
    if (pse->pseNext)
	pse->pseNext->psePrev = pse->psePrev;
    delete pse;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Find, public
//
//  Synopsis:	Attempts to find a string in the list
//
//  Arguments:	[ptcs] - String
//
//  Returns:	Entry or NULL
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

SStrEntry *CStrList::Find(OLECHAR *ptcs)
{
    SStrEntry *pse;

    for (pse = _pseHead; pse; pse = pse->pseNext)
	if (!olecscmp(ptcs, pse->atc))
	    return pse;
    return NULL;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Empty, public
//
//  Synopsis:	Frees all elements in list
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

void CStrList::Empty(void)
{
    SStrEntry *pse;

    while (_pseHead)
    {
	pse = _pseHead->pseNext;
	delete _pseHead;
	_pseHead = pse;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\trktest\trktest.cxx ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

WCHAR *Convert(char *psz)
{	int c;
	WCHAR *pwsz = new WCHAR [ c = strlen(psz) + 1 ];
	if (pwsz)
		mbstowcs(pwsz, psz, c);
	return pwsz;
}

#define CHECKNE(hr, stat, string, errRet) \
if (hr != stat) { iLine = __LINE__; pszErr = string; goto errRet; }

HRESULT TouchFile(WCHAR *pwszSource)
{
    FILETIME ftc;
    SYSTEMTIME st;

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ftc);
    return StgSetTimes(pwszSource, &ftc, NULL, NULL);
}

HRESULT CreateLink(WCHAR *pwszClient, WCHAR *pwszSource)
{
	HRESULT hr;
	IBindCtx *pbc=NULL;
	ULONG ulEaten;
	IMoniker *pmkSource=NULL;
	IStorage *pstg=NULL;
	IOleObject *poo=NULL;
	IMoniker *pmkThis=NULL;
	IMoniker *pmkLink=NULL;
	IPersistStorage *pps=NULL;
	char *pszErr;
	int iLine=0;

	hr = CreateFileMoniker(pwszClient, &pmkThis);
	CHECKNE(hr, S_OK, "CreateFileMoniker", errRet);
	hr = CreateItemMoniker(L"!", L"Link", &pmkLink);
	CHECKNE(hr, S_OK, "CreateItemMoniker", errRet);
	hr = StgCreateDocfile(pwszClient, STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
		0, &pstg);
	CHECKNE(hr, S_OK, "StgCreateDocfile", errRet);
	hr = CreateBindCtx(0, &pbc);
	CHECKNE(hr, S_OK, "CreateBindCtx", errRet);
	hr = MkParseDisplayName(pbc, pwszSource, &ulEaten, &pmkSource);
	CHECKNE(hr, S_OK, "MkParseDisplayName", errRet);
	hr = OleCreateLink(pmkSource, IID_IOleObject, OLERENDER_NONE, NULL, NULL, pstg, (void**)&poo);
	CHECKNE(hr, S_OK, "OleCreateLink", errRet);
	hr = poo->SetMoniker(OLEWHICHMK_CONTAINER, pmkThis);
	CHECKNE(hr, S_OK, "SetMonikerOLEWHICHMK_CONTAINER", errRet);
	hr = poo->SetMoniker(OLEWHICHMK_OBJREL, pmkLink);
	CHECKNE(hr, S_OK, "SetMonikerOLEWHICHMK_OBJREL", errRet);
	hr = poo->QueryInterface(IID_IPersistStorage, (void**)&pps);
	CHECKNE(hr, S_OK, "QueryInterface(IID_IPersistStorage", errRet);
	hr = OleSave(pps, pstg, TRUE);
	CHECKNE(hr, S_OK, "OleSave", errRet);

errRet:
	if (hr != S_OK)
            printf("CreateLink at %s line %d with hr=%08x\n", pszErr, iLine, hr);

	if (pbc) pbc->Release();
	if (pmkSource) pmkSource->Release();
	if (pstg) pstg->Release();
	if (poo) poo->Release();
	if (pmkThis) pmkThis->Release();
	if (pmkLink) pmkLink->Release();
	if (pps) pps->Release();

	return hr;
}

HRESULT ResolveLink(WCHAR *pwszClient, WCHAR *pwszSource, BOOL fReSave)
{
	HRESULT hr;
	IStorage *pstg = NULL;
	IOleLink *pol = NULL;
	WCHAR *pwszSourceFound = NULL;
	IPersistStorage *pps = NULL;
	char *pszErr;
	int iLine;

	hr = StgOpenStorage(pwszClient, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
		NULL, 0, &pstg);
	CHECKNE(hr, S_OK, "StgOpenStorage(pwszClient", errRet);
	hr = OleLoad(pstg, IID_IOleLink, NULL, (void**)&pol);
	CHECKNE(hr, S_OK, "OleLoad(pstg, IID_IOleLink", errRet);
	hr = pol->BindToSource(0, NULL);
	CHECKNE(hr, S_OK, "pol->BindToSource", errRet);
	hr = pol->GetSourceDisplayName(&pwszSourceFound);
	CHECKNE(hr, S_OK, "pol->GetSourceDisplayName", errRet);
	if (wcsicmp(pwszSourceFound, pwszSource) != 0)
	{
		printf("SourceFound=%ls, SourceExpected=%ls\n", pwszSourceFound, pwszSource);
                pszErr = "'path compare'";
		hr = E_FAIL;
		goto errRet;
	}

	if (fReSave)
	{
		hr = pol->QueryInterface(IID_IPersistStorage, (void**)&pps);
		CHECKNE(hr, S_OK, "pol->QueryInterface(IID_IPersistStorage", errRet);
		hr = OleSave(pps, pstg, TRUE);
		CHECKNE(hr, S_OK, "OleSave(pps, pstg, TRUE)", errRet);
	}

errRet:
	if (hr != S_OK)
            printf("ResolveLink at %s line %d with hr=%08x\n", pszErr, iLine, hr);

	CoTaskMemFree(pwszSourceFound);
	if (pol) pol->Release();
	if (pstg) pstg->Release();
	if (pps) pps->Release();
	return hr;
}

int __cdecl main(int argc, char **argv)
{
	char * pszExit = "TEST FAILED.";
	int iExit = 1;
	WCHAR *pwszClient = NULL;
	WCHAR *pwszSource = NULL;
	HRESULT hr=E_FAIL;
	BOOL fArgsOk = FALSE;
        HRESULT hrExpected=S_OK;

	CoInitialize(NULL);
	OleInitialize(NULL);

        if (argc >= 3)
        {
		pwszClient = Convert(argv[2]);
        }

        if (argc >= 5)
        {
		pwszSource = Convert(argv[3]);
                sscanf(argv[4], "%x", &hrExpected);
		if (!pwszClient || !pwszSource)
		{
			pszExit = "Out of memory.";
			goto errExit;
		}
        }

        if (argc == 3)
        {
		if (stricmp(argv[1], "/t") == 0 || stricmp(argv[1], "-t") == 0)
		{
			// touch file creation date
			hr = TouchFile(pwszClient);
			fArgsOk = TRUE;
		}
        }
        else
	if (argc == 5)
	{
		if (stricmp(argv[1], "/c") == 0 || stricmp(argv[1], "-c") == 0)
		{
			// create link
			hr = CreateLink(pwszClient, pwszSource);
			fArgsOk = TRUE;
		}
	}
	else
	if (argc == 6)
	{
		if (stricmp(argv[1], "/r") == 0 || stricmp(argv[1], "-r") == 0)
		{
			// resolve link
			hr = ResolveLink(pwszClient, pwszSource, argv[5][0] == 's');
			fArgsOk = TRUE;
		}
	}

	if (!fArgsOk)
	{
		pszExit = "Usage: /c client source expected_status -- create .lts file linked to source\n"
			  "       /r client expected_source expected_status save/nosave  -- resolve .lts file, checked linked to source\n"
                          "       expected_source is ignored(but required) if not found during resolve.\n"
                          "       /t source -- change the creation date\n";

	}
        else
        {
            if (hrExpected != hr)
            {
                printf("Expected status = %08X, actual status = %08X\n",
                    hrExpected,
                    hr);
            }
            else
            {
                pszExit = "TEST PASSED.";
                iExit = 0;
            }
        }
	
errExit:

	OleUninitialize();
	CoUninitialize();

	delete pwszClient;
	delete pwszSource;

	puts(pszExit);

	return iExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgdrt\wrap.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	wrap.cxx
//
//  Contents:	Wrapper implementations
//
//  History:	22-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <dfentry.hxx>

// Retrieve interface pointer for possibly NULL objects
#define SAFEI(obj) ((obj) ? (obj)->GetI() : NULL)

//+--------------------------------------------------------------
//
//  IStorage wrappers
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

WStorage *WStorage::Wrap(IStorage *pistg)
{
    WStorage *wstg;

    wstg = new WStorage(pistg);
    if (wstg == NULL)
	error(EXIT_OOM, "Unable to wrap IStorage\n");
    return wstg;
}

WStorage::WStorage(IStorage *pstg)
{
    // Note:  takes ownership of pstg
    _pstg = pstg;
}

WStorage::~WStorage(void)
{
    if (_pstg)
	Release();
}

void WStorage::Unwrap(void)
{
    delete this;
}

HRESULT WStorage::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IStorage %p::QueryInterface(riid, %p)", _pstg, ppvObj);
    return Result(_pstg->QueryInterface(riid, ppvObj));
}

ULONG WStorage::AddRef(void)
{
    ULONG ul;

    ul = _pstg->AddRef();
    out("IStorage %p::AddRef() - %lu\n", _pstg, ul);
    return ul;
}

ULONG WStorage::Release(void)
{
    ULONG ul;

    ul = _pstg->Release();
    out("IStorage %p::Release() - %lu\n", _pstg, ul);
    if (ul == 0)
	_pstg = NULL;
    return ul;
}

HRESULT WStorage::CreateStream(const OLECHAR * pwcsName,
			     const DWORD grfMode,
			     DWORD reserved1,
			     DWORD reserved2,
			     WStream **ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStorage %p::CreateStream(%s, 0x%lX, %lu, %lu, %p)", _pstg,
	OlecsOut(pwcsName), grfMode, reserved1, reserved2, ppstm);
    hr = Result(_pstg->CreateStream(pwcsName, grfMode, reserved1,
                                    reserved2, &pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

HRESULT WStorage::OpenStream(const OLECHAR * pwcsName,
			   void *reserved1,
			   const DWORD grfMode,
			   DWORD reserved2,
			   WStream **ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStorage %p::OpenStream(%s, %p, 0x%lX, %lu, %p)", _pstg,
	OlecsOut(pwcsName), reserved1, grfMode, reserved2, ppstm);
    hr = Result(_pstg->OpenStream(pwcsName, reserved1, grfMode,
				 reserved2, &pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

HRESULT WStorage::CreateStorage(const OLECHAR * pwcsName,
			      const DWORD grfMode,
			      DWORD reserved1,
                              DWORD reserved2,
			      WStorage **ppstg)
{
    HRESULT hr;
    IStorage *pistg;

    out("IStorage %p::CreateStorage(%s, 0x%lX, %lu, %lu, %p)", _pstg,
        OlecsOut(pwcsName), grfMode, reserved1, reserved2, ppstg);
    hr = Result(_pstg->CreateStorage(pwcsName, grfMode, reserved1,
                                     reserved2, &pistg));
    *ppstg = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStorage::OpenStorage(const OLECHAR * pwcsName,
			    WStorage *pstgPriority,
			    const DWORD grfMode,
			    SNB snbExclude,
			    DWORD reserved,
			    WStorage **ppstg)
{
    HRESULT hr;
    IStorage *pistg;

    out("IStorage %p::OpenStorage(%s, %p, 0x%lX, %p, %lu, %p)", _pstg,
	OlecsOut(pwcsName), SAFEI(pstgPriority), grfMode,
	snbExclude, reserved, ppstg);
    hr = Result(_pstg->OpenStorage(pwcsName, SAFEI(pstgPriority),
                                   grfMode, snbExclude,
                                   reserved, &pistg));
    *ppstg = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStorage::CopyTo(DWORD ciidExclude,
		       IID *rgiidExclude,
		       SNB snbExclude,
		       WStorage *pstgDest)
{
    out("IStorage %p::CopyTo(%lu, %p, %p, %p)", _pstg, ciidExclude,
	rgiidExclude, snbExclude, pstgDest->GetI());
    return Result(_pstg->CopyTo(ciidExclude, rgiidExclude, snbExclude,
                                pstgDest->GetI()));
}

HRESULT WStorage::MoveElementTo(OLECHAR const FAR* lpszName,
    			WStorage FAR *pstgDest,
                        OLECHAR const FAR* lpszNewName,
                        DWORD grfFlags)
{
    out("IStorage %p::MoveElementTo(%p, %p, %p, %lu)", _pstg, lpszName,
	pstgDest->GetI(), lpszNewName, grfFlags);
    return Result(_pstg->MoveElementTo(lpszName, pstgDest->GetI(),
                                       lpszNewName, grfFlags));
}

HRESULT WStorage::Commit(const DWORD grfCommitFlags)
{
    out("IStorage %p::Commit(0x%lX)", _pstg, grfCommitFlags);
    return Result(_pstg->Commit(grfCommitFlags));
}

HRESULT WStorage::Revert(void)
{
    out("IStorage %p::Revert()", _pstg);
    return Result(_pstg->Revert());
}

HRESULT WStorage::EnumElements(DWORD reserved1,
			     void *reserved2,
			     DWORD reserved3,
			     WEnumSTATSTG **ppenm)
{
    HRESULT hr;
    IEnumSTATSTG *pienm;

    out("IStorage %p::EnumElements(%lu, %p, %lu, %p)", _pstg,
	reserved1, reserved2, reserved3, ppenm);
    hr = Result(_pstg->EnumElements(reserved1, reserved2, reserved3, &pienm));
    *ppenm = WEnumSTATSTG::Wrap(pienm);
    return hr;
}

HRESULT WStorage::DestroyElement(const OLECHAR * pwcsName)
{
    out("IStorage %p::DestroyElement(%s)", _pstg, OlecsOut(pwcsName));
    return Result(_pstg->DestroyElement(pwcsName));
}

HRESULT WStorage::RenameElement(const OLECHAR * pwcsOldName,
			      const OLECHAR * pwcsNewName)
{
    out("IStorage %p::RenameElement(%s, %s)", _pstg, OlecsOut(pwcsOldName),
	OlecsOut(pwcsNewName));
    return Result(_pstg->RenameElement(pwcsOldName, pwcsNewName));
}

HRESULT WStorage::SetElementTimes(const OLECHAR *lpszName,
                                FILETIME const *pctime,
                                FILETIME const *patime,
                                FILETIME const *pmtime)
{
    out("IStorage %p::SetElementTimes(%s, %p, %p, %p)", _pstg,
        OlecsOut(lpszName), pctime, patime, pmtime);
    return Result(_pstg->SetElementTimes(lpszName, pctime, patime, pmtime));
}

HRESULT WStorage::SetClass(REFCLSID clsid)
{
    out("IStorage %p::SetClass(%s)", _pstg, GuidText(&clsid));
    return Result(_pstg->SetClass(clsid));
}

HRESULT WStorage::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    out("IStorage %p::SetStateBits(0x%lX, 0x%lX)", _pstg, grfStateBits,
        grfMask);
    return Result(_pstg->SetStateBits(grfStateBits, grfMask));
}

HRESULT WStorage::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    out("IStorage %p::Stat(%p, %lu)", _pstg, pstatstg, grfStatFlag);
    return Result(_pstg->Stat(pstatstg, grfStatFlag));
}

//+--------------------------------------------------------------
//
//  IStream wrappers
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

WStream *WStream::Wrap(IStream *pistm)
{
    WStream *wstm;

    wstm = new WStream(pistm);
    if (wstm == NULL)
	error(EXIT_OOM, "Unable to wrap IStream\n");
    return wstm;
}

WStream::WStream(IStream *pstm)
{
    // Note:  takes ownership of pstm
    _pstm = pstm;
}

WStream::~WStream(void)
{
    if (_pstm)
	Release();
}

void WStream::Unwrap(void)
{
    delete this;
}

HRESULT WStream::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IStream %p::QueryInterface(riid, %p)", _pstm, ppvObj);
    return Result(_pstm->QueryInterface(riid, ppvObj));
}

ULONG WStream::AddRef(void)
{
    ULONG ul;

    ul = _pstm->AddRef();
    out("IStream %p::AddRef() - %lu\n", _pstm, ul);
    return ul;
}

ULONG WStream::Release(void)
{
    ULONG ul;

    ul = _pstm->Release();
    out("IStream %p::Release() - %lu\n", _pstm, ul);
    if (ul == 0)
	_pstm = NULL;
    return ul;
}

HRESULT WStream::Read(VOID *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr;

    out("IStream %p::Read(%p, %lu, %p)", _pstm, pv, cb, pcbRead);
    hr = _pstm->Read(pv, cb, pcbRead);
    if (pcbRead)
	out(" - %lu bytes", *pcbRead);
    Result(hr);
    if (pcbRead && *pcbRead != cb && fExitOnFail)
	error(EXIT_BADSC, "Couldn't read data\n");
    return hr;
}

HRESULT WStream::Write(VOID *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT hr;

    out("IStream %p::Write(%p, %lu, %p)", _pstm, pv, cb, pcbWritten);
    hr = _pstm->Write(pv, cb, pcbWritten);
    if (pcbWritten)
	out(" - %lu bytes", *pcbWritten);
    Result(hr);
    if (pcbWritten && *pcbWritten != cb && fExitOnFail)
	error(EXIT_BADSC, "Couldn't write data\n");
    return hr;
}

HRESULT WStream::Seek(LONG dlibMove,
		    DWORD dwOrigin,
		    ULONG *plibNewPosition)
{
    HRESULT hr;
    LARGE_INTEGER dlib;
    ULARGE_INTEGER plib;

    out("IStream %p::Seek(%ld, %lu, %p)", _pstm, dlibMove, dwOrigin,
	plibNewPosition);
    LISet32(dlib, dlibMove);
    hr = _pstm->Seek(dlib, dwOrigin, &plib);
    if (plibNewPosition)
    {
        *plibNewPosition = ULIGetLow(plib);
	out(" - ptr %lu", *plibNewPosition);
    }
    return Result(hr);
}

HRESULT WStream::SetSize(ULONG libNewSize)
{
    ULARGE_INTEGER lib;
    
    out("IStream %p::SetSize(%lu)", _pstm, libNewSize);
    ULISet32(lib, libNewSize);
    return Result(_pstm->SetSize(lib));
}

HRESULT WStream::Commit(const DWORD dwFlags)
{
    out("IStream %p:Commit(%lu)", _pstm, dwFlags);
    return Result(_pstm->Commit(dwFlags));
}

HRESULT WStream::CopyTo(WStream *pstm,
		      ULONG cb,
		      ULONG *pcbRead,
		      ULONG *pcbWritten)
{
    ULARGE_INTEGER lcb, pcbr, pcbw;
    HRESULT hr;
    
    out("IStream %p::CopyTo(%p, %lu, %p, %p)", _pstm, pstm->GetI(), cb,
	pcbRead, pcbWritten);
    ULISet32(lcb, cb);
    hr = Result(_pstm->CopyTo(pstm->GetI(), lcb, &pcbr, &pcbw));
    if (pcbRead)
        *pcbRead = ULIGetLow(pcbr);
    if (pcbWritten)
        *pcbWritten = ULIGetLow(pcbw);
    return hr;
}

HRESULT WStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    out("IStream %p::Stat(%p, %lu)", _pstm, pstatstg, grfStatFlag);
    return Result(_pstm->Stat(pstatstg, grfStatFlag));
}

HRESULT WStream::Clone(WStream * *ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStream %p::Clone(%p)", _pstm, ppstm);
    hr = Result(_pstm->Clone(&pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

//+--------------------------------------------------------------
//
//  IEnumSTATSTG wrappers
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

WEnumSTATSTG *WEnumSTATSTG::Wrap(IEnumSTATSTG *pienm)
{
    WEnumSTATSTG *wenm;

    wenm = new WEnumSTATSTG(pienm);
    if (wenm == NULL)
	error(EXIT_OOM, "Unable to wrap IEnumSTATSTG\n");
    return wenm;
}

WEnumSTATSTG::WEnumSTATSTG(IEnumSTATSTG *penm)
{
    // Note:  takes ownership of penm
    _penm = penm;
}

WEnumSTATSTG::~WEnumSTATSTG(void)
{
    if (_penm)
	Release();
}

void WEnumSTATSTG::Unwrap(void)
{
    delete this;
}

HRESULT WEnumSTATSTG::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IEnumSTATSTG %p::QueryInterface(riid, %p)", _penm, ppvObj);
    return Result(_penm->QueryInterface(riid, ppvObj));
}

ULONG WEnumSTATSTG::AddRef(void)
{
    ULONG ul;

    ul = _penm->AddRef();
    out("IEnumSTATSTG %p::AddRef() - %lu\n", _penm, ul);
    return ul;
}

ULONG WEnumSTATSTG::Release(void)
{
    ULONG ul;

    ul = _penm->Release();
    out("IEnumSTATSTG %p::Release() - %lu\n", _penm, ul);
    if (ul == 0)
	_penm = NULL;
    return ul;
}

HRESULT WEnumSTATSTG::Next(ULONG celt, STATSTG rgelt[], ULONG *pceltFetched)
{
    out("IEnumSTATSTG %p::Next(%lu, rgelt, %p)", _penm, celt, pceltFetched);
    return Result(_penm->Next(celt, rgelt, pceltFetched));
}

HRESULT WEnumSTATSTG::Skip(ULONG celt)
{
    out("IEnumSTATSTG %p::Skip(%lu)", _penm, celt);
    return Result(_penm->Skip(celt));
}

HRESULT WEnumSTATSTG::Reset(void)
{
    out("IEnumSTATSTG %p::Reset()", _penm);
    return Result(_penm->Reset());
}

HRESULT WEnumSTATSTG::Clone(WEnumSTATSTG **ppenm)
{
    HRESULT hr;
    IEnumSTATSTG *pienm;

    out("IEnumSTATSTG %p::Clone(%p)", _penm, ppenm);
    hr = Result(_penm->Clone(&pienm));
    *ppenm = WEnumSTATSTG::Wrap(pienm);
    return hr;
}

//+--------------------------------------------------------------
//
//  IMarshal wrappers
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

WMarshal *WMarshal::Wrap(IMarshal *pimsh)
{
    WMarshal *wmsh;

    wmsh = new WMarshal(pimsh);
    if (wmsh == NULL)
	error(EXIT_OOM, "Unable to wrap IMarshal\n");
    return wmsh;
}

WMarshal::WMarshal(IMarshal *pmsh)
{
    // Note:  takes ownership of pmsh
    _pmsh = pmsh;
}

WMarshal::~WMarshal(void)
{
    if (_pmsh)
	Release();
}

void WMarshal::Unwrap(void)
{
    delete this;
}

HRESULT WMarshal::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IMarshal %p::QueryInterface(riid, %p)", _pmsh, ppvObj);
    return Result(_pmsh->QueryInterface(riid, ppvObj));
}

ULONG WMarshal::AddRef(void)
{
    ULONG ul;

    ul = _pmsh->AddRef();
    out("IMarshal %p::AddRef() - %lu\n", _pmsh, ul);
    return ul;
}

ULONG WMarshal::Release(void)
{
    ULONG ul;

    ul = _pmsh->Release();
    out("IMarshal %p::Release() - %lu\n", _pmsh, ul);
    if (ul == 0)
	_pmsh = NULL;
    return ul;
}

HRESULT WMarshal::MarshalInterface(WStream * pStm,
                                   REFIID riid,
                                   LPVOID pv,
                                   DWORD dwDestContext,
				   LPVOID pvDestContext,
                                   DWORD mshlflags)
{
    out("IMarshal %p::MarshalInterface(%p, riid, %p, %lu, %lu, %lu)",
	_pmsh, pStm->GetI(), pv, dwDestContext, pvDestContext, mshlflags);
    return Result(_pmsh->MarshalInterface(pStm->GetI(), riid, pv,
#ifdef OLDMARSHAL
                                          dwDestContext
#ifdef NEWMARSHAL
                                          , mshlflags
#endif                                          
                                          ));
#else
                                          dwDestContext,
					  pvDestContext,
                                          mshlflags));
#endif
}

//+--------------------------------------------------------------
//
//  Root level wrappers
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

HRESULT WStgCreateDocfile(const OLECHAR * pwcsName,
			const DWORD grfMode,
			DWORD reserved,
			WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

#ifndef _CAIRO_
    out("StgCreateDocfile(%s, 0x%lX, %lu, %p)", OlecsOut(pwcsName), grfMode,
	reserved, ppstgOpen);

    hr = Result(StgCreateDocfile(pwcsName, grfMode,
                                 reserved, &pistg));
#else ELSE == 300
    out("StgCreateStorage(%s, 0x%lX, %lu, %p)", OlecsOut(pwcsName), grfMode,
	reserved, ppstgOpen);

    hr = Result(StgCreateStorage(pwcsName, grfMode,
                                 STGFMT_DOCUMENT,
                                 (LPSECURITY_ATTRIBUTES)reserved, &pistg));
#endif

    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgCreateDocfileOnILockBytes(ILockBytes *plkbyt,
				    const DWORD grfMode,
				    DWORD reserved,
				    WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgCreateDocfileOnILockBytes(%p, 0x%lX, %lu, %p)",
	plkbyt, grfMode, reserved, ppstgOpen);
    hr = Result(StgCreateDocfileOnILockBytes(plkbyt, grfMode,
                                             reserved, &pistg));
    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgOpenStorage(const OLECHAR * pwcsName,
		      WStorage *pstgPriority,
		      const DWORD grfMode,
		      SNB snbExclude,
		      DWORD reserved,
		      WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgOpenStorage(%s, %p, 0x%lX, %p, %lu, %p)", OlecsOut(pwcsName),
	SAFEI(pstgPriority), grfMode, snbExclude, reserved, ppstgOpen);
    hr = Result(StgOpenStorage(pwcsName, SAFEI(pstgPriority), grfMode,
			      snbExclude,
                               reserved, &pistg));

    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgOpenStorageOnILockBytes(ILockBytes *plkbyt,
				  WStorage *pstgPriority,
				  const DWORD grfMode,
				  SNB snbExclude,
				  DWORD reserved,
				  WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgOpenStorageOnILockBytes(%p, %p, 0x%lX, %p, %lu, %p)",
	plkbyt, SAFEI(pstgPriority), grfMode, snbExclude, reserved,
	ppstgOpen);
    hr = Result(StgOpenStorageOnILockBytes(plkbyt, SAFEI(pstgPriority),
					  grfMode, snbExclude, reserved,
					  &pistg));
    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgIsStorageFile(const OLECHAR * pwcsName)
{
    out("StgIsStorageFile(%s)", OlecsOut(pwcsName));
    return Result(StgIsStorageFile(pwcsName));
}

HRESULT WStgIsStorageILockBytes(ILockBytes * plkbyt)
{
    out("StgIsStorageILockBytes(%p)", plkbyt);
    return Result(StgIsStorageILockBytes(plkbyt));
}

HRESULT WCoMarshalInterface(WStream *pStm,
                            REFIID iid,
                            IUnknown *pUnk,
                            DWORD dwDestContext,
                            LPVOID pvDestContext,
                            DWORD mshlflags)
{
    out("CoMarshalInterface(%p, iid, %p, %lu, %p, %lX)", pStm->GetI(),
        pUnk, dwDestContext, pvDestContext, mshlflags);
#ifdef OLDMARSHAL
    return Result(CoMarshalInterface(pStm->GetI(), iid, pUnk, dwDestContext,
                                     mshlflags));
#else    
    return Result(CoMarshalInterface(pStm->GetI(), iid, pUnk, dwDestContext,
                                     pvDestContext, mshlflags));
#endif
}

HRESULT WCoUnmarshalInterface(WStream *pStm,
                              REFIID riid,
                              LPVOID *ppv)
{
    out("CoUnmarshalInterface(%p, iid, %p)", pStm->GetI(), ppv);
    return Result(CoUnmarshalInterface(pStm->GetI(), riid, ppv));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\makefile.inc ===
# 16-bit makefile
#
# Copyright (c) 1991, Microsoft Corporation
#
# History:
#
#   18-Feb-1994 KevinRo
#   24-Feb-1994 DrewB, added OBJDIR and some other niceties from win40.mk
#

.SUFFIXES:
.SUFFIXES: .c  .cxx  .cpp .asm .h   .inc .obj .lst
.SUFFIXES: .sys .exe .com .map .sym .def .lib .rc .res

!if "$(TARGET)" == ""
!error TARGET must be defined
!endif

OUTNUL= 1>nul 2>nul

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail"
OBJDIR = objd
!else
OBJDIR = objr
!endif

# Build up lists of files to produce from sources

!if "$(CFILES)" != ""
OBJFILES = $(OBJFILES) $(CFILES:.c=.obj)
!endif
!if "$(CXXFILES)" != ""
OBJFILES = $(OBJFILES) $(CXXFILES:.cxx=.obj)
!endif
!if "$(CPPFILES)" != ""
OBJFILES = $(OBJFILES) $(CPPFILES:.cpp=.obj)
!endif

!if "$(ASMFILES)" != ""
OBJFILES = $(OBJFILES) $(ASMFILES:.asm=.obj)
!endif

!if "$(RCFILES)" != ""
RESFILES = $(RCFILES:.rc=.res)
!endif

# Replace .\ with $(OBJDIR)
# Unfortunately we can't do this directly so we have to explicitly check
# the value of OBJDIR

!if "$(OBJDIR)" == "objd"
OBJFILES = $(OBJFILES:.\=objd\)
RESFILES = $(RESFILES:.\=objd\)

!elseif "$(OBJDIR)" == "objr"
OBJFILES = $(OBJFILES:.\=objr\)
RESFILES = $(RESFILES:.\=objr\)

!else
!error Unknown OBJDIR: $(OBJDIR)
!endif

# Default target

all: $(OBJDIR)\$(TARGET)

# Determine target type and base name

# Is it a DLL?
TARGETBASE=$(TARGET:.dll=)
!if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=dll
!else

# Is it an EXE?
TARGETBASE=$(TARGET:.exe=)
! if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=exe
! else

# Is it a LIB?
TARGETBASE=$(TARGET:.lib=)
!  if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=lib
!  endif
! endif
!endif

!if "$(TARGETTYPE)" == ""
!error Unknown target type for "$(TARGET)"
!endif

!if "$(BUILDDETAILS)" != ""
BLDKEEP=        KEEP
!endif

OLETHUNK= $(_NTDRIVE)$(_NTROOT)\private\ole32\olethunk
OLE16= $(OLETHUNK)\ole16

RCINC = $(RCINC) -i$(OLE16)\inc
INCS = -I$(OLE16)\inc -I$(OLETHUNK)\h -I$(_NTDRIVE)$(_NTROOT)\private\cinc


PATH     = $(OLE16)\tools;$(PATH)
LINK    = link16
RC      = rc16
CL      = cl16
IMPLIB  = implib
LIBUTIL = lib16
MAPSYM  = mapsym
MASM    = masm

DEFINES = -DWOW

AOBJ    = -Mx -t $(DEFINES) $(INCS)

!if "$(TARGETTYPE)" == "exe"
CW16    = -GA
!else
CW16    = -GD
DEFINES = $(DEFINES) -D_WINDLL
!endif

CW16    = $(CW16) -G2 -AL $(DEFINES) $(INCS) /NMSEG_CODE

LFLAGS  = $(LFLAGS) /nod /noe /map:0 /align:16

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail"

DEFINES = $(DEFINES) -DDBG=1 -DDEVL=1

!if "$(NTDEBUGTYPE)" == "windbg"
AOBJ    = $(AOBJ) -Zi
CW16    = $(CW16) /Odi /Zip /FA
LFLAGS  = $(LFLAGS) /CO
!else
AOBJ    = $(AOBJ) -Zd
CW16    = $(CW16) /Odi /Zd
LFLAGS  = $(LFLAGS) /LI
!endif

!else
CW16    = $(CW16) /Os /Zp /Gs
DEFINES = $(DEFINES) -DDBG=0 -DDEVL=1
!endif

!if "$(TARGETTYPE)" == "dll"
W16LIBS = $(OLE16)\lib\ldllcew.lib
!else
!if "$(QUICKWINDOWS)" != ""
W16LIBS = $(OLE16)\lib\llibcewq.lib
!else
W16LIBS = $(OLE16)\lib\llibcew.lib
!endif
!endif

W16LIBS = $(W16LIBS) $(OLE16)\lib\libw.lib

!if "$(TARGETTYPE)" == "dll" || "$(TARGETTYPE)" == "exe"
LIBS = $(LIBS) $(W16LIBS)
!endif

.asm{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) $*,$*;

.asm.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) -l $*,nul,$*.lst;


.c{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
$<
<<$(BLDKEEP)

.c.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fonul
-Fc$*.lst
$<
<<$(BLDKEEP)

.cxx{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cxx.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cxx.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.cpp{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cpp.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cpp.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.def{$(OBJDIR)}.lib:
        @-md $(OBJDIR) $(OUTNUL)
        $(IMPLIB) $*.lib $<

{$(OBJDIR)}.map{$(OBJDIR)}.sym:
        @-md $(OBJDIR) $(OUTNUL)
        $(MAPSYM) $<

.rc{$(OBJDIR)}.res:
                @-md $(OBJDIR) $(OUTNUL)
        $(RC) -r  $(RCINC) -fo $*.res $<


cleanup:
    if exist $(OBJDIR)\*.lrf del $(OBJDIR)\*.lrf
    if exist $(OBJDIR)\*.obj del $(OBJDIR)\*.obj
    if exist $(OBJDIR)\*.exe del $(OBJDIR)\*.exe
    if exist $(OBJDIR)\*.map del $(OBJDIR)\*.map
    if exist $(OBJDIR)\*.sym del $(OBJDIR)\*.sym
    if exist $(OBJDIR)\*.res del $(OBJDIR)\*.res

clean: cleanup

!if "$(TARGETTYPE)" == "dll"

$(OBJDIR)\$(TARGETBASE).lib: $(TARGETBASE).def

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(OBJDIR)\$(TARGETBASE).lib $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map
!if "$(RCFILES)" != ""
        $(RC)  -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif

!elseif "$(TARGETTYPE)" == "lib"

$(OBJDIR)\$(TARGET): $(OBJFILES) $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        -del $@ $(OUTNUL)
        $(LIBUTIL) @<<$*.lnb
$(OBJDIR)\$(TARGET)
y
$(OBJFILES: = &^
)&
$(LIBS: = &^
)&

$*.lls
<<$(BLDKEEP)

!elseif "$(TARGETTYPE)" == "exe"

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
!if "$(RCFILES)" != ""
       $(RC) -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\app.h ===
//**********************************************************************
// File name: app.h
//
//      Definition of CSimpleApp
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _APP_H_)
#define _APP_H_

#include <ole2.h>

class CSimpleDoc;

class CSimpleApp : public IUnknown
{
public:

        int m_nCount;           // reference count
        HWND m_hAppWnd;         // main window handle
        HWND m_hDriverWnd;      // window handle for the driver app.
        HINSTANCE m_hInst;      // application instance
        CSimpleDoc FAR * m_lpDoc;   // pointer to document object
        BOOL m_fInitialized;    // OLE initialization flag
        HMENU           m_hMainMenu;
        HMENU           m_hFileMenu;
        HMENU           m_hEditMenu;
        HMENU           m_hHelpMenu;
        HMENU           m_hCascadeMenu;     // OLE object's verb


        // Drag/Drop related fields
        int m_nDragDelay;       // time delay (in msec) before drag should start
        int m_nDragMinDist;     // min. distance (radius) before drag should start
        int m_nScrollDelay;     // time delay (in msec) before scroll should start
        int m_nScrollInset;     // Border inset distance to start drag scroll
        int m_nScrollInterval;  // scroll interval time (in msec)

        CSimpleApp();           // Constructor
        ~CSimpleApp();          // Destructor

        // IUnknown Interfaces
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // Initialization methods

        BOOL fInitApplication (HANDLE hInstance);
        BOOL fInitInstance (HANDLE hInstance, int nCmdShow);

        // Message handling methods

        long lCommandHandler (HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
        long lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
        long lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
        BOOL HandleAccelerators (LPMSG lpMsg);
        void PaintApp(HDC hDC);
        void DestroyDocs();
};

#endif  // _APP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\doc.h ===
//**********************************************************************
// File name: doc.h
//
//      Definition of CSimpleDoc
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DOC_H_ )
#define _DOC_H_

#include "idt.h"
#include "ids.h"

class CSimpleSite;
class CSimpleApp;

class CSimpleDoc : public IUnknown
{
public:
	int             m_nCount;           // reference count
	LPSTORAGE       m_lpStorage;        // IStorage* pointer for Doc
	BOOL            m_fModifiedMenu;    // is object's verb menu on menu

	// Drag/Drop related fields
	BOOL            m_fRegDragDrop;     // is doc registered as drop target?
	BOOL            m_fLocalDrag;       // is doc source of the drag
	BOOL            m_fLocalDrop;       // was doc target of the drop
	BOOL            m_fCanDropCopy;     // is Drag/Drop copy/move possible?
	BOOL            m_fCanDropLink;     // is Drag/Drop link possible?
	BOOL            m_fDragLeave;       // has drag left
	BOOL            m_fPendingDrag;     // LButtonDown--possible drag pending
	POINT           m_ptButDown;        // LButtonDown coordinates

	CSimpleSite FAR * m_lpSite;
	CSimpleApp FAR * m_lpApp;

	HWND m_hDocWnd;

	CDropTarget m_DropTarget;
	CDropSource m_DropSource;

	static CSimpleDoc FAR* Create(CSimpleApp FAR *lpApp, LPRECT lpRect,
			HWND hWnd);

	void Close(void);

	CSimpleDoc();
	CSimpleDoc(CSimpleApp FAR *lpApp, HWND hWnd);
	~CSimpleDoc();

	// IUnknown Interface
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	void InsertObject(void);
	void DisableInsertObject(void);
	long lResizeDoc(LPRECT lpRect);
	long lAddVerbs(void);
	void PaintDoc(HDC hDC);

	// Drag/Drop and clipboard support methods
	void CopyObjectToClip(void);
	BOOL QueryDrag(POINT pt);
	DWORD DoDragDrop(void);
	void Scroll(DWORD dwScrollDir) { /*...scroll Doc here...*/ }
};

#endif  // _DOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\doc.cpp ===
//**********************************************************************
// File name: DOC.CPP
//
//      Implementation file for CSimpleDoc.
//
// Functions:
//
//      See DOC.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include "idt.h"
#include "dxferobj.h"

//**********************************************************************
//
// CSimpleDoc::Create
//
// Purpose:
//
//      Creation for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      LPRECT lpRect           -   Client area rect of "frame" window
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      RegisterDragDrop            OLE API
//      CoLockObjectExternal        OLE API
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//
// Comments:
//
//      This routine was added so that failure could be returned
//      from object creation.
//
//********************************************************************

CSimpleDoc FAR * CSimpleDoc::Create(CSimpleApp FAR *lpApp, LPRECT lpRect,HWND hWnd)
{
	CSimpleDoc FAR * lpTemp = new CSimpleDoc(lpApp, hWnd);

	if (!lpTemp)
		return NULL;

	// create storage for the doc.
	HRESULT hErr = StgCreateDocfile (
		NULL,       // generate temp name
		STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
		0, &lpTemp->m_lpStorage);

	if (hErr != NOERROR)
		goto error;

	// create the document Window
	lpTemp->m_hDocWnd = CreateWindow(
			"SimpDndDocWClass",
			NULL,
			WS_CHILD | WS_CLIPCHILDREN,
			lpRect->left,
			lpRect->top,
			lpRect->right,
			lpRect->bottom,
			hWnd,
			NULL,
			lpApp->m_hInst,
			NULL);

	if (!lpTemp->m_hDocWnd)
		goto error;

	ShowWindow(lpTemp->m_hDocWnd, SW_SHOWNORMAL);  // Show the window
	UpdateWindow(lpTemp->m_hDocWnd);               // Sends WM_PAINT message

	// Ensable InsertObject menu choice
	EnableMenuItem( lpApp->m_hEditMenu, 1, MF_BYPOSITION | MF_ENABLED);
	// Disable Copy menu choice
	EnableMenuItem( lpApp->m_hEditMenu, 0, MF_BYPOSITION | MF_DISABLED | MF_GRAYED);

	// It is *REQUIRED* to hold a strong LOCK on the object that is
	// registered as drop target. this call will result in at least one
	// ref count held on our document. later in CSimpleDoc::Close we will
	// unlock this lock which will make our document's ref count go to 0.
	// when the document's ref count goes to 0, it will be deleted.
	CoLockObjectExternal (&lpTemp->m_DropTarget, TRUE, 0);

	// Register our window as a DropTarget
	RegisterDragDrop(lpTemp->m_hDocWnd, &lpTemp->m_DropTarget);
	lpTemp->m_fRegDragDrop = TRUE;

	return (lpTemp);

error:
	delete (lpTemp);
	return NULL;

}

//**********************************************************************
//
// CSimpleDoc::Close
//
// Purpose:
//
//      Close CSimpleDoc object.
//      when the document's reference count goes to 0, the document
//      will be destroyed.
//
// Parameters:
//
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      RevokeDragDrop              OLE API
//      CoLockObjectExternal        OLE API
//      OleFlushClipboard           OLE API
//      ShowWindow                  Windows API
//
// Comments:
//
//********************************************************************

void CSimpleDoc::Close(void)
{
	TestDebugOut("In CSimpleDoc::Close\r\n");

	ShowWindow(m_hDocWnd, SW_HIDE);  // Hide the window

	// Remove our data transfer object from clipboard if it is there.
	//  this will leave HGLOBAL based data behind on the clipboard
	//  including OLE 1.0 compatibility formats.
	OleFlushClipboard();

	// Revoke our window as a DropTarget
	if (m_fRegDragDrop) {
		RevokeDragDrop(m_hDocWnd);
		m_fRegDragDrop = FALSE;
	}

	// Close the OLE object in our document
	if (m_lpSite)
		m_lpSite->CloseOleObject();

	// Unlock the lock added in CSimpleDoc::Create. this will make
	// the document's ref count go to 0, and the document will be deleted.
	CoLockObjectExternal (&m_DropTarget, FALSE, TRUE);
}

//**********************************************************************
//
// CSimpleDoc::CSimpleDoc
//
// Purpose:
//
//      Constructor for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetMenu                     Windows API
//      GetSubMenu                  Windows API
//
// Comments:
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
								// tells us that we are passing this in
								// an initializer, before "this" is through
								// initializing.  This is ok, because
								// we just store the ptr in the other
								// constructor

CSimpleDoc::CSimpleDoc(CSimpleApp FAR * lpApp,HWND hWnd)
		: m_DropTarget(this), m_DropSource(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
	TestDebugOut("In CSimpleDoc's Constructor\r\n");
	m_lpApp = lpApp;
	m_lpSite = NULL;
	m_nCount = 0;
	// set up menu handles
	lpApp->m_hMainMenu = GetMenu(hWnd);
	lpApp->m_hFileMenu = GetSubMenu(lpApp->m_hMainMenu, 0);
	lpApp->m_hEditMenu = GetSubMenu(lpApp->m_hMainMenu, 1);
	lpApp->m_hHelpMenu = GetSubMenu(lpApp->m_hMainMenu, 2);
	lpApp->m_hCascadeMenu = NULL;
	m_fModifiedMenu = FALSE;

	// drag/drop related stuff
	m_fRegDragDrop = FALSE;       // is doc registered as drop target?
	m_fLocalDrag = FALSE;         // is doc source of the drag
	m_fLocalDrop = FALSE;         // was doc target of the drop
	m_fCanDropCopy = FALSE;       // is Drag/Drop copy/move possible?
	m_fCanDropLink = FALSE;       // is Drag/Drop link possible?
	m_fDragLeave = FALSE;         // has drag left
	m_fPendingDrag = FALSE;       // LButtonDown--possible drag pending
	m_ptButDown.x = m_ptButDown.y = 0; // LButtonDown coordinates
}

//**********************************************************************
//
// CSimpleDoc::~CSimpleDoc
//
// Purpose:
//
//      Destructor for CSimpleDoc
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::Release        SITE.CPP
//      IStorage::Release           OLE API
//
// Comments:
//
//********************************************************************

CSimpleDoc::~CSimpleDoc()
{
	TestDebugOut("In CSimpleDoc's Destructor\r\n");

	// Release all pointers we hold to the OLE object. also release
	// the ref count added in CSimpleSite::Create. this will make
	// the Site's ref count go to 0, and the Site will be deleted.
	if (m_lpSite) {
		m_lpSite->UnloadOleObject();
		m_lpSite->Release();
		m_lpSite = NULL;
	}

	// Release the Storage
	if (m_lpStorage) {
		m_lpStorage->Release();
		m_lpStorage = NULL;
	}

	// if the edit menu was modified, remove the menu item and
	// destroy the popup if it exists
	if (m_fModifiedMenu)
		{
		int nCount = GetMenuItemCount(m_lpApp->m_hEditMenu);
		RemoveMenu(m_lpApp->m_hEditMenu, nCount-1, MF_BYPOSITION);
		if (m_lpApp->m_hCascadeMenu)
			DestroyMenu(m_lpApp->m_hCascadeMenu);
		}

	DestroyWindow(m_hDocWnd);
}


//**********************************************************************
//
// CSimpleDoc::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_OK                -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP CSimpleDoc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In CSimpleDoc::QueryInterface\r\n");

	*ppvObj = NULL;     // must set out pointer parameters to NULL

	// looking for IUnknown
	if ( riid == IID_IUnknown)
		{
		AddRef();
		*ppvObj = this;
		return ResultFromScode(S_OK);
		}

	// looking for IDropTarget
	if ( riid == IID_IDropTarget)
		{
		m_DropTarget.AddRef();
		*ppvObj=&m_DropTarget;
		return ResultFromScode(S_OK);
		}

	// looking for IDropSource
	if ( riid == IID_IDropSource)
		{
		m_DropSource.AddRef();
		*ppvObj=&m_DropSource;
		return ResultFromScode(S_OK);
		}

	// Not a supported interface
	return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleDoc::AddRef
//
// Purpose:
//
//      Increments the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleApp::AddRef          APP.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::AddRef()
{
	TestDebugOut("In CSimpleDoc::AddRef\r\n");
	return ++m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::Release
//
// Purpose:
//
//      Decrements the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::Release()
{
	TestDebugOut("In CSimpleDoc::Release\r\n");

	if (--m_nCount == 0) {
		delete this;
		return 0;
	}
	return m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::InsertObject
//
// Purpose:
//
//      Inserts a new object to this document
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::CSimpleSite    SITE.CPP
//      CSimpleSite::InitObject     SITE.CPP
//      memset                      C Runtime
//      OleUIInsertObject           OUTLUI function
//      CSimpleDoc::DisableInsertObject DOC.CPP
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another.
//
//********************************************************************

void CSimpleDoc::InsertObject()
{
	OLEUIINSERTOBJECT io;
	UINT iret;
	char szFile[OLEUI_CCHPATHMAX];

	m_lpSite = CSimpleSite::Create(this);

	// clear the structure
	_fmemset(&io, 0, sizeof(OLEUIINSERTOBJECT));

	// fill the structure
	io.cbStruct = sizeof(OLEUIINSERTOBJECT);
	io.dwFlags = IOF_SELECTCREATENEW |
					IOF_DISABLELINK | IOF_DISABLEDISPLAYASICON |
					IOF_CREATENEWOBJECT | IOF_CREATEFILEOBJECT;
	io.hWndOwner = m_hDocWnd;
	io.lpszCaption = (LPSTR)"Insert Object";
	io.iid = IID_IOleObject;
	io.oleRender = OLERENDER_DRAW;
	io.lpIOleClientSite = &m_lpSite->m_OleClientSite;
	io.lpIStorage = m_lpSite->m_lpObjStorage;
	io.ppvObj = (LPVOID FAR *)&m_lpSite->m_lpOleObject;
	io.lpszFile = szFile;
	io.cchFile = sizeof(szFile);
	_fmemset((LPSTR)szFile, 0, sizeof(szFile));

	// call OUTLUI to do all the hard work
	iret = OleUIInsertObject(&io);

	if (iret == OLEUI_OK)
		{
		m_lpSite->InitObject((BOOL)(io.dwFlags & IOF_SELECTCREATENEW));
		// disable Insert Object menu item
		DisableInsertObject();
		}
	else
		{
		m_lpSite->Release();
		m_lpSite = NULL;
		m_lpStorage->Revert();
		}

}

//**********************************************************************
//
// CSimpleDoc::lResizeDoc
//
// Purpose:
//
//      Resizes the document
//
// Parameters:
//
//      LPRECT lpRect   -   The size of the client are of the "frame"
//                          Window.
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                Location
//
//      MoveWindow                              Windows API
//
// Comments:
//
//********************************************************************

long CSimpleDoc::lResizeDoc(LPRECT lpRect)
{
	MoveWindow(
			m_hDocWnd,
			lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom, TRUE);

	return NULL;
}

//**********************************************************************
//
// CSimpleDoc::lAddVerbs
//
// Purpose:
//
//      Adds the objects verbs to the edit menu.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetMenuItemCount            Windows API
//      OleUIAddVerbMenu            OUTLUI function
//
// Comments:
//
//********************************************************************

long CSimpleDoc::lAddVerbs(void)
{
	// m_fModifiedMenu is TRUE if the menu has already been modified
	// once.  Since we only support one obect every time the application
	// is run, then once the menu is modified, it doesn't have
	// to be done again.
	if (m_lpSite && !m_fModifiedMenu)
		{
		int nCount = GetMenuItemCount(m_lpApp->m_hEditMenu);

		OleUIAddVerbMenu ( m_lpSite->m_lpOleObject,
						   NULL,
						   m_lpApp->m_hEditMenu,
						   nCount + 1,
						   IDM_VERB0,
						   0,           // no maximum verb IDM enforced
						   FALSE,
						   1,
						   &m_lpApp->m_hCascadeMenu);

		m_fModifiedMenu = TRUE;
		}
	return (NULL);
}

//**********************************************************************
//
// CSimpleDoc::PaintDoc
//
// Purpose:
//
//      Paints the Document
//
// Parameters:
//
//      HDC hDC -   hDC of the document Window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::PaintObj       SITE.CPP
//
// Comments:
//
//********************************************************************

void CSimpleDoc::PaintDoc (HDC hDC)
{
	// if we supported multiple objects, then we would enumerate
	// the objects and call paint on each of them from here.

	if (m_lpSite)
		m_lpSite->PaintObj(hDC);

}

//**********************************************************************
//
// CSimpleDoc::DisableInsertObject
//
// Purpose:
//
//      Disable the ability to insert a new object in this document.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      RevokeDragDrop              OLE API
//      EnableMenuItem              Windows API
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another. Also we revoke ourself as
//      a potential drop target.
//
//********************************************************************

void CSimpleDoc::DisableInsertObject(void)
{
	// Disable InsertObject menu choice
	EnableMenuItem( m_lpApp->m_hEditMenu, 1, MF_BYPOSITION | MF_DISABLED | MF_GRAYED);
	// Enable Copy menu choice
	EnableMenuItem( m_lpApp->m_hEditMenu, 0, MF_BYPOSITION | MF_ENABLED);

	// We no longer accept dropping of objects
	if (m_fRegDragDrop) {
		RevokeDragDrop(m_hDocWnd);
		m_fRegDragDrop = FALSE;
	}
}

//**********************************************************************
//
// CSimpleDoc::CopyObjectToClip
//
// Purpose:
//
//      Copy the embedded OLE object to the clipboard
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CDataXferObj::Create        DXFEROBJ.CPP
//      CDataXferObj::QueryInterface DXFEROBJ.CPP
//      OleSetClipboard             OLE API
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Copy menu choice is enabled.
//
//********************************************************************

void CSimpleDoc::CopyObjectToClip(void)
{
	LPDATAOBJECT lpDataObj;

	// Create a data transfer object by cloning the existing OLE object
	CDataXferObj FAR* pDataXferObj = CDataXferObj::Create(m_lpSite,NULL);
	if (! pDataXferObj) {
		MessageBox(NULL,"Out-of-memory","SimpDnD",MB_SYSTEMMODAL|MB_ICONHAND);
		return;
	}
	// initially obj is created with 0 refcnt. this QI will make it go to 1.
	pDataXferObj->QueryInterface(IID_IDataObject, (LPVOID FAR*)&lpDataObj);

	// put out data transfer object on the clipboard. this API will AddRef.
	OleSetClipboard(lpDataObj);

	// Give ownership of data transfer object to clipboard
	pDataXferObj->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\ole2ui\res\localole.h ===
/*
 * OLE2UI.H
 *
 * Published definitions, structures, types, and function prototypes for the
 * OLE 2.0 User Interface support library.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 */


#define NONAMELESSUNION     // use strict ANSI standard (for DVOBJ.H)

#ifndef _OLE2UI_H_
#define _OLE2UI_H_

#ifndef RC_INVOKED
#pragma message ("Including OLE2UI.H from " __FILE__)
#endif  //RC_INVOKED

#include <windows.h>
#include <shellapi.h>
#include <ole2.h>
#include <string.h>
#include "olestd.h"
#include "uiclass.h"
// -- see below

#ifdef __TURBOC__
#define _getcwd getcwd
#define _itoa   itoa
#define __max   max
#define _find_t find_t
#endif // __TURBOC__

/*
 * Initialization / Uninitialization routines.  OleUIInitialize
 * MUST be called prior to using any functions in OLE2UI.
 */

STDAPI_(BOOL) OleUIInitialize(HINSTANCE);
STDAPI_(BOOL) OleUIUnInitialize(void);  // Must be called when completed using functions in OLE2UI

//Dialog Identifiers as passed in Help messages to identify the source.
#define IDD_INSERTOBJECT        1000
#define IDD_CHANGEICON          1001
#define IDD_CONVERT             1002
#define IDD_PASTESPECIAL        1003
#define IDD_EDITLINKS           1004
#define IDD_FILEOPEN            1005
#define IDD_BUSY                1006
#define IDD_LINKSOURCEUNAVAILABLE   1007
#define IDD_CANNOTUPDATELINK    1008
#define IDD_SERVERNOTREG        1009
#define IDD_LINKTYPECHANGED     1010
#define IDD_SERVERNOTFOUND      1011
#define IDD_UPDATELINKS         1012
#define IDD_OUTOFMEMORY         1013

#define IDOK    1
#define IDCANCEL 2

// Stringtable identifers
#define IDS_OLE2UIUNKNOWN       300
#define IDS_OLE2UILINK          301
#define IDS_OLE2UIOBJECT        302
#define IDS_OLE2UIEDIT          303
#define IDS_OLE2UICONVERT       304
#define IDS_OLE2UIEDITLINKCMD_1VERB     305
#define IDS_OLE2UIEDITOBJECTCMD_1VERB   306
#define IDS_OLE2UIEDITLINKCMD_NVERB     307
#define IDS_OLE2UIEDITOBJECTCMD_NVERB   308
#define IDS_OLE2UIEDITNOOBJCMD  309
#define IDS_DEFICONLABEL        310     // def. icon label (usu. "Document")


#define IDS_FILTERS             64
#define IDS_ICONFILTERS         65

//Resource identifiers for bitmaps
#define IDB_RESULTSEGA                  10
#define IDB_RESULTSVGA                  11
#define IDB_RESULTSHIRESVGA             12


//Missing from windows.h
#ifndef PVOID
typedef VOID *PVOID;
#endif


//Hook type used in all structures.
typedef UINT (CALLBACK *LPFNOLEUIHOOK)(HWND, UINT, WPARAM, LPARAM);


//Strings for registered messages
#define SZOLEUI_MSG_HELP                "OLEUI_MSG_HELP"
#define SZOLEUI_MSG_ENDDIALOG           "OLEUI_MSG_ENDDIALOG"
#define SZOLEUI_MSG_BROWSE              "OLEUI_MSG_BROWSE"
#define SZOLEUI_MSG_CHANGEICON          "OLEUI_MSG_CHANGEICON"
#define SZOLEUI_MSG_CLOSEBUSYDIALOG     "OLEUI_MSG_CLOSEBUSYDIALOG"
#define SZOLEUI_MSG_FILEOKSTRING        "OLEUI_MSG_FILEOKSTRING"

// Define the classname strings.  The strings below define the custom
// control classnames for the controls used in the UI dialogs.  
//
// **************************************************************
// These classnames must be distinct for each application
// which uses this library, or your application will generate an
// fatal error under the debugging version of Windows 3.1.
// **************************************************************
//
// The MAKEFILE for this library automatically generates a file
// uiclass.h which contains distinct definitions for these
// classname strings, as long as you use a distinct name when
// you build the library.  See the MAKEFILE for more information
// on setting the name of the library.

#define SZCLASSICONBOX                 OLEUICLASS1
#define SZCLASSRESULTIMAGE             OLEUICLASS2

#define OLEUI_ERR_STANDARDMIN           100
#define OLEUI_ERR_STRUCTURENULL         101   //Standard field validation
#define OLEUI_ERR_STRUCTUREINVALID      102
#define OLEUI_ERR_CBSTRUCTINCORRECT     103
#define OLEUI_ERR_HWNDOWNERINVALID      104
#define OLEUI_ERR_LPSZCAPTIONINVALID    105
#define OLEUI_ERR_LPFNHOOKINVALID       106
#define OLEUI_ERR_HINSTANCEINVALID      107
#define OLEUI_ERR_LPSZTEMPLATEINVALID   108
#define OLEUI_ERR_HRESOURCEINVALID      109

#define OLEUI_ERR_FINDTEMPLATEFAILURE   110   //Initialization errors
#define OLEUI_ERR_LOADTEMPLATEFAILURE   111
#define OLEUI_ERR_DIALOGFAILURE         112
#define OLEUI_ERR_LOCALMEMALLOC         113
#define OLEUI_ERR_GLOBALMEMALLOC        114
#define OLEUI_ERR_LOADSTRING            115

#define OLEUI_ERR_STANDARDMAX           116   //Start here for specific errors.



//Help Button Identifier
#define ID_OLEUIHELP                    99

// Help button for fileopen.dlg  (need this for resizing) 1038 is pshHelp
#define IDHELP  1038

// Static text control (use this instead of -1 so things work correctly for
// localization
#define  ID_STATIC                      98

//Maximum key size we read from the RegDB.
#define OLEUI_CCHKEYMAX                 256  // make any changes to this in geticon.c too

//Maximum verb length and length of Object menu
#define OLEUI_CCHVERBMAX                32
#define OLEUI_OBJECTMENUMAX             64

//Maximum MS-DOS pathname.
#define OLEUI_CCHPATHMAX                256 // make any changes to this in geticon.c too
#define OLEUI_CCHFILEMAX                13

//Icon label length
#define OLEUI_CCHLABELMAX               40  // make any changes to this in geticon.c too

//Length of the CLSID string
#define OLEUI_CCHCLSIDSTRING            39


/*
 * What follows here are first function prototypes for general utility
 * functions, then sections laid out by dialog.  Each dialog section
 * defines the dialog structure, the API prototype, flags for the dwFlags
 * field, the dialog-specific error values, and dialog control IDs (for
 * hooks and custom templates.
 */


//Miscellaneous utility functions.
STDAPI_(BOOL) OleUIAddVerbMenu(LPOLEOBJECT lpOleObj,
                             LPSTR lpszShortType,
                             HMENU hMenu,
                             UINT uPos,
                             UINT uIDVerbMin,
                             BOOL bAddConvert,
                             UINT idConvert,
                             HMENU FAR *lphMenu);
        
//Metafile utility functions
STDAPI_(HGLOBAL) OleUIMetafilePictFromIconAndLabel(HICON, LPSTR, LPSTR, UINT);
STDAPI_(void)    OleUIMetafilePictIconFree(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictIconDraw(HDC, LPRECT, HGLOBAL, BOOL);
STDAPI_(UINT)    OleUIMetafilePictExtractLabel(HGLOBAL, LPSTR, UINT, LPDWORD);
STDAPI_(HICON)   OleUIMetafilePictExtractIcon(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictExtractIconSource(HGLOBAL,LPSTR,UINT FAR *);





/*************************************************************************
** INSERT OBJECT DIALOG
*************************************************************************/


typedef struct tagOLEUIINSERTOBJECT
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;         //Structure Size
    DWORD           dwFlags;          //IN-OUT:  Flags
    HWND            hWndOwner;        //Owning window
    LPCSTR          lpszCaption;      //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;         //Hook callback
    LPARAM          lCustData;        //Custom data to pass to hook
    HINSTANCE       hInstance;        //Instance for customized template name
    LPCSTR          lpszTemplate;     //Customized template name
    HRSRC           hResource;        //Customized template handle

    //Specifics for OLEUIINSERTOBJECT.  All are IN-OUT unless otherwise spec.
    CLSID           clsid;            //Return space for class ID
    LPSTR           lpszFile;         //Filename for inserts or links
    UINT            cchFile;          //Size of lpszFile buffer: OLEUI_CCHPATHMAX
    UINT            cClsidExclude;    //IN only:  CLSIDs in lpClsidExclude
    LPCLSID         lpClsidExclude;   //List of CLSIDs to exclude from listing.

    //Specific to create objects if flags say so
    IID             iid;              //Requested interface on creation.
    DWORD           oleRender;        //Rendering option
    LPFORMATETC     lpFormatEtc;      //Desired format
    LPOLECLIENTSITE lpIOleClientSite; //Site to be use for the object.
    LPSTORAGE       lpIStorage;       //Storage used for the object
    LPVOID FAR     *ppvObj;           //Where the object is returned.
    SCODE           sc;               //Result of creation calls.
    HGLOBAL         hMetaPict;        //OUT: METAFILEPICT containing iconic aspect.
                                      //IFF we couldn't stuff it in the cache.
    } OLEUIINSERTOBJECT, *POLEUIINSERTOBJECT, FAR *LPOLEUIINSERTOBJECT;

//API prototype
STDAPI_(UINT) OleUIInsertObject(LPOLEUIINSERTOBJECT);


//Insert Object flags
#define IOF_SHOWHELP                0x00000001L
#define IOF_SELECTCREATENEW         0x00000002L
#define IOF_SELECTCREATEFROMFILE    0x00000004L
#define IOF_CHECKLINK               0x00000008L
#define IOF_CHECKDISPLAYASICON      0x00000010L
#define IOF_CREATENEWOBJECT         0x00000020L
#define IOF_CREATEFILEOBJECT        0x00000040L
#define IOF_CREATELINKOBJECT        0x00000080L
#define IOF_DISABLELINK             0x00000100L
#define IOF_VERIFYSERVERSEXIST      0x00000200L


//Insert Object specific error codes
#define OLEUI_IOERR_LPSZFILEINVALID         (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_IOERR_LPSZLABELINVALID        (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_IOERR_HICONINVALID            (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_IOERR_LPFORMATETCINVALID      (OLEUI_ERR_STANDARDMAX+3)
#define OLEUI_IOERR_PPVOBJINVALID           (OLEUI_ERR_STANDARDMAX+4)
#define OLEUI_IOERR_LPIOLECLIENTSITEINVALID (OLEUI_ERR_STANDARDMAX+5)
#define OLEUI_IOERR_LPISTORAGEINVALID       (OLEUI_ERR_STANDARDMAX+6)
#define OLEUI_IOERR_SCODEHASERROR           (OLEUI_ERR_STANDARDMAX+7)
#define OLEUI_IOERR_LPCLSIDEXCLUDEINVALID   (OLEUI_ERR_STANDARDMAX+8)
#define OLEUI_IOERR_CCHFILEINVALID          (OLEUI_ERR_STANDARDMAX+9)


//Insert Object Dialog identifiers
#define ID_IO_CREATENEW                 2100
#define ID_IO_CREATEFROMFILE            2101
#define ID_IO_LINKFILE                  2102
#define ID_IO_OBJECTTYPELIST            2103
#define ID_IO_DISPLAYASICON             2104
#define ID_IO_CHANGEICON                2105
#define ID_IO_FILE                      2106
#define ID_IO_FILEDISPLAY               2107
#define ID_IO_RESULTIMAGE               2108
#define ID_IO_RESULTTEXT                2109
#define ID_IO_ICONDISPLAY               2110
#define ID_IO_OBJECTTYPETEXT            2111
#define ID_IO_FILETEXT                  2112
#define ID_IO_FILETYPE                  2113
                                        
// Strings in OLE2UI resources
#define IDS_IORESULTNEW                 256
#define IDS_IORESULTNEWICON             257
#define IDS_IORESULTFROMFILE1           258
#define IDS_IORESULTFROMFILE2           259
#define IDS_IORESULTFROMFILEICON2       260
#define IDS_IORESULTLINKFILE1           261     
#define IDS_IORESULTLINKFILE2           262
#define IDS_IORESULTLINKFILEICON1       263 
#define IDS_IORESULTLINKFILEICON2       264

/*************************************************************************
** PASTE SPECIAL DIALOG
*************************************************************************/

// Maximum number of link types
#define     PS_MAXLINKTYPES  8

//NOTE: OLEUIPASTEENTRY and OLEUIPASTEFLAG structs are defined in OLESTD.H

typedef struct tagOLEUIPASTESPECIAL
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;       //Structure Size
    DWORD           dwFlags;        //IN-OUT:  Flags
    HWND            hWndOwner;      //Owning window
    LPCSTR          lpszCaption;    //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;       //Hook callback
    LPARAM          lCustData;      //Custom data to pass to hook
    HINSTANCE       hInstance;      //Instance for customized template name
    LPCSTR          lpszTemplate;   //Customized template name
    HRSRC           hResource;      //Customized template handle

    //Specifics for OLEUIPASTESPECIAL.

    //IN  fields
    LPDATAOBJECT    lpSrcDataObj;       //Source IDataObject* (on the clipboard) for data to paste

    LPOLEUIPASTEENTRY arrPasteEntries;  //OLEUIPASTEENTRY array which specifies acceptable formats. See
                                        //  OLEUIPASTEENTRY for more information.
    int             cPasteEntries;      //Number of OLEUIPASTEENTRY array entries

    UINT        FAR *arrLinkTypes;      //List of link types that are acceptable. Link types are referred
                                        //  to using OLEUIPASTEFLAGS in arrPasteEntries
    int             cLinkTypes;         //Number of link types

    //OUT fields
    int             nSelectedIndex;    //Index of arrPasteEntries[] that the user selected
    BOOL            fLink;             //Indicates if Paste or Paste Link was selected by the user
    HGLOBAL         hMetaPict;         //Handle to Metafile containing icon and icon title selected by the user
                                       //  Use the Metafile utility functions defined in this header to
                                       //  manipulate hMetaPict
    } OLEUIPASTESPECIAL, *POLEUIPASTESPECIAL, FAR *LPOLEUIPASTESPECIAL;


//API to bring up PasteSpecial dialog
STDAPI_(UINT) OleUIPasteSpecial(LPOLEUIPASTESPECIAL);


//Paste Special flags
// Show Help button. IN flag.
#define PSF_SHOWHELP                0x00000001L
// Select Paste radio button at dialog startup. This is the default if PSF_SELECTPASTE or PSF_SELECTPASTELINK
// are not specified. Also specifies state of button on dialog termination. IN/OUT flag.
#define PSF_SELECTPASTE             0x00000002L
// Select PasteLink radio button at dialog startup. Also specifies state of button on dialog termination.
// IN/OUT flag.
#define PSF_SELECTPASTELINK         0x00000004L
// Specfies if DisplayAsIcon button was checked on dialog termination. OUT flag.
#define PSF_CHECKDISPLAYASICON      0x00000008L


//Paste Special specific error codes
#define OLEUI_IOERR_SRCDATAOBJECTINVALID      (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_IOERR_ARRPASTEENTRIESINVALID    (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_IOERR_ARRLINKTYPESINVALID       (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_PSERR_CLIPBOARDCHANGED          (OLEUI_ERR_STANDARDMAX+3)

//Paste Special Dialog identifiers
#define ID_PS_PASTE                    500
#define ID_PS_PASTELINK                501
#define ID_PS_SOURCETEXT               502
#define ID_PS_PASTELIST                503
#define ID_PS_PASTELINKLIST            504
#define ID_PS_DISPLAYLIST              505
#define ID_PS_DISPLAYASICON            506
#define ID_PS_ICONDISPLAY              507
#define ID_PS_CHANGEICON               508
#define ID_PS_RESULTIMAGE              509
#define ID_PS_RESULTTEXT               510
#define ID_PS_RESULTGROUP              511
#define ID_PS_STXSOURCE                512
#define ID_PS_STXAS                    513

// Paste Special String IDs
#define IDS_PSPASTEDATA                400
#define IDS_PSPASTEOBJECT              401
#define IDS_PSPASTEOBJECTASICON        402
#define IDS_PSPASTELINKDATA            403
#define IDS_PSPASTELINKOBJECT          404
#define IDS_PSPASTELINKOBJECTASICON    405
#define IDS_PSNONOLE                   406
#define IDS_PSUNKNOWNTYPE              407
#define IDS_PSUNKNOWNSRC               408
#define IDS_PSUNKNOWNAPP               409


/*************************************************************************
** EDIT LINKS DIALOG
*************************************************************************/



/* IOleUILinkContainer Interface
** -----------------------------
**    This interface must be implemented by container applications that
**    want to use the EditLinks dialog. the EditLinks dialog calls back
**    to the container app to perform the OLE functions to manipulate
**    the links within the container.
*/

#define LPOLEUILINKCONTAINER     IOleUILinkContainer FAR*

#undef  INTERFACE
#define INTERFACE   IOleUILinkContainer

DECLARE_INTERFACE_(IOleUILinkContainer, IUnknown)
{
    //*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD_(DWORD,GetNextLink) (THIS_ DWORD dwLink) PURE;
    STDMETHOD(SetLinkUpdateOptions) (THIS_ DWORD dwLink, DWORD dwUpdateOpt) PURE;
    STDMETHOD(GetLinkUpdateOptions) (THIS_ DWORD dwLink, DWORD FAR* lpdwUpdateOpt) PURE;
    STDMETHOD(SetLinkSource) (THIS_
            DWORD       dwLink,
            LPSTR       lpszDisplayName,
            ULONG       lenFileName,
            ULONG FAR*  pchEaten,
            BOOL        fValidateSource) PURE;
    STDMETHOD(GetLinkSource) (THIS_
            DWORD       dwLink,
            LPSTR FAR*  lplpszDisplayName,
            ULONG FAR*  lplenFileName,
            LPSTR FAR*  lplpszFullLinkType,
            LPSTR FAR*  lplpszShortLinkType,
            BOOL FAR*   lpfSourceAvailable,
            BOOL FAR*   lpfIsSelected) PURE;
    STDMETHOD(OpenLinkSource) (THIS_ DWORD dwLink) PURE;
    STDMETHOD(UpdateLink) (THIS_ 
            DWORD dwLink, 
            BOOL fErrorMessage,
            BOOL fErrorAction) PURE;
    STDMETHOD(CancelLink) (THIS_ DWORD dwLink) PURE;
};


typedef struct tagOLEUIEDITLINKS
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;       //Structure Size
    DWORD           dwFlags;        //IN-OUT:  Flags
    HWND            hWndOwner;      //Owning window
    LPCSTR          lpszCaption;    //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;       //Hook callback
    LPARAM          lCustData;      //Custom data to pass to hook
    HINSTANCE       hInstance;      //Instance for customized template name
    LPCSTR          lpszTemplate;   //Customized template name
    HRSRC           hResource;      //Customized template handle

    //Specifics for OLEUI<STRUCT>.  All are IN-OUT unless otherwise spec.

    LPOLEUILINKCONTAINER lpOleUILinkContainer;  //IN: Interface to manipulate
                                                //links in the container
    } OLEUIEDITLINKS, *POLEUIEDITLINKS, FAR *LPOLEUIEDITLINKS;


//API Prototype
STDAPI_(UINT) OleUIEditLinks(LPOLEUIEDITLINKS);


// Edit Links flags
#define ELF_SHOWHELP                0x00000001L

// Edit Links Dialog identifiers
#define ID_EL_CHANGESOURCE             201
#define ID_EL_AUTOMATIC                202
#define ID_EL_CLOSE                    208
#define ID_EL_CANCELLINK               209
#define ID_EL_UPDATENOW                210
#define ID_EL_OPENSOURCE               211
#define ID_EL_MANUAL                   212
#define ID_EL_LINKSOURCE               216
#define ID_EL_LINKTYPE                 217
#define ID_EL_UPDATE                   218
#define ID_EL_NULL                     -1
#define ID_EL_LINKSLISTBOX             206
#define ID_EL_HELP                     207
#define ID_EL_COL1                     223
#define ID_EL_COL2                     221
#define ID_EL_COL3                     222



/*************************************************************************
** CHANGE ICON DIALOG
*************************************************************************/

typedef struct tagOLEUICHANGEICON
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;       //Structure Size
    DWORD           dwFlags;        //IN-OUT:  Flags
    HWND            hWndOwner;      //Owning window
    LPCSTR          lpszCaption;    //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;       //Hook callback
    LPARAM          lCustData;      //Custom data to pass to hook
    HINSTANCE       hInstance;      //Instance for customized template name
    LPCSTR          lpszTemplate;   //Customized template name
    HRSRC           hResource;      //Customized template handle

    //Specifics for OLEUICHANGEICON.  All are IN-OUT unless otherwise spec.
    HGLOBAL         hMetaPict;      //Current and final image.  Source of the
                                    //icon is embedded in the metafile itself.
    CLSID           clsid;          //IN only: class used to get Default icon
    char            szIconExe[OLEUI_CCHPATHMAX];
    int             cchIconExe;
    } OLEUICHANGEICON, *POLEUICHANGEICON, FAR *LPOLEUICHANGEICON;


//API prototype
STDAPI_(UINT) OleUIChangeIcon(LPOLEUICHANGEICON);


//Change Icon flags
#define CIF_SHOWHELP                0x00000001L
#define CIF_SELECTCURRENT           0x00000002L
#define CIF_SELECTDEFAULT           0x00000004L
#define CIF_SELECTFROMFILE          0x00000008L
#define CIF_USEICONEXE              0x0000000aL


//Change Icon specific error codes
#define OLEUI_CIERR_MUSTHAVECLSID           (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_CIERR_MUSTHAVECURRENTMETAFILE (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_CIERR_SZICONEXEINVALID        (OLEUI_ERR_STANDARDMAX+2)


//Change Icon Dialog identifiers
#define ID_GROUP                    120
#define ID_CURRENT                  121
#define ID_CURRENTICON              122
#define ID_DEFAULT                  123
#define ID_DEFAULTICON              124
#define ID_FROMFILE                 125
#define ID_FROMFILEEDIT             126
#define ID_ICONLIST                 127
#define ID_LABEL                    128
#define ID_LABELEDIT                129
#define ID_BROWSE                   130
#define ID_RESULTICON               132
#define ID_RESULTLABEL              133

// Stringtable defines for Change Icon
#define IDS_CINOICONSINFILE         288
#define IDS_CIINVALIDFILE           289
#define IDS_CIFILEACCESS            290
#define IDS_CIFILESHARE             291
#define IDS_CIFILEOPENFAIL          292



/*************************************************************************
** CONVERT DIALOG
*************************************************************************/

typedef struct tagOLEUICONVERT
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;         //Structure Size
    DWORD           dwFlags;          //IN-OUT:  Flags
    HWND            hWndOwner;        //Owning window
    LPCSTR          lpszCaption;      //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;         //Hook callback
    LPARAM          lCustData;        //Custom data to pass to hook
    HINSTANCE       hInstance;        //Instance for customized template name
    LPCSTR          lpszTemplate;     //Customized template name
    HRSRC           hResource;        //Customized template handle

    //Specifics for OLEUICONVERT.  All are IN-OUT unless otherwise spec.
    CLSID           clsid;            //Class ID sent in to dialog: IN only
    CLSID           clsidConvertDefault;  //Class ID to use as convert default: IN only
    CLSID           clsidActivateDefault;  //Class ID to use as activate default: IN only

    CLSID           clsidNew;         //Selected Class ID: OUT only
    DWORD           dvAspect;         //IN-OUT, either DVASPECT_CONTENT or
                                      //DVASPECT_ICON
    WORD            wFormat;          //Original data format
    BOOL            fIsLinkedObject;  //IN only; true if object is linked
    HGLOBAL         hMetaPict;        //IN-OUT: METAFILEPICT containing iconic aspect.
    LPSTR           lpszUserType;     //IN: user type name of original class. We'll do lookup if it's NULL.
                                      //This gets freed on exit.
    BOOL            fObjectsIconChanged;  // OUT; TRUE if ChangeIcon was called (and not cancelled)

    } OLEUICONVERT, *POLEUICONVERT, FAR *LPOLEUICONVERT;


//API prototype
STDAPI_(UINT) OleUIConvert(LPOLEUICONVERT);

//Convert Dialog flags

// IN only: Shows "HELP" button
#define CF_SHOWHELPBUTTON          0x00000001L

// IN only: lets you set the convert default object - the one that is
// selected as default in the convert listbox.
#define CF_SETCONVERTDEFAULT       0x00000002L


// IN only: lets you set the activate default object - the one that is
// selected as default in the activate listbox.

#define CF_SETACTIVATEDEFAULT       0x00000004L


// IN/OUT: Selects the "Convert To" radio button, is set on exit if
// this button was selected
#define CF_SELECTCONVERTTO         0x00000008L

// IN/OUT: Selects the "Activate As" radio button, is set on exit if
// this button was selected
#define CF_SELECTACTIVATEAS        0x00000010L


//Convert specific error codes
#define OLEUI_CTERR_CLASSIDINVALID      (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_CTERR_DVASPECTINVALID     (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_CTERR_CBFORMATINVALID     (OLEUI_ERR_STANDARDMAX+3)
#define OLEUI_CTERR_HMETAPICTINVALID    (OLEUI_ERR_STANDARDMAX+4)
#define OLEUI_CTERR_STRINGINVALID       (OLEUI_ERR_STANDARDMAX+5)


//Convert Dialog identifiers
#define IDCV_OBJECTTYPE             150
#define IDCV_HELP                   151
#define IDCV_DISPLAYASICON          152
#define IDCV_CHANGEICON             153
#define IDCV_ACTIVATELIST           154
#define IDCV_CONVERTTO              155
#define IDCV_ACTIVATEAS             156
#define IDCV_RESULTTEXT             157
#define IDCV_CONVERTLIST            158
#define IDCV_ICON                   159
#define IDCV_ICONLABEL1             160
#define IDCV_ICONLABEL2             161
#define IDCV_STXCURTYPE             162
#define IDCV_GRPRESULT              163
#define IDCV_STXCONVERTTO           164

// String IDs for Convert dialog
#define IDS_CVRESULTCONVERTLINK     500
#define IDS_CVRESULTCONVERTTO       501
#define IDS_CVRESULTNOCHANGE        502
#define IDS_CVRESULTDISPLAYASICON   503
#define IDS_CVRESULTACTIVATEAS      504
#define IDS_CVRESULTACTIVATEDIFF    505


/*************************************************************************
** BUSY DIALOG
*************************************************************************/

typedef struct tagOLEUIBUSY
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;         //Structure Size
    DWORD           dwFlags;          //IN-OUT:  Flags ** NOTE ** this dialog has no flags
    HWND            hWndOwner;        //Owning window
    LPCSTR          lpszCaption;      //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;         //Hook callback
    LPARAM          lCustData;        //Custom data to pass to hook
    HINSTANCE       hInstance;        //Instance for customized template name
    LPCSTR          lpszTemplate;     //Customized template name
    HRSRC           hResource;        //Customized template handle

    //Specifics for OLEUIBUSY.
    HTASK           hTask;            //IN: HTask which is blocking
    HWND FAR *      lphWndDialog;     //IN: Dialog's HWND is placed here
    } OLEUIBUSY, *POLEUIBUSY, FAR *LPOLEUIBUSY;

//API prototype
STDAPI_(UINT) OleUIBusy(LPOLEUIBUSY);

// Flags for this dialog

// IN only: Disables "Cancel" button
#define BZ_DISABLECANCELBUTTON          0x00000001L

// IN only: Disables "Switch To..." button
#define BZ_DISABLESWITCHTOBUTTON        0x00000002L

// IN only: Disables "Retry" button
#define BZ_DISABLERETRYBUTTON           0x00000004L

// IN only: Generates a "Not Responding" dialog as opposed to the
// "Busy" dialog.  The wording in the text is slightly different, and
// the "Cancel" button is grayed out if you set this flag.
#define BZ_NOTRESPONDINGDIALOG          0x00000008L

// Busy specific error/return codes
#define OLEUI_BZERR_HTASKINVALID     (OLEUI_ERR_STANDARDMAX+0)

// SWITCHTOSELECTED is returned when user hit "switch to"
#define OLEUI_BZ_SWITCHTOSELECTED    (OLEUI_ERR_STANDARDMAX+1)

// RETRYSELECTED is returned when user hit "retry"
#define OLEUI_BZ_RETRYSELECTED       (OLEUI_ERR_STANDARDMAX+2)

// CALLUNBLOCKED is returned when call has been unblocked
#define OLEUI_BZ_CALLUNBLOCKED       (OLEUI_ERR_STANDARDMAX+3)

// Busy dialog identifiers
#define IDBZ_RETRY                      600
#define IDBZ_ICON                       601
#define IDBZ_MESSAGE1                   602
#define IDBZ_SWITCHTO                   604

// Busy dialog stringtable defines
#define IDS_BZRESULTTEXTBUSY            601
#define IDS_BZRESULTTEXTNOTRESPONDING   602

// Links dialog stringtable defines
#define IDS_LINK_AUTO           800
#define IDS_LINK_MANUAL         801
#define IDS_LINK_UNKNOWN        802
#define IDS_LINKS               803
#define IDS_FAILED              804
#define IDS_CHANGESOURCE        805
#define IDS_INVALIDSOURCE       806
#define IDS_ERR_GETLINKSOURCE   807
#define IDS_ERR_GETLINKUPDATEOPTIONS    808
#define IDS_ERR_ADDSTRING       809
#define IDS_CHANGEADDITIONALLINKS   810


/*************************************************************************
** PROMPT USER DIALOGS
*************************************************************************/
#define ID_PU_LINKS             900
#define ID_PU_TEXT              901
#define ID_PU_CONVERT           902
#define ID_PU_HELP              903
#define ID_PU_BROWSE            904
#define ID_PU_METER             905
#define ID_PU_PERCENT           906
#define ID_PU_STOP              907

// used for -1 ids in dialogs:
#define ID_DUMMY    999

/* inside ole2ui.c */
#ifdef __cplusplus
extern "C" 
#endif
int __export FAR CDECL OleUIPromptUser(int nTemplate, HWND hwndParent, ...);
STDAPI_(BOOL) OleUIUpdateLinks(
        LPOLEUILINKCONTAINER lpOleUILinkCntr, 
        HWND hwndParent, 
        LPSTR lpszTitle, 
        int cLinks);


/*************************************************************************
** OLE OBJECT FEEDBACK EFFECTS
*************************************************************************/

#define OLEUI_HANDLES_USEINVERSE    0x00000001L
#define OLEUI_HANDLES_NOBORDER      0x00000002L
#define OLEUI_HANDLES_INSIDE        0x00000004L
#define OLEUI_HANDLES_OUTSIDE       0x00000008L


/* objfdbk.c function prototypes */
STDAPI_(void) OleUIDrawHandles(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cSize, BOOL fDraw);
STDAPI_(void) OleUIDrawShading(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cWidth);
STDAPI_(void) OleUIShowObject(LPCRECT lprc, HDC hdc, BOOL fIsLink);


/*************************************************************************
** Hatch window definitions and prototypes                              **
*************************************************************************/
#define DEFAULT_HATCHBORDER_WIDTH   4

STDAPI_(BOOL) RegisterHatchWindowClass(HINSTANCE hInst);
STDAPI_(HWND) CreateHatchWindow(HWND hWndParent, HINSTANCE hInst);
STDAPI_(UINT) GetHatchWidth(HWND hWndHatch);
STDAPI_(void) GetHatchRect(HWND hWndHatch, LPRECT lpHatchRect);
STDAPI_(void) SetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect);
STDAPI_(void) SetHatchWindowSize(
        HWND        hWndHatch,
        LPRECT      lprcIPObjRect,
        LPRECT      lprcClipRect,
        LPPOINT     lpptOffset
);



/*************************************************************************
** VERSION VERIFICATION INFORMATION
*************************************************************************/

// The following magic number is used to verify that the resources we bind
// to our EXE are the same "version" as the LIB (or DLL) file which
// contains these routines.  This is not the same as the Version information
// resource that we place in OLE2UI.RC, this is a special ID that we will
// have compiled in to our EXE.  Upon initialization of OLE2UI, we will
// look in our resources for an RCDATA called "VERIFICATION" (see OLE2UI.RC),
// and make sure that the magic number there equals the magic number below.

#define OLEUI_VERSION_MAGIC 0x4D42

#endif  //_OLE2UI_H_
/*****************************************************************************\
*                                                                             *
* dlgs.h -      Common dialog's dialog element ID numbers                     *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_DLGS
#define _INC_DLGS

#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

#endif  /* !_INC_DLGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\ole2ui\ole2ui.h ===
/*
 * OLE2UI.H
 *
 * Published definitions, structures, types, and function prototypes for the
 * OLE 2.0 User Interface support library.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 */

/* NOTE: All dialog and string resource ID's defined in this file are
 *    in the range:
 *          32248 - 32504   (0x7DF8 - 0x7EF8)
*/


#ifndef _OLE2UI_H_
#define _OLE2UI_H_

#ifndef RC_INVOKED
#pragma message ("Including OLE2UI.H from " __FILE__)
#endif  //RC_INVOKED

#ifdef WIN32
#define _INC_OLE
#define __RPC_H__
#endif

#if !defined(__cplusplus) && !defined( __TURBOC__)
#define NONAMELESSUNION     // use strict ANSI standard (for DVOBJ.H)
#endif

#include <windows.h>
#include <shellapi.h>
#include <ole2.h>
#include <string.h>
#include <dlgs.h>           //For fileopen dlg; standard include
#include "olestd.h"

#ifdef __TURBOC__
#define _getcwd getcwd
#define _itoa   itoa
#define __max   max
#define _find_t find_t
#endif // __TURBOC__

#ifdef WIN32
#define _fmemset memset
#define _fmemcpy memcpy
#define _fmemcmp memcmp
#define _fstrcpy strcpy
#define _fstrlen strlen
#define _fstrrchr strrchr
#define _fstrtok strtok
#define lstrcpyn strncpy

// BUGBUG32: isspace function does not seem to work properly
#undef isspace
#define isspace(j) (j==' ' || j=='\t' || j=='\n')
#endif  // WIN32

#if !defined( EXPORT )
#ifdef WIN32
#define EXPORT
#else
#define EXPORT  __export
#endif  // WIN32
#endif  // !EXPORT

/*
 * Initialization / Uninitialization routines.  OleUIInitialize
 * must be called prior to using any functions in OLE2UI, and OleUIUnInitialize
 * must be called before you app shuts down and when you are done using the
 * library.
 *
 * NOTE:  If you are using the DLL version of this library, these functions
 * are automatically called in the DLL's LibMain and WEP, so you should
 * not call them directly from your application.
 */

// Backward compatibility with older library
#define OleUIUninitialize OleUIUnInitialize

STDAPI_(BOOL) OleUIInitialize(HINSTANCE hInstance, HINSTANCE hPrevInst);
STDAPI_(BOOL) OleUIUninitialize(void);

#if !defined( SZCLASSICONBOX )
#define SZCLASSICONBOX  "ole2uiIBCls"
#endif

#if !defined( SZCLASSRESULTIMAGE )
#define SZCLASSRESULTIMAGE  "ole2uiRICls"
#endif

// object count, used to support DllCanUnloadNow and OleUICanUnloadNow
extern DWORD g_dwObjectCount;

STDAPI OleUICanUnloadNow(void);
STDAPI OleUILockLibrary(BOOL fLock);


//Dialog Identifiers as passed in Help messages to identify the source.
#define IDD_INSERTOBJECT        32248
#define IDD_CHANGEICON          32249
#define IDD_CONVERT             32250
#define IDD_PASTESPECIAL        32251
#define IDD_EDITLINKS           32252
#define IDD_FILEOPEN            32253
#define IDD_BUSY                32254
#define IDD_UPDATELINKS         32255
#define IDD_CANNOTUPDATELINK    32256
#define IDD_CHANGESOURCE        32257
#define IDD_INSERTFILEBROWSE    32258
#define IDD_CHANGEICONBROWSE    32259

// The following Dialogs are message dialogs used by OleUIPromptUser API
#define IDD_LINKSOURCEUNAVAILABLE   32260
#define IDD_SERVERNOTREG        32261
#define IDD_LINKTYPECHANGED     32262
#define IDD_SERVERNOTFOUND      32263
#define IDD_OUTOFMEMORY         32264

// Stringtable identifers
#define IDS_OLE2UIUNKNOWN       32300
#define IDS_OLE2UILINK          32301
#define IDS_OLE2UIOBJECT        32302
#define IDS_OLE2UIEDIT          32303
#define IDS_OLE2UICONVERT       32304
#define IDS_OLE2UIEDITLINKCMD_1VERB     32305
#define IDS_OLE2UIEDITOBJECTCMD_1VERB   32306
#define IDS_OLE2UIEDITLINKCMD_NVERB     32307
#define IDS_OLE2UIEDITOBJECTCMD_NVERB   32308
#define IDS_OLE2UIEDITNOOBJCMD  32309
// def. icon label (usu. "Document")
#define IDS_DEFICONLABEL        32310
#define IDS_OLE2UIPASTELINKEDTYPE  32311


#define IDS_FILTERS             32320
#define IDS_ICONFILTERS         32321
#define IDS_BROWSE              32322

//Resource identifiers for bitmaps
#define IDB_RESULTSEGA                  32325
#define IDB_RESULTSVGA                  32326
#define IDB_RESULTSHIRESVGA             32327


//Missing from windows.h
#ifndef PVOID
typedef VOID *PVOID;
#endif


//Hook type used in all structures.
typedef UINT (CALLBACK *LPFNOLEUIHOOK)(HWND, UINT, WPARAM, LPARAM);


//Strings for registered messages
#define SZOLEUI_MSG_HELP                "OLEUI_MSG_HELP"
#define SZOLEUI_MSG_ENDDIALOG           "OLEUI_MSG_ENDDIALOG"
#define SZOLEUI_MSG_BROWSE              "OLEUI_MSG_BROWSE"
#define SZOLEUI_MSG_CHANGEICON          "OLEUI_MSG_CHANGEICON"
#define SZOLEUI_MSG_CLOSEBUSYDIALOG     "OLEUI_MSG_CLOSEBUSYDIALOG"
#define SZOLEUI_MSG_FILEOKSTRING        "OLEUI_MSG_FILEOKSTRING"

//Standard error definitions
#define OLEUI_FALSE                     0
#define OLEUI_SUCCESS                   1     //No error, same as OLEUI_OK
#define OLEUI_OK                        1     //OK button pressed
#define OLEUI_CANCEL                    2     //Cancel button pressed

#define OLEUI_ERR_STANDARDMIN           100
#define OLEUI_ERR_STRUCTURENULL         101   //Standard field validation
#define OLEUI_ERR_STRUCTUREINVALID      102
#define OLEUI_ERR_CBSTRUCTINCORRECT     103
#define OLEUI_ERR_HWNDOWNERINVALID      104
#define OLEUI_ERR_LPSZCAPTIONINVALID    105
#define OLEUI_ERR_LPFNHOOKINVALID       106
#define OLEUI_ERR_HINSTANCEINVALID      107
#define OLEUI_ERR_LPSZTEMPLATEINVALID   108
#define OLEUI_ERR_HRESOURCEINVALID      109

#define OLEUI_ERR_FINDTEMPLATEFAILURE   110   //Initialization errors
#define OLEUI_ERR_LOADTEMPLATEFAILURE   111
#define OLEUI_ERR_DIALOGFAILURE         112
#define OLEUI_ERR_LOCALMEMALLOC         113
#define OLEUI_ERR_GLOBALMEMALLOC        114
#define OLEUI_ERR_LOADSTRING            115

#define OLEUI_ERR_STANDARDMAX           116   //Start here for specific errors.



//Help Button Identifier
#define ID_OLEUIHELP                    99

// Help button for fileopen.dlg  (need this for resizing) 1038 is pshHelp
#define IDHELP  1038

// Static text control (use this instead of -1 so things work correctly for
// localization
#define  ID_STATIC                      98

//Maximum key size we read from the RegDB.
#define OLEUI_CCHKEYMAX                 256  // make any changes to this in geticon.c too

//Maximum verb length and length of Object menu
#define OLEUI_CCHVERBMAX                32
#define OLEUI_OBJECTMENUMAX             256

//Maximum MS-DOS pathname.
#define OLEUI_CCHPATHMAX                256 // make any changes to this in geticon.c too
#define OLEUI_CCHFILEMAX                13

//Icon label length
#define OLEUI_CCHLABELMAX               40  // make any changes to this in geticon.c too

//Length of the CLSID string
#define OLEUI_CCHCLSIDSTRING            39


/*
 * What follows here are first function prototypes for general utility
 * functions, then sections laid out by dialog.  Each dialog section
 * defines the dialog structure, the API prototype, flags for the dwFlags
 * field, the dialog-specific error values, and dialog control IDs (for
 * hooks and custom templates.
 */


//Miscellaneous utility functions.
STDAPI_(BOOL) OleUIAddVerbMenu(LPOLEOBJECT lpOleObj,
							 LPSTR lpszShortType,
							 HMENU hMenu,
							 UINT uPos,
							 UINT uIDVerbMin,
							 UINT uIDVerbMax,
							 BOOL bAddConvert,
							 UINT idConvert,
							 HMENU FAR *lphMenu);

//Metafile utility functions
STDAPI_(HGLOBAL) OleUIMetafilePictFromIconAndLabel(HICON, LPSTR, LPSTR, UINT);
STDAPI_(void)    OleUIMetafilePictIconFree(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictIconDraw(HDC, LPRECT, HGLOBAL, BOOL);
STDAPI_(UINT)    OleUIMetafilePictExtractLabel(HGLOBAL, LPSTR, UINT, LPDWORD);
STDAPI_(HICON)   OleUIMetafilePictExtractIcon(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictExtractIconSource(HGLOBAL,LPSTR,UINT FAR *);





/*************************************************************************
** INSERT OBJECT DIALOG
*************************************************************************/


typedef struct tagOLEUIINSERTOBJECT
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;         //Structure Size
	DWORD           dwFlags;          //IN-OUT:  Flags
	HWND            hWndOwner;        //Owning window
	LPCSTR          lpszCaption;      //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;         //Hook callback
	LPARAM          lCustData;        //Custom data to pass to hook
	HINSTANCE       hInstance;        //Instance for customized template name
	LPCSTR          lpszTemplate;     //Customized template name
	HRSRC           hResource;        //Customized template handle

	//Specifics for OLEUIINSERTOBJECT.  All are IN-OUT unless otherwise spec.
	CLSID           clsid;            //Return space for class ID
	LPSTR           lpszFile;         //Filename for inserts or links
	UINT            cchFile;          //Size of lpszFile buffer: OLEUI_CCHPATHMAX
	UINT            cClsidExclude;    //IN only:  CLSIDs in lpClsidExclude
	LPCLSID         lpClsidExclude;   //List of CLSIDs to exclude from listing.

	//Specific to create objects if flags say so
	IID             iid;              //Requested interface on creation.
	DWORD           oleRender;        //Rendering option
	LPFORMATETC     lpFormatEtc;      //Desired format
	LPOLECLIENTSITE lpIOleClientSite; //Site to be use for the object.
	LPSTORAGE       lpIStorage;       //Storage used for the object
	LPVOID FAR     *ppvObj;           //Where the object is returned.
	SCODE           sc;               //Result of creation calls.
	HGLOBAL         hMetaPict;        //OUT: METAFILEPICT containing iconic aspect.
									  //IFF we couldn't stuff it in the cache.
	} OLEUIINSERTOBJECT, *POLEUIINSERTOBJECT, FAR *LPOLEUIINSERTOBJECT;

//API prototype
STDAPI_(UINT) OleUIInsertObject(LPOLEUIINSERTOBJECT);


//Insert Object flags
#define IOF_SHOWHELP                0x00000001L
#define IOF_SELECTCREATENEW         0x00000002L
#define IOF_SELECTCREATEFROMFILE    0x00000004L
#define IOF_CHECKLINK               0x00000008L
#define IOF_CHECKDISPLAYASICON      0x00000010L
#define IOF_CREATENEWOBJECT         0x00000020L
#define IOF_CREATEFILEOBJECT        0x00000040L
#define IOF_CREATELINKOBJECT        0x00000080L
#define IOF_DISABLELINK             0x00000100L
#define IOF_VERIFYSERVERSEXIST      0x00000200L
#define IOF_DISABLEDISPLAYASICON    0x00000400L


//Insert Object specific error codes
#define OLEUI_IOERR_LPSZFILEINVALID         (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_IOERR_LPSZLABELINVALID        (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_IOERR_HICONINVALID            (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_IOERR_LPFORMATETCINVALID      (OLEUI_ERR_STANDARDMAX+3)
#define OLEUI_IOERR_PPVOBJINVALID           (OLEUI_ERR_STANDARDMAX+4)
#define OLEUI_IOERR_LPIOLECLIENTSITEINVALID (OLEUI_ERR_STANDARDMAX+5)
#define OLEUI_IOERR_LPISTORAGEINVALID       (OLEUI_ERR_STANDARDMAX+6)
#define OLEUI_IOERR_SCODEHASERROR           (OLEUI_ERR_STANDARDMAX+7)
#define OLEUI_IOERR_LPCLSIDEXCLUDEINVALID   (OLEUI_ERR_STANDARDMAX+8)
#define OLEUI_IOERR_CCHFILEINVALID          (OLEUI_ERR_STANDARDMAX+9)


//Insert Object Dialog identifiers
#define ID_IO_CREATENEW                 2100
#define ID_IO_CREATEFROMFILE            2101
#define ID_IO_LINKFILE                  2102
#define ID_IO_OBJECTTYPELIST            2103
#define ID_IO_DISPLAYASICON             2104
#define ID_IO_CHANGEICON                2105
#define ID_IO_FILE                      2106
#define ID_IO_FILEDISPLAY               2107
#define ID_IO_RESULTIMAGE               2108
#define ID_IO_RESULTTEXT                2109
#define ID_IO_ICONDISPLAY               2110
#define ID_IO_OBJECTTYPETEXT            2111
#define ID_IO_FILETEXT                  2112
#define ID_IO_FILETYPE                  2113

// Strings in OLE2UI resources
#define IDS_IORESULTNEW                 32400
#define IDS_IORESULTNEWICON             32401
#define IDS_IORESULTFROMFILE1           32402
#define IDS_IORESULTFROMFILE2           32403
#define IDS_IORESULTFROMFILEICON2       32404
#define IDS_IORESULTLINKFILE1           32405
#define IDS_IORESULTLINKFILE2           32406
#define IDS_IORESULTLINKFILEICON1       32407
#define IDS_IORESULTLINKFILEICON2       32408

/*************************************************************************
** PASTE SPECIAL DIALOG
*************************************************************************/

// Maximum number of link types
#define     PS_MAXLINKTYPES  8

//NOTE: OLEUIPASTEENTRY and OLEUIPASTEFLAG structs are defined in OLESTD.H

typedef struct tagOLEUIPASTESPECIAL
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCSTR          lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCSTR          lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	//Specifics for OLEUIPASTESPECIAL.

	//IN  fields
	LPDATAOBJECT    lpSrcDataObj;       //Source IDataObject* (on the
										// clipboard) for data to paste

	LPOLEUIPASTEENTRY arrPasteEntries;  //OLEUIPASTEENTRY array which
										// specifies acceptable formats. See
										// OLEUIPASTEENTRY for more info.
	int             cPasteEntries;      //No. of OLEUIPASTEENTRY array entries

	UINT        FAR *arrLinkTypes;      //List of link types that are
										// acceptable. Link types are referred
										// to using OLEUIPASTEFLAGS in
										// arrPasteEntries
	int             cLinkTypes;         //Number of link types
	UINT            cClsidExclude;      //Number of CLSIDs in lpClsidExclude
	LPCLSID         lpClsidExclude;     //List of CLSIDs to exclude from list.

	//OUT fields
	int             nSelectedIndex;     //Index of arrPasteEntries[] that the
										// user selected
	BOOL            fLink;              //Indicates if Paste or Paste Link was
										// selected by the user
	HGLOBAL         hMetaPict;          //Handle to Metafile containing icon
										// and icon title selected by the user
										// Use the Metafile utility functions
										// defined in this header to
										// manipulate hMetaPict
	SIZEL           sizel;              // size of object/link in its source
										//  if the display aspect chosen by
										//  the user matches the aspect
										//  displayed in the source. if
										//  different aspect is chosen then
										//  sizel.cx=sizel.cy=0 is returned.
										//  sizel displayed in source is
										//  retrieved from the
										//  ObjectDescriptor if fLink is FALSE
										//  LinkSrcDescriptor if fLink is TRUE
	} OLEUIPASTESPECIAL, *POLEUIPASTESPECIAL, FAR *LPOLEUIPASTESPECIAL;


//API to bring up PasteSpecial dialog
STDAPI_(UINT) OleUIPasteSpecial(LPOLEUIPASTESPECIAL);


//Paste Special flags
// Show Help button. IN flag.
#define PSF_SHOWHELP                0x00000001L

//Select Paste radio button at dialog startup. This is the default if
// PSF_SELECTPASTE or PSF_SELECTPASTELINK are not specified. Also specifies
// state of button on dialog termination. IN/OUT flag.
#define PSF_SELECTPASTE             0x00000002L

//Select PasteLink radio button at dialog startup. Also specifies state of
// button on dialog termination. IN/OUT flag.
#define PSF_SELECTPASTELINK         0x00000004L

//Specfies if DisplayAsIcon button was checked on dialog termination. OUT flag
#define PSF_CHECKDISPLAYASICON      0x00000008L
#define PSF_DISABLEDISPLAYASICON    0x00000010L


//Paste Special specific error codes
#define OLEUI_IOERR_SRCDATAOBJECTINVALID      (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_IOERR_ARRPASTEENTRIESINVALID    (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_IOERR_ARRLINKTYPESINVALID       (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_PSERR_CLIPBOARDCHANGED          (OLEUI_ERR_STANDARDMAX+3)

//Paste Special Dialog identifiers
#define ID_PS_PASTE                    500
#define ID_PS_PASTELINK                501
#define ID_PS_SOURCETEXT               502
#define ID_PS_PASTELIST                503
#define ID_PS_PASTELINKLIST            504
#define ID_PS_DISPLAYLIST              505
#define ID_PS_DISPLAYASICON            506
#define ID_PS_ICONDISPLAY              507
#define ID_PS_CHANGEICON               508
#define ID_PS_RESULTIMAGE              509
#define ID_PS_RESULTTEXT               510
#define ID_PS_RESULTGROUP              511
#define ID_PS_STXSOURCE                512
#define ID_PS_STXAS                    513

// Paste Special String IDs
#define IDS_PSPASTEDATA                32410
#define IDS_PSPASTEOBJECT              32411
#define IDS_PSPASTEOBJECTASICON        32412
#define IDS_PSPASTELINKDATA            32413
#define IDS_PSPASTELINKOBJECT          32414
#define IDS_PSPASTELINKOBJECTASICON    32415
#define IDS_PSNONOLE                   32416
#define IDS_PSUNKNOWNTYPE              32417
#define IDS_PSUNKNOWNSRC               32418
#define IDS_PSUNKNOWNAPP               32419


/*************************************************************************
** EDIT LINKS DIALOG
*************************************************************************/



/* IOleUILinkContainer Interface
** -----------------------------
**    This interface must be implemented by container applications that
**    want to use the EditLinks dialog. the EditLinks dialog calls back
**    to the container app to perform the OLE functions to manipulate
**    the links within the container.
*/

#define LPOLEUILINKCONTAINER     IOleUILinkContainer FAR*

#undef  INTERFACE
#define INTERFACE   IOleUILinkContainer

DECLARE_INTERFACE_(IOleUILinkContainer, IUnknown)
{
	//*** IUnknown methods ***/
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD_(DWORD,GetNextLink) (THIS_ DWORD dwLink) PURE;
	STDMETHOD(SetLinkUpdateOptions) (THIS_ DWORD dwLink, DWORD dwUpdateOpt) PURE;
	STDMETHOD(GetLinkUpdateOptions) (THIS_ DWORD dwLink, DWORD FAR* lpdwUpdateOpt) PURE;
	STDMETHOD(SetLinkSource) (THIS_
			DWORD       dwLink,
			LPSTR       lpszDisplayName,
			ULONG       lenFileName,
			ULONG FAR*  pchEaten,
			BOOL        fValidateSource) PURE;
	STDMETHOD(GetLinkSource) (THIS_
			DWORD       dwLink,
			LPSTR FAR*  lplpszDisplayName,
			ULONG FAR*  lplenFileName,
			LPSTR FAR*  lplpszFullLinkType,
			LPSTR FAR*  lplpszShortLinkType,
			BOOL FAR*   lpfSourceAvailable,
			BOOL FAR*   lpfIsSelected) PURE;
	STDMETHOD(OpenLinkSource) (THIS_ DWORD dwLink) PURE;
	STDMETHOD(UpdateLink) (THIS_
			DWORD dwLink,
			BOOL fErrorMessage,
			BOOL fErrorAction) PURE;
	STDMETHOD(CancelLink) (THIS_ DWORD dwLink) PURE;
};


typedef struct tagOLEUIEDITLINKS
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCSTR          lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCSTR          lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	//Specifics for OLEUI<STRUCT>.  All are IN-OUT unless otherwise spec.

	LPOLEUILINKCONTAINER lpOleUILinkContainer;  //IN: Interface to manipulate
												//links in the container
	} OLEUIEDITLINKS, *POLEUIEDITLINKS, FAR *LPOLEUIEDITLINKS;


//API Prototype
STDAPI_(UINT) OleUIEditLinks(LPOLEUIEDITLINKS);


// Edit Links flags
#define ELF_SHOWHELP                0x00000001L
#define ELF_DISABLEUPDATENOW        0x00000002L
#define ELF_DISABLEOPENSOURCE       0x00000004L
#define ELF_DISABLECHANGESOURCE     0x00000008L
#define ELF_DISABLECANCELLINK       0x00000010L

// Edit Links Dialog identifiers
#define ID_EL_CHANGESOURCE             201
#define ID_EL_AUTOMATIC                202
#define ID_EL_CLOSE                    208
#define ID_EL_CANCELLINK               209
#define ID_EL_UPDATENOW                210
#define ID_EL_OPENSOURCE               211
#define ID_EL_MANUAL                   212
#define ID_EL_LINKSOURCE               216
#define ID_EL_LINKTYPE                 217
#define ID_EL_UPDATE                   218
#define ID_EL_NULL                     -1
#define ID_EL_LINKSLISTBOX             206
#define ID_EL_COL1                     220
#define ID_EL_COL2                     221
#define ID_EL_COL3                     222



/*************************************************************************
** CHANGE ICON DIALOG
*************************************************************************/

typedef struct tagOLEUICHANGEICON
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCSTR          lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCSTR          lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	//Specifics for OLEUICHANGEICON.  All are IN-OUT unless otherwise spec.
	HGLOBAL         hMetaPict;      //Current and final image.  Source of the
									//icon is embedded in the metafile itself.
	CLSID           clsid;          //IN only: class used to get Default icon
	char            szIconExe[OLEUI_CCHPATHMAX];
	int             cchIconExe;
	} OLEUICHANGEICON, *POLEUICHANGEICON, FAR *LPOLEUICHANGEICON;


//API prototype
STDAPI_(UINT) OleUIChangeIcon(LPOLEUICHANGEICON);


//Change Icon flags
#define CIF_SHOWHELP                0x00000001L
#define CIF_SELECTCURRENT           0x00000002L
#define CIF_SELECTDEFAULT           0x00000004L
#define CIF_SELECTFROMFILE          0x00000008L
#define CIF_USEICONEXE              0x0000000aL


//Change Icon specific error codes
#define OLEUI_CIERR_MUSTHAVECLSID           (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_CIERR_MUSTHAVECURRENTMETAFILE (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_CIERR_SZICONEXEINVALID        (OLEUI_ERR_STANDARDMAX+2)


//Change Icon Dialog identifiers
#define ID_GROUP                    120
#define ID_CURRENT                  121
#define ID_CURRENTICON              122
#define ID_DEFAULT                  123
#define ID_DEFAULTICON              124
#define ID_FROMFILE                 125
#define ID_FROMFILEEDIT             126
#define ID_ICONLIST                 127
#define ID_LABEL                    128
#define ID_LABELEDIT                129
#define ID_BROWSE                   130
#define ID_RESULTICON               132
#define ID_RESULTLABEL              133

// Stringtable defines for Change Icon
#define IDS_CINOICONSINFILE         32430
#define IDS_CIINVALIDFILE           32431
#define IDS_CIFILEACCESS            32432
#define IDS_CIFILESHARE             32433
#define IDS_CIFILEOPENFAIL          32434



/*************************************************************************
** CONVERT DIALOG
*************************************************************************/

typedef struct tagOLEUICONVERT
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;         //Structure Size
	DWORD           dwFlags;          //IN-OUT:  Flags
	HWND            hWndOwner;        //Owning window
	LPCSTR          lpszCaption;      //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;         //Hook callback
	LPARAM          lCustData;        //Custom data to pass to hook
	HINSTANCE       hInstance;        //Instance for customized template name
	LPCSTR          lpszTemplate;     //Customized template name
	HRSRC           hResource;        //Customized template handle

	//Specifics for OLEUICONVERT.  All are IN-OUT unless otherwise spec.
	CLSID           clsid;            //Class ID sent in to dialog: IN only
	CLSID           clsidConvertDefault;  //Class ID to use as convert default: IN only
	CLSID           clsidActivateDefault;  //Class ID to use as activate default: IN only

	CLSID           clsidNew;         //Selected Class ID: OUT only
	DWORD           dvAspect;         //IN-OUT, either DVASPECT_CONTENT or
									  //DVASPECT_ICON
	WORD            wFormat;          //Original data format
	BOOL            fIsLinkedObject;  //IN only; true if object is linked
	HGLOBAL         hMetaPict;        //IN-OUT: METAFILEPICT containing iconic aspect.
	LPSTR           lpszUserType;     //IN-OUT: user type name of original class.
									  //  We'll do lookup if it's NULL.
									  //  This gets freed on exit.
	BOOL            fObjectsIconChanged;  // OUT; TRUE if ChangeIcon was called (and not cancelled)
	LPSTR           lpszDefLabel;     //IN-OUT: default label to use for icon.
									  //  if NULL, the short user type name
									  //  will be used. if the object is a
									  //  link, the caller should pass the
									  //  DisplayName of the link source
									  //  This gets freed on exit.

	UINT            cClsidExclude;    //IN: No. of CLSIDs in lpClsidExclude
	LPCLSID         lpClsidExclude;   //IN: List of CLSIDs to exclude from list
	} OLEUICONVERT, *POLEUICONVERT, FAR *LPOLEUICONVERT;


//API prototype
STDAPI_(UINT) OleUIConvert(LPOLEUICONVERT);

// Determine if there is at least one class that can Convert or ActivateAs
// the given clsid.
STDAPI_(BOOL) OleUICanConvertOrActivateAs(
		REFCLSID    rClsid,
		BOOL        fIsLinkedObject,
		WORD        wFormat
);

//Convert Dialog flags

// IN only: Shows "HELP" button
#define CF_SHOWHELPBUTTON          0x00000001L

// IN only: lets you set the convert default object - the one that is
// selected as default in the convert listbox.
#define CF_SETCONVERTDEFAULT       0x00000002L


// IN only: lets you set the activate default object - the one that is
// selected as default in the activate listbox.

#define CF_SETACTIVATEDEFAULT       0x00000004L


// IN/OUT: Selects the "Convert To" radio button, is set on exit if
// this button was selected
#define CF_SELECTCONVERTTO         0x00000008L

// IN/OUT: Selects the "Activate As" radio button, is set on exit if
// this button was selected
#define CF_SELECTACTIVATEAS        0x00000010L
#define CF_DISABLEDISPLAYASICON    0x00000020L
#define CF_DISABLEACTIVATEAS       0x00000040L


//Convert specific error codes
#define OLEUI_CTERR_CLASSIDINVALID      (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_CTERR_DVASPECTINVALID     (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_CTERR_CBFORMATINVALID     (OLEUI_ERR_STANDARDMAX+3)
#define OLEUI_CTERR_HMETAPICTINVALID    (OLEUI_ERR_STANDARDMAX+4)
#define OLEUI_CTERR_STRINGINVALID       (OLEUI_ERR_STANDARDMAX+5)


//Convert Dialog identifiers
#define IDCV_OBJECTTYPE             150
#define IDCV_DISPLAYASICON          152
#define IDCV_CHANGEICON             153
#define IDCV_ACTIVATELIST           154
#define IDCV_CONVERTTO              155
#define IDCV_ACTIVATEAS             156
#define IDCV_RESULTTEXT             157
#define IDCV_CONVERTLIST            158
#define IDCV_ICON                   159
#define IDCV_ICONLABEL1             160
#define IDCV_ICONLABEL2             161
#define IDCV_STXCURTYPE             162
#define IDCV_GRPRESULT              163
#define IDCV_STXCONVERTTO           164

// String IDs for Convert dialog
#define IDS_CVRESULTCONVERTLINK     32440
#define IDS_CVRESULTCONVERTTO       32441
#define IDS_CVRESULTNOCHANGE        32442
#define IDS_CVRESULTDISPLAYASICON   32443
#define IDS_CVRESULTACTIVATEAS      32444
#define IDS_CVRESULTACTIVATEDIFF    32445


/*************************************************************************
** BUSY DIALOG
*************************************************************************/

typedef struct tagOLEUIBUSY
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;         //Structure Size
	DWORD           dwFlags;          //IN-OUT:  Flags ** NOTE ** this dialog has no flags
	HWND            hWndOwner;        //Owning window
	LPCSTR          lpszCaption;      //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;         //Hook callback
	LPARAM          lCustData;        //Custom data to pass to hook
	HINSTANCE       hInstance;        //Instance for customized template name
	LPCSTR          lpszTemplate;     //Customized template name
	HRSRC           hResource;        //Customized template handle

	//Specifics for OLEUIBUSY.
	HTASK           hTask;            //IN: HTask which is blocking
	HWND FAR *      lphWndDialog;     //IN: Dialog's HWND is placed here
	} OLEUIBUSY, *POLEUIBUSY, FAR *LPOLEUIBUSY;

//API prototype
STDAPI_(UINT) OleUIBusy(LPOLEUIBUSY);

// Flags for this dialog

// IN only: Disables "Cancel" button
#define BZ_DISABLECANCELBUTTON          0x00000001L

// IN only: Disables "Switch To..." button
#define BZ_DISABLESWITCHTOBUTTON        0x00000002L

// IN only: Disables "Retry" button
#define BZ_DISABLERETRYBUTTON           0x00000004L

// IN only: Generates a "Not Responding" dialog as opposed to the
// "Busy" dialog.  The wording in the text is slightly different, and
// the "Cancel" button is grayed out if you set this flag.
#define BZ_NOTRESPONDINGDIALOG          0x00000008L

// Busy specific error/return codes
#define OLEUI_BZERR_HTASKINVALID     (OLEUI_ERR_STANDARDMAX+0)

// SWITCHTOSELECTED is returned when user hit "switch to"
#define OLEUI_BZ_SWITCHTOSELECTED    (OLEUI_ERR_STANDARDMAX+1)

// RETRYSELECTED is returned when user hit "retry"
#define OLEUI_BZ_RETRYSELECTED       (OLEUI_ERR_STANDARDMAX+2)

// CALLUNBLOCKED is returned when call has been unblocked
#define OLEUI_BZ_CALLUNBLOCKED       (OLEUI_ERR_STANDARDMAX+3)

// Busy dialog identifiers
#define IDBZ_RETRY                      600
#define IDBZ_ICON                       601
#define IDBZ_MESSAGE1                   602
#define IDBZ_SWITCHTO                   604

// Busy dialog stringtable defines
#define IDS_BZRESULTTEXTBUSY            32447
#define IDS_BZRESULTTEXTNOTRESPONDING   32448

// Links dialog stringtable defines
#define IDS_LINK_AUTO           32450
#define IDS_LINK_MANUAL         32451
#define IDS_LINK_UNKNOWN        32452
#define IDS_LINKS               32453
#define IDS_FAILED              32454
#define IDS_CHANGESOURCE        32455
#define IDS_INVALIDSOURCE       32456
#define IDS_ERR_GETLINKSOURCE   32457
#define IDS_ERR_GETLINKUPDATEOPTIONS    32458
#define IDS_ERR_ADDSTRING       32459
#define IDS_CHANGEADDITIONALLINKS   32460
#define IDS_CLOSE               32461


/*************************************************************************
** PROMPT USER DIALOGS
*************************************************************************/
#define ID_PU_LINKS             900
#define ID_PU_TEXT              901
#define ID_PU_CONVERT           902
#define ID_PU_BROWSE            904
#define ID_PU_METER             905
#define ID_PU_PERCENT           906
#define ID_PU_STOP              907

// used for -1 ids in dialogs:
#define ID_DUMMY    999

/* inside ole2ui.c */
#ifdef __cplusplus
extern "C"
#endif
int EXPORT FAR CDECL OleUIPromptUser(WORD nTemplate, HWND hwndParent, ...);

#define UPDATELINKS_STARTDELAY  2000    // Delay before 1st link updates
										//  to give the user a chance to
										//  dismiss the dialog before any
										//  links update.

STDAPI_(BOOL) OleUIUpdateLinks(
		LPOLEUILINKCONTAINER lpOleUILinkCntr,
		HWND hwndParent,
		LPSTR lpszTitle,
		int cLinks);


/*************************************************************************
** OLE OBJECT FEEDBACK EFFECTS
*************************************************************************/

#define OLEUI_HANDLES_USEINVERSE    0x00000001L
#define OLEUI_HANDLES_NOBORDER      0x00000002L
#define OLEUI_HANDLES_INSIDE        0x00000004L
#define OLEUI_HANDLES_OUTSIDE       0x00000008L


#define OLEUI_SHADE_FULLRECT        1
#define OLEUI_SHADE_BORDERIN        2
#define OLEUI_SHADE_BORDEROUT       3

/* objfdbk.c function prototypes */
STDAPI_(void) OleUIDrawHandles(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cSize, BOOL fDraw);
STDAPI_(void) OleUIDrawShading(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cWidth);
STDAPI_(void) OleUIShowObject(LPCRECT lprc, HDC hdc, BOOL fIsLink);


/*************************************************************************
** Hatch window definitions and prototypes                              **
*************************************************************************/
#define DEFAULT_HATCHBORDER_WIDTH   4

STDAPI_(BOOL) RegisterHatchWindowClass(HINSTANCE hInst);
STDAPI_(HWND) CreateHatchWindow(HWND hWndParent, HINSTANCE hInst);
STDAPI_(UINT) GetHatchWidth(HWND hWndHatch);
STDAPI_(void) GetHatchRect(HWND hWndHatch, LPRECT lpHatchRect);
STDAPI_(void) SetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect);
STDAPI_(void) SetHatchWindowSize(
		HWND        hWndHatch,
		LPRECT      lprcIPObjRect,
		LPRECT      lprcClipRect,
		LPPOINT     lpptOffset
);



/*************************************************************************
** VERSION VERIFICATION INFORMATION
*************************************************************************/

// The following magic number is used to verify that the resources we bind
// to our EXE are the same "version" as the LIB (or DLL) file which
// contains these routines.  This is not the same as the Version information
// resource that we place in OLE2UI.RC, this is a special ID that we will
// have compiled in to our EXE.  Upon initialization of OLE2UI, we will
// look in our resources for an RCDATA called "VERIFICATION" (see OLE2UI.RC),
// and make sure that the magic number there equals the magic number below.

#define OLEUI_VERSION_MAGIC 0x4D42

#endif  //_OLE2UI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\dxferobj.h ===
//**********************************************************************
// File name: dxferobj.h
//
//      Definition of CDataXferObj
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DATAXFEROBJ_H_)
#define _DATAXFEROBJ_H_

class CSimpleSite;

interface CDataObject;

class CDataXferObj : public IDataObject
{
private:
	int m_nCount;                       // reference count
	SIZEL m_sizel;
	POINTL m_pointl;
	LPSTORAGE m_lpObjStorage;
	LPOLEOBJECT m_lpOleObject;

	// construction/destruction
	CDataXferObj();
	~CDataXferObj();

public:
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP DAdvise  ( FORMATETC FAR* pFormatetc, DWORD advf,
	LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
		{ return ResultFromScode(OLE_E_ADVISENOTSUPPORTED); }
	STDMETHODIMP DUnadvise  ( DWORD dwConnection)
		{ return ResultFromScode(OLE_E_ADVISENOTSUPPORTED); }
	STDMETHODIMP EnumDAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise)
		{ return ResultFromScode(OLE_E_ADVISENOTSUPPORTED); }
	STDMETHODIMP EnumFormatEtc  ( DWORD dwDirection,
			LPENUMFORMATETC FAR* ppenumFormatEtc);
			STDMETHODIMP GetCanonicalFormatEtc  ( LPFORMATETC pformatetc,
			LPFORMATETC pformatetcOut)
		{ pformatetcOut->ptd = NULL; return ResultFromScode(E_NOTIMPL); }
	STDMETHODIMP GetData  (LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium );
	STDMETHODIMP GetDataHere  (LPFORMATETC pformatetc, LPSTGMEDIUM pmedium);
	STDMETHODIMP QueryGetData  (LPFORMATETC pformatetc );
	STDMETHODIMP SetData  (LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
			BOOL fRelease)
		{ return ResultFromScode(E_NOTIMPL); }

	static CDataXferObj FAR* Create(CSimpleSite FAR* lpSite,
			POINTL FAR* pPointl);

};
#endif  // _DATAXFEROBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\dxferobj.cpp ===
//**********************************************************************
// File name: DXFEROBJ.CPP
//
//      Implementation file for CDataXferObj, data transfer object
//      implementation of IDataObject interface.
//
// Functions:
//
//      See DXFEROBJ.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "enumfetc.h"
#include <assert.h>
#include "dxferobj.h"
#include "site.h"

CLIPFORMAT g_cfEmbeddedObject = RegisterClipboardFormat(CF_EMBEDDEDOBJECT);
CLIPFORMAT g_cfObjectDescriptor =RegisterClipboardFormat(CF_OBJECTDESCRIPTOR);

// List of formats offered by our data transfer object via EnumFormatEtc
static FORMATETC s_arrGetFmtEtcs[] =
{
        { g_cfEmbeddedObject, NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},
        { g_cfObjectDescriptor, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        { CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT}
};


//**********************************************************************
//
// CDataXferObj::Create
//
// Purpose:
//
//      Creation routine for CDataXferObj
//
// Parameters:
//
//      CSimpleSite FAR *lpSite   - Pointer to source CSimpleSite
//                                  this is the container site of the
//                                  source OLE object to be transfered
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      assert                      C Runtime
//
// Comments:
//      reference count of CDataXferObj will be 0 on return.
//
//********************************************************************

CDataXferObj FAR * CDataXferObj::Create(
                CSimpleSite FAR *lpSite,
                POINTL FAR* pPointl
)
{
        CDataXferObj FAR * lpTemp = new CDataXferObj();

        if (!lpTemp)
                return NULL;

        // create a sub-storage for the object
        HRESULT hErr = StgCreateDocfile(
                                NULL,
                                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE |
                                        STGM_DELETEONRELEASE,
                                0,
                                &lpTemp->m_lpObjStorage);

        assert(hErr == NOERROR);

        if (hErr != NOERROR)
                {
                delete lpTemp;
                return NULL;
                }

        // Clone the source object
        if (lpSite->m_lpOleObject) {
                // Object is loaded; ask the object to save into the new storage
                LPPERSISTSTORAGE pPersistStorage;

                lpSite->m_lpOleObject->QueryInterface(IID_IPersistStorage,
                                (LPVOID FAR*)&pPersistStorage);
                assert(pPersistStorage);
                OleSave(pPersistStorage, lpTemp->m_lpObjStorage, FALSE);

                // pass NULL so that object application won't forget the real stg
                pPersistStorage->SaveCompleted(NULL);
                pPersistStorage->Release();
        } else {
                // Object not loaded so use cheaper IStorage CopyTo operation
                lpSite->m_lpObjStorage->CopyTo(0, NULL, NULL, lpTemp->m_lpObjStorage);
        }

        OleLoad(lpTemp->m_lpObjStorage, IID_IOleObject, NULL,
                        (LPVOID FAR*)&lpTemp->m_lpOleObject);
        assert(lpTemp->m_lpOleObject);

        lpTemp->m_sizel = lpSite->m_sizel;
        if (pPointl)
                lpTemp->m_pointl = *pPointl;
        else
                lpTemp->m_pointl.x = lpTemp->m_pointl.y = 0;
        return lpTemp;
}

//**********************************************************************
//
// CDataXferObj::CDataXferObj
//
// Purpose:
//
//      Constructor for CDataXferObj
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
// Comments:
//
//********************************************************************

CDataXferObj::CDataXferObj (void)
{
        // clear the reference count
        m_nCount = 0;

        m_lpObjStorage = NULL;
        m_lpOleObject = NULL;
        m_sizel.cx = m_sizel.cy = 0;
        m_pointl.x = m_pointl.y = 0;
}

//**********************************************************************
//
// CDataXferObj::~CDataXferObj
//
// Purpose:
//
//      Destructor for CDataXferObj
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

CDataXferObj::~CDataXferObj ()
{
        TestDebugOut ("In CDataXferObj's Destructor \r\n");

        if (m_lpOleObject)
           {
           m_lpOleObject->Release();
           m_lpOleObject = NULL;

           // Release the storage for this object
           m_lpObjStorage->Release();
           m_lpObjStorage = NULL;
           }
}



//**********************************************************************
//
// CDataXferObj::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the CDataXferObj instance
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK            -   The interface is supported.
//      E_NOINTERFACE   -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      CDataXferObj::AddRef        DXFEROBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CDataXferObj::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
        TestDebugOut("In CDataXferObj::QueryInterface\r\n");

        if ( riid == IID_IUnknown || riid == IID_IDataObject)
                {
                AddRef();
                *ppvObj = this;
                return NOERROR;
                }

        // unknown interface requested
        *ppvObj = NULL;     // must set out pointer parameters to NULL
        return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CDataXferObj::AddRef
//
// Purpose:
//
//      Increments the reference count of the CDataXferObj instance
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the object
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataXferObj::AddRef()
{
        TestDebugOut("In CDataXferObj::AddRef\r\n");

        return ++m_nCount;
}

//**********************************************************************
//
// CDataXferObj::Release
//
// Purpose:
//
//      Decrements the reference count of the CDataXferObj object
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the object.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataXferObj::Release()
{
        TestDebugOut("In CDataXferObj::Release\r\n");

        if (--m_nCount == 0) {
                delete this;
                return 0;
        }
        return m_nCount;
}


/********************************************************************
** This IDataObject implementation is used for data transfer.
**
** The following methods are NOT supported for data transfer:
**      IDataObject::SetData    -- return E_NOTIMPL
**      IDataObject::DAdvise    -- return OLE_E_ADVISENOTSUPPORTED
**                 ::DUnadvise
**                 ::EnumDAdvise
**      IDataObject::GetCanonicalFormatEtc -- return E_NOTIMPL
**                      (NOTE: must set pformatetcOut->ptd = NULL)
*********************************************************************/


//**********************************************************************
//
// CDataXferObj::QueryGetData
//
// Purpose:
//
//      Called to determine if our object supports a particular
//      FORMATETC.
//
// Parameters:
//
//      LPFORMATETC pformatetc  - Pointer to the FORMATETC being queried for.
//
// Return Value:
//
//      DV_E_FORMATETC    - The FORMATETC is not supported
//      S_OK              - The FORMATETC is supported.
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//      we support the following formats:
//          "Embedded Object"
//          "Object Descriptor"
//          CF_METAFILEPICT
//
//********************************************************************
STDMETHODIMP CDataXferObj::QueryGetData (LPFORMATETC pformatetc)
{
        SCODE sc = DV_E_FORMATETC;

        TestDebugOut("In CDataXferObj::QueryGetData\r\n");

        // check the validity of the formatetc.

        if ( (pformatetc->cfFormat == g_cfEmbeddedObject) &&
                 (pformatetc->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetc->tymed == TYMED_ISTORAGE) )
                sc = S_OK;

        else if ( (pformatetc->cfFormat == g_cfObjectDescriptor) &&
                 (pformatetc->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetc->tymed == TYMED_HGLOBAL) )
                sc = S_OK;

        else if ( (pformatetc->cfFormat == CF_METAFILEPICT) &&
                 (pformatetc->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetc->tymed == TYMED_MFPICT) )
                sc = S_OK;

        return ResultFromScode(sc);
}


STDMETHODIMP CDataXferObj::EnumFormatEtc(
                DWORD dwDirection,
                LPENUMFORMATETC FAR* ppenumFormatEtc
)
{
        SCODE sc = E_NOTIMPL;

        TestDebugOut("In CDataXferObj::EnumFormatEtc\r\n");
        *ppenumFormatEtc = NULL;

        if (dwDirection == DATADIR_GET) {
                *ppenumFormatEtc = OleStdEnumFmtEtc_Create(
                                sizeof(s_arrGetFmtEtcs)/sizeof(s_arrGetFmtEtcs[0]),
                                s_arrGetFmtEtcs);
                if (*ppenumFormatEtc == NULL)
                        sc = E_OUTOFMEMORY;
                else
                        sc = S_OK;
        }
        return ResultFromScode(sc);
}


//**********************************************************************
//
// CDataXferObj::GetData
//
// Purpose:
//
//      Returns the data in the format specified in pformatetcIn.
//
// Parameters:
//
//      LPFORMATETC pformatetcIn    -   The format requested by the caller
//
//      LPSTGMEDIUM pmedium         -   The medium requested by the caller
//
// Return Value:
//
//      DV_E_FORMATETC    - Format not supported
//      S_OK                - Success
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      OleStdGetOleObjectData          OLE2UI API
//      OleStdGetMetafilePictFromOleObject OLE2UI API
//      ResultFromScode                 OLE API
//
// Comments:
//      we support GetData for the following formats:
//          "Embedded Object"
//          "Object Descriptor"
//          CF_METAFILEPICT
//
//********************************************************************

STDMETHODIMP CDataXferObj::GetData (
                LPFORMATETC pformatetcIn,
                LPSTGMEDIUM pmedium
)
{
        SCODE sc = DV_E_FORMATETC;

        TestDebugOut("In CDataXferObj::GetData\r\n");

        // we must set all out pointer parameters to NULL. */
        pmedium->tymed = TYMED_NULL;
        pmedium->pUnkForRelease = NULL;    // we transfer ownership to caller
        pmedium->hGlobal = NULL;

        // Check the FORMATETC and fill pmedium if valid.
        if ( (pformatetcIn->cfFormat == g_cfEmbeddedObject) &&
                 (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetcIn->tymed == TYMED_ISTORAGE) ) {
                 LPPERSISTSTORAGE pPersistStorage;

                 /* render CF_EMBEDDEDOBJECT by asking the object to save
                 **    into a temporary, DELETEONRELEASE IStorage allocated by us.
                 */
                 m_lpOleObject->QueryInterface(
                                 IID_IPersistStorage, (LPVOID FAR*)&pPersistStorage);
                 assert(pPersistStorage);
                 HRESULT hrErr = OleStdGetOleObjectData(
                                        pPersistStorage,
                                        pformatetcIn,
                                        pmedium,
                                        FALSE   /* fUseMemory -- (use file-base stg) */
                 );
                 pPersistStorage->Release();
                 sc = GetScode( hrErr );

        } else if ( (pformatetcIn->cfFormat == g_cfObjectDescriptor) &&
                 (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetcIn->tymed == TYMED_HGLOBAL) ) {

                 // render CF_OBJECTDESCRIPTOR data
                 pmedium->hGlobal = OleStdGetObjectDescriptorDataFromOleObject(
                                 m_lpOleObject,
                                 "Simple OLE 2.0 Container",    // string to identify source
                                 DVASPECT_CONTENT,
                                 m_pointl,
                                 (LPSIZEL)&m_sizel
                        );
                 if (! pmedium->hGlobal)
                         sc = E_OUTOFMEMORY;
                 else {
                         pmedium->tymed = TYMED_HGLOBAL;
                         sc = S_OK;
                 }

        } else if ( (pformatetcIn->cfFormat == CF_METAFILEPICT) &&
                 (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetcIn->tymed == TYMED_MFPICT) ) {

                 // render CF_METAFILEPICT by drawing the object into a metafile DC
                 pmedium->hGlobal = OleStdGetMetafilePictFromOleObject(
                                 m_lpOleObject, DVASPECT_CONTENT, NULL, pformatetcIn->ptd);
                 if (! pmedium->hGlobal)
                         sc = E_OUTOFMEMORY;
                 else {
                         pmedium->tymed = TYMED_MFPICT;
                         sc = S_OK;
                 }
        }

        return ResultFromScode( sc );
}

//**********************************************************************
//
// CDataXferObj::GetDataHere
//
// Purpose:
//
//      Called to get a data format in a caller supplied location
//
// Parameters:
//
//      LPFORMATETC pformatetc  - FORMATETC requested
//
//      LPSTGMEDIUM pmedium     - Medium to return the data
//
// Return Value:
//
//      DATA_E_FORMATETC    - We don't support the requested format
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      OleStdGetOleObjectData      OLE2UI API
//
// Comments:
//
//********************************************************************

STDMETHODIMP CDataXferObj::GetDataHere (
                LPFORMATETC pformatetc,
                LPSTGMEDIUM pmedium
)
{
        SCODE sc = DV_E_FORMATETC;

        TestDebugOut("In CDataXferObj::GetDataHere\r\n");

        // NOTE: pmedium is an IN parameter. we should NOT set
        //           pmedium->pUnkForRelease to NULL

        // Check the FORMATETC and fill pmedium if valid.
        if ( (pformatetc->cfFormat == g_cfEmbeddedObject) &&
                 (pformatetc->dwAspect == DVASPECT_CONTENT) &&
                 (pformatetc->tymed == TYMED_ISTORAGE) ) {
                 LPPERSISTSTORAGE pPersistStorage;

                 /* render CF_EMBEDDEDOBJECT by asking the object to save
                 **    into the IStorage allocated by the caller.
                 */
                 m_lpOleObject->QueryInterface(
                                 IID_IPersistStorage, (LPVOID FAR*)&pPersistStorage);
                 assert(pPersistStorage);
                 HRESULT hrErr = OleStdGetOleObjectData(
                                 pPersistStorage, pformatetc, pmedium,0 /*fUseMemory--N/A*/ );
                 pPersistStorage->Release();
                 sc = GetScode( hrErr );
        }
        return ResultFromScode( sc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\app.cpp ===
//**********************************************************************
// File name: app.cpp
//
//    Implementation file for the CSimpleApp Class
//
// Functions:
//
//    See app.h for a list of member functions.
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <testmess.h>

//**********************************************************************
//
// CSimpleApp::CSimpleApp()
//
// Purpose:
//
//      Constructor for CSimpleApp
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetRectEmpty                Windows API
//
// Comments:
//
//********************************************************************
CSimpleApp::CSimpleApp()
{
        TestDebugOut("In CSimpleApp's Constructor \r\n");

        // Set Ref Count
        m_nCount = 0;

        // clear members
        m_hAppWnd = NULL;
        m_hDriverWnd = NULL;
        m_hInst = NULL;
        m_lpDoc = NULL;

        // clear flags
        m_fInitialized = FALSE;
}

//**********************************************************************
//
// CSimpleApp::~CSimpleApp()
//
// Purpose:
//
//      Destructor for CSimpleApp Class.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      OleUninitialize             OLE API
//
// Comments:
//
//********************************************************************

CSimpleApp::~CSimpleApp()
{
        TestDebugOut("In CSimpleApp's Destructor\r\n");

        // need to uninit the library...
        if (m_fInitialized)
                OleUninitialize();
}

//**********************************************************************
//
// CSimpleApp::DestroyDocs()
//
// Purpose:
//
//      Destroys all of the open documents in the application (Only one
//      since this is an SDI app, but could easily be modified to
//      support MDI).
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
// Comments:
//
//********************************************************************

void CSimpleApp::DestroyDocs()
{
        m_lpDoc->Close();   // we have only 1 document
}

//**********************************************************************
//
// CSimpleApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the Frame level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP CSimpleApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
        TestDebugOut("In CSimpleApp::QueryInterface\r\n");

        *ppvObj = NULL;     // must set out pointer parameters to NULL

        // Not a supported interface
        return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Application level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::AddRef()
{
        TestDebugOut("In CSimpleApp::AddRef\r\n");
        return ++m_nCount;
}

//**********************************************************************
//
// CSimpleApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::Release()
{
        TestDebugOut("In CSimpleApp::Release\r\n");

        if (--m_nCount == 0) {
                delete this;
                return 0;
        }
        return m_nCount;
}

//**********************************************************************
//
// CSimpleApp::fInitApplication
//
// Purpose:
//
//      Initializes the application
//
// Parameters:
//
//      HANDLE hInstance    -   Instance handle of the application.
//
// Return Value:
//
//      TRUE    -   Application was successfully initialized.
//      FALSE   -   Application could not be initialized
//
// Function Calls:
//      Function                    Location
//
//      LoadIcon                    Windows API
//      LoadCursor                  Windows API
//      GetStockObject              Windows API
//      RegisterClass               Windows API
//
// Comments:
//
//********************************************************************

BOOL CSimpleApp::fInitApplication(HANDLE hInstance)
{
        WNDCLASS  wc;

        // Fill in window class structure with parameters that describe the
        // main window.

        wc.style = NULL;                    // Class style(s).
        wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for
                                                                                // windows of this class.
        wc.cbClsExtra = 0;                  // No per-class extra data.
        wc.cbWndExtra = 0;                  // No per-window extra data.
        wc.hInstance = hInstance;           // Application that owns the class.
        wc.hIcon = LoadIcon(hInstance,"SimpDnd");
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
        wc.lpszMenuName =  "SIMPLEMENU";    // Name of menu resource in .RC file.
        wc.lpszClassName = "SimpDndAppWClass";  // Name used in CreateWindow call.

        if (!RegisterClass(&wc))
                return FALSE;

        wc.style = CS_DBLCLKS;              // Class style(s). allow DBLCLK's
        wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for
                                                                                // windows of this class.
        wc.cbClsExtra = 0;                  // No per-class extra data.
        wc.cbWndExtra = 0;                  // No per-window extra data.
        wc.hInstance = hInstance;           // Application that owns the class.
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
        wc.lpszMenuName =  NULL;
        wc.lpszClassName = "SimpDndDocWClass"; // Name used in CreateWindow call.

        // Register the window class and return success/failure code.

        return (RegisterClass(&wc));
}

//**********************************************************************
//
// CSimpleApp::fInitInstance
//
// Purpose:
//
//      Instance initialization.
//
// Parameters:
//
//      HANDLE hInstance    -   App. Instance Handle.
//
//      int nCmdShow        -   Show parameter from WinMain
//
// Return Value:
//
//      TRUE    -   Initialization Successful
//      FALSE   -   Initialization Failed.
//
//
// Function Calls:
//      Function                    Location
//
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      OleBuildVersion             OLE API
//      OleInitialize               OLE API
//
// Comments:
//
//      Note that successful Initalization of the OLE libraries
//      is remembered so the UnInit is only called if needed.
//
//********************************************************************

BOOL CSimpleApp::fInitInstance (HANDLE hInstance, int nCmdShow)
{
        DWORD dwVer = OleBuildVersion();
        LPMALLOC lpMalloc = NULL;

#ifdef NO
        // check to see if we are compatible with this version of the libraries
        if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup) {
#ifdef _DEBUG
                TestDebugOut("WARNING: Incompatible OLE library version\r\n");
#else
                return FALSE;
#endif
        }

#endif

#if defined( _DEBUG )
        /* OLE2NOTE: Use a special debug allocator to help track down
        **    memory leaks.
        */
        OleStdCreateDbAlloc(0, &lpMalloc);
#endif

        if (OleInitialize(lpMalloc) == NOERROR)
                m_fInitialized = TRUE;

#if defined( _DEBUG )
        /* OLE2NOTE: release the special debug allocator so that only OLE is
        **    holding on to it. later when OleUninitialize is called, then
        **    the debug allocator object will be destroyed. when the debug
        **    allocator object is destoyed, it will report (to the Output
        **    Debug Terminal) whether there are any memory leaks.
        */
        if (lpMalloc) lpMalloc->Release();
#endif

        m_hInst = hInstance;

        // Create the "application" windows
        m_hAppWnd = CreateWindow ("SimpDndAppWClass",
                                                          "Simple OLE 2.0 Drag/Drop Container",
                                                          WS_OVERLAPPEDWINDOW,
                                                          CW_USEDEFAULT,
                                                          CW_USEDEFAULT,
                                                          CW_USEDEFAULT,
                                                          CW_USEDEFAULT,
                                                          NULL,
                                                          NULL,
                                                          hInstance,
                                                          NULL);

        if (!m_hAppWnd)
                return FALSE;

        // if we have been launched by the test driver, tell it our window handle

        if( m_hDriverWnd )
        {
            PostMessage(m_hDriverWnd, WM_TESTREG, (WPARAM)m_hAppWnd, 0);
        }

        // delay before dragging should start, in milliseconds
        m_nDragDelay = GetProfileInt(
                        "windows",
                        "DragDelay",
                        DD_DEFDRAGDELAY
        );

        // minimum distance (radius) before drag should start, in pixels
        m_nDragMinDist = GetProfileInt(
                        "windows",
                        "DragMinDist",
                        DD_DEFDRAGMINDIST
        );

        // delay before scrolling, in milliseconds
        m_nScrollDelay = GetProfileInt(
                        "windows",
                        "DragScrollDelay",
                        DD_DEFSCROLLDELAY
        );

        // inset-width of the hot zone, in pixels
        m_nScrollInset = GetProfileInt(
                        "windows",
                        "DragScrollInset",
                        DD_DEFSCROLLINSET
        );

        // scroll interval, in milliseconds
        m_nScrollInterval = GetProfileInt(
                        "windows",
                        "DragScrollInterval",
                        DD_DEFSCROLLINTERVAL
        );

        ShowWindow (m_hAppWnd, nCmdShow);
        UpdateWindow (m_hAppWnd);

        return m_fInitialized;
}

//**********************************************************************
//
// CSimpleApp::lCommandHandler
//
// Purpose:
//
//      Handles the processing of WM_COMMAND.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_COMMAND)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                    Location
//
//      IOleObject::DoVerb                          Object
//      GetClientRect                               Windows API
//      MessageBox                                  Windows API
//      DialogBox                                   Windows API
//      MakeProcInstance                            Windows API
//      FreeProcInstance                            Windows API
//      SendMessage                                 Windows API
//      DefWindowProc                               Windows API
//      CSimpleDoc::InsertObject                    DOC.CPP
//
// Comments:
//
//********************************************************************

long CSimpleApp::lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        RECT rect;

        // see if the command is a verb selections
        if (wParam >= IDM_VERB0)
                {
                // get the rectangle of the object
                m_lpDoc->m_lpSite->GetObjRect(&rect);

                m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(
                                wParam - IDM_VERB0, NULL,
                                &m_lpDoc->m_lpSite->m_OleClientSite, -1,
                                m_lpDoc->m_hDocWnd, &rect);
                }
        else
                {
                switch (wParam) {
                        // bring up the About box
                        case IDM_ABOUT:
                                {
                                FARPROC lpProcAbout = MakeProcInstance((FARPROC)About, m_hInst);

                                DialogBox(m_hInst,               // current instance
                                        "AboutBox",                  // resource to use
                                        m_hAppWnd,                   // parent handle
                                        lpProcAbout);                // About() instance address

                                FreeProcInstance(lpProcAbout);
                                break;
                                }

                        // bring up the InsertObject Dialog
                        case IDM_INSERTOBJECT:
                                m_lpDoc->InsertObject();
                                break;

                        // Copy the object to the Clipboard
                        case IDM_COPY:
                                m_lpDoc->CopyObjectToClip();
                                break;

                        // exit the application
                        case IDM_EXIT:
                                SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                                break;

                        case IDM_NEW:
                                m_lpDoc->Close();
                                m_lpDoc = NULL;
                                lCreateDoc(hWnd, 0, 0, 0);
                                break;

                        default:
                                return (DefWindowProc(hWnd, message, wParam, lParam));
                        }   // end of switch
                }  // end of else
        return NULL;
}

//**********************************************************************
//
// CSimpleApp::lSizeHandler
//
// Purpose:
//
//      Handles the WM_SIZE message
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_SIZE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      LONG    -   returned from the "document" resizing
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::lResizeDoc      DOC.CPP
//
// Comments:
//
//********************************************************************

long CSimpleApp::lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        RECT rect;

        GetClientRect(m_hAppWnd, &rect);
        return m_lpDoc->lResizeDoc(&rect);
}

//**********************************************************************
//
// CSimpleApp::lCreateDoc
//
// Purpose:
//
//      Handles the creation of a document.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_CREATE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::CSimpleDoc      DOC.CPP
//
// Comments:
//
//********************************************************************

long CSimpleApp::lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        RECT rect;

        GetClientRect(hWnd, &rect);

        m_lpDoc = CSimpleDoc::Create(this, &rect, hWnd);

        return NULL;
}

//**********************************************************************
//
// CSimpleApp::HandleAccelerators
//
// Purpose:
//
//      To properly handle accelerators in the Message Loop
//
// Parameters:
//
//      LPMSG lpMsg -   A pointer to the message structure.
//
// Return Value:
//
//      TRUE    -   The accelerator was handled
//      FALSE   -   The accelerator was not handled
//
// Function Calls:
//      Function                                        Location
//
// Comments:
//
//********************************************************************

BOOL CSimpleApp::HandleAccelerators(LPMSG lpMsg)
{
        BOOL retval = FALSE;

        // we do not have any accelerators

        return retval;
}

//**********************************************************************
//
// CSimpleApp::PaintApp
//
// Purpose:
//
//      Handles the painting of the doc window.
//
//
// Parameters:
//
//      HDC hDC -   hDC to the Doc Window.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::PaintDoc        DOC.CPP
//
// Comments:
//
//      This is an app level function in case we want to do palette
//      management.
//
//********************************************************************

void CSimpleApp::PaintApp (HDC hDC)
{
        // at this level, we could enumerate through all of the
        // visible objects in the application, so that a palette
        // that best fits all of the objects can be built.

        // This app is designed to take on the same palette
        // functionality that was provided in OLE 1.0, the palette
        // of the last object drawn is realized.  Since we only
        // support one object at a time, it shouldn't be a big
        // deal.

        // if we supported multiple documents, we would enumerate
        // through each of the open documents and call paint.

        if (m_lpDoc)
                m_lpDoc->PaintDoc(hDC);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\ias.cpp ===
//**********************************************************************
// File name: IAS.CPP
//
//      Implementation file of CAdviseSink
//
//
// Functions:
//
//      See IAS.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CAdviseSink::QueryInterface
//
// Purpose:
//
//      Returns a pointer to a requested interface.
//
// Parameters:
//
//      REFIID riid         - The requested interface
//
//      LPVOID FAR* ppvObj  - Place to return the interface
//
// Return Value:
//
//      HRESULT from CSimpleSite::QueryInterface
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::QueryInterface SITE.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function simply delegates to the Object class, which is
//      aware of the supported interfaces.
//
//********************************************************************

STDMETHODIMP CAdviseSink::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In IAS::QueryInterface\r\n");

	// delegate to the document Object
	return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CAdviseSink::AddRef
//
// Purpose:
//
//      Increments the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::AddReff        SITE.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function adds one to the ref count of the interface,
//      and calls then calls CSimpleSite to increment its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::AddRef()
{
	TestDebugOut("In IAS::AddRef\r\n");

	// increment the interface reference count (for debugging only)
	++m_nCount;

	// delegate to the container Site
	return m_pSite->AddRef();
}

//**********************************************************************
//
// CAdviseSink::Release
//
// Purpose:
//
//      Decrements the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::Release        SITE.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function subtracts one from the ref count of the interface,
//      and calls then calls CSimpleSite to decrement its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::Release()
{
	TestDebugOut("In IAS::Release\r\n");

	// decrement the interface reference count (for debugging only)
	m_nCount--;

	// delegate to the container Site
	return m_pSite->Release();
}

//**********************************************************************
//
// CAdviseSink::OnDataChange
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnDataChange (FORMATETC FAR* pFormatetc, STGMEDIUM FAR* pStgmed)
{
	TestDebugOut("In IAS::OnDataChange\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnViewChange
//
// Purpose:
//
//      Notifies us that the view has changed and needs to be updated.
//
// Parameters:
//
//      DWORD dwAspect  - Aspect that has changed
//
//      LONG lindex     - Index that has changed
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      InvalidateRect              Windows API
//      IViewObject2::GetExtent     Object
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnViewChange (DWORD dwAspect, LONG lindex)
{
	LPVIEWOBJECT2 lpViewObject2;
	TestDebugOut("In IAS::OnViewChange\r\n");

	// get a pointer to IViewObject2
	HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(
			IID_IViewObject2,(LPVOID FAR *)&lpViewObject2);

	if (hErr == NOERROR) {
		// get extent of the object
		// NOTE: this method will never be remoted; it can be called w/i this async method
		lpViewObject2->GetExtent(DVASPECT_CONTENT, -1 , NULL, &m_pSite->m_sizel);
		lpViewObject2->Release();
	}

	InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);
}

//**********************************************************************
//
// CAdviseSink::OnRename
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnRename (LPMONIKER pmk)
{
	TestDebugOut("In IAS::OnRename\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnSave
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnSave ()
{
	TestDebugOut("In IAS::OnSave\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnClose
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnClose()
{
	TestDebugOut("In IAS::OnClose\r\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\ids.cpp ===
//**********************************************************************
// File name: IDS.CPP
//
//      Implementation file for CDropSource
//
// Functions:
//
//      See IDS.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "doc.h"
#include "site.h"
#include "dxferobj.h"


//**********************************************************************
//
// CSimpleDoc::QueryDrag
//
// Purpose:
//
//      Check to see if Drag operation should be initiated based on the
//      current position of the mouse.
//
// Parameters:
//
//      POINT pt                - position of mouse
//
// Return Value:
//
//      BOOL                    - TRUE if drag should take place,
//                                else FALSE
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::GetObjRect     SITE.CPP
//      PtInRect                    Windows API
//
// Comments:
//
//********************************************************************

BOOL CSimpleDoc::QueryDrag(POINT pt)
{
	// if pt is within rect of object, then start drag
	if (m_lpSite)
		{
		RECT rect;
		m_lpSite->GetObjRect(&rect);
		return ( PtInRect(&rect, pt) ? TRUE : FALSE );
		}
	else
		return FALSE;
}


//**********************************************************************
//
// CSimpleDoc::DoDragDrop
//
// Purpose:
//
//      Actually perform a drag/drop operation with the current
//      selection in the source document.
//
// Parameters:
//
//      none.
//
// Return Value:
//
//      DWORD                    - returns the result effect of the
//                                 drag/drop operation:
//                                      DROPEFFECT_NONE,
//                                      DROPEFFECT_COPY,
//                                      DROPEFFECT_MOVE, or
//                                      DROPEFFECT_LINK
//
// Function Calls:
//      Function                    Location
//
//      CDataXferObj::Create        DXFEROBJ.CPP
//      CDataXferObj::QueryInterface DXFEROBJ.CPP
//      CDataXferObj::Release       DXFEROBJ.CPP
//      DoDragDrop                  OLE API
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

DWORD CSimpleDoc::DoDragDrop (void)
{
	DWORD       dwEffect     = 0;
	LPDATAOBJECT lpDataObj;

	TestDebugOut("In CSimpleDoc::DoDragDrop\r\n");

	// Create a data transfer object by cloning the existing OLE object
	CDataXferObj FAR* pDataXferObj = CDataXferObj::Create(m_lpSite,NULL);

	if (! pDataXferObj) {
		MessageBox(NULL,"Out-of-memory","SimpDnD",MB_SYSTEMMODAL|MB_ICONHAND);
		return DROPEFFECT_NONE;
	}

	// initially obj is created with 0 refcnt. this QI will make it go to 1.
	pDataXferObj->QueryInterface(IID_IDataObject, (LPVOID FAR*)&lpDataObj);
	assert(lpDataObj);

	m_fLocalDrop     = FALSE;
	m_fLocalDrag     = TRUE;

	::DoDragDrop ( lpDataObj,
				 &m_DropSource,
				 DROPEFFECT_COPY,   // we only allow copy
				 &dwEffect
	);

	m_fLocalDrag     = FALSE;

	/* if after the Drag/Drop modal (mouse capture) loop is finished
	**    and a drag MOVE operation was performed, then we must delete
	**    the selection that was dragged.
	*/
	if ( (dwEffect & DROPEFFECT_MOVE) != 0 ) {
		// ... delete source object here (we do NOT support MOVE)
	}

	pDataXferObj->Release();    // this should destroy the DataXferObj
	return dwEffect;
}



//**********************************************************************
//
// CDropSource::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_OK                -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleDoc::QueryInterface  DOC.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP CDropSource::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In IDS::QueryInterface\r\n");

	// delegate to the document
	return m_pDoc->QueryInterface(riid, ppvObj);
}


//**********************************************************************
//
// CDropSource::AddRef
//
// Purpose:
//
//      Increments the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleObj::AddReff         OBJ.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function adds one to the ref count of the interface,
//      and calls then calls CSimpleDoc to increment its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropSource::AddRef()
{
	TestDebugOut("In IDS::AddRef\r\n");

	// increment the interface reference count (for debugging only)
	++m_nCount;

	// delegate to the document Object
	return m_pDoc->AddRef();
}

//**********************************************************************
//
// CDropSource::Release
//
// Purpose:
//
//      Decrements the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleObj::Release         OBJ.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function subtracts one from the ref count of the interface,
//      and calls then calls CSimpleDoc to decrement its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropSource::Release()
{
	TestDebugOut("In IDS::Release\r\n");

	// decrement the interface reference count (for debugging only)
	--m_nCount;

	// delegate to the document object
	return m_pDoc->Release();
}

//**********************************************************************
//
// CDropSource::QueryContinueDrag
//
// Purpose:
//
//      Called to determine if a drop should take place or be canceled.
//
// Parameters:
//
//      BOOL fEscapePressed - TRUE if ESCAPE key has been pressed
//      DWORD grfKeyState   - key state
//
// Return Value:
//
//      DRAGDROP_S_CANCEL   - drag operation should be canceled
//      DRAGDROP_S_DROP     - drop operation should be performed
//      S_OK                - dragging should continue
//
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP CDropSource::QueryContinueDrag (
		BOOL    fEscapePressed,
		DWORD   grfKeyState
)
{
	if (fEscapePressed)
		return ResultFromScode(DRAGDROP_S_CANCEL);
	else if (!(grfKeyState & MK_LBUTTON))
		return ResultFromScode(DRAGDROP_S_DROP);
	else
		return NOERROR;
}


//**********************************************************************
//
// CDropSource::GiveFeedback
//
// Purpose:
//
//      Called to set cursor feedback
//
// Parameters:
//
//      DWORD dwEffect      - drop operation to give feedback for
//
// Return Value:
//
//      DRAGDROP_S_USEDEFAULTCURSORS  - tells OLE to use standard cursors
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP CDropSource::GiveFeedback (DWORD dwEffect)
{
	return ResultFromScode(DRAGDROP_S_USEDEFAULTCURSORS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\pre.cpp ===
//**********************************************************************
// File name: pre.cpp
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\ias.h ===
//**********************************************************************
// File name: IAS.H
//
//      Definition of CAdviseSink
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IAS_H_ )
#define _IAS_H_

#include <assert.h>

class CSimpleSite;

interface CAdviseSink : public IAdviseSink
{
	int m_nCount;
	CSimpleSite FAR * m_pSite;

	CAdviseSink(CSimpleSite FAR * pSite) {
		TestDebugOut("In IAS's constructor\r\n");
		m_pSite = pSite;
		m_nCount = 0;
		};

	~CAdviseSink() {
		TestDebugOut("In IAS's destructor\r\n");
		assert(m_nCount == 0);
		} ;

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	// *** IAdviseSink methods ***
	STDMETHODIMP_(void) OnDataChange (FORMATETC FAR* pFormatetc, STGMEDIUM FAR* pStgmed);
	STDMETHODIMP_(void) OnViewChange (DWORD dwAspect, LONG lindex);
	STDMETHODIMP_(void) OnRename (LPMONIKER pmk);
	STDMETHODIMP_(void) OnSave ();
	STDMETHODIMP_(void) OnClose ();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\ids.h ===
//**********************************************************************
// File name: ids.h
//
//      Definition of CDropSource
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IDS_H_ )
#define _IDS_H_

#include <assert.h>

class CSimpleDoc;

interface CDropSource : public IDropSource
{
	int m_nCount;
	CSimpleDoc FAR * m_pDoc;

	CDropSource(CSimpleDoc FAR * pDoc) {
		TestDebugOut("In IDS's constructor\r\n");
		m_pDoc = pDoc;
		m_nCount = 0;
		};

	~CDropSource() {
		TestDebugOut("In IDS's destructor\r\n");
		} ;

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	   // *** IDropSource methods ***
	STDMETHODIMP QueryContinueDrag (BOOL fEscapePressed, DWORD grfKeyState);
	STDMETHODIMP GiveFeedback (DWORD dwEffect);

private:

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\idt.cpp ===
//**********************************************************************
// File name: IDT.CPP
//
//      Implementation file for CDropTarget
//
// Functions:
//
//      See IDT.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include "idt.h"

extern CLIPFORMAT g_cfObjectDescriptor;


//**********************************************************************
//
// CDropTarget::QueryDrop
//
// Purpose:
//
//      Check if the desired drop operation (identified by the given key
//      state) is possible at the current mouse position (pointl).
//
// Parameters:
//
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      BOOL fDragScroll        - TRUE if drag scrolling cursor should
//                                be shown.
//      LPDWORD pdwEffect       - (OUT) drag effect that should occur
//
// Return Value:
//
//      BOOL                    - TRUE if drop could take place,
//                                else FALSE
//
// Function Calls:
//      Function                    Location
//
//      OleStdGetDropEffect         OLE2UI API
//
// Comments:
//
//********************************************************************

BOOL CDropTarget::QueryDrop (
	DWORD           grfKeyState,
	POINTL          pointl,
	BOOL            fDragScroll,
	LPDWORD         pdwEffect
)
{
	DWORD      dwScrollEffect = 0L;
	DWORD      dwOKEffects = *pdwEffect;

	/* check if the cursor is in the active scroll area, if so need the
	**    special scroll cursor.
	*/
	if (fDragScroll)
		dwScrollEffect = DROPEFFECT_SCROLL;

	/* if we have already determined that the source does NOT have any
	**    acceptable data for us, the return NO-DROP
	*/
	if (! m_fCanDropCopy && ! m_fCanDropLink)
		goto dropeffect_none;

	/* OLE2NOTE: determine what type of drop should be performed given
	**    the current modifier key state. we rely on the standard
	**    interpretation of the modifier keys:
	**          no modifier -- DROPEFFECT_MOVE or whatever is allowed by src
	**          SHIFT       -- DROPEFFECT_MOVE
	**          CTRL        -- DROPEFFECT_COPY
	**          CTRL-SHIFT  -- DROPEFFECT_LINK
	*/

	*pdwEffect = OleStdGetDropEffect(grfKeyState);
	if (*pdwEffect == 0) {
		// No modifier keys given. Try in order MOVE, COPY, LINK.
		if ((DROPEFFECT_MOVE & dwOKEffects) && m_fCanDropCopy)
			*pdwEffect = DROPEFFECT_MOVE;
		else if ((DROPEFFECT_COPY & dwOKEffects) && m_fCanDropCopy)
			*pdwEffect = DROPEFFECT_COPY;
		else if ((DROPEFFECT_LINK & dwOKEffects) && m_fCanDropLink)
			*pdwEffect = DROPEFFECT_LINK;
		else
			goto dropeffect_none;
	} else {
		/* OLE2NOTE: we should check if the drag source application allows
		**    the desired drop effect.
		*/
		if (!(*pdwEffect & dwOKEffects))
			goto dropeffect_none;

		if ((*pdwEffect == DROPEFFECT_COPY || *pdwEffect == DROPEFFECT_MOVE)
				&& ! m_fCanDropCopy)
			goto dropeffect_none;

		if (*pdwEffect == DROPEFFECT_LINK && ! m_fCanDropLink)
			goto dropeffect_none;
	}

	*pdwEffect |= dwScrollEffect;
	return TRUE;

dropeffect_none:

	*pdwEffect = DROPEFFECT_NONE;
	return FALSE;
}


//**********************************************************************
//
// CDropTarget::QueryDrop
//
// Purpose:
//
//     Check to see if Drag scroll operation should be initiated.
//
// Parameters:
//
//      POINTL pointl           - position of mouse
//
// Return Value:
//
//      BOOL                    - TRUE if scroll cursor should be given
//                                else FALSE
//
// Function Calls:
//      Function                    Location
//
//      ScreenToClient              WINDOWS API
//      GetClientRect               WINDOWS API
//
// Comments:
//     A Drag scroll operation should be initiated when the mouse has
//     remained in the active scroll area (11 pixels frame around border
//     of window) for a specified amount of time (50ms).
//
//********************************************************************

BOOL CDropTarget::DoDragScroll (POINTL pointl)
{
	DWORD dwScrollDir = SCROLLDIR_NULL;
	DWORD dwTime = GetCurrentTime();
	int nScrollInset = m_pDoc->m_lpApp->m_nScrollInset;
	int nScrollDelay = m_pDoc->m_lpApp->m_nScrollDelay;
	int nScrollInterval = m_pDoc->m_lpApp->m_nScrollInterval;
	POINT point;
	RECT rect;

	point.x = (int)pointl.x;
	point.y = (int)pointl.y;

	ScreenToClient( m_pDoc->m_hDocWnd, &point);
	GetClientRect ( m_pDoc->m_hDocWnd, (LPRECT) &rect );

	if (rect.top <= point.y && point.y<=(rect.top+nScrollInset))
		dwScrollDir = SCROLLDIR_UP;
	else if ((rect.bottom-nScrollInset) <= point.y && point.y <= rect.bottom)
		dwScrollDir = SCROLLDIR_DOWN;
	else if (rect.left <= point.x && point.x <= (rect.left+nScrollInset))
		dwScrollDir = SCROLLDIR_LEFT;
	else if ((rect.right-nScrollInset) <= point.x && point.x <= rect.right)
		dwScrollDir = SCROLLDIR_RIGHT;

	if (m_dwTimeEnterScrollArea) {

		/* cursor was already in Scroll Area */

		if (! dwScrollDir) {
			/* cusor moved OUT of scroll area.
			**      clear "EnterScrollArea" time.
			*/
			m_dwTimeEnterScrollArea = 0L;
			m_dwNextScrollTime = 0L;
			m_dwLastScrollDir = SCROLLDIR_NULL;

		} else if (dwScrollDir != m_dwLastScrollDir) {
			/* cusor moved into a different direction scroll area.
			**      reset "EnterScrollArea" time to start a new 50ms delay.
			*/
			m_dwTimeEnterScrollArea = dwTime;
			m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay;
			m_dwLastScrollDir = dwScrollDir;

		} else if (dwTime && dwTime >= m_dwNextScrollTime) {
			m_pDoc->Scroll ( dwScrollDir );    // Scroll document now
			m_dwNextScrollTime = dwTime + (DWORD)nScrollInterval;
		}
	} else {
		if (dwScrollDir) {
			/* cusor moved INTO a scroll area.
			**      reset "EnterScrollArea" time to start a new 50ms delay.
			*/
			m_dwTimeEnterScrollArea = dwTime;
			m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay;
			m_dwLastScrollDir = dwScrollDir;
		}
	}

	return (dwScrollDir ? TRUE : FALSE);
}


// Support functions/macros
#define SetTopLeft(rc, pt)      \
	((rc)->top = (pt)->y,(rc)->left = (pt)->x)
#define SetBottomRight(rc, pt)      \
	((rc)->bottom = (pt)->y,(rc)->right = (pt)->x)
#define OffsetPoint(pt, dx, dy)     \
	((pt)->x += dx, (pt)->y += dy)


/* HighlightRect
** -------------
**    Invert rectangle on screen. used for drop target feedback.
*/

static int HighlightRect(HWND hwnd, HDC hdc, LPRECT rc)
{
	POINT pt1, pt2;
	int old = SetROP2(hdc, R2_NOT);
	HPEN hpen;
	HGDIOBJ hold;

	pt1.x = rc->left;
	pt1.y = rc->top;
	pt2.x = rc->right;
	pt2.y = rc->bottom;

	ScreenToClient(hwnd, &pt1);
	ScreenToClient(hwnd, &pt2);

	hold = SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
	hpen = SelectObject(hdc, CreatePen(PS_SOLID, 2,
						  GetSysColor(COLOR_ACTIVEBORDER)));

	Rectangle(hdc, pt1.x, pt1.y, pt2.x, pt2.y);

	SetROP2(hdc, old);

	hold = SelectObject(hdc, hold);
	hpen = SelectObject(hdc, hpen);

	DeleteObject(hpen);

  return 0;
}


//**********************************************************************
//
// CDropTarget::InitDragFeedback
//
// Purpose:
//
//      Initialize data used to draw drop target feedback.
//      As feedback we draw a rectangle the size of the object.
//
// Parameters:
//
//      LPDATAOBJECT pDataObj   - IDataObject from Drop source
//      POINTL pointl           - position of mouse
//
// Return Value:
//
//      none.
//
// Function Calls:
//      Function                    Location
//
//      IDataObject::GetData        Object
//      XformSizeInHimetricToPixels OLE2UI Library
//      GlobalLock                  WINDOWS API
//      GlobalUnlock                WINDOWS API
//      ReleaseStgMedium            OLE2 API
//      OffsetPoint                 IDT.CPP
//      SetTopLeft                  IDT.CPP
//      SetBottomRight              IDT.CPP
//
// Comments:
//      In order to known the size of the object before the object
//      is actually dropped, we render CF_OBJECTDESCRIPTOR format.
//      this data format tells us both the size of the object as
//      well as which aspect is the object is displayed as in the
//      source. if the object is currently displayed as DVASPECT_ICON
//      then we want to create the object also as DVASPECT_ICON.
//
//********************************************************************

void CDropTarget::InitDragFeedback(LPDATAOBJECT pDataObj, POINTL pointl)
{
	FORMATETC fmtetc;
	STGMEDIUM stgmed;
	POINT pt;
	int height, width;
	HRESULT hrErr;

	height = width = 100; // some default values
	pt.x = (int)pointl.x;
	pt.y = (int)pointl.y;

	// do a GetData for CF_OBJECTDESCRIPTOR format to get the size of the
	// object as displayed in the source. using this size, initialize the
	// size for the drag feedback rectangle.
	fmtetc.cfFormat = g_cfObjectDescriptor;
	fmtetc.ptd = NULL;
	fmtetc.lindex = -1;
	fmtetc.dwAspect = DVASPECT_CONTENT;
	fmtetc.tymed = TYMED_HGLOBAL;

	hrErr = pDataObj->GetData(&fmtetc, &stgmed);
	if (hrErr == NOERROR) {
		LPOBJECTDESCRIPTOR pOD=(LPOBJECTDESCRIPTOR)GlobalLock(stgmed.hGlobal);
		if (pOD != NULL) {
			XformSizeInHimetricToPixels(NULL, &pOD->sizel, &pOD->sizel);

			width = (int)pOD->sizel.cx;
			height = (int)pOD->sizel.cy;
			m_dwSrcAspect = pOD->dwDrawAspect;
		}

		GlobalUnlock(stgmed.hGlobal);
		ReleaseStgMedium(&stgmed);
	}

	m_ptLast = pt;
	m_fDragFeedbackDrawn = FALSE;

	OffsetPoint(&pt, -(width/2), -(height/2));
	SetTopLeft(&m_rcDragRect, &pt);

	OffsetPoint(&pt, width, height);
	SetBottomRight(&m_rcDragRect, &pt);
}


//**********************************************************************
//
// CDropTarget::UndrawDragFeedback
//
// Purpose:
//
//      Erase any drop target feedback.
//      As feedback we draw a rectangle the size of the object.
//
// Parameters:
//
//      none.
//
// Return Value:
//
//      none.
//
// Function Calls:
//      Function                    Location
//
//      GetDC                       WINDOWS API
//      ReleaseDC                   WINDOWS API
//      GlobalUnlock                WINDOWS API
//      HighlightRect               IDT.CPP
//
// Comments:
//      In order to known the size of the object before the object
//      is actually dropped, we render CF_OBJECTDESCRIPTOR format.
//      this data format tells us both the size of the object as
//      well as which aspect is the object is displayed as in the
//      source. if the object is currently displayed as DVASPECT_ICON
//      then we want to create the object also as DVASPECT_ICON.
//
//********************************************************************

void CDropTarget::UndrawDragFeedback( void )
{
	if (m_fDragFeedbackDrawn) {
		m_fDragFeedbackDrawn = FALSE;
		HDC hDC = GetDC(m_pDoc->m_hDocWnd);
		HighlightRect(m_pDoc->m_hDocWnd, hDC, &m_rcDragRect);
		ReleaseDC(m_pDoc->m_hDocWnd, hDC);
	}
}


//**********************************************************************
//
// CDropTarget::DrawDragFeedback
//
// Purpose:
//
//      Compute new position of drop target feedback rectangle and
//      erase old rectangle and draw new rectangle.
//      As feedback we draw a rectangle the size of the object.
//
// Parameters:
//
//      POINTL pointl           - position of mouse
//
// Return Value:
//
//      none.
//
// Function Calls:
//      Function                    Location
//
//      OffsetPoint                 IDT.CPP
//      HighlightRect               IDT.CPP
//      GetDC                       WINDOWS API
//      ReleaseDC                   WINDOWS API
//
// Comments:
//
//********************************************************************

void CDropTarget::DrawDragFeedback( POINTL pointl )
{
	POINT ptDiff;

	ptDiff.x = (int)pointl.x - m_ptLast.x;
	ptDiff.y = (int)pointl.y - m_ptLast.y;

	if (m_fDragFeedbackDrawn && (ptDiff.x == 0 && ptDiff.y == 0))
		return;     // mouse did not move; leave rectangle as drawn

	HDC hDC = GetDC(m_pDoc->m_hDocWnd);
	if (m_fDragFeedbackDrawn) {
		m_fDragFeedbackDrawn = FALSE;
		HighlightRect(m_pDoc->m_hDocWnd, hDC, &m_rcDragRect);
	}

	OffsetRect(&m_rcDragRect, ptDiff.x, ptDiff.y);
	HighlightRect(m_pDoc->m_hDocWnd, hDC, &m_rcDragRect);
	m_fDragFeedbackDrawn = TRUE;
	m_ptLast.x = (int)pointl.x;
	m_ptLast.y = (int)pointl.y;
	ReleaseDC(m_pDoc->m_hDocWnd, hDC);
}


//**********************************************************************
//
// CDropTarget::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_OK                -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleDoc::QueryInterface  DOC.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP CDropTarget::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In IDT::QueryInterface\r\n");

	// delegate to the document
	return m_pDoc->QueryInterface(riid, ppvObj);
}


//**********************************************************************
//
// CDropTarget::AddRef
//
// Purpose:
//
//      Increments the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::AddReff         DOC.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function adds one to the ref count of the interface,
//      and calls then calls CSimpleObj to increment its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropTarget::AddRef()
{
	TestDebugOut("In IDT::AddRef\r\n");

	// increment the interface reference count (for debugging only)
	++m_nCount;

	// delegate to the document Object
	return m_pDoc->AddRef();
}

//**********************************************************************
//
// CDropTarget::Release
//
// Purpose:
//
//      Decrements the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::Release         DOC.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function subtracts one from the ref count of the interface,
//      and calls then calls CSimpleDoc to decrement its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropTarget::Release()
{
	TestDebugOut("In IDT::Release\r\n");

	// decrement the interface reference count (for debugging only)
	--m_nCount;

	// delegate to the document object
	return m_pDoc->Release();
}


//**********************************************************************
//
// CDropTarget::DragEnter
//
// Purpose:
//
//      Called when the mouse first enters our DropTarget window
//
// Parameters:
//
//      LPDATAOBJECT pDataObj   - IDataObject from Drop source
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur
//                                ON INPUT, this is dwOKEffects that source
//                                passed to DoDragDrop API.
//                                ON OUTPUT, this is the effect that we
//                                want to take effect (used to determine
//                                cursor feedback).
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      OleQueryCreateFromData      OLE2 API
//      DoDragScroll                IDT.CPP
//      QueryDrop                   IDT.CPP
//      InitDragFeedback            IDT.CPP
//      DrawDragFeedback            IDT.CPP
//      UndrawDragFeedback          IDT.CPP
//
// Comments:
//      Callee should honor the dwEffects as passed in to determine
//      if the caller allows DROPEFFECT_MOVE.
//
//********************************************************************

STDMETHODIMP CDropTarget::DragEnter (LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pointl, LPDWORD pdwEffect)
{
	TestDebugOut("In IDT::DragEnter\r\n");

	/* Determine if the drag source data object offers a data format
	**  that we understand. we accept only creating embedded objects.
	*/
	m_fCanDropCopy = ((OleQueryCreateFromData(pDataObj) == NOERROR) ?
			TRUE : FALSE);
	m_fCanDropLink = FALSE; // linking NOT supported in this simple sample

	if (m_fCanDropCopy || m_fCanDropLink)
		InitDragFeedback(pDataObj, pointl);

	BOOL fDragScroll = DoDragScroll ( pointl );

	if (QueryDrop(grfKeyState,pointl,fDragScroll,pdwEffect))
		DrawDragFeedback( pointl );

	return NOERROR;
}


//**********************************************************************
//
// CDropTarget::DragOver
//
// Purpose:
//
//      Called when the mouse moves, key state changes, or a time
//      interval passes while the mouse is still within our DropTarget
//      window.
//
// Parameters:
//
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur
//                                ON INPUT, this is dwOKEffects that source
//                                passed to DoDragDrop API.
//                                ON OUTPUT, this is the effect that we
//                                want to take effect (used to determine
//                                cursor feedback).
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DoDragScroll                IDT.CPP
//      QueryDrop                   IDT.CPP
//      DrawDragFeedback            IDT.CPP
//      UndrawDragFeedback          IDT.CPP
//
// Comments:
//      Callee should honor the dwEffects as passed in to determine
//      if the caller allows DROPEFFECT_MOVE. OLE pulses the DragOver
//      calls in order that the DropTarget can implement drag scrolling
//
//********************************************************************

STDMETHODIMP CDropTarget::DragOver  (DWORD grfKeyState, POINTL pointl, LPDWORD pdwEffect)
{
	TestDebugOut("In IDT::DragOver\r\n");

	BOOL fDragScroll = DoDragScroll ( pointl );

	if (QueryDrop(grfKeyState,pointl,fDragScroll,pdwEffect))
		DrawDragFeedback( pointl );
	else
		UndrawDragFeedback();

	return NOERROR;
}


//**********************************************************************
//
// CDropTarget::DragLeave
//
// Purpose:
//
//      Called when the mouse leaves our DropTarget window
//
// Parameters:
//
//      none.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      UndrawDragFeedback          IDT.CPP
//      ResultFromScode             OLE2 API
//
// Comments:
//
//********************************************************************

STDMETHODIMP CDropTarget::DragLeave ()
{
	TestDebugOut("In IDT::DragLeave\r\n");

	UndrawDragFeedback();

	return ResultFromScode(S_OK);
}


//**********************************************************************
//
// CDropTarget::Drop
//
// Purpose:
//
//      Called when a Drop operation should take place.
//
// Parameters:
//
//      LPDATAOBJECT pDataObj   - IDataObject from Drop source
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur
//                                ON INPUT, this is dwOKEffects that source
//                                passed to DoDragDrop API.
//                                ON OUTPUT, this is the effect that we
//                                want to take effect (used to determine
//                                cursor feedback).
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::Create         SITE.CPP
//      CSimpleSite::InitObject     SITE.CPP
//      OleCreateFromData           OLE2 API
//      DoDragScroll                IDT.CPP
//      QueryDrop                   IDT.CPP
//      InitDragFeedback            IDT.CPP
//      DrawDragFeedback            IDT.CPP
//      UndrawDragFeedback          IDT.CPP
//      GetScode                    OLE2 API
//      ResultFromScode             OLE2 API
//
// Comments:
//      Callee should honor the dwEffects as passed in to determine
//      if the caller allows DROPEFFECT_MOVE.
//
//********************************************************************

STDMETHODIMP CDropTarget::Drop (LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pointl, LPDWORD pdwEffect)
{
	FORMATETC fmtetc;
	SCODE sc = S_OK;

	TestDebugOut("In IDT::Drop\r\n");

	UndrawDragFeedback();

	if (pDataObj && QueryDrop(grfKeyState,pointl,FALSE,pdwEffect))
		{
		m_pDoc->m_lpSite = CSimpleSite::Create(m_pDoc);
		// keep same aspect as drop source
		m_pDoc->m_lpSite->m_dwDrawAspect = m_dwSrcAspect;

		// in order to specify a particular drawing Aspect we must
		// pass a FORMATETC* to OleCreateFromData
		fmtetc.cfFormat = NULL;             // use whatever for drawing
		fmtetc.ptd = NULL;
		fmtetc.lindex = -1;
		fmtetc.dwAspect = m_dwSrcAspect;    // desired drawing aspect
		fmtetc.tymed = TYMED_NULL;

		HRESULT hrErr = OleCreateFromData (
							pDataObj,
							IID_IOleObject,
							OLERENDER_DRAW,
							&fmtetc,
							&m_pDoc->m_lpSite->m_OleClientSite,
							m_pDoc->m_lpSite->m_lpObjStorage,
							(LPVOID FAR *)&m_pDoc->m_lpSite->m_lpOleObject);

		if (hrErr == NOERROR)
			{
			m_pDoc->m_lpSite->InitObject(FALSE /* fCreateNew */);
			m_pDoc->DisableInsertObject();
			}
		else
			sc = GetScode(hrErr);
		}

	return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\idt.h ===
//**********************************************************************
// File name: idt.h
//
//      Definition of CDropTarget
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IDT_H_ )
#define _IDT_H_

#include <assert.h>

class CSimpleDoc;

/* Flags to control direction for drag scrolling */
typedef enum tagSCROLLDIR {
	SCROLLDIR_NULL          = 0,
	SCROLLDIR_UP            = 1,
	SCROLLDIR_DOWN          = 2,
	SCROLLDIR_RIGHT         = 3,
	SCROLLDIR_LEFT          = 4
} SCROLLDIR;

interface CDropTarget : public IDropTarget
{
	int   m_nCount;                 // reference count
	CSimpleDoc FAR * m_pDoc;
	BOOL  m_fCanDropCopy;
	BOOL  m_fCanDropLink;
	DWORD m_dwSrcAspect;
	RECT  m_rcDragRect;
	POINT m_ptLast;
	BOOL  m_fDragFeedbackDrawn;
	DWORD m_dwTimeEnterScrollArea;  // time of entering scroll border region
	DWORD m_dwLastScrollDir;        // current dir for drag scroll
	DWORD m_dwNextScrollTime;       // time for next scroll

	CDropTarget(CSimpleDoc FAR * pDoc) {
		TestDebugOut("In IDT's constructor\r\n");
		m_pDoc = pDoc;
		m_nCount = 0;
		m_fCanDropCopy = FALSE;
		m_fCanDropLink = FALSE;
		m_fDragFeedbackDrawn = FALSE;
		m_dwTimeEnterScrollArea = 0L;
		m_dwNextScrollTime = 0L;
		m_dwLastScrollDir = SCROLLDIR_NULL;
		};

	~CDropTarget() {
		TestDebugOut("In IDT's destructor\r\n");
		assert(m_nCount == 0);
		} ;

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	   // *** IDropTarget methods ***
	STDMETHODIMP DragEnter (LPDATAOBJECT pDataObj, DWORD grfKeyState,
			POINTL pt, LPDWORD pdwEffect);
	STDMETHODIMP DragOver  (DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect);
	STDMETHODIMP DragLeave ();
	STDMETHODIMP Drop (LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt,
			LPDWORD pdwEffect);

private:
	// Drag/Drop support methods
	BOOL QueryDrop (DWORD grfKeyState, POINTL pointl, BOOL fDragScroll,
			LPDWORD lpdwEffect);
	BOOL DoDragScroll( POINTL pointl );
	void InitDragFeedback(LPDATAOBJECT pDataObj, POINTL pointl);
	void DrawDragFeedback( POINTL pointl );
	void UndrawDragFeedback( void );
};

#endif  // _IDT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\iocs.h ===
//**********************************************************************
// File name: IOCS.H
//
//      Definition of COleClientSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOCS_H_ )
#define _IOCS_H_

#include <assert.h>

class CSimpleSite;

interface COleClientSite : public IOleClientSite
{
	int m_nCount;
	CSimpleSite FAR * m_pSite;

	COleClientSite(CSimpleSite FAR * pSite) {
		TestDebugOut("In IOCS's constructor\r\n");
		m_pSite = pSite;
		m_nCount = 0;
		}

	~COleClientSite() {
		TestDebugOut("In IOCS's destructor\r\n");
		assert(m_nCount == 0);
		}

	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// *** IOleClientSite methods ***
	STDMETHODIMP SaveObject();
	STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk);
	STDMETHODIMP GetContainer(LPOLECONTAINER FAR* ppContainer);
	STDMETHODIMP ShowObject();
	STDMETHODIMP OnShowWindow(BOOL fShow);
	STDMETHODIMP RequestNewObjectLayout();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\iocs.cpp ===
//**********************************************************************
// File name: IOCS.CPP
//
//      Implementation file for COleClientSite
//
// Functions:
//
//      See IOCS.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"


//**********************************************************************
//
// COleClientSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at this interface
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK                -   The interface is supported.
//      E_NOINTERFACE       -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::QueryInterface SITE.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In IOCS::QueryInterface\r\n");

	// delegate to the container Site
	return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CSimpleApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the interface level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::AddRef()
{
	TestDebugOut("In IOCS::AddRef\r\n");

	// increment the interface reference count (for debugging only)
	++m_nCount;

	// delegate to the container Site
	return m_pSite->AddRef();
}


//**********************************************************************
//
// CSimpleApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::Release()
{
	TestDebugOut("In IOCS::Release\r\n");

	// decrement the interface reference count (for debugging only)
	--m_nCount;

	// delegate to the container Site
	return m_pSite->Release();
}

//**********************************************************************
//
// COleClientSite::SaveObject
//
// Purpose:
//
//      Called by the object when it wants to be saved to persistant
//      storage
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleObject::QueryInterface          Object
//      IPersistStorage::SaveCompleted      Object
//      IPersistStorage::Release            Object
//      OleSave                             OLE API
//      ResultFromScode                     OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::SaveObject()
{
	LPPERSISTSTORAGE lpPS;
	SCODE sc = E_FAIL;

	TestDebugOut("In IOCS::SaveObject\r\n");

	// get a pointer to IPersistStorage
	HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(IID_IPersistStorage, (LPVOID FAR *)&lpPS);

	// save the object
	if (hErr == NOERROR)
		{
		sc = GetScode( OleSave(lpPS, m_pSite->m_lpObjStorage, TRUE) );
		lpPS->SaveCompleted(NULL);
		lpPS->Release();
		}

	return ResultFromScode(sc);
}

//**********************************************************************
//
// COleClientSite::GetMoniker
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
	TestDebugOut("In IOCS::GetMoniker\r\n");

	// need to null the out pointer
	*ppmk = NULL;

	return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::GetContainer
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
	TestDebugOut("In IOCS::GetContainer\r\n");

	// NULL the out pointer
	*ppContainer = NULL;

	return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::ShowObject
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::ShowObject()
{
	TestDebugOut("In IOCS::ShowObject\r\n");
	return NOERROR;
}

//**********************************************************************
//
// COleClientSite::OnShowWindow
//
// Purpose:
//
//      Object calls this method when it is opening/closing non-InPlace
//      Window
//
// Parameters:
//
//      BOOL fShow  - TRUE if Window is opening, FALSE if closing
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      InvalidateRect              Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::OnShowWindow(BOOL fShow)
{
	TestDebugOut("In IOCS::OnShowWindow\r\n");
	m_pSite->m_fObjectOpen = fShow;
	InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);

	// if object window is closing, then bring container window to top
	if (! fShow) {
		BringWindowToTop(m_pSite->m_lpDoc->m_hDocWnd);
		SetFocus(m_pSite->m_lpDoc->m_hDocWnd);
	}
	return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleClientSite::RequestNewObjectLayout
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleClientSite::RequestNewObjectLayout()
{
	TestDebugOut("In IOCS::RequestNewObjectLayout\r\n");
	return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SIMPDND.RC
//
#define IDM_OPEN                        102
#define IDC_DRAGPENDING                 102
#define IDM_SAVE                        103
#define IDM_SAVEAS                      104
#define IDM_PRINT                       105
#define IDM_EXIT                        106
#define IDM_UNDO                        107
#define IDM_CUT                         108
#define IDM_COPY                        109
#define IDM_PASTE                       110
#define ID_EDIT_INSERTOBJECT            111
#define IDM_INSERTOBJECT                111
#define IDM_NEW                         112

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         113
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <ole2.h>
#include <ole2ui.h>
#include <assert.h>
#include <string.h>
#include "simpdnd.h"
#include "resource.h"
#include <ole2ver.h>

extern "C" void TestDebugOut(LPSTR psz);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\simpdnd.h ===
//**********************************************************************
// File name: simpdnd.h
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#define IDM_ABOUT 100
#define IDM_INSERT  101
#define IDM_VERB0 1000

int PASCAL WinMain(HANDLE hInstance,HANDLE hPrevInstance,LPSTR lpCmdLine,int nCmdShow);
BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, int nCmdShow);
long FAR PASCAL _export MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
long FAR PASCAL _export DocWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL FAR PASCAL _export About(HWND hDlg, unsigned message, WORD wParam, LONG lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\tests.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	tests.h
//
//  Contents: 	Declarations for the unit test functions
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//  		07-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef __TESTS_H
#define __TESTS_H

void StartTest1(CSimpleApp *);
void StartTest2(CSimpleApp *);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\simpdnd.cpp ===
//**********************************************************************
// File name: Simple.cpp
//
//      Main source file for the Simple OLE 2.0 object container
//
// Functions:
//
//      WinMain         - Program entry point
//      MainWndProc     - Processes messages for the frame window
//      About           - Processes messages for the about dialog
//      DocWndProc      - Processes messages for the doc window
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <testmess.h>
#include <stdlib.h>
#include "tests.h"

// This line is needed for the debug utilities in OLE2UI
extern "C" {
        OLEDBGDATA_MAIN("SIMPDND")
}

CSimpleApp FAR * lpCSimpleApp;
BOOL fBeVerbose = FALSE;
extern "C"
void TestDebugOut(LPSTR psz)
{
    if (fBeVerbose)
    {
	OutputDebugString(psz);
    }
}

//**********************************************************************
//
// WinMain
//
// Purpose:
//
//      Program entry point
//
// Parameters:
//
//      HANDLE hInstance        - Instance handle for this instance
//
//      HANDLE hPrevInstance    - Instance handle for the last instance
//
//      LPSTR lpCmdLine         - Pointer to the command line
//
//      int nCmdShow            - Window State
//
// Return Value:
//
//      msg.wParam
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::CSimpleApp          APP.CPP
//      CSimpleApp::fInitApplication    APP.CPP
//      CSimpleApp::fInitInstance       APP.CPP
//      CSimpleApp::HandleAccelerators  APP.CPP
//      CSimpleApp::~CSimpleApp         APP.CPP
//      OleUIInitialize                 OLE2UI
//      OleUIUninitialize               OLE2UI
//      GetMessage                      Windows API
//      TranslateMessage                Windows API
//      DispatchMessage                 Windows API
//
// Comments:
//
//********************************************************************

int PASCAL WinMain(HANDLE hInstance,HANDLE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)

{
        LPSTR       pszTemp;
        MSG msg;
	fBeVerbose = GetProfileInt("OLEUTEST","BeVerbose",0);

	if(fBeVerbose == 0)
	{
	    fBeVerbose = GetProfileInt("OLEUTEST","spdnd16",0);
	}

        // needed for LRPC to work properly...
        SetMessageQueue(96);

        lpCSimpleApp = new CSimpleApp;

        // we will add one ref count on our App. later when we want to destroy
        // the App object we will release this  ref count. when the App's ref
        // count goes to 0, it will be deleted.
        lpCSimpleApp->AddRef();

        // process the command line

        if( (pszTemp = strstr(lpCmdLine, "-driver")) )
        {
            //we were launched by the test driver
            lpCSimpleApp->m_hDriverWnd = (HWND)strtoul(pszTemp+8, NULL, 10);
        }



        // app initialization
        if (!hPrevInstance)
                if (!lpCSimpleApp->fInitApplication(hInstance))
                        return (FALSE);

        // instance initialization
        if (!lpCSimpleApp->fInitInstance(hInstance, nCmdShow))
                return (FALSE);

        /* Initialization required for OLE 2 UI library.  This call is
        **    needed ONLY if we are using the static link version of the UI
        **    library. If we are using the DLL version, we should NOT call
        **    this function in our application.
        */
        if (!OleUIInitialize(hInstance, hPrevInstance))
                {
                OleDbgOut("Could not initialize OLEUI library\n");
                return FALSE;
                }

        // message loop
        while (GetMessage(&msg, NULL, NULL, NULL))
                if (!lpCSimpleApp->HandleAccelerators(&msg))
                        {
                        TranslateMessage(&msg);    /* Translates virtual key codes */
                        DispatchMessage(&msg);     /* Dispatches message to window */
                        }

        // De-initialization for UI libraries.  Just like OleUIInitialize, this
        // funciton is needed ONLY if we are using the static link version of the
        // OLE UI library.
        OleUIUninitialize();

        // Release the ref count added on the App above. this will make
        // the App's ref count go to 0, and the App object will be deleted.
        lpCSimpleApp->Release();

        return (msg.wParam);          /* Returns the value from PostQuitMessage */
}


//**********************************************************************
//
// MainWndProc
//
// Purpose:
//
//      Processes messages for the frame window
//
// Parameters:
//
//      HWND hWnd       - Window handle for frame window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//      long
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::lCommandHandler     APP.CPP
//      CSimpleApp::DestroyDocs         APP.CPP
//      CSimpleApp::lCreateDoc          APP.CPP
//      CSimpleApp::lSizeHandler        APP.CPP
//      CSimpleDoc::lAddVerbs           DOC.CPP
//      PostQuitMessage                 Windows API
//      DefWindowProc                   Windows API
//
// Comments:
//
//********************************************************************

long FAR PASCAL _export MainWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)

{

        switch (message)
                {
                    case WM_TEST2:
                    StartTest2(lpCSimpleApp);
                    break;
                case WM_TEST1:
                    StartTest1(lpCSimpleApp);
                    break;
                case WM_CLOSE:
                    DestroyWindow(lpCSimpleApp->m_hAppWnd);
                    break;


                case WM_COMMAND:           // message: command from application menu
                        return lpCSimpleApp->lCommandHandler(hWnd, message, wParam, lParam);
                        break;

                case WM_CREATE:
                        return lpCSimpleApp->lCreateDoc(hWnd, message, wParam, lParam);
                        break;

                case WM_DESTROY:                  // message: window being destroyed
                        lpCSimpleApp->DestroyDocs();  // need to destroy the doc...
                        PostQuitMessage(0);
                        break;

                case WM_INITMENUPOPUP:
                        // is this the edit menu?
                        if ( LOWORD(lParam) == 1)
                                return lpCSimpleApp->m_lpDoc->lAddVerbs();

                        break;

                case WM_SIZE:
                        return lpCSimpleApp->lSizeHandler(hWnd, message, wParam, lParam);

                default:                          // Passes it on if unproccessed
                        return (DefWindowProc(hWnd, message, wParam, lParam));
                }
                return (NULL);
}


//**********************************************************************
//
// About
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for dialog box
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//      EndDialog                   Windows API
//
// Comments:
//
//********************************************************************

BOOL FAR PASCAL _export About(HWND hDlg,unsigned message,WORD wParam,LONG lParam)

{
        switch (message) {
        case WM_INITDIALOG:                /* message: initialize dialog box */
                return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
                if (wParam == IDOK                /* "OK" box selected?          */
                || wParam == IDCANCEL) {      /* System menu close command? */
                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                return (TRUE);
                }
                break;
        }
        return (FALSE);                           /* Didn't process a message    */
}

//**********************************************************************
//
// DocWndProc
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for doc window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
// Function Calls:
//      Function                            Location
//
//      CSimpleApp::PaintApp                APP.CPP
//      BeginPaint                          Windows API
//      EndPaint                            Windows API
//      DefWindowProc                       Windows API
//      IOleObject::QueryInterface          Object
//      IOleObject::DoVerb                  Object
//      CSimpleSite::GetObjRect             SITE.CPP
//      CSimpleDoc::QueryDrag               DOC.CPP
//      CSimpleDoc::DoDragDrop              DOC.CPP
//      SetTimer                            Windows API
//      KillTimer                           Windows API
//      SetCapture                          Windows API
//      ReleaseCapture                      Windows API
//
// Comments:
//
//********************************************************************

long FAR PASCAL _export DocWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
        HDC hDC;
        PAINTSTRUCT ps;

        switch (message) {
                case WM_PAINT:

                        hDC = BeginPaint(hWnd, &ps);

                        if (lpCSimpleApp)
                                lpCSimpleApp->PaintApp (hDC);

                        EndPaint(hWnd, &ps);
                        break;

                case WM_LBUTTONDBLCLK:
                        {
                        POINT pt;

                        pt.x = (int)(short)LOWORD (lParam );
                        pt.y = (int)(short)HIWORD (lParam );

                        if (lpCSimpleApp->m_lpDoc->m_lpSite &&
                                lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject)
                                {
                                RECT rect;

                                lpCSimpleApp->m_lpDoc->m_lpSite->GetObjRect(&rect);

                                if ( PtInRect(&rect, pt) )
                                        {
                                        // Execute object's default verb
                                        lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(
                                                        OLEIVERB_PRIMARY, (LPMSG)&message,
                                                        &lpCSimpleApp->m_lpDoc->m_lpSite->m_OleClientSite,
                                                        -1, hWnd, &rect);
                                        }
                                }
                        }
                        break;

                case WM_LBUTTONDOWN:
                        {
                        POINT pt;

                        pt.x = (int)(short)LOWORD (lParam );
                        pt.y = (int)(short)HIWORD (lParam );

                        /* OLE2NOTE: check if this is a button down on the region
                        **    that is a handle to start a drag operation. for us,
                        **    this this is any where in the window. we
                        **    do NOT want to start a drag immediately; we want to
                        **    wait until the mouse moves a certain threshold. or a
                        **    certain amount of time has elapsed. if
                        **    LButtonUp comes before the drag is started, then
                        **    the fPendingDrag state is cleared. we must capture
                        **    the mouse to ensure the modal state is handled
                        **    properly.
                        */
                        if (lpCSimpleApp->m_lpDoc->QueryDrag(pt) )
                                {
                                lpCSimpleApp->m_lpDoc->m_fPendingDrag = TRUE;
                                lpCSimpleApp->m_lpDoc->m_ptButDown = pt;
                                SetTimer(hWnd, 1, lpCSimpleApp->m_nDragDelay, NULL);
                                SetCapture(hWnd);
                                }
                        break;
                        }

                case WM_LBUTTONUP:

                        if (lpCSimpleApp->m_lpDoc->m_fPendingDrag)
                                {
                                /* ButtonUP came BEFORE distance/time threshholds were
                                **    exceeded. clear fPendingDrag state.
                                */
                                ReleaseCapture();
                                KillTimer(hWnd, 1);
                                lpCSimpleApp->m_lpDoc->m_fPendingDrag = FALSE;
                                }
                        break;

                case WM_MOUSEMOVE:
                        {
                        if (lpCSimpleApp->m_lpDoc->m_fPendingDrag)
                                {
                                int  x = (int)(short)LOWORD (lParam );
                                int  y = (int)(short)HIWORD (lParam );
                                POINT pt = lpCSimpleApp->m_lpDoc->m_ptButDown;
                                int nDragMinDist = lpCSimpleApp->m_nDragMinDist;

                                if (! ( ((pt.x - nDragMinDist) <= x)
                                                && (x <= (pt.x + nDragMinDist))
                                                && ((pt.y - nDragMinDist) <= y)
                                                && (y <= (pt.y + nDragMinDist)) ) )
                                        {
                                        // mouse moved beyond threshhold to start drag
                                        ReleaseCapture();
                                        KillTimer(hWnd, 1);
                                        lpCSimpleApp->m_lpDoc->m_fPendingDrag = FALSE;

                                        // perform the modal drag/drop operation.
                                        lpCSimpleApp->m_lpDoc->DoDragDrop( );
                                        }
                                }
                        break;
                        }

                case WM_TIMER:
                        {
                        // drag time delay threshhold exceeded -- start drag
                        ReleaseCapture();
                        KillTimer(hWnd, 1);
                        lpCSimpleApp->m_lpDoc->m_fPendingDrag = FALSE;

                        // perform the modal drag/drop operation.
                        lpCSimpleApp->m_lpDoc->DoDragDrop( );
                        break;
                        }

                default:                          /* Passes it on if unproccessed */
                        return (DefWindowProc(hWnd, message, wParam, lParam));
        }
        return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\site.cpp ===
//**********************************************************************
// File name: SITE.CPP
//
//      Implementation file for CSimpleSite
//
// Functions:
//
//      See SITE.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CSimpleSite::Create
//
// Purpose:
//
//      Creation routine for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      IStorage::CreateStorage     OLE API
//      assert                      C Runtime
//
// Comments:
//
//********************************************************************

CSimpleSite FAR * CSimpleSite::Create(CSimpleDoc FAR *lpDoc)
{
        CSimpleSite FAR * lpTemp = new CSimpleSite(lpDoc);

        if (!lpTemp)
                return NULL;

        // create a sub-storage for the object
        HRESULT hErr = lpDoc->m_lpStorage->CreateStorage( "Object",
                                STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
                                0,
                                0,
                                &lpTemp->m_lpObjStorage);

        assert(hErr == NOERROR);

        if (hErr != NOERROR)
                {
                delete lpTemp;
                return NULL;
                }

        // we will add one ref count on our Site. later when we want to destroy
        // the Site object we will release this  ref count. when the Site's ref
        // count goes to 0, it will be deleted.
        lpTemp->AddRef();

        return lpTemp;
}

//**********************************************************************
//
// CSimpleSite::CSimpleSite
//
// Purpose:
//
//      Constructor for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
// Comments:
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
                                                                // tells us that we are passing this in
                                                                // an initializer, before "this" is through
                                                                // initializing.  This is ok, because
                                                                // we just store the ptr in the other
                                                                // constructors

CSimpleSite::CSimpleSite (CSimpleDoc FAR *lpDoc) : m_OleClientSite(this),
                                                                                                 m_AdviseSink(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
        // remember the pointer to the doc
        m_lpDoc = lpDoc;

        // clear the reference count
        m_nCount = 0;

        m_dwDrawAspect = DVASPECT_CONTENT;
        m_lpOleObject = NULL;
        m_fObjectOpen = FALSE;
}

//**********************************************************************
//
// CSimpleSite::~CSimpleSite
//
// Purpose:
//
//      Destructor for CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

CSimpleSite::~CSimpleSite ()
{
        TestDebugOut ("In CSimpleSite's Destructor \r\n");

        if (m_lpOleObject)
           m_lpOleObject->Release();

        if (m_lpObjStorage)
           m_lpObjStorage->Release();
}


//**********************************************************************
//
// CSimpleSite::CloseOleObject
//
// Purpose:
//
//      Call IOleObject::Close on the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Close                       Object
//
// Comments:
//
//********************************************************************

void CSimpleSite::CloseOleObject (void)
{
        LPVIEWOBJECT lpViewObject = NULL;

        TestDebugOut ("In CSimpleSite::CloseOleObject \r\n");

        if (m_lpOleObject)
           {
           m_lpOleObject->Close(OLECLOSE_NOSAVE);
           }
}


//**********************************************************************
//
// CSimpleSite::UnloadOleObject
//
// Purpose:
//
//      Close and release all pointers to the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      CSimpleSite::CloseOleObject             SITE.CPP
//      IOleObject::QueryInterface              Object
//      IViewObject::SetAdvise                  Object
//      IViewObject::Release                    Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

void CSimpleSite::UnloadOleObject (void)
{
        TestDebugOut ("In CSimpleSite::UnloadOleObject \r\n");

        if (m_lpOleObject)
           {
           LPVIEWOBJECT lpViewObject;
           CloseOleObject();    // ensure object is closed; NOP if already closed

           m_lpOleObject->QueryInterface(IID_IViewObject, (LPVOID FAR *)&lpViewObject);

           if (lpViewObject)
                   {
                   // Remove the view advise
                   lpViewObject->SetAdvise(m_dwDrawAspect, 0, NULL);
                   lpViewObject->Release();
                   }

           m_lpOleObject->Release();
           m_lpOleObject = NULL;
           }
}


//**********************************************************************
//
// CSimpleSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the container Site.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      CSimpleSite::AddRef          OBJ.CPP
//      COleClientSite::AddRef      IOCS.CPP
//      CAdviseSink::AddRef         IAS.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CSimpleSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
        TestDebugOut("In CSimpleSite::QueryInterface\r\n");

        *ppvObj = NULL;     // must set out pointer parameters to NULL

        if ( riid == IID_IUnknown)
                {
                AddRef();
                *ppvObj = this;
                return ResultFromScode(S_OK);
                }

        if ( riid == IID_IOleClientSite)
                {
                m_OleClientSite.AddRef();
                *ppvObj = &m_OleClientSite;
                return ResultFromScode(S_OK);
                }

        if ( riid == IID_IAdviseSink)
                {
                m_AdviseSink.AddRef();
                *ppvObj = &m_AdviseSink;
                return ResultFromScode(S_OK);
                }

        // Not a supported interface
        return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the container Site.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the site.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::AddRef()
{
        TestDebugOut("In CSimpleSite::AddRef\r\n");

        return ++m_nCount;
}

//**********************************************************************
//
// CSimpleSite::Release
//
// Purpose:
//
//      Decrements the reference count of the container Site
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Site.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::Release()
{
        TestDebugOut("In CSimpleSite::Release\r\n");

        if (--m_nCount == 0) {
                delete this;
                return 0;
        }
        return m_nCount;
}

//**********************************************************************
//
// CSimpleSite::InitObject
//
// Purpose:
//
//      Used to initialize a newly create object (can't be done in the
//      constructor).
//
// Parameters:
//
//      BOOL fCreateNew -   TRUE if insert NEW object
//                          FALSE if create object FROM FILE
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::SetHostNames        Object
//      IOleObject::QueryInterface      Object
//      IViewObject2::GetExtent         Object
//      IOleObject::DoVerb              Object
//      IViewObject::SetAdvise          Object
//      IViewObject::Release            Object
//      GetClientRect                   Windows API
//      OleSetContainedObject           OLE API
//
// Comments:
//
//********************************************************************

HRESULT CSimpleSite::InitObject(BOOL fCreateNew)
{
    LPVIEWOBJECT2 lpViewObject2;
    RECT rect;
    HRESULT hRes;

    // Set a View Advise
    hRes = m_lpOleObject->QueryInterface(IID_IViewObject2,
                                  (LPVOID FAR *)&lpViewObject2);
    if (hRes == ResultFromScode(S_OK))
    {
       hRes = lpViewObject2->SetAdvise(m_dwDrawAspect, ADVF_PRIMEFIRST,
                                &m_AdviseSink);

       if( FAILED(hRes))
       {
                goto errRtn;
       }
       // get the initial size of the object

       hRes = lpViewObject2->GetExtent(m_dwDrawAspect, -1 /*lindex*/, NULL /*ptd*/,
                                &m_sizel);

       //
       // Is OK if the object is actually blank
       //
       if( FAILED(hRes) && (GetScode(hRes) !=  OLE_E_BLANK) )
       {
                goto errRtn;
       }

       lpViewObject2->Release();
    }
    GetObjRect(&rect);  // get the rectangle of the object in pixels

    // give the object the name of the container app/document
    hRes  = m_lpOleObject->SetHostNames("Simple Application",
                                "Simple OLE 2.0 Drag/Drop Container");

    if( FAILED(hRes) )
    {
       goto errRtn;
    }

    // inform object handler/DLL object that it is used in the embedding
    // container's context
    if (OleSetContainedObject(m_lpOleObject, TRUE) != ResultFromScode(S_OK))
    {
       TestDebugOut("Fail in OleSetContainedObject\n");
    }

    if (fCreateNew)
    {
       // force new object to save to guarantee valid object in our storage.
       // OLE 1.0 objects may close w/o saving. this is NOT necessary if the
       // object is created FROM FILE; its data in storage is already valid.
       m_OleClientSite.SaveObject();

       // we only want to DoVerb(SHOW) if this is an InsertNew object.
       // we should NOT DoVerb(SHOW) if the object is created FromFile.
       hRes = m_lpOleObject->DoVerb(
               OLEIVERB_SHOW,
               NULL,
               &m_OleClientSite,
               -1,
               m_lpDoc->m_hDocWnd,
               &rect);
    }

errRtn:
    return hRes;

}

//**********************************************************************
//
// CSimpleSite::PaintObj
//
// Purpose:
//
//      Paints the object
//
// Parameters:
//
//      HDC hDC     - Device context of the document window
//
// Return Value:
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::QueryInterface      Object
//      IViewObject::GetColorSet        Object
//      IViewObject::Release            Object
//      SetMapMode                      Windows API
//      LPtoDP                          Windows API
//      CreateHatchBrush                Windows API
//      SelectObject                    Windows API
//      DeleteObject                    Windows API
//      CreatePalette                   Windows API
//      SelectPalette                   Windows API
//      RealizePalette                  Windows API
//      OleStdFree                      OUTLUI Function
//      OleDraw                         OLE API
//
// Comments:
//
//********************************************************************

void CSimpleSite::PaintObj(HDC hDC)
{
RECT rect;

        // need to check to make sure there is a valid object
        // available.  This is needed if there is a paint msg
        // between the time that CSimpleSite is instantiated
        // and OleUIInsertObject returns.
        if (!m_lpOleObject)
                return;

        // convert it to pixels
        GetObjRect(&rect);

        LPLOGPALETTE pColorSet = NULL;
        LPVIEWOBJECT lpView = NULL;

        // get a pointer to IViewObject
        m_lpOleObject->QueryInterface(IID_IViewObject,(LPVOID FAR *) &lpView);

        // if the QI succeeds, get the LOGPALETTE for the object
        if (lpView)
                lpView->GetColorSet(m_dwDrawAspect, -1, NULL, NULL, NULL, &pColorSet);

        HPALETTE hPal=NULL;
        HPALETTE hOldPal=NULL;

        // if a LOGPALETTE was returned (not guarateed), create the palette and
        // realize it.  NOTE: A smarter application would want to get the LOGPALETTE
        // for each of its visible objects, and try to create a palette that
        // satisfies all of the visible objects.  ALSO: OleStdFree() is use to
        // free the returned LOGPALETTE.
        if ((pColorSet))
                {
                hPal = CreatePalette((const LPLOGPALETTE) pColorSet);
                hOldPal = SelectPalette(hDC, hPal, FALSE);
                RealizePalette(hDC);
                OleStdFree(pColorSet);
                }

        // draw the object
        OleDraw(m_lpOleObject, m_dwDrawAspect, hDC, &rect);

        // if the object is open, draw a hatch rect.
        if (m_fObjectOpen)
                {
                HBRUSH hBrush = CreateHatchBrush ( HS_BDIAGONAL, RGB(0,0,0) );
                HBRUSH hOldBrush = SelectObject (hDC, hBrush);
                SetROP2(hDC, R2_MASKPEN);
                Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom);
                SelectObject(hDC, hOldBrush);
                DeleteObject(hBrush);
                }

        // if we created a palette, restore the old one, and destroy
        // the object.
        if (hPal)
                {
                SelectPalette(hDC,hOldPal,FALSE);
                DeleteObject(hPal);
                }

        // if a view pointer was successfully returned, it needs to be released.
        if (lpView)
                lpView->Release();
}

//**********************************************************************
//
// CSimpleSite::GetObjRect
//
// Purpose:
//
//      Retrieves the rect of the object in pixels
//
// Parameters:
//
//      LPRECT lpRect - Rect structure filled with object's rect in pixels
//
// Return Value:
//
// Function Calls:
//      Function                        Location
//
//      XformWidthInHimetricToPixels    OUTLUI Function
//      XformHeightInHimetricToPixels   OUTLUI Function
//
// Comments:
//
//********************************************************************

void CSimpleSite::GetObjRect(LPRECT lpRect)
{
        // convert it to pixels
        lpRect->left = lpRect->top = 0;
        lpRect->right = XformWidthInHimetricToPixels(NULL,(int)m_sizel.cx);
        lpRect->bottom = XformHeightInHimetricToPixels(NULL,(int)m_sizel.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\site.h ===
//**********************************************************************
// File name: SITE.H
//
//      Definition of CSimpleSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _SITE_H_ )
#define _SITE_H_

#include <ole2.h>
#include "ias.h"
#include "iocs.h"

class CSimpleDoc;

class CSimpleSite : public IUnknown
{
public:
        int m_nCount;
        LPOLEOBJECT m_lpOleObject;
        DWORD m_dwDrawAspect;
        SIZEL m_sizel;
        BOOL m_fObjectOpen;
        LPSTORAGE m_lpObjStorage;

        CAdviseSink m_AdviseSink;
        COleClientSite m_OleClientSite;

        CSimpleDoc FAR * m_lpDoc;

        // IUnknown Interfaces
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        HRESULT InitObject(BOOL fCreateNew);
        static CSimpleSite FAR * Create(CSimpleDoc FAR *lpDoc);
        CSimpleSite(CSimpleDoc FAR *lpDoc);
        ~CSimpleSite();
        void PaintObj(HDC hDC);
        void GetObjRect(LPRECT lpRect);
        void CloseOleObject(void);
        void UnloadOleObject(void);
};

#endif  // _SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\app.h ===
//**********************************************************************
// File name: app.h
//
//      Definition of CSimpSvrApp
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _APP_H_)
#define _APP_H_

class CSimpSvrDoc;
interface CClassFactory;

class CSimpSvrApp : public IUnknown
{
private:

	int m_nCount;               // reference count
	HWND m_hAppWnd;             // main window handle
	HINSTANCE m_hInst;          // application instance
	BOOL m_fStartByOle;         // TRUE if app started by OLE
	DWORD m_dwRegisterClass;    // returned by RegisterClassFactory

	HMENU m_hMainMenu;
	HMENU m_hColorMenu;
	HMENU m_hHelpMenu;


	LPOLEOBJECT m_OleObject;    // pointer to "dummy" object


	CSimpSvrDoc FAR * m_lpDoc;   // pointer to document object
	BOOL m_fInitialized;         // OLE initialization flag

	RECT nullRect;               // used in inplace negotiation

public:
	// IUnknown Interfaces
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Initialization methods

	CSimpSvrApp();           // Constructor
	~CSimpSvrApp();          // Destructor


	BOOL fInitApplication (HANDLE hInstance);
	BOOL fInitInstance (HANDLE hInstance, int nCmdShow, CClassFactory FAR * lpClassFactory);

	// Message handling methods

	long lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	long lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	long lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	void PaintApp(HDC hDC);

	//  Utility functions
	void ParseCmdLine(LPSTR lpCmdLine);
	void SetStatusText();
	BOOL IsInPlaceActive();
	void ShowAppWnd(int nCmdShow=SW_SHOWNORMAL);
	void HideAppWnd();


	// member variable access
	inline HWND GethAppWnd() { return m_hAppWnd; };
	inline HINSTANCE GethInst() { return m_hInst; };
	inline BOOL IsStartedByOle() { return m_fStartByOle; };
	inline BOOL IsInitialized() { return m_fInitialized; };
	inline DWORD GetRegisterClass() { return m_dwRegisterClass; };
	inline CSimpSvrDoc FAR * GetDoc() { return m_lpDoc; };
	inline void ClearDoc() { m_lpDoc = NULL; };
	inline LPOLEOBJECT GetOleObject() { return m_OleObject; };
		inline HMENU GetMainMenu() { return m_hMainMenu; };
	inline HMENU GetColorMenu() { return m_hColorMenu; };
	inline HMENU GetHelpMenu() { return m_hHelpMenu; } ;


	friend interface CClassFactory;  // make the contained class a friend
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpdnd\tests.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       tests.cpp
//
//  Contents:   Implementations of the Upper Layer unit tests
//
//  Classes:
//
//  Functions:  StartTest1
//
//  History:    dd-mmm-yy Author    Comment
//              07-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <testmess.h>

#ifdef WIN32
const CLSID CLSID_SimpleServer = {0xbcf6d4a0, 0xbe8c, 0x1068, { 0xb6, 0xd4,
        0x00, 0xdd, 0x01, 0x0c, 0x05, 0x09 }};
#else
const CLSID CLSID_SimpleServer = {0x9fb878d0, 0x6f88, 0x101b, { 0xbc, 0x65,
        0x00, 0x00, 0x0b, 0x65, 0xc7, 0xa6 }};
#endif



const CLSID CLSID_Paintbrush = {0x0003000a, 0, 0, { 0xc0, 0,0,0,0,0,0,0x46 }};

//+-------------------------------------------------------------------------
//
//  Function:   StartTest1
//
//  Synopsis:   Starts unit test1, inserting a simple server object into
//              this (simpdnd) container.
//
//  Effects:
//
//  Arguments:  pApp    -- a pointer to the CSimpleApp that we're a part of
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              07-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void StartTest1( CSimpleApp *pApp )
{
        HRESULT hresult;
        static FORMATETC formatetc;

        //insert the simple server object

        formatetc.dwAspect = DVASPECT_CONTENT;
        formatetc.cfFormat = NULL;
        formatetc.lindex = -1;

        //need to create the client site

        pApp->m_lpDoc->m_lpSite = CSimpleSite::Create(pApp->m_lpDoc);

        hresult = OleCreate(CLSID_SimpleServer, IID_IOleObject,
                OLERENDER_DRAW, &formatetc,
                &pApp->m_lpDoc->m_lpSite->m_OleClientSite,
                pApp->m_lpDoc->m_lpSite->m_lpObjStorage,
                (void **)&(pApp->m_lpDoc->m_lpSite->m_lpOleObject));

        if( hresult != NOERROR )
        {
                goto errRtn;
        }

        //initialize the object

        hresult = pApp->m_lpDoc->m_lpSite->InitObject(TRUE);

        if( hresult == NOERROR )
        {
                //tell it to paint itself, then we'll quit
                PostMessage(pApp->m_lpDoc->m_hDocWnd, WM_PAINT, 0L, 0L);
                PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_SUCCESS,
                (LPARAM)hresult);
                PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                return;
        }

errRtn:
        PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_FAILURE,
                (LPARAM)hresult);
        PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
        return;
}


//+-------------------------------------------------------------------------
//
//  Function:   StartTest2
//
//  Synopsis:   Starts unit Test2, inserting a paintbrush object into
//              this (simpdnd) container.
//
//  Effects:
//
//  Arguments:  pApp    -- a pointer to the CSimpleApp that we're a part of
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kevinro & alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void StartTest2( CSimpleApp *pApp )
{
        HRESULT hresult;
        static FORMATETC formatetc;

        //insert the simple server object

        formatetc.dwAspect = DVASPECT_CONTENT;
        formatetc.cfFormat = NULL;
        formatetc.lindex = -1;

        //need to create the client site

        pApp->m_lpDoc->m_lpSite = CSimpleSite::Create(pApp->m_lpDoc);

        hresult = OleCreate(CLSID_Paintbrush, IID_IOleObject,
                OLERENDER_DRAW, &formatetc,
                &pApp->m_lpDoc->m_lpSite->m_OleClientSite,
                pApp->m_lpDoc->m_lpSite->m_lpObjStorage,
                (void **)&(pApp->m_lpDoc->m_lpSite->m_lpOleObject));

        if( hresult != NOERROR )
        {
                goto errRtn;
        }

        //initialize the object

        hresult = pApp->m_lpDoc->m_lpSite->InitObject(TRUE);

        //
        // The DDE layer is going to ignore all of the parameters except
        // the verb index. The parameters here are mostly dummies.
        //
        if (hresult == NOERROR)
        {
                hresult = pApp->m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(0,
                                NULL,
                                &(pApp->m_lpDoc->m_lpSite->m_OleClientSite),
                                -1,
                                NULL,
                                NULL);
        }

        if( hresult == NOERROR )
        {
                //tell it to paint itself, then we'll quit
                PostMessage(pApp->m_lpDoc->m_hDocWnd, WM_PAINT, 0L, 0L);
                PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_SUCCESS,
                (LPARAM)hresult);
                PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                return;
        }

errRtn:
        PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_FAILURE,
                (LPARAM)hresult);
        PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\doc.h ===
//**********************************************************************
// File name: doc.h
//
//      Definition of CSimpSvrDoc
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DOC_H_ )
#define _DOC_H_

class CSimpSvrApp;
class CSimpSvrObj;

class CSimpSvrDoc : IUnknown
{
private:
	int m_nCount;

	CSimpSvrApp FAR * m_lpApp;
	CSimpSvrObj FAR * m_lpObj;

	HWND m_hDocWnd;
	HWND m_hHatchWnd;
	BOOL m_fClosing;

public:
	static CSimpSvrDoc FAR * Create(CSimpSvrApp FAR *lpApp, LPRECT lpRect,HWND hWnd);

	CSimpSvrDoc();
	CSimpSvrDoc(CSimpSvrApp FAR *lpApp, HWND hWnd);
	~CSimpSvrDoc();

// IUnknown Interfaces
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	long lResizeDoc(LPRECT lpRect);
	long lAddVerbs();

	BOOL Load(LPSTR lpszFileName);
	void PaintDoc(HDC hDC);
	void lButtonDown(WPARAM wParam,LPARAM lParam);

	HRESULT CreateObject(REFIID riid, LPVOID FAR *ppvObject);

	void Close();
	void SetStatusText();
	void ShowDocWnd();
	void ShowHatchWnd();
	void CSimpSvrDoc::HideDocWnd();
	void CSimpSvrDoc::HideHatchWnd();

// member access
	inline HWND GethDocWnd() { return m_hDocWnd; };
	inline HWND GethHatchWnd() { return m_hHatchWnd; };
	inline HWND GethAppWnd() { return m_lpApp->GethAppWnd(); };
	inline CSimpSvrApp FAR * GetApp() { return m_lpApp; };
	inline CSimpSvrObj FAR * GetObj() { return m_lpObj; };
	inline void ClearObj() { m_lpObj = NULL; };

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\icf.h ===
//**********************************************************************
// File name: icf.h
//
//      Definition of CClassFactory
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _ICF_H_)
#define _ICF_H_

class CSimpSvrApp;

interface CClassFactory :  IClassFactory
{
private:
	int m_nCount;               // reference count
	CSimpSvrApp FAR * m_lpApp;

public:
	CClassFactory::CClassFactory(CSimpSvrApp FAR * lpApp)
		{
		TestDebugOut("In CClassFactory's Constructor\r\n");
		m_lpApp = lpApp;
		m_nCount = 0;
		};
	CClassFactory::~CClassFactory()
	   {
	   TestDebugOut("In CClassFactory's Destructor\r\n");
	   };

	// IUnknown Methods

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP CreateInstance (LPUNKNOWN pUnkOuter,
							  REFIID riid,
							  LPVOID FAR* ppvObject);
	STDMETHODIMP LockServer ( BOOL fLock);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\ido.cpp ===
//**********************************************************************
// File name: IDO.CPP
//
//    Implementation file for the CDataObject Class
//
// Functions:
//
//    See ido.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ido.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CDataObject::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In CDataObject::QueryInterface\r\n");

	return m_lpObj->QueryInterface(riid, ppvObj);
};

//**********************************************************************
//
// CDataObject::AddRef
//
// Purpose:
//
//      Increments the reference count on CClassFactory and the application
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on CDataObject
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataObject::AddRef ()
{
	TestDebugOut("In CDataObject::AddRef\r\n");
	++m_nCount;
	return m_lpObj->AddRef();
};

//**********************************************************************
//
// CDataObject::Release
//
// Purpose:
//
//      Decrements the reference count of CDataObject
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP_(ULONG) CDataObject::Release ()
{
	TestDebugOut("In CDataObject::Release\r\n");
	--m_nCount;
	return m_lpObj->Release();
};

//**********************************************************************
//
// CDataObject::QueryGetData
//
// Purpose:
//
//      Called to determine if our object supports a particular
//      FORMATETC.
//
// Parameters:
//
//      LPFORMATETC pformatetc  - Pointer to the FORMATETC being queried for.
//
// Return Value:
//
//      DATA_E_FORMATETC    - The FORMATETC is not supported
//      S_OK                - The FORMATETC is supported.
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::QueryGetData  ( LPFORMATETC pformatetc )
{
	SCODE sc = DATA_E_FORMATETC;

	TestDebugOut("In CDataObject::QueryGetData\r\n");

	// check the validity of the formatetc.
	if ( (pformatetc->cfFormat == CF_METAFILEPICT)  &&
		 (pformatetc->dwAspect == DVASPECT_CONTENT) &&
		 (pformatetc->tymed == TYMED_MFPICT) )
		sc = S_OK;

	return ResultFromScode(sc);
};

//**********************************************************************
//
// CDataObject::DAdvise
//
// Purpose:
//
//      Called by the container when it would like to be notified of
//      changes in the object data.
//
// Parameters:
//
//      FORMATETC FAR* pFormatetc   - The format the container is interested in.
//
//      DWORD advf                  - The type of advise to be set up.
//
//      LPADVISESINK pAdvSink       - Pointer to the containers IAdviseSink
//
//      DWORD FAR* pdwConnection    - Out parameter to return a unique connection id.
//
// Return Value:
//
//      passed on from IDataAdviseHolder
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CreateDataAdviseHolder      OLE API
//      IDataAdviseHolder::Advise   OLE API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::DAdvise  ( FORMATETC FAR* pFormatetc, DWORD advf,
									 LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
	TestDebugOut("In CDataObject::DAdvise\r\n");

	// if no DataAdviseHolder has been created, then create one.
	if (!m_lpObj->m_lpDataAdviseHolder)
		CreateDataAdviseHolder(&m_lpObj->m_lpDataAdviseHolder);

	// pass on to the DataAdviseHolder
	return m_lpObj->m_lpDataAdviseHolder->Advise( this, pFormatetc, advf,
												  pAdvSink, pdwConnection);
}

//**********************************************************************
//
// CDataObject::GetData
//
// Purpose:
//
//      Returns the data in the format specified in pformatetcIn.
//
// Parameters:
//
//      LPFORMATETC pformatetcIn    -   The format requested by the caller
//
//      LPSTGMEDIUM pmedium         -   The medium requested by the caller
//
// Return Value:
//
//      DATA_E_FORMATETC    - Format not supported
//      S_OK                - Success
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      CSimpSvrObj::GetMetaFilePict()  OBJ.CPP
//      ResultFromScode                 OLE API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::GetData  ( LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium )
{
	SCODE sc = DATA_E_FORMATETC;

	TestDebugOut("In CDataObject::GetData\r\n");

	// Check to the FORMATETC and fill pmedium if valid.
	if ( (pformatetcIn->cfFormat == CF_METAFILEPICT)  &&
		 (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
		 (pformatetcIn->tymed & TYMED_MFPICT) )
		{
		HANDLE hmfPict = m_lpObj->GetMetaFilePict();
		pmedium->tymed = TYMED_MFPICT;
		pmedium->hGlobal = hmfPict;
		pmedium->pUnkForRelease = NULL;
		sc = S_OK;
		}

	return ResultFromScode( sc );
};

//**********************************************************************
//
// CDataObject::DUnadvise
//
// Purpose:
//
//      Breaks down an Advise connection.
//
// Parameters:
//
//      DWORD dwConnection  - Advise connection ID.
//
// Return Value:
//
//      Returned from the DataAdviseHolder.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IDataAdviseHolder::Unadvise OLE
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::DUnadvise  ( DWORD dwConnection)
{
	TestDebugOut("In CDataObject::DUnadvise\r\n");

	if (m_lpObj != NULL && m_lpObj->m_lpDataAdviseHolder != NULL)
	{
	    return m_lpObj->m_lpDataAdviseHolder->Unadvise(dwConnection);
	}
	
	return ResultFromScode( E_UNEXPECTED);


};

//**********************************************************************
//
// CDataObject::GetDataHere
//
// Purpose:
//
//      Called to get a data format in a caller supplied location
//
// Parameters:
//
//      LPFORMATETC pformatetc  - FORMATETC requested
//
//      LPSTGMEDIUM pmedium     - Medium to return the data
//
// Return Value:
//
//      DATA_E_FORMATETC    - We don't support the requested format
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      In this simple implementation, we don't really support this
//      method, we just always return DATA_E_FORMATETC.
//
//********************************************************************


STDMETHODIMP CDataObject::GetDataHere  ( LPFORMATETC pformatetc,
										 LPSTGMEDIUM pmedium )
{
	TestDebugOut("In CDataObject::GetDataHere\r\n");
	return ResultFromScode( DATA_E_FORMATETC);
};

//**********************************************************************
//
// CDataObject::GetCanonicalFormatEtc
//
// Purpose:
//
//      Returns a FORMATETC that is equivalent to the one passed in.
//
// Parameters:
//
//      LPFORMATETC pformatetc      - FORMATETC to be tested.
//
//      LPFORMATETC pformatetcOut   - Out ptr for returned FORMATETC.
//
// Return Value:
//
//      DATA_S_SAMEFORMATETC    - Use the same formatetc as was passed.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CoGetMalloc                 OLE API
//      IMalloc::Alloc              OLE
//      IMalloc::Release            OLE
//      _fmemcpy                    C run-time
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::GetCanonicalFormatEtc  ( LPFORMATETC pformatetc,
												   LPFORMATETC pformatetcOut)
{
	HRESULT hresult;
	TestDebugOut("In CDataObject::GetCanonicalFormatEtc\r\n");

	if (!pformatetcOut)
		return ResultFromScode(E_INVALIDARG);

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	pformatetcOut->ptd = NULL;

	if (!pformatetc)
		return ResultFromScode(E_INVALIDARG);

	// OLE2NOTE: we must validate that the format requested is supported
	if ((hresult = QueryGetData(pformatetc)) != NOERROR)
		return hresult;

	/* OLE2NOTE: an app that is insensitive to target device (as
	**    SimpSvr is) should fill in the lpformatOut parameter
	**    but NULL out the "ptd" field; it should return NOERROR if the
	**    input formatetc->ptd what non-NULL. this tells the caller
	**    that it is NOT necessary to maintain a separate screen
	**    rendering and printer rendering. if should return
	**    DATA_S_SAMEFORMATETC if the input and output formatetc's are
	**    identical.
	*/

	*pformatetcOut = *pformatetc;
	if (pformatetc->ptd == NULL)
		return ResultFromScode(DATA_S_SAMEFORMATETC);
	else
		{
		pformatetcOut->ptd = NULL;
		return NOERROR;
		}
};

//**********************************************************************
//
// CDataObject::SetData
//
// Purpose:
//
//      Called to set the data for the object.
//
// Parameters:
//
//      LPFORMATETC pformatetc      - the format of the data being passed
//
//      STGMEDIUM FAR * pmedium     - the location of the data.
//
//      BOOL fRelease               - Defines the ownership of the medium
//
// Return Value:
//
//      DATA_E_FORMATETC    - Not a valid FORMATETC for this object
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This simple object does not support having its data set, so an
//      error value is always returned.
//
//********************************************************************


STDMETHODIMP CDataObject::SetData  ( LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
									 BOOL fRelease)
{
	TestDebugOut("In CDataObject::SetData\r\n");
	return ResultFromScode( DATA_E_FORMATETC );
};

//**********************************************************************
//
// CDataObject::EnumFormatEtc
//
// Purpose:
//
//      Enumerates the formats supported by this object.
//
// Parameters:
//
//      DWORD dwDirection                       - Order of enumeration.
//
//      LPENUMFORMATETC FAR* ppenumFormatEtc    - Place to return a pointer
//                                                to the enumerator.
//
// Return Value:
//
//      OLE_S_USEREG    - Indicates that OLE should consult the REG DB
//                        to enumerate the formats.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CDataObject::EnumFormatEtc  ( DWORD dwDirection,
										   LPENUMFORMATETC FAR* ppenumFormatEtc)
{
	TestDebugOut("In CDataObject::EnumFormatEtc\r\n");
	// need to NULL the out parameter
	*ppenumFormatEtc = NULL;
	return ResultFromScode( OLE_S_USEREG );
};

//**********************************************************************
//
// CDataObject::EnumDAdvise
//
// Purpose:
//
//      Returns an enumerator that enumerates all of the advises
//      set up on this data object.
//
// Parameters:
//
//      LPENUMSTATDATA FAR* ppenumAdvise    - An out ptr in which to
//                                            return the enumerator.
//
// Return Value:
//
//      Passed back from IDataAdviseHolder::EnumAdvise
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      IDAtaAdviseHolder::EnumAdvise   OLE
//
// Comments:
//
//      This just delegates to the DataAdviseHolder.
//
//********************************************************************


STDMETHODIMP CDataObject::EnumDAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise)
{
	TestDebugOut("In CDataObject::EnumDAdvise\r\n");
	// need to NULL the out parameter
	*ppenumAdvise = NULL;

	return m_lpObj->m_lpDataAdviseHolder->EnumAdvise(ppenumAdvise);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\app.cpp ===
//**********************************************************************
// File name: app.cpp
//
//    Implementation file for the CSimpSvrApp Class
//
// Functions:
//
//    See app.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "app.h"
#include "doc.h"
#include "icf.h"

#include "initguid.h"

#ifdef WIN32
DEFINE_GUID(GUID_SIMPLE, 0xBCF6D4A0, 0xBE8C, 0x1068, 0xB6, 0xD4, 0x00, 0xDD, 0x01, 0x0C, 0x05, 0x09);
#else
DEFINE_GUID(GUID_SIMPLE, 0x9fb878d0, 0x6f88, 0x101b, 0xbc, 0x65, 0x00, 0x00, 0x0b, 0x65, 0xc7, 0xa6);
#endif



//**********************************************************************
//
// CSimpSvrApp::CSimpSvrApp()
//
// Purpose:
//
//      Constructor for CSimpSvrApp
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetRectEmpty                Windows API
//
// Comments:
//
//
//********************************************************************

CSimpSvrApp::CSimpSvrApp()
{
        TestDebugOut("In CSimpSvrApp's Constructor \r\n");

        // Set Ref Count
        m_nCount = 0;

        // clear members
        m_hAppWnd = NULL;
        m_hInst = NULL;
        m_lpDoc = NULL;

        // clear flags
        m_fInitialized = FALSE;

        // used for inplace
        SetRectEmpty(&nullRect);
}

//**********************************************************************
//
// CSimpSvrApp::~CSimpSvrApp()
//
// Purpose:
//
//      Destructor for CSimpSvrApp Class.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DestroyWindow               Windows API
//      CSimpSvrApp::IsInitialized  APP.H
//      OleUninitialize             OLE API
//
// Comments:
//
//********************************************************************

CSimpSvrApp::~CSimpSvrApp()
{
        TestDebugOut("In CSimpSvrApp's Destructor\r\n");

        // need to uninit the library...
        if (IsInitialized())
                OleUninitialize();

        DestroyWindow(m_hAppWnd);
}


//**********************************************************************
//
// CSimpSvrApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the Application level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK          -   The interface is supported.
//      E_NOINTERFACE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      IUnknown::AddRef            APP.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CSimpSvrApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
        TestDebugOut("In CSimpSvrApp::QueryInterface\r\n");

        SCODE sc = S_OK;

        if (riid == IID_IUnknown)
                *ppvObj = this;
        else
                {
                *ppvObj = NULL;
                sc = E_NOINTERFACE;
                }

        if (*ppvObj)
                ((LPUNKNOWN)*ppvObj)->AddRef();

        // asking for something we don't understand at this level.
        return ResultFromScode(sc);
}

//**********************************************************************
//
// CSimpSvrApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Application level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrApp::AddRef()
{
        TestDebugOut("In CSimpSvrApp::AddRef\r\n");
        return ++m_nCount;
}

//**********************************************************************
//
// CSimpSvrApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrApp::Release()
{
        TestDebugOut("In CSimpSvrApp::Release\r\n");

        if (--m_nCount == 0) {
                delete this;
        return 0;
    }

        return m_nCount;
}

//**********************************************************************
//
// CSimpSvrApp::fInitApplication
//
// Purpose:
//
//      Initializes the application
//
// Parameters:
//
//      HANDLE hInstance    -   Instance handle of the application.
//
// Return Value:
//
//      TRUE    -   Application was successfully initialized.
//      FALSE   -   Application could not be initialized
//
// Function Calls:
//      Function                    Location
//
//      LoadIcon                    Windows API
//      LoadCursor                  Windows API
//      GetStockObject              Windows API
//      RegisterClass               Windows API
//      RegisterHatchWindowClass    OUTLUI.DLL
//
// Comments:
//
//********************************************************************

BOOL CSimpSvrApp::fInitApplication(HANDLE hInstance)
{
        WNDCLASS  wc;

        // Fill in window class structure with parameters that describe the
        // main window.

        wc.style = NULL;                    // Class style(s).
        wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for
                                                                                // windows of this class.
        wc.cbClsExtra = 0;                  // No per-class extra data.
        wc.cbWndExtra = 0;                  // No per-window extra data.
        wc.hInstance = hInstance;           // Application that owns the class.
        wc.hIcon = LoadIcon(hInstance, "SimpSvr");
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
        wc.lpszMenuName =  "SimpSvrMENU";    // Name of menu resource in .RC file.
        wc.lpszClassName = "SimpSvrWClass";  // Name used in call to CreateWindow.

        if (!RegisterClass(&wc))
                return FALSE;

        wc.style = CS_VREDRAW | CS_HREDRAW;                    // Class style(s).
        wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for
                                                                                // windows of this class.
        wc.cbClsExtra = 0;                  // No per-class extra data.
        wc.cbWndExtra = 0;                  // No per-window extra data.
        wc.hInstance = hInstance;           // Application that owns the class.
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
        wc.lpszMenuName =  NULL;
        wc.lpszClassName = "DocWClass";     // Name used in call to CreateWindow.

        // Register the window class and return success/failure code.

        if (!RegisterClass(&wc))
                return FALSE;

        return (RegisterHatchWindowClass(hInstance));
}

//**********************************************************************
//
// CSimpSvrApp::fInitInstance
//
// Purpose:
//
//      Instance initialization.
//
// Parameters:
//
//      HANDLE hInstance    -   App. Instance Handle.
//
//      int nCmdShow        -   Show parameter from WinMain
//
// Return Value:
//
//      TRUE    -   Initialization Successful
//      FALSE   -   Initialization Failed.
//
//
// Function Calls:
//      Function                    Location
//
//      CreateWindow                Windows API
//      InvalidateRect              Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      CoRegisterClassObject       OLE API
//      OleBuildVersion             OLE API
//      OleInitialize               OLE API
//      CSimpSvrDoc::CreateObject   DOC.CPP
//
// Comments:
//
//      Note that successful Initalization of the OLE libraries
//      is remembered so the UnInit is only called if needed.
//
//********************************************************************

BOOL CSimpSvrApp::fInitInstance (HANDLE hInstance, int nCmdShow, CClassFactory FAR * lpClassFactory)
{
        m_hInst = hInstance;

                DWORD dwVer = OleBuildVersion();

        // check to see if we are compatible with this version of the libraries
        if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup)
                TestDebugOut("*** WARNING:  Not compatible with current libs ***\r\n");

        // initialize the libraries
        if (OleInitialize(NULL) == NOERROR)
                m_fInitialized = TRUE;


        // Create the "application" windows
        m_hAppWnd = CreateWindow ("SimpSvrWClass",
                                                          "Simple OLE 2.0 Server",
                                                          WS_OVERLAPPEDWINDOW,
                                                          CW_USEDEFAULT,
                                                          CW_USEDEFAULT,
                                                          CW_USEDEFAULT,
                                                          CW_USEDEFAULT,
                                                          NULL,
                                                          NULL,
                                                          hInstance,
                                                          NULL);

        if (!m_hAppWnd)
                return FALSE;

        // if not started by OLE, then show the Window, and create a "fake" object, else
        // Register a pointer to IClassFactory so that OLE can instruct us to make an
        // object at the appropriate time.
        if (!m_fStartByOle)
                {
                ShowAppWnd(nCmdShow);
                m_lpDoc->CreateObject(IID_IOleObject, (LPVOID FAR *)&m_OleObject);
                InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
                }
        else
                {
                lpClassFactory = new CClassFactory(this);

                // shouldn't pass an API an object with a zero ref count
                lpClassFactory->AddRef();

                CoRegisterClassObject(GUID_SIMPLE,(IUnknown FAR *)lpClassFactory, CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE, &m_dwRegisterClass);

                // remove artificial Ref. count
                lpClassFactory->Release();
                }

        m_hMainMenu = GetMenu(m_hAppWnd);
        m_hColorMenu = GetSubMenu(m_hMainMenu, 1);
        m_hHelpMenu = GetSubMenu(m_hMainMenu, 2);


        return m_fInitialized;
}

//**********************************************************************
//
// CSimpSvrApp::lCommandHandler
//
// Purpose:
//
//      Handles the processing of WM_COMMAND.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_COMMAND)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                    Location
//
//      GetClientRect                               Windows API
//      MessageBox                                  Windows API
//      DialogBox                                   Windows API
//      MakeProcInstance                            Windows API
//      FreeProcInstance                            Windows API
//      SendMessage                                 Windows API
//      DefWindowProc                               Windows API
//      InvalidateRect                              Windows API
//      CSimpSvrDoc::InsertObject                   DOC.CPP
//      CSimpSvrObj::SetColor                       OBJ.CPP
//      CSimpSvrObj::RotateColor                    OBJ.CPP
//
// Comments:
//
//********************************************************************

long CSimpSvrApp::lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        switch (wParam) {
                // bring up the About box
                case IDM_ABOUT:
                        {
                        FARPROC lpProcAbout = MakeProcInstance((FARPROC)About, m_hInst);

                        DialogBox(m_hInst,               // current instance
                                        "AboutBox",                  // resource to use
                                        m_hAppWnd,                   // parent handle
                                        lpProcAbout);                // About() instance address

                        FreeProcInstance(lpProcAbout);
                        break;
                        }

                // exit the application
                case IDM_EXIT:
                        SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                        break;

                case IDM_RED:
                        m_lpDoc->GetObj()->SetColor (128, 0, 0);
                        InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
                        break;

                case IDM_GREEN:
                        m_lpDoc->GetObj()->SetColor (0,128, 0);
                        InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
                        break;

                case IDM_BLUE:
                        m_lpDoc->GetObj()->SetColor (0, 0, 128);
                        InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
                        break;

                case IDM_ROTATE:
                        m_lpDoc->GetObj()->RotateColor();
                        InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
                        break;

                default:
                        return (DefWindowProc(hWnd, message, wParam, lParam));
                   }   // end of switch
        return NULL;
}

//**********************************************************************
//
// CSimpSvrApp::lSizeHandler
//
// Purpose:
//
//      Handles the WM_SIZE message
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_SIZE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      LONG    -   returned from the "document" resizing
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpSvrDoc::lResizeDoc      DOC.CPP
//
// Comments:
//
//********************************************************************

long CSimpSvrApp::lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        RECT rect;

        GetClientRect(m_hAppWnd, &rect);
        return m_lpDoc->lResizeDoc(&rect);
}

//**********************************************************************
//
// CSimpSvrApp::lCreateDoc
//                                                         d
// Purpose:
//
//      Handles the creation of a document.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_CREATE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpSvrDoc::Create         DOC.CPP
//
// Comments:
//
//********************************************************************

long CSimpSvrApp::lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        RECT rect;

        GetClientRect(hWnd, &rect);

        m_lpDoc = CSimpSvrDoc::Create(this, &rect, hWnd);

        return NULL;
}



//**********************************************************************
//
// CSimpSvrApp::PaintApp
//
// Purpose:
//
//      Handles the painting of the doc window.
//
//
// Parameters:
//
//      HDC hDC -   hDC to the Doc Window.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrDoc::PaintDoc        DOC.CPP
//
// Comments:
//
//
//********************************************************************

void CSimpSvrApp::PaintApp (HDC hDC)
{

        // if we supported multiple documents, we would enumerate
        // through each of the open documents and call paint.

        if (m_lpDoc)
                m_lpDoc->PaintDoc(hDC);

}

//**********************************************************************
//
// CSimpSvrApp::ParseCmdLine
//
// Purpose:
//
//      Determines if the app was started by OLE
//
//
// Parameters:
//
//      LPSTR lpCmdLine -   Pointer to the command line
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      lstrlen                     Windows API
//      lstrcmp                     Windows API
//
//
// Comments:
//
//      Parses the command line looking for the -Embedding or /Embedding
//      flag.
//
//********************************************************************

void CSimpSvrApp::ParseCmdLine(LPSTR lpCmdLine)
{
        char szTemp[255];

        m_fStartByOle = TRUE;

        ::ParseCmdLine (lpCmdLine, &m_fStartByOle, szTemp);
}

//**********************************************************************
//
// CSimpSvrApp::SetStatusText
//
// Purpose:
//
//      Blanks out the text in the status bar
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrDoc::SetStatusText  DOC.CPP
//
//
// Comments:
//
//
//********************************************************************

void CSimpSvrApp::SetStatusText()
{
        m_lpDoc->SetStatusText();
}


//**********************************************************************
//
// CSimpSvrApp::IsInPlaceActive
//
// Purpose:
//
//      Safely determines from the app level if currently inplace active.
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      TRUE    - Inplace active
//      FALSE   - Not Inplace active
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrDoc::GetObject      OBJ.H
//      CSimpSvrObj:IsInPlaceActive OBJ.H
//
//
// Comments:
//
//
//********************************************************************

BOOL CSimpSvrApp::IsInPlaceActive()
{
        BOOL retval = FALSE;

        if (m_lpDoc)
                if (m_lpDoc->GetObj())
                        retval = m_lpDoc->GetObj()->IsInPlaceActive();

        return retval;
}

//**********************************************************************
//
// CSimpSvrApp::ShowAppWnd
//
// Purpose:
//
//      Shows the Application Window
//
// Parameters:
//
//      int nCmdShow    - Window State
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//      UpdateWindow                    Windows API
//      CoLockObjectExternal            OLE API
//
// Comments:
//
//********************************************************************

void CSimpSvrApp::ShowAppWnd(int nCmdShow)
{
        CoLockObjectExternal(this, TRUE, FALSE);
        ShowWindow (m_hAppWnd, nCmdShow);
        UpdateWindow (m_hAppWnd);
}

//**********************************************************************
//
// CSimpSvrApp::ShowAppWnd
//
// Purpose:
//
//      Hides the Application Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//      CoLockObjectExternal            OLE API
//
// Comments:
//
//********************************************************************

void CSimpSvrApp::HideAppWnd()
{
        CoLockObjectExternal(this, FALSE, TRUE);
        ShowWindow (m_hAppWnd, SW_HIDE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\doc.cpp ===
//**********************************************************************
// File name: DOC.CPP
//
//      Implementation file for CSimpSvrDoc.
//
// Functions:
//
//      See DOC.H for Class Definition
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CSimpSvrDoc::Create
//
// Purpose:
//
//      Creation for the CSimpSvrDoc Class
//
// Parameters:
//
//      CSimpSvrApp FAR * lpApp  -   Pointer to the CSimpSvrApp Class
//
//      LPRECT lpRect           -   Client area rect of "frame" window
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      CSimpSvrDoc::CSimpSvrDoc    DOC.CPP
//      CreateHatchWindow           OLE2UI
//
// Comments:
//
//      This routine was added so that failure could be returned
//      from object creation.
//
//********************************************************************

CSimpSvrDoc FAR * CSimpSvrDoc::Create(CSimpSvrApp FAR *lpApp, LPRECT lpRect,HWND hWnd)
{
	CSimpSvrDoc FAR * lpTemp = new CSimpSvrDoc(lpApp, hWnd);

	if (!lpTemp)
		return NULL;

	// create the document Window
	lpTemp->m_hDocWnd = CreateWindow(
			"DocWClass",
			NULL,
			WS_CHILD | WS_CLIPSIBLINGS,
			lpRect->left,
			lpRect->top,
			lpRect->right,
			lpRect->bottom,
			hWnd,
			NULL,
			lpApp->GethInst(),
			NULL);

	if (!lpTemp->m_hDocWnd)
		goto error;

	lpTemp->ShowDocWnd();

	lpTemp->m_hHatchWnd = CreateHatchWindow( lpTemp->m_hDocWnd, lpApp->GethInst());

	lpTemp->HideHatchWnd();

	return (lpTemp);

error:
	delete (lpTemp);
	return NULL;

}

//**********************************************************************
//
// CSimpSvrDoc::CSimpSvrDoc
//
// Purpose:
//
//      Constructor for the CSimpSvrDoc Class
//
// Parameters:
//
//      CSimpSvrApp FAR * lpApp  -   Pointer to the CSimpSvrApp Class
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetMenu                     Windows API
//      GetSubMenu                  Windows API
//
// Comments:
//
//********************************************************************

CSimpSvrDoc::CSimpSvrDoc(CSimpSvrApp FAR * lpApp,HWND hWnd)
{
	TestDebugOut("In CSimpSvrDoc's Constructor\r\n");
	m_lpApp = lpApp;
	m_nCount = 0;
	m_lpObj = NULL;
	m_fClosing = FALSE;

	// set up menu handles


}

//**********************************************************************
//
// CSimpSvrDoc::~CSimpSvrDoc
//
// Purpose:
//
//      Destructor for CSimpSvrDoc
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DestroyWindow               Windows API
//      CSimpSvrApp::ClearDoc       APP.CPP
//
// Comments:
//
//********************************************************************

CSimpSvrDoc::~CSimpSvrDoc()
{
	TestDebugOut("In CSimpSvrDoc's Destructor\r\n");
	m_lpApp->ClearDoc();
	DestroyWindow(m_hHatchWnd);
}


//**********************************************************************
//
// CSimpSvrDoc::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      E_NOINTERFACE -   Always
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrApp::QueryInterface APP.CPP
//
// Comments:
//
//      Since the document could contain multiple objects, all
//      interfaces except those associated with the document should
//      be returned.  In this implementation, there are no doc level
//      interfaces.
//
//********************************************************************

STDMETHODIMP CSimpSvrDoc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In CSimpSvrDoc::QueryInterface\r\n");

	SCODE sc = E_NOINTERFACE;

	if ( (riid == IID_IUnknown) )
	   {
	   AddRef();
	   *ppvObj = this;
	   sc = S_OK;
	   }

	return ResultFromScode(sc);
}

//**********************************************************************
//
// CSimpSvrDoc::AddRef
//
// Purpose:
//
//      Increments the document level reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrApp::AddRef         APP.CPP
//
// Comments:
//
//      The reference count at this level reflects the total ref.
//      count of all interfaces on all objects contained within
//      this document.  Note that it also "trickles up" the
//      ref count to the app level.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrDoc::AddRef()
{
	TestDebugOut("In CSimpSvrDoc::AddRef\r\n");
	// AddRef the app, but return the doc count
	m_lpApp->AddRef();

	return ++m_nCount;
}

//**********************************************************************
//
// CSimpSvrDoc::Release
//
// Purpose:
//
//      Decrements the document level reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrApp::Release         APP.CPP
//
// Comments:
//
//      The reference count at this level reflects the total ref.
//      count of all interfaces on all objects contained within
//      this document.  Note that it also "trickles up" the
//      ref count to the app level.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrDoc::Release()
{
	TestDebugOut("In CSimpSvrDoc::Release\r\n");
	// Release the app, but return the app count
	m_lpApp->Release();

	if (--m_nCount == 0) {
		delete this;
        return 0;
    }

	return m_nCount;
}

//**********************************************************************
//
// CSimpSvrDoc::lResizeDoc
//
// Purpose:
//
//      Resizes the document
//
// Parameters:
//
//      LPRECT lpRect   -   The size of the client are of the "frame"
//                          Window.
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                Location
//
//      MoveWindow                              Windows API
//
// Comments:
//
//********************************************************************

long CSimpSvrDoc::lResizeDoc(LPRECT lpRect)
{
	MoveWindow(m_hDocWnd, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, TRUE);
	return NULL;
}


//**********************************************************************
//
// CSimpSvrDoc::PaintDoc
//
// Purpose:
//
//      Paints the Document
//
// Parameters:
//
//      HDC hDC -   hDC of the document Window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::Draw                   OBJ.CPP
//      CSimpSvrObj::GetDataAdviseHolder    OBJ.H
//      CSimpSvrObj::GetDataObject          OBJ.H
//      CSimpAppObj::IsStartedByOle         APP.CPP
//      IDataAdviseHolder::SendOnDataChange OLE API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::PaintDoc (HDC hDC)
{

	// if the object hasn't been created yet, then don't draw
	if (m_lpObj)
		m_lpObj->Draw(hDC,FALSE);
	else
		return;

	// Sending a data change every time we paint, but only if we
	// were started by OLE
	if (m_lpApp->IsStartedByOle())
			m_lpObj->SendOnDataChange( );
}



//**********************************************************************
//
// CSimpSvrDoc::CreateObject
//
// Purpose:
//
//
// Parameters:
//
//
// Return Value:
//
//      NOERROR if the function succeeds, otherwise E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::CSimpSvrObj    OBJ.CPP
//      CSimpSvrOjb::QueryInterface OBJ.CPP
//
// Comments:
//
//********************************************************************

HRESULT CSimpSvrDoc::CreateObject(REFIID riid, LPVOID FAR *ppvObject)
{
	SCODE sc = E_FAIL;

	m_lpObj = new CSimpSvrObj(this);

	if (m_lpObj)
		{
		m_lpObj->QueryInterface(riid, ppvObject);
		sc = S_OK;
		}

	return ResultFromScode(sc);
}

//**********************************************************************
//
// CSimpSvrDoc::Close
//
// Purpose:
//
//      Closes the object
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      CSimpSvrObj::AddRef                     OBJ.CPP
//      CSimpSvrObj::Release                    OBJ.CPP
//      CSimpSvrObj::IsInPlaceActive            OBJ.H
//      CSimpSvrObj::GetOleInPlaceObject        OBJ.H
//      CSimpSvrObj::ClearOleClientSite         OBJ.H
//      CSimpSvrObj::GetDataAdviseHolder        OBJ.H
//      CSimpSvrObj::GetOleClientSite           OBJ.H
//      CSimpSvrObj::ClearDataAdviseHolder      OBJ.H
//      CSimpSvrObj::GetOleAdviseHolder         OBJ.H
//      CSimpSvrObj::ClearOleAdviseHolder       OBJ.H
//      IOleInPlaceObject::InPlaceDeactivate    Container
//      IOleClientSite::SaveObject              Container
//      IOleClientSite::OnShowWindow            Container
//      IOleClientSite::Release                 Container
//      IDataAdviseHolder::SendOnDataChange     OLE
//      IDataAdviseHolder::Release              OLE
//      IOleAdviseHolder::SendOnClose           OLE
//      IOleAdviseHolder::Release               OLE
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::Close()
{
	TestDebugOut("In CSimpSvrDoc::Close() \r\n");

	m_lpObj->AddRef(); // hold object alive

	if (m_fClosing)
		return;

	m_fClosing = TRUE;

	// if the object is currently inplace active, then deactivate
	if (m_lpObj->IsInPlaceActive())
		m_lpObj->GetOleInPlaceObject()->InPlaceDeactivate();

	// unregister from the ROT...
	if (m_lpObj->GetRotRegister())
		{
		LPRUNNINGOBJECTTABLE lpRot;

		if (GetRunningObjectTable (0, &lpRot) == NOERROR )
			{
			lpRot->Revoke(m_lpObj->GetRotRegister());
			lpRot->Release();
			}
		}

	// if we have a clientsite, instruct it to save the object
	if (m_lpObj->GetOleClientSite())
		{
		m_lpObj->GetOleClientSite()->SaveObject();
		m_lpObj->GetOleClientSite()->OnShowWindow(FALSE);
		}

	// Do a final SendOnDataChange for those containers that have specified the
	// ADF_DATAONSTOP flag.
	if (m_lpObj->GetDataAdviseHolder())
		{
		m_lpObj->GetDataAdviseHolder()->SendOnDataChange( m_lpObj->GetDataObject(), 0, ADVF_DATAONSTOP);
		m_lpObj->GetDataAdviseHolder()->Release();
		m_lpObj->ClearDataAdviseHolder();
		}


	// Tell the container that we are shutting down.
	if (m_lpObj->GetOleAdviseHolder())
		{
		m_lpObj->GetOleAdviseHolder()->SendOnClose();
		m_lpObj->GetOleAdviseHolder()->Release();
		m_lpObj->ClearOleAdviseHolder();
		}

	if (m_lpObj->GetOleClientSite())
		{
		m_lpObj->GetOleClientSite()->Release();
		m_lpObj->ClearOleClientSite();
		}

	// release our streams and storage
	m_lpObj->GetPersistStorage()->ReleaseStreamsAndStorage();

	// Disconnect the object.  NOTE: This call should not do anything
	// unless the container has cause a GP Fault or some other problem
	// has occured...
	TestDebugOut("*** Before CoDisconnectObject *** \r\n");
	CoDisconnectObject((LPUNKNOWN)m_lpObj, 0);
	TestDebugOut("*** After CoDisconnectObject *** \r\n");

	m_lpObj->Release(); // let object close

}


//**********************************************************************
//
// CSimpSvrDoc::SetStatusText
//
// Purpose:
//
//      Sets the Container's status bar text
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      CSimpSvrObj::IsInPlaceActive    OBJ.CPP
//      IOleInPlaceFrame::SetStatusText Container
//
// Comments:
//
//      Even though there is no status line in this sample, this
//      method must be called on WM_MENUSELECT to clear the last
//      message in the status line.
//
//********************************************************************

void CSimpSvrDoc::SetStatusText()
{
	if (m_lpObj->IsInPlaceActive())
		m_lpObj->GetInPlaceFrame()->SetStatusText("\0");
}

//**********************************************************************
//
// CSimpSvrDoc::ShowDocWnd
//
// Purpose:
//
//      Shows the Document Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//      UpdateWindow                    Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::ShowDocWnd()
{
	ShowWindow(m_hDocWnd, SW_SHOWNORMAL);  // Show the window
	UpdateWindow(m_hDocWnd);               // Sends WM_PAINT message
}

//**********************************************************************
//
// CSimpSvrDoc::ShowHatchWnd
//
// Purpose:
//
//      Shows the hatch Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::ShowHatchWnd()
{
	ShowWindow(m_hHatchWnd, SW_SHOW);
}

//**********************************************************************
//
// CSimpSvrDoc::HideDocWnd
//
// Purpose:
//
//      Hides the DocumentWindow
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::HideDocWnd()
{
	ShowWindow(m_hDocWnd, SW_HIDE);
}

//**********************************************************************
//
// CSimpSvrDoc::HideHatchWnd
//
// Purpose:
//
//      Hides the Hatch Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::HideHatchWnd()
{
	ShowWindow(m_hHatchWnd, SW_HIDE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\icf.cpp ===
//**********************************************************************
// File name: ICF.CPP
//
//    Implementation file for the CClassFactory Class
//
// Functions:
//
//    See icf.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "app.h"
#include "doc.h"
#include "icf.h"

//**********************************************************************
//
// CClassFactory::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrApp::QueryInterface APP.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CClassFactory::QueryInterface  ( REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In CClassFactory::QueryInterface\r\n");

	SCODE sc = S_OK;

	if ( (riid == IID_IUnknown) ||
		 (riid == IID_IClassFactory) )
		*ppvObj = this;
	else
		{
		*ppvObj = NULL;
		sc = E_NOINTERFACE;
		}

	if (*ppvObj)
		((LPUNKNOWN)*ppvObj)->AddRef();

	// pass it on to the Application object
	return ResultFromScode(sc);
};

//**********************************************************************
//
// CClassFactory::AddRef
//
// Purpose:
//
//      Increments the reference count on CClassFactory and the application
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on CClassFactory
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP_(ULONG) CClassFactory::AddRef ()
{
	TestDebugOut("In CClassFactory::AddRef\r\n");

	return ++m_nCount;
};

//**********************************************************************
//
// CClassFactory::Release
//
// Purpose:
//
//      Decrements the reference count of CClassFactory and the
//      application object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP_(ULONG) CClassFactory::Release ()
{
	TestDebugOut("In CClassFactory::Release\r\n");

	if (--m_nCount == 0) {
		delete this;
        return 0;
    }

	return m_nCount;
};


//**********************************************************************
//
// CClassFactory::CreateInstance
//
// Purpose:
//
//      Instantiates a new OLE object
//
// Parameters:
//
//      LPUNKNOWN pUnkOuter     - Pointer to the controlling unknown
//
//      REFIID riid             - The interface type to fill in ppvObject
//
//      LPVOID FAR* ppvObject   - Out pointer for the object
//
// Return Value:
//
//      S_OK                    - Creation was successful
//      CLASS_E_NOAGGREGATION   - Tried to be created as part of an aggregate
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::CreateObject   DOC.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CClassFactory::CreateInstance ( LPUNKNOWN pUnkOuter,
							  REFIID riid,
							  LPVOID FAR* ppvObject)
{
	HRESULT hErr;

	TestDebugOut("In CClassFactory::CreateInstance\r\n");

	// need to NULL the out parameter
	*ppvObject = NULL;

	// we don't support aggregation...
	if (pUnkOuter)
		{
		hErr = ResultFromScode(CLASS_E_NOAGGREGATION);
		goto error;
		}

	hErr = m_lpApp->m_lpDoc->CreateObject(riid, ppvObject);

error:
	return hErr;
};

//**********************************************************************
//
// CClassFactory::LockServer
//
// Purpose:
//
//
// Parameters:
//
//      BOOL fLock      - TRUE to lock the server, FALSE to unlock it
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CoLockObjectExternal        OLE API
//      ResultFromScode             OLE API
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP CClassFactory::LockServer ( BOOL fLock)
{
	TestDebugOut("In CClassFactory::LockServer\r\n");
	CoLockObjectExternal(m_lpApp, fLock, TRUE);

	return ResultFromScode( S_OK);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\iec.h ===
//**********************************************************************
// File name: iec.h
//
//      Definition of CExternalConnection
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IEC_H_)
#define _IEC_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface CExternalConnection : public IExternalConnection
{
private:
	CSimpSvrObj FAR * m_lpObj;  // Ptr to object
	int m_nCount;               // Ref count
	DWORD m_dwStrong;           // Connection Count

public:
	CExternalConnection::CExternalConnection(CSimpSvrObj FAR * lpSimpSvrObj)
		{
		m_lpObj = lpSimpSvrObj;
		m_nCount = 0;
		m_dwStrong = 0;
		};

	CExternalConnection::~CExternalConnection() {};

	// *** IUnknown methods ***
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	// *** IExternalConnection methods ***
	STDMETHODIMP_(DWORD) AddConnection (DWORD extconn, DWORD reserved);
	STDMETHODIMP_(DWORD) ReleaseConnection (DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\ido.h ===
//**********************************************************************
// File name: ido.h
//
//      Definition of CDataObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IDO_H_)
#define _IDO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface CDataObject : public IDataObject
{
private:
	CSimpSvrObj FAR * m_lpObj;
	int m_nCount;

public:
	CDataObject::CDataObject(CSimpSvrObj FAR * lpSimpSvrObj)
		{
		m_lpObj = lpSimpSvrObj;
		m_nCount = 0;
		};

	CDataObject::~CDataObject() {};

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP DAdvise  ( FORMATETC FAR* pFormatetc, DWORD advf,
					LPADVISESINK pAdvSink, DWORD FAR* pdwConnection);
	STDMETHODIMP DUnadvise  ( DWORD dwConnection);
	STDMETHODIMP EnumDAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise);
	STDMETHODIMP EnumFormatEtc  ( DWORD dwDirection,
								  LPENUMFORMATETC FAR* ppenumFormatEtc);
	STDMETHODIMP GetCanonicalFormatEtc  ( LPFORMATETC pformatetc,
										  LPFORMATETC pformatetcOut);
	STDMETHODIMP GetData  ( LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium );
	STDMETHODIMP GetDataHere  ( LPFORMATETC pformatetc, LPSTGMEDIUM pmedium );
	STDMETHODIMP QueryGetData  ( LPFORMATETC pformatetc );
	STDMETHODIMP SetData  ( LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
							BOOL fRelease);


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\iec.cpp ===
//**********************************************************************
// File name: IEC.CPP
//
//    Implementation file for the CExternalConnection Class
//
// Functions:
//
//    See iec.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "iec.h"
#include "app.h"
#include "doc.h"


//**********************************************************************
//
// CExternalConnection::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CExternalConnection::QueryInterface (REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In CExternalConnection::QueryInterface\r\n");

	return m_lpObj->QueryInterface(riid, ppvObj);
}


//**********************************************************************
//
// CExternalConnection::AddRef
//
// Purpose:
//
//      Increments the reference count on CExternalConnection and the "object"
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on the Object.
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CExternalConnection::AddRef ()
{
	TestDebugOut("In CExternalConnection::AddRef\r\n");
	++m_nCount;
	return m_lpObj->AddRef();
};

//**********************************************************************
//
// CExternalConnection::Release
//
// Purpose:
//
//      Decrements the reference count of COleObject and the
//      "object" object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP_(ULONG) CExternalConnection::Release ()
{
	TestDebugOut("In CExternalConnection::Release\r\n");
	--m_nCount;
	return m_lpObj->Release();
};



//**********************************************************************
//
// CExternalConnection::AddConnection
//
// Purpose:
//
//      Called when another connection is made to the object.
//
// Parameters:
//
//      DWORD extconn   -   Type of connection
//
//      DWORD reserved  -   Reserved
//
// Return Value:
//
//      Strong connection count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(DWORD) CExternalConnection::AddConnection (DWORD extconn, DWORD reserved)
{
	TestDebugOut("In CExternalConnection::AddConnection\r\n");

	if (extconn & EXTCONN_STRONG)
		return ++m_dwStrong;

	return 0;
}

//**********************************************************************
//
// CExternalConnection::ReleaseConnection
//
// Purpose:
//
//      Called when a connection to the object is released.
//
// Parameters:
//
//      DWORD extconn               - Type of Connection
//
//      DWORD reserved              - Reserved
//
//      BOOL fLastReleaseCloses     - Close flag
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      COleObject::Close           IOO.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(DWORD) CExternalConnection::ReleaseConnection (DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses)
{
	TestDebugOut("In CExternalConnection::ReleaseConnection\r\n");

	if (extconn & EXTCONN_STRONG)
		{
		DWORD dwSave = --m_dwStrong;

		if (!m_dwStrong && fLastReleaseCloses)
			m_lpObj->m_OleObject.Close(OLECLOSE_SAVEIFDIRTY);

		return dwSave;
		}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\ioipo.cpp ===
//**********************************************************************
// File name: IOIPO.CPP
//
//    Implementation file for the CClassFactory Class
//
// Functions:
//
//    See ioipo.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioipo.h"
#include "app.h"
#include "doc.h"
#include "math.h"

//**********************************************************************
//
// COleInPlaceObject::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In COleInPlaceObject::QueryInterface\r\n");
	// need to NULL the out parameter
	*ppvObj = NULL;
	return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceObject::AddRef
//
// Purpose:
//
//      Increments the reference count on COleInPlaceObject and the "object"
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on the Object
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceObject::AddRef ()
{
	TestDebugOut("In COleInPlaceObject::AddRef\r\n");
	++m_nCount;
	return m_lpObj->AddRef();
}

//**********************************************************************
//
// COleInPlaceObject::Release
//
// Purpose:
//
//      Decrements the reference count of COleInPlaceObject and the
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceObject::Release ()
{
	TestDebugOut("In COleInPlaceObject::Release\r\n");
	--m_nCount;
	return m_lpObj->Release();
}

//**********************************************************************
//
// COleInPlaceObject::InPlaceDeactivate
//
// Purpose:
//
//      Called to deactivat the object
//
// Parameters:
//
//      None
//
// Return Value:
//
//
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleClientSite::QueryInterface          Container
//      IOleInPlaceSite::OnInPlaceDeactivate    Container
//      IOleInPlaceSite::Release                Container
//
// Comments:
//
//
//********************************************************************


STDMETHODIMP COleInPlaceObject::InPlaceDeactivate()
{
	 TestDebugOut("In COleInPlaceObject::InPlaceDeactivate\r\n");

	 // if not inplace active, return NOERROR
	 if (!m_lpObj->m_fInPlaceActive)
		 return NOERROR;

	 // clear inplace flag
	 m_lpObj->m_fInPlaceActive = FALSE;

	 // deactivate the UI
	 m_lpObj->DeactivateUI();
	 m_lpObj->DoInPlaceHide();

	 // tell the container that we are deactivating.
	 if (m_lpObj->m_lpIPSite)
		 {
		 m_lpObj->m_lpIPSite->OnInPlaceDeactivate();
		 m_lpObj->m_lpIPSite->Release();
		 m_lpObj->m_lpIPSite =NULL;
		 }

	return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceObject::UIDeactivate
//
// Purpose:
//
//      Instructs us to remove our UI.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NOERROR
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleInPlaceUIWindow::SetActiveObject    Container
//      IOleInPlaceFrame::SetActiveObject       Container
//      IOleClientSite::QueryInterface          Container
//      IOleInPlaceSite::OnUIDeactivate         Container
//      IOleInPlaceSite::Release                Container
//      CSimpSvrObj::DoInPlaceHide              OBJ.H
//      IDataAdviseHolder::SendOnDataChange     OLE
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::UIDeactivate()
{
	TestDebugOut("In COleInPlaceObject::UIDeactivate\r\n");

	m_lpObj->DeactivateUI();

	return ResultFromScode (S_OK);
}

//**********************************************************************
//
// COleInPlaceObject::SetObjectRects
//
// Purpose:
//
//      Called when the container clipping region or the object position
//      changes.
//
// Parameters:
//
//      LPCRECT lprcPosRect     - New Position Rect.
//
//      LPCRECT lprcClipRect    - New Clipping Rect.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IntersectRect               Windows API
//      OffsetRect                  Windows API
//      CopyRect                    Windows API
//      MoveWindow                  Windows API
//      CSimpSvrDoc::GethHatchWnd   DOC.H
//      CSimpSvrDoc::gethDocWnd     DOC.h
//      SetHatchWindowSize          OLE2UI
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::SetObjectRects  ( LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
	TestDebugOut("In COleInPlaceObject::SetObjectRects\r\n");

	RECT resRect;
	POINT pt;

	// Get the intersection of the clipping rect and the position rect.
	IntersectRect(&resRect, lprcPosRect, lprcClipRect);

	m_lpObj->m_xOffset = abs (resRect.left - lprcPosRect->left);
	m_lpObj->m_yOffset = abs (resRect.top - lprcPosRect->top);

	m_lpObj->m_scale = (float)(lprcPosRect->right - lprcPosRect->left)/m_lpObj->m_size.x;

	if (m_lpObj->m_scale == 0)
		m_lpObj->m_scale = 1;

	char szBuffer[255];
	wsprintf(szBuffer,"New Scale %3d\r\n",m_lpObj->m_scale);
	TestDebugOut(szBuffer);

	// Adjust the size of the Hatch Window.
	SetHatchWindowSize(m_lpObj->m_lpDoc->GethHatchWnd(),(LPRECT) lprcPosRect, (LPRECT) lprcClipRect, &pt);

	// offset the rect
	OffsetRect(&resRect, pt.x, pt.y);

	CopyRect(&m_lpObj->m_posRect, lprcPosRect);

	// Move the actual object window
	MoveWindow(m_lpObj->m_lpDoc->GethDocWnd(),
				   resRect.left,
				   resRect.top,
				   resRect.right - resRect.left,
				   resRect.bottom - resRect.top,
				   TRUE);


	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleInPlaceObject::GetWindow
//
// Purpose:
//
//      Returns the Window handle of the inplace object
//
// Parameters:
//
//      HWND FAR* lphwnd    - Out pointer in which to return the window
//                            Handle.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleDoc::GethDocWnd      DOC.H
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::GetWindow  ( HWND FAR* lphwnd)
{
	TestDebugOut("In COleInPlaceObject::GetWindow\r\n");
	*lphwnd = m_lpObj->m_lpDoc->GethDocWnd();

	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleInPlaceObject::ContextSensitiveHelp
//
// Purpose:
//
//      Used in performing Context Sensitive Help
//
// Parameters:
//
//      BOOL fEnterMode     - Flag to determine if enter or exiting
//                            Context Sensitive Help.
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented due to the fact that it is
//      beyond the scope of a simple object.  All *real* applications
//      are going to want to implement this function, otherwise any
//      container that supports context sensitive help will not work
//      properly while the object is in place.
//
//      See TECHNOTES.WRI include with the OLE SDK for details on
//      Implementing this method.
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::ContextSensitiveHelp  ( BOOL fEnterMode)
{
	TestDebugOut("In COleInPlaceObject::ContextSensitiveHelp\r\n");
	return ResultFromScode( E_NOTIMPL);
};

//**********************************************************************
//
// COleInPlaceObject::ReactivateAndUndo
//
// Purpose:
//
//      Called when the container wants to undo the last edit made in
//      the object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      INPLACE_E_NOTUNDOABLE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Since this server does not support undo, the value
//      INPLACE_E_NOTUNDOABLE is always returned.
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::ReactivateAndUndo  ()
{
	TestDebugOut("In COleInPlaceObject::ReactivateAndUndo\r\n");
	return ResultFromScode( INPLACE_E_NOTUNDOABLE );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\ioipao.h ===
//**********************************************************************
// File name: IOIPAO.H
//
//      Definition of COleInPlaceActiveObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _IOIPAO_H_)
#define _IOIPAO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface COleInPlaceActiveObject : public IOleInPlaceActiveObject
{
private:
	CSimpSvrObj FAR * m_lpObj;
	int m_nCount;

public:
	COleInPlaceActiveObject::COleInPlaceActiveObject(CSimpSvrObj FAR * lpSimpSvrObj)
		{
		m_lpObj = lpSimpSvrObj;     // set up the back ptr
		m_nCount = 0;            // clear the ref count.
		};
	COleInPlaceActiveObject::~COleInPlaceActiveObject() {};   // destructor

// IUnknown Methods

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP OnDocWindowActivate  ( BOOL fActivate) ;
	STDMETHODIMP OnFrameWindowActivate  ( BOOL fActivate) ;
	STDMETHODIMP GetWindow  ( HWND FAR* lphwnd);
	STDMETHODIMP ContextSensitiveHelp  ( BOOL fEnterMode);
	STDMETHODIMP TranslateAccelerator  ( LPMSG lpmsg);
	STDMETHODIMP ResizeBorder  ( LPCRECT lprectBorder,
								 LPOLEINPLACEUIWINDOW lpUIWindow,
								 BOOL fFrameWindow);
	STDMETHODIMP EnableModeless  ( BOOL fEnable);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\ioo.cpp ===
//**********************************************************************
// File name: IOO.CPP
//
//    Implementation file for the COleObject Class
//
// Functions:
//
//    See ioo.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioo.h"
#include "app.h"
#include "doc.h"

#define VERB_OPEN 1

//**********************************************************************
//
// COleObject::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In COleObject::QueryInterface\r\n");
	return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleObject::AddRef
//
// Purpose:
//
//      Increments the reference count on COleObject and the "object"
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on the Object.
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleObject::AddRef ()
{
	TestDebugOut("In COleObject::AddRef\r\n");
	++m_nCount;
	return m_lpObj->AddRef();
}

//**********************************************************************
//
// COleObject::Release
//
// Purpose:
//
//      Decrements the reference count of COleObject and the
//      "object" object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleObject::Release ()
{
	TestDebugOut("In COleObject::Release\r\n");
	--m_nCount;
	return m_lpObj->Release();
}

//**********************************************************************
//
// COleObject::SetClientSite
//
// Purpose:
//
//      Called to notify the object of it's client site.
//
// Parameters:
//
//      LPOLECLIENTSITE pClientSite     - ptr to new client site
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IOleClientSite::Release     Container
//      IOleClientSite::AddRef      Container
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::SetClientSite  ( LPOLECLIENTSITE pClientSite)
{
	TestDebugOut("In COleObject::SetClientSite\r\n");

	// if we already have a client site, release it.
	if (m_lpObj->m_lpOleClientSite)
		{
		m_lpObj->m_lpOleClientSite->Release();
		m_lpObj->m_lpOleClientSite = NULL;
		}

	// store copy of the client site.
	m_lpObj->m_lpOleClientSite = pClientSite;

	// AddRef it so it doesn't go away.
	if (m_lpObj->m_lpOleClientSite)
		m_lpObj->m_lpOleClientSite->AddRef();

	return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleObject::Advise
//
// Purpose:
//
//      Called to set up an advise on the OLE object.
//
// Parameters:
//
//      LPADVISESINK pAdvSink       - ptr to the Advise Sink for notification
//
//      DWORD FAR* pdwConnection    - place to return the connection ID.
//
// Return Value:
//
//      Passed back from IOleAdviseHolder::Advise.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CreateOleAdviseHolder       OLE API
//      IOleAdviseHolder::Advise    OLE
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::Advise ( LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
	TestDebugOut("In COleObject::Advise\r\n");

	// if we haven't made an OleAdviseHolder yet, make one.
	if (!m_lpObj->m_lpOleAdviseHolder)
		CreateOleAdviseHolder(&m_lpObj->m_lpOleAdviseHolder);

	// pass this call onto the OleAdviseHolder.
	return m_lpObj->m_lpOleAdviseHolder->Advise(pAdvSink, pdwConnection);
}

//**********************************************************************
//
// COleObject::SetHostNames
//
// Purpose:
//
//      Called to pass strings for Window titles.
//
// Parameters:
//
//      LPCSTR szContainerApp   -   ptr to string describing Container App
//
//      LPCSTR szContainerObj   -   ptr to string describing Object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This routine is called so that the server application can
//      set the window title appropriately.
//
//********************************************************************

STDMETHODIMP COleObject::SetHostNames  ( LPCSTR szContainerApp, LPCSTR szContainerObj)
{
	TestDebugOut("In COleObject::SetHostNames\r\n");

	return ResultFromScode( S_OK);
};

//**********************************************************************
//
// COleObject::DoVerb
//
// Purpose:
//
//      Called by the container application to invoke a verb.
//
// Parameters:
//
//      LONG iVerb                  - The value of the verb to be
//                                    invoked.
//
//      LPMSG lpmsg                 - The message that caused the
//                                    verb to be invoked.
//
//      LPOLECLIENTSITE pActiveSite - Ptr to the active client site.
//
//      LONG lindex                 - Used in extended layout
//
//      HWND hwndParent             - This should be the window handle of
//                                    the window in which we are contained.
//                                    This value could be used to "fake"
//                                    inplace activation in a manner similar
//                                    to Video for Windows in OLE 1.0.
//
//      LPCRECT lprcPosRect         - The rectangle that contains the object
//                                    within hwndParent.  Also used to
//                                    "fake" inplace activation.
//
// Return Value:
//
//      OLE_E_NOTINPLACEACTIVE      - Returned if attempted to undo while not
//                                    inplace active.
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      ShowWindow                          Windows API
//      CSimpSvrObj::DoInPlaceActivate      OBJ.CPP
//      CSimpSvrObj::DoInPlaceHide          OBJ.CPP
//      COleObject::OpenEdit                IOO.CPP
//      CSimpSvrDoc::GethDocWnd             DOC.H
//      COleInPlaceObj::InPlaceDeactivate   IOIPO.CPP
//
// Comments:
//
//      Be sure to look at TECHNOTES.WRI included with the OLE
//      SDK for a description of handling the inplace verbs
//      properly.
//
//********************************************************************

STDMETHODIMP COleObject::DoVerb  (  LONG iVerb,
									LPMSG lpmsg,
									LPOLECLIENTSITE pActiveSite,
									LONG lindex,
									HWND hwndParent,
									LPCRECT lprcPosRect)
{
	TestDebugOut("In COleObject::DoVerb\r\n");

	switch (iVerb)
		{
		case OLEIVERB_SHOW:
		case OLEIVERB_PRIMARY:
			if (m_fOpen)
				SetFocus(m_lpObj->m_lpDoc->GethAppWnd());
			else if (m_lpObj->DoInPlaceActivate(iVerb) == FALSE)
				OpenEdit(pActiveSite);
			break;

		case OLEIVERB_UIACTIVATE:
			if (m_fOpen)
				return ResultFromScode (E_FAIL);

			// inplace activate
			if (!m_lpObj->DoInPlaceActivate(iVerb))
				return ResultFromScode (E_FAIL);
			break;

		case OLEIVERB_DISCARDUNDOSTATE:
			// don't have to worry about this situation as we don't
			// support an undo state.
			if (!m_lpObj->m_fInPlaceActive)
				return ResultFromScode(OLE_E_NOT_INPLACEACTIVE);
			break;

		case OLEIVERB_HIDE:
			// if inplace active, do an "inplace" hide, otherwise
			// just hide the app window.
			if (m_lpObj->m_fInPlaceActive)
				{
				m_lpObj->DeactivateUI();
				m_lpObj->DoInPlaceHide();
				}
			else
				m_lpObj->m_lpDoc->GetApp()->HideAppWnd();
			break;

		case OLEIVERB_OPEN:
		case VERB_OPEN:
			// if inplace active, deactivate
			if (m_lpObj->m_fInPlaceActive)
				m_lpObj->m_OleInPlaceObject.InPlaceDeactivate();

			// open into another window.
			OpenEdit(pActiveSite);
			break;

		default:
			if (iVerb < 0)
				return ResultFromScode(E_FAIL);
		}

	return ResultFromScode( S_OK);
};

//**********************************************************************
//
// COleObject::GetExtent
//
// Purpose:
//
//      Returns the extent of the object.
//
// Parameters:
//
//      DWORD dwDrawAspect  - The aspect in which to get the size.
//
//      LPSIZEL lpsizel     - Out ptr to return the size.
//
// Return Value:
//
//
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      XformWidthInPixelsToHimetric    OLE2UI
//      XformHeightInPixelsToHimetric   OLE2UI
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::GetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	TestDebugOut("In COleObject::GetExtent\r\n");

	SCODE sc = E_FAIL;

	// Only DVASPECT_CONTENT is supported....
	if (dwDrawAspect == DVASPECT_CONTENT)
		{
		sc = S_OK;

		// return the correct size in HIMETRIC...
		lpsizel->cx = XformWidthInPixelsToHimetric(NULL, m_lpObj->m_size.x);
		lpsizel->cy = XformHeightInPixelsToHimetric(NULL, m_lpObj->m_size.y);
		}

	return ResultFromScode( sc );
};

//**********************************************************************
//
// COleObject::Update
//
// Purpose:
//
//      Called to get the most up to date data
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IDataAdviseHolder::SendOnDataChange OLE
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::Update()
{
	TestDebugOut("In COleObject::Update\r\n");

	// force an update
	m_lpObj->SendOnDataChange();

	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleObject::Close
//
// Purpose:
//
//      Called when the OLE object needs to be closed
//
// Parameters:
//
//      DWORD dwSaveOption  - Flags to instruct the server how to prompt
//                            the user.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::Close          DOC.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::Close  ( DWORD dwSaveOption)
{
	TestDebugOut("In COleObject::Close\r\n");

	// delegate to the document object.
	m_lpObj->m_lpDoc->Close();

	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleObject::Unadvise
//
// Purpose:
//
//      Breaks down an OLE advise that has been set up on this object.
//
// Parameters:
//
//      DWORD dwConnection  - Connection that needs to be broken down
//
// Return Value:
//
//      Passed back from IOleAdviseHolder::Unadvise
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IOleAdviseHolder::Unadvise  OLE
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::Unadvise ( DWORD dwConnection)
{
	TestDebugOut("In COleObject::Unadvise\r\n");

	// pass on to OleAdviseHolder.
	return m_lpObj->m_lpOleAdviseHolder->Unadvise(dwConnection);
};

//**********************************************************************
//
// COleObject::EnumVerbs
//
// Purpose:
//
//      Enumerates the verbs associated with this object.
//
// Parameters:
//
//      LPENUMOLEVERB FAR* ppenumOleVerb    - Out ptr in which to return
//                                            the enumerator
//
// Return Value:
//
//      OLE_S_USEREG    - Instructs OLE to use the verbs found in the
//                        REG DB for this server.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      In a .DLL, an application cannot return OLE_S_USEREG.  This is
//      due to the fact that the default object handler is not being
//      used, and the container is really making direct function calls
//      into the server .DLL.
//
//********************************************************************

STDMETHODIMP COleObject::EnumVerbs  ( LPENUMOLEVERB FAR* ppenumOleVerb)
{
	TestDebugOut("In COleObject::EnumVerbs\r\n");

	return ResultFromScode( OLE_S_USEREG );
};

//**********************************************************************
//
// COleObject::GetClientSite
//
// Purpose:
//
//      Called to get the current client site of the object.
//
// Parameters:
//
//      LPOLECLIENTSITE FAR* ppClientSite   - Out ptr in which to return the
//                                            client site.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::GetClientSite  ( LPOLECLIENTSITE FAR* ppClientSite)
{
	TestDebugOut("In COleObject::GetClientSite\r\n");
	*ppClientSite = m_lpObj->m_lpOleClientSite;
	return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::SetMoniker
//
// Purpose:
//
//      Used to set the objects moniker
//
// Parameters:
//
//      DWORD dwWhichMoniker    - Type of moniker being set
//
//      LPMONIKER pmk           - Pointer to the moniker
//
// Return Value:
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::SetMoniker  ( DWORD dwWhichMoniker, LPMONIKER pmk)
{
	TestDebugOut("In COleObject::SetMoniker\r\n");

	LPMONIKER lpmk;

	if (! m_lpObj->GetOleClientSite())
		return ResultFromScode (E_FAIL);

	if (m_lpObj->GetOleClientSite()->GetMoniker (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL, &lpmk) != NOERROR)
		return ResultFromScode (E_FAIL);


	if (m_lpObj->GetOleAdviseHolder())
		m_lpObj->GetOleAdviseHolder()->SendOnRename(lpmk);

	LPRUNNINGOBJECTTABLE lpRot;

	if (GetRunningObjectTable(0, &lpRot) == NOERROR)
		{
		if (m_lpObj->m_dwRegister)
			lpRot->Revoke(m_lpObj->m_dwRegister);

		lpRot->Register(0, m_lpObj, lpmk, &m_lpObj->m_dwRegister);

		lpRot->Release();
		}


	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleObject::GetMoniker
//
// Purpose:
//
////
// Parameters:
//
//      DWORD dwAssign          - Assignment for the moniker
//
//      DWORD dwWhichMoniker    - Which moniker to return
//
//      LPMONIKER FAR* ppmk     - An out ptr to return the moniker
//
// Return Value:
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::GetMoniker  (  DWORD dwAssign, DWORD dwWhichMoniker,
										LPMONIKER FAR* ppmk)
{
	TestDebugOut("In COleObject::GetMoniker\r\n");
	// need to NULL the out parameter
	*ppmk = NULL;

	return m_lpObj->GetOleClientSite()->GetMoniker (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL, ppmk);
};

//**********************************************************************
//
// COleObject::InitFromData
//
// Purpose:
//
//      Initialize the object from the passed pDataObject.
//
// Parameters:
//
//      LPDATAOBJECT pDataObject    - Pointer to data transfer object
//                                    to be used in the initialization
//
//      BOOL fCreation              - TRUE if the object is currently being
//                                    created.
//
//      DWORD dwReserved            - Reserved
//
// Return Value:
//
//      S_FALSE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      We don't support this functionality, so we will always return
//      error.
//
//********************************************************************

STDMETHODIMP COleObject::InitFromData  ( LPDATAOBJECT pDataObject,
										 BOOL fCreation,
										 DWORD dwReserved)
{
	TestDebugOut("In COleObject::InitFromData\r\n");

	return ResultFromScode( S_FALSE );
};

//**********************************************************************
//
// COleObject::GetClipboardData
//
// Purpose:
//
//      Returns an IDataObject that is the same as doing an OleSetClipboard
//
// Parameters:
//
//      DWORD dwReserved                - Reserved
//
//      LPDATAOBJECT FAR* ppDataObject  - Out ptr for the Data Object.
//
// Return Value:
//
//      OLE_E_NOTSUPPORTED
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Support of this method is optional.
//
//********************************************************************

STDMETHODIMP COleObject::GetClipboardData  ( DWORD dwReserved,
											 LPDATAOBJECT FAR* ppDataObject)
{
	TestDebugOut("In COleObject::GetClipboardData\r\n");
	// NULL the out ptr
	*ppDataObject = NULL;
	return ResultFromScode( E_NOTIMPL );
};

//**********************************************************************
//
// COleObject::IsUpToDate
//
// Purpose:
//
//      Determines if an object is up to date
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Our embedded object is always up to date.  This function is
//      particularly useful in linking situations.
//
//********************************************************************

STDMETHODIMP COleObject::IsUpToDate()
{
	TestDebugOut("In COleObject::IsUpToDate\r\n");
	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleObject::GetUserClassID
//
// Purpose:
//
//      Returns the applications CLSID
//
// Parameters:
//
//      CLSID FAR* pClsid   - Out ptr to return the CLSID
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CPersistStorage::GetClassID IPS.CPP
//
// Comments:
//
//      This function is just delegated to IPS::GetClassID.
//
//********************************************************************

STDMETHODIMP COleObject::GetUserClassID  ( CLSID FAR* pClsid)
{
	TestDebugOut("In COleObject::GetUserClassID\r\n");

	m_lpObj->m_PersistStorage.GetClassID(pClsid);
	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleObject::GetUserType
//
// Purpose:
//
//      Used to get a user presentable id for this object
//
// Parameters:
//
//      DWORD dwFormOfType      - The ID requested
//
//      LPSTR FAR* pszUserType  - Out ptr to return the string
//
// Return Value:
//
//      OLE_S_USEREG    - Use the reg db to get these entries.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::GetUserType  ( DWORD dwFormOfType, LPSTR FAR* pszUserType)
{
	TestDebugOut("In COleObject::GetUserType\r\n");

	return ResultFromScode( OLE_S_USEREG );
};

//**********************************************************************
//
// COleObject::SetExtent
//
// Purpose:
//
//      Called to set the extent of the object.
//
// Parameters:
//
//      DWORD dwDrawAspect  - Aspect to have its size set
//
//      LPSIZEL lpsizel     - New size of the object.
//
// Return Value:
//
//      E_NOTIMPL   - This function is not curently implemented.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::SetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	TestDebugOut("In COleObject::SetExtent\r\n");
	return ResultFromScode( E_NOTIMPL);
};

//**********************************************************************
//
// COleObject::EnumAdvise
//
// Purpose:
//
//      Returns an enumerate which enumerates the outstanding advises
//      associated with this OLE object.
//
// Parameters:
//
//      LPENUMSTATDATA FAR* ppenumAdvise - Out ptr in which to return
//                                         the enumerator.
//
// Return Value:
//
//      Passed on from IOleAdviseHolder::EnumAdvise.
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      IOleAdviseHolder::EnumAdvise    OLE
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::EnumAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise)
{
	TestDebugOut("In COleObject::EnumAdvise\r\n");
	// need to NULL the out parameter
	*ppenumAdvise = NULL;

	// pass on to the OLE Advise holder.
	return m_lpObj->m_lpOleAdviseHolder->EnumAdvise(ppenumAdvise);
};

//**********************************************************************
//
// COleObject::GetMiscStatus
//
// Purpose:
//
//      Return status information about the object
//
// Parameters:
//
//      DWORD dwAspect          - Aspect interested in.
//
//      DWORD FAR* pdwStatus    - Out ptr in which to return the bits.
//
// Return Value:
//
//      CO_E_READREGDB  - Tell the library to use the reg DB.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleObject::GetMiscStatus  ( DWORD dwAspect, DWORD FAR* pdwStatus)
{
	TestDebugOut("In COleObject::GetMiscStatus\r\n");
	// need to NULL the out parameter
	*pdwStatus = NULL;
	return ResultFromScode( OLE_S_USEREG );
};

//**********************************************************************
//
// COleObject::SetColorScheme
//
// Purpose:
//
//      Used to set the palette for the object to use.
//
// Parameters:
//
//      LPLOGPALETTE lpLogpal   - Pointer to the LOGPALETTE to be used.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This server ignores this method.
//
//********************************************************************

STDMETHODIMP COleObject::SetColorScheme  ( LPLOGPALETTE lpLogpal)
{
	TestDebugOut("In COleObject::SetColorScheme\r\n");
	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleObject::OpenEdit
//
// Purpose:
//
//      Used to Open the object into a seperate window.
//
// Parameters:
//
//      LPOLECLIENTSITE pActiveSite - Pointer to the Active clientsite.
//
// Return Value:
//
//      None.
//
// Function Calls:
//      Function                        Location
//
//      IOleClientSite::OnShowWindow    Container
//      ShowWindow                      Windows API
//      UpdateWindow                    Windows API
//      TestDebugOut               Windows API
//      CSimpSvrDoc::GethAppWnd         DOC.H
//      CSimpSvrDoc::GethHatchWnd       DOC.H
//
// Comments:
//
//
//********************************************************************

void COleObject::OpenEdit(LPOLECLIENTSITE pActiveSite)
{
   if (m_lpObj->GetOleClientSite())
	   m_lpObj->GetOleClientSite()->ShowObject();


	m_fOpen = TRUE;

	// tell the site we are opening so the object can be hatched out.
	if (m_lpObj->GetOleClientSite())
		m_lpObj->GetOleClientSite()->OnShowWindow(TRUE);


	m_lpObj->m_lpDoc->ShowDocWnd();

	m_lpObj->m_lpDoc->HideHatchWnd();

	// Show app window.
	m_lpObj->m_lpDoc->GetApp()->ShowAppWnd();

	SetFocus(m_lpObj->m_lpDoc->GethAppWnd());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\ioipo.h ===
//**********************************************************************
// File name: ioipo.h
//
//      Definition of COleInPlaceObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _IOIPO_H_)
#define _IOIPO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface COleInPlaceObject : public IOleInPlaceObject
{
private:
	CSimpSvrObj FAR * m_lpObj;
	int m_nCount;

public:
	COleInPlaceObject::COleInPlaceObject(CSimpSvrObj FAR * lpSimpSvrObj)
		{
		m_lpObj = lpSimpSvrObj;
		m_nCount = 0;
		};
	COleInPlaceObject::~COleInPlaceObject() {};

//  IUnknown Methods
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP InPlaceDeactivate  ();
	STDMETHODIMP UIDeactivate  () ;
	STDMETHODIMP SetObjectRects  ( LPCRECT lprcPosRect, LPCRECT lprcClipRect);
	STDMETHODIMP GetWindow  ( HWND FAR* lphwnd) ;
	STDMETHODIMP ContextSensitiveHelp  ( BOOL fEnterMode);
	STDMETHODIMP ReactivateAndUndo  ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\ips.h ===
//**********************************************************************
// File name: ips.h
//
//      Definition of CPersistStorage
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _IPS_H_)
#define _IPS_H_


#include <ole2.h>
#include <storage.h>
#include "obj.h"

class CSimpSvrObj;

interface CPersistStorage : IPersistStorage
{
private:
	CSimpSvrObj FAR * m_lpObj;
	int m_nCount;
	BOOL m_fSameAsLoad;

public:
	CPersistStorage::CPersistStorage(CSimpSvrObj FAR * lpSimpSvrObj)
		{
		m_lpObj = lpSimpSvrObj;
		m_nCount = 0;
		};
	CPersistStorage::~CPersistStorage() {};

	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP InitNew (LPSTORAGE pStg);
	STDMETHODIMP GetClassID  ( LPCLSID lpClassID) ;
	STDMETHODIMP Save  ( LPSTORAGE pStgSave, BOOL fSameAsLoad) ;
	STDMETHODIMP SaveCompleted  ( LPSTORAGE pStgNew);
	STDMETHODIMP Load  ( LPSTORAGE pStg);
	STDMETHODIMP IsDirty  ();
	STDMETHODIMP HandsOffStorage  ();

	void ReleaseStreamsAndStorage();
	void OpenStreams(LPSTORAGE lpStg);
	void CreateStreams(LPSTORAGE lpStg);
	void CreateStreams(LPSTORAGE lpStg, LPSTREAM FAR *lpTempColor, LPSTREAM FAR *lpTempSize);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\ioipao.cpp ===
//**********************************************************************
// File name: IOIPAO.CPP
//
//    Implementation file for the CClassFactory Class
//
// Functions:
//
//    See ioipao.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioipao.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// COleInPlaceActiveObject::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In COleInPlaceActiveObject::QueryInterface\r\n");
	// need to NULL the out parameter
	return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceActiveObject::AddRef
//
// Purpose:
//
//      Increments the reference count on COleInPlaceActiveObject and the
//      "object" object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on the "object" object.
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceActiveObject::AddRef ()
{
	TestDebugOut("In COleInPlaceActiveObject::AddRef\r\n");

	++m_nCount;

	return m_lpObj->AddRef();
}

//**********************************************************************
//
// COleInPlaceActiveObject::Release
//
// Purpose:
//
//      Decrements the reference count of COleInPlaceActiveObject.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceActiveObject::Release ()
{
	TestDebugOut("In COleInPlaceActiveObject::Release\r\n");

	--m_nCount;

	return m_lpObj->Release();
}

//**********************************************************************
//
// COleInPlaceActiveObject::OnDocWindowActivate
//
// Purpose:
//
//      Called when the doc window (in an MDI App) is (de)activated.
//
// Parameters:
//
//      BOOL fActivate  - TRUE if activating, FALSE if deactivating
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleInPlaceFrame::SetActiveObject   Container
//      CSimpSvrObject::AddFrameLevelUI     OBJ.CPP
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::OnDocWindowActivate  ( BOOL fActivate )
{
	TestDebugOut("In COleInPlaceActiveObject::OnDocWindowActivate\r\n");

	// Activating?
	if (fActivate)
		m_lpObj->AddFrameLevelUI();

	// No frame level tools to remove...

	return ResultFromScode(S_OK);
};

//**********************************************************************
//
// COleInPlaceActiveObject::OnFrameWindowActivate
//
// Purpose:
//
//      Called when the Frame window is (de)activating
//
// Parameters:
//
//      BOOL fActivate  - TRUE if activating, FALSE if Deactivating
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetFocus                    Windows API
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::OnFrameWindowActivate  ( BOOL fActivate)
{
	TestDebugOut("In COleInPlaceActiveObject::OnFrameWindowActivate\r\n");

	// set the focus to the object window if we are activating.
/*    if (fActivate)
		SetFocus(m_lpObj->m_lpDoc->GethDocWnd()); */

	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleInPlaceActiveObject::GetWindow
//
// Purpose:
//
//      Gets the objects Window Handle.
//
// Parameters:
//
//      HWND FAR* lphwnd    - Location to return the window handle.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::GethDocWnd     DOC.H
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::GetWindow  ( HWND FAR* lphwnd)
{
	TestDebugOut("In COleInPlaceActiveObject::GetWindow\r\n");
	// need to NULL the out parameter
	*lphwnd = m_lpObj->m_lpDoc->GethDocWnd();
	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleInPlaceActiveObject::ContextSensitiveHelp
//
// Purpose:
//
//      Used to implement Context Sensitive help
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      See TECHNOTES.WRI include with the OLE SDK for proper
//      implementation of this function.
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::ContextSensitiveHelp  ( BOOL fEnterMode )
{
	TestDebugOut("In COleInPlaceActiveObject::ContextSensitiveHelp\r\n");
	return ResultFromScode( E_NOTIMPL);
};

//**********************************************************************
//
// COleInPlaceActiveObject::TranslateAccelerator
//
// Purpose:
//
//      Used for translating accelerators in .DLL objects.
//
// Parameters:
//
//      LPMSG lpmsg - Pointer to a message
//
// Return Value:
//
//      S_FALSE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      This method should never be called since we are implemented
//      in an executable.
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::TranslateAccelerator  ( LPMSG lpmsg)
{
	TestDebugOut("In COleInPlaceActiveObject::TranslateAccelerator\r\n");
	// no accelerator table, return FALSE
	return ResultFromScode( S_FALSE );
};

//**********************************************************************
//
// COleInPlaceActiveObject::ResizeBorder
//
// Purpose:
//
//      Called when the border changes size.
//
// Parameters:
//
//      LPCRECT lprectBorder                - New Border
//
//      LPOLEINPLACEUIWINDOW lpUIWindow     - Pointer to UIWindow
//
//      BOOL fFrameWindow                   - True if lpUIWindow is the
//                                            frame window.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      Need to call SetBorderSpace again...
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::ResizeBorder  ( LPCRECT lprectBorder,
													  LPOLEINPLACEUIWINDOW lpUIWindow,
													  BOOL fFrameWindow)
{
	TestDebugOut("In COleInPlaceActiveObject::ResizeBorder\r\n");

	// should always have an inplace frame...
	m_lpObj->GetInPlaceFrame()->SetBorderSpace(NULL);

	// There will only be a UIWindow if in an MDI container
	if (m_lpObj->GetUIWindow())
		m_lpObj->GetUIWindow()->SetBorderSpace(NULL);

	return ResultFromScode( S_OK );
};

//**********************************************************************
//
// COleInPlaceActiveObject::EnableModeless
//
// Purpose:
//
//      Called to enable/disable modeless dialogs.
//
// Parameters:
//
//      BOOL fEnable    - TRUE to enable, FALSE to disable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      Called by the container when a model dialog box is added/removed
//      from the screen.  The appropriate action for a server application
//      is to disable/enable any modeless dialogs currently being displayed.
//      Since this application doesn't display any modeless dialogs,
//      this method is essentially ignored.
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::EnableModeless  ( BOOL fEnable)
{
	TestDebugOut("In COleInPlaceActiveObject::EnableModeless\r\n");
	return ResultFromScode( S_OK );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\pre.cpp ===
//**********************************************************************
// File name: pre.cpp
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\ips.cpp ===
//**********************************************************************
// File name: ips.cpp
//
//    Implementation file for the CSimpSvrApp Class
//
// Functions:
//
//    See ips.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ips.h"
#include "app.h"
#include "doc.h"

#include <storage.h>

#ifdef WIN32
DEFINE_GUID(GUID_SIMPLE, 0xBCF6D4A0, 0xBE8C, 0x1068, 0xB6, 0xD4, 0x00, 0xDD, 0x01, 0x0C, 0x05, 0x09);
#else
DEFINE_GUID(GUID_SIMPLE, 0x9fb878d0, 0x6f88, 0x101b, 0xbc, 0x65, 0x00, 0x00, 0x0b, 0x65, 0xc7, 0xa6);
#endif

//**********************************************************************
//
// CPersistStorage::QueryInterface
//
// Purpose:
//
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
        TestDebugOut("In CPersistStorage::QueryInterface\r\n");
        // need to NULL the out parameter
        return m_lpObj->QueryInterface(riid, ppvObj);
};

//**********************************************************************
//
// CPersistStorage::AddRef
//
// Purpose:
//
//      Increments the reference count on CPersistStorage and the "object"
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on the Object.
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CPersistStorage::AddRef ()
{
        TestDebugOut("In CPersistStorage::AddRef\r\n");
        ++m_nCount;
        return m_lpObj->AddRef();
};

//**********************************************************************
//
// CPersistStorage::Release
//
// Purpose:
//
//      Decrements the reference count of CPersistStorage and the
//      "object" object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CPersistStorage::Release ()
{
        TestDebugOut("In CPersistStorage::Release\r\n");
        --m_nCount;
        return m_lpObj->Release();
};

//**********************************************************************
//
// CPersistStorage::InitNew
//
// Purpose:
//
//      Used to give a new OLE object a ptr to its storage.
//
// Parameters:
//
//      LPSTORAGE pStg  - Pointer to the storage
//
// Return Value:
//
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//      IStorage::AddRef            OLE
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::InitNew (LPSTORAGE pStg)
{
        TestDebugOut("In CPersistStorage::InitNew\r\n");

        // release any streams and storages that may be open
        ReleaseStreamsAndStorage();

        m_lpObj->m_lpStorage = pStg;

        // AddRef the new Storage
        if (m_lpObj->m_lpStorage)
                m_lpObj->m_lpStorage->AddRef();

        CreateStreams(m_lpObj->m_lpStorage);

        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// CPersistStorage::GetClassID
//
// Purpose:
//
//      Returns the CLSID of this object.
//
// Parameters:
//
//      LPCLSID lpClassID   - Out ptr in which to return the CLSID
//
// Return Value:
//
//       S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::GetClassID  ( LPCLSID lpClassID)
{
        TestDebugOut("In CPersistStorage::GetClassID\r\n");

        *lpClassID = GUID_SIMPLE;

        return ResultFromScode( S_OK );
};

//**********************************************************************
//
// CPersistStorage::Save
//
// Purpose:
//
//      Instructs the object to save itself into the storage.
//
// Parameters:
//
//      LPSTORAGE pStgSave  - Storage in which the object should be saved
//
//      BOOL fSameAsLoad    - TRUE if pStgSave is the same as the storage
//                            that the object was originally created with.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CPersistStorage::InitNew    IPS.CPP
//      CSimpSvrObj::SaveToStorage  OBJ.CPP
//
//
// Comments:
//
//      A real app will want better error checking in this method.
//
//********************************************************************

STDMETHODIMP CPersistStorage::Save  ( LPSTORAGE pStgSave, BOOL fSameAsLoad)
{
        TestDebugOut("In CPersistStorage::Save\r\n");

        // save the data
        m_lpObj->SaveToStorage (pStgSave, fSameAsLoad);

        m_lpObj->m_fSaveWithSameAsLoad = fSameAsLoad;
        m_lpObj->m_fNoScribbleMode = TRUE;

        return ResultFromScode( S_OK );
};

//**********************************************************************
//
// CPersistStorage::SaveCompleted
//
// Purpose:
//
//      Called when the container is finished saving the object
//
// Parameters:
//
//      LPSTORAGE pStgNew   - ptr to the new storage
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::SaveCompleted  ( LPSTORAGE pStgNew)
{
        TestDebugOut("In CPersistStorage::SaveCompleted\r\n");

        if (pStgNew)
                {
                ReleaseStreamsAndStorage();
                m_lpObj->m_lpStorage = pStgNew;
                m_lpObj->m_lpStorage->AddRef();
                OpenStreams(pStgNew);
                }


        /* OLE2NOTE: it is only legal to perform a Save or SaveAs operation
        **    on an embedded object. if the document is a file-based document
        **    then we can not be changed to a IStorage-base object.
        **
        **      fSameAsLoad   lpStgNew     Type of Save     Send OnSave
        **    ---------------------------------------------------------
        **         TRUE        NULL        SAVE             YES
        **         TRUE        ! NULL      SAVE *           YES
        **         FALSE       ! NULL      SAVE AS          YES
        **         FALSE       NULL        SAVE COPY AS     NO
        **
        **    * this is a strange case that is possible. it is inefficient
        **    for the caller; it would be better to pass lpStgNew==NULL for
        **    the Save operation.
        */

        if ( pStgNew || m_lpObj->m_fSaveWithSameAsLoad)
                {
                if (m_lpObj->m_fNoScribbleMode)
                        m_lpObj->GetOleAdviseHolder()->SendOnSave();  // normally would clear a
                                                                                                                  // dirty bit
                m_lpObj->m_fSaveWithSameAsLoad = FALSE;
                }

        m_lpObj->m_fNoScribbleMode = FALSE;

        return ResultFromScode( S_OK );
};

//**********************************************************************
//
// CPersistStorage::Load
//
// Purpose:
//
//      Instructs the object to be loaded from storage.
//
// Parameters:
//
//      LPSTORAGE pStg  - Ptr to the storage in which to be loaded
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      CSimpSvrObj::LoadFromStorage    OBJ.CPP
//
//
// Comments:
//
//      A real app will want better error checking in this method.
//
//********************************************************************

STDMETHODIMP CPersistStorage::Load  ( LPSTORAGE pStg)
{
        TestDebugOut("In CPersistStorage::Load\r\n");

        // remember the storage
        if (m_lpObj->m_lpStorage)
                {
                m_lpObj->m_lpStorage->Release();
                m_lpObj->m_lpStorage = NULL;
                }

        m_lpObj->m_lpStorage = pStg;

        m_lpObj->m_lpStorage->AddRef();

        OpenStreams(m_lpObj->m_lpStorage);

        m_lpObj->LoadFromStorage();


        return ResultFromScode( S_OK );
};


//**********************************************************************
//
// CPersistStorage::IsDirty
//
// Purpose:
//
//      Returns whether or not the object is dirty w/respect to its
//      Storage
//
// Parameters:
//
//      None
//
// Return Value:
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      This sample does not implement this function, although a
//      real application should.
//
//********************************************************************

STDMETHODIMP CPersistStorage::IsDirty()
{
        TestDebugOut("In CPersistStorage::IsDirty\r\n");
        return ResultFromScode( S_OK );
};

//**********************************************************************
//
// CPersistStorage::HandsOffStorage
//
// Purpose:
//
//      Forces the object to release its handle to its storage.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::HandsOffStorage  ()
{
        TestDebugOut("In CPersistStorage::HandsOffStorage\r\n");

        ReleaseStreamsAndStorage();

        return ResultFromScode( S_OK );
};

//**********************************************************************
//
// CPersistStorage::CreateStreams
//
// Purpose:
//
//      Creates the streams that are held open for the object's lifetime.
//
// Parameters:
//
//      LPSTORAGE lpStg -   Storage in which to create the streams
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//      IStream::Release            OLE
//      IStorage::CreateStream      OLE
//
// Comments:
//
//
//********************************************************************

void CPersistStorage::CreateStreams(LPSTORAGE lpStg)
{
        if (m_lpObj->m_lpColorStm)
                m_lpObj->m_lpColorStm->Release();

        if (m_lpObj->m_lpSizeStm)
                m_lpObj->m_lpSizeStm->Release();

                // create a stream to save the colors
        lpStg->CreateStream ( "RGB",
                                                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                                   0,
                                                   0,
                                                   &m_lpObj->m_lpColorStm);

        // create a stream to save the size
        lpStg->CreateStream ( "size",
                                                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                                   0,
                                                   0,
                                                   &m_lpObj->m_lpSizeStm);
}

//**********************************************************************
//
// CPersistStorage::OpenStreams
//
// Purpose:
//
//      Opens the streams in a storage.
//
// Parameters:
//
//      LPSTORAGE lpStg -   Storage in which to open the streams.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//
// Comments:
//
//
//********************************************************************

void CPersistStorage::OpenStreams(LPSTORAGE lpStg)
{
        if (m_lpObj->m_lpColorStm)
                m_lpObj->m_lpColorStm->Release();

        if (m_lpObj->m_lpSizeStm)
                m_lpObj->m_lpSizeStm->Release();

                // open the color stream
        lpStg->OpenStream ( "RGB",
                                                   0,
                                                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                                   0,
                                                   &m_lpObj->m_lpColorStm);

        // open the color stream
        lpStg->OpenStream ( "size",
                                                   0,
                                                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                                   0,
                                                   &m_lpObj->m_lpSizeStm);
}

//**********************************************************************
//
// CPersistStorage::ReleaseStreamsAndStorage
//
// Purpose:
//
//      Releases the stream and storage ptrs
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//
// Comments:
//
//
//********************************************************************

void CPersistStorage::ReleaseStreamsAndStorage()
{
        if (m_lpObj->m_lpColorStm)
                {
                m_lpObj->m_lpColorStm->Release();
                m_lpObj->m_lpColorStm = NULL;
                }

        if (m_lpObj->m_lpSizeStm)
                {
                m_lpObj->m_lpSizeStm->Release();
                m_lpObj->m_lpSizeStm = NULL;
                }

        if (m_lpObj->m_lpStorage)
                {
                m_lpObj->m_lpStorage->Release();
                m_lpObj->m_lpStorage = NULL;
                }
}

//**********************************************************************
//
// CPersistStorage::CreateStreams
//
// Purpose:
//
//      Creates temporary streams in a storage.
//
// Parameters:
//
//      LPSTORAGE lpStg                 - Pointer to the storage
//
//      LPSTREAM FAR* lplpTempColor     - Color Stream
//
//      LPSTREAM FAR* lplpTempSize      - Size Stream
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//
// Comments:
//
//
//********************************************************************

void CPersistStorage::CreateStreams(LPSTORAGE lpStg, LPSTREAM FAR* lplpTempColor,LPSTREAM FAR* lplpTempSize)
{
                // create a stream to save the colors
         lpStg->CreateStream ( "RGB",
                                                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                                   0,
                                                   0,
                                                   lplpTempColor);

        // create a stream to save the size
        lpStg->CreateStream ( "size",
                                                   STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                                   0,
                                                   0,
                                                   lplpTempSize);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\ioo.h ===
//**********************************************************************
// File name: ioo.h
//
//      Definition of COleObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOO_H_)
#define _IOO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface COleObject : public IOleObject
{
private:
	CSimpSvrObj FAR * m_lpObj;
	int m_nCount;
	BOOL m_fOpen;

public:
	COleObject::COleObject(CSimpSvrObj FAR * lpSimpSvrObj)
		{
		m_lpObj = lpSimpSvrObj;
		m_nCount = 0;
		m_fOpen = FALSE;
		};
	COleObject::~COleObject()
		{
		};
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

	STDMETHODIMP SetClientSite (LPOLECLIENTSITE pClientSite);
	STDMETHODIMP Advise (LPADVISESINK pAdvSink, DWORD FAR* pdwConnection);
	STDMETHODIMP SetHostNames  ( LPCSTR szContainerApp, LPCSTR szContainerObj);
	STDMETHODIMP DoVerb  (  LONG iVerb,
							LPMSG lpmsg,
							LPOLECLIENTSITE pActiveSite,
							LONG lindex,
							HWND hwndParent,
							LPCRECT lprcPosRect);
	STDMETHODIMP GetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel);
	STDMETHODIMP Update  () ;
	STDMETHODIMP Close  ( DWORD dwSaveOption) ;
	STDMETHODIMP Unadvise ( DWORD dwConnection);
	STDMETHODIMP EnumVerbs  ( LPENUMOLEVERB FAR* ppenumOleVerb) ;
	STDMETHODIMP GetClientSite  ( LPOLECLIENTSITE FAR* ppClientSite);
	STDMETHODIMP SetMoniker  ( DWORD dwWhichMoniker, LPMONIKER pmk);
	STDMETHODIMP GetMoniker  ( DWORD dwAssign, DWORD dwWhichMoniker,
							   LPMONIKER FAR* ppmk);
	STDMETHODIMP InitFromData  ( LPDATAOBJECT pDataObject,
								 BOOL fCreation,
								 DWORD dwReserved);
	STDMETHODIMP GetClipboardData  ( DWORD dwReserved,
									 LPDATAOBJECT FAR* ppDataObject);
	STDMETHODIMP IsUpToDate  ();
	STDMETHODIMP GetUserClassID  ( CLSID FAR* pClsid);
	STDMETHODIMP GetUserType  ( DWORD dwFormOfType, LPSTR FAR* pszUserType);
	STDMETHODIMP SetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel);
	STDMETHODIMP EnumAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise);
	STDMETHODIMP GetMiscStatus  ( DWORD dwAspect, DWORD FAR* pdwStatus);
	STDMETHODIMP SetColorScheme  ( LPLOGPALETTE lpLogpal);

	void OpenEdit(LPOLECLIENTSITE pActiveSite);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <ole2.h>
#include <ole2ui.h>
#include <assert.h>
#include <string.h>
#include "simpsvr.h"
#include "resource.h"
#include <ole2ver.h>
extern "C" void TestDebugOut(LPSTR psz);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\simpsvr.h ===
//**********************************************************************
// File name: simpsvr.h
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#define IDM_ABOUT 100
#define IDM_INSERT  101
#define IDM_VERB0 1000


int PASCAL WinMain(HANDLE hInstance,HANDLE hPrevInstance,LPSTR lpCmdLine,int nCmdShow);
BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, int nCmdShow);
long FAR PASCAL _export MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
long FAR PASCAL _export DocWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL FAR PASCAL _export About(HWND hDlg, unsigned message, WORD wParam, LONG lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SIMPSVR.RC
//
#define IDM_OPEN                        102
#define IDM_SAVE                        103
#define IDM_SAVEAS                      104
#define IDM_PRINT                       105
#define IDM_EXIT                        106
#define IDM_UNDO                        107
#define IDM_CUT                         108
#define IDM_COPY                        109
#define IDM_PASTE                       110
#define ID_EDIT_INSERTOBJECT            111
#define IDM_INSERTOBJECT                111
#define IDM_NEW                         112
#define IDM_RED                         113
#define IDM_GREEN                       114
#define IDM_BLUE                        115
#define IDM_ROTATE                      116

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         117
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\uthread\comclass.h ===
//+-------------------------------------------------------------------
//
//  File:       comclass.h
//
//  Contents:   Define class id for use by com class
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#ifndef _COMCLASS_H_
#define _COMCLASS_H_

extern CLSID clsidServer;

void InitDll(void);

#endif // _COMCLASS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\obj.h ===
//**********************************************************************
// File name: obj.h
//
//      Definition of CSimpSvrObj
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _OBJ_H_)
#define _OBJ_H_

#include "ioipao.h"
#include "ioipo.h"
#include "ioo.h"
#include "ips.h"
#include "ido.h"
#include "iec.h"

class CSimpSvrDoc;
interface COleObject;
interface CPersistStorage;
interface CDataObject;
interface COleInPlaceActiveObject;
interface COleInPlaceObject;
interface CExternalConnection;

class CSimpSvrObj : public IUnknown
{
private:
	CSimpSvrDoc FAR * m_lpDoc;      // Back pointer
	int m_nCount;                   // reference count
	BOOL m_fInPlaceActive;          // Used during InPlace Negotiation
	BOOL m_fInPlaceVisible;         // "  "  "  "   "   "   "   "   "
	BOOL m_fUIActive;               // "  "  "  "   "   "   "   "   "
	HMENU m_hmenuShared;            // "  "  "  "   "   "   "   "   "
	HOLEMENU m_hOleMenu;            // "  "  "  "   "   "   "   "   "
	RECT m_posRect;                 // "  "  "  "   "   "   "   "   "
	OLEINPLACEFRAMEINFO m_FrameInfo;
	BOOL m_fSaveWithSameAsLoad;
	BOOL m_fNoScribbleMode;

	DWORD m_dwRegister;             // Registered in ROT

	int m_red, m_green, m_blue;     // current color
	POINT m_size;                   // current size
	int m_xOffset;
	int m_yOffset;
	float m_scale;

	HWND m_hWndParent;              // parent window handle

	// interfaces used
	LPSTORAGE m_lpStorage;
	LPSTREAM m_lpColorStm, m_lpSizeStm;
	LPOLECLIENTSITE m_lpOleClientSite;          // IOleClientSite
	LPOLEADVISEHOLDER m_lpOleAdviseHolder;      // IOleAdviseHolder
	LPDATAADVISEHOLDER m_lpDataAdviseHolder;    // IDataAdviseHolder
	LPOLEINPLACEFRAME m_lpFrame;                // IOleInPlaceFrame
	LPOLEINPLACEUIWINDOW m_lpCntrDoc;           // IOleInPlaceUIWindow
	LPOLEINPLACESITE m_lpIPSite;                // IOleInPlaceSite

	// interface implemented
	COleObject m_OleObject;                             // IOleObject
	CPersistStorage m_PersistStorage;                   // IPersistStorage
	CDataObject m_DataObject;                           // IDataObject
	COleInPlaceActiveObject m_OleInPlaceActiveObject;   // IOleInPlaceActiveObject
	COleInPlaceObject m_OleInPlaceObject;               // IOleInPlaceObject
	CExternalConnection m_ExternalConnection;

public:
	STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
	STDMETHODIMP_(ULONG) AddRef ();
	STDMETHODIMP_(ULONG) Release ();

// construction/destruction
	CSimpSvrObj(CSimpSvrDoc FAR * lpSimpSvrDoc);
	~CSimpSvrObj();

// utility functions
	void Draw(HDC hDC, BOOL fMetaDC = TRUE);
	void PaintObj(HDC hDC);
	void lButtonDown(WPARAM wParam,LPARAM lParam);
	HANDLE GetMetaFilePict();
	void SaveToStorage (LPSTORAGE lpStg, BOOL fSameAsLoad);
	void LoadFromStorage ();

// visual editing helper functions
	BOOL DoInPlaceActivate (LONG lVerb);
	void AssembleMenus();
	void AddFrameLevelUI();
	void DoInPlaceHide();
	void DisassembleMenus();
	void SendOnDataChange();
	void DeactivateUI();

// member variable access
	inline BOOL IsInPlaceActive() { return m_fInPlaceActive; };
	inline BOOL IsInPlaceVisible() { return m_fInPlaceVisible; };
	inline BOOL IsUIActive() { return m_fUIActive; };
	inline HWND GetParent() { return m_hWndParent; };
	inline LPSTORAGE GetStorage() { return m_lpStorage; };
	inline LPOLECLIENTSITE GetOleClientSite() { return m_lpOleClientSite; };
	inline LPDATAADVISEHOLDER GetDataAdviseHolder() { return m_lpDataAdviseHolder; };
	inline LPOLEADVISEHOLDER GetOleAdviseHolder() { return m_lpOleAdviseHolder; };
	inline LPOLEINPLACEFRAME GetInPlaceFrame() { return m_lpFrame; };
	inline LPOLEINPLACEUIWINDOW GetUIWindow() { return m_lpCntrDoc; };
	inline LPOLEINPLACESITE GetInPlaceSite() { return m_lpIPSite; };
	inline COleObject FAR * GetOleObject() { return &m_OleObject; };
	inline CPersistStorage FAR * GetPersistStorage() { return &m_PersistStorage; };
	inline CDataObject FAR * GetDataObject() { return &m_DataObject; };
	inline COleInPlaceActiveObject FAR * GetOleInPlaceActiveObject() { return &m_OleInPlaceActiveObject; };
	inline COleInPlaceObject FAR * GetOleInPlaceObject() { return &m_OleInPlaceObject; };
	inline void ClearOleClientSite() { m_lpOleClientSite = NULL; };
	inline void ClearDataAdviseHolder() { m_lpDataAdviseHolder = NULL; };
	inline void ClearOleAdviseHolder() { m_lpOleAdviseHolder = NULL; };
	inline LPRECT GetPosRect() { return &m_posRect; };
	inline LPPOINT GetSize() { return &m_size; };
	inline LPOLEINPLACEFRAMEINFO GetFrameInfo() {return &m_FrameInfo;};
	inline DWORD GetRotRegister() { return m_dwRegister; };



	// member manipulation
	inline void SetColor (int nRed, int nGreen, int nBlue)
		{ m_red = nRed; m_green = nGreen; m_blue = nBlue; };

	inline void RotateColor()
		{ m_red+=10; m_green+=10; m_blue+=10;};


// all of the interface implementations should be friends of this
// class
friend interface COleObject;
friend interface CPersistStorage;
friend interface CDataObject;
friend interface COleInPlaceActiveObject;
friend interface COleInPlaceObject;
friend interface CExternalConnection;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\obj.cpp ===
//**********************************************************************
// File name: obj.cpp
//
//    Implementation file for the CSimpSvrApp Class
//
// Functions:
//
//    See obj.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioo.h"
#include "ido.h"
#include "ips.h"
#include "icf.h"
#include "ioipao.h"
#include "ioipo.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CSimpSvrObj::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the "Object" level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK          -   The interface is supported.
//      E_NOINTERFACE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      IUnknown::AddRef            OBJ.CPP, IOO.CPP, IDO.CPP, IPS.CPP
//                                  IOIPO.CPP, IOIPAO.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CSimpSvrObj::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
	TestDebugOut("In CSimpSvrObj::QueryInterface\r\n");

	SCODE sc = S_OK;

	if (riid == IID_IUnknown)
		*ppvObj = this;
	else if (riid == IID_IOleObject)
		*ppvObj = &m_OleObject;
	else if (riid == IID_IDataObject)
		*ppvObj = &m_DataObject;
	else if ( (riid == IID_IPersistStorage) || (riid == IID_IPersist) )
		*ppvObj = &m_PersistStorage;
	else if (riid == IID_IOleInPlaceObject)
		*ppvObj = &m_OleInPlaceObject;
	else if (riid == IID_IOleInPlaceActiveObject)
		*ppvObj = &m_OleInPlaceActiveObject;
	else if (riid == IID_IExternalConnection)
		 *ppvObj = &m_ExternalConnection;
	else
		{
		*ppvObj = NULL;
		sc = E_NOINTERFACE;
		}

	if (*ppvObj)
		((LPUNKNOWN)*ppvObj)->AddRef();

	return ResultFromScode( sc );
};

//**********************************************************************
//
// CSimpSvrObj::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Object level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Object.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrObj::AddRef ()
{
	TestDebugOut("In CSimpSvrObj::AddRef\r\n");

	m_lpDoc->AddRef();

	return ++m_nCount;
};

//**********************************************************************
//
// CSimpSvrObj::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the object.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrObj::Release ()
{
	TestDebugOut("In CSimpSvrObj::Release\r\n");

	m_lpDoc->Release();

	if (--m_nCount == 0) {
		delete this;
        return 0;
    }

	return m_nCount;
};

//**********************************************************************
//
// CSimpSvrObj::CSimpSvrObj
//
// Purpose:
//
//      Constructor for CSimpSvrObj
//
// Parameters:
//
//      CSimpSvrDoc FAR * lpSimpSvrDoc - ptr to the doc object
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//
//********************************************************************
#pragma warning (disable : 4355) // "this" used in base initializer list warning.  This
								 // can be disabled because we are not using "this" in
								 // the constructor for these objects, rather we are
								 // just storing it for future use...
CSimpSvrObj::CSimpSvrObj(CSimpSvrDoc FAR * lpSimpSvrDoc) : m_OleObject(this),
														   m_DataObject(this),
														   m_PersistStorage(this),
														   m_OleInPlaceActiveObject(this),
														   m_OleInPlaceObject(this),
														   m_ExternalConnection(this)
#pragma warning (default : 4355) // Turn the warning back on

{
	m_lpDoc = lpSimpSvrDoc;
	m_nCount = 0;
	m_fInPlaceActive = FALSE;
	m_fInPlaceVisible = FALSE;
	m_fUIActive = FALSE;
	m_hmenuShared = NULL;
	m_hOleMenu = NULL;

	m_dwRegister = 0;

	m_lpFrame = NULL;
	m_lpCntrDoc = NULL;

	m_lpStorage = NULL;
	m_lpColorStm = NULL;
	m_lpSizeStm = NULL;
	m_lpOleClientSite = NULL;
	m_lpOleAdviseHolder = NULL;
	m_lpDataAdviseHolder = NULL;
	m_lpIPSite = NULL;

	m_red = 128;
	m_green = 0;
	m_blue = 0;

	m_size.x = 100;
	m_size.y = 100;

	m_xOffset = 0;
	m_yOffset = 0;

	m_scale = 1;

	m_fSaveWithSameAsLoad = FALSE;
	m_fNoScribbleMode = FALSE;

}

//**********************************************************************
//
// CSimpSvrObj::~CSimpSvrObj
//
// Purpose:
//
//      Destructor for CSimpSvrObj
//
// Parameters:
//
//      None
//
// Return Value:
//
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      PostMessage                 Windows API
//      CSimpSvrDoc::GetApp         DOC.H
//      CSimpSvrDoc::GethAppWnd     DOC.H
//      CSimpSvrDoc::ClearObj       DOC.H
//      CSimpSvrApp::IsStartedByOle APP.CPP
//
// Comments:
//
//
//********************************************************************

CSimpSvrObj::~CSimpSvrObj()
{
	TestDebugOut("In CSimpSvrObj's Destructor \r\n");

	// if we were started by ole, post ourselves a close message
	if (m_lpDoc->GetApp()->IsStartedByOle())
		PostMessage(m_lpDoc->GethAppWnd(), WM_SYSCOMMAND, SC_CLOSE, 0L);

	// clear the OBJ ptr in the doc class
	m_lpDoc->ClearObj();

}

//**********************************************************************
//
// CSimpSvrObj::Draw
//
// Purpose:
//
//      Draws the object into an arbitrary DC
//
// Parameters:
//
//      HDC hDC - DC to draw into
//
// Return Value:
//
//      NONE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CreateBrushIndirect         Windows API
//      SelectObject                Windows API
//      Rectangle                   Windows API
//      DeleteObject                Windows API
//
// Comments:
//
//
//********************************************************************

void CSimpSvrObj::Draw (HDC hDC, BOOL m_fMeta)
{
	LOGBRUSH lb;

	TestDebugOut("In CSimpSvrObj::Draw\r\n");

	char szBuffer[255];
	wsprintf(szBuffer,"Drawing Scale %3d\r\n",m_scale);
	TestDebugOut(szBuffer);

	if (!m_fMeta)
		{
		SetMapMode(hDC, MM_ANISOTROPIC);
		SetWindowOrg(hDC, (int)(m_xOffset/m_scale), (int)(m_yOffset/m_scale));
		SetWindowExt(hDC, m_size.x, m_size.y);
		SetViewportExt(hDC, (int)(m_size.x*m_scale), (int)(m_size.y*m_scale));
		}

	// fill out a LOGBRUSH
	lb.lbStyle = BS_SOLID;
	lb.lbColor = RGB(m_red, m_green, m_blue);
	lb.lbHatch = 0;

	// create the brush
	HBRUSH hBrush = CreateBrushIndirect(&lb);

	// select the brush
	HBRUSH hOldBrush = SelectObject(hDC, hBrush);
	HPEN hPen = CreatePen(PS_INSIDEFRAME, 6, RGB(0, 0, 0));

	HPEN hOldPen = SelectObject(hDC, hPen);

	// draw the rectangle
	Rectangle (hDC, 0, 0, m_size.x, m_size.y);

	// restore the pen
	hPen = SelectObject(hDC, hOldPen);

	// free the pen
	DeleteObject(hPen);

	// restore the old brush
	hBrush = SelectObject(hDC, hOldBrush);

	// free the brush
	DeleteObject(hBrush);
}

//**********************************************************************
//
// CSimpSvrObj::GetMetaFilePict
//
// Purpose:
//
//      Returns a handle to a metafile representation of the object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      Handle to the metafile.
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      GlobalAlloc                     Windows API
//      GlobalLock                      Windows API
//      SetWindowOrg                    Windows API
//      SetWindowExt                    Windows API
//      CreateMetaFile                  Windows API
//      CloseMetaFile                   Windows API
//      GlobalUnlock                    Windows API
//      XformWidthInPixelsToHimetric    OLE2UI
//      XformHeightInPixelsToHimetric   OLE2UI
//      CSimpSvrObj::Draw               OBJ.CPP
//
// Comments:
//
//
//********************************************************************

HANDLE CSimpSvrObj::GetMetaFilePict()
{
	HANDLE hMFP;
	METAFILEPICT FAR * lpMFP;
	POINT pt;

	TestDebugOut("In CSimpSvrObj::GetMetaFilePict\r\n");

	// allocate the memory for the METAFILEPICT structure
	hMFP = GlobalAlloc (GMEM_SHARE | GHND, sizeof (METAFILEPICT) );
	lpMFP = (METAFILEPICT FAR*) GlobalLock(hMFP);

	// get the size of the object in HIMETRIC
	pt.x = XformWidthInPixelsToHimetric(NULL, m_size.x);
	pt.y = XformHeightInPixelsToHimetric(NULL, m_size.y);

	// fill out the METAFILEPICT structure
	lpMFP->mm = MM_ANISOTROPIC;
	lpMFP->xExt = pt.x;
	lpMFP->yExt = pt.y;

	// Create the metafile
	HDC hDC = CreateMetaFile(NULL);

	SetWindowOrg (hDC, 0, 0);
	SetWindowExt (hDC, m_size.x,
					   m_size.y);

	Draw(hDC);

	lpMFP->hMF = CloseMetaFile(hDC);

	// unlock the metafilepict
	GlobalUnlock(hMFP);

	return hMFP;
}


//**********************************************************************
//
// CSimpSvrObj::SaveToStorage
//
// Purpose:
//
//      Saves the object to the passed storage
//
// Parameters:
//
//      LPSTORAGE lpStg - Storage in which to save the object
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::CreateStream      OLE
//      IStream::Write              OLE
//      IStream::Release            OLE
//
// Comments:
//
//      A real app will want to do better error checking / returning
//
//********************************************************************

void CSimpSvrObj::SaveToStorage (LPSTORAGE lpStg, BOOL fSameAsLoad)
{
	TestDebugOut("In CSimpSvrObj::SaveToStorage\r\n");

	LPSTREAM lpTempColor, lpTempSize;

	if (!fSameAsLoad)
		m_PersistStorage.CreateStreams( lpStg, &lpTempColor, &lpTempSize);
	else
		{
		lpTempColor = m_lpColorStm;
		lpTempColor->AddRef();
		lpTempSize = m_lpSizeStm;
		lpTempSize->AddRef();
		}

	ULARGE_INTEGER uli;

	uli.LowPart = 0;
	uli.HighPart = 0;

	lpTempColor->SetSize(uli);
	lpTempSize->SetSize(uli);

	LARGE_INTEGER li;

	li.LowPart = 0;
	li.HighPart = 0;

	lpTempColor->Seek(li, STREAM_SEEK_SET, NULL);
	lpTempSize->Seek(li, STREAM_SEEK_SET, NULL);

	// write the colors to the stream
	lpTempColor->Write(&m_red, sizeof(m_red), NULL);
	lpTempColor->Write(&m_green, sizeof(m_green), NULL);
	lpTempColor->Write(&m_blue, sizeof(m_blue), NULL);

	// write the size to the stream
	lpTempSize->Write(&m_size, sizeof(m_size), NULL);

	lpTempColor->Release();
	lpTempSize->Release();
}

//**********************************************************************
//
// CSimpSvrObj::LoadFromStorage
//
// Purpose:
//
//      Loads the object from the passed storage
//
// Parameters:
//
//      LPSTORAGE lpStg     - Storage in which to load the object from
//
// Return Value:
//
//      None.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::OpenStream        OLE
//      IStream::Read               OLE
//      IStream::Release            OLE
//
// Comments:
//
//
//********************************************************************

void CSimpSvrObj::LoadFromStorage ()
{
	TestDebugOut("In CSimpSvrObj::LoadFromStorage\r\n");

	// Read the colors
	m_lpColorStm->Read(&m_red, sizeof(m_red), NULL);
	m_lpColorStm->Read(&m_green, sizeof(m_green), NULL);
	m_lpColorStm->Read(&m_blue, sizeof(m_blue), NULL);

	// read the size
	m_lpSizeStm->Read(&m_size, sizeof(m_size), NULL);

}

//**********************************************************************
//
// CSimpSvrObj::DoInPlaceActivate
//
// Purpose:
//
//      Does the inplace activation for the object
//
// Parameters:
//
//      LONG lVerb  - Verb that caused this function to be called
//
// Return Value:
//
//      TRUE/FALSE depending on success or failure.
//
// Function Calls:
//      Function                                Location
//
//      IOleClientSite::QueryInterface          Container
//      IOleClientSite::ShowObject              Container
//      IOleInPlaceSite::CanInPlaceActivate     Container
//      IOleInPlaceSite::Release                Container
//      IOleInPlaceSite::OnInPlaceActivate      Container
//      IOleInPlaceSite::GetWindow              Container
//      IOleInPlaceSite::GetWindowContext       Container
//      IOleInPlaceSite::OnUIActivate           Container
//      IOleInPlaceSite::Release                Container
//      IOleInPlaceFrame::SetActiveObject       Container
//      IOleInPlaceUIWindow::SetActiveObject    Container
//      TestDebugOut                       Windows API
//      ShowWindow                              Windows API
//      SetParent                               Windows API
//      IntersectRect                           Windows API
//      OffsetRect                              Windows API
//      MoveWindow                              Windows API
//      CopyRect                                Windows API
//      SetFocus                                Windows API
//      SetHatchWindowSize                      OLE2UI
//      CSimpSvrObj::AssembleMenus              OBJ.CPP
//      CSimpSvrObj::AddFrameLevelUI            OBJ.CPP
//
//
// Comments:
//
//      Be sure to read TECHNOTES.WRI included with the OLE SDK
//      for details on implementing inplace activation.
//
//********************************************************************

BOOL CSimpSvrObj::DoInPlaceActivate (LONG lVerb)
{
	BOOL retval = FALSE;
	RECT posRect, clipRect;


	TestDebugOut("In CSimpSvrObj::DoInPlaceActivate\r\n");

	// if not currently in place active
	if (!m_fInPlaceActive)
		{
		// get the inplace site
		if (m_lpOleClientSite->QueryInterface(IID_IOleInPlaceSite,
											  (LPVOID FAR *)&m_lpIPSite) != NOERROR)
			goto error;


		// if the inplace site could not be obtained, or refuses to inplace
		// activate then goto error.
		if (m_lpIPSite == NULL || m_lpIPSite->CanInPlaceActivate() != NOERROR)
			{
			if (m_lpIPSite)
				m_lpIPSite->Release();
			m_lpIPSite = NULL;
			goto error;
			}

		// tell the site that we are activating.
		m_lpIPSite->OnInPlaceActivate();
		m_fInPlaceActive = TRUE;
		}

	// if not currently inplace visibl
	if (!m_fInPlaceVisible)
		{
		m_fInPlaceVisible = TRUE;

		// get the window handle of the site
		m_lpIPSite->GetWindow(&m_hWndParent);

		// get window context from the container
		m_lpIPSite->GetWindowContext ( &m_lpFrame,
									 &m_lpCntrDoc,
									 &posRect,
									 &clipRect,
									 &m_FrameInfo);

		// show the hatch window
		m_lpDoc->ShowHatchWnd();

		// Set the parenting
		SetParent (m_lpDoc->GethHatchWnd(), m_hWndParent);
		SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethHatchWnd());

		// tell the client site to show the object
		m_lpOleClientSite->ShowObject();

		RECT resRect;

		// figure out the "real" size of the object
		IntersectRect(&resRect, &posRect, &clipRect);
		CopyRect(&m_posRect, &posRect);

		POINT pt;

		// adjust our hatch window size
		SetHatchWindowSize ( m_lpDoc->GethHatchWnd(),
							 &resRect,
							 &posRect,
							 &pt);

		// calculate the actual object rect inside the hatchwnd.
		OffsetRect (&resRect, pt.x, pt.y);

		// move the object window
		MoveWindow(m_lpDoc->GethDocWnd(),
				   resRect.left,
				   resRect.top,
				   resRect.right - resRect.left,
				   resRect.bottom - resRect.top,
				   FALSE);

		// create the combined window
		AssembleMenus();
		}

	// if not UIActive
	if (!m_fUIActive)
		{
		m_fUIActive = TRUE;

		// tell the inplace site that we are activating
		m_lpIPSite->OnUIActivate();

		// set the focus to our object window
		SetFocus(m_lpDoc->GethDocWnd());

		// set the active object on the frame
		m_lpFrame->SetActiveObject(&m_OleInPlaceActiveObject, "Simple OLE 2.0 Server");

		// set the active object on the Doc, if available.
		if (m_lpCntrDoc)
			m_lpCntrDoc->SetActiveObject(&m_OleInPlaceActiveObject, "Simple OLE 2.0 Server");

		// add the frame level UI.
		AddFrameLevelUI();
		}

	retval = TRUE;
error:
	return retval;
}

//**********************************************************************
//
// CSimpSvrObj::AssembleMenus
//
// Purpose:
//
//      Creates the combined menus used during inplace activation.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      CreateMenu                      Windows API
//      IOleInPlaceFrame::InsertMenus   Container
//      InsertMenu                      Windows API
//      DestroyMenu                     Windows API
//      OleCreateMenuDescriptor         OLE API
//
// Comments:
//
//
//********************************************************************

void CSimpSvrObj::AssembleMenus()
{
	TestDebugOut("In CSimpSvrObj::AssembleMenus\r\n");
	OLEMENUGROUPWIDTHS menugroupwidths;

	m_hmenuShared = NULL;

	//  Create the menu resource
	m_hmenuShared = CreateMenu();

	// have the contaner insert its menus
	if (m_lpFrame->InsertMenus (m_hmenuShared, &menugroupwidths) == NOERROR)
		{
		int nFirstGroup = (int) menugroupwidths.width[0];

		// insert the server menus
		InsertMenu( m_hmenuShared, nFirstGroup, MF_BYPOSITION | MF_POPUP, m_lpDoc->GetApp()->GetColorMenu(), "&Color");
		menugroupwidths.width[1] = 1;
		menugroupwidths.width[3] = 0;
		menugroupwidths.width[5] = 0;
		}
	else
		{
		// Destroy the menu resource
		DestroyMenu(m_hmenuShared);
		m_hmenuShared = NULL;
		}

	// tell OLE to create the menu descriptor
	m_hOleMenu = OleCreateMenuDescriptor(m_hmenuShared, &menugroupwidths);
}

//**********************************************************************
//
// CSimpSvrObj::AddFrameLevelUI
//
// Purpose:
//
//      Adds the Frame level user interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut                   Windows API
//      IOleInPlaceFrame::SetMenu           Container
//      IOleInPlaceFrame::SetBorderSpace    Container
//      IOleInPlaceUIWindow::SetBorderSpace Container
//      CSimpSvrDoc::GethDocWnd             DOC.H
//
// Comments:
//
//
//********************************************************************

void CSimpSvrObj::AddFrameLevelUI()
{
	TestDebugOut("In CSimpSvrObj::AddFrameLevelUI\r\n");

	// add the combined menu
	m_lpFrame->SetMenu(m_hmenuShared, m_hOleMenu, m_lpDoc->GethDocWnd());

	// do hatched border
	SetParent (m_lpDoc->GethHatchWnd(), m_hWndParent);
	SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethHatchWnd());

	// set the border space.  Normally we would negotiate for toolbar
	// space at this point.  Since this server doesn't have a toolbar,
	// this isn't needed...
	if (m_lpFrame)
		m_lpFrame->SetBorderSpace(NULL);

	if (m_lpCntrDoc)
		m_lpCntrDoc->SetBorderSpace(NULL);
}

//**********************************************************************
//
// CSimpSvrObj::DoInPlaceHide
//
// Purpose:
//
//      Hides the object while inplace actvie
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      SetParent                       Windows API
//      CSimpSvrDoc::GethDocWnd         DOC.H
//      CSimpSvrDoc::GethAppWnd         DOC.H
//      CSimpSvrDoc::GethHatchWnd       DOC.H
//      CSimpSvrObj::DisassembleMenus   OBJ.CPP
//      IOleInPlaceFrame::Release       Container
//      IOleInPlaceUIWindow::Release    Container
//
//
// Comments:
//
//      Be sure to read TECHNOTES.WRI included with the OLE SDK
//      for details on implementing inplace activation.
//
//********************************************************************

void CSimpSvrObj::DoInPlaceHide()
{
	TestDebugOut("In CSimpSvrObj::DoInPlaceHide\r\n");

	// if we aren't inplace visible, then this routine is a NOP,
	if (!m_fInPlaceVisible)
		return;

	m_fInPlaceVisible = FALSE;

	// change the parenting
	SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethAppWnd());
	SetParent (m_lpDoc->GethHatchWnd(),m_lpDoc->GethDocWnd());

	// rip down the combined menus
	DisassembleMenus();

	// release the inplace frame
	m_lpFrame->Release();

	m_lpFrame = NULL;  // only holding one ref. to frame.

	// release the UIWindow if it is there.
	if (m_lpCntrDoc)
		m_lpCntrDoc->Release();

	m_lpCntrDoc = NULL;

}

//**********************************************************************
//
// CSimpSvrObj::DisassembleMenus
//
// Purpose:
//
//      Disassembles the combined menus used in inplace activation
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut               Windows API
//      OleDestroyMenuDescriptor        OLE API
//      RemoveMenu                      Windows API
//      IOleInPlaceFrame::RemoveMenus   Container
//      DestroyMenu                     Windows API
//
// Comments:
//
//      Be sure to read TECHNOTES.WRI included with the OLE SDK
//      for details on implementing inplace activation.
//
//********************************************************************

void CSimpSvrObj::DisassembleMenus()
{
	// destroy the menu descriptor
	OleDestroyMenuDescriptor(m_hOleMenu);

	if (m_hmenuShared)
		{
		// remove the menus that we added
		RemoveMenu( m_hmenuShared, 1, MF_BYPOSITION);

		// have the container remove its menus
		m_lpFrame->RemoveMenus(m_hmenuShared);

		// Destroy the menu resource
		DestroyMenu(m_hmenuShared);

		m_hmenuShared = NULL;
		}
}

//**********************************************************************
//
// CSimpSvrObj::SendOnDataChange
//
// Purpose:
//
//      Uses the data advise holder to send a data change, then updates
//      the ROT to note the time of change.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      IDataAdviseHolder::SendOnDataChange     OLE API
//      GetRunningObjectTable                   OLE API
//      CoFileTimeNow                           OLE API
//      IRunningObjectTable::NoteChangeTime     OLE API
//
// Comments:
//
//
//********************************************************************

void CSimpSvrObj::SendOnDataChange()
{
	if (m_lpDataAdviseHolder)
		m_lpDataAdviseHolder->SendOnDataChange( (LPDATAOBJECT)&m_DataObject, 0, 0);

	LPRUNNINGOBJECTTABLE lpRot;

	GetRunningObjectTable(0, &lpRot);

	if ( lpRot && m_dwRegister)
		{
		FILETIME ft;
		CoFileTimeNow(&ft);

		lpRot->NoteChangeTime(m_dwRegister, &ft);
		lpRot->Release();
		}
}

//**********************************************************************
//
// CSimpSvrObj::DeactivateUI
//
// Purpose:
//
//      Breaks down the inplace ui
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      SetParent                               Windows API
//      IOleInPlaceUIWindow::SetActiveObject    Container
//      IOleInPlaceFrame::SetActiveObject       Container
//      IOleInPlaceSite::UIDeactivate           Container
//
// Comments:
//
//
//********************************************************************

void CSimpSvrObj::DeactivateUI()
{
	// if not UI active, or no pointer to IOleInPlaceFrame, then
	// return NOERROR
	if (!(m_fUIActive || m_lpFrame))
		return;
	else
		{
		m_fUIActive = FALSE;

		// remove hatching
		SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethAppWnd());
		SetParent (m_lpDoc->GethHatchWnd(),m_lpDoc->GethDocWnd());

		// if in an MDI container, call SetActiveObject on the DOC.
		if (m_lpCntrDoc)
			m_lpCntrDoc->SetActiveObject(NULL, NULL);

		m_lpFrame->SetActiveObject(NULL, NULL);

		// tell the container that our UI is going away.
		if (m_lpIPSite)
			m_lpIPSite->OnUIDeactivate(FALSE);
		}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\utests16\simpsvr\simpsvr.cpp ===
//**********************************************************************
// File name: simpsvr.cpp
//
//      Main source file for the simple OLE 2.0 server
//
// Functions:
//
//      WinMain         - Program entry point
//      MainWndProc     - Processes messages for the frame window
//      About           - Processes messages for the about dialog
//      DocWndProc      - Processes messages for the doc window
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "app.h"
#include "doc.h"
#include "icf.h"

// This line is needed for the debug utilities in OLE2UI
extern "C" {
	OLEDBGDATA_MAIN("SIMPSVR")
}

CSimpSvrApp FAR * lpCSimpSvrApp;
CClassFactory FAR * lpClassFactory;
BOOL fBeVerbose = FALSE;
extern "C"
void TestDebugOut(LPSTR psz)
{
    if (fBeVerbose)
    {
	OutputDebugString(psz);
    }
}

//**********************************************************************
//
// WinMain
//
// Purpose:
//
//      Program entry point
//
// Parameters:
//
//      HANDLE hInstance        - Instance handle for this instance
//
//      HANDLE hPrevInstance    - Instance handle for the last instance
//
//      LPSTR lpCmdLine         - Pointer to the command line
//
//      int nCmdShow            - Window State
//
// Return Value:
//
//      msg.wParam
//
// Function Calls:
//      Function                        Location
//
//      CSimpSvrApp::CSimpSvrApp          APP.CPP
//      CSimpSvrApp::fInitApplication    APP.CPP
//      CSimpSvrApp::fInitInstance       APP.CPP
//      CSimpSvrApp::HandleAccelerators  APP.CPP
//      CSimpSvrApp::~CSimpSvrApp         APP.CPP
//      OleUIInitialize                 OLE2UI
//      OleUIUninitialize               OLE2UI
//      GetMessage                      Windows API
//      TranslateMessage                Windows API
//      DispatchMessage                 Windows API
//
// Comments:
//
//********************************************************************

int PASCAL WinMain(HANDLE hInstance,HANDLE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)

{
	MSG msg;
	fBeVerbose = GetProfileInt("OLEUTEST","BeVerbose",0);

	if(fBeVerbose == 0)
	{
	    fBeVerbose = GetProfileInt("OLEUTEST","spsvr16",0);
	}

	// recommended size for OLE apps
	SetMessageQueue(96);

	lpCSimpSvrApp = new CSimpSvrApp;

	lpCSimpSvrApp->AddRef();      // need the app ref. count at 1 to hold the
								  // app alive.

	lpCSimpSvrApp->ParseCmdLine(lpCmdLine);

	// app initialization
	if (!hPrevInstance)
		if (!lpCSimpSvrApp->fInitApplication(hInstance))
			return (FALSE);

	// instance initialization
	if (!lpCSimpSvrApp->fInitInstance(hInstance, nCmdShow, lpClassFactory))
		return (FALSE);

	/* Initialization required for OLE 2 UI library.  This call is
	**    needed ONLY if we are using the static link version of the UI
	**    library. If we are using the DLL version, we should NOT call
	**    this function in our application.
	*/
	if (!OleUIInitialize(hInstance, hPrevInstance))
		{
		OleDbgOut("Could not initialize OLEUI library\n");
		return FALSE;
		}

	// message loop
	while (GetMessage(&msg, NULL, NULL, NULL))
		{
		if (lpCSimpSvrApp->IsInPlaceActive())

			// Only key messages need to be sent to OleTranslateAccelerator.  Any other message
			// would result in an extra FAR call to occur for that message processing...

			if ( (msg.message >= WM_KEYFIRST) && (msg.message <= WM_KEYLAST) )

				// OleTranslateAccelerator MUST be called, even though this application does
				// not have an accelerator table.  This has to be done in order for the
				// mneumonics for the top level menu items to work properly.

				if ( OleTranslateAccelerator ( lpCSimpSvrApp->GetDoc()->GetObj()->GetInPlaceFrame(),
											   lpCSimpSvrApp->GetDoc()->GetObj()->GetFrameInfo(),
											   &msg) == NOERROR)
					continue;

		TranslateMessage(&msg);    /* Translates virtual key codes           */
		DispatchMessage(&msg);     /* Dispatches message to window           */
		}

	// De-initialization for UI libraries.  Just like OleUIInitialize, this
	// funciton is needed ONLY if we are using the static link version of the
	// OLE UI library.
	OleUIUninitialize();

	return (msg.wParam);           /* Returns the value from PostQuitMessage */
}


//**********************************************************************
//
// MainWndProc
//
// Purpose:
//
//      Processes messages for the frame window
//
// Parameters:
//
//      HWND hWnd       - Window handle for frame window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//      long
//
// Function Calls:
//      Function                        Location
//
//      CSimpSvrApp::lCommandHandler     APP.CPP
//      CSimpSvrApp::DestroyDocs         APP.CPP
//      CSimpSvrApp::lCreateDoc          APP.CPP
//      CSimpSvrApp::lSizeHandler        APP.CPP
//      CGameDoc::lAddVerbs           DOC.CPP
//      PostQuitMessage                 Windows API
//      DefWindowProc                   Windows API
//
// Comments:
//
//********************************************************************

long FAR PASCAL _export MainWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)

{

	switch (message)
		{
		case WM_CLOSE:
			TestDebugOut("*** In WM_CLOSE *** \r\n");

			// if there is still a document
			if (lpCSimpSvrApp->GetDoc())

				// if there is still an object within a document
				if (lpCSimpSvrApp->GetDoc()->GetObj())   // this case occurs if there is still
														 // an outstanding Ref count on the object
														 // when the app is trying to go away.
														 // typically this case will occur in
														 // the "open" editing mode.
					//  Close the document
					lpCSimpSvrApp->GetDoc()->Close();

			// hide the app window
			lpCSimpSvrApp->HideAppWnd();

			// if we were started by ole, unregister the class factory, otherwise
			// remove the ref count on our dummy OLE object
			if (lpCSimpSvrApp->IsStartedByOle())
				CoRevokeClassObject(lpCSimpSvrApp->GetRegisterClass());
			else
				lpCSimpSvrApp->GetOleObject()->Release();

			lpCSimpSvrApp->Release();  // This should close the app.

			break;

		case WM_COMMAND:           // message: command from application menu
			return lpCSimpSvrApp->lCommandHandler(hWnd, message, wParam, lParam);
			break;

		case WM_CREATE:
			return lpCSimpSvrApp->lCreateDoc(hWnd, message, wParam, lParam);
			break;

		case WM_DESTROY:                  // message: window being destroyed
			PostQuitMessage(0);
			break;

		case WM_SIZE:
			return lpCSimpSvrApp->lSizeHandler(hWnd, message, wParam, lParam);

		default:                          // Passes it on if unproccessed
			return (DefWindowProc(hWnd, message, wParam, lParam));
		}
		return (NULL);
}


//**********************************************************************
//
// About
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for dialog box
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//      EndDialog                   Windows API
//
// Comments:
//
//********************************************************************

BOOL FAR PASCAL _export About(HWND hDlg,unsigned message,WORD wParam,LONG lParam)

{
	switch (message) {
	case WM_INITDIALOG:                /* message: initialize dialog box */
		return (TRUE);

	case WM_COMMAND:                      /* message: received a command */
		if (wParam == IDOK                /* "OK" box selected?          */
		|| wParam == IDCANCEL) {      /* System menu close command? */
		EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
		return (TRUE);
		}
		break;
	}
	return (FALSE);                           /* Didn't process a message    */
}

//**********************************************************************
//
// DocWndProc
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for doc window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
// Function Calls:
//      Function                            Location
//
//      CSimpSvrApp::PaintApp                APP.CPP
//      BeginPaint                          Windows API
//      EndPaint                            Windows API
//      DefWindowProc                       Windows API
//      IOleObject::QueryInterface          Object
//      IOleInPlaceObject::UIDeactivate     Object
//      IOleObject::DoVerb                  Object
//      IOleInPlaceObject::Release          Object
//
// Comments:
//
//********************************************************************

long FAR PASCAL _export DocWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	HDC hDC;
	PAINTSTRUCT ps;

	switch (message) {
		case WM_COMMAND:           // message: command from application menu
			return lpCSimpSvrApp->lCommandHandler(hWnd, message, wParam, lParam);
			break;

		case WM_PAINT:
			hDC = BeginPaint(hWnd, &ps);

			// tell the app class to paint itself
			if (lpCSimpSvrApp)
				lpCSimpSvrApp->PaintApp (hDC);

			EndPaint(hWnd, &ps);
			break;

		case WM_MENUSELECT:
			lpCSimpSvrApp->SetStatusText();
			break;

	default:                          /* Passes it on if unproccessed    */
		return (DefWindowProc(hWnd, message, wParam, lParam));
	}
	return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\uthread\bt\makefile.inc ===
obj\i386\olebt.def: olebt.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\uthread\at\oleat.cpp ===
//+-------------------------------------------------------------------
//
//  File:       oleat.cpp
//
//  Contents:   Unique parts of apt model DLL server
//
//  Classes:
//
//  Functions:
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#undef _UNICODE
#undef UNICODE
#include    <windows.h>
#include    <ole2.h>
#include    <comclass.h>
#include    <uthread.h>

CLSID clsidServer;

void InitDll(void)
{
    clsidServer = clsidAptThreadedDll;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\uthread\at\makefile.inc ===
obj\i386\oleat.def: oleat.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\uthread\uthread.h ===
//+-------------------------------------------------------------------
//
//  File:       uthread.h
//
//  Contents:   Common constants for thread unit test
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#ifndef _UTHREAD_H_
#define _UTHREAD_H_
#undef UNICODE
#undef _UNICODE

extern const CLSID clsidSingleThreadedDll;
extern const char *pszSingleThreadedDll;

extern const CLSID clsidAptThreadedDll;
extern const char *pszAptThreadedDll;

extern const CLSID clsidBothThreadedDll;
extern const char *pszBothThreadedDll;

#endif // _UTHREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\uthread\bt\olebt.cpp ===
//+-------------------------------------------------------------------
//
//  File:       olebt.cpp
//
//  Contents:   Test DLL class code that be used multithreaded.
//
//  Classes:
//
//  Functions:
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#undef _UNICODE
#undef UNICODE
#include    <windows.h>
#include    <ole2.h>
#include    <uthread.h>


// Global count of
ULONG g_UseCount = 0;

void PrintDebugMsg(char *pszMsg, DWORD dwData)
{
    char wszBuf[256];
    wsprintf(wszBuf, "olebt.dll: %s %d\n", pszMsg, dwData);
    OutputDebugString(wszBuf);
}



//+-------------------------------------------------------------------
//
//  Class:    CBasicBndCF
//
//  Synopsis: Class Factory for CBasicBnd
//
//  Methods:  IUnknown      - QueryInterface, AddRef, Release
//            IClassFactory - CreateInstance
//
//  History:  03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
class FAR CBasicBndCF: public IClassFactory
{
public:

                        // Constructor/Destructor
                        CBasicBndCF(void);
                        ~CBasicBndCF();

                        // IUnknown
    STDMETHODIMP        QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


                        // IClassFactory
    STDMETHODIMP        CreateInstance(
                            IUnknown FAR* pUnkOuter,
	                    REFIID iidInterface,
			    void FAR* FAR* ppv);

    STDMETHODIMP        LockServer(BOOL fLock);

private:

    ULONG		_cRefs;

    IUnknown *          _punkFm;
};



//+-------------------------------------------------------------------
//
//  Class:    CBasicBnd
//
//  Synopsis: Test class CBasicBnd
//
//  Methods:
//
//  History:  03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
class FAR CBasicBnd: public IPersist
{
public:
                        // Constructor/Destructor
                        CBasicBnd(void);
                        ~CBasicBnd();

                        // IUnknown
    STDMETHODIMP        QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

                        // IPersist - only thing we implement because it
                        // gives us a nice way to figure who we are talking to.
    STDMETHODIMP        GetClassID(LPCLSID lpClassID);

private:

    ULONG               _cRefs;

    IUnknown *          _punkFm;
};


extern "C" BOOL WINAPI DllMain(
    HANDLE,
    DWORD,
    LPVOID)
{
    return TRUE;
}


//+-------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Called by client (from within BindToObject et al)
//              interface requested  should be IUnknown or IClassFactory -
//              Creates ClassFactory object and returns pointer to it
//
//  Arguments:  REFCLSID clsid    - class id
//              REFIID iid        - interface id
//              void FAR* FAR* ppv- pointer to class factory interface
//
//  Returns:    TRUE
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (!IsEqualGUID(iid, IID_IUnknown)
        && !IsEqualGUID(iid, IID_IClassFactory)
        && !IsEqualGUID(iid, IID_IMarshal))
    {
	return E_NOINTERFACE;
    }

    if (IsEqualGUID(clsid, clsidBothThreadedDll))
    {
	IUnknown *punk = new CBasicBndCF();

        HRESULT hr = punk->QueryInterface(iid, ppv);

        punk->Release();

	return hr;
    }

    return E_FAIL;
}


STDAPI DllCanUnloadNow(void)
{
    return (g_UseCount == 0)
	? S_OK
	: S_FALSE;
}




//+-------------------------------------------------------------------
//
//  Member:     CBasicBndCF::CBasicBndCF()
//
//  Synopsis:   The constructor for CBAsicBnd.
//
//  Arguments:  None
//
//  History:    21-Nov-92  Ricksa  Created
//
//--------------------------------------------------------------------
CBasicBndCF::CBasicBndCF(void)
    : _cRefs(1), _punkFm(NULL)
{
    PrintDebugMsg("Creating Class Factory", (DWORD) this);
    g_UseCount++;
}



//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndCF()
//
//  Synopsis:   The destructor for CBasicCF.
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
CBasicBndCF::~CBasicBndCF()
{
    PrintDebugMsg("Deleting Class Factory", (DWORD) this);
    g_UseCount--;

    if (_punkFm != NULL)
    {
        _punkFm->Release();
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBndCF::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (IsEqualGUID(iid, IID_IUnknown) || IsEqualGUID(iid, IID_IClassFactory))
    {
        *ppv = this;
	AddRef();
        hr = S_OK;
    }
    else if (IsEqualGUID(iid, IID_IMarshal))
    {
        if (NULL == _punkFm)
        {
            hr = CoCreateFreeThreadedMarshaler(this, &_punkFm);
        }

        if (_punkFm != NULL)
        {
            return _punkFm->QueryInterface(iid, ppv);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::AddRef
//
//  Synopsis:   Increment reference count
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBasicBndCF::AddRef(void)
{
    return ++_cRefs;
}

//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::Release
//
//  Synopsis:   Decrement reference count
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBasicBndCF::Release(void)
{
    ULONG cRefs = --_cRefs;

    if (cRefs == 0)
    {
	delete this;
    }

    return cRefs;
}



//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the
//              actual class object
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBndCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    HRESULT hresult = S_OK;

    if (pUnkOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    CBasicBnd *pbb = new FAR CBasicBnd();

    if (pbb == NULL)
    {
	return E_OUTOFMEMORY;
    }

    hresult = pbb->QueryInterface(iidInterface, ppv);

    pbb->Release();

    return hresult;
}

//+-------------------------------------------------------------------
//
//  Method:	CBasicBndCF::LockServer
//
//  Synopsis:   Inc/Dec stay alive count
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBndCF::LockServer(BOOL fLock)
{
    if (fLock)
    {
        g_UseCount++;
    }
    else
    {
        g_UseCount--;
    }

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::CBasicBnd()
//
//  Synopsis:   The constructor for CBAsicBnd. I
//
//  Arguments:  None
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------

CBasicBnd::CBasicBnd(void)
    : _cRefs(1), _punkFm(NULL)
{
    PrintDebugMsg("Creating App Object", (DWORD) this);
    g_UseCount++;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndObj()
//
//  Synopsis:   The destructor for CBAsicBnd.
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------

CBasicBnd::~CBasicBnd(void)
{
    PrintDebugMsg("Deleting App Object", (DWORD) this);
    g_UseCount--;
    return;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::QueryInterface
//
//  Returns:	S_OK
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::QueryInterface(REFIID iid, void **ppv)
{
    if (IsEqualGUID(iid, IID_IUnknown) || IsEqualGUID(iid, IID_IPersist))
    {
        *ppv = this;
	AddRef();
        return S_OK;
    }
    else if (IsEqualGUID(iid, IID_IMarshal))
    {
        HRESULT hr;

        if (NULL == _punkFm)
        {
            hr = CoCreateFreeThreadedMarshaler(this, &_punkFm);
        }

        if (_punkFm != NULL)
        {
            hr = _punkFm->QueryInterface(iid, ppv);
        }

        return hr;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::AddRef
//
//  Synopsis:   Standard stuff
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBasicBnd::AddRef(void)
{
    return _cRefs++;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Release
//
//  Synopsis:   Standard stuff
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBasicBnd::Release(void)
{
    ULONG cRefs;

    if ((cRefs = --_cRefs) == 0)
    {
        delete this;
    }

    return cRefs;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::GetClassID
//
//  Synopsis:   Return the class id
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::GetClassID(LPCLSID classid)
{
    *classid = clsidBothThreadedDll;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\uthread\common\sources.inc ===
SYNCHRONIZE_BLOCK=1
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\uthread\st\olest.cpp ===
//+-------------------------------------------------------------------
//
//  File:       olest.cpp
//
//  Contents:   Unique parts of apt model DLL server
//
//  Classes:
//
//  Functions:
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#undef _UNICODE
#undef UNICODE
#include    <windows.h>
#include    <ole2.h>
#include    <comclass.h>
#include    <uthread.h>

CLSID clsidServer;

void InitDll(void)
{
    clsidServer = clsidSingleThreadedDll;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\uthread\common\classdef.cpp ===
//+-------------------------------------------------------------------
//
//  File:       classdef.cpp
//
//  Contents:   Common constants for thread unit test
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#undef _UNICODE
#undef UNICODE
#include <windows.h>
#include <uthread.h>

const CLSID clsidSingleThreadedDll =
    {0xe22e88c0, 0xf72a, 0x11cd, {0xa1,0xaa,0x00,0x00,0x69,0x01,0x29,0x3f}};
const char *pszSingleThreadedDll = "olest.dll";

const CLSID clsidAptThreadedDll =
    {0xe82c0ae0, 0xf72a, 0x11cd, {0xa1,0xaa,0x00,0x00,0x69,0x01,0x29,0x3f}};
const char *pszAptThreadedDll = "oleat.dll";

const CLSID clsidBothThreadedDll =
    {0xe97d4300, 0xf72a, 0x11cd, {0xa1,0xaa,0x00,0x00,0x69,0x01,0x29,0x3f}};
const char *pszBothThreadedDll = "olebt.dll";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\uthread\st\makefile.inc ===
obj\i386\olest.def: olest.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\catsrvut.c ===
#include "compch.h"
#pragma hdrstop

#include <windows.h>

STDAPI
CGMIsAdministrator(
    OUT BOOL *pfIsAdministrator
    )
{
    if (pfIsAdministrator)
        *pfIsAdministrator = FALSE;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

STDAPI SysprepComplus2()
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(catsrvut)
{
    DLPENTRY(CGMIsAdministrator)
    DLPENTRY(SysprepComplus2)
};

DEFINE_PROCNAME_MAP(catsrvut)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\catsrv.c ===
#include "compch.h"
#pragma hdrstop

#include <comsvcs.h>

HRESULT
GetCatalogCRMClerk(
    OUT ICrmLogControl **ppClerk
    )
{
    if (ppClerk)
        *ppClerk = NULL;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(catsrv)
{
    DLPENTRY(GetCatalogCRMClerk)
};

DEFINE_PROCNAME_MAP(catsrv)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\uthread\common\comclass.cpp ===
//+-------------------------------------------------------------------
//
//  File:       comclass.cpp
//
//  Contents:   Test DLL class code that can be used for both apt
//              model and single threaded application
//
//  Classes:
//
//  Functions:
//
//  History:    03-Nov-94   Ricksa
//
//--------------------------------------------------------------------
#undef _UNICODE
#undef UNICODE
#include    <windows.h>
#include    <ole2.h>
#include    <comclass.h>


// Global count of
ULONG g_UseCount = 0;




//+-------------------------------------------------------------------
//
//  Class:    CBasicBndCF
//
//  Synopsis: Class Factory for CBasicBnd
//
//  Methods:  IUnknown      - QueryInterface, AddRef, Release
//            IClassFactory - CreateInstance
//
//  History:  03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
class FAR CBasicBndCF: public IClassFactory
{
public:

                        // Constructor/Destructor
                        CBasicBndCF(REFCLSID rclsid);
                        ~CBasicBndCF();

                        // IUnknown
    STDMETHODIMP        QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


                        // IClassFactory
    STDMETHODIMP        CreateInstance(
                            IUnknown FAR* pUnkOuter,
	                    REFIID iidInterface,
			    void FAR* FAR* ppv);

    STDMETHODIMP        LockServer(BOOL fLock);

private:

    ULONG		_cRefs;

    REFCLSID            _rclsid;

    DWORD               _dwThreadId;
};



//+-------------------------------------------------------------------
//
//  Class:    CBasicBnd
//
//  Synopsis: Test class CBasicBnd
//
//  Methods:
//
//  History:  03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
class FAR CBasicBnd: public IPersist
{
public:
                        // Constructor/Destructor
                        CBasicBnd(REFCLSID rclsd, DWORD dwThreadId);
                        ~CBasicBnd();

                        // IUnknown
    STDMETHODIMP        QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

                        // IPersist - only thing we implement because it
                        // gives us a nice way to figure who we are talking to.
    STDMETHODIMP        GetClassID(LPCLSID lpClassID);

private:

    ULONG               _cRefs;

    REFCLSID            _rclsid;

    DWORD               _dwThreadId;
};


extern "C" BOOL WINAPI DllMain(
    HANDLE,
    DWORD,
    LPVOID)
{
    static BOOL fFirst = TRUE;

    if (fFirst)
    {
        InitDll();
        fFirst = FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Called by client (from within BindToObject et al)
//              interface requested  should be IUnknown or IClassFactory -
//              Creates ClassFactory object and returns pointer to it
//
//  Arguments:  REFCLSID clsid    - class id
//              REFIID iid        - interface id
//              void FAR* FAR* ppv- pointer to class factory interface
//
//  Returns:    TRUE
//
//  History:    03-Nov-94  Ricksa  Created
//
//--------------------------------------------------------------------
STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    if (!IsEqualGUID(iid, IID_IUnknown)
        && !IsEqualGUID(iid, IID_IClassFactory))
    {
	return E_NOINTERFACE;
    }

    if (IsEqualGUID(clsid, clsidServer))
    {
	*ppv = new CBasicBndCF(clsidServer);

	return (*ppv != NULL) ? S_OK : E_OUTOFMEMORY;
    }

    return E_FAIL;
}


STDAPI DllCanUnloadNow(void)
{
    return (g_UseCount == 0)
	? S_OK
	: S_FALSE;
}




//+-------------------------------------------------------------------
//
//  Member:     CBasicBndCF::CBasicBndCF()
//
//  Synopsis:   The constructor for CBAsicBnd.
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
CBasicBndCF::CBasicBndCF(REFCLSID rclsid)
    : _cRefs(1), _rclsid(rclsid), _dwThreadId(GetCurrentThreadId())
{
    g_UseCount++;
}



//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndCF()
//
//  Synopsis:   The destructor for CBasicCF.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
CBasicBndCF::~CBasicBndCF()
{
    g_UseCount--;
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBndCF::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (IsEqualGUID(iid, IID_IUnknown) || IsEqualGUID(iid, IID_IClassFactory))
    {
        *ppv = this;
	AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CBasicBndCF::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CBasicBndCF::Release(void)
{
    ULONG cRefs = --_cRefs;

    if (cRefs == 0)
    {
	delete this;
    }

    return cRefs;
}



//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the
//              actual class object
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBndCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    if (GetCurrentThreadId() != _dwThreadId)
    {
        return E_UNEXPECTED;
    }

    HRESULT hresult = S_OK;

    if (pUnkOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    CBasicBnd *pbb = new FAR CBasicBnd(_rclsid, _dwThreadId);

    if (pbb == NULL)
    {
	return E_OUTOFMEMORY;
    }

    hresult = pbb->QueryInterface(iidInterface, ppv);

    pbb->Release();

    return hresult;
}

//+-------------------------------------------------------------------
//
//  Method:	CBasicBndCF::LockServer
//
//  Synopsis:	Who knows what this is for?
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBndCF::LockServer(BOOL fLock)
{
    if (GetCurrentThreadId() != _dwThreadId)
    {
        return E_UNEXPECTED;
    }

    if (fLock)
    {
        g_UseCount++;
    }
    else
    {
        g_UseCount--;
    }

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::CBasicBnd()
//
//  Synopsis:   The constructor for CBAsicBnd. I
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBnd::CBasicBnd(REFCLSID rclsid, DWORD dwThreadId)
    : _cRefs(1), _rclsid(rclsid), _dwThreadId(dwThreadId)
{
    g_UseCount++;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndObj()
//
//  Synopsis:   The destructor for CBAsicBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBnd::~CBasicBnd()
{
    g_UseCount--;
    return;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::QueryInterface
//
//  Returns:	S_OK
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::QueryInterface(REFIID iid, void **ppv)
{
    if (GetCurrentThreadId() != _dwThreadId)
    {
        return E_UNEXPECTED;
    }

    if (IsEqualGUID(iid, IID_IUnknown) || IsEqualGUID(iid, IID_IPersist))
    {
        *ppv = this;
	AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::AddRef
//
//  Synopsis:   Standard stuff
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBasicBnd::AddRef(void)
{
    return _cRefs++;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Release
//
//  Synopsis:   Standard stuff
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP_(ULONG) CBasicBnd::Release(void)
{
    ULONG cRefs;

    if ((cRefs = --_cRefs) == 0)
    {
        delete this;
    }

    return cRefs;
}


//+-------------------------------------------------------------------
//
//  Interface:  IPersist
//
//  Synopsis:   IPersist interface methods
//              Need to return a valid class id here
//
//  History:    21-Nov-92  SarahJ  Created
//

STDMETHODIMP CBasicBnd::GetClassID(LPCLSID classid)
{
    if (GetCurrentThreadId() != _dwThreadId)
    {
        return E_UNEXPECTED;
    }

    *classid = _rclsid;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\comutils\reghelp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2002.
//
//  File:       reghelp.cxx
//
//  Contents:   Registry helper functions for accessing HKCR
//
//  Classes:
//
//  Functions:
//
//  Notes:
//      The registry APIs do a surprising thing when you access
//      HKEY_CLASSES_ROOT.  They will determine which user hive to use 
//      based on whoever was impersonating when the first access was made for
//      the process, and it will use that mapping no matte who is impersonated
//      later.  As such, it is impossible to know at any point in time where you
//      will be picking up your user mapping when you access HKCR.
//      This could present security holes if a malicious user were able to force
//      their own hive to be the first one accessed.  So, for example, a 
//      malicious user could force their own InprocServer32 value to be used
//      instead of one from a different user's hive.
//
//      The APIs in this file provide a reliable means of accessing HKCR, so that
//      you always know what the mapping will be.  These functions will use
//      HKEY_USERS\SID_ProcessToken\Software\Classes instead of trying to get
//      the current user's token.  
//      
//----------------------------------------------------------------------------
#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>

#include <windows.h>
#include <reghelp.hxx>

//+-------------------------------------------------------------------
//
//  Function:  Impersonation helper functions
//
//--------------------------------------------------------------------
inline void ResumeImpersonate( HANDLE hToken )
{
    if (hToken != NULL)
    {
        BOOL fResult = SetThreadToken( NULL, hToken );
        ASSERT(fResult);
        CloseHandle( hToken );
    }
}

inline void SuspendImpersonate( HANDLE *pHandle )
{
    if(OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE,
                         TRUE, pHandle ))
	{
	
        BOOL fResult = SetThreadToken(NULL, NULL);
        ASSERT(fResult);
	}
	else
	{
        *pHandle = NULL;
	}
}

//+-------------------------------------------------------------------
//
//  Function:   OpenClassesRootKeyExW, private
//
//  Synopsis:   See the comments above.  This is the special verision of
//             RegOpenKeyExW for HKCR-based hives.
//
//--------------------------------------------------------------------
LONG WINAPI OpenClassesRootKeyExW(LPCWSTR pszSubKey,REGSAM samDesired,HKEY *phkResult)
{
	LONG lResult = ERROR_SUCCESS;
    HANDLE hImpToken = NULL;
    HANDLE hProcToken = NULL;
    HKEY hkcr = NULL;

	if(phkResult == NULL)
		return ERROR_INVALID_PARAMETER;

	*phkResult = NULL;
	
    SuspendImpersonate(&hImpToken);
    BOOL fRet = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcToken);
    if (fRet)
    {        
        lResult = RegOpenUserClassesRoot(hProcToken, 0, MAXIMUM_ALLOWED, &hkcr);
        if (lResult != ERROR_SUCCESS)
        {
            // Failed to open the user's HKCR.  We're going to use 
            // HKLM\Software\Classes.
            lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                L"Software\\Classes",
                                0,
                                MAXIMUM_ALLOWED,
                                &hkcr);
        }
        
        CloseHandle(hProcToken);
    }
    else 
    {        
        lResult = GetLastError();
    }
    
    ResumeImpersonate(hImpToken);

    if(lResult == ERROR_SUCCESS)
    {
		if( (pszSubKey != NULL) && (pszSubKey[0]) )
		{
			lResult = RegOpenKeyEx(hkcr,pszSubKey,0,samDesired,phkResult);
			RegCloseKey(hkcr);
		}
		else
		{
			*phkResult = hkcr;
		}
    }

    return lResult;
}

//+-------------------------------------------------------------------
//
//  Function:   OpenClassesRootKeyW, private
//
//  Synopsis:   See the comments above.  This is the special verision of
//             RegOpenKeyW for HKCR-based hives.
//
//--------------------------------------------------------------------
LONG WINAPI OpenClassesRootKeyW(LPCWSTR pszSubKey,HKEY *phkResult)
{
	return OpenClassesRootKeyExW(pszSubKey,MAXIMUM_ALLOWED,phkResult);
}
	
//+-------------------------------------------------------------------
//
//  Function:   QueryClassesRootValueW, private
//
//  Synopsis:   See the comments above.  This is the special verision of
//             RegQueryValue for HKCR-based hives.
//
//--------------------------------------------------------------------
LONG WINAPI QueryClassesRootValueW(LPCWSTR pszSubKey,LPWSTR pszValue,PLONG lpcbValue)
{
	HKEY hkcr = NULL;
	LONG lResult = OpenClassesRootKeyW(NULL,&hkcr);

	if(lResult == ERROR_SUCCESS)
	{
		lResult = RegQueryValueW(hkcr,pszSubKey,pszValue,lpcbValue);
		RegCloseKey(hkcr);
	}

	return lResult;
}

//+-------------------------------------------------------------------
//
//  Function:   OpenClassesRootKeyExA, private
//
//  Synopsis:   See the comments above.  This is the special verision of
//             RegOpenKeyExA for HKCR-based hives.
//
//--------------------------------------------------------------------
LONG WINAPI OpenClassesRootKeyExA(LPCSTR pszSubKey,REGSAM samDesired,HKEY *phkResult)
{
	LONG lResult = ERROR_SUCCESS;
    HANDLE hImpToken = NULL;
    HANDLE hProcToken = NULL;
    HKEY hkcr = NULL;

	if(phkResult == NULL)
		return ERROR_INVALID_PARAMETER;

	*phkResult = NULL;

    SuspendImpersonate(&hImpToken);
    BOOL fRet = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcToken);
    if (fRet)
    {        
        lResult = RegOpenUserClassesRoot(hProcToken, 0, MAXIMUM_ALLOWED, &hkcr);
        if (lResult != ERROR_SUCCESS)
        {
            // Failed to open the user's HKCR.  We're going to use 
            // HKLM\Software\Classes.
            lResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                "Software\\Classes",
                                0,
                                MAXIMUM_ALLOWED,
                                &hkcr);
        }
        
        CloseHandle(hProcToken);
    }
    else 
    {        
        lResult = GetLastError();
    }
    
    ResumeImpersonate(hImpToken);

    if(lResult == ERROR_SUCCESS)
    {
		if( (pszSubKey != NULL) && (pszSubKey[0]) )
		{
			lResult = RegOpenKeyExA(hkcr,pszSubKey,0,samDesired,phkResult);
			RegCloseKey(hkcr);
		}
		else
		{
			*phkResult = hkcr;
		}
    }

    return lResult;
}

//+-------------------------------------------------------------------
//
//  Function:   OpenClassesRootKeyA, private
//
//  Synopsis:   See the comments above.  This is the special verision of
//             RegOpenKeyA for HKCR-based hives.
//
//--------------------------------------------------------------------
LONG WINAPI OpenClassesRootKeyA(LPCSTR pszSubKey,HKEY *phkResult)
{
	return OpenClassesRootKeyExA(pszSubKey,MAXIMUM_ALLOWED,phkResult);
}
	
//+-------------------------------------------------------------------
//
//  Function:   QueryClassesRootValueA, private
//
//  Synopsis:   See the comments above.  This is the special verision of
//             RegQueryValueA for HKCR-based hives.
//
//--------------------------------------------------------------------
LONG WINAPI QueryClassesRootValueA(LPCSTR pszSubKey,LPSTR pszValue,PLONG lpcbValue)
{
	HKEY hkcr = NULL;
	LONG lResult = OpenClassesRootKeyA(NULL,&hkcr);

	if(lResult == ERROR_SUCCESS)
	{
		lResult = RegQueryValueA(hkcr,pszSubKey,pszValue,lpcbValue);
		RegCloseKey(hkcr);
	}

	return lResult;
}

//+-------------------------------------------------------------------
//
//  Function:   SetClassesRootValueW, private
//
//  Synopsis:   See the comments above.  This is the special verision of
//             RegSetValueW for HKCR-based hives.
//
//--------------------------------------------------------------------
LONG WINAPI SetClassesRootValueW(LPCWSTR pszSubKey,DWORD dwType,LPCWSTR pszData,DWORD cbData)
{
	HKEY hkcr = NULL;
	LONG lResult = OpenClassesRootKeyW(NULL,&hkcr);

	if(lResult == ERROR_SUCCESS)
	{
		lResult = RegSetValueW(hkcr,pszSubKey,dwType,pszData,cbData);
		RegCloseKey(hkcr);
	}

	return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\compch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\colbact.c ===
#include "compch.h"
#pragma hdrstop

#include <catalog.h>

STDAPI GetClassInfoForCurrentUser(
    IN REFCLSID rclsid,
    OUT IComClassInfo** ppIComClassInfo
    )
{
    if (ppIComClassInfo)
        *ppIComClassInfo = NULL;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

STDAPI GetDefaultPartitionForCurrentUser(
    OUT GUID * pguidPartitionId
    )
{
    if (pguidPartitionId)
        *pguidPartitionId = GUID_NULL;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

STDAPI GetDefaultPartitionForSid(
    IN const PSID pSid,
    OUT GUID* pguidPartitionId
    )
{
    if (pguidPartitionId)
        *pguidPartitionId = GUID_NULL;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

STDAPI PartitionAccessCheck(
    IN REFGUID guidPartition,
    OUT BOOL* pfAccess
    )
{
    if (pfAccess)
        *pfAccess = FALSE;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(colbact)
{
    DLPENTRY(GetClassInfoForCurrentUser)
    DLPENTRY(GetDefaultPartitionForCurrentUser)
    DLPENTRY(GetDefaultPartitionForSid)
    DLPENTRY(PartitionAccessCheck)
};

DEFINE_PROCNAME_MAP(colbact)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\clbcatq.c ===
#include "compch.h"
#pragma hdrstop

#include <objidl.h>

STDAPI
CheckMemoryGates(
    IN DWORD id,
    OUT BOOL *pbResult
    )
{
    if (pbResult)
        *pbResult = FALSE;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

STDAPI
ComPlusEnableRemoteAccess(IN BOOL fEnabled)
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

STDAPI
ComPlusRemoteAccessEnabled(OUT BOOL* pfEnabled)
{
    if (pfEnabled)
        *pfEnabled = FALSE;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

STDAPI
GetCatalogObject(
    IN REFIID riid,
    OUT void** ppv
    )
{
    if (ppv)
        *ppv = NULL;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

STDAPI
GetCatalogObject2(
    IN REFIID riid,
    OUT void** ppv
    )
{
    if (ppv)
        *ppv = NULL;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

STDAPI
GetComputerObject(
    IN REFIID riid,
    OUT void **ppv
    )
{
    if (ppv)
        *ppv = NULL;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(clbcatq)
{
    DLPENTRY(CheckMemoryGates)
    DLPENTRY(ComPlusEnableRemoteAccess)
    DLPENTRY(ComPlusRemoteAccessEnabled)
    DLPENTRY(GetCatalogObject)
    DLPENTRY(GetCatalogObject2)
    DLPENTRY(GetComputerObject)
};

DEFINE_PROCNAME_MAP(clbcatq)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\mobsync.c ===
#include "compch.h"
#pragma hdrstop

#include <syncrasp.h>

static
LRESULT
CALLBACK
SyncMgrRasProc (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    return -1;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mobsync)
{
    DLPENTRY(SyncMgrRasProc)
};

DEFINE_PROCNAME_MAP(mobsync)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\mtxclu.c ===
#include "compch.h"
#pragma hdrstop

#include <objidl.h>

#define NOTINPATH	0

BOOL
MtxCluIsClusterPresent()
{
    return FALSE;
}

LONG
WasDTCInstalledBySQL()
{
    return NOTINPATH;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mtxclu)
{
    DLPENTRY(MtxCluIsClusterPresent)
    DLPENTRY(WasDTCInstalledBySQL)
};

DEFINE_PROCNAME_MAP(mtxclu)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\comres.c ===
#include "compch.h"
#pragma hdrstop

HINSTANCE
COMResModuleInstance()
{
    SetLastError (ERROR_MOD_NOT_FOUND);
    return NULL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(comres)
{
    DLPENTRY(COMResModuleInstance)
};

DEFINE_PROCNAME_MAP(comres)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\comsvcs.c ===
#include "compch.h"
#pragma hdrstop

#include <comsvcs.h>
#undef GetObjectContext

DWORD __stdcall ComSvcsExceptionFilter(
    IN EXCEPTION_POINTERS* pExcepPtrs,
    IN const wchar_t* wszMethodName,
    IN const wchar_t* objectName
    )
{
    return EXCEPTION_CONTINUE_SEARCH;
}

STDAPI ComSvcsLogError(
    IN HRESULT hrError,
    IN int iErrorMessageCode,
    IN LPWSTR wszInfo,
    IN BOOL fFailFast
    )
{
    return FAILED (hrError) ? hrError : HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

typedef struct{

    DWORD dwMTAThreadPoolMaxSize;
    DWORD dwMTAThreadPoolThrottle;

} MTA_METRICS;


BOOL __stdcall
GetMTAThreadPoolMetrics(
    MTA_METRICS *pMM
    )
{
    if (pMM)
        ZeroMemory (pMM, sizeof (MTA_METRICS));

    return FALSE;
}

HRESULT __cdecl GetObjectContext(
    OUT IObjectContext** ppInstanceContext
    )
{
    if (ppInstanceContext)
        *ppInstanceContext = NULL;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

STDAPI
GetTrkSvrObject(
    IN REFIID riid,
    OUT void** ppv
    )
{
    if (ppv)
        *ppv = NULL;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(comsvcs)
{
    DLPENTRY(ComSvcsExceptionFilter)
    DLPENTRY(ComSvcsLogError)
    DLPENTRY(GetMTAThreadPoolMetrics)
    DLPENTRY(GetObjectContext)
    DLPENTRY(GetTrkSvrObject)
};

DEFINE_PROCNAME_MAP(comsvcs)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\ole32.c ===
#include "compch.h"
#pragma hdrstop

#define _OLE32_
#include <objidl.h>

#undef WINOLEAPI
#define WINOLEAPI           HRESULT STDAPICALLTYPE
#undef  WINOLEAPI_
#define WINOLEAPI_(_x)      _x STDAPICALLTYPE


static
WINOLEAPI
CLSIDFromProgID(
    IN LPCOLESTR lpszProgID,
    OUT LPCLSID lpclsid
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CLSIDFromString(
    IN LPOLESTR lpsz,
    OUT LPCLSID pclsid
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoCancelCall(
    IN DWORD dwThreadId,
    IN ULONG ulTimeout
    )
{
    return E_FAIL;
}
 

static
WINOLEAPI
CoCreateGuid(
    OUT GUID * pGuid
    )
{
    return RPC_S_OUT_OF_MEMORY;
}
 

static
WINOLEAPI
CoCreateInstance(
    IN REFCLSID rclsid,
    IN LPUNKNOWN pUnkOuter,
    IN DWORD dwClsContext,
    IN REFIID riid,
    OUT LPVOID FAR* ppv
    )
{
    *ppv = NULL;
    return E_FAIL;
}

static
WINOLEAPI
CoDisableCallCancellation(
    IN LPVOID pReserved
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoDisconnectObject(
    IN LPUNKNOWN pUnk,
    IN DWORD dwReserved
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoEnableCallCancellation(
    IN LPVOID pReserved
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoInitialize(
    IN LPVOID pvReserved
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoInitializeEx(
    IN LPVOID pvReserved,
    IN DWORD  dwCoInit
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoInitializeSecurity(
    IN PSECURITY_DESCRIPTOR         pSecDesc,
    IN LONG                         cAuthSvc,
    IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
    IN void                        *pReserved1,
    IN DWORD                        dwAuthnLevel,
    IN DWORD                        dwImpLevel,
    IN void                        *pAuthList,
    IN DWORD                        dwCapabilities,
    IN void                        *pReserved3
    )
{
    return E_FAIL;
}

static
WINOLEAPI CoImpersonateClient()
{
    return E_FAIL;
}

static
WINOLEAPI_(HINSTANCE)
CoLoadLibrary(
    IN LPOLESTR lpszLibName,
    IN BOOL     bAutoFree
    )
{
    return NULL;
}

static
WINOLEAPI
CoRevertToSelf()
{
    return E_FAIL;
}

static
WINOLEAPI 
CoSwitchCallContext( 
    IN IUnknown *pNewObject, 
    OUT IUnknown **ppOldObject )
{
    return E_FAIL;
}

static
WINOLEAPI
CoMarshalInterface(
    IN LPSTREAM pStm,
    IN REFIID riid,
    IN LPUNKNOWN pUnk,
    IN DWORD dwDestContext,
    IN LPVOID pvDestContext,
    IN DWORD mshlflags
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoRegisterClassObject(
    IN REFCLSID rclsid,
    IN LPUNKNOWN pUnk,
    IN DWORD dwClsContext,
    IN DWORD flags,
    OUT LPDWORD lpdwRegister
    )
{
    return E_FAIL;
}


static
WINOLEAPI
CoReleaseMarshalData(
    IN LPSTREAM pStm
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoResumeClassObjects(
    void
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoRevokeClassObject(
    IN DWORD dwRegister
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoSetProxyBlanket(
    IN IUnknown                 *pProxy,
    IN DWORD                     dwAuthnSvc,
    IN DWORD                     dwAuthzSvc,
    IN OLECHAR                  *pServerPrincName,
    IN DWORD                     dwAuthnLevel,
    IN DWORD                     dwImpLevel,
    IN RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    IN DWORD                     dwCapabilities
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoSuspendClassObjects(
    void
    )
{
    return E_FAIL;
}

static
WINOLEAPI_(LPVOID)
CoTaskMemAlloc(
    IN SIZE_T cb
    )
{
    return NULL;
}

static
WINOLEAPI_(LPVOID)
CoTaskMemRealloc(
    IN LPVOID pv,
    IN SIZE_T cb
    )
{
    return NULL;
}

static
WINOLEAPI_(void)
CoTaskMemFree(
    IN LPVOID pv
    )
{
    NOTHING;
}


static
WINOLEAPI_(void) 
CoUninitialize(
    void
    )
{
    NOTHING;
}

static
WINOLEAPI
CoUnmarshalInterface(
    IN LPSTREAM pStm,
    IN REFIID riid,
    OUT LPVOID FAR* ppv
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CreateClassMoniker(
    IN REFCLSID rclsid,
    OUT LPMONIKER FAR* ppmk)
{
    *ppmk = NULL;
    return E_FAIL;
}

static
WINOLEAPI
CreateItemMoniker(
    IN LPCOLESTR lpszDelim,
    IN LPCOLESTR lpszItem,
    OUT LPMONIKER FAR* ppmk)
{
    *ppmk = NULL;
    return E_FAIL;
}

static
WINOLEAPI
CreateStreamOnHGlobal(
    IN HGLOBAL hGlobal,
    IN BOOL fDeleteOnRelease,
    OUT LPSTREAM FAR* ppstm
    )
{
    return E_FAIL;
}

static
WINOLEAPI
GetRunningObjectTable(
    IN DWORD reserved,
    OUT LPRUNNINGOBJECTTABLE FAR* pprot
    )
{
    *pprot = NULL;
    return E_FAIL;
}

static
WINOLEAPI
MkParseDisplayName(
  LPBC pbc,
  LPCOLESTR szUserName,
  ULONG FAR *pchEaten,
  LPMONIKER FAR *ppmk
)
{
    *ppmk = NULL;
    return E_FAIL;
}

static
WINOLEAPI
OleInitialize(
    IN LPVOID pvReserved
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleLoadFromStream(
    IN LPSTREAM pStm,
    IN REFIID iidInterface,
    OUT LPVOID FAR* ppvObj
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleSaveToStream(
    IN LPPERSISTSTREAM pPStm,
    IN LPSTREAM pStm
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleLockRunning(
    IN LPUNKNOWN pUnknown,
    IN BOOL fLock,
    IN BOOL fLastUnlockCloses
    )
{
    return E_FAIL;
}

static
WINOLEAPI_(void)
OleUninitialize(
    void
    )
{
    NOTHING;
}

static
WINOLEAPI
ProgIDFromCLSID(
    IN REFCLSID clsid,
    OUT LPOLESTR FAR* lplpszProgID
    )
{
    return E_FAIL;
}


static
WINOLEAPI
StringFromCLSID(
    IN REFCLSID rclsid,
    OUT LPOLESTR FAR* lplpsz
    )
{
    return E_FAIL;
}

static
WINOLEAPI
WriteClassStm(
    IN LPSTREAM pStm,
    IN REFCLSID rclsid
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CreateDataAdviseHolder(
    OUT LPDATAADVISEHOLDER FAR* ppDAHolder
    )
{
    return E_FAIL;
}

static
WINOLEAPI
StgCreateDocfile(
    IN const OLECHAR FAR* pwcsName,
    IN DWORD grfMode,
    IN DWORD reserved,
    OUT IStorage FAR * FAR *ppstgOpen
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CreateILockBytesOnHGlobal(
    IN HGLOBAL hGlobal,
    IN BOOL fDeleteOnRelease,
    OUT LPLOCKBYTES FAR* pplkbyt
    )
{
    return E_FAIL;
}

static
WINOLEAPI
StgCreateDocfileOnILockBytes(
    IN ILockBytes FAR *plkbyt,
    IN DWORD grfMode,
    IN DWORD reserved,
    OUT IStorage FAR * FAR *ppstgOpen
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleQueryCreateFromData(
    IN LPDATAOBJECT pSrcDataObject
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleQueryLinkFromData(
    IN LPDATAOBJECT pSrcDataObject
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CreateFileMoniker(
    IN LPCOLESTR lpszPathName, 
    OUT LPMONIKER FAR* ppmk
    )
{
    return E_FAIL;
}

static
WINOLEAPI
GetClassFile(
    IN LPCOLESTR szFilename, 
    OUT CLSID FAR* pclsid
    )
{
    return E_FAIL;
}

static
WINOLEAPI
StgOpenStorage(
    IN const OLECHAR FAR* pwcsName,
    IN  IStorage FAR *pstgPriority,
    IN  DWORD grfMode,
    IN  SNB snbExclude,
    IN  DWORD reserved,
    OUT IStorage FAR * FAR *ppstgOpen
    )
{
    return E_FAIL;
}

static
WINOLEAPI_(int)
StringFromGUID2(
    IN REFGUID rguid,
    OUT LPOLESTR lpsz, 
    IN int cchMax
    )
{
    return 0;
}

static
WINOLEAPI
CoMarshalInterThreadInterfaceInStream(
    IN REFIID riid,
    IN LPUNKNOWN pUnk,
    OUT LPSTREAM *ppStm
    )
{
    return E_FAIL;
}

static 
WINOLEAPI
CoGetInterfaceAndReleaseStream(
    IN LPSTREAM pStm, 
    IN REFIID iid,
    OUT LPVOID FAR* ppv)
{
    return E_FAIL;
}

static 
WINOLEAPI
DoDragDrop(
    IN LPDATAOBJECT pDataObj,
    IN LPDROPSOURCE pDropSource,
    IN DWORD dwOKEffects,
    OUT LPDWORD pdwEffect
    )
{
    return E_FAIL;
}

static 
WINOLEAPI
OleGetClipboard(
    OUT LPDATAOBJECT FAR* ppDataObj
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleSetClipboard(
    IN LPDATAOBJECT pDataObj
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleRegEnumVerbs(
    IN REFCLSID clsid,
    OUT LPENUMOLEVERB FAR* ppenum
    )
{
    return E_FAIL;
}

static
WINOLEAPI
PropVariantClear(
    PROPVARIANT * pvar
    )
{
    return E_FAIL;
}

static
WINOLEAPI_(void)
ReleaseStgMedium(
    IN LPSTGMEDIUM pmedium
    )
{
    NOTHING;
}

static
WINOLEAPI_(void)
CoFreeUnusedLibraries(void)
{
    NOTHING;
}

static
WINOLEAPI
RevokeDragDrop(
    IN HWND hwnd
    )
{
    return E_FAIL;
}

static
WINOLEAPI
RegisterDragDrop(
    IN HWND hwnd,
    IN LPDROPTARGET pDropTarget
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleFlushClipboard(void)
{
    return E_FAIL;
}

static
WINOLEAPI
CoGetMalloc(
    IN DWORD dwMemContext,
    OUT LPMALLOC FAR* ppMalloc
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleRegGetMiscStatus(
    IN REFCLSID clsid,
    IN DWORD dwAspect,
    OUT DWORD FAR* pdwStatus
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleRegGetUserType(
    IN REFCLSID clsid,
    IN DWORD dwFormOfType,
    OUT LPOLESTR FAR* pszUserType
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CreateOleAdviseHolder(
    OUT LPOLEADVISEHOLDER FAR* ppOAHolder
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleRun(
    IN LPUNKNOWN pUnknown
    )
{
    return E_FAIL;
}

static
WINOLEAPI
FreePropVariantArray(
    ULONG cVariants,
    PROPVARIANT * rgvars
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CreateBindCtx(
    IN DWORD reserved,
    OUT LPBC FAR* ppbc
    )
{
    return E_FAIL;
}

static
WINOLEAPI
StgOpenStorageEx(
    IN const WCHAR* pwcsName,
    IN  DWORD grfMode,
    IN  DWORD stgfmt,              // enum
    IN  DWORD grfAttrs,             // reserved
    IN  STGOPTIONS * pStgOptions,
    IN  void * reserved,
    IN  REFIID riid,
    OUT void ** ppObjectOpen
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoGetClassObject(
    IN REFCLSID rclsid,
    IN DWORD dwClsContext,
    IN LPVOID pvReserved,
    IN REFIID riid,
    OUT LPVOID FAR* ppv
    )
{
    *ppv = NULL;
    return E_FAIL;
}  

static
WINOLEAPI
OleDraw(
    IN LPUNKNOWN pUnknown,
    IN DWORD dwAspect,
    IN HDC hdcDraw,
    IN LPCRECT lprcBounds
    )
{
    return E_OUTOFMEMORY;
}

static
WINOLEAPI
OleCreateFromData(
    IN LPDATAOBJECT pSrcDataObj,
    IN REFIID riid,
    IN DWORD renderopt,
    IN LPFORMATETC pFormatEtc,
    IN LPOLECLIENTSITE pClientSite,
    IN LPSTORAGE pStg,
    OUT LPVOID FAR* ppvObj
    )
{
    *ppvObj = NULL;
    return E_FAIL;
}

static
WINOLEAPI
OleSetMenuDescriptor(
    IN HOLEMENU holemenu,
    IN HWND hwndFrame,
    IN HWND hwndActiveObject,
    IN LPOLEINPLACEFRAME lpFrame,
    IN LPOLEINPLACEACTIVEOBJECT lpActiveObj
    )
{
    return E_FAIL;
}

static
WINOLEAPI
OleSave(
    IN LPPERSISTSTORAGE pPS,
    IN LPSTORAGE pStg,
    IN BOOL fSameAsLoad
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoFileTimeNow(
    OUT FILETIME FAR* lpFileTime
    )
{
    lpFileTime->dwHighDateTime = 0;
    lpFileTime->dwLowDateTime = GetTickCount();
    return S_OK;
}
    
static
WINOLEAPI_(void)
CoFreeLibrary(
    IN HINSTANCE hInst
    )
{
    NOTHING;
}

static
WINOLEAPI
CoRegisterMessageFilter(
    IN LPMESSAGEFILTER lpMessageFilter,
    OUT LPMESSAGEFILTER FAR* lplpMessageFilter
    )
{
    return E_FAIL;
}

static
WINOLEAPI
GetHGlobalFromStream(
    IN LPSTREAM pstm,
    OUT HGLOBAL FAR* phglobal
    )
{
    return E_OUTOFMEMORY;
}

static
WINOLEAPI
PropVariantCopy(
    PROPVARIANT * pvarDest,
    const PROPVARIANT * pvarSrc
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoAllowSetForegroundWindow(
    IN IUnknown *pUnk,
    IN LPVOID lpvReserved
    )
{
    return E_FAIL;
}

static
WINOLEAPI
CoCreateFreeThreadedMarshaler(
    IN LPUNKNOWN  punkOuter,
    OUT LPUNKNOWN *ppunkMarshal
    )
{
    *ppunkMarshal = NULL;
    return E_FAIL;
}

static
WINOLEAPI
CoWaitForMultipleHandles(
    IN DWORD dwFlags,
    IN DWORD dwTimeout,
    IN ULONG cHandles,
    IN LPHANDLE pHandles,
    OUT LPDWORD  lpdwindex)
{
    return E_FAIL;
}

static
WINOLEAPI
StringFromIID(
    IN REFIID rclsid,
    OUT LPOLESTR FAR* lplpsz
    )
{
    return E_FAIL;
}

static
WINOLEAPI
IIDFromString(
    IN LPOLESTR lpsz,
    OUT LPIID lpiid
    )
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ole32)
{
    DLPENTRY(CLSIDFromProgID)
    DLPENTRY(CLSIDFromString)
    DLPENTRY(CoAllowSetForegroundWindow)
    DLPENTRY(CoCancelCall)
    DLPENTRY(CoCreateFreeThreadedMarshaler)
    DLPENTRY(CoCreateGuid)
    DLPENTRY(CoCreateInstance)
    DLPENTRY(CoDisableCallCancellation)
    DLPENTRY(CoDisconnectObject)
    DLPENTRY(CoEnableCallCancellation)
    DLPENTRY(CoFileTimeNow)
    DLPENTRY(CoFreeLibrary)
    DLPENTRY(CoFreeUnusedLibraries)
    DLPENTRY(CoGetClassObject)
    DLPENTRY(CoGetInterfaceAndReleaseStream)
    DLPENTRY(CoGetMalloc)
    DLPENTRY(CoImpersonateClient)
    DLPENTRY(CoInitialize)
    DLPENTRY(CoInitializeEx)
    DLPENTRY(CoInitializeSecurity)
    DLPENTRY(CoLoadLibrary)
    DLPENTRY(CoMarshalInterThreadInterfaceInStream)
    DLPENTRY(CoMarshalInterface)
    DLPENTRY(CoRegisterClassObject)
    DLPENTRY(CoRegisterMessageFilter)
    DLPENTRY(CoReleaseMarshalData)
    DLPENTRY(CoResumeClassObjects)
    DLPENTRY(CoRevertToSelf)
    DLPENTRY(CoRevokeClassObject)
    DLPENTRY(CoSetProxyBlanket)
    DLPENTRY(CoSuspendClassObjects)
    DLPENTRY(CoSwitchCallContext)
    DLPENTRY(CoTaskMemAlloc)
    DLPENTRY(CoTaskMemFree)
    DLPENTRY(CoTaskMemRealloc)
    DLPENTRY(CoUninitialize)
    DLPENTRY(CoUnmarshalInterface)
    DLPENTRY(CoWaitForMultipleHandles)
    DLPENTRY(CreateBindCtx)
    DLPENTRY(CreateClassMoniker)
    DLPENTRY(CreateDataAdviseHolder)
    DLPENTRY(CreateFileMoniker)
    DLPENTRY(CreateILockBytesOnHGlobal)
    DLPENTRY(CreateItemMoniker)
    DLPENTRY(CreateOleAdviseHolder)
    DLPENTRY(CreateStreamOnHGlobal)
    DLPENTRY(DoDragDrop)
    DLPENTRY(FreePropVariantArray)
    DLPENTRY(GetClassFile)
    DLPENTRY(GetHGlobalFromStream)
    DLPENTRY(GetRunningObjectTable)
    DLPENTRY(IIDFromString)
    DLPENTRY(MkParseDisplayName)
    DLPENTRY(OleCreateFromData)
    DLPENTRY(OleDraw)
    DLPENTRY(OleFlushClipboard)
    DLPENTRY(OleGetClipboard)
    DLPENTRY(OleInitialize)
    DLPENTRY(OleLoadFromStream)
    DLPENTRY(OleLockRunning)
    DLPENTRY(OleQueryCreateFromData)
    DLPENTRY(OleQueryLinkFromData)
    DLPENTRY(OleRegEnumVerbs)
    DLPENTRY(OleRegGetMiscStatus)
    DLPENTRY(OleRegGetUserType)
    DLPENTRY(OleRun)
    DLPENTRY(OleSave)
    DLPENTRY(OleSaveToStream)
    DLPENTRY(OleSetClipboard)
    DLPENTRY(OleSetMenuDescriptor)
    DLPENTRY(OleUninitialize)
    DLPENTRY(ProgIDFromCLSID)
    DLPENTRY(PropVariantClear)
    DLPENTRY(PropVariantCopy)
    DLPENTRY(RegisterDragDrop)
    DLPENTRY(ReleaseStgMedium)
    DLPENTRY(RevokeDragDrop)
    DLPENTRY(StgCreateDocfile)
    DLPENTRY(StgCreateDocfileOnILockBytes)
    DLPENTRY(StgOpenStorage)
    DLPENTRY(StgOpenStorageEx)
    DLPENTRY(StringFromCLSID)
    DLPENTRY(StringFromGUID2)
    DLPENTRY(StringFromIID)
    DLPENTRY(WriteClassStm)         
};

DEFINE_PROCNAME_MAP(ole32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\xolehlp.c ===
#include "compch.h"
#pragma hdrstop

#include <objidl.h>

HRESULT __cdecl DtcGetTransactionManagerExW(
    IN WCHAR* pwszHost,
	IN WCHAR* pwszTmName,
	IN REFIID riid,
	IN DWORD grfOptions,
	IN void* pvConfigParams,
	OUT void** ppvObject
    )
{
    if (ppvObject)
        *ppvObject = NULL;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(xolehlp)
{
    DLPENTRY(DtcGetTransactionManagerExW)
};

DEFINE_PROCNAME_MAP(xolehlp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\idlole\idl\makefile.inc ===
callobj.idl : ..\public\callobj.idl
ocidl.idl   : ..\public\ocidl.idl
wtypes.idl  : ..\public\wtypes.idl
unknwn.idl  : ..\public\unknwn.idl
objidl.idl  : ..\public\objidl.idl
propidl.idl : ..\public\propidl.idl
pbagex.idl  : ..\public\pbagex.idl
oleidl.idl  : ..\public\oleidl.idl
oaidl.idl   : ..\public\oaidl.idl
storext.idl : ..\public\storext.idl
iaccess.idl : ..\public\iaccess.idl
immact.idl  : ..\public\immact.idl
obase.idl   : ..\public\obase.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\idlole\public\makefile.inc ===
#
# Inference Rules
#
.SUFFIXES:.acf

.idl{$(SDK_INC_PATH)}.idl:
    copy $? $@

.acf{$(SDK_INC_PATH)}.acf:
    copy $? $@

$(SDK_INC_PATH)\ocidl.idl:$(@F)
$(SDK_INC_PATH)\ocidl.acf:$(@F)
$(SDK_INC_PATH)\wtypes.idl:$(@F)
$(SDK_INC_PATH)\unknwn.idl:$(@F)
$(SDK_INC_PATH)\objidl.idl:$(@F)
$(SDK_INC_PATH)\propidl.idl:$(@F)
$(SDK_INC_PATH)\pbagex.idl:$(@F)
$(SDK_INC_PATH)\oleidl.idl:$(@F)
$(SDK_INC_PATH)\oaidl.idl:$(@F)
$(SDK_INC_PATH)\oaidl.acf:$(@F)
$(SDK_INC_PATH)\storext.idl:$(@F)
$(SDK_INC_PATH)\iaccess.idl:$(@F)
$(SDK_INC_PATH)\iaccess.acf:$(@F)
    copy $** $@
$(SDK_INC_PATH)\callobj.idl:$(@F)

clean:
    -del /F /Q $(NTTARGETFILE0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\rpcrt4.c ===
#include "compch.h"
#pragma hdrstop

#include <rpcdce.h>
#include <rpcdcep.h>
#include <rpcndr.h>
#include <midles.h>

static
RPCRTAPI
long
RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
RPC_STATUS
RPC_ENTRY
MesDecodeIncrementalHandleCreate(
    void         *  UserState,
    MIDL_ES_READ    ReadFn,
    handle_t     *  pHandle
    )
{
    return RPC_E_UNEXPECTED;
}

static
RPC_STATUS
RPC_ENTRY
MesEncodeIncrementalHandleCreate(
    void          * UserState,
    MIDL_ES_ALLOC   AllocFn,
    MIDL_ES_WRITE   WriteFn,
    handle_t      * pHandle
    )
{
    return RPC_E_UNEXPECTED;
}

static
RPC_STATUS
RPC_ENTRY
MesHandleFree(
    handle_t  Handle
    )
{
    return RPC_E_UNEXPECTED;
}

static
RPC_STATUS
RPC_ENTRY
MesIncrementalHandleReset(
    handle_t        Handle,
    void     *      UserState,
    MIDL_ES_ALLOC   AllocFn,
    MIDL_ES_WRITE   WriteFn,
    MIDL_ES_READ    ReadFn,
    MIDL_ES_CODE    Operation
    )
{
    return RPC_E_UNEXPECTED;
}

static
CLIENT_CALL_RETURN
RPC_VAR_ENTRY
NdrClientCall2(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    )
{
    CLIENT_CALL_RETURN RetVal;

    RetVal.Simple = (LONG_PTR) STATUS_PROCEDURE_NOT_FOUND;
    return RetVal;
}

static
size_t
RPC_ENTRY
NdrMesTypeAlignSize2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pPicklingInfo,
    const MIDL_STUB_DESC *          pStubDesc,
    PFORMAT_STRING                  pFormatString,
    const void           *          pObject
    )
{
    return 0;
}

static
void
RPC_ENTRY
NdrMesTypeDecode2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pPicklingInfo,
    const MIDL_STUB_DESC *          pStubDesc,
    PFORMAT_STRING                  pFormatString,
    void                 *          pObject
    )
{
    return;
}

static
void
RPC_ENTRY
NdrMesTypeEncode2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pPicklingInfo,
    const MIDL_STUB_DESC *          pStubDesc,
    PFORMAT_STRING                  pFormatString,
    const void           *          pObject
    )
{
    return;
}

static
void  
RPC_ENTRY
NdrMesTypeFree2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    void                          * pObject
    )
{
    return;
}

static
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFree (
    IN OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    )
{
    return RPC_E_UNEXPECTED;
}

static
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    )
{
    return RPC_E_UNEXPECTED;
}

static
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoExW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc, OPTIONAL
    IN RPC_SECURITY_QOS *SecurityQOS
    )
{
    return RPC_E_UNEXPECTED;
}

static
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpResolveBinding (
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_IF_HANDLE IfSpec
    )
{
    return RPC_E_UNEXPECTED;
}

static
RPCRTAPI
void
RPC_ENTRY
RpcSsDestroyClientContext (
    IN void  *  * ContextHandle
    )
{
    return;
}

static
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeW (
    IN unsigned short __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned short __RPC_FAR * Protseq OPTIONAL,
    IN unsigned short __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned short __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned short __RPC_FAR * Options OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    )
{
    return RPC_E_UNEXPECTED;
}

static
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeA (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    )
{
    return RPC_E_UNEXPECTED;
}

static
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeW (
    IN OUT unsigned short __RPC_FAR * __RPC_FAR * String
    )
{
    return RPC_E_UNEXPECTED;
}

static
RPC_STATUS
RPC_ENTRY
UuidCreate (
    OUT UUID* Uuid
    )
{
    ZeroMemory(Uuid, sizeof(*Uuid));
    return RPC_E_UNEXPECTED;
}

static
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringA (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    )
{
    return RPC_E_UNEXPECTED;
}

//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(rpcrt4)
{
    DLPENTRY(I_RpcMapWin32Status)
    DLPENTRY(MesDecodeIncrementalHandleCreate)
    DLPENTRY(MesEncodeIncrementalHandleCreate)
    DLPENTRY(MesHandleFree)
    DLPENTRY(MesIncrementalHandleReset)
    DLPENTRY(NdrClientCall2)
    DLPENTRY(NdrMesTypeAlignSize2)
    DLPENTRY(NdrMesTypeDecode2)
    DLPENTRY(NdrMesTypeEncode2)
    DLPENTRY(NdrMesTypeFree2)
    DLPENTRY(RpcBindingFree)
    DLPENTRY(RpcBindingFromStringBindingW)
    DLPENTRY(RpcBindingSetAuthInfoExW)
    DLPENTRY(RpcEpResolveBinding)
    DLPENTRY(RpcSsDestroyClientContext)
    DLPENTRY(RpcStringBindingComposeW)
    DLPENTRY(RpcStringFreeA)
    DLPENTRY(RpcStringFreeW)
    DLPENTRY(UuidCreate)
    DLPENTRY(UuidToStringA)
};

DEFINE_PROCNAME_MAP(rpcrt4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\dload\oleaut32.c ===
#include "compch.h"
#pragma hdrstop

#define _OLEAUT32_
#include <oleauto.h>
#include <olectl.h>

#undef WINOLEAUTAPI
#define WINOLEAUTAPI    HRESULT STDAPICALLTYPE
#undef WINOLECTLAPI
#define WINOLECTLAPI    HRESULT STDAPICALLTYPE
#undef WINOLEAUTAPI_
#define WINOLEAUTAPI_(type) type STDAPICALLTYPE
    

static
STDMETHODIMP_(BSTR)
SysAllocString(
    const OLECHAR * string
    )
{
    return NULL;
}

static
STDMETHODIMP_(void)
SysFreeString(
    BSTR bstrString
    )
{
    return;
}

static
STDMETHODIMP_(void)
VariantInit(
    VARIANTARG * pvarg
    )
{
    pvarg->vt = VT_EMPTY;

    return;
}

static
STDMETHODIMP
VariantClear(
    VARIANTARG * pvarg
    )
{
    pvarg->vt = VT_EMPTY;

    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP_(BSTR)
SysAllocStringByteLen(
    LPCSTR psz,
    UINT len
    )
{
    return NULL;
}

static
STDMETHODIMP_(UINT)
SafeArrayGetDim(
    SAFEARRAY * psa
    )
{
    return 0;
}

static
STDMETHODIMP_(UINT)
SysStringByteLen(
    BSTR bstr
    )
{
    return 0;
}

static
STDMETHODIMP_(SAFEARRAY *)
SafeArrayCreateVector(
    VARTYPE vt,
    LONG lLbound,
    ULONG cElements
    )
{
    return NULL;
}

static
STDMETHODIMP_(SAFEARRAY *)
SafeArrayCreate(
    VARTYPE vt,
    UINT cDims,
    SAFEARRAYBOUND * rgsabound
    )
{
    return NULL;
}

static
STDMETHODIMP
SafeArrayCopy(
    SAFEARRAY * psa,
    SAFEARRAY ** ppsaOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
SafeArrayPutElement(
    SAFEARRAY * psa,
    LONG * rgIndices,
    void * pv
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
SafeArrayDestroy(
    SAFEARRAY * psa
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
SafeArrayAccessData(
    SAFEARRAY * psa,
    void HUGEP** ppvData
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
SafeArrayUnaccessData(
    SAFEARRAY * psa
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP_(INT)
VariantTimeToSystemTime(
    DOUBLE vtime,
    LPSYSTEMTIME lpSystemTime
    )
{
    return FALSE;
}

static
STDMETHODIMP
OleCreatePropertyFrame(
    HWND hwndOwner,
    UINT x,
    UINT y,
    LPCOLESTR lpszCaption,
    ULONG cObjects,
    LPUNKNOWN FAR* ppUnk,
    ULONG cPages,
    LPCLSID pPageClsID,
    LCID lcid,
    DWORD dwReserved,
    LPVOID pvReserved)
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP_(UINT)
SysStringLen(
    BSTR bstr
    )
{
    return 0;
}

static
STDMETHODIMP
LoadRegTypeLib(
    REFGUID rguid,
    WORD wVerMajor,
    WORD wVerMinor,
    LCID lcid,
    ITypeLib ** pptlib
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
SetErrorInfo(
    ULONG dwReserved,
    IErrorInfo * perrinfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP_(INT)
SystemTimeToVariantTime(
    LPSYSTEMTIME lpSystemTime,
    DOUBLE *pvtime
    )
{
    return 0;
}

static
STDMETHODIMP
VariantCopy(
    VARIANTARG * pvargDest,
    VARIANTARG * pvargSrc
    )
{
    return E_OUTOFMEMORY;
}

static
STDMETHODIMP_(INT)
DosDateTimeToVariantTime(
    USHORT wDosDate,
    USHORT wDosTime,
    DOUBLE * pvtime
    )
{
    return 0;
}

static
STDMETHODIMP_(INT)
VariantTimeToDosDateTime(
    DOUBLE vtime,
    USHORT * pwDosDate,
    USHORT * pwDosTime
    )
{
    return 0;
}

static
STDMETHODIMP
SafeArrayGetUBound(
    SAFEARRAY * psa,
    UINT nDim,
    LONG * plUbound
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
VarDiv(
    LPVARIANT pvarLeft,
    LPVARIANT pvarRight,
    LPVARIANT pvarResult)
{
    // I bet people don't check the return value
    // so do a VariantClear just to be safe
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
VarNeg(
    LPVARIANT pvarIn,
    LPVARIANT pvarResult)
{
    // I bet people don't check the return value
    // so do a VariantClear just to be safe
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
VarRound(
    LPVARIANT pvarIn,
    int cDecimals,
    LPVARIANT pvarResult)
{
    // I bet people don't check the return value
    // so do a VariantClear just to be safe
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
VarCmp(
    LPVARIANT pvarLeft,
    LPVARIANT pvarRight,
    LCID lcid,
    ULONG dwFlags
    )
{
    return VARCMP_NULL;
}

static
STDMETHODIMP
VarMul(
    LPVARIANT pvarLeft,
    LPVARIANT pvarRight,
    LPVARIANT pvarResult)
{
    // I bet people don't check the return value
    // so do a VariantClear just to be safe
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
VarPow(
    LPVARIANT pvarLeft,
    LPVARIANT pvarRight,
    LPVARIANT pvarResult)
{
    // I bet people don't check the return value
    // so do a VariantClear just to be safe
    ZeroMemory(pvarResult, sizeof(*pvarResult));
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
RegisterTypeLib(
    ITypeLib * ptlib,
    OLECHAR  *szFullPath,
    OLECHAR  *szHelpDir
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
LoadTypeLib(
    const OLECHAR *szFile,
    ITypeLib ** pptlib
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
LoadTypeLibEx(
    LPCOLESTR szFile,
    REGKIND regKind,
    ITypeLib ** pptlib
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP_(BSTR)
SysAllocStringLen(
    const OLECHAR * strIn,
    UINT cch
    )
{
    return NULL;
}

static
STDMETHODIMP
VariantChangeType(
    VARIANTARG * pvargDest,
    VARIANTARG * pvarSrc,
    USHORT wFlags,
    VARTYPE vt
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
STDMETHODIMP
SafeArrayGetLBound(
    SAFEARRAY * psa,
    UINT nDim,
    LONG * plLbound
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
DispInvoke(
    void * _this,
    ITypeInfo * ptinfo,
    DISPID dispidMember,
    WORD wFlags,
    DISPPARAMS * pparams,
    VARIANT * pvarResult,
    EXCEPINFO * pexcepinfo,
    UINT * puArgErr
    )
{
    return E_OUTOFMEMORY;
}

static
WINOLEAUTAPI
DispGetIDsOfNames(
    ITypeInfo * ptinfo,
    OLECHAR ** rgszNames,
    UINT cNames,
    DISPID * rgdispid
    )
{
    return E_OUTOFMEMORY;
}

static
WINOLEAUTAPI
SafeArrayGetElement(
    SAFEARRAY* psa,
    LONG* rgIndices,
    void* pv
    )
{
    return E_OUTOFMEMORY;
}

static
WINOLECTLAPI
OleCreatePropertyFrameIndirect(
    LPOCPFIPARAMS lpParams
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VariantCopyInd(
    VARIANT* pvarDest,
    VARIANTARG* pvargSrc
    )
{
    return E_OUTOFMEMORY;
}

static
WINOLEAUTAPI_(UINT)
SafeArrayGetElemsize(
    SAFEARRAY * psa
    )
{
    return 0;
}

static
WINOLEAUTAPI
VarI2FromI4(
    LONG lIn,
    SHORT * psOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarI2FromR4(
    FLOAT fltIn,
    SHORT * psOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarI2FromR8(
    DOUBLE dblIn,
    SHORT * psOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarI2FromCy(
    CY cyIn,
    SHORT * psOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarI2FromDate(
    DATE dateIn,
    SHORT * psOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarI2FromStr(
    OLECHAR * strIn,
    LCID lcid,
    ULONG dwFlags,
    SHORT * psOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarI4FromR4(
    FLOAT fltIn,
    LONG * plOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarI4FromR8(
    DOUBLE dblIn,
    LONG * plOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarI4FromCy(
    CY cyIn,
    LONG * plOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarI4FromDate(
    DATE dateIn,
    LONG * plOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarI4FromStr(
    OLECHAR * strIn,
    LCID lcid,
    ULONG dwFlags,
    LONG * plOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarUI4FromStr(
    OLECHAR * strIn,
    LCID lcid,
    ULONG dwFlags,
    ULONG * plOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}



static
WINOLEAUTAPI
VarR4FromI4(
    LONG lIn,
    FLOAT * pfltOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarR4FromR8(
    DOUBLE dblIn,
    FLOAT * pfltOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarR4FromCy(
    CY cyIn,
    FLOAT * pfltOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarR4FromDate(
    DATE dateIn,
    FLOAT * pfltOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarR4FromStr(
    OLECHAR * strIn,
    LCID lcid,
    ULONG dwFlags,
    FLOAT *pfltOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarR8FromCy(
    CY cyIn,
    DOUBLE * pdblOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarR8FromDate(
    DATE dateIn,
    DOUBLE * pdblOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarR8FromStr(
    OLECHAR *strIn,
    LCID lcid,
    ULONG dwFlags,
    DOUBLE *pdblOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarDateFromI2(
    SHORT sIn,
    DATE * pdateOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarDateFromI4(
    LONG lIn,
    DATE * pdateOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarDateFromR4(
    FLOAT fltIn,
    DATE * pdateOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarDateFromR8(
    DOUBLE dblIn,
    DATE * pdateOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarDateFromCy(
    CY cyIn,
    DATE * pdateOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarDateFromStr(
    OLECHAR *strIn,
    LCID lcid,
    ULONG dwFlags,
    DATE *pdateOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarDateFromBool(
    VARIANT_BOOL boolIn,
    DATE * pdateOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarCyFromI2(
    SHORT sIn,
    CY * pcyOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarCyFromI4(
    LONG lIn,
    CY * pcyOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarCyFromR4(
    FLOAT fltIn,
    CY * pcyOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarCyFromR8(
    DOUBLE dblIn,
    CY * pcyOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarCyFromDate(
    DATE dateIn,
    CY * pcyOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarCyFromStr(
    OLECHAR * strIn,
    LCID lcid,
    ULONG dwFlags,
    CY * pcyOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarCyFromBool(
    VARIANT_BOOL boolIn,
    CY * pcyOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBstrFromI2(
    SHORT iVal,
    LCID lcid,
    ULONG dwFlags,
    BSTR * pbstrOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBstrFromI4(
    LONG lIn,
    LCID lcid,
    ULONG dwFlags,
    BSTR * pbstrOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBstrFromR4(
    FLOAT fltIn,
    LCID lcid,
    ULONG dwFlags,
    BSTR * pbstrOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBstrFromR8(
    DOUBLE dblIn,
    LCID lcid,
    ULONG dwFlags,
    BSTR * pbstrOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBstrFromCy(
    CY cyIn,
    LCID lcid,
    ULONG dwFlags,
    BSTR * pbstrOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBstrFromDate(
    DATE dateIn,
    LCID lcid,
    ULONG dwFlags,
    BSTR * pbstrOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBstrFromBool(
    VARIANT_BOOL boolIn,
    LCID lcid,
    ULONG dwFlags,
    BSTR * pbstrOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBoolFromI2(
    SHORT sIn,
    VARIANT_BOOL * pboolOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBoolFromI4(
    LONG lIn,
    VARIANT_BOOL * pboolOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBoolFromR4(
    FLOAT fltIn,
    VARIANT_BOOL * pboolOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBoolFromR8(
    DOUBLE dblIn,
    VARIANT_BOOL * pboolOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBoolFromDate(
    DATE dateIn,
    VARIANT_BOOL * pboolOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBoolFromCy(
    CY cyIn,
    VARIANT_BOOL * pboolOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarBoolFromStr(
    OLECHAR * strIn,
    LCID lcid,
    ULONG dwFlags,
    VARIANT_BOOL * pboolOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VarFormatCurrency(
    LPVARIANT pvarIn,
    int iNumDig,
    int iIncLead,
    int iUseParens,
    int iGroup,
    ULONG dwFlags,
    BSTR *pbstrOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
VariantChangeTypeEx(
    VARIANTARG * pvargDest,
    VARIANTARG * pvarSrc,
    LCID lcid,
    USHORT wFlags,
    VARTYPE vt
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
CreateTypeLib2(
    SYSKIND syskind,
    LPCOLESTR szFile,
    ICreateTypeLib2 **ppctlib
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
UnRegisterTypeLib(
    REFGUID libID, 
    WORD wVerMajor,
    WORD wVerMinor,
    LCID lcid,
    SYSKIND syskind
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
GetErrorInfo(
    ULONG dwReserved,
    IErrorInfo ** pperrinfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLEAUTAPI
CreateErrorInfo(
    ICreateErrorInfo ** pperrinfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
WINOLECTLAPI
OleCreateFontIndirect(
    LPFONTDESC lpFontDesc,
    REFIID riid,
    LPVOID FAR* lplpvObj
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(oleaut32)
{
    DLOENTRY(  2, SysAllocString)
    DLOENTRY(  4, SysAllocStringLen)
    DLOENTRY(  6, SysFreeString)
    DLOENTRY(  7, SysStringLen)
    DLOENTRY(  8, VariantInit)
    DLOENTRY(  9, VariantClear)
    DLOENTRY( 10, VariantCopy)
    DLOENTRY( 11, VariantCopyInd)
    DLOENTRY( 12, VariantChangeType)
    DLOENTRY( 13, VariantTimeToDosDateTime)
    DLOENTRY( 14, DosDateTimeToVariantTime)
    DLOENTRY( 15, SafeArrayCreate)
    DLOENTRY( 16, SafeArrayDestroy)
    DLOENTRY( 17, SafeArrayGetDim)
    DLOENTRY( 18, SafeArrayGetElemsize)
    DLOENTRY( 19, SafeArrayGetUBound)
    DLOENTRY( 20, SafeArrayGetLBound)
    DLOENTRY( 23, SafeArrayAccessData)
    DLOENTRY( 24, SafeArrayUnaccessData)
    DLOENTRY( 25, SafeArrayGetElement)
    DLOENTRY( 26, SafeArrayPutElement)
    DLOENTRY( 27, SafeArrayCopy)
    DLOENTRY( 29, DispGetIDsOfNames)
    DLOENTRY( 30, DispInvoke)
    DLOENTRY( 49, VarI2FromI4)
    DLOENTRY( 50, VarI2FromR4)
    DLOENTRY( 51, VarI2FromR8)
    DLOENTRY( 52, VarI2FromCy)
    DLOENTRY( 53, VarI2FromDate)
    DLOENTRY( 54, VarI2FromStr)
    DLOENTRY( 60, VarI4FromR4)
    DLOENTRY( 61, VarI4FromR8)
    DLOENTRY( 62, VarI4FromCy)
    DLOENTRY( 63, VarI4FromDate)
    DLOENTRY( 64, VarI4FromStr)
    DLOENTRY( 70, VarR4FromI4)
    DLOENTRY( 71, VarR4FromR8)
    DLOENTRY( 72, VarR4FromCy)
    DLOENTRY( 73, VarR4FromDate)
    DLOENTRY( 74, VarR4FromStr)
    DLOENTRY( 82, VarR8FromCy)
    DLOENTRY( 83, VarR8FromDate)
    DLOENTRY( 84, VarR8FromStr)
    DLOENTRY( 89, VarDateFromI2)
    DLOENTRY( 90, VarDateFromI4)
    DLOENTRY( 91, VarDateFromR4)
    DLOENTRY( 92, VarDateFromR8)
    DLOENTRY( 93, VarDateFromCy)
    DLOENTRY( 94, VarDateFromStr)
    DLOENTRY( 96, VarDateFromBool)
    DLOENTRY( 99, VarCyFromI2)
    DLOENTRY(100, VarCyFromI4)
    DLOENTRY(101, VarCyFromR4)
    DLOENTRY(102, VarCyFromR8)
    DLOENTRY(103, VarCyFromDate)
    DLOENTRY(104, VarCyFromStr)
    DLOENTRY(106, VarCyFromBool)
    DLOENTRY(109, VarBstrFromI2)
    DLOENTRY(110, VarBstrFromI4)
    DLOENTRY(111, VarBstrFromR4)
    DLOENTRY(112, VarBstrFromR8)
    DLOENTRY(113, VarBstrFromCy)
    DLOENTRY(114, VarBstrFromDate)
    DLOENTRY(116, VarBstrFromBool)
    DLOENTRY(119, VarBoolFromI2)
    DLOENTRY(120, VarBoolFromI4)
    DLOENTRY(121, VarBoolFromR4)
    DLOENTRY(122, VarBoolFromR8)
    DLOENTRY(123, VarBoolFromDate)
    DLOENTRY(124, VarBoolFromCy)
    DLOENTRY(125, VarBoolFromStr)
    DLOENTRY(127, VarFormatCurrency)
    DLOENTRY(143, VarDiv)
    DLOENTRY(147, VariantChangeTypeEx)
    DLOENTRY(149, SysStringByteLen)
    DLOENTRY(150, SysAllocStringByteLen)
    DLOENTRY(156, VarMul)
    DLOENTRY(158, VarPow)
    DLOENTRY(161, LoadTypeLib)
    DLOENTRY(162, LoadRegTypeLib)
    DLOENTRY(163, RegisterTypeLib)
    DLOENTRY(173, VarNeg)
    DLOENTRY(175, VarRound)
    DLOENTRY(176, VarCmp)
    DLOENTRY(180, CreateTypeLib2)
    DLOENTRY(183, LoadTypeLibEx)
    DLOENTRY(184, SystemTimeToVariantTime)
    DLOENTRY(185, VariantTimeToSystemTime)
    DLOENTRY(186, UnRegisterTypeLib)
    DLOENTRY(200, GetErrorInfo)
    DLOENTRY(201, SetErrorInfo)
    DLOENTRY(202, CreateErrorInfo)
    DLOENTRY(277, VarUI4FromStr)
    DLOENTRY(411, SafeArrayCreateVector)
    DLOENTRY(416, OleCreatePropertyFrameIndirect)
    DLOENTRY(417, OleCreatePropertyFrame)
    DLOENTRY(420, OleCreateFontIndirect)
};

DEFINE_ORDINAL_MAP(oleaut32);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\idlole\genxie\makefile.inc ===
#
# Special hack for comcat.  Turn off 4090 until midl is fixed to generate the remote thunks
# correctly.
#

$(O)\comcat_p.obj : $(O)\comcat_p.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    type << > $(O)\comcat_warning.h
#pragma warning(4:4090)
#pragma warning(4:4047)
#undef _MIDL_USE_GUIDDEF_
#undef __RPCNDR_H__ 	
#undef __RPC_H__ 	
#undef RPC_NO_WINDOWS_H
#undef COM_NO_WINDOWS_H
#undef GUID_DEFS_ONLY
#define REGISTER_PROXY_DLL
<<
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$O/" $(USE_FC) $(USECXX_FLAG) $?
$(EX_C_COMPILER_FLAGS)
-FI$(O)\comcat_warning.h
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\inc\makefile.inc ===
# ole2.w -> $(SDK_INC_PATH)\ole2.h
#$(O)\ole2.h : ole2.w

#
# Inference rules.  These help build whatever is in the NTTARGETFILES and
# NTTARGETFILE0 lists.
#

.SUFFIXES:.w .h 

# generate header.h from header.w
{}.w{$O}.h:
    copy $** $@
#    shfusion2 $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\idlole\h\idlmulti.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       idlmulti.h
//
//  Contents:   preprocessor trickery to make our .idl/.tdl files compile
//              with MIDL or APBU Mktyplib.
//
//  History:    27-May-94   DonCl     Created
//              20-Jul-94   ErikGav   Remove SDKTOOLS support
//
//----------------------------------------------------------------------------

#ifndef __IDLMULTI_H__
#define __IDLMULTI_H__

#define ENDCOCLASS  };


#ifndef __MKTYPLIB__
#define TYPEDEF(guid)   \
typedef

#define LOCAL_INTERFACE(guid)       \
[                                   \
    local,                          \
    object,                         \
    uuid(guid),                     \
    pointer_default(unique)         \
]


#define REMOTED_INTERFACE(guid)     \
[                                   \
    object,                         \
    uuid(guid),                     \
    pointer_default(unique)         \
]


#define BEGINEVENTSET(es)   \
eventset es  \
{            \

#define ENDEVENTSET  };


#define COCLASS(name, dispint, events)  \
cotype name                                                 \
{                                                           \
    dispinterface dispint;                                  \
    eventset events;



#else // __MKTYPLIB__

#define TYPEDEF(guid) typedef [uuid(guid)]

#define cpp_quote(string)

#define const

#define LOCAL_INTERFACE(guid)    \
[                           \
    uuid(guid),             \
    odl                     \
]

#define REMOTED_INTERFACE(guid)   \
[                           \
    uuid(guid),             \
    odl                     \
]

#define BEGINEVENTSET(es)  \
dispinterface es           \
{                          \
properties:                \
                           \
methods:                   \

#define ENDEVENTSET  };


#define COCLASS(name, dispint, events)          \
coclass name                                    \
{                                               \
    [default] dispinterface dispint;            \
    [source, default] dispinterface events;     \



#endif  /// MKTYPLIB

#endif  // __IDLMULTI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\mc\makefile.inc ===
$(O)\allerror.mc:    smctlerr.mc smgmterr.mc oledberr.mc reconcil.mc a_first.x z_last.x
    copy a_first.x + smctlerr.mc + smgmterr.mc + oledberr.mc + z_last.x $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\inc\sens.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sens.h

Abstract:

    This file is the master header file for Event System events published
    and subscribed by the System Event Notification service (SENS).

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          12/8/1997         Start.

--*/


#ifndef __SENS_H__
#define __SENS_H__

#if _MSC_VER > 1000
#pragma once
#endif

//
// Constants
//

#define CONNECTION_LAN   0x00000001
#define CONNECTION_WAN   0x00000002
#define CONNECTION_AOL   0x00000004




//
// SENS Guids related to Event System
//


DEFINE_GUID(
    SENSGUID_PUBLISHER,             /* 5fee1bd6-5b9b-11d1-8dd2-00aa004abd5e */
    0x5fee1bd6,
    0x5b9b,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_SUBSCRIBER_LCE,        /* d3938ab0-5b9d-11d1-8dd2-00aa004abd5e */
    0xd3938ab0,
    0x5b9d,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_SUBSCRIBER_WININET,    /* d3938ab5-5b9d-11d1-8dd2-00aa004abd5e */
    0xd3938ab5,
    0x5b9d,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);





//
// Classes of Events published by SENS
//

DEFINE_GUID(
    SENSGUID_EVENTCLASS_NETWORK,        /* d5978620-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978620,
    0x5b9f,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_EVENTCLASS_LOGON,          /* d5978630-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978630,
    0x5b9f,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_EVENTCLASS_ONNOW,          /* d5978640-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978640,
    0x5b9f,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);

DEFINE_GUID(
    SENSGUID_EVENTCLASS_LOGON2,         /* d5978650-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978650,
    0x5b9f,
    0x11d1,
    0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e
);


#endif // __SENS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\inc\sensapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sensapi.h

Abstract:

    Public header file for the SENS Connectivity APIs.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/12/1997         Start.

--*/


#ifndef __SENSAPI_H__
#define __SENSAPI_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


#define NETWORK_ALIVE_LAN   0x00000001
#define NETWORK_ALIVE_WAN   0x00000002
#define NETWORK_ALIVE_AOL   0x00000004


typedef struct tagQOCINFO
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwInSpeed;
    DWORD dwOutSpeed;
} QOCINFO, *LPQOCINFO;



#ifdef UNICODE
#define  IsDestinationReachable  IsDestinationReachableW
#else
#define  IsDestinationReachable  IsDestinationReachableA
#endif // UNICODE


#if !defined(__midl)

BOOL APIENTRY
IsDestinationReachableA(
    LPCSTR lpszDestination,
    LPQOCINFO lpQOCInfo
    );

BOOL APIENTRY
IsDestinationReachableW(
    LPCWSTR lpszDestination,
    LPQOCINFO lpQOCInfo
    );

BOOL APIENTRY
IsNetworkAlive(
    LPDWORD lpdwFlags
    );

#endif // !defined(__midl)


#ifdef __cplusplus
}
#endif

#endif // __SENSAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\inc\sensapip.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sensapip.h

Abstract:

    This header file is used by components external to System Event
    Notification Service (SENS). These components will call SENS to
    notify it of events related to themselves.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/4/1997         Start.

--*/


#ifndef __SENSAPIP_H__
#define __SENSAPIP_H__

#if _MSC_VER > 1000
#pragma once
#endif

//
// Includes
//


#if !defined(__midl)
#include <netcon.h>
#else
import "netcon.idl";
#endif // __midl

#ifdef __cplusplus
extern "C" {
#endif

//
// Constants
//

#define SENS_NOTIFY_RAS_STARTED                 0x00000001
#define SENS_NOTIFY_RAS_STOPPED                 0x00000002
#define SENS_NOTIFY_RAS_CONNECT                 0x00000004
#define SENS_NOTIFY_RAS_DISCONNECT              0x00000008
#define SENS_NOTIFY_RAS_DISCONNECT_PENDING      0x00000010
#define SENS_NOTIFY_LAN_CONNECT                 0x00000020
#define SENS_NOTIFY_LAN_DISCONNECT              0x00000040

#define SENS_NOTIFY_WINLOGON_LOGON              0x00001000
#define SENS_NOTIFY_WINLOGON_LOGOFF             0x00002000
#define SENS_NOTIFY_WINLOGON_STARTUP            0x00004000
#define SENS_NOTIFY_WINLOGON_STARTSHELL         0x00008000
#define SENS_NOTIFY_WINLOGON_SHUTDOWN           0x00010000
#define SENS_NOTIFY_WINLOGON_LOCK               0x00020000
#define SENS_NOTIFY_WINLOGON_UNLOCK             0x00040000
#define SENS_NOTIFY_WINLOGON_STARTSCREENSAVER   0x00080000
#define SENS_NOTIFY_WINLOGON_STOPSCREENSAVER    0x00100000
#define SENS_NOTIFY_WINLOGON_POSTSHELL          0x00200000
#define SENS_NOTIFY_WINLOGON_SESSION_DISCONNECT 0x00400000
#define SENS_NOTIFY_WINLOGON_SESSION_RECONNECT  0x00800000

//
// Typedefs
//

typedef DWORD SENS_HRASCONN;

typedef struct _WINLOGON_INFO
{
    ULONG Size;
    ULONG Flags;
    LPWSTR UserName;
    LPWSTR Domain;
    LPWSTR WindowStation;
    DWORD hToken;   // Originally HANDLE
    DWORD hDesktop; // Originally HDESK
    DWORD dwSessionId;
} WINLOGON_INFO, *PWINLOGON_INFO;

typedef struct _SENS_NOTIFY_WINLOGON
{
    DWORD eType;
    WINLOGON_INFO Info;
} SENS_NOTIFY_WINLOGON, *PSENS_NOTIFY_WINLOGON;

typedef struct _SENS_NOTIFY_RAS
{
    DWORD eType;
    SENS_HRASCONN hConnection;
} SENS_NOTIFY_RAS, *PSENS_NOTIFY_RAS;

typedef struct _SENS_NOTIFY_NETCON
{
    DWORD eType;
    INetConnection *pINetConnection;
} SENS_NOTIFY_NETCON, *PSENS_NOTIFY_NETCON;

typedef struct _SENS_NOTIFY_NETCON_P // _P stands for Private
{
    DWORD eType;
#ifdef MIDL_PASS
    [string]
#endif // MIDL_PASS
    LPWSTR Name;
    NETCON_STATUS Status;
    NETCON_MEDIATYPE Type;
} SENS_NOTIFY_NETCON_P, *PSENS_NOTIFY_NETCON_P;

//
// Function prototypes
//

#if !defined(__midl)

DWORD APIENTRY
SensNotifyWinlogonEvent(
    PSENS_NOTIFY_WINLOGON pEvent
    );

DWORD APIENTRY
SensNotifyRasEvent(
    PSENS_NOTIFY_RAS pEvent
    );

DWORD APIENTRY
SensNotifyNetconEvent(
    PSENS_NOTIFY_NETCON pEvent
    );

#endif // !defined(__midl)


#ifdef __cplusplus
}
#endif

#endif // __SENSAPIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\inc\mtsadmin_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */
// Copyright (c) Microsoft Corporation. All rights reserved.
/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0158 */
/* at Thu Mar 11 18:35:18 1999
 */
/* Compiler settings for mtsadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICatalog = {0x6eb22870,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IComponentUtil = {0x6eb22873,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IPackageUtil = {0x6eb22874,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IRemoteComponentUtil = {0x6eb22875,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IRoleAssociationUtil = {0x6eb22876,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID LIBID_MTSAdmin = {0x6eb22880,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_Catalog = {0x6eb22881,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_CatalogObject = {0x6eb22882,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_CatalogCollection = {0x6eb22883,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_ComponentUtil = {0x6eb22884,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_PackageUtil = {0x6eb22885,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_RemoteComponentUtil = {0x6eb22886,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_RoleAssociationUtil = {0x6eb22887,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\uuid\qosguid.c ===
#define INITGUID
#include <guiddef.h>

#include <tcguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\uuid\trkadm_i.c ===
#define INITGUID
#include <guiddef.h>

DEFINE_GUID(IID_ITrkForceOwnership, 0xA2531F44,0xC67D,0x11D0,0x8C,0xB1,0x00,0xC0,0x4F,0xD9,0x0F,0x85);
DEFINE_GUID(IID_ITrkRestoreNotify,  0xD0056F6B,0xE2A0,0x11D0,0xB1,0xC2,0x00,0xC0,0x4F,0xB9,0x38,0x6D);
DEFINE_GUID(IID_ITrkRestoreParser,  0x755939E3,0xE381,0x11D0,0xB1,0xC5,0x00,0xC0,0x4F,0xB9,0x38,0x6D);
DEFINE_GUID(LIBID_ITRKADMNLib,      0xA2531F35,0xC67D,0x11D0,0x8C,0xB1,0x00,0xC0,0x4F,0xD9,0x0F,0x85);
DEFINE_GUID(CLSID_TrkForceOwnership,0xA2531F45,0xC67D,0x11D0,0x8C,0xB1,0x00,0xC0,0x4F,0xD9,0x0F,0x85);
DEFINE_GUID(CLSID_TrkRestoreNotify, 0xD0056F6C,0xE2A0,0x11D0,0xB1,0xC2,0x00,0xC0,0x4F,0xB9,0x38,0x6D);
DEFINE_GUID(CLSID_TrkRestoreParser, 0x755939E4,0xE381,0x11D0,0xB1,0xC5,0x00,0xC0,0x4F,0xB9,0x38,0x6D);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\uuid\trkcom_i.c ===
#define INITGUID
#include <guiddef.h>
DEFINE_GUID(CLSID_TrackFile, 0x8790c947,0xa30b,0x11d0,0x8c,0xab,0x00,0xc0,0x4f,0xd9,0x0f,0x85);
DEFINE_GUID(IID_ITrackFile,  0x8790c948,0xa30b,0x11d0,0x8c,0xab,0x00,0xc0,0x4f,0xd9,0x0f,0x85);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\uuid\sifmt_i.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       sifmt_i.c
//
//  Contents:   Defines Format IDs for the SummaryInformation and DocumentSummaryInformation
//              property sets.
//              This file is named so the this file will be include into UUID.LIB
//
//  History:    1/25/96   MikeHill   Created
//
//----------------------------------------------------------------------------




#define INITGUID

#include <guiddef.h>


// The FMTID of the "SummaryInformation" property set.

DEFINE_GUID( FMTID_SummaryInformation,
             0xf29f85e0, 0x4ff9, 0x1068,
             0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9 );

// The FMTID of the first Section of the "DocumentSummaryInformation" property set.

DEFINE_GUID( FMTID_DocSummaryInformation,
             0xd5cdd502, 0x2e9c, 0x101b,
             0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae );

// The FMTID of the section Section of the "DocumentSummaryInformation" property set.

DEFINE_GUID( FMTID_UserDefinedProperties,
             0xd5cdd505, 0x2e9c, 0x101b,
             0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae );


DEFINE_GUID( FMTID_PropertyBag,
             0x20001801, 0x5DE6, 0x11D1,
             0x8E, 0x38, 0x00, 0xC0, 0x4F, 0xB9, 0x38, 0x6D );

// The FMTID of the "DiscardableInformation" property set

DEFINE_GUID( FMTID_DiscardableInformation,
             0xd725ebb0, 0xc9b8, 0x11d1,
             0x89, 0xbc, 0x00, 0x00, 0xf8, 0x04, 0xb0, 0x57 );


// ImageSummaryInfo propset
DEFINE_GUID( FMTID_ImageSummaryInformation,
             0x6444048f, 0x4c8b, 0x11d1,
             0x8b, 0x70, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3 ) ;

// AudioSummaryInfo propset
DEFINE_GUID( FMTID_AudioSummaryInformation,
             0x64440490, 0x4c8b, 0x11d1,
             0x8b, 0x70, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3 ) ;

// VideoSummaryInfo propset
DEFINE_GUID( FMTID_VideoSummaryInformation,
	     0x64440491, 0x4c8b, 0x11d1,
             0x8b, 0x70, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3 ) ;

// MediaFileSummaryInfo propset - common properties for multimedia files
DEFINE_GUID( FMTID_MediaFileSummaryInformation,
             0x64440492, 0x4c8b, 0x11d1,
             0x8b, 0x70, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3 ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\uuid\makefile.inc ===
$(O)\callobj_i.c : ..\idlole\idl\$(O)\callobj_i.c
    copy $** $@

$(O)\ctxtcall_i.c : ..\idlole\idl\$(O)\ctxtcall_i.c
    copy $** $@

$(O)\iaccess_i.c : ..\idlole\idl\$(O)\iaccess_i.c
    copy $** $@

$(O)\immact_i.c : ..\idlole\idl\$(O)\immact_i.c
    copy $** $@

$(O)\oaidl_i.c : ..\idlole\idl\$(O)\oaidl_i.c
    copy $** $@

$(O)\objidl_i.c : ..\idlole\idl\$(O)\objidl_i.c
    copy $** $@

$(O)\ocidl_i.c : ..\idlole\idl\$(O)\ocidl_i.c
    copy $** $@

$(O)\oleext_i.c : ..\idlole\oleext\$(O)\oleext_i.c
    copy $** $@

$(O)\oleidl_i.c : ..\idlole\idl\$(O)\oleidl_i.c
    copy $** $@

$(O)\pbagex_i.c : ..\idlole\idl\$(O)\pbagex_i.c
    copy $** $@

$(O)\propidl_i.c : ..\idlole\idl\$(O)\propidl_i.c
    copy $** $@

$(O)\storext_i.c : ..\idlole\idl\$(O)\storext_i.c
    copy $** $@

$(O)\sysmgmt_i.c : ..\idlole\sysmgmt\$(O)\sysmgmt_i.c
    copy $** $@

$(O)\transact_i.c : ..\idlole\complus\$(O)\transact_i.c
    copy $** $@

$(O)\unknwn_i.c : ..\idlole\idl\$(O)\unknwn_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\uuid\vcguids.c ===
#define INITGUID
#include <guiddef.h>


typedef enum tagDBCOLKIND
{
    DBCOLKIND_GUID_NAME = 0,
    DBCOLKIND_GUID_NUMBER = 1,
    DBCOLKIND_NAME = 2
} DBCOLKIND;

typedef struct tagDBCOLUMNID
{
    GUID guid;
    DBCOLKIND dwKind;
    union
    {
        long lNumber;
        wchar_t* lpdbsz;
    };
} DBCOLUMNID;

#define DBCIDGUID {0xfe284700L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#define DBBMKGUID {0xf6304bb0L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}

#define DECLARE_COLUMNID    EXTERN_C const DBCOLUMNID DECLSPEC_SELECTANY

DECLARE_COLUMNID COLUMNID_INVALID         = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, -1};
DECLARE_COLUMNID COLUMN_AUTOINCREMENT     = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 0};
DECLARE_COLUMNID COLUMN_BASECOLUMNNAME    = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 1};
DECLARE_COLUMNID COLUMN_BASENAME          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 2};
DECLARE_COLUMNID COLUMN_BINARYCOMPARABLE  = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 3};
DECLARE_COLUMNID COLUMN_BINDTYPE          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 4};
DECLARE_COLUMNID COLUMN_CASESENSITIVE     = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 5};
DECLARE_COLUMNID COLUMN_COLLATINGORDER    = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 6};
DECLARE_COLUMNID COLUMN_COLUMNID          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 7};
DECLARE_COLUMNID COLUMN_CURSORCOLUMN      = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 8};
DECLARE_COLUMNID COLUMN_DATACOLUMN        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 9};
DECLARE_COLUMNID COLUMN_DEFAULTVALUE      = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 10};
DECLARE_COLUMNID COLUMN_ENTRYIDMAXLENGTH  = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 11};
DECLARE_COLUMNID COLUMN_FIXED             = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 12};
DECLARE_COLUMNID COLUMN_HASDEFAULT        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 13};
DECLARE_COLUMNID COLUMN_MAXLENGTH         = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 14};
DECLARE_COLUMNID COLUMN_MULTIVALUED       = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 15};
DECLARE_COLUMNID COLUMN_NAME              = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 16};
DECLARE_COLUMNID COLUMN_NULLABLE          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 17};
DECLARE_COLUMNID COLUMN_PHYSICALSORT      = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 18};
DECLARE_COLUMNID COLUMN_NUMBER            = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 19};
DECLARE_COLUMNID COLUMN_ROWENTRYID        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 20};
DECLARE_COLUMNID COLUMN_SCALE             = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 21};
DECLARE_COLUMNID COLUMN_SEARCHABLE        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 22};
DECLARE_COLUMNID COLUMN_TYPE              = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 23};
DECLARE_COLUMNID COLUMN_UNIQUE            = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 24};
DECLARE_COLUMNID COLUMN_UPDATABLE         = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 25};
DECLARE_COLUMNID COLUMN_VERSION           = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 26};
DECLARE_COLUMNID COLUMN_STATUS            = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 27};

DECLARE_COLUMNID COLUMN_BMKTEMPORARY      = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 0};
DECLARE_COLUMNID COLUMN_BMKTEMPORARYREL   = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 1};
DECLARE_COLUMNID COLUMN_BMKCURSOR         = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 2};
DECLARE_COLUMNID COLUMN_BMKCURSORREL      = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 3};
DECLARE_COLUMNID COLUMN_BMKSESSION        = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 4};
DECLARE_COLUMNID COLUMN_BMKSESSIONREL     = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 5};
DECLARE_COLUMNID COLUMN_BMKPERSIST        = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 6};
DECLARE_COLUMNID COLUMN_BMKPERSISTREL     = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 7};


#define DECLARE_BYTE    EXTERN_C const unsigned char DECLSPEC_SELECTANY

DECLARE_BYTE DBBMK_INVALID   = 0x0;
DECLARE_BYTE DBBMK_CURRENT   = 0x1;
DECLARE_BYTE DBBMK_BEGINNING = 0x2;
DECLARE_BYTE DBBMK_END       = 0x3;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\uuid\wdmguids.c ===
#define INITGUID
#include <guiddef.h>

#include <wdmguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\uuid\cguid_i.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       cguid_i.c
//
//  Contents:   Defines guids for interfaces not supported by MIDL.
//              This file is named so the this file will be include into UUID.LIB
//              As these interfaces are converted to IDL, the corresponding DEFINE_OLEGUID
//              macro calls for  the interfaces should be removed.
//
//  History:    8-06-93   terryru   Created
//
//----------------------------------------------------------------------------




#define INITGUID

#include <guiddef.h>


DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

/* Marshaler Component Category ID (same as IID_IMarshal) */
/* If you change this IID, change the string in IsMarshalerCLSID */

DEFINE_OLEGUID(CATID_MARSHALER,                 0x00000003, 0, 0);

/* RPC related interfaces */
DEFINE_OLEGUID(IID_IRpcChannel,                 0x00000004, 0, 0);
DEFINE_OLEGUID(IID_IRpcStub,                    0x00000005, 0, 0);
DEFINE_OLEGUID(IID_IStubManager,                0x00000006, 0, 0);
DEFINE_OLEGUID(IID_IRpcProxy,                   0x00000007, 0, 0);
DEFINE_OLEGUID(IID_IProxyManager,               0x00000008, 0, 0);
DEFINE_OLEGUID(IID_IPSFactory,                  0x00000009, 0, 0);


/* moniker related interfaces */

DEFINE_OLEGUID(IID_IInternalMoniker,            0x00000011, 0, 0);

DEFINE_OLEGUID(IID_IDfReserved1,                0x00000013, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved2,                0x00000014, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved3,                0x00000015, 0, 0);


/* CLSID of standard marshaler */
DEFINE_OLEGUID(CLSID_StdMarshal,                0x00000017, 0, 0);

DEFINE_OLEGUID(IID_IStub,                       0x00000026, 0, 0);
DEFINE_OLEGUID(IID_IProxy,                      0x00000027, 0, 0);

/* NOTE: LSB 0x2E through 0xff are reserved for future use */


//--------------------------------------------------------------------------
//
//  master definition of all public GUIDs specific to OLE2
//
//--------------------------------------------------------------------------


DEFINE_OLEGUID(IID_IEnumGeneric,                0x00000106, 0, 0);
DEFINE_OLEGUID(IID_IEnumHolder,                 0x00000107, 0, 0);
DEFINE_OLEGUID(IID_IEnumCallback,               0x00000108, 0, 0);





DEFINE_OLEGUID(IID_IOleManager,                 0x0000011f, 0, 0);
DEFINE_OLEGUID(IID_IOlePresObj,                 0x00000120, 0, 0);


DEFINE_OLEGUID(IID_IDebug,                      0x00000123, 0, 0);
DEFINE_OLEGUID(IID_IDebugStream,                0x00000124, 0, 0);


// clsids for proxy/stub objects
DEFINE_OLEGUID(CLSID_PSGenObject,               0x0000030c, 0, 0);
DEFINE_OLEGUID(CLSID_PSClientSite,              0x0000030d, 0, 0);
DEFINE_OLEGUID(CLSID_PSClassObject,             0x0000030e, 0, 0);
DEFINE_OLEGUID(CLSID_PSInPlaceActive,           0x0000030f, 0, 0);
DEFINE_OLEGUID(CLSID_PSInPlaceFrame,            0x00000310, 0, 0);
DEFINE_OLEGUID(CLSID_PSDragDrop,                0x00000311, 0, 0);
DEFINE_OLEGUID(CLSID_PSBindCtx,                 0x00000312, 0, 0);
DEFINE_OLEGUID(CLSID_PSEnumerators,             0x00000313, 0, 0);

DEFINE_OLEGUID(CLSID_StaticMetafile,            0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_StaticDib,                 0x00000316, 0, 0);


/* GUIDs defined in OLE's private range */
DEFINE_OLEGUID(CLSID_Picture_Metafile,          0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_Picture_EnhMetafile,       0x00000319, 0, 0);
DEFINE_OLEGUID(CLSID_Picture_Dib,               0x00000316, 0, 0);
DEFINE_OLEGUID(CLSID_DCOMAccessControl,         0x0000031D, 0, 0);
DEFINE_OLEGUID(CLSID_StdGlobalInterfaceTable,   0x00000323, 0, 0);


// Class ids for various implementations of ISynchronize
DEFINE_OLEGUID(CLSID_ManualResetEvent,             0x0000032c, 0, 0);
DEFINE_OLEGUID(CLSID_StdEvent,                     0x0000032b, 0, 0);
DEFINE_OLEGUID(CLSID_SynchronizeContainer,         0x0000032d, 0, 0);


// OBJREF Moniker                                  0x00000327
// Class id for string binding wrapper object
DEFINE_OLEGUID(CLSID_ComBinding,                0x00000328, 0, 0);
// Class id for obtaining an implementation of IAsyncManager
DEFINE_OLEGUID(CLSID_StdAsyncActManager,           0x00000329L, 0, 0);

/* clsid for free threaded marshaler */
DEFINE_OLEGUID(CLSID_InProcFreeMarshaler,       0x00000033a, 0, 0);
DEFINE_OLEGUID(CLSID_RemoteUnknownPSFactory,       0x00000340, 0, 0);


//
//  Define Richedit GUIDs
//
DEFINE_OLEGUID(IID_IRichEditOle,                0x00020D00, 0, 0);
DEFINE_OLEGUID(IID_IRichEditOleCallback,        0x00020D03, 0, 0);

//
//  Define Class Repository CLSIDs
//

DEFINE_OLEGUID(CLSID_AllClasses,                0x00000330, 0, 0);
DEFINE_OLEGUID(CLSID_LocalMachineClasses,       0x00000331, 0, 0);
DEFINE_OLEGUID(CLSID_CurrentUserClasses,        0x00000332, 0, 0);


// for address control object
DEFINE_OLEGUID(CLSID_AddrControl,                 0x00000348, 0, 0);

//
// define ole controls clsids
//
//

DEFINE_GUID(IID_IPropertyFrame,
        0xB196B28A,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);

//  Class IDs for property sheet implementations
//

DEFINE_GUID(CLSID_CFontPropPage,
        0x0be35200,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);
DEFINE_GUID(CLSID_CColorPropPage,
        0x0be35201,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);
DEFINE_GUID(CLSID_CPicturePropPage,
        0x0be35202,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);

//
// class IDs for msprop32's property pages.
//

#include <msstkppg.h>

//
//  Class IDs for persistent property set formats
//

DEFINE_GUID(CLSID_PersistPropset,
        0xfb8f0821,0x0164,0x101b,0x84,0xed,0x08,0x00,0x2b,0x2e,0xc7,0x13);
DEFINE_GUID(CLSID_ConvertVBX,
        0xfb8f0822,0x0164,0x101b,0x84,0xed,0x08,0x00,0x2b,0x2e,0xc7,0x13);

//
//  Class ID for standard implementations of IFont and IPicture

DEFINE_GUID(CLSID_StdFont,
        0x0be35203,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);
DEFINE_GUID(CLSID_StdPicture,
        0x0be35204,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);


//
//  GUIDs for standard types
//

DEFINE_GUID(GUID_HIMETRIC,
        0x66504300,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_COLOR,
        0x66504301,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_XPOSPIXEL,
        0x66504302,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_YPOSPIXEL,
        0x66504303,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_XSIZEPIXEL,
        0x66504304,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_YSIZEPIXEL,
        0x66504305,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_XPOS,
        0x66504306,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_YPOS,
        0x66504307,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_XSIZE,
        0x66504308,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_YSIZE,
        0x66504309,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_TRISTATE,
        0x6650430A,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_OPTIONVALUEEXCLUSIVE,
        0x6650430B,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_CHECKVALUEEXCLUSIVE,
        0x6650430C,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTNAME,
        0x6650430D,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTSIZE,
        0x6650430E,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTBOLD,
        0x6650430F,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTITALIC,
        0x66504310,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTUNDERSCORE,
        0x66504311,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTSTRIKETHROUGH,
        0x66504312,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_HANDLE,
        0x66504313,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);

//
//  GUIDs for OLE Automation
//
DEFINE_OLEGUID(IID_StdOle,  0x00020430L, 0, 0);

// Ole Control Data Binding guids

DEFINE_GUID(IID_ICursor,
    0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_ICursorMove,
    0xacff0690, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_ICursorScroll,
    0xbb87e420, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_ICursorUpdateARow,
    0xd14216a0, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_INotifyDBEvents,
    0xdb526cc0, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_ICursorFind,
    0xe01d7850, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_IEntryID,
    0xe4d19810, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(_GUID_NAMEONLY,
    0xe8bf1170, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(_DBBMKGUID,
    0xf6304bb0, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(_DBCIDGUID,
    0xfe284700, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

// OLE Data binding

DEFINE_GUID(IID_IBoundObject,
    0x9BFBBC00, 0xEFF1, 0x101A, 0x84, 0xED, 0x00, 0xAA, 0x00, 0x34, 0x1D, 0x07);

DEFINE_GUID(IID_IBoundObjectSite,
    0x9BFBBC01, 0xEFF1, 0x101A, 0x84, 0xED, 0x00, 0xAA, 0x00, 0x34, 0x1D, 0x07);

// Global Comcat clsid (with Class Store)
DEFINE_OLEGUID(CLSID_GblComponentCategoriesMgr, 0x0002E006, 0, 0);


//
// A GUID for the thumbnail generator
//
DEFINE_GUID(CLSID_ThumbnailFCNHandler,
    0xcefc65d8, 0x66d8, 0x11d1, 0x8d, 0x8c, 0x00, 0x00, 0xf8, 0x04, 0xb0, 0x57);

DEFINE_GUID(CLSID_ThumbnailUpdater,
    0xa3c63918, 0x889d, 0x11d1, 0x83, 0xe9, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0xd4);

#include <devguid.h>

#define _WINIOCTL_
#include <winioctl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\client\nsi.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    nsi.h

Abstract:

    This module contains utility functions used by the NSI client wrappers.

Author:

    Steven Zeck (stevez) 03/27/92

--*/

#ifndef __NSI_H
#define __NSI_H

#ifdef __cplusplus
extern "C" {
#endif

#define RPC_REG_ROOT HKEY_LOCAL_MACHINE
#define REG_NSI "Software\\Microsoft\\Rpc\\NameService"

#if !defined(NSI_ASCII)
#define UNICODE
typedef unsigned short RT_CHAR;
#define CONST_CHAR const char
#else
typedef unsigned char RT_CHAR;
#define CONST_CHAR  char
#endif

#if defined(NTENV) 
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <rpc.h>
#include <rpcnsi.h>
#include <nsisvr.h>
#include <nsiclt.h>
#include <nsimgm.h>

#ifdef __cplusplus
} // extern "C"
#endif

#ifdef __cplusplus
#include <nsiutil.hxx>
#endif 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\client\nsimgmt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    nsimgmt.cxx

Abstract:

    This is the module implements the client side support for management
    APIs.

Author:

    Steven Zeck (stevez) 04/23/92

--*/

#include <nsi.h>
#include <string.h>

RPC_STATUS RPC_ENTRY
I_NsBindingFoundBogus(RPC_BINDING_HANDLE *BindingHandle, DWORD BindId);
RPC_STATUS RPC_ENTRY
I_NsClientBindSearch(RPC_BINDING_HANDLE *NsiClntBinding, DWORD *BindId);
void RPC_ENTRY
I_NsClientBindDone(RPC_BINDING_HANDLE *NsiClntBinding, DWORD BindId);

RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteW(
    IN unsigned long GroupNameSyntax,
    IN unsigned short __RPC_FAR * GroupName
    )
/*++

Routine Description:

    Remove a group entry and all its member items.

Arguments:

    GroupNameSyntax - This value describes the type/format of the GroupName.

    GroupName -  Name that will be deleted.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_group_delete()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! GroupNameSyntax)
        GroupNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_group_delete(NsiClntBinding, GroupNameSyntax, GroupName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddW(
    IN unsigned long GroupNameSyntax,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax,
    IN unsigned short __RPC_FAR * MemberName
    )
/*++

Routine Description:

    Add a new member to a group entry.  Create the group entry on demand.

Arguments:

    GroupNameSyntax - This value describes the type/format of the GroupName.

    GroupName -  Name of the group that the member will be added to.

    MemberNameSyntax - This value describes the type/format of the MemberName.

    MemberName -  Name of member in the group that will be added.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_group_mbr_add()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! GroupNameSyntax)
        GroupNameSyntax = DefaultSyntax;

    if (! MemberNameSyntax)
        MemberNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_group_mbr_add(NsiClntBinding, GroupNameSyntax, GroupName,
                              MemberNameSyntax, MemberName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }
    
    I_NsClientBindDone(&NsiClntBinding, BindId);
    
    return(status);
}



RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveW(
    IN unsigned long GroupNameSyntax,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax,
    IN unsigned short __RPC_FAR * MemberName
    )
/*++

Routine Description:


Arguments:

    GroupNameSyntax - This value describes the type/format of the GroupName.

    GroupName -  Name of the group that the member will be deleted from.

    MemberNameSyntax - This value describes the type/format of the MemberName.

    MemberName -  Name of member in the group that will be deleted

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_group_mbr_remove()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! GroupNameSyntax)
        GroupNameSyntax = DefaultSyntax;

    if (! MemberNameSyntax)
        MemberNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {

        RpcTryExcept
        {
            nsi_group_mbr_remove(NsiClntBinding, GroupNameSyntax, GroupName,
                MemberNameSyntax, MemberName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept

        status = NsiMapStatus(NsiStatus);

        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return status;
}


RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginW(
    IN unsigned long GroupNameSyntax,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax,
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    Begin a inquiry to enumerate all the members in a group entry.

Arguments:

    GroupNameSyntax - This value describes the type/format of the GroupName.

    GroupName -  Name of the group that the member will be deleted from.

    MemberNameSyntax - This controls what format the name is returned in.

    InquiryContext - context handle for RpcNsGroupMbrInqNextW

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_group_mbr_inq_begin()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    *InquiryContext = 0;

    if (! GroupNameSyntax)
        GroupNameSyntax = DefaultSyntax;

    if (! MemberNameSyntax)
        MemberNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_group_mbr_inq_begin(NsiClntBinding, GroupNameSyntax, GroupName,
                MemberNameSyntax, InquiryContext, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }
    
    I_NsClientBindDone(&NsiClntBinding, BindId);
        
    return status;
}


RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextW(
    OUT RPC_NS_HANDLE InquiryContext,
    OUT unsigned short __RPC_FAR * __RPC_FAR * MemberName
    )
/*++

Routine Description:

    Get the next member in a group entry.

Arguments:

    InquiryContext - context handle from RpcNsGroupMbrInqBeginW

    MemberName - pointer to return results.

Returns:

    nsi_group_mbr_inq_next()

--*/

{
    UNSIGNED16 NsiStatus;

    *MemberName = 0;

    RpcTryExcept
        {
        nsi_group_mbr_inq_next(InquiryContext, MemberName, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept


    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqDone(
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    Finish enumerating the members of a group.

Arguments:

    InquiryContext - context handle from RpcNsGroupMbrInqBeginW

Returns:

    nsi_group_mbr_inq_done()

--*/

{
    UNSIGNED16 NsiStatus;

    RpcTryExcept
        {
        nsi_group_mbr_inq_done(InquiryContext, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName,
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    Begin a inquiry to enumerate all the UUID objects in a server entry.

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name of the server entry to inquiry.

    InquiryContext - context handle for RpcNsGroupMbrInqNextW

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_entry_object_inq_begin()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    *InquiryContext = 0;
        
    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;
        
    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_entry_object_inq_begin(NsiClntBinding, EntryNameSyntax, EntryName,
                InquiryContext, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;
        
        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return status;
}


RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqNext(
    IN RPC_NS_HANDLE InquiryContext,
    OUT UUID __RPC_FAR * ObjUuid
    )
/*++

Routine Description:

    Gets the next object UUID in the server entry.

Arguments:

    InquiryContext - context handle from RpcNsEntryObjectInqBeginW

    ObjUuid - pointer to memory to return results

Returns:

    nsi_entry_object_inq_next()

--*/

{
    UNSIGNED16 NsiStatus;

    RpcTryExcept
        {
        nsi_entry_object_inq_next(InquiryContext, (NSI_UUID_T *) ObjUuid, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqDone(
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    Finish enumerating the objects of a server entry.

Arguments:

    InquiryContext - context handle from RpcNsEntryObjectInqBeginW

Returns:

    nsi_entry_object_inq_done()

--*/

{
    UNSIGNED16 NsiStatus;

    RpcTryExcept
        {
        nsi_entry_object_inq_done(InquiryContext, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    return(NsiMapStatus(NsiStatus));
}



RPC_STATUS RPC_ENTRY
RpcNsMgmtInqExpAge(
    OUT unsigned long *ExpirationAge
    )
/*++

Routine Description:

    Get the global time that a cached entry remains valide.

Arguments:

    ExpirationAge - place to expiration age in seconds

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_inq_exp_age()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_mgmt_inq_exp_age(NsiClntBinding, ExpirationAge, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
    
        status = NsiMapStatus(NsiStatus);

        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return status;
}



RPC_STATUS RPC_ENTRY
RpcNsMgmtSetExpAge(
    IN unsigned long ExpirationAge
    )
/*++

Routine Description:

    set the global time that a cached entry remains valide.

Arguments:

    ExpirationAge - new expiration age in seconds

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_set_exp_age()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        
        RpcTryExcept
        {
            nsi_mgmt_inq_set_age(NsiClntBinding, ExpirationAge, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept

        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return status;
}


RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ExpandedName
    )
/*++

Routine Description:


Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that will be expanded.

    ExpandedName - fully quailified global name.

Returns:


--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_entry_expand_name(NsiClntBinding, EntryNameSyntax, EntryName, ExpandedName,
                &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
             
        status = NsiMapStatus(NsiStatus);

        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}



RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName,
    IN RPC_IF_ID * IfId, OPTIONAL
    IN unsigned long VersOption, OPTIONAL
    IN UUID_VECTOR * ObjectUuidVec OPTIONAL
    )
/*++

Routine Description:

    Remove interfaces and or objects from an server entry.

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  The server name that will be unexported.

    IfId - The interface to unexport, NIL means objects only.

    VersOption -  constrains which interfaces to remove

    ObjectUuidVec - list of objects to remove in combination with interface.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_binding_unexport()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_mgmt_binding_unexport(NsiClntBinding, EntryNameSyntax, EntryName,
                (NSI_IF_ID_P_T) IfId, VersOption,
                (NSI_UUID_VECTOR_T *)ObjectUuidVec, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }
    
    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}



RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName
    )
/*++

Routine Description:

    Create an entry name that is empty.  It has no type and becomes a
    type according to the first add API aplied (profile, groupd, server).

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name of the new entry.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_entry_Create()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_mgmt_entry_create(NsiClntBinding, EntryNameSyntax, EntryName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;
        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}



RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName
    )
/*++

Routine Description:

    Remove an entry name (server, group or profile).

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that this export will be stored in.  This is just a
       token that is passed on the the Name Server.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_entry_delete()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        
        RpcTryExcept
        {
            nsi_mgmt_entry_delete(NsiClntBinding, EntryNameSyntax, EntryName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;
        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}



RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName,
    OUT RPC_IF_ID_VECTOR ** IfIdVec
    )
/*++

Routine Description:

    Get all the interface identifiers in a server entry.

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that this export will be stored in.  This is just a
       token that is passed on the the Name Server.

    IfIdVec - pointer to return results in

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_entry_inq_ifids()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;


    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        *IfIdVec = 0;
        
        RpcTryExcept
        {
            nsi_mgmt_entry_inq_if_ids(NsiClntBinding, EntryNameSyntax, EntryName,
                (NSI_IF_ID_VECTOR_T **)  IfIdVec, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            
        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);

    }
    
    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteW(
    IN unsigned long ProfileNameSyntax,
    IN unsigned short __RPC_FAR * ProfileName
    )

/*++

Routine Description:

    Remove a profile entry and all its member items.

Arguments:

    profileNameSyntax - This value describes the type/format of the profile ame.

    profileName -  Name that will be deleted.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_profile_delete()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! ProfileNameSyntax)
        ProfileNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_profile_delete(NsiClntBinding, ProfileNameSyntax, ProfileName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept

        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddW(
    IN unsigned long ProfileNameSyntax,
    IN unsigned short __RPC_FAR * ProfileName,
    IN RPC_IF_ID * IfId,
    IN unsigned long MemberNameSyntax,
    IN unsigned short __RPC_FAR * MemberName,
    IN unsigned long Priority,
    IN unsigned short __RPC_FAR * Annotation
    )
/*++

Routine Description:

    Add elements to the profile entry

Arguments:

    ProfileNameSyntax - This value describes the type/format of the ProfileName.

    ProfileName -  The server name that will be unexported.

    IfId - The interface to unexport, NIL means objects only.

    MemberNameSyntax - This value describes the type/format of the MemberName.

    MemberName -  The server name that will be unexported.

    Priority - Place to insert member in profile

    Annotation - comment for member

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_profile_elt_add()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! ProfileNameSyntax)
        ProfileNameSyntax = DefaultSyntax;

    if (! MemberNameSyntax)
        MemberNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_profile_elt_add(NsiClntBinding, ProfileNameSyntax, ProfileName,
                (NSI_IF_ID_P_T) IfId,
                MemberNameSyntax, MemberName, Priority, Annotation, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;       

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveW(
    IN unsigned long ProfileNameSyntax,
    IN unsigned short __RPC_FAR * ProfileName,
    IN RPC_IF_ID * IfId,
    IN unsigned long MemberNameSyntax,
    IN unsigned short __RPC_FAR * MemberName
    )

/*++

Routine Description:

    Remove an element from a profile entry.

Arguments:

    ProfileNameSyntax - This value describes the type/format of the ProfileName.

    ProfileName -  The server name that will be unexported.

    IfId - The interface to unexport, NIL means objects only.

    MemberNameSyntax - This value describes the type/format of the MemberName.

    MemberName -  The server name that will be unexported.

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_mgmt_binding_unexport()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (! ProfileNameSyntax)
        ProfileNameSyntax = DefaultSyntax;

    if (! MemberNameSyntax)
        MemberNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_profile_elt_remove(NsiClntBinding, ProfileNameSyntax, ProfileName,
                    (NSI_IF_ID_P_T) IfId, MemberNameSyntax, MemberName, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept

        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginW(
    IN unsigned long ProfileNameSyntax,
    IN unsigned short __RPC_FAR * ProfileName,
    IN unsigned long InquiryType,
    IN RPC_IF_ID * IfId,
    IN unsigned long VersOption,
    IN unsigned long MemberNameSyntax,
    IN unsigned short __RPC_FAR * MemberName,
    OUT RPC_NS_HANDLE *InquiryContext
    )

/*++

Routine Description:

    Remove an element from a profile entry.

Arguments:

    ProfileNameSyntax - This value describes the type/format of the ProfileName.

    ProfileName -  The server name that will be unexported.

    InquiryType - Type of inquiry, one of RpcCProfile* constants

    IfId - The interface to unexport, NIL means objects only.

    VersOption - Version options, one of RpcCVers* constants

    MemberNameSyntax - This value describes the type/format of the MemberName.

    MemberName -  The server name that will be unexported.

    InquiryContext - context handle for use wiht RpcNsProfileEltInqNextW

Returns:

    NSI_S_NAME_SERVICE_UNAVAILABLE, nsi_profile_elt_inq_begin()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (InquiryContext)
        *InquiryContext = NULL;

    if (! ProfileNameSyntax)
        ProfileNameSyntax = DefaultSyntax;

    if (! MemberNameSyntax)
        MemberNameSyntax = DefaultSyntax;

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK) 
    {
        RpcTryExcept
        {
            nsi_profile_elt_inq_begin(NsiClntBinding, ProfileNameSyntax, ProfileName, InquiryType,
                (NSI_IF_ID_P_T) IfId, VersOption,
                MemberNameSyntax, MemberName, InquiryContext, &NsiStatus);
        }
        RpcExcept(1)
        {
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept

        status = NsiMapStatus(NsiStatus);
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;

        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }

    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextW(
    IN RPC_NS_HANDLE InquiryContext,
    OUT RPC_IF_ID * IfId,
    OUT unsigned short __RPC_FAR * __RPC_FAR * MemberName,
    OUT unsigned long __RPC_FAR * Priority,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation
    )
/*++

Routine Description:

    Gets the next element in the profile entry.

Arguments:

    InquiryContext - context handle from RpcNsEntryObjectInqBeginW

    MemberName - place to put profile element name

    IfId - place to return interface

    Priority - place to put profile element priority

    Annotation - place to put profile element comment

Returns:

    nsi_profile_elt_inq_next()

--*/
{
    unsigned short *  pAnnotation;
    unsigned short *  pMemberName;
    unsigned short ** ppAnnotation;
    unsigned short ** ppMemberName;
    
    UNSIGNED16 NsiStatus;

    if (Annotation)
        ppAnnotation = Annotation;
    else
        ppAnnotation = &pAnnotation;

    *ppAnnotation = NULL;

    if (MemberName)
        ppMemberName = MemberName;
    else
        ppMemberName = &pMemberName;

    *ppMemberName = NULL;
    
    RpcTryExcept
        {
        nsi_profile_elt_inq_next(InquiryContext, (NSI_IF_ID_P_T) IfId,
            ppMemberName, Priority, ppAnnotation, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    if (!Annotation)
        RpcStringFreeW(ppAnnotation);

    if (!MemberName)
        RpcStringFreeW(ppMemberName);

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqDone(
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    Finish enumerating the objects of a profile entry.

Arguments:

    InquiryContext - context handle from RpcNsProfileEltInqBeginW

Returns:

    nsi_profile_elt_inq_done()

--*/

{
    UNSIGNED16 NsiStatus;

    RpcTryExcept
        {
        nsi_profile_elt_inq_done(InquiryContext, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    return(NsiMapStatus(NsiStatus));
}



// The following are ASCII wrappers to the UNICODE API's

RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteA(
    IN unsigned long GroupNameSyntax,
    IN unsigned char __RPC_FAR * GroupName
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING GroupNameW(GroupName);

    if (GroupNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsGroupDeleteW(GroupNameSyntax, &GroupNameW));
}


RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddA(
    IN unsigned long GroupNameSyntax,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax,
    IN unsigned char __RPC_FAR * MemberName
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING GroupNameW(GroupName);
    WIDE_STRING MemberNameW(MemberName);

    if (GroupNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    if (MemberNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsGroupMbrAddW(GroupNameSyntax, &GroupNameW,
   	MemberNameSyntax, &MemberNameW));
}


RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveA(
    IN unsigned long GroupNameSyntax,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax,
    IN unsigned char __RPC_FAR * MemberName
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING GroupNameW(GroupName);
    WIDE_STRING MemberNameW(MemberName);

    if (GroupNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    if (MemberNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsGroupMbrRemoveW(GroupNameSyntax, &GroupNameW,
   	MemberNameSyntax, &MemberNameW));
}



RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginA(
    IN unsigned long GroupNameSyntax,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax,
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING GroupNameW(GroupName);

    if (GroupNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsGroupMbrInqBeginW(GroupNameSyntax, &GroupNameW,
	MemberNameSyntax, InquiryContext));
}

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextA(
    OUT RPC_NS_HANDLE InquiryContext,
    OUT unsigned char __RPC_FAR * __RPC_FAR * MemberName
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    RPC_STATUS Status;

    Status = RpcNsGroupMbrInqNextW(InquiryContext,
        (unsigned short __RPC_FAR * __RPC_FAR *) MemberName);

    if (Status)
        return(Status);

    return(UnicodeToAscii((unsigned short *) *MemberName));
}


RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName,
    OUT RPC_NS_HANDLE *InquiryContext
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsEntryObjectInqBeginW(EntryNameSyntax, &EntryNameW,
        InquiryContext));
}

RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ExpandedName
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    RPC_STATUS Status;
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    Status = RpcNsEntryExpandNameW(EntryNameSyntax, &EntryNameW,
        (unsigned short __RPC_FAR * __RPC_FAR *) ExpandedName);

    if (Status)
        return(Status);

    return(UnicodeToAscii((unsigned short *) *ExpandedName));
}


RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName,
    IN RPC_IF_ID * IfId,
    IN unsigned long VersOption,
    IN UUID_VECTOR * ObjectUuidVec OPTIONAL
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsMgmtBindingUnexportW(EntryNameSyntax, &EntryNameW,
        IfId, VersOption, ObjectUuidVec));
}

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsMgmtEntryCreateW(EntryNameSyntax, &EntryNameW));
}

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsMgmtEntryDeleteW(EntryNameSyntax, &EntryNameW));
}

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName,
    OUT RPC_IF_ID_VECTOR ** IfIdVec
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsMgmtEntryInqIfIdsW(EntryNameSyntax, &EntryNameW,
	IfIdVec));
}


RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteA(
    IN unsigned long ProfileNameSyntax,
    IN unsigned char __RPC_FAR * ProfileName
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING ProfileNameW(ProfileName);

    if (ProfileNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsProfileDeleteW(ProfileNameSyntax, &ProfileNameW));
}

RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddA(
    IN unsigned long ProfileNameSyntax,
    IN unsigned char __RPC_FAR * ProfileName,
    IN RPC_IF_ID * IfId,
    IN unsigned long MemberNameSyntax,
    IN unsigned char __RPC_FAR * MemberName,
    IN unsigned long Priority,
    IN unsigned char __RPC_FAR * Annotation
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING ProfileNameW(ProfileName);
    WIDE_STRING MemberNameW(MemberName);
    WIDE_STRING AnnotationW(Annotation);

    if (ProfileNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    if (MemberNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    if (AnnotationW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsProfileEltAddW(ProfileNameSyntax, &ProfileNameW,
	IfId, MemberNameSyntax, &MemberNameW, Priority, &AnnotationW));
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveA(
    IN unsigned long ProfileNameSyntax,
    IN unsigned char __RPC_FAR * ProfileName,
    IN RPC_IF_ID * IfId,
    IN unsigned long MemberNameSyntax,
    IN unsigned char __RPC_FAR * MemberName
    )
/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING ProfileNameW(ProfileName);
    WIDE_STRING MemberNameW(MemberName);

    if (ProfileNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    if (MemberNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsProfileEltRemoveW(ProfileNameSyntax, &ProfileNameW,
	IfId, MemberNameSyntax, &MemberNameW));
}


RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginA(
    IN unsigned long ProfileNameSyntax,
    IN unsigned char __RPC_FAR * ProfileName,
    IN unsigned long InquiryType,
    IN RPC_IF_ID * IfId,
    IN unsigned long VersOption,
    IN unsigned long MemberNameSyntax,
    IN unsigned char __RPC_FAR * MemberName,
    OUT RPC_NS_HANDLE *InquiryContext
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING ProfileNameW(ProfileName);
    WIDE_STRING MemberNameW(MemberName);

    if (ProfileNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    if (MemberNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsProfileEltInqBeginW(ProfileNameSyntax, &ProfileNameW,
	InquiryType, IfId, VersOption, MemberNameSyntax, &MemberNameW,
	InquiryContext));
}

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextA(
    IN RPC_NS_HANDLE InquiryContext,
    OUT RPC_IF_ID * IfId,
    OUT unsigned char __RPC_FAR * __RPC_FAR * MemberName,
    OUT unsigned long __RPC_FAR * Priority,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    RPC_STATUS Status;

    Status = RpcNsProfileEltInqNextW(InquiryContext, IfId,
        (unsigned short __RPC_FAR * __RPC_FAR *) MemberName, Priority,
        (unsigned short __RPC_FAR * __RPC_FAR *) Annotation);

    if (Status)
        return(Status);

    if (Status = UnicodeToAscii((unsigned short *) *MemberName))
        return(Status);

    if (Annotation)
        return(UnicodeToAscii((unsigned short *) *Annotation));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\client\mem.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mem.c
//
//--------------------------------------------------------------------------

/*++

Module Name:

    mem.c

Abstract:

    Implements midl_user_allocate and midl_user_free.

Author:

    Jeff Roberts (jroberts)  15-May-1996

Revision History:

     15-May-1996     jroberts

        Created this module.

--*/

#include <rpc.h>


void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    unsigned cb
    )
/*++

Routine Description:

    Call the C memory allocation for MIDL.

--*/
{
    return I_RpcAllocate(cb);
}

void __RPC_API
MIDL_user_free(
    void __RPC_FAR * p
    )
{
    I_RpcFree(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\client\nsiclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    nsiclnt.cxx

Abstract:

    This is the client side NSI service support layer.  These are wrappers
    which call the name service provider.

Author:

    Steven Zeck (stevez) 03/04/92

--*/

#include <nsi.h>

#include <string.h>
#include <time.h>


// This structure is used in binding handle select processing.

typedef struct
{
    unsigned long Count;
    int IndexMatch[1];

} MATCH_VECTOR;

RPC_STATUS RPC_ENTRY 
I_NsBindingFoundBogus(RPC_BINDING_HANDLE *BindingHandle, DWORD BindId);
RPC_STATUS RPC_ENTRY
I_NsClientBindSearch(RPC_BINDING_HANDLE *NsiClntBinding, DWORD *BindId);
void RPC_ENTRY
I_NsClientBindDone(RPC_BINDING_HANDLE *NsiClntBinding, DWORD BindId);



RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle,
    IN UUID __RPC_FAR * Object OPTIONAL,
    IN unsigned long BindingMaxCount,
    OUT RPC_NS_HANDLE *LookupContext
    )

/*++

Routine Description:

    Query the named server for the requested binding handles.  This will
    request a query from name server to be performed and store the results
    to be retrieved with RpcNsBindingLookupNext().

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that this export will be stored in.  This is just a
       token that is passed on the the Name Server.

    RpcIfHandle - The interface that is being exported.

    Object - the object UUID that you are looking for (or in combination
        with RpcIfHandle).

    BindingMaxCount - The maxium size of the binding vector to be returned
        to the RpcNsBindingLookupNext function.

    LookupContext - handle to be used to pass to RpcNsBindingImportNext,
        This is really allocated by RpcNsLookupBinding

    SearchOptions - used by the auto handle binding routines and Micosoft
        name server.

Returns:

    RPC_S_OK, RPC_S_NO_MORE_BINDINGS

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    NSI_INTERFACE_ID_T NilIfOnWire, __RPC_FAR *IfPtr;
    RPC_BINDING_HANDLE NsiClntBinding = NULL;
    DWORD              BindId = 0;

    if (RpcIfHandle == NULL)
      {
         IfPtr = &NilIfOnWire;
         memset(IfPtr, 0, sizeof(NSI_INTERFACE_ID_T));
      }
    else
      {
         IfPtr = (NSI_INTERFACE_ID_T __RPC_FAR *)
                    &((PRPC_CLIENT_INTERFACE)RpcIfHandle)->InterfaceId;
      }

    while ((status = I_NsClientBindSearch(&NsiClntBinding, &BindId)) == RPC_S_OK)
    {
        
        // Provide the default entry name if there is none.
        
        if ((! EntryName || *EntryName == 0) && DefaultName)
        {
            EntryName = &(*DefaultName);
            EntryNameSyntax = DefaultSyntax;
        }
        else if (! EntryNameSyntax)
            EntryNameSyntax = DefaultSyntax;
        
        RpcTryExcept
        {
            nsi_binding_lookup_begin(NsiClntBinding, EntryNameSyntax, EntryName,
                IfPtr,
                (NSI_UUID_P_T) Object, BindingMaxCount, 0,
                LookupContext, &NsiStatus);
            
        }
        RpcExcept(1)
        {
            *LookupContext = 0;
            NsiStatus = MapException(RpcExceptionCode());
        }
        RpcEndExcept
            status = NsiMapStatus(NsiStatus);
        
        if (NsiStatus != NSI_S_NAME_SERVICE_UNAVAILABLE)
            break;
        
        I_NsBindingFoundBogus(&NsiClntBinding, BindId);
    }
    
    I_NsClientBindDone(&NsiClntBinding, BindId);

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsBindingLookupNext(
    IN  RPC_NS_HANDLE LookupContext,
    OUT RPC_BINDING_VECTOR **BindingVector
    )

/*++

Routine Description:

    Retrieve the next group of bindings queryed from RpcNsBindingLookupBegin().
Arguments:

    LookupContext - handle to allocated by RpcNsBindingLookupBegin()

    BindingVector - returns a pointer to a  binding vector.

Returns:

    RPC_S_OK, RPC_S_NO_MORE_BINDINGS, RPC_S_OUT_OF_MEMORY,
    nsi_binding_lookup_next()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    NSI_BINDING_VECTOR_T * NsiBindingVector;
    RPC_BINDING_HANDLE Handle;
    unsigned int HandleValide, Index;

     NsiBindingVector = 0;
    *BindingVector = 0;

    RpcTryExcept
        {
        nsi_binding_lookup_next((NSI_NS_HANDLE_T *) LookupContext,
            &NsiBindingVector, &NsiStatus);

        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    if (NsiStatus)
        return(NsiMapStatus(NsiStatus));

    // Convert the string bindings to binding handles.  This done by
    // replacing the StringBinding with RPC_BINDING_HANDLE to a
    // RPC_BINDING_VECTOR allocated by the runtime.

    *BindingVector = (RPC_BINDING_VECTOR *) I_RpcAllocate((unsigned int) (
        sizeof(RPC_BINDING_VECTOR) - sizeof(RPC_BINDING_HANDLE) +
        sizeof(RPC_BINDING_HANDLE) * NsiBindingVector->count));

    if (! *BindingVector)
        return(RPC_S_OUT_OF_MEMORY);

    for (Index = 0, HandleValide = 0;
        Index < NsiBindingVector->count; Index++)
        {
        Handle = 0;

        if (!UnicodeToRtString(NsiBindingVector->binding[Index].string))
            status = RpcBindingFromStringBinding(
                    (RT_CHAR *)NsiBindingVector->binding[Index].string, &Handle);


        if (!status && NsiBindingVector->binding[Index].entry_name)
            {
            if (!UnicodeToRtString( NsiBindingVector->binding[Index].entry_name))
            {
#ifdef NTENV
                status = I_RpcNsBindingSetEntryNameW(Handle,
#else
                status = I_RpcNsBindingSetEntryName(Handle,
#endif
                    NsiBindingVector->binding[Index].entry_name_syntax,
                    (RT_CHAR *)NsiBindingVector->binding[Index].entry_name);
                }
            }

        if (NsiBindingVector->binding[Index].entry_name)
             I_RpcFree(NsiBindingVector->binding[Index].entry_name);

        I_RpcFree(NsiBindingVector->binding[Index].string);

        // only copy the handle to the output if the Binding was OK.

        if (! status)
            (*BindingVector)->BindingH[HandleValide++] = Handle;
        }

    (*BindingVector)->Count = HandleValide;

    I_RpcFree(NsiBindingVector);

    return((HandleValide > 0)? RPC_S_OK: RPC_S_NO_MORE_BINDINGS);
}



RPC_STATUS RPC_ENTRY
RpcNsBindingLookupDone(
    OUT RPC_NS_HANDLE *LookupContext
    )

/*++

Routine Description:

    Close the context opened with RpcNsBindingLookupBegin();

Arguments:

    LookupContext - context handle to close

Returns:

    nsi_binding_lookup_done()

--*/

{
    UNSIGNED16 NsiStatus = NSI_S_OK;

    RpcTryExcept
        {
        nsi_binding_lookup_done((NSI_NS_HANDLE_T *) LookupContext, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

//    RpcBindingFree(&NsiClntBinding);
    *LookupContext = 0;

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle,
    IN UUID __RPC_FAR * Object OPTIONAL,
    OUT RPC_NS_HANDLE *ImportContextOut
    )

/*++

Routine Description:

    Query the named server for the requested binding handles.  This function
    is implemented in terms of RpcNsLookupBinding.

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that this export will be stored in.  This is just a
       token that is passed on the the Name Server.

    RpcIfHandle - The interface that is being exported.

    Object - the object UUID that you are looking for (or in combination
        with RpcIfHandle).

    ImportContext - handle to be used to pass to RpcNsBindingImportNext,
        This is really allocated by RpcNsLookupBinding

    SearchOptions - used by the auto handle binding routines and Micosoft
        name server.

Returns:


    RpcNsBindingLookupBegin(), RPC_S_OUT_OF_MEMORY, RPS_S_OK
--*/

{
    RPC_STATUS status;
    RPC_NS_HANDLE LookupContext;
    PRPC_IMPORT_CONTEXT_P ImportContext;
    const int BindingVectorSize = 10;

    *ImportContextOut = 0;

    status = RpcNsBindingLookupBeginW(EntryNameSyntax, EntryName,
        RpcIfHandle, Object, BindingVectorSize, &LookupContext);

    if (status)
        return(status);

    // Allocate an import context which contains a lookup context,
    // a StringBinding vector and an index to the current StringBinding
    // in the vector.

    if (!(ImportContext = (PRPC_IMPORT_CONTEXT_P)
            I_RpcAllocate(sizeof(RPC_IMPORT_CONTEXT_P))) )

        return(RPC_S_OUT_OF_MEMORY);

    ImportContext->LookupContext = LookupContext;
    ImportContext->Bindings = 0;

    *ImportContextOut = ImportContext;

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcNsBindingImportNext(
    IN RPC_NS_HANDLE ImportContextIn,
    OUT RPC_BINDING_HANDLE __RPC_FAR * RpcBinding
    )

/*++

Routine Description:

    Get the next StringBinding in the Import StringBinding vector.  If
    the vector is empty, call RpcNsBindingLookupBegin() to get a new
    vector.

Arguments:

    ImportContext - handle to be used get a new string binding vector from
        RpcNsBindingLookupNext()

    RpcBinding - place to return a binding.  This Binding Handle ownership
        passes to caller.

Returns:

    RPC_S_OK, RpcNsBindingLookupNext()

--*/

{
    RPC_STATUS status;
    PRPC_IMPORT_CONTEXT_P ImportContext;

    ImportContext = (PRPC_IMPORT_CONTEXT_P) ImportContextIn;

    if (!ImportContext)
        return(RPC_S_NO_CONTEXT_AVAILABLE);

    if (ImportContext->Bindings)
        {
        status = RpcNsBindingSelect(ImportContext->Bindings, RpcBinding);

        if (status == RPC_S_OK)
            return(RPC_S_OK);

        if (status != RPC_S_NO_MORE_BINDINGS)
            return(status);
        }

    // The vector was empty or there were no more entris.  Get another vector.

    if (ImportContext->Bindings)
        RpcBindingVectorFree(&ImportContext->Bindings);

    status = RpcNsBindingLookupNext(ImportContext->LookupContext,
        &ImportContext->Bindings);

    if (status)
        return(status);

    return(RpcNsBindingSelect(ImportContext->Bindings, RpcBinding));

}



RPC_STATUS RPC_ENTRY
RpcNsBindingImportDone(
    IN RPC_NS_HANDLE *ImportContextIn
    )

/*++

Routine Description:

    Close an Import Context handle when done.  Free up the current
    Bindings vector, LookupContext and ImportContext structure.

Arguments:

    ImportContext - handle to close.

Returns:

    RPC_S_OK, RpcNsBindingLookupDone()

--*/

{
    RPC_STATUS status;
    PRPC_IMPORT_CONTEXT_P ImportContext;

    ImportContext = (PRPC_IMPORT_CONTEXT_P) *ImportContextIn;

    if (! ImportContext)
        return(RPC_S_OK);

    if (ImportContext->Bindings)
        RpcBindingVectorFree(&ImportContext->Bindings);

    status = RpcNsBindingLookupDone(&ImportContext->LookupContext);

    I_RpcFree (ImportContext);
    *ImportContextIn = 0;

    return(status);
}


RPC_STATUS RPC_ENTRY
RpcNsMgmtHandleSetExpAge(
    IN RPC_NS_HANDLE NsHandle,
    IN unsigned long ExpirationAge
    )
/*++

Routine Description:

    Set the maxium age that a cached entry will be returned in reponse
    to a name service inquirary transaction.

Arguments:

    NsHandle - context handle created with one of the RpcNs*Begin APIs

Returns:

    nsi_mgmt_handle_set_exp_age()

--*/

{
    UNSIGNED16 NsiStatus;
    RPC_NS_HANDLE LookupContext =
                  ((PRPC_IMPORT_CONTEXT_P)NsHandle)->LookupContext;


    RpcTryExcept
        {
        nsi_mgmt_handle_set_exp_age(LookupContext, ExpirationAge, &NsiStatus);
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    return(NsiMapStatus(NsiStatus));
}


#define isLocalName(NetWorkAddress) (1) //BUGBUG


static RPC_STATUS
GetMatchingProtocols(
    IN RPC_BINDING_VECTOR *BindingVector,
    OUT MATCH_VECTOR *MatchVector,
    IN char * SearchProtocol, OPTIONAL
    IN int fLocalOnly
    )

/*++

Routine Description:

    Construct a match binding vector with protocols that we are interested in.
    PERF: When we know how to parse NetWorkAddress to know when it is
    a local name, we should select those first

Arguments:

    BindingVector - vector of binding handles to select from.

    MatchVector - place to put the results.

    SearchProtocol - Protocol we are looking for.  A Nil matches everything.

Returns:

    The number of protocols that we matched in the match vector.

    RPC_S_OK, RpcBindingToStringBinding(), RpcStringBindingParse()

--*/

{
    RPC_STATUS Status;
    unsigned int Index;
    RT_CHAR * StringBinding, *ProtocolSeq, *NetAddress;
    int fProtocolsMatched;

    MatchVector->Count = 0;

    for (Index = 0; Index < BindingVector->Count; Index++)
        {
        if (!BindingVector->BindingH[Index])
            continue;

        // Convert the binding handle to a string and then extract
        // the fields we are interested in.

        if (Status = RpcBindingToStringBinding(
            BindingVector->BindingH[Index], &StringBinding))

             return (Status);

        if (Status = RpcStringBindingParse(StringBinding, 0,
            &ProtocolSeq, &NetAddress, 0, 0))

             return (Status);

        fProtocolsMatched = 1;

        if (SearchProtocol)
            {
            char * STmp = SearchProtocol;

            for (RT_CHAR *pT = ProtocolSeq; *pT &&
                (char) *pT++ == *STmp++; ) ;

            if (*STmp)
                fProtocolsMatched = 0;
            }

        // If we are looking for a local name only and the matched
        // protocol isn't local, throw this one out.

        if (fLocalOnly && !isLocalName(NetAddress))
            fProtocolsMatched = 0;


        // Return all the strings to the RPC runtime.

        if (Status = RpcStringFree(&ProtocolSeq))
            return(Status);

        if (Status = RpcStringFree(&NetAddress))
            return(Status);

        if (Status = RpcStringFree(&StringBinding))
            return(Status);

        if (! fProtocolsMatched)
           continue;


        // A match is recorded as an index into the original vector.

        MatchVector->IndexMatch[MatchVector->Count++] = Index;
        }

    return(RPC_S_OK);
}


int
RandomNumber(
    )
/*++

Routine Description:

    Yet another pseudo-random number generator.

Returns:

    New random number, in the range 0..32767.

--*/
{
     static long holdrand;
     static int fInitialized = 0;

    // Start with a different seed everytime.

    if (!fInitialized)
        {
        fInitialized = 1;
//      holdrand = clock();
        }

    return( (int) (holdrand = (long) ( (holdrand * 214013L + 2531011L)
                >> 16  & 0x7fff ) ));
}



RPC_STATUS RPC_ENTRY
RpcNsBindingSelect(
    IN OUT RPC_BINDING_VECTOR *BindingVector,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * RpcBinding
    )

/*++

Routine Description:

    This function will select a Binding handle from a vector of binding
    handles.  Since we know a little bit about our binding handles, we
    will chose the more effiecent types of handles first.  We select
    groups of bindings unordered via a random number generator.

Arguments:

    BindingVector - vector of binding handles to select from

    RpcBinding - place to return the binding handle.  The ownership of
       the handle passes to the caller.

Returns:

    RPC_S_OK, RPC_S_OUT_OF_MEMORY, RPC_S_NO_MORE_BINDINGS, GetMatchingProtocols()

--*/

{
    static char * PreferredProtocol[] =
    {
        "ncalrpc",
        "ncacn_np",
        0
    };
    int CountPreferredProtocol = sizeof(PreferredProtocol) / sizeof(void *);

    RPC_STATUS Status;
    MATCH_VECTOR *MatchVector;
    int IndexSelected;
    int ProtocolIndex;
    int fLocalOnly;

    *RpcBinding = 0;

    MatchVector = (MATCH_VECTOR *) I_RpcAllocate((unsigned int)
        (sizeof(MATCH_VECTOR) + sizeof(int) * BindingVector->Count));

    if (!MatchVector)
        return(RPC_S_OUT_OF_MEMORY);

    // For all the protocols returned, first try the local ones, then
    // the remote.

    for (fLocalOnly = 1; fLocalOnly >= 0; fLocalOnly--)
        {
        for (ProtocolIndex = 0; ProtocolIndex < CountPreferredProtocol;
             ProtocolIndex++)
            {

            // First, get the perferred protocols into a match vector.
            // The match vector has a range from 0..number of matching protocols.
            // We need this so we know what range to generate a random number.

            if (Status = GetMatchingProtocols(BindingVector, MatchVector,
                PreferredProtocol[ProtocolIndex], fLocalOnly))

                return(Status);

            // If we found any, select one and return it.

            if (MatchVector->Count)
                {
                IndexSelected = MatchVector->
                    IndexMatch[RandomNumber() % MatchVector->Count];

                *RpcBinding = BindingVector->BindingH[IndexSelected];

                // Remove selected one from binding vector.

                BindingVector->BindingH[IndexSelected] = 0;
                I_RpcFree (MatchVector);

                return(RPC_S_OK);
                }
            }
        }

    I_RpcFree (MatchVector);

    return(RPC_S_NO_MORE_BINDINGS);
}


RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE RpcIfSpec,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned long BindingMaxCount,
    OUT RPC_NS_HANDLE *LookupContext
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsBindingLookupBeginW(EntryNameSyntax, &EntryNameW,
        RpcIfSpec, ObjUuid, BindingMaxCount, LookupContext));
}


RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE RpcIfSpec,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    OUT RPC_NS_HANDLE *ImportContext
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsBindingImportBeginW(EntryNameSyntax, &EntryNameW,
        RpcIfSpec, ObjUuid, ImportContext));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\published\uuid\xenroll_i.c ===
#define INITGUID
#include <guiddef.h>
DEFINE_GUID(IID_ICEnroll,    0x43F8F288,0x7A20,0x11D0,0x8F,0x06,0x00,0xC0,0x4F,0xC2,0x95,0xE1);
DEFINE_GUID(IID_ICEnroll2,   0x704ca730,0xc90b,0x11d1,0x9b,0xec,0x00,0xc0,0x4f,0xc2,0x95,0xe1);
DEFINE_GUID(IID_ICEnroll3,   0xc28c2d95,0xb7de,0x11d2,0xa4,0x21,0x00,0xc0,0x4f,0x79,0xfe,0x8e);
DEFINE_GUID(IID_ICEnroll4,   0xc1f1188a,0x2eb5,0x4a80,0x84,0x1b,0x7e,0x72,0x9a,0x35,0x6d,0x90);
DEFINE_GUID(IID_IEnroll,     0xacaa7838,0x4585,0x11d1,0xab,0x57,0x00,0xc0,0x4f,0xc2,0x95,0xe1);
DEFINE_GUID(IID_IEnroll2,    0xc080e199,0xb7df,0x11d2,0xa4,0x21,0x00,0xc0,0x4f,0x79,0xfe,0x8e);
DEFINE_GUID(IID_IEnroll4,    0xf8053fe5,0x78f4,0x448f,0xa0,0xdb,0x41,0xd6,0x1b,0x73,0x44,0x6b);
DEFINE_GUID(LIBID_XENROLLLib,0x43F8F27B,0x7A20,0x11D0,0x8F,0x06,0x00,0xC0,0x4F,0xC2,0x95,0xE1);
DEFINE_GUID(CLSID_CEnroll,   0x43F8F289,0x7A20,0x11D0,0x8F,0x06,0x00,0xC0,0x4F,0xC2,0x95,0xE1);
DEFINE_GUID(CLSID_CEnroll2,  0x127698e4,0xe730,0x4e5c,0xa2,0xb1,0x21,0x49,0x0a,0x70,0xc8,0xa1);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\client\nsisvr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    nsisvr.cxx

Abstract:

    This is the server side NSI service support layer.  These are wrappers
    which call the name service provider.

Author:

    Steven Zeck (stevez) 03/04/92

--*/

#include <nsi.h>

#include <memory.h>
#include <string.h>
#include <stdio.h>

RPC_STATUS RPC_ENTRY
RpcNsBindingExportW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle, OPTIONAL
    IN RPC_BINDING_VECTOR * BindingVector, OPTIONAL
    IN UUID_VECTOR * ObjectVector OPTIONAL
    )

/*++

Routine Description:

    Place a server interface and objects in the name service data base.

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that this export will be stored in.  This is just a
       token that is passed on the the Name Server.

    RpcIfHandle - The interface that is being exported.

    BindingVector - A list of StringBindings to export that are associated
        with this interface.

    ObjectVector -  A list of objects that are associated with this
       interface and Entry Name

Returns:

    Bind(), RpcBindingToStringBinding(), nsi_binding_export()


--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    NSI_SERVER_BINDING_VECTOR_T *NsiVector = 0;
    WIDE_STRING *StringBindingW;
    RT_CHAR * StringBinding = 0;
    RT_CHAR * DynamicEndpoint = 0;
    unsigned int Index;
    unsigned int VectorSize = 0;
    NSI_INTERFACE_ID_T NilIfOnWire, __RPC_FAR *IfPtr;

    if (RpcIfHandle == NULL)
      {
         IfPtr = &NilIfOnWire;
         memset(IfPtr, 0, sizeof(NSI_INTERFACE_ID_T));
      }
    else
      {
         IfPtr = (NSI_INTERFACE_ID_T __RPC_FAR *)
                    &((PRPC_CLIENT_INTERFACE)RpcIfHandle)->InterfaceId;
      }


    if (status = I_NsServerBindSearch())
        return(status);

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;

    if (BindingVector && BindingVector->Count && RpcIfHandle)
        {
        VectorSize = (unsigned int) BindingVector->Count;

        NsiVector = (NSI_SERVER_BINDING_VECTOR_T *) I_RpcAllocate((unsigned int) (
            sizeof(NSI_SERVER_BINDING_VECTOR_T) +
            sizeof(unsigned short *) * VectorSize));

        if (!NsiVector)
            return(RPC_S_OUT_OF_MEMORY);

        NsiVector->count = 0;
        }

    // Copy the vector of binding handles into a vector of string bindinds
    // that are wide character.

    for (Index = 0; Index < VectorSize; Index++)
        {

        if (!BindingVector->BindingH[Index])
            continue;

        // Turn the private runtime data structure into a StringBinding.
#ifdef NTENV
        status = I_RpcBindingToStaticStringBindingW(BindingVector->BindingH[Index],
                &StringBinding);

        // call to remove the dynamic part from the binding
        // and give the string binding.
#else
        status = RpcBindingToStringBinding(BindingVector->BindingH[Index],
                &StringBinding);
#endif

        if (status)
            goto ErrorExit;

        StringBindingW = new WIDE_STRING (StringBinding);

        if (!StringBindingW || StringBindingW->OutOfMemory())
            {
            status = RPC_S_OUT_OF_MEMORY;
            goto ErrorExit;
            }

        NsiVector->string[NsiVector->count++] = &(*StringBindingW);

        I_RpcFree(StringBindingW);      // Free memory without destuctor

#ifndef NTENV
        I_RpcFree(StringBinding);       // Free the non unicode string
#endif
        }

    RpcTryExcept
        {
        nsi_binding_export(
                           NsiSvrBinding,
                           EntryNameSyntax,
                           EntryName,
                           IfPtr,
                           NsiVector,
                           (NSI_UUID_VECTOR_P_T) ObjectVector,
                           &NsiStatus
                          );

        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    status = NsiMapStatus(NsiStatus);

ErrorExit:
    // Return memory allocated for nsi vector.

    if (NsiVector)
        for (Index = 0; Index < NsiVector->count; Index++)
            I_RpcFree(NsiVector->string[Index]);

    if (NsiVector)
        I_RpcFree(NsiVector);

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle OPTIONAL,
    IN UUID_VECTOR * ObjectVector OPTIONAL
    )

/*++

Routine Description:

    Remove a server interface and objects in the name service data base.

Arguments:

    EntryNameSyntax - This value describes the type/format of the EntryName.

    EntryName -  Name that this export will be stored in.  This is just a
       token that is passed on the the Name Server.

    RpcIfHandle - The interface that is being unexported.

    ObjectVector -  A list of objects that are associated with this
       interface and Entry Name

Returns:

    Bind(), nsi_binding_unexport()

--*/

{
    RPC_STATUS status;
    UNSIGNED16 NsiStatus;
    NSI_INTERFACE_ID_T NilIfOnWire, __RPC_FAR *IfPtr;

    if (RpcIfHandle == NULL)
      {
         IfPtr = &NilIfOnWire;
         memset(IfPtr, 0, sizeof(NSI_INTERFACE_ID_T));
      }
    else
      {
         IfPtr = (NSI_INTERFACE_ID_T __RPC_FAR *)
                    &((PRPC_CLIENT_INTERFACE)RpcIfHandle)->InterfaceId;
      }


    if (status = I_NsServerBindSearch())
        return(status);

    if (! EntryNameSyntax)
        EntryNameSyntax = DefaultSyntax;

    RpcTryExcept
        {
         nsi_binding_unexport(NsiSvrBinding, EntryNameSyntax, EntryName,
             IfPtr, (NSI_UUID_VECTOR_P_T) ObjectVector,
             &NsiStatus); 
        }
    RpcExcept(1)
        {
        NsiStatus = MapException(RpcExceptionCode());
        }
    RpcEndExcept

    return(NsiMapStatus(NsiStatus));
}


RPC_STATUS RPC_ENTRY
RpcNsBindingExportA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle,
    IN RPC_BINDING_VECTOR * BindingVector, OPTIONAL
    IN UUID_VECTOR * ObjectVector OPTIONAL
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsBindingExportW(EntryNameSyntax, &EntryNameW,
        RpcIfHandle, BindingVector, ObjectVector));
}


RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle,
    IN UUID_VECTOR * ObjectVector OPTIONAL
    )

/*++

Routine Description:

    This is an ASCII wrapper to the UNICODE version of the API.  It
    converts all char * -> short * strings and calls the UNICODE version.

--*/

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsBindingUnexportW(EntryNameSyntax, &EntryNameW,
        RpcIfHandle, ObjectVector));
}

#ifdef NTENV

/*
Function:
        The Binding Vector corresponding to this Server is discovered
using InqBindings, And is cached along with the EntryName and RpcIfHandle 
in the same Process.

When a PnP event occurs resulting in addition/deletion of the bindings
Corresponding changes are made to the Name Service database. (added or deleted)

Notice that this can not be called from a process that is not a server. The
Exports have to be done from the server itself if it has to be PnP aware

*/

RPC_STATUS RPC_ENTRY
RpcNsBindingExportPnPW(
    IN unsigned long EntryNameSyntax,
    IN unsigned short * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle, OPTIONAL
     IN UUID_VECTOR * ObjectVector OPTIONAL
    )

{
    RPC_STATUS status = RPC_S_OK;
    RPC_BINDING_VECTOR *BindingVec = NULL;

    status = RpcServerInqBindings(&BindingVec);
    // InqBindings to get the binding vector

    if (status != RPC_S_OK)
        return status;


    status = RpcNsBindingExportW(EntryNameSyntax, EntryName,
                                     RpcIfHandle, BindingVec, 
                                     ObjectVector
                                     );
    if (status != RPC_S_OK)
        return status;

    // only if this is valid, other invalid cases will all be caught before

    if (RpcIfHandle)
        status = I_RpcNsInterfaceExported(EntryNameSyntax, EntryName,
                                      (RPC_SERVER_INTERFACE *)RpcIfHandle);

    return status;

// going to cache for bindings exported to the locator 
// (only if the prev. export succeeded)
}

/*
        Removes all the bindings corresponding to this particular server
from the Name Service database. It also removes it from the cache that
is maintained for the EntryName/InterfaceId combination.

Notice that this can not be called from a process that is not a server. The
Unexports have to be done from the server itself if it has to be PnP aware

*/

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportPnPW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle OPTIONAL,
    IN UUID_VECTOR * ObjectVector OPTIONAL
    )
{
    RPC_STATUS status = RPC_S_OK;
    status = RpcNsBindingUnexportW(EntryNameSyntax, EntryName,
                                   RpcIfHandle, ObjectVector);

    if (status != RPC_S_OK)
        return status;

    if (RpcIfHandle)
        status = I_RpcNsInterfaceUnexported(EntryNameSyntax, EntryName,
                                      (RPC_SERVER_INTERFACE *)RpcIfHandle);
    // once it has got removed, remove it from the cache as well.

    return status;
}

RPC_STATUS RPC_ENTRY
RpcNsBindingExportPnPA(
    IN unsigned long EntryNameSyntax,
    IN unsigned char * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle, OPTIONAL
     IN UUID_VECTOR * ObjectVector OPTIONAL
    )

{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsBindingExportPnPW(EntryNameSyntax, &EntryNameW,
        RpcIfHandle, ObjectVector));

}

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportPnPA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char * EntryName,
    IN RPC_IF_HANDLE RpcIfHandle OPTIONAL,
    IN UUID_VECTOR * ObjectVector OPTIONAL
    )
{
    WIDE_STRING EntryNameW(EntryName);

    if (EntryNameW.OutOfMemory())
        return(RPC_S_OUT_OF_MEMORY);

    return(RpcNsBindingUnexportPnPW(EntryNameSyntax, &EntryNameW,
        RpcIfHandle, ObjectVector));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\client\autohand.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    autohand.cxx

Abstract:

    This module implements the autohandle functions call by the compiler
    generated stubs.

Author:

    Steven Zeck (stevez) 03/10/92
    Kamen Moutafov (KamenM) Feb 2000 - add support for multiple transfer syntaxes

--*/

#include <rpc.h>
#include <rpcdcep.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <rpcnsi.h>
#include <rpcnsip.h>

#ifdef __cplusplus
}
#endif

typedef RPC_STATUS
(RPC_ENTRY *RPC_BIND)
        (
        IN PRPC_MESSAGE Message
        );

RPC_STATUS
RpcpNsGetBuffer(
    IN PRPC_MESSAGE Message,
    RPC_BIND BindFn
    );

// Interface can be only RPC_CLIENT_INTERFACE
inline BOOL DoesInterfaceSupportMultipleTransferSyntaxes(void *Interface)
{
    // the client and server interface have the same layout - we can just
    // use one of them
    RPC_CLIENT_INTERFACE *ClientInterface = (RPC_CLIENT_INTERFACE *)Interface;

    if (ClientInterface->Length == NT351_INTERFACE_SIZE)
        return FALSE;

    return (ClientInterface->Flags & RPCFLG_HAS_MULTI_SYNTAXES);
}

RPC_STATUS RPC_ENTRY
I_RpcNsGetBuffer(
    IN PRPC_MESSAGE Message
    )

/*++

Routine Description:

    Auto bind to a given interface.

Arguments:

    Message - describes the interface that we want to auto bind to.

Returns:

    RPC_S_OK, RPC_S_CALL_FAILED_DNE, I_RpcGetBuffer()

--*/

{
    if (!DoesInterfaceSupportMultipleTransferSyntaxes(Message->RpcInterfaceInformation))
        Message->ImportContext = 0;

    return RpcpNsGetBuffer(Message, I_RpcGetBuffer);
}

extern "C"
{

RPC_STATUS RPC_ENTRY
I_RpcNsNegotiateTransferSyntax(
    IN PRPC_MESSAGE Message
    );

};   // extern "C"

RPC_STATUS RPC_ENTRY
I_RpcNsNegotiateTransferSyntax(
    IN PRPC_MESSAGE Message
    )

/*++

Routine Description:

    Auto bind to a given interface.

Arguments:

    Message - describes the interface that we want to auto bind to.

Returns:

    RPC_S_OK, RPC_S_CALL_FAILED_DNE, I_RpcGetBuffer()

--*/

{
    Message->ImportContext = 0;
    return RpcpNsGetBuffer(Message, I_RpcNegotiateTransferSyntax);
}


RPC_STATUS
RpcpNsGetBuffer(
    IN PRPC_MESSAGE Message,
    RPC_BIND BindFn
    )

/*++

Routine Description:

    Auto bind to a given interface.

Arguments:

    Message - describes the interface that we want to auto bind to.

Returns:

    RPC_S_OK or error

--*/

{
    RPC_STATUS status;
    PRPC_IMPORT_CONTEXT_P Import;
    int fSetAge = 0;

    // If there already is a handle, use it directly.

    if (Message->Handle)
        return(BindFn(Message));

    Message->ImportContext = 0;

    for (int cTry = 0; cTry < 2; cTry++)
        {
        status = RpcNsBindingImportBegin(RPC_C_NS_SYNTAX_DEFAULT, 0,
            Message->RpcInterfaceInformation, 0, &Message->ImportContext);

        Import = (PRPC_IMPORT_CONTEXT_P) Message->ImportContext;

        if (status)
            break;

        // This will cause some Zecky Magic
        // Also note that naively one might move this ExpAge to
        // after the first lookup failed time- that is a bobo
        if (fSetAge)
            status = RpcNsMgmtHandleSetExpAge (Message->ImportContext, 0);

        // If we found no bindings last time, tell the locator
        // to look on the net.


        // For each handle returned by import, try using it with I_RpcGetBuffer
        // function until success or no more import handles.

        while(RpcNsBindingImportNext(Import, &Import->ProposedHandle)
                                                               == RPC_S_OK)
            {
            Message->Handle = Import->ProposedHandle;

            if (BindFn(Message) == RPC_S_OK)
                return(RPC_S_OK);

            RpcBindingFree(&Import->ProposedHandle);
            }

        fSetAge = 1;


        RpcNsBindingImportDone(&Message->ImportContext);
        }


    if (status == RPC_S_NAME_SERVICE_UNAVAILABLE ||
        status == RPC_S_OUT_OF_MEMORY ||
        status == RPC_S_OUT_OF_RESOURCES)

        return(status);

    return(RPC_S_CALL_FAILED_DNE);
}



RPC_STATUS RPC_ENTRY
I_RpcNsSendReceive(
    IN PRPC_MESSAGE Message,
    OUT RPC_BINDING_HANDLE * Handle
    )

/*++

Routine Description:

    Make a call on a RPC server.  If the call fails continue looking for
    servers to bind to.  This is only needed for protocols
    which don't allocate the connection at I_RpcGetBuffer time.


Arguments:

    Message - describes the interface that we want to Call.  The
        ImportContext field contains the active lookup handle, if any.

    Handle - returns the binding handle used on the successfull call.

Returns:


    RPC_S_CALL_FAILED_DNE, I_RpcSendReceive()

--*/

{
    RPC_STATUS status;
    PRPC_IMPORT_CONTEXT_P Import;

    Import = (PRPC_IMPORT_CONTEXT_P) Message->ImportContext;

    while ((status = I_RpcSendReceive(Message)) != RPC_S_OK && Import)
       {
       RpcBindingFree(&Import->ProposedHandle);

       // The call failed, try the next binding handle

       while(RpcNsBindingImportNext(Import, &Import->ProposedHandle)
           == RPC_S_OK)
           {
           Message->Handle = Import->ProposedHandle;

           I_RpcReBindBuffer(Message);
           continue;
           }

       I_RpcFreeBuffer(Message);

       status = RPC_S_CALL_FAILED_DNE;
       }

    if (Import)
       {
       *Handle = Import->ProposedHandle;
       RpcNsBindingImportDone(&Message->ImportContext);
       }

    if (status)
        *Handle = 0;

    return(status);
}



void RPC_ENTRY
I_RpcNsRaiseException(
    IN PRPC_MESSAGE Message,
    IN RPC_STATUS Status
    )

/*++

Routine Description:

    Raise an Exception for an autobind interface.  We simply cleanup any
    open import context and raise the exception.

Arguments:

    Message - continas the import context, if any.

--*/

{
    RpcNsBindingImportDone(&Message->ImportContext);

    RpcRaiseException(Status);
}


// BUG BUG implement this is the runtime.

RPC_STATUS RPC_ENTRY
I_RpcReBindBuffer(
    IN PRPC_MESSAGE Message
    )
{
    (void __RPC_FAR *) Message;

    RpcRaiseException(RPC_S_INTERNAL_ERROR);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\client\cbind.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    cbind.cxx

Abstract:

    This is the client side NSI service support layer.  These functions
    provide for binding to the locator or other name server.

Author:

    Steven Zeck (stevez) 03/04/92

--*/

#include <nsi.h>

#ifndef NTENV

#include <netcons.h>
#include <neterr.h>
#include <server.h>
#include <access.h>
#include <regapi.h>
#include <mailslot.h>
#include <wksta.h>

#ifndef USHORT
#define USHORT unsigned short
#endif

#else

#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <stdlib.h>
#include "startsvc.h"
#endif

#include <string.h>

#ifndef NTENV
#include "locquery.h"
#endif

extern "C"
{
unsigned long RPC_ENTRY
I_GetDefaultEntrySyntax(
    );
}

void RpcNsLmDiscard(void);

#ifndef NTENV
unsigned short BroadcastAQuery(unsigned long Query,
                               char __RPC_FAR * Buffer,
                               unsigned short Count);

#define MAXLOCATORSTOTRY 8
#endif

#ifdef NTENV
#define LOCALLOCATOR "\\\\."
#endif

#if defined(DOS) && !defined(WIN)

extern int _NsAllocatorInitialized;
extern __RPC_API NsAllocatorSetup();

#define INIT_DOS_ALLOCATOR_IF_NECESSARY \
    { if (!_NsAllocatorInitialized) NsAllocatorSetup(); }

#else  // DOS only
#define INIT_DOS_ALLOCATOR_IF_NECESSARY
#endif // DOS only

unsigned char * NsiStringBinding;

enum {
    BindingReadRegistry = 0,
    BindingNotYetTried,
    BindingContinueRegistry,
    BindingFound,
#ifndef NTENV
    BindingBackupFirst,
    BindingBackup,
    BindToBackupViaBC,
    BindToAnyViaBC
#endif
};

#define NilOffset (-1)

typedef struct
{
    unsigned char *ProtoSeq;
    unsigned char *NetworkAddress;
    unsigned char *Endpoint;

    HKEY RegHandle;
    unsigned int NumberServers;
    int AddressOffset;
    void *Buffer;
    char *ServerList;
    int State;
    int NextState;

} RPC_LOCATOR_BIND_CONTEXT, *PRPC_LOCATOR_BIND_CONTEXT;

DWORD GblBindId = 0;

#define MAX_SERVER_NAME 20

static RPC_LOCATOR_BIND_CONTEXT near BindSearch;

WIDE_STRING *DefaultName;
long DefaultSyntax = RPC_C_NS_SYNTAX_DCE;
int  fSyntaxDefaultsLoaded;

#ifndef NTENV

char __RPC_FAR * MailslotName = "\\\\*\\mailslot\\Resp_s";
char __RPC_FAR * LocalMS      = "\\mailslot\\Resp_c";

#define RESPONSETIME  4096L
#endif



unsigned char *
RegGetString(
    IN void * RegHandle,
    IN char * KeyName
    )

/*++

Routine Description:

    Get a string from the registery.

Arguments:

    KeyName - name of key to lookup.

Returns:

    pointer to the allocated string, or Nil if not found

--*/
{
    char Buffer[300];
    DWORD BufferLength = sizeof(Buffer);
    DWORD Type;

#ifdef NTENV

    if (RegQueryValueExA((HKEY)RegHandle, KeyName, 0, &Type,
            (unsigned char far*)Buffer, &BufferLength))
#else

    if (RegQueryValueA((HKEY)RegHandle, KeyName,
                (char far*)Buffer, &BufferLength))

#endif
        return(0);

    return(CopyString(Buffer));
}


static RPC_STATUS
Bind(RPC_BINDING_HANDLE *NsiClntBinding
    )

/*++

Routine Description:

    Bind to the locator server

Returns:

    RpcBindingFromStringBinding()

--*/
{
    RPC_STATUS status;
    unsigned char AddressBuffer[100];

    status = RpcStringFreeA(&NsiStringBinding);
    ASSERT(!status);

    // Get the next path componet from the NetworkAddress field.
    // Conponets are ; delimited fields.

    ASSERT(BindSearch.AddressOffset >= 0);

    for (int i = 0; i < sizeof(AddressBuffer); BindSearch.AddressOffset++, i++)
         {

         AddressBuffer[i] =
             BindSearch.NetworkAddress[BindSearch.AddressOffset];

         if (BindSearch.NetworkAddress[BindSearch.AddressOffset] == ';')
            {

            BindSearch.AddressOffset++;

            // If there are two ;; in a row, then pass through the ;
            // as a literal instead of a path seperator.

            if (BindSearch.NetworkAddress[BindSearch.AddressOffset] == ';')
                continue;

            AddressBuffer[i] = 0;
            break;
            }

         if (BindSearch.NetworkAddress[BindSearch.AddressOffset] == 0)
            {
            BindSearch.AddressOffset = NilOffset;
            break;
            }
        }
 

    status = RpcStringBindingComposeA(0, BindSearch.ProtoSeq,
         AddressBuffer, BindSearch.Endpoint,
         0, &NsiStringBinding);

    if (status)
        return(status);

    return (RpcBindingFromStringBindingA(NsiStringBinding, NsiClntBinding));
}


RPC_STATUS RPC_ENTRY
I_NsClientBindSearch(RPC_BINDING_HANDLE *NsiClntBinding, DWORD *BindId
                     )
/*++
    
Routine Description:
  
    The function binds to the locator, first it tries to bind to a
    local machine, then it attempts to bind to the domain controller.
                         
Arguments:
                           
  BindingSearchContext - context of search for the locator.

Returns:
                               
  RPC_S_OK, RPC_S_NO_BINDINGS, RPC_S_CANNOT_BIND, RPC_S_OUT_OF_RESOURCES
                                 
  rewritten to make it multi-thread capable. ushaji, Mar 98

--*/
                                   
{
    long status;
    
#ifndef NTENV
    unsigned short cbSI;
#define SERVER_INFO struct server_info_0
#define ServerName(p) ((struct server_info_0 *)p)->sv0_name
    unsigned short Count = 1;
    QUERYLOCATORREPLY Reply, __RPC_FAR * QueryReply;
#else
#define SERVER_INFO SERVER_INFO_100
#define ServerName(p) ((SERVER_INFO_100 *)p)->sv100_name
#endif
    
    INIT_DOS_ALLOCATOR_IF_NECESSARY;
    
    RequestGlobalMutex();
    
    switch (BindSearch.State)
    {
    case BindingReadRegistry:
        
        if (BindSearch.RegHandle)
        {
            status = RegCloseKey(BindSearch.RegHandle);
            ASSERT(!status);
            BindSearch.RegHandle = 0;
            
            delete BindSearch.NetworkAddress;
            delete BindSearch.ProtoSeq;
            delete BindSearch.Endpoint;
        }
        memset(&BindSearch, 0, sizeof(RPC_LOCATOR_BIND_CONTEXT));
        
        // We store the binding information on the name service in
        // the registry.  Get the information into BindingHandle.
        
#ifdef NTENV
        status = RegOpenKeyExA(RPC_REG_ROOT, REG_NSI, 0L, KEY_READ,
            &BindSearch.RegHandle);
#else
        status = RegOpenKeyA(RPC_REG_ROOT, REG_NSI, &BindSearch.RegHandle);
#endif
        
        
        if (status) {
            status = RPC_S_NAME_SERVICE_UNAVAILABLE;
            break;
        }
        
        BindSearch.ProtoSeq = RegGetString((void *) BindSearch.RegHandle, "Protocol");
        BindSearch.NetworkAddress = RegGetString((void *) BindSearch.RegHandle,
            "NetworkAddress");
        BindSearch.Endpoint = RegGetString((void *) BindSearch.RegHandle, "Endpoint");
        
        GetDefaultEntrys((void *) BindSearch.RegHandle);
        
        if (!BindSearch.ProtoSeq || !BindSearch.Endpoint) {
            status = RPC_S_NAME_SERVICE_UNAVAILABLE;
            break;
        }
        
#ifdef NTENV
        if (
            (BindSearch.NetworkAddress == NULL)
            || (BindSearch.NetworkAddress[0] == '\0')
            || (!strncmp((char *) BindSearch.NetworkAddress, LOCALLOCATOR,
            strlen(LOCALLOCATOR)))
            )
        {
            StartServiceIfNecessary();
        }
#endif
        
        status = Bind(NsiClntBinding);
        if (status == RPC_S_OK) {
            BindSearch.State = BindingNotYetTried;
            GblBindId++;
            BindSearch.NextState = BindingContinueRegistry;
        }
        
        break;
        
        
    case BindingNotYetTried:
    case BindingFound:
        status = RpcBindingFromStringBindingA(NsiStringBinding, NsiClntBinding);
        break;
        
    case BindingContinueRegistry:
        
        if (BindSearch.AddressOffset != NilOffset) {
            status = Bind(NsiClntBinding);
            
            if (status == RPC_S_OK) {
                BindSearch.State = BindingNotYetTried;
                GblBindId++;
            }
            break;
        }
        
#ifdef NTENV
        status = RPC_S_NAME_SERVICE_UNAVAILABLE;
        break;
#else
        
        if (BindSearch.NetworkAddress)
            delete BindSearch.NetworkAddress;
        
        // Don't search the Net if we aren't looking for the locator.
        if (strcmp((char *)BindSearch.Endpoint, "\\pipe\\locator"))
        {
            status = RPC_S_NAME_SERVICE_UNAVAILABLE;
            break;
        }
        
        BindSearch.NetworkAddress = new unsigned char [MAX_SERVER_NAME];
        
        // second, try the domain controller
        
        
        if (NetGetDCName(0, 0, (char far *) BindSearch.NetworkAddress,
            MAX_SERVER_NAME))
        {
            status = RPC_S_NAME_SERVICE_UNAVAILABLE;
            break;
        }
        
        BindSearch.AddressOffset = 0;
        
        status = Bind(NsiClntBinding);
        if (status == RPC_S_OK) 
        {
            GblBindId++;
            BindSearch.State = BindingNotYetTried;
            BindSearch.NextState = BindingBackupFirst;
            break;
        }
        break;
        
    case BindingBackupFirst:
        BindSearch.NumberServers = 0;
        
        // third, try all the member servers. First get the # of bytes
        // needed to hold all the names, then retrive them.
        
        NetServerEnum2(0, 0, 0, 0,
            (USHORT *) &BindSearch.NumberServers,
            (USHORT *) &BindSearch.NumberServers,
            SV_TYPE_DOMAIN_BAKCTRL, 0);
        
        cbSI = (BindSearch.NumberServers+2) * sizeof(SERVER_INFO);
        BindSearch.Buffer = new char [cbSI];
        BindSearch.ServerList = (char *) BindSearch.Buffer;
        
        if (!BindSearch.ServerList)
        {
            status = RPC_S_OUT_OF_RESOURCES;
            break;
        }
        
        if (NetServerEnum2(0, 0, (char far *)BindSearch.ServerList, cbSI,
            (USHORT *) &BindSearch.NumberServers,
            (USHORT *) &BindSearch.NumberServers,
            SV_TYPE_DOMAIN_BAKCTRL, 0))
            
        {
            delete BindSearch.Buffer;
            status = RPC_S_NAME_SERVICE_UNAVAILABLE;
            break;
        }
        
    case BindingBackup:
        
        if (BindSearch.NumberServers == 0)
        {
            delete BindSearch.Buffer;
            BindSearch.Buffer = new char [sizeof(QUERYLOCATORREPLY) *
                MAXLOCATORSTOTRY];
            if (BindSearch.Buffer == NULL)
            {
                status = RPC_S_NAME_SERVICE_UNAVAILABLE;
                break;
            }
            
            BindSearch.ServerList = (char *)BindSearch.Buffer;
            BindSearch.NumberServers = BroadcastAQuery(
                QUERY_DC_LOCATOR,
                (char __RPC_FAR *)BindSearch.Buffer,
                MAXLOCATORSTOTRY
                );
            
        }
        else
        {
            BindSearch.NumberServers--;
            BindSearch.NetworkAddress[0] = '\\';
            BindSearch.NetworkAddress[1] = '\\';
            
            strcpy((char far *)BindSearch.NetworkAddress+2,
                ServerName(BindSearch.ServerList));
            
            BindSearch.ServerList += sizeof(SERVER_INFO);
            
            BindSearch.AddressOffset = 0;
            status = Bind(NsiClntBinding);
            if (status == RPC_S_OK) {
                GblBindId++;
                BindSearch.NextState = BindSearch.State;
                BindSearch.State = BindingNotYetTried;
            }
            
            break;
        }
        
        
    case BindToBackupViaBC:
        
        if (BindSearch.NumberServers == 0)
        {
            //The buffer is already setup, use it for next phase
            BindSearch.NumberServers =  BroadcastAQuery(
                QUERY_ANY_LOCATOR,
                (char __RPC_FAR *)BindSearch.Buffer,
                MAXLOCATORSTOTRY
                );
            BindSearch.State = BindToAnyViaBC;
            BindSearch.ServerList = (char *) BindSearch.Buffer;
        }
        else
        {
            BindSearch.NumberServers--;
            QueryReply = (QUERYLOCATORREPLY __RPC_FAR *)
                BindSearch.ServerList;
            UnicodeToAscii(QueryReply->SenderName);
            strcpy((char __RPC_FAR *) BindSearch.NetworkAddress,
                (char __RPC_FAR *)QueryReply->SenderName);
            BindSearch.ServerList = (char __RPC_FAR *)(QueryReply+1);
            BindSearch.AddressOffset = 0;
            status = Bind(NsiClntBinding);

            if (status == RPC_S_OK) {
                GblBindId++;
                BindSearch.NextState = BindSearch.State;
                BindSearch.State = BindingNotYetTried;
            }
            break;
        }
        
        //In the If case - we intentionally fall through to the
        //BindAny state.
        
    case BindToAnyViaBC:
        if (BindSearch.NumberServers == 0)
        {
            delete BindSearch.Buffer;
            status = RPC_S_NAME_SERVICE_UNAVAILABLE;
        }
        else
        {
            BindSearch.NumberServers--;
            QueryReply = (QUERYLOCATORREPLY __RPC_FAR *)
                BindSearch.ServerList;
            UnicodeToAscii(QueryReply->SenderName);
            strcpy((char __RPC_FAR *) BindSearch.NetworkAddress,
                (char __RPC_FAR *)QueryReply->SenderName);
            BindSearch.ServerList = (char __RPC_FAR *)(QueryReply+1);
            BindSearch.AddressOffset = 0;
            status = Bind(NsiClntBinding);

            if (status == RPC_S_OK) {
                GblBindId++;
                BindSearch.NextState = BindSearch.State;
                BindSearch.State = BindingNotYetTried;
            }
        }
        
        break;
#endif
        
    default:
        ASSERT(!"Bad Search State");
        BindSearch.State = BindingReadRegistry;
        status = RPC_S_NAME_SERVICE_UNAVAILABLE;
        break;
    }
    
    *BindId = GblBindId;
    ClearGlobalMutex();
    return(status);
}

RPC_STATUS RPC_ENTRY
I_NsBindingFoundBogus(RPC_BINDING_HANDLE *NsiClntBinding, DWORD BindId
        )
{
    long status;

    if (*NsiClntBinding)
    {
        status = RpcBindingFree(NsiClntBinding);
        ASSERT(!status);
    }
    *NsiClntBinding = NULL;

    RequestGlobalMutex();

    switch (BindSearch.State)
    {
    case BindingNotYetTried:
        if (BindId == GblBindId)
            BindSearch.State = BindSearch.NextState;
        break;
    case BindingFound:
        if (BindId == GblBindId)
            BindSearch.State = BindingReadRegistry;
        break;
    default:
        break;
    }

    ClearGlobalMutex();
    return(RPC_S_OK);
}

void RPC_ENTRY
I_NsClientBindDone(RPC_BINDING_HANDLE *NsiClntBinding, DWORD BindId
    )
/*++

Routine Description:

    The function cleans up after binding to the locator.

Returns:

--*/

{
    long status;
    RPC_STATUS RpcStatus;

    RequestGlobalMutex();

    switch (BindSearch.State)
      {
      case BindingFound:
        break;

      case BindingReadRegistry:
        break;

      case BindingNotYetTried:
          if (BindId == GblBindId) {
              BindSearch.State = BindingFound;

              if (BindSearch.RegHandle)
              {
                  status = RegCloseKey(BindSearch.RegHandle);
                  ASSERT(!status);
                  BindSearch.RegHandle = 0;
                  
                  delete BindSearch.NetworkAddress;
                  delete BindSearch.ProtoSeq;
                  delete BindSearch.Endpoint;
              }
          }
         break;

      case BindingContinueRegistry:
          if (BindId == GblBindId) {
             BindSearch.State = BindingReadRegistry;
             if (BindSearch.RegHandle)
             {
                  status = RegCloseKey(BindSearch.RegHandle);
                  ASSERT(!status);
                  BindSearch.RegHandle = 0;
                  
                  delete BindSearch.NetworkAddress;
                  delete BindSearch.ProtoSeq;
                  delete BindSearch.Endpoint;
             }
         }
         break;

#ifndef NTENV
      case BindToAnyViaBC:
      case BindToBackupViaBC:
      case BindingBackup:
        delete BindSearch.Buffer;

      case BindingBackupFirst:

         status = RegSetValue(BindSearch.RegHandle, "NetworkAddress",
            REG_SZ, (LPSTR) BindSearch.NetworkAddress,
            strlen((CONST_CHAR *)BindSearch.NetworkAddress) + 1);

         BindSearch.State = BindingFound;
         ASSERT(!status);
         break;
#endif

      default:
         ASSERT(!"Bad State - \n");
      }

#if defined(DOS) && !defined(WIN)

    // Unloaded the big fat lanman stuff now that we are done searching.

    RpcNsLmDiscard();

#endif

    RpcStatus = RpcBindingFree(NsiClntBinding);

    ClearGlobalMutex();
    
//    ASSERT(!RpcStatus);
}



unsigned long RPC_ENTRY
I_GetDefaultEntrySyntax(
    )
/*++

Routine Description:

    Called by the runtime DLL when it needs to know the default syntax.
    Currently this is used only by RpcBindingInqEntry().

Arguments:

    none

Return Value:

    the entry syntax

Exceptions:

    none

--*/
{
    return (unsigned long) DefaultSyntax;
}


#ifndef NTENV

unsigned short BroadcastAQuery(
               unsigned long Type,
               char __RPC_FAR * Buffer,
               unsigned short  Count
                 )
{

  unsigned short Err;
  unsigned MSHandle;
  unsigned short Returned, NextSize, NextPri, Avail;
  unsigned short RetCount = 0;
  QUERYLOCATOR   Query;
  unsigned long TimeRemaining = RESPONSETIME;
  wksta_info_10  __RPC_FAR * Wkio10;
  char __RPC_FAR * pBuf;
  unsigned short __RPC_FAR * pUZ;
  //First try and get the computer name

  Err = NetWkstaGetInfo(
                  0L,
                  10,
                  (char __RPC_FAR *) 0L,
                  0,
                  &Avail);

  ASSERT(Err == NERR_BufTooSmall);

  Wkio10 = (wksta_info_10 __RPC_FAR *) new char [Avail];

  if (Wkio10 == 0L)
    {
      return 0;
    }

  Err = NetWkstaGetInfo(
                  0L,
                  10,
                  (char __RPC_FAR *) Wkio10,
                  Avail,
                  &Avail
                  );

  //Format the Query!
  Query.MessageType = Type;
  Query.SenderOsType= OS_WIN31DOS;

  for (pBuf = &Wkio10->wki10_computername[0],pUZ = &Query.RequesterName[0];
       *pBuf !=0;
       pBuf++, pUZ++)
    *pUZ = *pBuf;

  *pUZ = 0;


  Err = DosMakeMailslot(
               LocalMS,
               sizeof(QUERYLOCATORREPLY),
               0,
               &MSHandle
               );

  if (Err != NERR_Success)
      {
        return 0;
      }

  Err = DosWriteMailslot(
                 MailslotName,
                 (char __RPC_FAR *) &Query,
                 sizeof(Query),
                 0,                //Priority
                 2,                //Class
                 0                 //Timeout
                 );

  if (Err != NERR_Success)
      goto CleanupAndExit;

  //Now sit in a loop and wait
  //for WAITRESPONSE secs

  while ((TimeRemaining) && (RetCount < Count))
  {

    Err = DosReadMailslot(
                   MSHandle,
                   Buffer,
                   &Returned,
                   &NextSize,
                   &NextPri,
                   TimeRemaining
                   );

    if (Err == NERR_Success)
       {
         ASSERT (Returned == sizeof(QUERYLOCATORREPLY));
         Buffer += sizeof(QUERYLOCATORREPLY);
         RetCount ++;
         TimeRemaining >> 1;
         continue;
       }

    break;

   } //end of while ReadMS


CleanupAndExit:
   DosDeleteMailslot(MSHandle);
   return (RetCount);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\client\startsvc.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    startsvc.h

Abstract:

    This file contains the interface for insuring that the rpcss service
    has been started.

Author:

    Michael Montague (mikemon) (02-Oct-1992)

Revision History:

--*/

#ifndef __STARTSVC_H__
#define __STARTSVC_H__

#ifdef __cplusplus
extern "C" {
#endif

RPC_STATUS
StartServiceIfNecessary (
    void
    );

#ifdef __cplusplus
}
#endif


#endif // __STARTSVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\client\sbind.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    sbind.cxx

Abstract:

    This is the server side NSI service support layer.  These functions
    provide for binding to the locator.

Author:

    Steven Zeck (stevez) 03/04/92

--*/

#define NSI_ASCII
#define RegistryIsWorking

#include <nsi.h>

#ifdef NTENV
#include <windows.h>
#endif

#include <winreg.h>

#include <string.h>

#ifdef NTENV

#include <startsvc.h>

#endif

RPC_BINDING_HANDLE NsiSvrBinding;	 // global binding handle to locator


// *** The following functions are used to RPC to the locator *** ///

RPC_STATUS RPC_ENTRY
I_NsServerBindSearch (
    )
/*++

Routine Description:

   Servers keep their RPC binding open until they terminate.

Returns:

    RPC_S_OK, RPC_S_CALL_FAILED_DNE, RpcStringBindingCompose(),
    RpcBindingFromStringBinding()

--*/
{
    RPC_STATUS status;
    long statusTmp;
    static RPC_BINDING_HANDLE NsiSvrBindingExport;
    unsigned char * StringBinding;
    HKEY RegHandle;
    unsigned char *ProtoSeq;
    unsigned char *NetworkAddress;
    unsigned char *Endpoint;

    RequestGlobalMutex();

    if (NsiSvrBinding = NsiSvrBindingExport)
        {
        ClearGlobalMutex();
	return(RPC_S_OK);
        }

#ifndef RegistryIsWorking
        ProtoSeq = (unsigned char *)"ncacn_np";
        NetworkAddress = 0;
        Endpoint = (unsigned char *)"\\pipe\\locator";
        DefaultSyntax = 1;

    status = RpcStringBindingCompose(0, ProtoSeq,
        NetworkAddress, Endpoint, 0, &StringBinding);
#else


    // We store the binding information on the name service in
    // the registry.  Get the information into BindingHandle.

#ifdef NTENV
    statusTmp = RegOpenKeyEx(RPC_REG_ROOT, REG_NSI, 0L, KEY_READ,
                             (PHKEY) &RegHandle);
#else
    statusTmp = RegOpenKey(RPC_REG_ROOT, REG_NSI, (PHKEY) &RegHandle);
#endif

    if (statusTmp)
        {
        ClearGlobalMutex();
        return(RPC_S_CALL_FAILED_DNE);
        }

    GetDefaultEntrys((void *) RegHandle);

    ProtoSeq = RegGetString((void *) RegHandle, "Protocol");
    NetworkAddress = RegGetString((void *) RegHandle, "ServerNetWorkAddress");
    Endpoint = RegGetString((void *) RegHandle, "Endpoint");

    status = RpcStringBindingCompose(0, ProtoSeq,
        NetworkAddress, Endpoint, 0, &StringBinding);

#ifdef NTENV

    if (  (NetworkAddress == NULL)
        || (NetworkAddress[0] == '\0')
        || (strcmp ((char *)NetworkAddress, "\\\\.") == 0)
       )
       {
          //We are binding to the local locator..
          //lets start the local locator if not already started

          StartServiceIfNecessary();
       }
#endif

    delete ProtoSeq;
    delete NetworkAddress;
    delete Endpoint;

    statusTmp = RegCloseKey(RegHandle);
    ASSERT(!statusTmp);
#endif

    if (status)
        {
        ClearGlobalMutex();
        return(status);
        }


    status = RpcBindingFromStringBinding(StringBinding, &NsiSvrBinding);

    if (status == RPC_S_OK)
        NsiSvrBindingExport = NsiSvrBinding;

    statusTmp = RpcStringFree(&StringBinding);
    ASSERT(!statusTmp);

    ClearGlobalMutex();

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\client\util.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    util.cxx

Abstract:

    This module contains utility functions used by the NSI client wrappers.

Author:

    Steven Zeck (stevez) 03/27/92

--*/


#include <nsi.h>

#include <memory.h>
#include <string.h>
#include <stdio.h>

#ifndef WIN32

extern "C"
{
int atoi(char *);

void far pascal OutputDebugString(void far *);


void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    size_t cb
    );

void __RPC_API
MIDL_user_free(
    void __RPC_FAR * p
    );
}

#else
#include <stdlib.h>

#endif

RPC_STATUS NsiToRpcStatus[] =
{
    RPC_S_OK,                      // NSI_S_OK
    RPC_S_NO_MORE_BINDINGS,        // NSI_S_NO_MORE_BINDINGS
    RPC_S_INTERFACE_NOT_FOUND,     // NSI_S_INTERFACE_NOT_FOUND
    RPC_S_ENTRY_NOT_FOUND,         // NSI_S_ENTRY_NOT_FOUND
    RPC_S_NAME_SERVICE_UNAVAILABLE,// NSI_S_NAME_SERVICE_UNAVAILABLE
    RPC_S_ACCESS_DENIED,           // NSI_S_NO_NS_PRIVILEGE
    RPC_S_UNSUPPORTED_NAME_SYNTAX, // NSI_S_UNSUPPORTED_NAME_SYNTAX
    RPC_S_NOT_ALL_OBJS_UNEXPORTED, // NSI_S_NOTHING_TO_UNEXPORT
    RPC_S_INVALID_NAME_SYNTAX,     // NSI_S_INVALID_NAME_SYNTAX
    RPC_S_NO_CONTEXT_AVAILABLE,    // NSI_S_INVALID_NS_HANDLE
    RPC_S_OUT_OF_RESOURCES,        // NSI_S_INVALID_OBJECT
    RPC_S_NOT_ALL_OBJS_UNEXPORTED, // NSI_S_NOT_ALL_OBJS_UNEXPORTED
    RPC_S_INVALID_STRING_BINDING,  // NSI_S_INVALID_STRING_BINDING
    RPC_S_INTERNAL_ERROR,          // NSI_S_SOME_OTHER_ERROR
    RPC_S_NOTHING_TO_EXPORT,       // NSI_S_NOTHING_TO_EXPORT
    RPC_S_CANNOT_SUPPORT,          // NSI_S_UNIMPLEMENTED_API
    RPC_S_NOTHING_TO_EXPORT,       // NSI_S_NO_INTERFACES_EXPORTED
    RPC_S_INCOMPLETE_NAME,         // NSI_S_INCOMPLETE_NAME
    RPC_S_INVALID_VERS_OPTION,     // NSI_S_INVALID_VERS_OPTION
    RPC_S_NO_MORE_MEMBERS,         // NSI_S_NO_MORE_MEMBERS
    RPC_S_ENTRY_ALREADY_EXISTS,    // NSI_S_ENTRY_ALREADY_EXISTS
    RPC_S_OUT_OF_MEMORY,           // NSI_S_OUT_OF_MEMORY
    RPC_S_GROUP_MEMBER_NOT_FOUND,  // NSI_S_GROUP_MEMBER_NOT_FOUND
    RPC_S_SERVER_UNAVAILABLE,      // NSI_S_NO_MASTER_LOCATOR
    RPC_S_ENTRY_TYPE_MISMATCH,	   // NSI_S_ENTRY_TYPE_MISMATCH
    RPC_S_NOT_ALL_OBJS_EXPORTED,   // NSI_S_NOT_ALL_OBJS_EXPORTED
    RPC_S_INTERFACE_NOT_EXPORTED,  // NSI_S_INTERFACE_NOT_EXPORTED
    RPC_S_PROFILE_NOT_ADDED,       // NSI_S_PROFILE_NOT_ADDED
    RPC_S_PRF_ELT_NOT_ADDED,       // NSI_S_PRF_ELT_NOT_ADDED
    RPC_S_PRF_ELT_NOT_REMOVED,	   // NSI_S_PRF_ELT_NOT_REMOVED
    RPC_S_GRP_ELT_NOT_ADDED,	   // NSI_S_GRP_ELT_NOT_ADDED
    RPC_S_GRP_ELT_NOT_REMOVED      // NSI_S_GRP_ELT_NOT_REMOVED
};



UNSIGNED16
MapException(
    IN RPC_STATUS Exception
    )
/*++

Routine Description:

    Map a RPC exception to a NSI status code.

Arguments:

    Exception - Stub generated exception code.

Returns:

    NSI status code
--*/
{

#ifdef NTENV

    // If an NT access fault was raised, re-raise it.

    if (Exception == 0xc0000005)
        RpcRaiseException(Exception);
#endif

    switch(Exception)
    {
      case RPC_X_SS_CONTEXT_MISMATCH:
      case RPC_X_SS_IN_NULL_CONTEXT:
      case RPC_S_INVALID_BINDING:
        return(NSI_S_INVALID_NS_HANDLE);

      case RPC_S_OUT_OF_MEMORY:
        return(NSI_S_OUT_OF_MEMORY);

      case RPC_X_ENUM_VALUE_OUT_OF_RANGE:
        return (NSI_S_UNIMPLEMENTED_API);
    }

    return(NSI_S_NAME_SERVICE_UNAVAILABLE);
}


WIDE_STRING::WIDE_STRING(
    IN unsigned char * AsciiString OPTIONAL
    )

/*++

Routine Description:

    Make a UNICODE string from an ASCII string.

Arguments:

    AsciiString - 8 bit string to widen to 16 bits.

Returns:

    String is set to new value.  If there was an allocation error, then
    the value is set to AllocError.

--*/
{
    if (!AsciiString)
        {
        String = 0;
        AllocMode = AllocReference;
        return;
        }

    int Size = (strlen((CONST_CHAR *) AsciiString) + 1) * sizeof(unsigned short);

    if (! (String = (unsigned short *)I_RpcAllocate(Size)))
        {
        AllocMode = AllocError;
        return;
        }

    AllocMode = AllocMemory;

#ifdef NTENV
    AsciiToUnicodeNT(String, AsciiString);
#else
    for (unsigned short *pT = String; *pT++ = *AsciiString++;) ;
#endif

}

#ifndef NTENV

int
UnicodeToAscii(
    unsigned short *UnicodeString
    )
/*++

Routine Description:

    Make a  ASCII string from an UNICODE string.  This is done in
    place so the string becomes ASCII.

Arguments:

    UnicodeString - unicode string to convert

Returns:

    1 if conversion was OK, 0 if there was an error.

--*/
{
    unsigned char * AsciiString;

    for (AsciiString = (unsigned char *) UnicodeString;
         *UnicodeString <= 0xff && *UnicodeString; )

         *AsciiString++ = *UnicodeString++;

    *AsciiString = 0;
    return((*UnicodeString == 0)? RPC_S_OK: RPC_S_OK);
}

#endif


void *
#if defined(WIN32)
__cdecl
#endif
operator new(
        size_t size
        )
{

    return(I_RpcAllocate(size));
}

void
#if defined(WIN32)
__cdecl
#endif
operator delete(
           void * p
           )
{

    I_RpcFree(p);
}


void CallExportInit() {}


unsigned char *
CopyString(
    IN char * String
    )

/*++

Routine Description:

    Copy a string.

Arguments:

    String - to copy

Returns:

    pointer to a copy, Nil if out of memory.

--*/
{
    unsigned char * pReturn;

    if (!String || !( pReturn = new unsigned char [strlen(String)+1]))
        return(0);

    return ((unsigned char *) strcpy((char *) pReturn, (CONST_CHAR *) String));
}


void
GetDefaultEntrys(
    IN void * Key
    )

/*++

Routine Description:

    Get the default Entry name and syntax type form the registry.

Arguments:

    Key - open registry handle

--*/
{
    // While we have the registry open, get the default syntax entrys.

    if (! fSyntaxDefaultsLoaded)
        {
        unsigned char *SyntaxValue;

        if (SyntaxValue = RegGetString(Key, "DefaultSyntax"))
            {
            DefaultSyntax = atoi((char *)SyntaxValue);
            delete SyntaxValue;
            }

        if (SyntaxValue = RegGetString(Key, "DefaultEntry"))
            {
            DefaultName = new WIDE_STRING(SyntaxValue);
            delete SyntaxValue;
            }

        fSyntaxDefaultsLoaded = 1;
        }
}


#if !defined(NTENV) && DBG


void
RtlAssert(
    void * FailedAssertion,
    void * FileName,
    unsigned long LineNumber,
    char * Message
    )
{
    UNUSED(Message);

#if defined(OS212)

    printf("Assert failed %s in %s line %ld\n",
        FailedAssertion, FileName, LineNumber);

#elif defined(WIN)


    char Buffer[300];
    sprintf(Buffer, "Assert failed %s in %s line %ld\n",
        FailedAssertion, FileName, LineNumber);

    OutputDebugString(Buffer);

#endif

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\c\makefile.inc ===
LIBC_LIB=$(SDK_LIB_PATH)\libcmt.lib

LINKER_FLAGS=$(LINKER_FLAGS) -map

#STDFLAGS= /c /Zel /Zp8 /Gy /MT $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
#          /QIfdiv- /QI6 /QIf /GB /Gm- /Gi- /GR- /GX- $(STRING_POOLING) $(MFC_FLAGS)

#CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) \
#              $(BROWSER) $(386_PERFFLAGS) $(USER_C_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\c\drtc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drtc.cxx
//
//--------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include "drt.h"    // header file generated by MIDL compiler

void __cdecl main(int argc, char **argv)
{
    unsigned char * pszString     = (unsigned char *)"drt";
    WCHAR * pszEntryName            = L"/.:/drtsrv_01";
    WCHAR * pszGrpEntryName1        = L"/.:/drtgrp_01";
    WCHAR * pszPrfEntryName1        = L"/.:/drtprf_01";
    WCHAR * pszStrBinding           = NULL;
    RPC_NS_HANDLE hdrt;
    RPC_BINDING_HANDLE bhdrt;
    RPC_IF_ID          ifid;
    unsigned long fNameSyntaxType = RPC_C_NS_SYNTAX_DEFAULT;
    RPC_STATUS status;
    unsigned long ulCode;
    short fSuccess = 0;
    short fContinue = 1;
    short i;
    WCHAR *pMemberName;
    WCHAR *pAnnotation;
    ULONG dwPriority = 0;

    RpcTryExcept {
        status = RpcNsBindingImportBegin(fNameSyntaxType,
                                         pszEntryName,
                                         drtsrv_01_v1_0_c_ifspec,
                                         NULL,
                                         &hdrt);
        printf("RpcNsBindingImportBegin returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    if ( status != RPC_S_OK )
        fContinue = 0;

    /* The loop is present because the name service may contain "stale" */
    /* and unusable binding handlers.  This is part of the DCE design.  */
    while( fContinue )
    {
        status = RpcNsBindingImportNext(hdrt,
                                        &bhdrt);
        printf("RpcNsBindingImportNext returned 0x%x\n", status);

        if ( (status == RPC_S_NO_MORE_BINDINGS) ||
             (status == RPC_S_NAME_SERVICE_UNAVAILABLE ) )
            break;

        if (status != RPC_S_OK)
            continue;

        RpcBindingToStringBinding( bhdrt, &pszStrBinding );
        printf("StringBinding: %s\n", pszStrBinding );
        RpcStringFree(&pszStrBinding);

        RpcTryExcept {
            printf("Calling remote procedure HelloProc with string %s\n",
                   pszString);
            HelloProc(bhdrt, pszString);
            fContinue = 0;
            fSuccess = 1;
        }
        RpcExcept(1) {
            ulCode = RpcExceptionCode();
            printf("RPC Runtime raised exception 0x%x\n", ulCode);
            status = RpcBindingFree(&bhdrt);
            printf("RpcBindingFree returned 0x%x\n", status);
            fContinue = 1;
        }
        RpcEndExcept

    }

    RpcTryExcept {
        status = RpcNsBindingImportDone(&hdrt);
        printf("RpcNsBindingImportDone returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    if ( fSuccess )
    {
        RpcTryExcept {
            Shutdown(bhdrt);  // Shutdown is a remote procedure
        }
        RpcExcept(1) {
            ulCode = RpcExceptionCode();
            printf("RPC runtime raised exception 0x%x\n", ulCode);
        }
        RpcEndExcept

        status = RpcBindingFree(&bhdrt);
        printf("RpcBindingFree returned 0x%x\n", status);
    }

    exit(0);

}  // end main()


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file drtc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\client\ntutil.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    ntutil.c

Abstract:

    This is provides basic utilities for the NT DLL.

Author:

    Steven Zeck (stevez) 03/04/92

--*/

#include <nsi.h>
#include <string.h>

void
AsciiToUnicodeNT(
    OUT unsigned short *String,
    IN unsigned char *AsciiString
    )
/*++

Routine Description:

    Convert a ASCII string to unicode via the NT librarys

Arguments:

    String - place to put result

    AsciiString - string to convert

--*/
{
    while(*String++ = RtlAnsiCharToUnicodeChar ((PUCHAR *) &AsciiString)) ;
}

int
UnicodeToAscii(
    unsigned short *WideCharString
    )
/*++

Routine Description:

    Make a  ASCII string from an UNICODE string.  This is done in
    place so the string becomes ASCII.

Arguments:

    UnicodeString - unicode string to convert

Returns:

    RPC_S_OK, RPC_S_OUT_OF_MEMORY

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    RtlInitUnicodeString(&UnicodeString, WideCharString);
    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);

    if (!NT_SUCCESS(NtStatus))
        return(RPC_S_OUT_OF_MEMORY);

    strcpy((char *)WideCharString, AnsiString.Buffer);
    RtlFreeAnsiString(&AnsiString);

    return(RPC_S_OK);
}


static RTL_CRITICAL_SECTION GlobalMutex;

extern "C" {
int
InitializeDLL (
    IN void * DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )
/*++

Routine Description:

    NT DLL initialization function. Allocate/free the global MUTEX.

Arguments:

    DllHandle - my module handle

    Reason - why this funciton is being called

    Context - the context pointer.

Returns:

    0 if there were no error during initialization, non 0 otherwise.

--*/
{
    NTSTATUS Status;

    UNUSED(Context);

    if (Reason == DLL_PROCESS_ATTACH)
        {
#ifndef RPC_NT31
        // API added for NT 3.11, don't call when building for NT 3.1

        DisableThreadLibraryCalls((HMODULE)DllHandle);
#endif

        Status = RtlInitializeCriticalSection(&GlobalMutex);

        if (! NT_SUCCESS(Status) )
            return(FALSE);

        }

    if (Reason == DLL_PROCESS_DETACH)
        {
        Status = RtlDeleteCriticalSection(&GlobalMutex);
        }

    return(TRUE);
}

}


void
GlobalMutexRequest (
    void
    )
/*++

Routine Description:

    Request the global mutex.

--*/
{
    NTSTATUS Status;

    Status = RtlEnterCriticalSection(&GlobalMutex);
}


void
GlobalMutexClear (
    void
    )
/*++

Routine Description:

    Clear the global mutex.

--*/
{
    NTSTATUS Status;

    Status = RtlLeaveCriticalSection(&GlobalMutex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\clean\makefile.inc ===
LIBC_LIB=$(SDK_LIB_PATH)\libcmt.lib

LINKER_FLAGS=$(LINKER_FLAGS) -map

#STDFLAGS= /c /Zel /Zp8 /Gy /MT $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
#          /QIfdiv- /QI6 /QIf /GB /Gm- /Gi- /GR- /GX- $(STRING_POOLING) $(MFC_FLAGS)

#CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) \
#              $(BROWSER) $(386_PERFFLAGS) $(USER_C_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\client\startsvc.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    startsvc.c

Abstract:

    This routine implements on-demand starting of the RpcSs service.

Author:

    Bharat Shah (barats) 4-5-92

Revision History:

--*/

#include <windows.h>
#include <rpc.h>
#include <winsvc.h>
#include <startsvc.h>

#define SUCCESS         0
#define RPCLOCATOR      "RPCLOCATOR"



RPC_STATUS 
StartServiceIfNecessary(
    void
    )
/*++

Routine Description:

    If the locator service has not yet been started, then we attempt to
    start it.

Returns:

    RPC_S_OK - The locator service is running.

    Service controller errors.


--*/
{

    SC_HANDLE           hServiceController = NULL;
    SC_HANDLE           hService = NULL;
    SERVICE_STATUS      ServiceStatus;
    DWORD               status;
    DWORD               Counter = 0L;
    BOOL                FirstTime = TRUE;
    unsigned long       ArgC = 0;
    char     __RPC_FAR *     ArgV[1] = { NULL };

    //
    // Get a handle to the service controller.
    //
    hServiceController = OpenSCManager(
                            NULL,
                            NULL,
                            GENERIC_READ);

    if (hServiceController == NULL)
       {
        status = GetLastError();
        return(status);
       }

    //
    // Get a handle to the service
    //
    hService = OpenService(
                hServiceController,
                RPCLOCATOR,
                GENERIC_READ|SERVICE_START);

    if (hService == NULL)
       {
        status = GetLastError();
        goto CleanExit;
       }

    //
    // Call StartService
    //
    /*
    if (!StartService(hService,ArgC,ArgV))
       {
          status = GetLastError();
          if (status == ERROR_SERVICE_ALREADY_RUNNING)
             status = RPC_S_OK;
          goto CleanExit;
       }
    */

    do
      {

        if (!QueryServiceStatus(hService,&ServiceStatus))
            {
              status = GetLastError();
              goto CleanExit;
            }

        switch(ServiceStatus.dwCurrentState)
        {

          case SERVICE_RUNNING:
                status = SUCCESS;
                goto CleanExit;
                break;

          case SERVICE_STOP_PENDING:
          case SERVICE_START_PENDING:
                if (!FirstTime && (Counter == ServiceStatus.dwCheckPoint))
                   {
                    status = ERROR_SERVICE_REQUEST_TIMEOUT;
                    goto CleanExit;
                   }
                else
                   {
                    FirstTime = FALSE;
                    Counter = ServiceStatus.dwCheckPoint;
                    Sleep(ServiceStatus.dwWaitHint);
                   }
                 break;
 
          case SERVICE_STOPPED:
                if (!StartService(hService,ArgC,ArgV))
                   {
                   status = GetLastError();
                   if (status == ERROR_SERVICE_ALREADY_RUNNING)
                               status = RPC_S_OK;
                   goto CleanExit;
                   }
                 Sleep(500);
                 break;

          default:
                 status = GetLastError();
                 goto CleanExit;
                 break;
       }
    }
   while (TRUE);

CleanExit:

    if(hServiceController != NULL) {
        (VOID) CloseServiceHandle(hServiceController);
    }
    if(hService != NULL) {
        (VOID) CloseServiceHandle(hService);
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\dynamic\makefile.inc ===
LIBC_LIB=$(SDK_LIB_PATH)\libcmt.lib

LINKER_FLAGS=$(LINKER_FLAGS) -map

#STDFLAGS= /c /Zel /Zp8 /Gy /MT $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
#          /QIfdiv- /QI6 /QIf /GB /Gm- /Gi- /GR- /GX- $(STRING_POOLING) $(MFC_FLAGS)

#CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) \
#              $(BROWSER) $(386_PERFFLAGS) $(USER_C_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\idl\makefile.inc ===
LIBC_LIB=$(SDK_LIB_PATH)\libcmt.lib

LINKER_FLAGS=$(LINKER_FLAGS) -map

#STDFLAGS= /c /Zel /Zp8 /Gy /MT $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
#          /QIfdiv- /QI6 /QIf /GB /Gm- /Gi- /GR- /GX- $(STRING_POOLING) $(MFC_FLAGS)

#CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) \
#              $(BROWSER) $(386_PERFFLAGS) $(USER_C_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\c\drtc.orig.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drtc.orig.cxx
//
//--------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include "drt.h"    // header file generated by MIDL compiler

void __cdecl main(int argc, char **argv)
{
    unsigned char * pszString     = (unsigned char *)"drt";
    WCHAR * pszEntryName            = L"/.:/drtsrv_01";
    WCHAR * pszGrpEntryName1        = L"/.:/drtgrp_01";
    WCHAR * pszPrfEntryName1        = L"/.:/drtprf_01";
    WCHAR * pszStrBinding           = NULL;
    RPC_NS_HANDLE hdrt;
    RPC_BINDING_HANDLE bhdrt;
    RPC_IF_ID          ifid;
    unsigned long fNameSyntaxType = RPC_C_NS_SYNTAX_DEFAULT;
    RPC_STATUS status;
    unsigned long ulCode;
    short fSuccess = 0;
    short fContinue = 1;
    short i;
    WCHAR *pMemberName;
    WCHAR *pAnnotation;
    ULONG dwPriority = 0;

    RpcTryExcept {
    status = RpcNsProfileEltInqBegin(
                          fNameSyntaxType,
                          pszPrfEntryName1,
                          RPC_C_PROFILE_ALL_ELT,
                          NULL,
                          0,
                          fNameSyntaxType,
                          NULL,
                          &hdrt
    );
    printf(" RpcNsProfileEltInqBegin returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    RpcTryExcept {
        status = RpcNsProfileEltInqNext(
                          hdrt,
                          &ifid,
                          &pMemberName,
                          &dwPriority,
                          &pAnnotation
        );
        printf("RpcNsProfileEltInqNext returned 0x%x\n", status);
        if (!status)
        {
            wprintf(L"Annotation: %s\n", pAnnotation);
            wprintf(L"MemberName: %s, Priority %d\n", pMemberName, dwPriority);
        }
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    RpcTryExcept {
        status = RpcNsProfileEltInqNext(
                          hdrt,
                          &ifid,
                          &pMemberName,
                          &dwPriority,
                          &pAnnotation
        );
        printf("RpcNsProfileEltInqNext returned 0x%x\n", status);
        if (!status)
        {
            wprintf(L"Annotation: %s\n", pAnnotation);
            wprintf(L"MemberName: %s, Priority %d\n", pMemberName, dwPriority);
        }
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    RpcTryExcept {
        status = RpcNsProfileEltInqDone(
                         &hdrt
        );
        printf("RpcNsProfileEltInqDone returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept


    RpcTryExcept {
    status = RpcNsGroupMbrInqBegin(
                          fNameSyntaxType,
                          pszGrpEntryName1,
                          fNameSyntaxType,
                          &hdrt
            );
    printf(" RpcNsGroupMbrInqBegin returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    *pMemberName = '\0';
    RpcTryExcept {
        status = RpcNsGroupMbrInqNext(
                          hdrt,
                          &pMemberName
        );
        printf("RpcNsGroupMbrInqNext returned 0x%x\n", status);
        if (!status)
        {
            wprintf(L"MemberName: %s\n", pMemberName);
        }
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    RpcTryExcept {
        status = RpcNsGroupMbrInqDone(
                         &hdrt
        );
        printf("RpcNsGroupMbrInqDone returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept



    RpcTryExcept {
        status = RpcNsBindingImportBegin(fNameSyntaxType,
                                         pszGrpEntryName1,
                                         drtsrv_01_v1_0_c_ifspec,
                                         NULL,
                                         &hdrt);
        printf("RpcNsBindingImportBegin returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    if ( status != RPC_S_OK )
        fContinue = 0;

    /* The loop is present because the name service may contain "stale" */
    /* and unusable binding handlers.  This is part of the DCE design.  */
    while( fContinue )
    {
        status = RpcNsBindingImportNext(hdrt,
                                        &bhdrt);
        printf("RpcNsBindingImportNext returned 0x%x\n", status);

        if ( (status == RPC_S_NO_MORE_BINDINGS) ||
             (status == RPC_S_NAME_SERVICE_UNAVAILABLE ) )
            break;

        if (status != RPC_S_OK)
            continue;

        RpcBindingToStringBinding( bhdrt, &pszStrBinding );
        printf("StringBinding: %s\n", pszStrBinding );
        RpcStringFree(&pszStrBinding);

        RpcTryExcept {
            printf("Calling remote procedure HelloProc with string %s\n",
                   pszString);
            HelloProc(bhdrt, pszString);
            fContinue = 0;
            fSuccess = 1;
        }
        RpcExcept(1) {
            ulCode = RpcExceptionCode();
            printf("RPC Runtime raised exception 0x%x\n", ulCode);
            status = RpcBindingFree(&bhdrt);
            printf("RpcBindingFree returned 0x%x\n", status);
            fContinue = 1;
        }
        RpcEndExcept

    }

    RpcTryExcept {
        status = RpcNsBindingImportDone(&hdrt);
        printf("RpcNsBindingImportDone returned 0x%x\n", status);
    }
    RpcExcept(1) {
        ulCode = RpcExceptionCode();
        printf("RPC Runtime raised exception 0x%x\n", ulCode);
        fContinue = 0;
    }
    RpcEndExcept

    if ( fSuccess )
    {
        RpcTryExcept {
            Shutdown(bhdrt);  // Shutdown is a remote procedure
        }
        RpcExcept(1) {
            ulCode = RpcExceptionCode();
            printf("RPC runtime raised exception 0x%x\n", ulCode);
        }
        RpcEndExcept

        status = RpcBindingFree(&bhdrt);
        printf("RpcBindingFree returned 0x%x\n", status);
    }

    exit(0);

}  // end main()


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file drtc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\clean\main.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       main.cxx
//
//--------------------------------------------------------------------------

// test routine for create/delete
#include "rpc.h"                                                               
#include "rpcndr.h"                                                            
#include <stdio.h>

// copied from Catalin's test-------------------
RPC_DISPATCH_TABLE nstest01_v1_0_DispatchTable =
    {
    2,
    nstest01_table
    };

extern RPC_DISPATCH_TABLE nstest01_v1_0_DispatchTable;

static const RPC_SERVER_INTERFACE nstest01___RpcServerInterface =                                                      
    {                                                                                                                  
    sizeof(RPC_SERVER_INTERFACE),                                                                                      
    {{0xdeadbeef,0x6b56,0x11d0,{0xbb,0xd7,0x00,0xc0,0x4f,0xd7,0xcf,0xc9}},{1,0}},                                      
    {{0xdeadbeef,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},                                      
    &nstest01_v1_0_DispatchTable,                                                                                      
    0,                                                                                                                 
    0,                                                                                                                 
    0,                                                                                                                 
    0,                                                                                                                 
    0                                                                                                                  
    };                                                                                                                 

RPC_IF_HANDLE nstest01_v1_0_s_ifspec = (RPC_IF_HANDLE)& nstest01___RpcServerInterface;                                 
//------------------------------------

void __cdecl main(int argc, char *argv[])
{
    RPC_STATUS status;
/*    RPC_IF_HANDLE  intf;
    RPC_BINDING_VECTOR bv;
    UUID_VECTOR ov;
        
			hIfSpec = nstest01_v1_0_s_ifspec;

			status = RpcServerRegisterIf(	nstest01_v1_0_s_ifspec, 
											NULL,   
											NULL);  
			printf("RpcServerRegisterIf returned 0x%x\n", status);
    
			if (MSG_OK != status){
				dwExitCode = (DWORD)status;
				break;
			}
			else
				fRegistered = 1;
		}
		else 
			hIfSpec = NULL;
    
    
		// BindingVec
		if( TEST_OPT_VALID_BIND == pTestOpt->m_nBindingVec ) {
			printf("CallingRpcServerUseProtseq...\n");
			status = RpcServerUseProtseq(   pszProtSeq[pTestOpt->m_nProtSeq], 
											cMaxCalls,    // max concurrent calls
											pszSecurity); // Security descriptor
			printf("RpcServerUseProtseq returned 0x%x\n", status);
			if (MSG_OK != status){
				dwExitCode = ERROR_MSG_USE_PROTSEQ;
				break;
			}
    
			status = RpcServerInqBindings(&pBindingVector);
			printf("RpcServerInqBindings returned 0x%x\n", status);
			if (MSG_OK != status){
				dwExitCode = (DWORD)status;
				break;
			}

			status = RpcServerInqBindings(&pbkBindingVector);
			printf("RpcServerInqBindings returned 0x%x\n", status);
			if (MSG_OK != status){
				dwExitCode = (DWORD)status;
				break;
			}


			if( hIfSpec ){
				status = RpcEpRegister(hIfSpec,
									   pBindingVector,
									   pUuidVect,
									   "");
				printf("RpcEpRegister returned 0x%x\n", status);
				if (MSG_OK != status){
					dwExitCode = (DWORD)status;
					break;
				}
				else
					fEndpoint = 1;
			}
		}
		else
			pBindingVector = NULL;

			
		if( NULL != pBindingVector ){
			status = RpcBindingReset( pBindingVector->BindingH[0] );
			printf("RpcBindingReset returned 0x%x\n", status);
		}


    status = RpcServerRegisterIf(nstest01_v1_0_s_ifspec, NULL, NULL); 

  // too many hoops
  */
    // create an entry
    status = RpcNsMgmtEntryCreate(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Create returned Status = 0x%x\n", status);

    // delete an entry
    status = RpcNsMgmtEntryDelete(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Delete returned Status = 0x%x\n", status);

    // create an entry
    status = RpcNsMgmtEntryCreate(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Create returned Status = 0x%x\n", status);

    // export to it

    status = RpcNsBindingExport(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08",
                        intf, bv, ov);
    printf("Export returned Status = 0x%x\n", status);

    // delete it
    status = RpcNsMgmtEntryDelete(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Delete returned Status = 0x%x\n", status);


    // create an entry
    status = RpcNsMgmtEntryCreate(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Create returned Status = 0x%x\n", status);

    // export to the group entry

    // delete the entry
    status = RpcNsMgmtEntryDelete(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Delete returned Status = 0x%x\n", status);


    // create an entry
    status = RpcNsMgmtEntryCreate(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Create returned Status = 0x%x\n", status);

    // export it as profile entry

    // delete the entry
    status = RpcNsMgmtEntryDelete(RPC_C_NS_SYNTAX_DEFAULT, L"/.:/ns_test_08");
    printf("Delete returned Status = 0x%x\n", status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\s\makefile.inc ===
LIBC_LIB=$(SDK_LIB_PATH)\libcmt.lib

LINKER_FLAGS=$(LINKER_FLAGS) -map

#STDFLAGS= /c /Zel /Zp8 /Gy /MT $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
#          /QIfdiv- /QI6 /QIf /GB /Gm- /Gi- /GR- /GX- $(STRING_POOLING) $(MFC_FLAGS)

#CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) \
#              $(BROWSER) $(386_PERFFLAGS) $(USER_C_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\s\drtp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drtp.cxx
//
//--------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "drt.h"    // header file generated by MIDL compiler

void HelloProc(handle_t hHello, unsigned char *pszString)
{
    printf("%s\n", pszString);
    return;
}

void Shutdown(handle_t hHello)
{
    RPC_STATUS status;

    printf("Calling RpcMgmtIsServerListening\n");
    status = RpcMgmtIsServerListening(NULL);
    printf("RpcMgmtIsServerListening returned: 0x%x\n", status);

    if ( status == RPC_S_OK )
    {
        printf("Calling RpcMgmtStopServerListening\n");
        status = RpcMgmtStopServerListening(NULL);
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
    }

}

/* end file drtp.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\export\exp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       exp.cxx
//
//--------------------------------------------------------------------------

// drt that mainly puts things into the locator
//
//

#include "drt.hxx"

void __cdecl main(int argc, char **argv)
{
    RPC_STATUS             status;
    RPC_BINDING_VECTOR   * pBindingVector = NULL;
    RPC_IF_HANDLE          IfSpec;
    UUID_VECTOR          * objuuid;
    RPC_IF_ID              intfid;
    int                    fFailed = 0;

    intfid.Uuid = ifid[0];
    intfid.VersMajor = 42;
    intfid.VersMinor = 42;

    FormBindingVector(Bindings, 1, &pBindingVector);

    FormObjUuid(objid, 2, &objuuid);

    // form a dynamic endpoint.
    unsigned int    cMinCalls       = 1;
    unsigned int    cMaxCalls       = 20;
    unsigned char * pszSecurity     = NULL;

    status = RpcServerUseProtseq(L"ncacn_ip_tcp", cMaxCalls, pszSecurity);
    printf("RpcServerUseProtseqs returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcServerInqBindings(&pBindingVector);
    printf("RpcServerInqBindings returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    FormIfHandle(ifid[1], &IfSpec);

    status = RpcNsBindingExport(RPC_C_NS_SYNTAX_DEFAULT,
                                szDynSrvEntryName,
                                IfSpec,
                                pBindingVector,
                                NULL);
     printf("RpcNsBindingExport returned 0x%x\n", status);
     if (status)
        fFailed = 1;

    status = RpcNsMgmtEntryCreate(RPC_C_NS_SYNTAX_DEFAULT,
			     szGrpEntryName[0]);
    if (status)
       fFailed = 1;

    printf("RpcNsMgmtEntryCreate returned 0x%x\n", status);

    FormIfHandle(ifid[0], &IfSpec);

    status = RpcNsBindingExport(RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                szSrvEntryName[0],        // nsi entry name
                                IfSpec,
                                pBindingVector,
                                objuuid);                 // UUID vector

    if (status)
       fFailed = 1;

    printf("RpcNsBindingExport returned 0x%x\n", status);

    status = RpcNsGroupMbrAdd(RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szGrpEntryName[0],
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szSrvEntryName[0]);

    printf("RpcNsGroupMbrAdd 1 returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsGroupMbrAdd(RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szGrpEntryName[0],
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szSrvEntryName[1]);

    printf("RpcNsGroupMbrAdd 2 returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsProfileEltAdd(
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szPrfEntryName[0],
                              &intfid,
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szGrpEntryName[0],
                              1,
                              L"Group Entry 1 Trying to test the length of the string possible");
    printf("RpcNsProfileEltAdd 1 returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsProfileEltAdd(
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szPrfEntryName[0],
                              &intfid,
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szGrpEntryName[1],
                              2,
                              L"Group Entry 2");
    printf("RpcNsProfileEltAdd 2 returned 0x%x\n", status);
    if (status)
       fFailed = 1;



    if (fFailed)
       printf("Export Test FAILED\n");
    else
       printf("Export Test PASSED\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\inc\drtcom.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drtcom.cxx
//
//--------------------------------------------------------------------------

// the common functions req'd by more than 1 exe in this drts

#include "rpc.h"
#include "rpcnsi.h"
#include "stdio.h"
#include "stdlib.h"

WCHAR *ep[] =       { L"1025",
		      L"1026"
		    };

void FormIfHandle(GUID ifid, RPC_IF_HANDLE *IfSpec)
{
     RPC_SERVER_INTERFACE  *intf = new RPC_SERVER_INTERFACE;
     RPC_DISPATCH_TABLE    *pdispatch = new RPC_DISPATCH_TABLE;
     RPC_DISPATCH_FUNCTION *pfn = new RPC_DISPATCH_FUNCTION;

     intf->Length = sizeof(RPC_SERVER_INTERFACE);

     (intf->InterfaceId).SyntaxGUID = ifid;
     (intf->InterfaceId).SyntaxVersion.MajorVersion = 1;
     (intf->InterfaceId).SyntaxVersion.MinorVersion = 0;

     (intf->TransferSyntax).SyntaxGUID = ifid;
     (intf->TransferSyntax).SyntaxVersion.MajorVersion = 1;
     (intf->TransferSyntax).SyntaxVersion.MinorVersion = 0;

     intf->RpcProtseqEndpointCount = 0;
     intf->RpcProtseqEndpoint = NULL;
     intf->InterpreterInfo = NULL;
     intf->Flags = 0;

     pfn[0] = NULL;

     pdispatch->DispatchTableCount = 1;
     pdispatch->DispatchTable = pfn;
     pdispatch->Reserved = 0;

     intf->DispatchTable = pdispatch; // &m_DispatchTable;

     *IfSpec = (RPC_IF_HANDLE)intf;
}

void FormBindingVector(WCHAR **Binding, ULONG num, RPC_BINDING_VECTOR **BindVec)
{
    ULONG i;
    RPC_BINDING_HANDLE *pBindHandle;
    RPC_STATUS		status = 0;

//    RpcStringBindingCompose(NULL, L"", L"0.0.0.0",
    for (i = 0; i < num; i++) {
       status = RpcServerUseProtseqEp(Binding[i], 20, ep[i], NULL);
    }

    status = RpcServerInqBindings(BindVec);
}

void FormObjUuid(GUID *pguid, ULONG num, UUID_VECTOR **objuuid)
{
    ULONG i;
    *objuuid = (UUID_VECTOR *)malloc(sizeof(ULONG)+sizeof(UUID *)*num);
    (*objuuid)->Count = num;

    for (i = 0; i < num; i++) {
       (*objuuid)->Uuid[i] = pguid+i;
    }
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\dynamic\exp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       exp.cxx
//
//--------------------------------------------------------------------------

// drt that mainly puts things into the locator
//
//

#include "drt.hxx"

void __cdecl main(int argc, char **argv)
{
    RPC_STATUS             status;
    RPC_BINDING_VECTOR   * pBindingVector = NULL;
    RPC_IF_HANDLE          IfSpec;
    UUID_VECTOR          * objuuid;
    int                    fFailed = 0;

    // form a dynamic endpoint.
    unsigned int    cMinCalls       = 1;
    unsigned int    cMaxCalls       = 20;
    unsigned char * pszSecurity     = NULL;

    status = RpcServerUseAllProtseqs(cMaxCalls, pszSecurity);
    printf("RpcServerUseProtseqs returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcServerInqBindings(&pBindingVector);
    printf("RpcServerInqBindings returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    FormIfHandle(ifid[1], &IfSpec);
    status = RpcNsBindingExport(RPC_C_NS_SYNTAX_DEFAULT,
                                szDynSrvEntryName,
                                IfSpec,
                                pBindingVector,
                                NULL);
    printf("RpcNsBindingExport returned 0x%x\n", status);
    if (status)
        fFailed = 1;

    if (fFailed)
       printf("Export Test FAILED\n");
    else
       printf("Export Test PASSED\n");


    RpcServerListen(10, 20, 0);


}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\clean\testclean.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       testclean.cpp
//
//--------------------------------------------------------------------------

// code to delete the contents of a container
//
//


#ifdef UNICODE
#define _UNICODE 1
#endif

//#include <sys/types.h>
//#include <sys/stat.h>

//
// CRunTime Includes
//

//#include <limits.h>
//#include <io.h>

#include <stdio.h>
#include <objbase.h>
#include <activeds.h>

#include <rpc.h>
#include <ole2.h>

#include "oledb.h"
#include "oledberr.h"
#include "msdadc.h"

#define RETURN_ON_FAILURE(hr)   \
        if (FAILED(hr)) {     \
                return hr;   \
        }

#define _MAX_LENGTH					500
#define MAX_ADS_ENUM				10
#define CLASSNAME                   L"objectClass" 

HRESULT
GetNextEnum(
    IEnumVARIANT * pEnum,
    IADs       **ppADs
    )
{

    HRESULT hr;
    VARIANT VariantArray[MAX_ADS_ENUM];
    IDispatch *pDispatch = NULL;


    hr = ADsEnumerateNext(
                    pEnum,
                    1,
                    VariantArray,
                    NULL
                    );

    if (hr == S_FALSE)
        return hr;

    RETURN_ON_FAILURE(hr);

    pDispatch = VariantArray[0].pdispVal;
    memset(VariantArray, 0, sizeof(VARIANT)*MAX_ADS_ENUM);
    hr = pDispatch->QueryInterface(IID_IADs, (void **) ppADs) ;
    pDispatch->Release();
    return(S_OK);
}

HRESULT GetPropertyListAlloc(IADs *pADs, LPOLESTR pszPropName, 
								DWORD *pCount, LPOLESTR **ppList)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;
    VARIANT var;

    *pCount = 0;
    VariantInit(&var);

    hr = pADs->Get(pszPropName, &var);
    
    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        return S_OK;
    }

    RETURN_ON_FAILURE(hr);

    if(!((V_VT(&var) &  VT_VARIANT)))
    {
        return(E_FAIL);
    }

    //
    // The following is a work around for the package detail field
    //
    if (!V_ISARRAY(&var))
    {
        (*ppList) = (LPOLESTR *) CoTaskMemAlloc(sizeof(LPOLESTR));
        *pCount = 1;
        *(*ppList) = (LPOLESTR) CoTaskMemAlloc (sizeof(WCHAR) * (wcslen(var.bstrVal)+1));
        wcscpy (*(*ppList), var.bstrVal);
        VariantClear(&var);
        return S_OK;
    }
    
    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) 
    {
        return E_FAIL;
    }
    //
    // Check that there is atleast one element in this array
    //
    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0)
    {
        return S_OK; // was E_FAIL;
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    RETURN_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    RETURN_ON_FAILURE(hr);

    (*ppList) = (LPOLESTR *) CoTaskMemAlloc(sizeof(LPOLESTR)*(dwSUBound-dwSLBound+1));

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        if (i <= dwSUBound) 
        {
            (*ppList)[*pCount] = (LPOLESTR) CoTaskMemAlloc 
                 (sizeof (WCHAR) * (wcslen(v.bstrVal) + 1));
            wcscpy ((*ppList)[*pCount], v.bstrVal);
            VariantClear(&v);
            (*pCount)++;
        }
    }

    VariantClear(&var);
    return(S_OK);
}

void EnumerateAndDelete(WCHAR *szContainerName)
{
	HRESULT			 hr=S_OK;
	IADsContainer	*pADsContainer=NULL, *pADssubContainer=NULL;
    IEnumVARIANT	*pEnum=NULL;
	IADs			*pADs=NULL;
	WCHAR			*szFullName=NULL, *szName=NULL;
    WCHAR			**ppswClassNameList=NULL;
	ULONG			 sz=0;

	hr = ADsGetObject(szContainerName, IID_IADsContainer, (void **)&pADsContainer);

	if (SUCCEEDED(hr))
		hr = ADsBuildEnumerator(pADsContainer, &pEnum);

	if (SUCCEEDED(hr))
	{
		for (;;)
		{
		    hr = GetNextEnum(pEnum, &pADs);
			if (hr != S_OK)
				break;

			hr = pADs->get_ADsPath(&szFullName);
			if (FAILED(hr))
				continue;

			wprintf(L"Deleting %s \n", szFullName);
			hr = pADs->QueryInterface(IID_IADsContainer, (void **)&pADssubContainer);

			if (SUCCEEDED(hr))
			{
				pADssubContainer->Release();
				EnumerateAndDelete(szFullName);
			}
			
	        hr = GetPropertyListAlloc(pADs, CLASSNAME, &sz, &ppswClassNameList);
			if (FAILED(hr))
				continue;
			
			SysFreeString(szFullName);

			hr = pADs->get_Name(&szName);
			if (FAILED(hr))
				continue;

			pADsContainer->Delete(ppswClassNameList[sz-1], szName);
			
			SysFreeString(szName);
		}
	}
	if (pADsContainer)
		pADsContainer->Release();
	return;
}

void __cdecl main(int argc, char *argv[])
{
	WCHAR szContainer [_MAX_LENGTH+1];

	if (argc != 2)
	{
		printf("Usage: %s <Full ContainerName that has to be emptied>", argv[0]);
		printf("\tThe container itself will remain\n");
		return;
	}

	CoInitialize(NULL);
	MultiByteToWideChar(CP_ACP, 0, argv[1], strlen(argv[1]) + 1, 
                szContainer, _MAX_LENGTH);

	EnumerateAndDelete(szContainer);
	CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\lookup\lkp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       lkp.cxx
//
//--------------------------------------------------------------------------

// drt that tries to lookup the various things.

#include "drt.hxx"

RPC_STATUS LookupCountAndPrint(RPC_NS_HANDLE NsHandle, int exp)
{
    int 		   i=0;
    RPC_STATUS 		   status = 0;
    RPC_BINDING_VECTOR   * pBindingVec;
    WCHAR		 * szBinding;

    for (;!status;) {
       status = RpcNsBindingLookupNext(
				  NsHandle,
				  &pBindingVec
				  );
       printf("RpcNsBindingLookupNext returned 0x%x\n", status);

       if (!status) {
	  status = RpcBindingToStringBinding(pBindingVec->BindingH[0], &szBinding);
	  i++;
	  printf("%d. Binding = \"%S\"\n", i, szBinding);
       }
    }
    if (i != exp)
       return 1;
    return 0;
}

void __cdecl main(int argc, char **argv)
{
    RPC_STATUS             status;
    RPC_NS_HANDLE          NsHandle;
    WCHAR                * Annotation, *MemberName;
    UUID_VECTOR		 * objuuid = NULL;
    RPC_IF_HANDLE          IfSpec;
    RPC_IF_ID		   ifidgot;
    DWORD		   Priority;
    int			   fFailed = 0;
    UUID		   uuidfound;

    FormObjUuid(objid, 1, &objuuid);

    FormIfHandle(ifid[0], &IfSpec);

    status = RpcNsMgmtSetExpAge(1);

    printf("RpcNsMgmtSetExpAge returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    // no interface, no objuuid
    printf("**Test: Entry Name, No intf, No objuuid\n");
    status = RpcNsBindingLookupBegin(
                                RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                szSrvEntryName[0],        // nsi entry name
                                NULL,
                                NULL,
                                1,
                				&NsHandle);

    printf("RpcNsBindingLookupBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = LookupCountAndPrint(NsHandle, 2);
    if (status)
       fFailed = 1;

    status = RpcNsBindingLookupDone(
			       &NsHandle
			       );
    printf("RpcNsBindingLookupDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    // 1 obj uuid
    printf("**Test: Entry Name, No intf, 1 objuuid\n");
    status = RpcNsBindingLookupBegin(
                                RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                szSrvEntryName[0],        // nsi entry name
                                NULL,
                                objid,
                                1,
				&NsHandle);

    printf("RpcNsBindingLookupBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = LookupCountAndPrint(NsHandle, 1);
    if (status)
       fFailed = 1;

    status = RpcNsBindingLookupDone(
			       &NsHandle
			       );
    printf("RpcNsBindingLookupDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    printf("**Test: No Entry Name, 1 intf, No objuuid\n");
    // Null entry name, 1 intf, no obj uuid
    status = RpcNsBindingLookupBegin(
                                RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                NULL,        // nsi entry name
                                IfSpec,
                                NULL,
                                1,
				&NsHandle);

    printf("RpcNsBindingLookupBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = LookupCountAndPrint(NsHandle, 2);
    if (status)
       fFailed = 1;

    status = RpcNsBindingLookupDone(
			       &NsHandle
			       );
    printf("RpcNsBindingLookupDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    printf("**Test: Enumerating Profiles\n");
    status = RpcNsProfileEltInqBegin(
				    RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				    szPrfEntryName[0],
				    RPC_C_PROFILE_ALL_ELTS,
				    NULL,
				    RPC_C_VERS_ALL,
				    RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				    NULL,
				    &NsHandle);
    printf("RpcNsProfileEltInqBegin returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsProfileEltInqNext(
				    NsHandle,
				    &ifidgot,
				    &MemberName,
				    &Priority,
				    &Annotation);
    printf("RpcNsProfileEltInqNext returned 0x%x\n\n", status);
    printf("MemberName = \"%S\", Priority = %d, Annotation = \"%S\"\n", MemberName, Priority,
				       Annotation);
    if (status)
       fFailed = 1;

    status = RpcNsProfileEltInqNext(
				    NsHandle,
				    &ifidgot,
				    &MemberName,
				    &Priority,
				    &Annotation);
    printf("RpcNsProfileEltInqNext returned 0x%x\n\n", status);
    printf("MemberName = \"%S\", Priority = %d, Annotation = \"%S\"\n", MemberName, Priority,
				       Annotation);
    if (status)
       fFailed = 1;

    status = RpcNsProfileEltInqNext(
				    NsHandle,
				    &ifidgot,
				    &MemberName,
				    &Priority,
				    &Annotation);
    printf("RpcNsProfileEltInqNext returned 0x%x\n", status);
    if (!status)
       fFailed = 1;

    status = RpcNsProfileEltInqDone(&NsHandle);
    printf("RpcNsProfileEltInqDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    printf("**Test: Enumerating Groups\n");

    status = RpcNsGroupMbrInqBegin(
				    RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				    szGrpEntryName[0],
				    RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				    &NsHandle);
    printf("RpcNsProfileEltInqBegin returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsGroupMbrInqNext(
			     	 NsHandle,
    				 &MemberName
	    			 );
    printf("RpcNsProfileEltInqNext returned 0x%x\n\n", status);
    printf("MemberName = \"%S\"\n", MemberName);
    if (status)
       fFailed = 1;

    status = RpcNsGroupMbrInqNext(
			     	 NsHandle,
				 &MemberName
				 );
    printf("RpcNsProfileEltInqNext returned 0x%x\n\n", status);
    printf("MemberName = \"%S\"\n", MemberName);

    if (status)
       fFailed = 1;

    status = RpcNsGroupMbrInqNext(
			     	 NsHandle,
				 &MemberName
				 );
    printf("RpcNsProfileEltInqNext returned 0x%x\n\n", status);
    if (!status)
       fFailed = 1;

    status = RpcNsGroupMbrInqDone(&NsHandle);
    printf("RpcNsProfileEltInqDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    printf("**Test: Lookup using Groups\n");
    printf("**Test: Entry Name, No intf, No objuuid\n");

    status = RpcNsBindingLookupBegin(
                                RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                szGrpEntryName[0],        // nsi entry name
                                NULL,
                                NULL,
                                1,
				&NsHandle);

    printf("RpcNsBindingLookupBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = LookupCountAndPrint(NsHandle, 2);
    if (status)
       fFailed = 1;

    status = RpcNsBindingLookupDone(
			       &NsHandle
			       );
    printf("RpcNsBindingLookupDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;


    printf("**Test: Lookup using Profiles\n");
    printf("**Test: Entry Name, No intf, No objuuid\n");
    status = RpcNsBindingLookupBegin(
			        RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				szPrfEntryName[0],        // nsi entry name
                                NULL,
                                NULL,
                                1,
				&NsHandle);

    printf("RpcNsBindingLookupBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = LookupCountAndPrint(NsHandle, 2);
    if (status)
       fFailed = 1;

    status = RpcNsBindingLookupDone(
			       &NsHandle
			       );
    printf("RpcNsBindingLookupDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;


    printf("**Test: Object Inquiry\n");
    printf("**Test: Entry Name\n");
    status = RpcNsEntryObjectInqBegin(
				RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				szSrvEntryName[0],        // nsi entry name
				&NsHandle);

    printf("RpcNsEntryObjectInqBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsEntryObjectInqNext(NsHandle, &uuidfound);
    printf("RpcNsEntryObjectInqNext returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsEntryObjectInqNext(NsHandle, &uuidfound);
    printf("RpcNsEntryObjectInqNext returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsEntryObjectInqNext(NsHandle, &uuidfound);
    printf("RpcNsEntryObjectInqNext returned 0x%x\n", status);
    if (!status)
       fFailed = 1;

    status = RpcNsEntryObjectInqDone(&NsHandle);
    printf("RpcNsEntryObjectInqDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    // getting the dynamic endpoint
    printf("**Test: Dyn Entry Name, No intf, No objuuid\n");
    status = RpcNsBindingLookupBegin(
                                RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                szDynSrvEntryName,        // nsi entry name
                                NULL,
                                NULL,
                                1,
				&NsHandle);

    printf("RpcNsBindingLookupBegin returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = LookupCountAndPrint(NsHandle, 1);
    if (status)
       fFailed = 1;

    status = RpcNsBindingLookupDone(
			       &NsHandle
			       );
    printf("RpcNsBindingLookupDone returned 0x%x\n\n", status);
    if (status)
       fFailed = 1;

    if (fFailed)
       printf("Lookup tests FAILED!!\n");
    else
       printf("Lookup tests PASSED!!\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\unexport\unexp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       unexp.cxx
//
//--------------------------------------------------------------------------

// drt that cleans up the entries
//
//

#include "drt.hxx"

void __cdecl main(int argc, char **argv)
{
    RPC_STATUS             status;
    RPC_IF_HANDLE          IfSpec;
    UUID_VECTOR         *  objuuid = NULL;
    RPC_IF_ID              intfid;
    int			   fFailed = 0;

    intfid.Uuid = ifid[0];
    intfid.VersMajor = 42;
    intfid.VersMinor = 42;

    FormIfHandle(ifid[0], &IfSpec);

    FormObjUuid(objid, 2, &objuuid);

    status = RpcNsBindingUnexport(
				RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                szSrvEntryName[0],        // nsi entry name
                                IfSpec,
                                objuuid);                 // UUID vector
    printf("RpcNsBindingUnexport returned 0x%x\n", status);
    if (status)
       fFailed = 1;

//    status = RpcNsGroupMbrRemove(RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
//                              szGrpEntryName[0],
//                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
//                              szSrvEntryName[0]);

//    printf("RpcNsGroupMbrRemove 1 returned 0x%x\n", status);
//    if (status)
//       fFailed = 1;

    status = RpcNsGroupMbrRemove(RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szGrpEntryName[0],
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szSrvEntryName[1]);

    printf("RpcNsGroupMbrRemove 2 returned 0x%x\n", status);
    if (status)
       fFailed = 1;

//    status = RpcNsProfileEltRemove(
//                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
//                              szPrfEntryName[0],
//                              &intfid,
//                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
//                              szGrpEntryName[0]);
//    printf("RpcNsProfileEltRemove 1 returned 0x%x\n", status);
//    if (status)
//       fFailed = 1;

    status = RpcNsProfileEltRemove(
    RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szPrfEntryName[0],
                              &intfid,
                              RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                              szGrpEntryName[1]);
    printf("RpcNsProfileEltRemove 2 returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsMgmtEntryDelete(
			      RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
			      szSrvEntryName[0]);
    printf("RpcNsMgmtEntryDelete returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsMgmtEntryDelete(
			      RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
			      szPrfEntryName[0]);
    printf("RpcNsMgmtEntryDelete returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsMgmtEntryDelete(
			      RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
			      szGrpEntryName[0]);
    printf("RpcNsMgmtEntryDelete returned 0x%x\n", status);
    if (status)
       fFailed = 1;

/*
    status = RpcNsProfileDelete(
				 RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				 szPrfEntryName[0]);
    printf("RpcNsProfileDelete returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    status = RpcNsGroupDelete(
				 RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
				 szGrpEntryName[0]);
    printf("RpcNsGroupDelete returned 0x%x\n", status);
    if (status)
       fFailed = 1;
*/

    status = RpcNsMgmtEntryDelete(
			      RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
			      szDynSrvEntryName);
    printf("RpcNsMgmtEntryDelete Dyn entryname returned 0x%x\n", status);
    if (status)
       fFailed = 1;

    if (fFailed)
       printf("Export Test FAILED\n");
    else
       printf("Export Test PASSED\n");

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\drt\s\drts.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drts.cxx
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include "drt.h"   // header file generated by MIDL compiler

void __cdecl main(int argc, char * argv[])
{
    RPC_STATUS status;
    RPC_BINDING_VECTOR * pBindingVector = NULL;
    WCHAR * pszEntryName            = L"/.:/drtsrv_01";
    WCHAR * pszGrpEntryName1        = L"/.:/drtgrp_01";
    WCHAR * pszPrfEntryName1        = L"/.:/drtprf_01";
    unsigned char * pszSecurity     = NULL;
    unsigned int    cMinCalls       = 1;
    unsigned int    cMaxCalls       = 20;
    unsigned int    fDontWait       = 0;
    unsigned int    fNameSyntaxType = RPC_C_NS_SYNTAX_DEFAULT;
    unsigned int    fRegistered     = 0;
    unsigned int    fEndpoint       = 0;
    unsigned int    fExported       = 0;
      // abcdefab-abcd-abcd-abcd-abcdefabcdef
    RPC_IF_ID       ifid            = {{ 0xabcdefab, 0xabcd, 0xabcd, { 0xab, 0xcd, 0xab, 0xcd, 0xef, 0xab, 0xcd, 0xef } },
                                      1, 0};
    int             i;

    printf("CallingRpcServerUseAllProtseqs...\n");

    status = RpcServerUseAllProtseqs(cMaxCalls,     // max concurrent calls
                                     pszSecurity);  // Security descriptor
    printf("RpcServerUseAllProtseqs returned 0x%x\n", status);
    if (status) {
        goto cleanup;
    }

    status = RpcServerRegisterIf(drtsrv_01_v1_0_s_ifspec, // interface to register
                                 NULL,                    // MgrTypeUuid
                                 NULL);                   // MgrEpv; null means use default
    printf("RpcServerRegisterIf returned 0x%x\n", status);
    if (status) {
        goto cleanup;
    }
    else
        fRegistered = 1;

    status = RpcServerInqBindings(&pBindingVector);
    printf("RpcServerInqBindings returned 0x%x\n", status);
    if (status) {
        goto cleanup;
    }

    status = RpcEpRegister(drtsrv_01_v1_0_s_ifspec,
                           pBindingVector,
                           NULL,
                           L"");
    printf("RpcEpRegister returned 0x%x\n", status);
    if (status) {
        goto cleanup;
    }
    else
        fEndpoint = 1;

     status = RpcNsBindingExport(fNameSyntaxType,  // name syntax type
				 pszEntryName,     // nsi entry name
				 drtsrv_01_v1_0_s_ifspec,
				 pBindingVector,   // set in previous call
				 NULL);            // UUID vector
     printf("RpcNsBindingExport returned 0x%x\n", status);
    if (status) {
        goto cleanup;
    }
    else
        fExported = 1;


    printf("Calling RpcServerListen: Case 1:\n");
    status = RpcServerListen(cMinCalls,
                             cMaxCalls,
                             fDontWait);  // wait flag
    printf("RpcServerListen returned: 0x%x\n", status);
    if (status) {
        goto cleanup;
    }

    if (fDontWait) {
        printf("Calling RpcMgmtWaitServerListen\n");
        status = RpcMgmtWaitServerListen();  //  wait operation
        printf("RpcMgmtWaitServerListen returned: 0x%x\n", status);
    }

  cleanup:

    if ( fExported )
    {
        status = RpcNsBindingUnexport(RPC_C_NS_SYNTAX_DEFAULT,  // name syntax type
                                       pszEntryName,            // nsi entry name
                                       drtsrv_01_v1_0_s_ifspec,
                                       NULL);                   // UUID vector
        printf( "RpcNsBindingUnexport returned 0x%x\n", status);
    }


    if ( fEndpoint )
    {
        status = RpcEpUnregister(drtsrv_01_v1_0_s_ifspec,
                                  pBindingVector,
                                  NULL);
        printf( "RpcEpUnregister returned 0x%x\n", status);
    }

    if ( pBindingVector )
    {
        status = RpcBindingVectorFree(&pBindingVector);
        printf( "RpcBindingVectorFree returned 0x%x\n", status);
    }

    if ( fRegistered )
    {
        status = RpcServerUnregisterIf(drtsrv_01_v1_0_s_ifspec, // interface to register
                                       NULL,   // MgrTypeUuid
                                       1);     // wait for outstanding calls
        printf( "RpcServerUnregisterIf returned 0x%x\n", status);
    }


}  // end main()



/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file drts.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\brodcast.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    brodcast.cxx

Abstract:

   This file contains the code for all mailslot activity relating to
   binding handle queries-- both outgoing and incoming ones.

Things to improve in future revisions:

  1.  CBindingVector::msriList

  2.  formQueryPacket

Author:

    Satish Thatte (SatishT) 08/15/95  Created all the code below except where
                                      otherwise indicated.

--*/


/* NOTE: Compatibility Issue: see below for meaning of END_FLAG_SIZE */

#include <locator.hxx>

const int END_FLAG_SIZE = 4;


/****************  Utilities for Broadcast **********************/


/* a little macro exclusively for use in UnmarshallBroadcastReplyItem */

#define unBufferIt(source)                                            \
    lBufferSize -= advance;                                           \
    if (lBufferSize < 0) {                                            \
                StatusCode = NSI_S_UNMARSHALL_UNSUCCESSFUL;           \
                return;                                               \
    }                                                                 \
    if (source) memcpy((char*) source, pcBuffer, advance);            \
    pcBuffer += advance;


// keeping track of history of broadcast requests.

BOOL
Locator::broadcastCleared(
    QueryPacket& NetRequest,
    ULONG ulCacheTolerance
    )
/*++
Member Description:

    Given a query packet and a tolerance for staleness, decide if a broadcast
    should be made based on recent history of broadcasts.

Arguments:

    NetRequest - the request packet

    ulCacheTolerance - tolerance for staleness in seconds

Returns:

    TRUE - if broadcast should be made

    FALSE - if broadcast is unnecessary

--*/
{
    SimpleCriticalSection me(PCSBroadcastHistory);

    TSLLBroadcastQPIter histIter(*psllBroadcastHistory);

    for (CBroadcastQueryPacket *pbqp = histIter.next(); pbqp; pbqp = histIter.next())
    {
        // if the history is too stale for the global cache retirement age, remove it.

        if (!pbqp->isCurrent(ulMaxCacheAge)) {
            psllBroadcastHistory->remove(pbqp);
            delete pbqp;
        }

        // otherwise, in the subsumes check, use the requested cache retirement age

        else if (pbqp->subsumes(NetRequest,ulCacheTolerance)) {
            return FALSE;
        }
    }

    return TRUE;
}

CRemoteLookupHandle *
Locator::NetLookup(
        UNSIGNED32           EntryNameSyntax,
        STRING_T             EntryName,
        CGUIDVersion    *    pGVinterface,
        CGUIDVersion    *    pGVsyntax,
        CGUID           *    pIDobject,
        unsigned long        ulVectorSize,
        unsigned long        ulCacheAge
        )
/*++
Member Description:

    Use the given lookup parameters to perform a lookup from the
    network -- either via a master locator or via broadcast depending
    on the status of the current locator and the status of the master locator(s).

    Since net lookup is now "lazy" (net is accessed only if needed), we need
    a lazy handle which initializes itself according to the old pattern of
    "use master if you can, broadcast if you must".

Arguments:

    EntryNameSyntax        - Name syntax, optional

    EntryName              - (raw) Name of the entry to look up, optional

    pGVinterface           - (wrapped) Interface to look up, optional

    pGVsyntax              - (wrapped) Transfer syntax, optional

    pIDobject              - (wrapped) Object UUID, optional

    ulVectorSize           - Max size of vectors of binding handles, 0 for default

    ulCacheAge             - acceptable max age of cached information from a master

Returns:

    A lookup handle based on the info retrieved.

--*/
{

    return new CNetLookupHandle(
                    EntryNameSyntax,
                    EntryName,
                    pGVinterface,
                    pGVsyntax,
                    pIDobject,
                    ulVectorSize,
                    ulCacheAge
                    );

}


CObjectInqHandle *
Locator::NetObjectInquiry(
        UNSIGNED32 EntryNameSyntax,
        STRING_T EntryName
        )
/*++
Member Description:

    Perform an inquiry on the network for object UUIDs registered in the
    given entry.   The network is searched either via a master locator or via
    broadcast depending on the status of the current locator and the status
    of the master locator(s).

Arguments:

    EntryNameSyntax        - Name syntax, optional

    EntryName              - (raw) Name of the entry to look up, optional

Returns:

    A handle based on the info retrieved.

--*/
{
    return new CNetObjectInqHandle(
                            EntryName,
                            ulMaxCacheAge
                            );

}

void
Locator::UpdateCache(
            STRING_T                 entry_name,
            UNSIGNED32               entry_name_syntax,
            RPC_SYNTAX_IDENTIFIER    rsiInterface,
            RPC_SYNTAX_IDENTIFIER    rsiTransferSyntax,
            STRING_T                 string,
            NSI_UUID_VECTOR_P_T      pUuidVector,
            TSSLEntryList        *   psslTempNetCache
            )
/*++
Member Description:

    Update the locator's cache with information retrieved from the net
    (either from a master locator or from a broadcast).  Also update the
    temporary cache (last parameter) which holds only new information
    for use in the remote handle based on the current NetLookup.
    The use of this temporary cache avoids duplication in the information
    returned to the client.

Arguments:

    entry_name          - (raw) name of the entry being updated

    entry_name_syntax   - name syntax

    rsiInterface        - (raw) interface

    rsiTransferSyntax   - (raw) transfer syntax

    string              - (raw) string binding handle

    pUuidVector         - vector of object UUIDs to add to entry

    psslTempNetCache    - a temporary cache of entries for use in a remote handle

--*/
{
    NSI_SERVER_BINDING_VECTOR_T BindingVector;
    BindingVector.count = 1;
    BindingVector.string[0] = string;

    NSI_INTERFACE_ID_T Interface;
    Interface.Interface = rsiInterface;
    Interface.TransferSyntax = rsiTransferSyntax;

    /* first we update the locator's cache */

    DBGOUT(BROADCAST, "\tUpdating the cache entry for Entry " << entry_name << "\n");
    DBGOUT(BROADCAST, "\t\tWith Interface: " << &rsiInterface.SyntaxGUID << "\n");
    DBGOUT(BROADCAST, "\t\tWith Binding Vector: " << &BindingVector << "\n");
    DBGOUT(BROADCAST, "\t\tAnd Object Vector: " << pUuidVector << "\n\n");

    if ((    nsi_binding_export(
                        entry_name_syntax,
                        entry_name,
                        &Interface,
                        &BindingVector,
                        pUuidVector,
                        NonLocal
                        )
        ) || (IsNilIfId(&(Interface.Interface))))
    {

    /* if there was something new, we update the temporary cache for the net handle.
       The constructor for CEntryName used below makes the name local if possible. */

        CStringW * pswName = new CStringW(CEntryName(entry_name));

        CServerEntry * pTempCacheEntry = (CServerEntry*)
                                         psslTempNetCache->find(pswName);

        delete pswName;

        if (!pTempCacheEntry) {

            pTempCacheEntry = new CServerEntry(entry_name);
            psslTempNetCache->insert(pTempCacheEntry);
        }

        pTempCacheEntry->add_to_entry(
                        &Interface,
                        &BindingVector,
                        pUuidVector,
                        pCacheInterfaceIndex,
                        TRUE
                        );

        CEntry *pEntry = GetEntryFromCache(
                                entry_name_syntax,
                                entry_name
                                );

        if ((pEntry) && (pEntry->getType() == FullServerEntryType))
        {
            CServerEntry *pLocal = ((CFullServerEntry *)pEntry)->getLocal();
            CServerEntry *pNonLocal = ((CFullServerEntry *)pEntry)->getNonLocal();

            // this is required b'cos the locator that contacted the
            // PDC itself responds to broadcast request and hence there
            // is a necessity to remove this info from the results got
            // back.

            if (pNonLocal->purgeCommonEntries(pLocal))
                        // all the bindings has been purged.
                ((CNonLocalServerEntry *)pNonLocal)->fHasNonLocalInfo = FALSE;
            if (pTempCacheEntry->purgeCommonEntries(pLocal))
            {
                psslTempNetCache->remove(pTempCacheEntry);
                delete pTempCacheEntry;
            }
        }
    }
}


void
UnmarshallBroadcastReplyItem(
            TSSLEntryList *psslCache,
            STRING_T szEntryDomain,
            char * &pcBuffer,
            long& lBufferSize,
            ULONG& StatusCode
            )
/*++

Routine Description:

    Unmarshall an item from the broadcast reply buffer.  If a well-formed item
    is found, the locator's cache and the temporary given cache (first argument)
    is updated and the buffer size is decreased accordingly.  A reply packet
    contains the name of the replying locator's domain, which is used as the
    domain of the entry unless otherwise specified in the name itself.

    If the unmarshalling is unsuccessful, this is indicated in the status code returned.

Arguments:

    psslCache        - temporary cache for remote handle

    szEntryDomain    - domain of replying locator

    pcBuffer         - reply buffer

    lBufferSize      - reduced buffer size returned here

    StatusCode       - status of unmarshalling attempt returned here

Returned Status:

    NSI_S_OK, NSI_OUT_OF_MEMORY, NSI_S_UNMARSHALL_UNSUCCESSFUL,
    NSI_S_UNSUPPORTED_BUFFER_TYPE

Remarks:

   The following function has "return"s inside a __try block.  Since this whole code
   is slated for removal after a couple of updates, I have left them in.  They could
   be easily replaced with "goto"s if necessary.

--*/
{
    StatusCode = NSI_S_OK;
    long advance;
    RPC_SYNTAX_IDENTIFIER Interface;
    RPC_SYNTAX_IDENTIFIER XferSyntax;
    STRING_T binding;
    STRING_T entryName = NULL;

    if (pcBuffer) {
        DBGOUT(BROADCAST, "Received:: " << pcBuffer << "\n");
    }
    else {
    	DBGOUT(BROADCAST, "\tThrowing the reply element because it is empty" << "\n");        
        return;
    }

    advance = sizeof(fixed_part_of_reply);
    fixed_part_of_reply fpr;
    unBufferIt(&fpr);

    if (fpr.type != MailslotServerEntryType) {
        StatusCode = NSI_S_UNSUPPORTED_BUFFER_TYPE;
    	DBGOUT(BROADCAST, "\tThrowing the reply element" << "\n");        
        return;
    }

    Interface = fpr.Interface;
    XferSyntax = fpr.XferSyntax;

    advance = fpr.EntryNameLength * sizeof(WCHAR);

    entryName = (WCHAR*) pcBuffer;

    unBufferIt(NULL);

    if (entryName[fpr.EntryNameLength-1] != L'\0') {
        StatusCode = NSI_S_UNMARSHALL_UNSUCCESSFUL;
	DBGOUT(BROADCAST, "\tThrowing the reply element b'cos the entry name sizes don't match" << "\n");
	DBGOUT(BROADCAST, "\tEntry Name " << entryName << "length = " << fpr.EntryNameLength << "\n");      
        return;
    }

    advance = sizeof(UNSIGNED32);
    UNSIGNED32 objVectorSize;
    unBufferIt(&objVectorSize);

    if (objVectorSize > NET_REPLY_BUFFER_SIZE) { // fix for bug #180095
        StatusCode = NSI_S_UNMARSHALL_UNSUCCESSFUL;
	DBGOUT(BROADCAST, "\tThrowing the reply element b'cos number of objuuids are too much" << "\n");      
	DBGOUT(BROADCAST, "\tObj Vector Size " << objVectorSize << "\n");      
        return; 
    }        
    
    GUID * guidVector = NULL;
    NSI_UUID_VECTOR_T * pUuidVector = NULL;
                
    CStringW *pswEntry = NULL, *pswDomain = NULL;
    CEntryName * penTempName = NULL;
        
    __try {
        guidVector = new GUID[objVectorSize];

        pUuidVector = (NSI_UUID_VECTOR_T *)
            new char [
            sizeof(UNSIGNED32) +
            sizeof(NSI_UUID_P_T) * objVectorSize
            ];

        pUuidVector->count = objVectorSize;
        
        advance = sizeof(DWORD);    // this is a useless pointer part
        lBufferSize -= advance;     // therefore we don't unmarshall it
        pcBuffer += advance;        // we just account for its size

        advance = sizeof(GUID);

        for (ULONG i = 0; i < objVectorSize; i++) {
            pUuidVector->uuid[i] = &(guidVector[i]);
            unBufferIt(&(guidVector[i]));
        }

        advance = fpr.BindingLength * sizeof(WCHAR);
        binding = (WCHAR*) pcBuffer;
        if (binding[fpr.BindingLength-1] != L'\0') {
            StatusCode = NSI_S_UNMARSHALL_UNSUCCESSFUL;
  	    DBGOUT(BROADCAST, "\tThrowing the reply element b'cos bindings do not match the size" << "\n");      
	    DBGOUT(BROADCAST, "\tBinding " << binding << "length = " << fpr.BindingLength << "\n");      
            return;
        }
        unBufferIt(NULL);

        parseEntryName(entryName,pswDomain,pswEntry);

        if (!pswDomain && szEntryDomain)    // if name has no domain then use the
                                            // domain of origin in forming name

            penTempName = new CEntryName(szEntryDomain,*pswEntry);

        else  penTempName = new CEntryName(entryName);

        myRpcLocator->UpdateCache(
                              *penTempName,
                              RPC_C_NS_SYNTAX_DCE,
                              Interface,
                              XferSyntax,
                              binding,
                              pUuidVector,
                              psslCache
                              );
              /* first update the central cache and, if there is anything new,
                 also update the temporary cache in psslCache
              */

    }
    __finally {
        delete [] pUuidVector;
        delete [] guidVector;
        delete pswDomain;
        delete pswEntry;
        delete penTempName;
    }
}


BOOL
CBroadcastQueryPacket::subsumes(QueryPacket& NewQuery, ULONG tolerance) {

    // too stale?

    if (!isCurrent(tolerance)) return FALSE;

    CStringW OtherEntry(NewQuery.EntryName);

    // incompatible entry name involved?

    if (!(swEntryName == OtherEntry) && (swEntryName.length() > 0))
        return FALSE;

    CGUID OtherObject(NewQuery.Object);

    // incompatible object involved?

    if (!(OtherObject == Object) && !Object.IsNil()) return FALSE;

    CGUIDVersion OtherInterface(NewQuery.Interface);
    CGUID myGUID(Interface.myIdAndVersion().SyntaxGUID);

    // incompatible interface involved?

    if (
        !OtherInterface.isMatching(Interface,RPC_C_VERS_COMPATIBLE) &&
        !myGUID.IsNil()
       )
       return FALSE;

    // we ran the gauntlet successfully -- stop the broadcast!

    return TRUE;

}


void
formQueryPacket(
            CEntryName        *    penEntryName,
            CGUIDVersion      *    pGVInterface,
            CGUID             *    pIDobject,
            QueryPacket       &    NetRequest
            )
/*++

Routine Description:

    Forms a query packet given the items in it.

Arguments:

    penEntryName    - (wrapped) entry name

    pGVInterface    - (wrapped) interface UUID and version

    pIDobject       - (wrapped) object UUID

    NetRequest      - The request packet is returned here

Remarks:

  BUGBUG:

       We used to perform some shenanigans with interface and object settings
       in the QueryPacket to allow us to correctly report NSI_S_ENTRY_NOT_FOUND
       when appropriate.  Specifically, using wildcards for interface and object
       if the entry name was non null so as to gather all information about the
       specific entry from the net.

       In order to interoperate with the old locator, these shenanigans have
       been suspended, and we will currently return NSI_S_ENTRY_NOT_FOUND
       spuriously when no information is received from the net in response to
       a specific rather than a wildcard query, just like the old locator
       (so that the old tests pass when they expect NSI_S_ENTRY_NOT_FOUND !!).

       The problem with the old locator is that it carefully avoids sending
       duplicate binding handles, so if a null interface is given in
       the broadcast query, it naturally assumes that we don't care about the
       interface, and may omit info about some interfaces unless they have
       distinct binding handles associated with them.

--*/
{

    memset(&(NetRequest.Object),0,sizeof(NetRequest.Object));
    memset(&(NetRequest.Interface),0,sizeof(NetRequest.Interface));

     if (penEntryName) // specific entry - we used to leave wildcards for interface and object
        wcscpy(NetRequest.EntryName,*penEntryName);

    else             // otherwise, use real interface and object if given
        memset(&(NetRequest.EntryName),0,sizeof(WCHAR)*MAX_ENTRY_NAME_LENGTH);

    // NOTE:  compatibility removal: the following two lines were conditional
    //  on the else before the "shenanigans" were eliminated

    if (pIDobject) NetRequest.Object = pIDobject->myGUID();
    if (pGVInterface) NetRequest.Interface = *pGVInterface;
}


TSSLEntryList *
getBroadcastResults(
            ULONG                 cacheTolerance,
            CEntryName       *    penEntryName,
            CGUIDVersion     *    pGVInterface,
            CGUID            *    pIDobject,
            ULONG            &    StatusCode
            )
/*++

Routine Description:

    Broadcasts for the requested binding handles.

Arguments:

    cacheTolerance  - the staleness tolerance associated with this request,
                      used in deciding whether to broadcast at all

    penEntryName    - (wrapped) entry name

    pGVInterface    - (wrapped) interface UUID and version

    pIDobject       - (wrapped) object UUID

    StatusCode      - The status of the broadcast attempt is returned here

Returns:

    A temporary cache of entries containing the new information.

Remarks:

       A broadcast is made only if a subsuming broadcast has not been made within
       the staleness limit specified by the parameter cacheTolerance.  Only one
       broadcast is allowed at a time, since there is only one mailslot for replies.

--*/
{
    char * pcBuffer;
    ULONG waitCur = INITIAL_MAILSLOT_READ_WAIT; // current wait time for replies
    STRING_T szEntryDomain;

    READ_MAIL_SLOT *hMailslotForReplies = myRpcLocator->hMailslotForReplies;
    long cbRead;

    QueryReply NetReply;

    if (!hMailslotForReplies) {
        StatusCode = NSI_S_ENTRY_NOT_FOUND;
        return NULL;
    }

    QueryPacket NetRequest;

    wcscpy(NetRequest.WkstaName, TEXT("\\\\"));
    wcscpy(NetRequest.WkstaName + 2, *myRpcLocator->getComputerName());

    formQueryPacket(penEntryName,pGVInterface,pIDobject,NetRequest);

    // now get this broadcast cleared -- make sure it is not redundant

    if (!myRpcLocator->broadcastCleared(NetRequest,cacheTolerance))
    {
        if (penEntryName)
        {
            DBGOUT(BROADCAST, "\nBroadcast request denied for " << *penEntryName << "\n"
                << "Interface = " << &NetRequest.Interface.SyntaxGUID << "\n"
                << "Object = " << &NetRequest.Object << "\n\n");
        }
        else
        {
            DBGOUT(BROADCAST, "\nBroadcast request denied for NULL entry\n"
                << "Interface = " << &NetRequest.Interface.SyntaxGUID << "\n"
                << "Object = " << &NetRequest.Object << "\n\n");
        }
        return NULL;
    }
    else
    {
        if (penEntryName)
        {
            DBGOUT(BROADCAST, "\nI am broadcasting for " << *penEntryName << "\n"
                << "Interface = " << &NetRequest.Interface.SyntaxGUID << "\n"
                << "Object = " << &NetRequest.Object << "\n\n");
        }
        else
        {
            DBGOUT(BROADCAST, "\nI am broadcasting for NULL entry\n"
                << "Interface = " << &NetRequest.Interface.SyntaxGUID << "\n"
                << "Object = " << &NetRequest.Object << "\n\n");
        }
        myRpcLocator->markBroadcast(NetRequest);
    }


    // szDomain should be either NULL or a plain Domain name

    STRING_T szDomainParam;

    CStringW *pswDomain = penEntryName ? penEntryName->getDomainName() : NULL;

    if (pswDomain)
        szDomainParam = catenate(TEXT("\\\\"),*pswDomain);
    else szDomainParam = TEXT("\\\\*");

    TSSLEntryList *psslCache = new TSSLEntryList;

    StatusCode = NSI_S_OK;

    __try {

        csBindingBroadcastGuard.Enter();    // only one broadcast at a time

        while (cbRead = hMailslotForReplies->Read((char *) &NetReply, 
							sizeof(NetReply), 
							0)); // flush

        WRITE_MAIL_SLOT MSquery(szDomainParam, PMAILNAME_S);

        MSquery.Write((char *) &NetRequest, sizeof(NetRequest));

        // now loop waiting for responses from other RPC servers

        DBGOUT(BROADCAST, "**Broadcast sent. Wait timeout:: " << waitCur << "\n\n");

        while (cbRead = hMailslotForReplies->Read((char *) &NetReply,
                                                sizeof(NetReply),
                                                waitCur
                                            )
                )
        {
            DBGOUT(BROADCAST, "**Received a reply\n");
            pcBuffer = NetReply.Buffer;
            szEntryDomain = (_wcsicmp(
                                    *myRpcLocator->getDomainName(),
                                    NetReply.Domain
                                    )
                                == 0
                             )? NULL: NetReply.Domain;

            while (!StatusCode) {

                UnmarshallBroadcastReplyItem(
                                            psslCache,
                                            szEntryDomain,
                                            pcBuffer,
                                            cbRead,
                                            StatusCode
                                            );
            }

            StatusCode = NSI_S_OK;

            // halve the wait period everytime you get a response from the net

            waitCur >>= 1;

            DBGOUT(BROADCAST, "Wait time out:: " << waitCur);
        }
        DBGOUT(BROADCAST, "\nFinished waiting\n\n");
        csBindingBroadcastGuard.Leave();
    }

    __except(EXCEPTION_EXECUTE_HANDLER) {
        csBindingBroadcastGuard.Leave();
        StatusCode = GetExceptionCode();
        psslCache->wipeOut();
        delete psslCache;
        psslCache = NULL;
        if (pswDomain) 
            delete [] szDomainParam;
        return NULL;
    }

    if (pswDomain) delete [] szDomainParam;

    if (psslCache->size() == 0) {
        delete psslCache;
        psslCache = NULL;
    }

    return psslCache;
}


/****************  Methods related to MailSlotReplyItem ********************/

/* a little macro exclusively for use in CMailSlotReplyItem::Marshall */

#define bufferIt(source)                                          \
    lBufferSize -= advance;                                       \
    if (lBufferSize < 0) return 0;                                \
    memcpy(pcBuffer, (char*) source, advance);                    \
    pcBuffer += advance;


DWORD
CMailSlotReplyItem::Marshall(
                        char * pcBuffer,
                        long lBufferSize
                        )

/*++
Method Description:

--*/

{
    DWORD dwOriginalBufferSize = lBufferSize;

    fixed_part_of_reply fpr;

    fpr.type = MailslotServerEntryType;

    fpr.Interface = Interface;
    fpr.XferSyntax = XferSyntax;

    fpr.BindingLength = wcslen(binding)+ 1;
    fpr.EntryNameLength = wcslen(entryName) + 1;

    long advance;

    advance = sizeof(fixed_part_of_reply);
    bufferIt(&fpr);

    advance = fpr.EntryNameLength * sizeof(WCHAR);
    bufferIt(entryName);

    DBGOUT(BROADCAST, "Marshalling entry " << entryName);

    advance = sizeof(long);
    long objListSize = pObjectList->size();
    bufferIt(&objListSize);

    advance = sizeof(DWORD);    // this is a useless pointer part
    lBufferSize -= advance;     // therefore we don't marshall it
    pcBuffer += advance;        // we just account for its size

    TCSafeSkipListIterator<CGUID> objIter(*pObjectList);
    advance = sizeof(GUID);

    for (CGUID *obj =objIter.next(); obj; obj =objIter.next()) {
        GUID rep = obj->myGUID();
        bufferIt(&rep);
    }

    advance = fpr.BindingLength * sizeof(WCHAR);
    bufferIt(binding);

    return dwOriginalBufferSize - lBufferSize;
}


TMSRILinkList *
CBindingVector::msriList(
                CInterface *pIf,
                TCSafeSkipList<CGUID>* psslObjList
                )

/*++
Method Description:

    We combine every relevant object in the server entry with every basic
    binding string although that seems ridiculous.  This is the way the old
    locator expects us to behave as far as I can tell.

--*/

{
    CMailSlotReplyItem *pmsrl;
    TMSRILinkList *pmsrill = new TMSRILinkList;

    TCSafeSkipListIterator<CStringW> bindingIter(*this);

    for (CStringW * psw = bindingIter.next(); psw; psw = bindingIter.next())
    {
            pmsrl = new CMailSlotReplyItem;

            pmsrl->binding = *psw;
            pmsrl->pObjectList = psslObjList;
            pmsrl->Interface = pIf->myIdAndVersion();
            pmsrl->XferSyntax = pIf->xferSyntaxIdAndVersion();
            pmsrl->entryName = pMyEntry->getCurrentName();

            pmsrill->insert(pmsrl);
    }

    return pmsrill;
}


/**********  CBroadcastLookupHandle Methods ****************/

CBroadcastLookupHandle::CBroadcastLookupHandle(
                            UNSIGNED32            EntryNameSyntax,
                            STRING_T              EntryName,
                            CGUIDVersion     *    pGVInterface,
                            CGUIDVersion     *    pGVTransferSyntax,
                            CGUID            *    pIDobject,
                            unsigned long         ulVectorSize,
                            unsigned long         ulCacheAge
                            ) :
                            CRemoteLookupHandle(
                                    EntryNameSyntax,
                                    EntryName,
                                    pGVInterface,
                                    pGVTransferSyntax,
                                    pIDobject,
                                    ulVectorSize,
                                    ulCacheAge
                                    )
{
}



void
CBroadcastLookupHandle::initialize()
{
    StatusCode = NSI_S_OK;

    DBGOUT(BROADCAST, "Broadcasting for the entry received\n");

    psslNewCache = getBroadcastResults(
                                    ulCacheMax,
                                    penEntryName,
                                    pgvInterface,
                                    pidObject,
                                    StatusCode
                                    );

    if (!psslNewCache) plhFetched = NULL;

    else {

        TSSLEntryListIterator *pCacheIter = new TSSLEntryListIterator(*psslNewCache);

        plhFetched = new CGroupLookupHandle(
                                        pCacheIter,
                                        pgvInterface,
                                        pgvTransferSyntax,
                                        pidObject,
                                        ulVS,
                                        ulCacheMax
                                        );
    }

    if (penEntryName && !plhFetched) {                  // we looked for a specific entry
        DBGOUT(BROADCAST, "Broadcast not Made????\n");  // by name but found nothing new,
        StatusCode = NSI_S_ENTRY_NO_NEW_INFO;           // possibly because the broadcast
    }                                                   // was redundant and was not made

    ulCreationTime = CurrentTime();
    fNotInitialized = FALSE;
}


/****************** CBroadcastObjectInqHandle Methods *******************/

CBroadcastObjectInqHandle::CBroadcastObjectInqHandle(
                                        STRING_T szEntryName,
                                        ULONG ulCacheAge
                                        )
                                : CRemoteObjectInqHandle(szEntryName,ulCacheAge)
{
}


void
CBroadcastObjectInqHandle::initialize()
{
    StatusCode = NSI_S_OK;

    TSSLEntryList *psslNewCache = getBroadcastResults(
                                                ulCacheMax,
                                                penEntryName,
                                                NULL,
                                                NULL,
                                                StatusCode
                                                );

    if (!psslNewCache || (psslNewCache->size() == 0)) {
        pUuidVector = NULL;
        return;
    }

    CEntry *pEntry = psslNewCache->pop();

    psslNewCache->wipeOut();
    delete psslNewCache;

    pUuidVector = getVector(pEntry->objectInquiry(ulCacheMax));
    delete pEntry;

    ulCreationTime = CurrentTime();
    fNotInitialized = FALSE;
}


/************  Methods for CServerMailSlotReplyHandle *************/


CServerMailSlotReplyHandle::CServerMailSlotReplyHandle(
        TMSRILinkList    *    pmsrill
    )
{
    pmsriIterator = new TMSRILinkListIterator(*pmsrill);
           // see CServerLookupHandle::CServerLookupHandle
    delete pmsrill;
}


CServerMailSlotReplyHandle::~CServerMailSlotReplyHandle()
{
    for (    // run down the remaining items in the handle
            CMailSlotReplyItem* pmsri = pmsriIterator->next();
            pmsri;
            pmsri = pmsriIterator->next()
        )
    {
        delete pmsri;
    }

    delete pmsriIterator;
}



/************  Methods for CIndexMailSlotReplyHandle *************/


void
CIndexMailSlotReplyHandle::advanceCurrentHandle()
{
    delete pCurrentHandle;
    pCurrentHandle = NULL;

    CEntry *pCurEntry;

    while (!pEIterator->finished()) {

        pCurEntry = pEIterator->next();
        if (pCurEntry->isNonLocalType()) continue;

        pCurrentHandle = pCurEntry->MailSlotLookup(
                                        pGVInterface,
                                        pIDobject
                                        );

        if (pCurrentHandle && !pCurrentHandle->finished()) break;
    }
}


CIndexMailSlotReplyHandle::CIndexMailSlotReplyHandle(
            CGUIDVersion    *    pGVInf,
            CGUID           *    pIDobj,
            TEntryIterator  *    pEI
        )
{
    pEIterator = pEI;
    pGVInterface = pGVInf;
    pIDobject = pIDobj;
    pCurrentHandle = NULL;

    advanceCurrentHandle();
}


CMailSlotReplyItem *
CIndexMailSlotReplyHandle::next()
{
    if (pCurrentHandle && pCurrentHandle->finished())
                advanceCurrentHandle();

    if (!pCurrentHandle) return NULL;    // no more entries
    else return pCurrentHandle->next();
}

int
CIndexMailSlotReplyHandle::finished()
{
    if (pCurrentHandle && pCurrentHandle->finished())
                advanceCurrentHandle();

    if (!pCurrentHandle) return TRUE;    // no more entries
    else return FALSE;
}



/************  MailSlotLookup Methods *************/


CMailSlotReplyHandle *
CServerEntry::MailSlotLookup(
                    CGUIDVersion    *    pGVInterface,
                    CGUID           *    pIDobject
                    )
/*++
Method Description:

--*/
{
    TCSafeSkipListIterator<CInterface> IfIter(InterfaceList);

    TMSRILinkList *pmsrill = new TMSRILinkList;

    for (CInterface *pIf = IfIter.next(); pIf != NULL; pIf = IfIter.next())
            if (pIf->isCompatibleWith(pGVInterface,NULL)
               )
    {
        TMSRILinkList *pmsrillTemp
            = pIf->pBVhandles->msriList(pIf,&ObjectList);

        pmsrill->catenate(*pmsrillTemp);
        delete pmsrillTemp;
    }

    return new CServerMailSlotReplyHandle(
                                pmsrill
                                );
}


CMailSlotReplyHandle *
CFullServerEntry::MailSlotLookup(
            CGUIDVersion    *    pGVInterface,
            CGUID           *    pIDobject
            )
{
    if (pLocalEntry) return pLocalEntry->MailSlotLookup(
                                                    pGVInterface,
                                                    pIDobject
                                                    );
    else return NULL;
}


/**************  Thread definition for replying to broadcasts ***************/


#define cleanup()            \
    delete plhQuery;         \
    delete pGVinterface;     \
    delete pIDobject;        \
    delete pEntryName;

void
QueryProcess(void*)
/*++

  Routine Description:
  
    This thread creates a mailslot which listens for requests for
    RPC servers of a given interface GID.  It then uses LookUp to
    build a response list.  It then replies via a mailslot to the
    requesting machine.
    
      --*/
{
    QueryReply NetReply;
    QueryPacket NetQuery;
    
    DWORD dwMailSize, dwBufferUsed;
    
    // create both a server (s) side mailslot
    
    READ_MAIL_SLOT *hMailslotForQueries;
    
    __try{
        hMailslotForQueries = new READ_MAIL_SLOT(PMAILNAME_S, sizeof(QueryPacket));
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        ExitThread(NSI_S_MAILSLOT_ERROR);
    }
    
    wcscpy(NetReply.Domain, *myRpcLocator->getDomainName());
    
    while (1) {
        
        CMailSlotReplyHandle * plhQuery = NULL;
        CGUIDVersion * pGVinterface = NULL;
        CGUID * pIDobject = NULL;
        CEntry * pEntry = NULL;
        
        RPC_STATUS status = NSI_S_OK;
        
        dwMailSize = hMailslotForQueries->Read(
            (char *) &NetQuery,
            sizeof(QueryPacket),
            MAILSLOT_WAIT_FOREVER
            );
        
        CriticalReader LocReader(rwLocatorGuard);
        // after mailslot receives a message take the lock.

        if (dwMailSize != sizeof(QueryPacket))
            continue;        // strange query, ignore it

        if (IsBadStringPtr(NetQuery.WkstaName, MAX_DOMAIN_NAME_LENGTH))
            continue;

        if (IsBadStringPtr(NetQuery.EntryName, MAX_ENTRY_NAME_LENGTH))
            continue;
        
        // ignore messages to self, sending a request on a mailslot
        // by a NetLookUp request will be delivered to the local slot too.
        // The pointer arithmetic skips over the initial "\\" in the name
        
        if (myRpcLocator->IsSelf(NetQuery.WkstaName+2)) continue;
        
        DBGOUT(BROADCAST, "\nReceived broadcast request from " << NetQuery.WkstaName << "\n\n");
        
        if (NetQuery.EntryName[0] != 0)
        {
            DBGOUT(BROADCAST, "\nBroadcast Looking for " << NetQuery.EntryName << "\n"
                << "Interface = " << &NetQuery.Interface.SyntaxGUID << "\n"
                << "Object = " << &NetQuery.Object << "\n\n");
        }
        else
        {
            DBGOUT(BROADCAST, "\nBroadcast Looking for NULL entry\n"
                << "Interface = " << &NetQuery.Interface.SyntaxGUID << "\n"
                << "Object = " << &NetQuery.Object << "\n\n");
        }
        
        // OK looks like a genuine query -- if we are in a workgroup, rememeber
        // the broadcaster as a potential master
        
        if (myRpcLocator->IsInWorkgroup()) myRpcLocator->addMaster((NetQuery.WkstaName)+2);
        
        pGVinterface = UuidIsNil(&NetQuery.Interface.SyntaxGUID,&status) ? NULL :
        new CGUIDVersion(NetQuery.Interface);
        
        pIDobject = UuidIsNil(&NetQuery.Object,&status) ? NULL :
        new CGUID(NetQuery.Object);
        
        // Variable used to make sure the entry name is well formed and local
        
        CEntryName *pEntryName = NULL;
        
        // This global reader block is needed because a lot of the info in the
        // MSRIs is "borrowed" from regular entries, i.e., not copied.  Thus, an
        // unexport in a separate thread can have unfortunate consequences.
        
        CriticalReader me(rwEntryGuard);
        
        if (NetQuery.EntryName[0] == 0) {    // use default entry
            
            plhQuery = new CIndexMailSlotReplyHandle(
                pGVinterface,
                pIDobject,
                myRpcLocator->IndexLookup(pGVinterface)
                );
            
            if (!plhQuery) {
                cleanup();                            // ignore the query
                continue;                            // if nothing to report
            }
        }
        
        else {
            
            __try {
                pEntryName = new CEntryName(NetQuery.EntryName);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                cleanup();                            // ignore the query
                continue;                            // if there is any problem
            }
            
            
            if (!pEntryName->isLocal()) {
                cleanup();                            // ignore the query
                continue;                            // if entry not in our domain
            }
            
            pEntry = myRpcLocator->findEntry(pEntryName);
            
            if (!pEntry) {
                cleanup();                            // ignore the query
                continue;                            // if entry not found
            }
            
            else plhQuery = pEntry->MailSlotLookup(
                pGVinterface,
                pIDobject
                );
            
            if (!plhQuery) {
                cleanup();                            // ignore the query
                continue;                            // if nothing to report
            }
            
        }
        
        __try {
            WRITE_MAIL_SLOT MSReply(NetQuery.WkstaName, PMAILNAME_C);
            
            char *pcBuffer = NetReply.Buffer;
            
            /* we must take care of the possibility that an item is fetched but
            cannot be marshalled because the buffer is full -- we have to
            retry marshalling it in the next cycle
            */
            
            CMailSlotReplyItem * pmsriNext = NULL;
            
            pmsriNext = plhQuery->next();
            
            while (pmsriNext) {
                
                int BufferNotFull = TRUE;
                dwBufferUsed = 0;
                
                while (BufferNotFull && pmsriNext) {
                    
                /*  NOTE: Compatibility Issue:  The +END_FLAG_SIZE below reserves space for
                the 4-byte 0 flag required by the old locator at the end of the buffer.
                    */
                    
                    DWORD dwBytesWritten =
                        pmsriNext->Marshall(
                        pcBuffer+dwBufferUsed,
                        NET_REPLY_MAILSLOT_BUFFER_SIZE-(dwBufferUsed+END_FLAG_SIZE)
                        );
                    
                    if (dwBytesWritten) {
                        dwBufferUsed += dwBytesWritten;
                        delete pmsriNext;
                        pmsriNext = plhQuery->next(); // only if marshalling was successful
                    }
                    
                    else BufferNotFull = FALSE;
                    
                }
                
                /* NOTE: Compatibility Issue:
                
                  The old locator does not use the count of bytes read to decide when
                  to stop unmarshalling a mailslot reply -- instead it uses the 0 flag
                  after the last marshalled entry for that purpose, so for compatibility
                  reasons we must do the needful.
                */
                
                memset(pcBuffer+dwBufferUsed,0,END_FLAG_SIZE);
                
                MSReply.Write(
                    (char*) &NetReply,
                    dwBufferUsed + MAX_DOMAIN_NAME_LENGTH * sizeof(WCHAR) + END_FLAG_SIZE
                    );
                DBGOUT(BROADCAST, "Reply sent\n\n");
            }
        }
        __finally {
            cleanup();                           // ignore the query
                                                 // if there is any problem
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\api.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    api.cxx

Abstract:

   This file contains

   1.  implementations of most noninline member functions in the Locator class.

   2.  implementations of the remoted API functions called by the name service client DLL.

   3.  implementations of the locator-to-locator API functions.

Author:

    Satish Thatte (SatishT) 08/15/95  Created all the code below except where
                                      otherwise indicated.

--*/


#include <locator.hxx>
extern BOOL fLocatorInitialized;


/*************                                         *************
 *************     The top level API routines follow   *************
 *************                                         *************/

extern "C" {

void
nsi_binding_export(
    IN UNSIGNED32           EntryNameSyntax,
    IN STRING_T             EntryName,
    IN NSI_INTERFACE_ID_T * Interface,
    IN NSI_SERVER_BINDING_VECTOR_T *BindingVector,
    IN NSI_UUID_VECTOR_P_T  ObjectVector, OPT
    IN UNSIGNED16         * status
    )
/*++
Routine Description:

    Export interfaces and objects to a server entry.

Arguments:

    EntryNameSyntax - Name syntax

    EntryName       - Name string of the entry to export

    Interface       - Interface unexport

    BindingVector   - Vector of string bindings to export.

    ObjectVector    - Objects to add to the entry

    status          - Status is returned here

Returned Status:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_S_OUT_OF_MEMORY, NSI_S_INVALID_OBJECT, NSI_S_NOTHING_TO_EXPORT,
    NSI_S_ENTRY_TYPE_MISMATCH

--*/
{
    // EntryName can be at most MAX_ENTRY_NAME_LENGTH WCHARs long, including the terminating NULL.
    if (EntryName != NULL && wcslen(EntryName)+1 > MAX_ENTRY_NAME_LENGTH)
        RpcRaiseException(RPC_S_INVALID_ARG);

    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);

    DBGOUT(API, "\nExport for Entry " << EntryName << "\n\n");
    DBGOUT(API, "With Binding Vector:\n" << BindingVector);
    DBGOUT(API, "\n\nAnd Object Vector:\n" << ObjectVector << "\n\n");


    *status = NSI_S_OK;

    RPC_STATUS raw_status;

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try {
        myRpcLocator->nsi_binding_export(
                    EntryNameSyntax,
                    pEntryName,
                    Interface,
                    BindingVector,
                    ObjectVector,
                    Local
                    );
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_INVALID_OBJECT:
            case NSI_S_NOTHING_TO_EXPORT:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_INTERFACE_NOT_EXPORTED:
            case NSI_S_NOT_ALL_OBJS_EXPORTED:

/* the following converts ULONG to UNSIGNED16 but that's OK for the actual values */

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }
    raw_status = RpcRevertToSelf();
}



void
nsi_mgmt_binding_unexport(
    UNSIGNED32          EntryNameSyntax,
    STRING_T            EntryName,
    NSI_IF_ID_P_T       Interface,
    UNSIGNED32          VersOption,
    NSI_UUID_VECTOR_P_T ObjectVector,
    UNSIGNED16 *        status
    )
/*++

Routine Description:

    unExport a information from a server entry finer control then nsi_binding
    counter part.

Arguments:

    EntryNameSyntax - Name syntax

    EntryName       - Name string of the entry to unexport

    Interface       - Interface to unexport

    VersOption      - controls in fine detail which interfaces to remove.

    ObjectVector    - Objects to remove from the entry

    status          - Status is returned here

Returned Status:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_S_INVALID_VERS_OPTION, NSI_S_ENTRY_NOT_FOUND.
    NSI_S_NOTHING_TO_UNEXPORT, NSI_S_NOT_ALL_OBJS_UNEXPORTED,
    NSI_S_INTERFACE_NOT_FOUND

--*/
{
    RPC_STATUS raw_status;

    // EntryName can be at most MAX_ENTRY_NAME_LENGTH WCHARs long, including the terminating NULL.
    if (EntryName != NULL && wcslen(EntryName)+1 > MAX_ENTRY_NAME_LENGTH)
        RpcRaiseException(RPC_S_INVALID_ARG);

    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    *status = NSI_S_OK;

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;


    __try {
        myRpcLocator->nsi_mgmt_binding_unexport(
                            EntryNameSyntax,
                            pEntryName,
                            Interface,
                            VersOption,
                            ObjectVector
                            );

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_NOTHING_TO_UNEXPORT:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_NOT_ALL_OBJS_UNEXPORTED:
            case NSI_S_INTERFACE_NOT_FOUND:
            case NSI_S_INVALID_VERS_OPTION:

/* the following converts ULONG to UNSIGNED16 but that's OK for the actual values */

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }

    raw_status = RpcRevertToSelf();
}



void
nsi_binding_unexport(
    IN UNSIGNED32           EntryNameSyntax,
    IN STRING_T             EntryName,
    IN NSI_INTERFACE_ID_T * Interface,
    IN NSI_UUID_VECTOR_P_T  ObjectVector, OPT
    IN UNSIGNED16         * status
    )
/*++

Routine Description:

    unExport a information from a server entry..

Arguments:

    EntryNameSyntax - Name syntax

    EntryName       - Name string of the entry to unexport

    Interface       - Interface to unexport

    ObjectVector    - Objects to remove from the entry

    status          - Status is returned here

Returned Status:

    See: nsi_mgmt_binding_unexport()

--*/
{
    // EntryName can be at most MAX_ENTRY_NAME_LENGTH WCHARs long, including the terminating NULL.
    if (EntryName != NULL && wcslen(EntryName)+1 > MAX_ENTRY_NAME_LENGTH)
        RpcRaiseException(RPC_S_INVALID_ARG);

    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    // critical section taken in mgmt_unexport

    if (Interface && IsNilIfId(&(Interface->Interface))) Interface = NULL;

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;


    nsi_mgmt_binding_unexport(EntryNameSyntax, pEntryName,
        (Interface)? &Interface->Interface: NULL,
        RPC_C_VERS_EXACT, ObjectVector, status);
}



void
nsi_binding_lookup_begin(
    IN  UNSIGNED32           EntryNameSyntax,
    IN  STRING_T             EntryName,
    IN  NSI_INTERFACE_ID_T * Interface, OPT
    IN  NSI_UUID_P_T         Object, OPT
    IN  UNSIGNED32           VectorSize,
    IN  UNSIGNED32           MaxCacheAge,
    OUT NSI_NS_HANDLE_T    * InqContext,
    IN  UNSIGNED16         * status
    )
/*++

Routine Description:

    Start a lookup operation.  Just save all the input params in the
    newly created lookup context.  Perform the initial query.

Arguments:

    EntryNameSyntax - Name syntax

    EntryName       -  Name string to lookup on.

    Interface       - Interface to search for

    Object          - Object to search for

    VectorSize      - Size of return vector

    MaxCacheAge     - take seriously if nonzero    -- always zero for old locator

    InqContext      - Context to continue with for use with "Next"

    status          - Status is returned here

Returned Status:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_ENTRY_NOT_FOUND,
    NSI_OUT_OF_MEMORY

--*/
{
    // EntryName can be at most MAX_ENTRY_NAME_LENGTH WCHARs long, including the terminating NULL.
    if (EntryName != NULL && wcslen(EntryName)+1 > MAX_ENTRY_NAME_LENGTH)
        RpcRaiseException(RPC_S_INVALID_ARG);

    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);

    DBGOUT(API, "\nLookup Begin for Entry " << EntryName << "\n\n");

    RPC_STATUS raw_status;

    *status = NSI_S_OK;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;

    __try {
        *InqContext =
            myRpcLocator->nsi_binding_lookup_begin(
                            EntryNameSyntax,
                            pEntryName,
                            Interface, OPT
                            Object, OPT
                            VectorSize,
                            MaxCacheAge,
                            LocalLookup
                            );

    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_INVALID_OBJECT:
            case NSI_S_NAME_SERVICE_UNAVAILABLE:
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_ENTRY_TYPE_MISMATCH:

/* the following converts ULONG to UNSIGNED16 but that's OK for the actual values */

                *status = (UNSIGNED16) raw_status;
                break;

            case NSI_S_NO_MORE_BINDINGS:

                *status = NSI_S_ENTRY_NOT_FOUND;

        /* N.B. This is all we really know, but the old locator did the above
            *status = NSI_S_OK;
        */
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }

        *InqContext = NULL;
    }

    raw_status = RpcRevertToSelf();

    DBGOUT(API, "\nExiting Lookup Begin with Status " << *status << "\n\n");
}


void
nsi_binding_lookup_next(
    OUT NSI_NS_HANDLE_T         InqContext,
    OUT NSI_BINDING_VECTOR_T ** BindingVectorOut,
    IN  UNSIGNED16            * status
    )
/*++

Routine Description:

    Continue a lookup operation.

Arguments:

    InqContext       - Context to continue with.

    BindingVectorOut - Pointer to return new vector of bindings

    status           - Status is returned here

Returned Status:

    NSI_S_OK, NSI_OUT_OF_MEMORY, NSI_S_NO_MORE_BINDINGS,
    NSI_S_INVALID_NS_HANDLE

--*/
{
    RPC_STATUS raw_status;

    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try {
        if (((CContextHandle *)InqContext)->myLocatorCount != LocatorCount)
            *BindingVectorOut = NULL;
        else {
            CLookupHandle *pHandle = (CLookupHandle *) InqContext;
            *BindingVectorOut = pHandle->next();
        }
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {
        *status = (UNSIGNED16) GetExceptionCode();
        return;
    }

    if (!*BindingVectorOut)
       *status = NSI_S_NO_MORE_BINDINGS;
    else
       *status = NSI_S_OK;

    raw_status = RpcRevertToSelf();
}


void
nsi_binding_lookup_done(
    IN OUT NSI_NS_HANDLE_T    * pInqContext,
    IN  UNSIGNED16            * pStatus
    )

/*++
Routine Description:

    Finish up a lookup operation.

Arguments:

    InqContext - Context to close

    status     - Status is returned here

Returned Status:

    NSI_S_OK

--*/

{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);

    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *pStatus = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    NSI_NS_HANDLE_T_done(pInqContext,pStatus);

    raw_status = RpcRevertToSelf();
}


void nsi_mgmt_handle_set_exp_age(
    /* [in] */ NSI_NS_HANDLE_T inq_context,
    /* [in] */ UNSIGNED32 expiration_age,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)
/*++
Routine Description:

    Set cache tolerance (expiration) age for a specific NS handle.

Arguments:

    InqContext        - Context to set age for

    expiration_age    - expiration age in seconds

    status            - Status is returned here

Returned Status:

    NSI_S_OK

--*/

{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);

    CContextHandle *pHandle = (CContextHandle *) inq_context;

    *status = NSI_S_OK;

    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    if (pHandle)

        __try {

        if (((CContextHandle *)inq_context)->myLocatorCount != LocatorCount)
            ;
        else
            pHandle->setExpiryAge(expiration_age);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            *status = (UNSIGNED16) GetExceptionCode();
        }

    raw_status = RpcRevertToSelf();
}


void nsi_mgmt_inq_exp_age(
    /* [out] */ UNSIGNED32 __RPC_FAR *expiration_age,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++
Routine Description:

    Check the global cache tolerance (expiration) age.

Arguments:

    expiration_age    - expiration age in seconds returned here

    status            - Status is returned here

Returned Status:

    NSI_S_OK

--*/
{
    RPC_STATUS raw_status;

    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    if (myRpcLocator->fNT4Compat)
        *expiration_age = myRpcLocator->ulMaxCacheAge;
    else
        *expiration_age = 0;

    *status = NSI_S_OK;

    raw_status = RpcRevertToSelf();
}


void nsi_mgmt_inq_set_age(
    /* [in] */ UNSIGNED32 expiration_age,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)
/*++
Routine Description:

    Set the global cache tolerance (expiration) age.

Arguments:

    expiration_age    - new global expiration age in seconds

    status            - Status is returned here

Returned Status:

    NSI_S_OK

--*/
{
    /* No need for locks since the new value does not depend on the old
       and race conditions need not be dealt with -- the old value is
       as legitimate as the new
    */

    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    myRpcLocator->ulMaxCacheAge = expiration_age;

    QueryPacket NetRequest;
    if (myRpcLocator->fNT4Compat)
        myRpcLocator->broadcastCleared(NetRequest,myRpcLocator->ulMaxCacheAge);

    /* we also purge the broadcast history, if any, to reflect the new
       ulMaxCacheAge setting, with a phoney "clear broacast" request.
    */

    *status = NSI_S_OK;

    raw_status = RpcRevertToSelf();
}

void nsi_entry_object_inq_begin(
    /* [in] */ UNSIGNED32 EntryNameSyntax,
    /* [in] */ STRING_T EntryName,
    /* [out] */ NSI_NS_HANDLE_T __RPC_FAR *InqContext,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    Perform an object inquiry, including all available information
    (owned, cached and from the network). Return a context handle for
    actual information.

Arguments:

    EntryNameSyntax   - Name syntax

    EntryName         - Name string to lookup on

    InqContext        - The NS context handle is returned here

--*/
{
    // EntryName can be at most MAX_ENTRY_NAME_LENGTH WCHARs long, including the terminating NULL.
    if (EntryName != NULL && wcslen(EntryName)+1 > MAX_ENTRY_NAME_LENGTH)
        RpcRaiseException(RPC_S_INVALID_ARG);

    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);

    DBGOUT(API, "\nLookup Begin for Entry " << EntryName << "\n\n");

    RPC_STATUS raw_status;

    *status = NSI_S_OK;

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;


    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    __try {
        *InqContext =
            myRpcLocator->nsi_entry_object_inq_begin(
                            EntryNameSyntax,
                            pEntryName,
                            LocalLookup
                            );

    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_NAME_SERVICE_UNAVAILABLE:
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_ENTRY_TYPE_MISMATCH:


                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }

        *InqContext = NULL;
    }

    raw_status = RpcRevertToSelf();

    DBGOUT(API, "\nExiting ObjectInq Begin with Status " << *status << "\n\n");
}

void nsi_entry_object_inq_next(
    /* [in] */ NSI_NS_HANDLE_T InqContext,
    /* [out][in] */ NSI_UUID_P_T uuid,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    Get the next object UUID from the given context handle.

Arguments:

    InqContext    - The NS context handle

    uuid          - a pointer to the UUID is returned here

Returned Status:

    NSI_S_OK, NSI_S_NO_MORE_MEMBERS

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    GUID * pgNextResult;
    __try {

        if (((CContextHandle *)InqContext)->myLocatorCount != LocatorCount)
            pgNextResult = NULL;
        else
            pgNextResult = ((CObjectInqHandle *) InqContext)->next();
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {
        *status = (UNSIGNED16) GetExceptionCode();
        return;
    }
    if (!pgNextResult)
            *status = NSI_S_NO_MORE_MEMBERS;
    else {
        *status = NSI_S_OK;
        *uuid = *pgNextResult;
    }

    raw_status = RpcRevertToSelf();
}

void nsi_entry_object_inq_done(
    /* [out][in] */ NSI_NS_HANDLE_T __RPC_FAR *inq_context,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    NSI_NS_HANDLE_T_done(inq_context,status);

    raw_status = RpcRevertToSelf();
}



/*********  Locator-to-Locator Server-side API implementations *********/
// Locator-to-Locator interfaces do not impersonate because they are mainly
// calls to the normal interfaces and thus do not need them.


void
I_nsi_lookup_begin(
    handle_t hrpcPrimaryLocatorHndl,
    UNSIGNED32 EntryNameSyntax,
    STRING_T EntryName,
    RPC_SYNTAX_IDENTIFIER * Interface,
    RPC_SYNTAX_IDENTIFIER * XferSyntax,
    NSI_UUID_P_T Object,
    UNSIGNED32 VectorSize,
    UNSIGNED32 maxCacheAge,       // if nonzero, take it seriously
    NSI_NS_HANDLE_T *InqContext,
    UNSIGNED16 *status)
/*++
Routine Description:


Arguments:


Returns:

Comments:
    Some of the code is the same as nsi_lookup_begin
    but on the PDC we didn't want it to look in the DS.
    It only returns the results from the broadcast.
--*/
{
    // EntryName can be at most MAX_ENTRY_NAME_LENGTH WCHARs long, including the terminating NULL.
    if (EntryName != NULL && wcslen(EntryName)+1 > MAX_ENTRY_NAME_LENGTH)
        RpcRaiseException(RPC_S_INVALID_ARG);

    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    NSI_INTERFACE_ID_T * InterfaceAndXfer = new NSI_INTERFACE_ID_T;


    CriticalReader  me(rwLocatorGuard);
    DBGOUT(BROADCAST, "Broadcast Lookup::Broadcast lookup request has arrived\n");

    if (Interface) InterfaceAndXfer->Interface = *Interface;
    else memset(&InterfaceAndXfer->Interface,0,sizeof(InterfaceAndXfer->Interface));

    if (XferSyntax) InterfaceAndXfer->TransferSyntax = *XferSyntax;
    else memset(&InterfaceAndXfer->TransferSyntax,0,sizeof(InterfaceAndXfer->TransferSyntax));

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;


    DBGOUT(TRACE, "Broadcast Lookup::Calling the normal lookup\n");

    DBGOUT(API, "\nLookup Begin Broadcast for Entry " << EntryName << "\n\n");

    RPC_STATUS raw_status;

    *status = NSI_S_OK;

    __try {
        *InqContext =
            myRpcLocator->nsi_binding_lookup_begin(
                            EntryNameSyntax,
                            pEntryName,
                            InterfaceAndXfer, OPT
                            Object, OPT
                            VectorSize,
                            maxCacheAge,
                            BroadcastLookup
                            );
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_INVALID_OBJECT:
            case NSI_S_NAME_SERVICE_UNAVAILABLE:
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_ENTRY_TYPE_MISMATCH:

/* the following converts ULONG to UNSIGNED16 but that's OK for the actual values */

                *status = (UNSIGNED16) raw_status;
                break;

           case NSI_S_NO_MORE_BINDINGS:

                *status = NSI_S_ENTRY_NOT_FOUND;

        /* N.B. This is all we really know, but the old locator did the above
            *status = NSI_S_OK;
        */
                break;

           default:
                *status = NSI_S_INTERNAL_ERROR;
        }

        *InqContext = NULL;
    }

    if (*InqContext) {
        CLocToLocCompleteHandle *pltlHandle = new CLocToLocCompleteHandle(
                        (CCompleteHandle<NSI_BINDING_VECTOR_T> *)(*InqContext));
        // BUGBUG:: Will this wrapping affect the serialization that satish is talking abt.
        *InqContext = pltlHandle;

        /* here we are using a formerly unused parameter to avoid sending outdated info
           from the master.  this is only a partial solution but better than nothing */

        if ((*status == NSI_S_OK) && (maxCacheAge != 0))
            nsi_mgmt_handle_set_exp_age(
                pltlHandle->pcompleteHandle,
                maxCacheAge,
                status
                );

    }
    else
        *InqContext = NULL;

    delete InterfaceAndXfer;

    DBGOUT(API, "\nExiting Lookup Begin with Status " << *status << "\n\n");
}



void
I_nsi_lookup_done(
    handle_t hrpcPrimaryLocatorHndl,
    NSI_NS_HANDLE_T *InqContext,
    UNSIGNED16 *status)
/*++

Routine Description:


Arguments:


Returns:


--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    if (!(*InqContext))
        return;

    DBGOUT(BROADCAST, "Lookup Done called on LocToLoc Handle\n");

    CLocToLocCompleteHandle *pltlHandle =
             (CLocToLocCompleteHandle *)(*InqContext);

    DBGOUT(BROADCAST, "Local handle done called for LocToLoc Handle\n");
    nsi_binding_lookup_done((NSI_NS_HANDLE_T *)&(pltlHandle->pcompleteHandle), status);
    pltlHandle->pcompleteHandle = NULL;

    DBGOUT(BROADCAST, "Deleting LocToLoc Handle\n");
    delete pltlHandle;


    *InqContext = NULL;
}



void
I_nsi_lookup_next(
    handle_t hrpcPrimaryLocatorHndl,
    NSI_NS_HANDLE_T InqContext,
    NSI_BINDING_VECTOR_P_T *BindingVectorOut,
    UNSIGNED16 *status)
/*++

Routine Description:

Arguments:

Returns:

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);

    if (!InqContext)
        return;

    CLocToLocCompleteHandle *pltlHandle = (CLocToLocCompleteHandle *)InqContext;

    DBGOUT(TRACE, "Broadcast Lookup:: Next Called\n");

    do {
        nsi_binding_lookup_next(
            pltlHandle->pcompleteHandle,
            BindingVectorOut,
            status);

        if (!(*BindingVectorOut))
            return;
        else
            pltlHandle->StripObjectsFromAndCompress(BindingVectorOut);
    } while (!(*BindingVectorOut)->count);
}



void
I_nsi_entry_object_inq_next(
    IN  handle_t            hrpcPrimaryLocatorHndl,
    IN  NSI_NS_HANDLE_T     InqContext,
    OUT NSI_UUID_VECTOR_P_T *uuid_vector,
    OUT UNSIGNED16          *status
    )
/*++

Routine Description:

    Continue an inquiry for objects in an entry.

Arguments:

    InqContext    - Context to continue with

    uuid          - pointer to return object in.

    status        - Status is returned here

Returns:

    NSI_S_OK, NSI_S_NO_MORE_MEMBERS

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    __try {

        if (((CContextHandle *)InqContext)->myLocatorCount != LocatorCount)
            *uuid_vector = NULL;
        else
            *uuid_vector = getVector((CObjectInqHandle *) InqContext);
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {
        *status = (UNSIGNED16) GetExceptionCode();
        return;
    }

    *status = NSI_S_OK;
}

void
I_nsi_ping_locator(
       handle_t h,
       error_status_t * Status
       )
{
    if (!fLocatorInitialized)
        InitializeLocator();

    *Status = 0;
}



void
I_nsi_entry_object_inq_begin(
    handle_t             hrpcPrimaryHandle,
    IN  UNSIGNED32       EntryNameSyntax,
    IN  STRING_T         EntryName,
    OUT NSI_NS_HANDLE_T *InqContext,
    OUT UNSIGNED16      *status
    )
/*++

Routine Description:

    Start a inquiry for objects in an entry.

Arguments:

    EntryNameSyntax    - Name syntax

    EntryName          - Name of the entry to find objects in

    InqContext         - Context to continue with for use with "Next"

    status             - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    // EntryName can be at most MAX_ENTRY_NAME_LENGTH WCHARs long, including the terminating NULL.
    if (EntryName != NULL && wcslen(EntryName)+1 > MAX_ENTRY_NAME_LENGTH)
        RpcRaiseException(RPC_S_INVALID_ARG);

    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    DBGOUT(API, "\nLookup Begin for Entry " << EntryName << "\n\n");

    RPC_STATUS raw_status;

    *status = NSI_S_OK;

    STRING_T pEntryName;
    if ((EntryName) && (wcscmp(EntryName, L"") == 0))
        pEntryName = NULL;
    else
        pEntryName = EntryName;

    __try {
        *InqContext =
            myRpcLocator->nsi_entry_object_inq_begin(
                            EntryNameSyntax,
                            pEntryName,
                            BroadcastLookup
                            );

    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_NAME_SERVICE_UNAVAILABLE:
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_ENTRY_TYPE_MISMATCH:


                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }

        *InqContext = NULL; // new CContextHandle;  // i.e., a NULL handle
    }

    DBGOUT(API, "\nExiting ObjectInq Begin with Status " << *status << "\n\n");
}


void
I_nsi_entry_object_inq_done(
    IN OUT NSI_NS_HANDLE_T *pInqContext,
    OUT    UNSIGNED16      *pStatus
    )
/*++

Routine Description:

    Finish an inquiry on a object.

Arguments:

    InqContext - Context to close

    status - Status is returned here

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    NSI_NS_HANDLE_T_done(pInqContext,pStatus);
}

void nsi_group_mbr_add(
    /* [in] */ UNSIGNED32 group_name_syntax,
    /* [in] */ STRING_T group_name,
    /* [in] */ UNSIGNED32 member_name_syntax,
    /* [in] */ STRING_T member_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    Add a member to the group. if the group doesn't exist create it.

Arguments:

    group_name_syntax  - Name syntax

    group_name         - Name of the group to add the member to

    member_name_syntax - Name syntax

    member_name        - Name of the member that has to be added

    status             - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    *status = NSI_S_OK;

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try
    {
        myRpcLocator->nsi_group_mbr_add(
                group_name_syntax,
                group_name,
                member_name_syntax,
                member_name
                );
    }

    __except (EXCEPTION_EXECUTE_HANDLER)
    {

        switch (raw_status = GetExceptionCode())
        {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_ENTRY_ALREADY_EXISTS:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_GRP_ELT_NOT_ADDED:

        // the following converts ULONG to UNSIGNED16
        // but that's OK for the actual values

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }

    raw_status = RpcRevertToSelf();
}

void nsi_group_mbr_remove(
    /* [in] */ UNSIGNED32       group_name_syntax,
    /* [in] */ STRING_T         group_name,
    /* [in] */ UNSIGNED32       member_name_syntax,
    /* [in] */ STRING_T         member_name,
    /* [out] */ UNSIGNED16 __RPC_FAR   *status)
/*++

Routine Description:

    Remove a member from the group.

Arguments:

    group_name_syntax  - Name syntax

    group_name         - Name of the group to remove the member from

    member_name_syntax - Name syntax

    member_name        - Name of the member that has to be removed

    status             - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/

{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    *status = NSI_S_OK;

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try
    {
            myRpcLocator->nsi_group_mbr_remove(
                        group_name_syntax,
                        group_name,
                        member_name_syntax,
                        member_name
                        );
    }

    __except (EXCEPTION_EXECUTE_HANDLER)
    {

        switch (raw_status = GetExceptionCode())
            {
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_GRP_ELT_NOT_REMOVED:

            // the following converts ULONG to UNSIGNED16
            // but that's OK for the actual values

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }
    raw_status = RpcRevertToSelf();
}

void nsi_group_mbr_inq_begin(
    /* [in] */ UNSIGNED32 group_name_syntax,
    /* [in] */ STRING_T group_name,
    /* [in] */ UNSIGNED32 member_name_syntax,
    /* [out] */ NSI_NS_HANDLE_T __RPC_FAR *inq_context,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    enumerate members from the group.

Arguments:

    group_name_syntax  - Name syntax

    group_name         - Name of the group to enumerate

    member_name_syntax - Name syntax

    inq_context        - name service handle for next.

    status             - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);
    *status = NSI_S_OK;

    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    __try
    {
        *inq_context = myRpcLocator->nsi_group_mbr_inq_begin(
                            group_name_syntax,
                            group_name,
                            member_name_syntax
                            );
    }

    __except (EXCEPTION_EXECUTE_HANDLER)
    {

        switch (raw_status = GetExceptionCode())
        {
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_ENTRY_NOT_FOUND:

            // the following converts ULONG to UNSIGNED16
            // but that's OK for the actual values

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
        *inq_context = NULL;
    }
    raw_status = RpcRevertToSelf();
}

void nsi_group_mbr_inq_next(
    /* [in] */ NSI_NS_HANDLE_T InqContext,
    /* [out] */ STRING_T __RPC_FAR *member_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    enumerate members from the group.

Arguments:

    inq_context        - name service handle got from begin.

    member_name        - Name of the group to enumerate

    status             - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    __try {

        CGroupInqHandle *pHandle = (CGroupInqHandle *) InqContext;
        *member_name = pHandle->next();
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {
        *status = (UNSIGNED16) GetExceptionCode();
        return;
    }

    if (!*member_name)
         *status = NSI_S_NO_MORE_MEMBERS;
    else *status = NSI_S_OK;

    raw_status = RpcRevertToSelf();
}


void nsi_group_mbr_inq_done(
    /* [out][in] */ NSI_NS_HANDLE_T __RPC_FAR *pInqContext,
    /* [out] */ UNSIGNED16 __RPC_FAR *pStatus)

{
    if (!fLocatorInitialized)
        InitializeLocator();

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *pStatus = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    NSI_NS_HANDLE_T_done(pInqContext,pStatus);

    raw_status = RpcRevertToSelf();
}

void nsi_profile_elt_add(
    /* [in] */ UNSIGNED32 profile_name_syntax,
    /* [in] */ STRING_T profile_name,
    /* [in] */ NSI_IF_ID_P_T if_id,
    /* [in] */ UNSIGNED32 member_name_syntax,
    /* [in] */ STRING_T member_name,
    /* [in] */ UNSIGNED32 priority,
    /* [in] */ STRING_T annotation,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    add elements from the profile.

Arguments:

    profile_name_syntax  - Name syntax of the profile

    profile_name         - Name of the profile.

    if_id        - interface id for the profile element.

    member_name_syntax   - Name syntax of the member.

    member_name      - Name of the member.

    priority         - Priority for the element.

    annotation       - Annotation for the element.

    status               - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    *status = NSI_S_OK;

    CriticalReader  me(rwLocatorGuard);
    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try
    {
        myRpcLocator->nsi_profile_elt_add(
                                    profile_name_syntax,
                                    profile_name,
                                    if_id,
                                    member_name_syntax,
                                    member_name,
                                    priority,
                                    annotation
                                    );
    }

    __except (EXCEPTION_EXECUTE_HANDLER)
    {

        switch (raw_status = GetExceptionCode())
        {
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_ENTRY_ALREADY_EXISTS:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_PROFILE_NOT_ADDED:
            case NSI_S_PRF_ELT_NOT_ADDED:

            // the following converts ULONG to UNSIGNED16
            // but that's OK for the actual values

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }
    raw_status = RpcRevertToSelf();
}

void nsi_profile_elt_remove(
    /* [in] */ UNSIGNED32 profile_name_syntax,
    /* [in] */ STRING_T profile_name,
    /* [in] */ NSI_IF_ID_P_T if_id,
    /* [in] */ UNSIGNED32 member_name_syntax,
    /* [in] */ STRING_T member_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    remove element from the profile.

Arguments:

    profile_name_syntax  - Name syntax of the profile

    profile_name         - Name of the profile.

    if_id        - interface id for the profile element.

    member_name_syntax   - Name syntax of the member.

    member_name      - Name of the member.

    status               - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);
    *status = NSI_S_OK;

    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    __try
    {
            myRpcLocator->nsi_profile_elt_remove(
                                        profile_name_syntax,
                                        profile_name,
                                        if_id,
                                        member_name_syntax,
                                        member_name
                                        );
    }

    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        switch (raw_status = GetExceptionCode())
            {
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_PRF_ELT_NOT_REMOVED:
                // the following converts ULONG to UNSIGNED16
                    // but that's OK for the actual values

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }
    raw_status = RpcRevertToSelf();
}

void nsi_profile_elt_inq_begin(
    /* [in] */ UNSIGNED32 profile_name_syntax,
    /* [in] */ STRING_T profile_name,
    /* [in] */ UNSIGNED32 inquiry_type,
    /* [in] */ NSI_IF_ID_P_T if_id,
    /* [in] */ UNSIGNED32 vers_option,
    /* [in] */ UNSIGNED32 member_name_syntax,
    /* [in] */ STRING_T member_name,
    /* [out] */ NSI_NS_HANDLE_T __RPC_FAR *inq_context,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    enumerate members elements from the profile depending on some criteria.

Arguments:

    profile_name_syntax  - Name syntax of the profile

    profile_name         - Name of the profile.

    inquiry_type     - type of inquiry. look in DCE spec.

    if_id        - interface id for the profile element.

    vers_option      - look in DCE spec.

    member_name_syntax   - Name syntax of the member.

    member_name      - Name of the member.

    priority         - Priority for the element.

    inq_context          - name service handle for next.

    status               - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    CriticalReader  me(rwLocatorGuard);
    *status = NSI_S_OK;

    RPC_STATUS raw_status;

    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try
    {
            *inq_context = myRpcLocator->nsi_profile_elt_inq_begin(
                                                            profile_name_syntax,
                                                            profile_name,
                                                            inquiry_type,
                                                            if_id,
                                                            vers_option,
                                                            member_name_syntax,
                                                            member_name
                                                            );
    }

    __except (EXCEPTION_EXECUTE_HANDLER)
    {

        switch (raw_status = GetExceptionCode())
        {
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_INCOMPLETE_NAME:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_ENTRY_TYPE_MISMATCH:
            case NSI_S_ENTRY_NOT_FOUND:

                 // the following converts ULONG to UNSIGNED16
                 // but that's OK for the actual values

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
        *inq_context = NULL;
    }
    raw_status = RpcRevertToSelf();
}

void nsi_profile_elt_inq_next(
    /* [in]  */ NSI_NS_HANDLE_T inq_context,
    /* [out] */ NSI_IF_ID_P_T if_id,
    /* [out] */ STRING_T __RPC_FAR *member_name,
    /* [out] */ UNSIGNED32 __RPC_FAR *priority,
    /* [out] */ STRING_T __RPC_FAR *annotation,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    enumerate members elements from the profile depending on some criteria.

Arguments:

    inq_context          - name service handle for next.

    if_id        - interface id for the profile element.

    member_name      - Name of the member.

    priority         - Priority for the element.

    annotation       - Annotation for the element.

    status               - Status is returned here

Returns:

    NSI_S_OK, NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY

--*/

{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    RPC_STATUS raw_status;

    CriticalReader  me(rwLocatorGuard);
    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }

    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    __try {

           CProfileInqHandle *pHandle = (CProfileInqHandle *) inq_context;
           CProfileElement *pElt = pHandle->next();

           if (pElt == NULL) Raise(NSI_S_NO_MORE_MEMBERS);

           *member_name = pElt->EntryName.copyAsMIDLstring();
           *priority = pElt->dwPriority;
           *annotation = CStringW::copyMIDLstring(pElt->pszAnnotation);
           *if_id = pElt->Interface.myIdAndVersion();
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {
        *status = (UNSIGNED16) GetExceptionCode();
        return;
    }
    *status = NSI_S_OK;

    raw_status = RpcRevertToSelf();
}

void nsi_profile_elt_inq_done(
    /* [out][in] */ NSI_NS_HANDLE_T __RPC_FAR *pInqContext,
    /* [out] */ UNSIGNED16 __RPC_FAR *pStatus)

/*++

Routine Description:

    close the handle

--*/
{
    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    RPC_STATUS raw_status;

    CriticalReader  me(rwLocatorGuard);
    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *pStatus = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));
    NSI_NS_HANDLE_T_done(pInqContext,pStatus);

    raw_status = RpcRevertToSelf();
}



void nsi_mgmt_entry_delete(
    /* [in] */ UNSIGNED32 entry_name_syntax,
    /* [in] */ STRING_T entry_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    deletes an entry.

Arguments:
    entry_name_syntax   - syntax of the entry name

    entry_name      - entry name

    status      - status is returned here.


Comments:
    whether the entry was created by create or
    during export it deletes it recursively.
--*/
{
    if (entry_name != NULL && wcslen(entry_name)+1 > MAX_ENTRY_NAME_LENGTH)
        RpcRaiseException(RPC_S_INVALID_ARG);

    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    RPC_STATUS raw_status;
    *status = NSI_S_OK;

    CriticalReader  me(rwLocatorGuard);
    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try {
        myRpcLocator->nsi_mgmt_entry_delete(
                            entry_name_syntax,
                            entry_name,
                            AnyEntryType);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_ENTRY_NOT_FOUND:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_NAME_SERVICE_UNAVAILABLE:

/* the following converts ULONG to UNSIGNED16 but that's OK for the actual values */

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }
    raw_status = RpcRevertToSelf();
}


void nsi_mgmt_entry_create(
    /* [in] */ UNSIGNED32 entry_name_syntax,
    /* [in] */ STRING_T entry_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

/*++

Routine Description:

    Creates an entry in the DS.

Arguments:
    entry_name_syntax   - syntax of the entry name

    entry_name      - entry name

    status      - status is returned here.


Comments:
   Marks it to distinguish it from entries in which some activity has been done
   The mark is removed as soon as something is done in the locator.
   The marked entry can be deleted and another entry can be created in its
   place which is group/profile.

Reason:
   Present schema has seperate group, profile and server entry type.
   which is different from DCE spec.

--*/
{
    if (entry_name != NULL && wcslen(entry_name)+1 > MAX_ENTRY_NAME_LENGTH)
        RpcRaiseException(RPC_S_INVALID_ARG);

    if (!fLocatorInitialized)
        InitializeLocator();

    CheckForLocalClientIfNecessary();

    RPC_STATUS raw_status;

    *status = NSI_S_OK;

    CriticalReader  me(rwLocatorGuard);
    raw_status = RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    if (raw_status != RPC_S_OK) {
        *status = NSI_S_NO_NS_PRIVILEGE;
        return;
    }


    CDSHandle CDSCachedHandle(*(myRpcLocator->pDomainNameDns), *(myRpcLocator->pRpcContainerDN));

    __try {
        myRpcLocator->nsi_mgmt_entry_create(
                            entry_name_syntax,
                            entry_name);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        switch (raw_status = GetExceptionCode()) {
            case NSI_S_NO_NS_PRIVILEGE:
            case NSI_S_UNSUPPORTED_NAME_SYNTAX:
            case NSI_S_ENTRY_ALREADY_EXISTS:
            case NSI_S_OUT_OF_MEMORY:
            case NSI_S_NAME_SERVICE_UNAVAILABLE:

/* the following converts ULONG to UNSIGNED16 but that's OK for the actual values */

                *status = (UNSIGNED16) raw_status;
                break;

            default:
                *status = NSI_S_INTERNAL_ERROR;
        }
    }
    raw_status = RpcRevertToSelf();
}


void nsi_entry_expand_name(
    /* [in] */ UNSIGNED32 entry_name_syntax,
    /* [in] */ STRING_T entry_name,
    /* [out] */ STRING_T __RPC_FAR *expanded_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

{
   *status = NSI_S_UNIMPLEMENTED_API;
}

void nsi_group_delete(
    /* [in] */ UNSIGNED32 group_name_syntax,
    /* [in] */ STRING_T group_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

{
   *status = NSI_S_UNIMPLEMENTED_API;
}

void nsi_profile_delete(
    /* [in] */ UNSIGNED32 profile_name_syntax,
    /* [in] */ STRING_T profile_name,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

{
   *status = NSI_S_UNIMPLEMENTED_API;
}

void nsi_mgmt_entry_inq_if_ids(
    /* [in] */ UNSIGNED32 entry_name_syntax,
    /* [in] */ STRING_T entry_name,
    /* [out] */ NSI_IF_ID_VECTOR_T __RPC_FAR *__RPC_FAR *if_id_vec,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)

{
    *status = NSI_S_UNIMPLEMENTED_API;
}


} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\debug.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    debug.cxx

Abstract:

   This file contains the implementations for non inline member functions
   used for debugging output via the CDebugStream class, as well as debug
   and retail versions of midl_user_{allocate,free}.

Author:

    Satish Thatte (SatishT) 08/15/95  Created all the code below except where
									  otherwise indicated.

--*/


#include <locator.hxx>

#if DBG


CDebugStream&
CDebugStream::operator<<(
				NSI_SERVER_BINDING_VECTOR_T * pbvt
				)
{
	if (!pbvt) return *this;
	OutputDebugString(WNL);

	for (ULONG i = 0; i < pbvt->count; i++) {
		OutputDebugString(pbvt->string[i]);
		OutputDebugString(WNL);
	}

	OutputDebugString(WNL);
	return *this;
}

	
CDebugStream&
CDebugStream::operator<<(
				NSI_UUID_T * puuid
				)
{
	if (!puuid) return *this;
	*this << " ";

	WCHAR * pBuffer;

	UuidToString(puuid, &pBuffer);
	*this << pBuffer;
	RpcStringFree(&pBuffer);
	*this << " ";

	return *this;
}


CDebugStream&
CDebugStream::operator<<(
				NSI_UUID_VECTOR_T * puvt
				)
{
	if (!puvt) return *this;
	OutputDebugString(WNL);

	for (ULONG i = 0; i < puvt->count; i++) {
		*this << puvt->uuid[i];
		OutputDebugString(WNL);
	}

	OutputDebugString(WNL);
	return *this;
}

CDebugStream&
CDebugStream::operator<<(NSI_SYNTAX_ID_T * pIF_ID)
{
	if (!pIF_ID) return *this;

    *this << &pIF_ID->SyntaxGUID << " Version "
          << pIF_ID->SyntaxVersion.MajorVersion << "."
          << pIF_ID->SyntaxVersion.MinorVersion;

	return *this;
}


#endif

extern "C" {

void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{

//#if DBG
//    void* pResult = CoTaskMemAlloc(len);
	// void* pResult = malloc(len);
//#else
	void* pResult = malloc(len);
//#endif

	if (pResult) return pResult;
	else Raise(NSI_S_OUT_OF_MEMORY);

	// the following just keeps the compiler happy

	return NULL;
}

void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
//#if DBG
//    CoTaskMemFree(ptr);
	// free(ptr);
//#else
	free(ptr);
//#endif
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\linklist.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    linklist.cxx

Abstract:

	This module contains definitions of non inline member functions for the
	basic implementation class CLinkList.
	
Author:

    Satish Thatte (SatishT) 08/16/95  Created all the code below except where
									  otherwise indicated.

--*/

#include <locator.hxx>


extern char * LLname = "CLinkList";

extern char * Lname = "Link";

	
CLinkList::Link::Link(IDataItem* a, Link* n) {
	data = a; 
	next = n;
	fDeleteData = FALSE;
}

CLinkList::Link::~Link() {		// called when ref count goes to zero
	if (next) next->release(); 
	if (fDeleteData) delete data;  // should this be release?
}

	
void CLinkList::enque(IDataItem* x) 
{	// no hold() calls needed because the constructor does an implicit hold
	if (pLnkLast) pLnkLast = pLnkLast->next = new Link(x, NULL);
	else pLnkFirst = pLnkLast = new Link(x,NULL);

	ulCount++;
}

void 
CLinkList::push(IDataItem* x) 
{	// see comment above
	pLnkFirst = new Link(x, pLnkFirst);
	if (!pLnkLast) pLnkLast = pLnkFirst;

	ulCount++;
}



void
CLinkList::releaseAll(Link *pCurr) 

/*  The reason why this method doesn't just release pCurr is
    because we must avoid stack overflow caused by a runaway recursive
	release effect.  So we do this iteratively.  We must, however,
	make sure to stop if we hit a link that would not be deleted if 
	released because we are releasing the next one only to simulate
    the release that would happen due to deletion of the current link.
*/

{
	Link *pPrev = NULL;

	/* The invariant for the loop below is that pCurr->ulRefCount 
	   is 1 higher than it should be, if pCurr != NULL.
	*/

	while (pCurr && pCurr->willBeDeletedIfReleased()) {
		pPrev = pCurr;
		pCurr = pCurr->next;
		if (pCurr) pCurr->hold();
		pPrev->release();
	}

	if (pCurr) pCurr->release();

//	printStats();
}


IDataItem* 
CLinkList::pop() 

/*++
Routine Description:

	Delete first item in the CLinkList and return it
	
--*/

{
	if (!pLnkFirst) return NULL;
		
	IDataItem* result = pLnkFirst->data;
	Link* oldFirst = pLnkFirst;
	pLnkFirst = pLnkFirst->next;
	if (!pLnkFirst) pLnkLast = NULL;  // nothing left
	else pLnkFirst->hold();
	oldFirst->release();

	ulCount--;
	return result;
}
		
int
CLinkList::remove(IDataItem* pDI)  

/*++
Routine Description:

	Remove the specified item and return it -- using pointer equality. 

    The return value primarily acts as a flag notifying success/failure
	
--*/

{
	if (!pLnkFirst) return FALSE;			// empty list

	if (pLnkFirst->data == pDI) { 			// remove first item
		pop();
		return TRUE;
	}

	Link * pLnkPrev = pLnkFirst, * pLnkCurr = pLnkFirst->next;

	while (pLnkCurr && (pLnkCurr->data != pDI)) {
		pLnkPrev = pLnkCurr; pLnkCurr = pLnkCurr->next;
	}

	if (!pLnkCurr) return FALSE;			// not found

	/* pLnkCurr contains the item to be removed and it is not the only 
	   item in the list since it is not the first item */

	pLnkPrev->next = pLnkCurr->next;
	if (pLnkPrev->next) 
            pLnkPrev->next->hold();
        else
            pLnkLast = pLnkPrev;               // this is the new last element.

	pLnkCurr->release();

	ulCount--;
	return TRUE;
}

IDataItem* 
CLinkList::nth(long lOrdinal)

/*++
Routine Description:

	Simply return the Nth data item -- starting the count at 0.
	
--*/

{
	if (!pLnkFirst) return NULL;			// empty list

	Link * pLnkCurr = pLnkFirst;
	long lCount = 0;

	while (pLnkCurr && (lCount++ < lOrdinal))
		pLnkCurr = pLnkCurr->next;

	if (!pLnkCurr) return NULL;			// not found
	else return pLnkCurr->data;
}

void 
CLinkList::rotate(long lDegree)

/*++
Routine Description:

	This routine imagines that the list is in fact circular and 
	rotates it by lDegree -- using pop and enque for modularity.  
	We could actually move links around, but this operation is
	not frequent enough (once for every NS lookup). Here we pay the
	price of not having a true circular list (we moved away from
	the true circular list for ref counting).
	
--*/

{
	if (!pLnkFirst) return;	// nothing to rotate;

	IDataItem *pCurr;

	for (long i = 0; i < (lDegree % ulCount); i++) {
		pCurr = pop();
		enque(pCurr);
	}
}


	
IDataItem* 
CLinkList::find(IDataItem* pDI,			// item to find
				TcompFun comp			// (pointer to) comparison function
			   )

/*++
Routine Description:

	Unlike remove, this method is designed to use a client-supplied
	comparison function instead of pointer equality.  The comparison
	function is expected to behave like strcmp (returning <0 is less,
	0 if equal and >0 if greater).
	
--*/

{
	if (!pLnkFirst) return NULL;			// empty list

	Link * pLnkCurr = pLnkFirst;

	while (pLnkCurr && comp(pLnkCurr->data,pDI))
		pLnkCurr = pLnkCurr->next;

	if (!pLnkCurr) return NULL;			// not found
	else return pLnkCurr->data;
}


void CLinkList::catenate(CLinkList& ll)

/*++
Routine Description:

	append the argument list to the current one -- as is, not a copy
	
--*/

{
	if (!ll.pLnkFirst) return;	// nothing to catenate

	if (!pLnkFirst) pLnkFirst = ll.pLnkFirst;
	else pLnkLast->next = ll.pLnkFirst;

	pLnkLast = ll.pLnkLast;

	ulCount += ll.ulCount;

	/* we only need to hold the first link, because *it* holds the others */

	ll.pLnkFirst->hold();
}

void CLinkList::wipeOut() 

/*++
Routine Description:

	release all links and all data and reinitialize to empty list
	
--*/

{
	if (pLnkFirst) {

		Link *pCurr = pLnkFirst;

		do {
			pCurr->fDeleteData = TRUE;	// delete data when Link dies
			pCurr = pCurr->next;
		} while (pCurr);

		releaseAll(pLnkFirst);	// release as many links as you can, and do it
								// iteratively for robustness

		pLnkFirst = pLnkLast = NULL;
		ulCount = 0;
	}
}



CLinkListIterator::CLinkListIterator(CLinkList& source) {
	ptr = first = source.pLnkFirst;
	if (ptr) ptr->hold();
}




IDataItem* 
CLinkListIterator::next() {	// advance the iterator and return next IDataItem

		if (!ptr) return NULL;

		CLinkList::Link* tl = ptr;
		IDataItem* result = ptr->data;
		ptr = ptr->next;
		if (ptr) ptr->hold();
		tl->release();
		return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\dsqry.cxx ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:  dsqry.cxx
//
//  Contents:  Null queries on NTDS
//
//
//  History:   09-24-96     DebiM
//
//------------------------------------------------------------------------------
#include "locator.hxx"

CDSHandle::CDSHandle(STRING_T szDomainNameDns, STRING_T szRpcContainer)
{
    STRING_T szFullDN = NULL;
    
    hDSObject = NULL;
    if (myRpcLocator->fDSEnabled)
    {
        szFullDN = new WCHAR [LDAPPrefixLength+DSDomainBeginLength+wcslen(szDomainNameDns)+
                              DSDomainEndLength+wcslen(szRpcContainer)+1];

        wsprintf(szFullDN, L"%s%s%s%s%s", LDAPPrefix, DSDomainBegin, szDomainNameDns, DSDomainEndStr, szRpcContainer);

        DBGOUT(DIRSVC, "CDSHandle::CDSHandle Opening " << szFullDN << "in the DS\n");
        ADSIOpenDSObject(szFullDN, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, &hDSObject);
        delete szFullDN;
    }
}

CDSHandle::~CDSHandle()
{
    if (hDSObject)
        ADSICloseDSObject(hDSObject);
}

// returns the attribute corresp. to a given property.
DWORD GetPropertyFromAttr(ADS_ATTR_INFO *pattr, DWORD cNum, WCHAR *szProperty)
{
    DWORD   i;
    for (i = 0; i < cNum; i++)
        if (wcscmp(pattr[i].pszAttrName, szProperty) == 0)
            break;
        return i;
}


HRESULT GetRpcContainerForDomain(WCHAR *szDomain, WCHAR **pszRpcContainerDN, WCHAR **szDomainNameDns)
{
   WCHAR	          *szPath=NULL, *szDN = NULL;
   HANDLE              hDSObject = NULL;
   LPWSTR    	       AttrName = DEFAULTNAMINGCONTEXT;
   ADS_ATTR_INFO     * pAttr=NULL;
   DWORD               cgot=0, len = 0, dwResult = 0;
   HRESULT	           hr = S_OK;
   PDOMAIN_CONTROLLER_INFO pDCI;
    
   len = RPCCONTAINERPREFIXLEN+1+wcslen(ROOTCONTAINER);
   *szDomainNameDns = NULL;

   dwResult = DsGetDcName(NULL, szDomain, NULL, NULL,
                                      DS_IP_REQUIRED |
                                      DS_IS_FLAT_NAME |
                                      DS_DIRECTORY_SERVICE_PREFERRED |
                                      DS_RETURN_DNS_NAME,
                                      &pDCI);

   if ((dwResult == ERROR_SUCCESS) && (pDCI->DomainName)) {
        *szDomainNameDns = new WCHAR[wcslen(pDCI->DomainName)+1];
        if (!(*szDomainNameDns)) {
           NetApiBufferFree(pDCI);        
           return E_OUTOFMEMORY;
        }
            
        wcscpy(*szDomainNameDns, (pDCI->DomainName));
        NetApiBufferFree(pDCI);        
   }
   else {
    	DBGOUT(DIRSVC, "DsGetDc failed with error " << dwResult);
    	if (szDomain) {
            *szDomainNameDns = new WCHAR[wcslen(szDomain)+1];
            if (!(*szDomainNameDns)) {
               return E_OUTOFMEMORY;
            }
        
            wcscpy(*szDomainNameDns, (szDomain));
        }
   }

   // allocate memory
   if ((*szDomainNameDns) && (**szDomainNameDns))
        len += wcslen(*szDomainNameDns)+1;
        
   szPath = new WCHAR[len];
   if (!szPath)
       return E_OUTOFMEMORY;

   wsprintf(szPath, L"%s", RPCCONTAINERPREFIX);
   if ((*szDomainNameDns) && (**szDomainNameDns))
      wsprintf(szPath+wcslen(szPath), L"%s/", szDomainNameDns);
   wcscat(szPath, ROOTCONTAINER);

   DBGOUT(DIRSVC, "GetRpcContainerForDomain Opening " << szPath << "in the DS\n");
   hr = ADSIOpenDSObject(szPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, &hDSObject);

   if (SUCCEEDED(hr))
      hr = ADSIGetObjectAttributes(hDSObject, &AttrName, 1, &pAttr, &cgot);

   if (SUCCEEDED(hr))
      szDN = UnpackStrFrom(pAttr[0]);

   if (SUCCEEDED(hr)) {
       *pszRpcContainerDN = new WCHAR[wcslen(RPCSUBCONTAINER)+wcslen(szDN)+1];
       if (!*pszRpcContainerDN) 
           hr = E_OUTOFMEMORY;
   }

   if (SUCCEEDED(hr)) {
       wsprintf(*pszRpcContainerDN, L"%s%s", RPCSUBCONTAINER, szDN);
   }

   if (hDSObject)
      ADSICloseDSObject(hDSObject);

   if (pAttr)
      FreeADsMem(pAttr);

   delete szPath;

   return hr;
}


// Goes in as local system. Gets the machine domain name.
// for the time being.

HRESULT GetDefaultRpcContainer(DSROLE_PRIMARY_DOMAIN_INFO_BASIC dsrole, WCHAR **pszRpcContainerDN)
{
    WCHAR              *bgn = NULL, *end = NULL;
    NTSTATUS            Status;
    unsigned int        i, j;

    SetSvcStatus();

    // allocating a large spc to have enough space for replacing ',' with "DC="

    if (dsrole.DomainNameDns) 
        *pszRpcContainerDN = new WCHAR[wcslen(dsrole.DomainNameDns)*3+wcslen(RPCSUBCONTAINER)+1];
    else 
        *pszRpcContainerDN = new WCHAR[wcslen(RPCSUBCONTAINER)+1];

    if (!pszRpcContainerDN)
        return E_OUTOFMEMORY;

    if (dsrole.DomainNameDns) {
    	DBGOUT(DIRSVC, "DnsDomainName <" << dsrole.DomainNameDns << "> returned\n");

        wsprintf(*pszRpcContainerDN, L"%s", RPCSUBCONTAINER);
        j= wcslen(RPCSUBCONTAINER);
        
        for (bgn = dsrole.DomainNameDns;;) {
            end = wcschr(bgn, L'.');
            // find the next '.'
            if (end)
                *end = L'\0';
            
            if (bgn != dsrole.DomainNameDns)
                wcscat(*pszRpcContainerDN, L",");
            // if it is not first part, add a seperator.
            
            wcscat(*pszRpcContainerDN, L"DC=");
            wcscat(*pszRpcContainerDN, bgn);
            
            if ((!end) || (!(*(end+1))))
                break;
            // quit either if there are no more '.' or 
            // if we have reached the end.
            bgn = end+1;
		}
    }
    else
    {
        wcscpy(*pszRpcContainerDN, L"");
    }

    SetSvcStatus();

    return S_OK;
}

// BUGBUG:: This has to change. for the time being it
// doesn't distinguish multiple cases like workgroup, DC coming up
// etc..

void Locator::SetConfigInfoFromDS(DSROLE_PRIMARY_DOMAIN_INFO_BASIC dsrole)
{
    HRESULT             hr=S_OK;
    WCHAR              *szFullName=NULL, *szRpcContainerDN= NULL;
    HANDLE              hDSObject = NULL;
    LPWSTR              AttrName = NT4COMPATIBILITY_FLAG;
    ADS_ATTR_INFO     * attr=NULL;
    DWORD               cgot=0;
    NTSTATUS            Status;

    //    csDSSettingsGuard.Enter();
    //    if (fTriedConnectingToDS)
    //    {
    //        csDSSettingsGuard.Leave();
    //        return;
    //    }
    //
    //    fTriedConnectingToDS = 1;

    //
    // LDAP has its own notions of when to pass the securitydescriptor to the DS. When running as 
    // as local system if we want to verify anything we have to pass the Dns Domain Name. Rest of the
    // the time flat name seems to be sufficient. In an effort to localize the changes we are passing
    // DomainNameDns only when a call is being made as system service. rest of the stuff still passes
    // flat name.
    //

    fNT4Compat = 1;
    fDSEnabled = 1;

    if (dsrole.DomainNameDns) {
        pDomainNameDns = new CStringW(dsrole.DomainNameDns);
        DBGOUT(DIRSVC, "DomainName <" << dsrole.DomainNameDns << "> returned\n");
    }
    else {
        DBGOUT(DIRSVC, "DnsDomainName is NULL\n");   
        pDomainNameDns = NULL;
    }

    if (dsrole.DomainNameFlat) {
        pDomainName = new CStringW(dsrole.DomainNameFlat);
        if (!pDomainNameDns)
            pDomainNameDns = new CStringW(dsrole.DomainNameFlat);

        DBGOUT(DIRSVC, "DomainName <" << dsrole.DomainNameFlat << "> returned\n");
    }
    else {
        DBGOUT(DIRSVC, "DomainName is NULL\n");                
        pDomainName = new CStringW(L"");
        pDomainNameDns = new CStringW(L"");
    }

    // get the domain name and its DN
    hr = GetDefaultRpcContainer(dsrole, &szRpcContainerDN);

    if (SUCCEEDED(hr))
        pRpcContainerDN = new CStringW(szRpcContainerDN);
    else
        pRpcContainerDN = new CStringW(L"");


    DBGOUT(DIRSVC, "Machine Domain " << *pDomainName << "\n");
    DBGOUT(DIRSVC, "szDefaultDNRpcContainer " << *pRpcContainerDN << "\n");

    if ((!szRpcContainerDN) || (!szRpcContainerDN[0])) {
        fDSEnabled = 0;
        DBGOUT(DIRSVC, "No DNS Information available. Running in NT4 Mode\n");
//		hr = GetRpcContainerForDomain(NULL, szRpcContainerDN);
//		DBGOUT(DIRSVC, "Contacting the DC we get" << szRpcContainerDN << "\n");
        return;
    }

    SetSvcStatus();

    // Get the compatibility flag value.

    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen((STRING_T)(*pDomainNameDns))+1+wcslen(szRpcContainerDN)+1];
    if (!szFullName)
        hr = E_OUTOFMEMORY;
    else {
        wsprintf(szFullName, L"%s%s/%s", RPCCONTAINERPREFIX, (STRING_T)(*pDomainNameDns), szRpcContainerDN);
        DBGOUT(DIRSVC, "SetConfigInfoFromDS Attempting to contact the DC at " << szFullName << "...\n");
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION, &hDSObject);
        
        SetSvcStatus();
        delete szFullName;
    }

    delete szRpcContainerDN;


    if (FAILED(hr)) {
/*
        // adding it to the event log.
        WCHAR ErrorCode[20];
        HANDLE LogHandle = NULL;
        LPCTSTR Strings[1];

        String[0] = ErrorCode;

        wsprintf(ErrorCode, L"Errorcode = 0x%x", hr);
        LogHandle = RegisterEventSource(NULL, LOCATOR_EVENT_SOURCE);

        if (!LogHandle) {
            DBGOUT(DIRSVC, "Couldn't open event log\n");
            return;
        }

        ReportEvent(LogHandle,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EVENT_RPCLOCATOR_BIND_TO_DS_ERROR,
                                  // create this event
                    1,
                    0,
                    (LPCTSTR *)Strings,
                    NULL
                    );
*/

        WCHAR errbuf[7+1+1+1+2+8+1];
        wsprintf(errbuf, L"HRESULT = 0x%x", hr);

        fDSEnabled = 0;
        DBGOUT(DIRSVC, "Couldn't contact the DC. Running in pure NT4 Mode" << errbuf << "\n");
        return;
    }
    else
        DBGOUT(DIRSVC, "contacted DC\n");

    hr = ADSIGetObjectAttributes(hDSObject, &AttrName, 1, &attr, &cgot);
    DBGOUT(DIRSVC, "Got the NT4Compat flag\n");

    if ((SUCCEEDED(hr)) && (cgot))
        fNT4Compat = UnpackIntFrom(attr[0]);

    SetSvcStatus();

    if (hDSObject)
        ADSICloseDSObject(hDSObject);

    DBGOUT(DIRSVC, "Clsoing the LDAP handle\n");
    if (attr)
        FreeADsMem(attr);

    //    csDSSettingsGuard.Leave();
}


CLookupHandle *
Locator::DSLookup(
                  UNSIGNED32           EntryNameSyntax,
                  STRING_T             EntryName,
                  CGUIDVersion    *    pGVinterface,
                  CGUIDVersion    *    pGVsyntax,
                  CGUID           *    pIDobject,
                  unsigned long        ulVectorSize,
                  unsigned long        ulCacheAge
                  )
/*++
Member Description:

  Use the given lookup parameters to perform a lookup from the
  DS.

  If an entry name is given then get all the data immediately available
  If an entry is server entry then get all the data immediately
  If an entry is group entry get all the data but do not chase the
        links immediately. Links will be chased lazily in case of nexts
        and not in creating the handle
  If an entry is profile entry it behaves the same way as the group
  entry above.

  if the entryname is not given it again behaves like a group entry.

Arguments:

  EntryNameSyntax        - Name syntax, optional

  EntryName              - (raw) Name of the entry to look up, optional

  pGVinterface           - (wrapped) Interface to look up, optional

  pGVsyntax              - (wrapped) Transfer syntax, optional

  pIDobject              - (wrapped) Object UUID, optional

  ulVectorSize           - Max size of vectors of binding handles, 0 for default

  ulCacheAge             - acceptable max age of cached information from a master
                           presently unused.

Returns:

  A lookup handle based on the info retrieved.

--*/
{
   ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and abt. to start lookup in DS");
   return new CDSLookupHandle(
            EntryNameSyntax,
            EntryName,
            pGVinterface,
            pGVsyntax,
            pIDobject,
            ulVectorSize,
            ulCacheAge
            );

}

//////////////////////////////////////////////////////////////////////////
//  GetEntryFromDS::
//          Given the entry name, this function creates an object of server,
//  profile or group entry type based on the schema name of the DS object.
// It then gets various fields/properties. After that Satish's code for in memory
// search takes over.
//////////////////////////////////////////////////////////////////////////

// all the functions below that use attr returned from GetObjectAttributes
// should free them at the place where GetObjectAttributes is called.

// all the functions that use columns should free them immediate after
// using GetColumn is called.

CEntry *
GetEntryFromDS(UNSIGNED32 EntryNameSyntax,
               STRING_T pszEntryName)
{
    ULONG                i, sz=0;
    HRESULT              hr = S_OK;
    CEntry             * pEntry = NULL;
    WCHAR              * pszFullEntryName=NULL;
    ADS_ATTR_INFO      * pAttr=NULL;
    DWORD                cAttrgot = 0, propnum=0;
    WCHAR             ** pszClasses, *szFullName=NULL;
    HANDLE               hDSObject=NULL;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and abt. to start lookup in DS");

    if (EntryNameSyntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!pszEntryName) Raise(NSI_S_INCOMPLETE_NAME);

    CEntryName * EntryName = new CEntryName(pszEntryName);

    pszFullEntryName = EntryName->getFullDNAlloc();

    DBGOUT(DIRSVC, "Looking for Entry " << pszFullEntryName << "in the DS\n");

    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen((STRING_T)(*(EntryName->getDomainNameDns())))+1+
                           wcslen(pszFullEntryName)+1];

    if (!szFullName)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr)) {
        wsprintf(szFullName, L"%s%s/%s", RPCCONTAINERPREFIX, (STRING_T)(*(EntryName->getDomainNameDns())),
	         pszFullEntryName);

        DBGOUT(DIRSVC, "GetEntryFromDS Opening " << szFullName << "in the DS\n");
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
		    	  &hDSObject);
    }

    // get all the attributes. we do not want to go on n/w again.
    if (SUCCEEDED(hr))
        hr = ADSIGetObjectAttributes(hDSObject, NULL, -1, &pAttr, &cAttrgot);

    if (SUCCEEDED(hr))
    {
        propnum = GetPropertyFromAttr(pAttr, cAttrgot, CLASSNAME);
        if (propnum == cAttrgot)
            hr = E_FAIL; // class didn't come back from the getobject.
    }

    if (SUCCEEDED(hr))
    {
        UnpackStrArrFrom(pAttr[propnum], &pszClasses, &sz);

        if ((!pszClasses) || (!sz))
            hr = E_FAIL;

        // create a new entry based on the value.
        if ((SUCCEEDED(hr)) && (wcsstr(pszClasses[sz-1], RPCSERVERCONTAINERCLASS) != NULL))
        {
            // if it is a created entry return NULL.
            propnum = GetPropertyFromAttr(pAttr, cAttrgot, DESCRIPTION);
            if (propnum < cAttrgot)
            {
                WCHAR *pszDesc = UnpackStrFrom(pAttr[propnum]);
                if ((pszDesc) && (wcscmp(pszDesc, CREATED_DESCRIPTION) != 0))
                {
                    DBGOUT(DIRSVC, "Found a Server Entry of the name in the DS\n");
                    CServerEntry *pServerEntry = new CServerEntry(pszEntryName, pAttr, cAttrgot,
                        hDSObject, &hr);
                    if (FAILED(hr))
                        delete pServerEntry;
                    else
                        pEntry = pServerEntry;
                }
            }
        }
        else if ((SUCCEEDED(hr)) && (wcsstr(pszClasses[sz-1], RPCPROFILECONTAINERCLASS) != NULL))
        {
            DBGOUT(DIRSVC, "Found a Profile Entry of the name in the DS\n");
            CProfileEntry *pProfileEntry = new CProfileEntry(pszEntryName, pAttr, cAttrgot,
                hDSObject, &hr);
            if (FAILED(hr))
                delete pProfileEntry;
            else
                pEntry = pProfileEntry;
        }
        else if ((SUCCEEDED(hr)) && (wcsstr(pszClasses[sz-1], RPCGROUPCLASS) != NULL))
        {
            DBGOUT(DIRSVC, "Found a Group Entry of the name in the DS\n");
            CGroupEntry *pGroupEntry = new CGroupEntry(pszEntryName, pAttr, cAttrgot,
                hDSObject, &hr);
            if (FAILED(hr))
                delete pGroupEntry;
            else
                pEntry = pGroupEntry;
        }
        else
            hr = E_FAIL;

        if (pszClasses)
            delete pszClasses;

        // Class type is not recognized.
    }

    if (hDSObject)
        ADSICloseDSObject(hDSObject);

    if (pszFullEntryName)
        delete pszFullEntryName;

    if (EntryName)
        delete EntryName;

    delete szFullName;

    DBGOUT(DIRSVC, "\n");

    if (pAttr)
        FreeADsMem(pAttr);

    return pEntry;
}

//------------------------------------------------------------
// these 2 macros repeat in profile and server entry searches.
#define MACSetSearchOneLevel                                    \
    SearchPrefs.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;     \
    SearchPrefs.vValue.dwType = ADSTYPE_INTEGER;                \
    SearchPrefs.vValue.Integer = ADS_SCOPE_ONELEVEL;            \
*phr = ADSISetSearchPreference(hDSObject, &SearchPrefs, 1);

#define MACExecuteSearch                                        \
*phr = ADSIExecuteSearch(hDSObject, filter, pChildAttrNames, nAttrs, &hSearchHandle);

#define MACEnumChildrenLOOP                                     \
    for (*phr = ADSIGetFirstRow(hDSObject, hSearchHandle);      \
    ((SUCCEEDED(*phr)) && ((*phr) != S_ADS_NOMORE_ROWS));       \
*phr = ADSIGetNextRow(hDSObject, hSearchHandle))


#define MACSetChildList                                         \
    MACSetSearchOneLevel                                        \
                                                                \
    if (SUCCEEDED(*phr))                                        \
        MACExecuteSearch                                        \
                                                                \
    if (SUCCEEDED(*phr))                                        \
        MACEnumChildrenLOOP
//----------------------------------------------------------

// fill in all the object uuid
void GetObjectList(TCSafeSkipList<CGUID> *pObjectList, WCHAR **pProperty, ULONG sz)
{
    GUID                 objectGuid;
    CGUID              * tmpguid=NULL;
    DWORD                 i;

    pObjectList->wipeOut();
    for (i = 0; i < sz; i++) {
        UuidFromString(pProperty[i], &objectGuid);
        tmpguid = new CGUID(objectGuid);
        pObjectList->insert(tmpguid);
    }
}

// fill the interface structure
void GetInterfaceList(CServerEntry *me, TCSafeSkipList<CInterface> *pInterfaceList,
                      HANDLE hDSObject, HRESULT *phr)
{
    ADS_SEARCH_HANDLE        hSearchHandle = NULL;
    CInterface             * pInterface = NULL;
    ADS_SEARCHPREF_INFO      SearchPrefs;
    LPWSTR                   pChildAttrNames[] = {BINDINGS, TRANSFERSYNTAX, INTERFACEID};
    DWORD                    nAttrs = 3;
    WCHAR                    filter[_MAX_PATH];   

    pInterfaceList->wipeOut();

    wsprintf(filter, L"(%s=%s)", CLASSNAME, RPCSERVERELEMENTCLASS);

    MACSetChildList {
        pInterface = new CInterface(me, hDSObject, hSearchHandle, phr);
        if (FAILED(*phr))
            delete pInterface;
        else
            pInterfaceList->insert(pInterface);
    }
    if (hSearchHandle)
        ADSICloseSearchHandle(hDSObject, hSearchHandle);
}

// create a new server entry
CServerEntry::CServerEntry(CONST_STRING_T pszStr, ADS_ATTR_INFO *pAttr,
                           DWORD cAttr, HANDLE hDSObject, HRESULT *phr)
                           : CEntry(pszStr, ServerEntryType)
{
    ULONG                   sz = 0;
    WCHAR                ** pProperty = NULL;
    DWORD                   propnum = 0;

    *phr = S_OK;
    propnum = GetPropertyFromAttr(pAttr, cAttr, OBJECTID);
    if (propnum < cAttr)
        UnpackStrArrFrom(pAttr[propnum], &pProperty, &sz);

    GetObjectList(&ObjectList, pProperty, sz);
    GetInterfaceList(this, &InterfaceList, hDSObject, phr);

    if (pProperty)
        delete pProperty;
}

CServerEntry::CServerEntry(CONST_STRING_T pszStr, CONST_STRING_T pszDomainNameDns, CONST_STRING_T pszEntryName, 
                          HANDLE hDSObject, ADS_SEARCH_HANDLE hSearchHandle, HRESULT *phr)
                           : CEntry(pszStr, pszDomainNameDns, 1, pszEntryName, ServerEntryType)
{
    ULONG                   sz = 0;
    WCHAR                ** pProperty = NULL, *szFullName=NULL, *pszFullEntryName = NULL;
    ADS_SEARCH_COLUMN       column;
    HANDLE                  hDSSrvObject = NULL;

    pszFullEntryName = getFullDNAlloc();

    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen(pszDomainNameDns)+1+wcslen(pszFullEntryName)+1];

    if (!szFullName) {
        *phr = E_OUTOFMEMORY;
    }
    else {
        wsprintf(szFullName, L"%s%s/%s", RPCCONTAINERPREFIX, pszDomainNameDns, pszFullEntryName);

        *phr = ADSIGetColumn(hDSObject, hSearchHandle, OBJECTID, &column);
    }

    if (SUCCEEDED(*phr)) {
        UnpackStrArrFrom(column, &pProperty, &sz);
        GetObjectList(&ObjectList, pProperty, sz);
        ADSIFreeColumn(hDSObject, &column);

        if (pProperty)
            delete pProperty;
    }

    DBGOUT(DIRSVC, "CServerEntry::CServerEntry Opening " << szFullName << "in the DS\n");
    *phr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                            &hDSSrvObject);
    if (SUCCEEDED(*phr))
        GetInterfaceList(this, &InterfaceList, hDSSrvObject, phr);

    if (hDSSrvObject)
        ADSICloseDSObject(hDSSrvObject);
    delete szFullName;

    *phr = S_OK;
}


//////////////////////////////////////////////////////////////////////////
//      It gets the property fields filled. Then it enumerates among its
//  children and gets the values for each of the profile elements.
//////////////////////////////////////////////////////////////////////////
CProfileEntry::CProfileEntry(const STRING_T pszStr, ADS_ATTR_INFO *pAttr, DWORD cAttr,
                             HANDLE hDSObject, HRESULT *phr)
                             : CEntry(pszStr, ProfileEntryType),
                             pDefaultElt(NULL)
{
    ADS_SEARCHPREF_INFO     SearchPrefs;
    ADS_SEARCH_HANDLE       hSearchHandle;
    LPWSTR                  pChildAttrNames[] = {PROFILE, PRIORITY, ANNOTATION, INTERFACEID}; 
    WCHAR                   filter[_MAX_PATH];
    DWORD                   i, nAttrs = 4;
    CProfileElement       * pProfileElement = NULL;

    *phr = S_OK;
    wsprintf(filter, L"(%s=%s)", CLASSNAME, RPCPROFILEELEMENTCLASS);

    MACSetChildList {
        pProfileElement = new CProfileElement(this, hDSObject, hSearchHandle, phr);
        if (FAILED(*phr))
            delete pProfileElement;
        else {
            if (pProfileElement->fIsDefault)
                pDefaultElt = pProfileElement;
            else {
                EltList.insert(pProfileElement);
                CProfileSet *pSet = ProfileList.find(&CUnsigned32(pProfileElement->dwPriority));

                if (pSet == NULL) {
                    // New priority level
                    pSet = new CProfileSet(pProfileElement);
                    ProfileList.insert(pSet);
                }
                else
                    pSet->insert(pProfileElement);
            }
        }
    }

    if (hSearchHandle)
        ADSICloseSearchHandle(hDSObject, hSearchHandle);
}

//////////////////////////////////////////////////////////////////////////
//      gets the property filled immediately.
//////////////////////////////////////////////////////////////////////////
CGroupEntry::CGroupEntry(const STRING_T pszStr, ADS_ATTR_INFO *pAttr, DWORD cAttr,
                         HANDLE hDSObject, HRESULT *phr)
                         : CEntry(pszStr, GroupEntryType)
{
    WCHAR        ** pszGroupList=NULL;
    DWORD           propnum, i, sz=0;
    WCHAR         * szRpcContainerDN = NULL, 
                  * szDomainNameDns = NULL, * szEntryName = NULL;

    *phr = S_OK;
    propnum = GetPropertyFromAttr(pAttr, cAttr, GROUP);
    if (propnum < cAttr) {
        UnpackStrArrFrom(pAttr[propnum], &pszGroupList, &sz);
        for (i = 0; i < sz; i++) {
            StripDomainFromDN(pszGroupList[i], &szDomainNameDns, &szEntryName, 
                              &szRpcContainerDN);
            CEntryName *pEntryName = new CEntryName(szRpcContainerDN, szDomainNameDns, 1, szEntryName);
            GroupList.insert(pEntryName);
        }

        if (pszGroupList)
            delete pszGroupList;
    }
}


CInterface::CInterface(CServerEntry *pMyEntry, HANDLE hDSObject, ADS_SEARCH_HANDLE hSearchHandle,
                       HRESULT *phr): m_pMyEntry(pMyEntry)
{
    ULONG                         i, sz = 0;
    RPC_SYNTAX_IDENTIFIER         in;
    WCHAR                      ** pszProperty=NULL;
    WCHAR                       * endptr=NULL;
    WCHAR                       * szProperty=NULL;
    ADS_SEARCH_COLUMN             column;

    *phr = S_OK;

    DBGOUT(DIRSVC, "Found a Interface, under the server Entry in the DS\n");

    pBVhandles = new CBindingVector(pMyEntry);

    if (SUCCEEDED(*phr))
        *phr = ADSIGetColumn(hDSObject, hSearchHandle, BINDINGS, &column);

    if (SUCCEEDED(*phr)) {
        UnpackStrArrFrom(column, &pszProperty, &sz);
        for (i = 0; i < sz; i++)
            pBVhandles->insertBindingHandle(pszProperty[i]);
        ADSIFreeColumn(hDSObject, &column);

        *phr = ADSIGetColumn(hDSObject, hSearchHandle, TRANSFERSYNTAX, &column);

        if (pszProperty)
            delete pszProperty;
    }

    if (SUCCEEDED(*phr)) {
        szProperty = UnpackStrFrom(column);
        if ((szProperty) && (SyntaxIdFromString(in, szProperty)))
            transferSyntax = CGUIDVersion(in);
        else
            *phr = E_FAIL;

        ADSIFreeColumn(hDSObject, &column);
    }

    if (SUCCEEDED(*phr))   
        *phr = ADSIGetColumn(hDSObject, hSearchHandle, INTERFACEID, &column);

    if (SUCCEEDED(*phr)) {
        szProperty = UnpackStrFrom(column);
        if (!((szProperty) && (SyntaxIdFromString(idAndVersion, szProperty))))
            *phr = E_FAIL;

        ADSIFreeColumn(hDSObject, &column);
    }
}


CProfileElement::CProfileElement(
                                 CProfileEntry            *  pMyEntry,
                                 HANDLE                      hDSObject,
                                 ADS_SEARCH_HANDLE           hSearchHandle,
                                 HRESULT                  *  phr
                                 ):m_pMyEntry(pMyEntry)
{
    RPC_SYNTAX_IDENTIFIER    in;
    WCHAR                  * szProperty = NULL;
    WCHAR                  * endptr=NULL;
    ADS_SEARCH_COLUMN        column;
    WCHAR                  * szRpcContainerDN = NULL, 
                           * szDomainNameDns = NULL, * szEntryName = NULL;

    DBGOUT(DIRSVC, "Found a Profile Element, under the Profile Entry in the DS\n");

    *phr = ADSIGetColumn(hDSObject, hSearchHandle, PROFILE, &column);
    if (SUCCEEDED(*phr)) {
        szProperty = UnpackStrFrom(column);
        if (!szProperty)
            *phr = E_FAIL;
        else {
            StripDomainFromDN(szProperty, &szDomainNameDns, &szEntryName, 
                              &szRpcContainerDN);
            EntryName = CEntryName(szRpcContainerDN, szDomainNameDns, 1, szEntryName);
        }
        ADSIFreeColumn(hDSObject, &column);

        *phr = ADSIGetColumn(hDSObject, hSearchHandle, PRIORITY, &column);
    }

    if (SUCCEEDED(*phr)) {
        dwPriority = (DWORD)UnpackIntFrom(column);
        ADSIFreeColumn(hDSObject, &column);

        *phr = ADSIGetColumn(hDSObject, hSearchHandle, ANNOTATION, &column);
    }

    if (SUCCEEDED(*phr)) {
        szProperty = UnpackStrFrom(column);
        if (szProperty)
            pszAnnotation = CStringW(szProperty);
        else
            pszAnnotation = CStringW(L"");
        ADSIFreeColumn(hDSObject, &column);
    }
    else {
        pszAnnotation = CStringW(L"");
        *phr = S_OK;
    }

    if (SUCCEEDED(*phr))
        *phr = ADSIGetColumn(hDSObject, hSearchHandle, INTERFACEID, &column);

    if (SUCCEEDED(*phr)) {
        szProperty = UnpackStrFrom(column);
        if (!((szProperty) && (SyntaxIdFromString(in, szProperty))))
            *phr = E_FAIL;
        else {
            Interface = CGUIDVersion(in);

            if (IsNilIfId(&in))
                fIsDefault = TRUE;
            else
                fIsDefault = FALSE;
        }
        ADSIFreeColumn(hDSObject, &column);
    }
}


CServerEntry *CDSQry::next()
{
    HRESULT                hr = S_OK;
    ADS_SEARCH_COLUMN      column;
    WCHAR                * szProperty = NULL;
    CServerEntry         * pServer = NULL;

    hr = ADSIGetNextRow(hDSObject, hSearchHandle);
    if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
        return NULL;

    hr = ADSIGetColumn(hDSObject, hSearchHandle, DISTINGUISHEDNAME, &column);
    if (FAILED(hr))
        return NULL;

    // this has to be there as part of all entries.
    // may be DS is down

    szProperty = UnpackStrFrom(column);
    if (szProperty)
    {
        WCHAR	*szDN = NULL, *szDomainNameDns = NULL, *szEntryName = NULL, *szRpcContainerDN = NULL;
   
        szDN = new WCHAR[DSDomainBeginLength+wcslen(*(myRpcLocator->getDomainNameDns()))+
    	    	        DSDomainEndLength+wcslen(szProperty)+1];

        wsprintf(szDN, L"%s%s%c%s", DSDomainBegin, (STRING_T)*(myRpcLocator->getDomainNameDns()), DSDomainEnd, 
                                     szProperty);

        StripDomainFromDN(szDN, &szDomainNameDns, &szEntryName, 
                              &szRpcContainerDN);

        pServer = new CServerEntry(szRpcContainerDN, szDomainNameDns, szEntryName, hDSObject, hSearchHandle, &hr);

        delete szDN;
    }
    else
        hr = E_FAIL;


    if (FAILED(hr)) {
        delete pServer;
        pServer = NULL;
    }
    ADSIFreeColumn(hDSObject, &column);
    return pServer;

}

CDSQry::CDSQry(WCHAR *filter, HRESULT *phr)
{
    WCHAR                   *szFullName=NULL;
    ADS_SEARCHPREF_INFO      SearchPrefs;
    ULONG                    nAttrs = 2;
    LPWSTR                   pChildAttrNames[] = {DISTINGUISHEDNAME, OBJECTID};

    // get all the relevant properties.
    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen((STRING_T)*(myRpcLocator->getDomainNameDns()))+1+
                           wcslen((STRING_T)*(myRpcLocator->pRpcContainerDN))+1];

    wsprintf(szFullName, L"%s%s/%s", RPCCONTAINERPREFIX, (STRING_T)*(myRpcLocator->getDomainNameDns()),
                                    (STRING_T)*(myRpcLocator->pRpcContainerDN));

    if (!szFullName) {
        *phr = E_OUTOFMEMORY;
    } else {
        DBGOUT(DIRSVC, "CDSQry::CDSQry Opening " << szFullName << "in the DS\n");
        *phr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
            &hDSObject);
    }

    if (SUCCEEDED(*phr))
        MACSetSearchOneLevel;

    if (SUCCEEDED(*phr))
        MACExecuteSearch;

    delete szFullName;
}

CDSQry::~CDSQry()
{
    if (hSearchHandle)
        ADSICloseSearchHandle(hDSObject, hSearchHandle);
    if (hDSObject)
        ADSICloseDSObject(hDSObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\dsedit.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dsedit.cxx
//
//--------------------------------------------------------------------------

/***************************************************************************
* dsedit.cxx
*      Author:         UShaji
*
* Contains:
*      The member functions that add/delete from DS.
*      Uses mainly functions defined in dsutils for setting
*      the various properties.
*  Issues:
*          Domain name for many of the DN has to be set up properly.
*
*
***************************************************************************/

#include <locator.hxx>

//+-------------------------------------------------------------------------
//
//  Function:  RemapErrorCode
// remaps error code to nsi
//--------------------------------------------------------------------------

DWORD RemapErrorCode(HRESULT ErrorCode)
{
    HRESULT RetCode;

    if (SUCCEEDED(ErrorCode))
        return S_OK;

    switch (ErrorCode) 
    {
        //            
        //  All kinds of failures due to ObjectNotFound
        //  due to non-existence of object OR 
        //         non-existent container OR
        //         invalid path specification
        //  Other than Access Denails
        //
        case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
        case HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED):    // understand what causes this
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_FOUND):   //  -do-
            
            RetCode = NSI_S_ENTRY_NOT_FOUND;                       // which object - specific error
            break;

        case HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
        case HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS):
        case E_ADS_OBJECT_EXISTS:
            RetCode = NSI_S_ENTRY_ALREADY_EXISTS;
            break;

        //            
        //  The following errors should not be expected normally.
        //  Class Store schema mismatched should be handled correctly.
        //  Errors below may ONLY occur for corrupted data OR out-of-band changes
        //  to a Class Store content.

        case E_ADS_CANT_CONVERT_DATATYPE:
        case E_ADS_SCHEMA_VIOLATION:
        case HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE):
        case HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION):
            RetCode = NSI_S_UNSUPPORTED_NAME_SYNTAX;
            break;

        //            
        //  Any kinds of Access or Auth Denial
        //      return ACCESS_DENIED
        //

        case HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED):
        case HRESULT_FROM_WIN32(ERROR_DS_STRONG_AUTH_REQUIRED):
        case HRESULT_FROM_WIN32(ERROR_DS_CONFIDENTIALITY_REQUIRED):
        case HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD):
        case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
        case HRESULT_FROM_WIN32(ERROR_DS_AUTH_UNKNOWN):

            RetCode = NSI_S_NO_NS_PRIVILEGE;
            break;

        case E_ADS_BAD_PATHNAME:
        case HRESULT_FROM_WIN32(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX):  // this is wrong
            RetCode = NSI_S_INCOMPLETE_NAME;
            break;
        
        //            
        //  Out of Memory
        //

        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY):
            
            RetCode = NSI_S_OUT_OF_MEMORY;
            break;

        //            
        //  Any DNS, DS or Network failures
        //

        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_RESOLVING):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_UNIQUE):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NO_MAPPING):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_DOMAIN_ONLY):
        case HRESULT_FROM_WIN32(ERROR_DS_TIMELIMIT_EXCEEDED):
        case HRESULT_FROM_WIN32(ERROR_DS_BUSY):
        case HRESULT_FROM_WIN32(ERROR_DS_UNAVAILABLE):
        case HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM):
        case HRESULT_FROM_WIN32(ERROR_TIMEOUT):
        case HRESULT_FROM_WIN32(ERROR_CONNECTION_REFUSED):
        case HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN):
        case HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN):
            RetCode = NSI_S_INTERNAL_ERROR;
            break;

        case HRESULT_FROM_WIN32(ERROR_DS_ADMIN_LIMIT_EXCEEDED):
             RetCode = NSI_S_NO_NS_PRIVILEGE;
             break;


        case E_INVALIDARG:
        case ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS:
            RetCode = NSI_S_ENTRY_ALREADY_EXISTS;
            break;

        default:
            RetCode = NSI_S_INTERNAL_ERROR;
    }

    DBGOUT(DIRSVC, "Error Code 0x%x remapped to 0x%x\n" << ErrorCode << RetCode);
    return RetCode;
}


//+-------------------------------------------------------------------------
//
//  Function:  UuidToStringEx
// no memory allocation.
//--------------------------------------------------------------------------

int UuidToStringEx(UUID *Uuid, WCHAR *StringUuid)
{
    swprintf(StringUuid, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        Uuid->Data1, Uuid->Data2, Uuid->Data3,
        Uuid->Data4[0], Uuid->Data4[1],
        Uuid->Data4[2], Uuid->Data4[3],
        Uuid->Data4[4], Uuid->Data4[5],
        Uuid->Data4[6], Uuid->Data4[7]);
    return 36;
}

BOOL SyntaxIdToString(RPC_SYNTAX_IDENTIFIER &SynId, WCHAR *StringSynId)
{
    UuidToStringEx(&SynId.SyntaxGUID, StringSynId);
    wsprintf(StringSynId+wcslen(StringSynId), L".%04d.%04d",
        SynId.SyntaxVersion.MajorVersion%10000,
        SynId.SyntaxVersion.MinorVersion%10000
        );
    return TRUE;
}

BOOL SyntaxIdFromString(RPC_SYNTAX_IDENTIFIER &SynId, WCHAR *StringSynId)
{
    WCHAR    *endptr = NULL;

    if (wcslen(StringSynId) < STRINGGUIDVERSIONLEN)
        return FALSE;

    StringSynId[STRINGGUIDLEN] = L'\0';
    StringSynId[STRINGMAJVERSIONLEN] = L'\0';

    UuidFromString(StringSynId, &SynId.SyntaxGUID);
    SynId.SyntaxVersion.MajorVersion = (unsigned short)wcstoul(StringSynId+STRINGGUIDLEN+1,
        &endptr, 10);
    SynId.SyntaxVersion.MinorVersion = (unsigned short)wcstoul(StringSynId+STRINGMAJVERSIONLEN+1,
        &endptr, 10);
    return TRUE;
}

void FreeAttr(ADS_ATTR_INFO attr)
{
    delete attr.pADsValues;
}

// Note: None of these APIs copies anything into their own buffers.
// It allocates a buffer for adsvalues though.

// packing a property's value into a attribute structure
// for sending in with a create/modify.
void PackStrArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty,
                      WCHAR **pszAttr, DWORD num)
{
    DWORD    i;

    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;

    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_DELETE;

    attr->dwADsType = ADSTYPE_DN_STRING;
    attr->pADsValues = new ADSVALUE[num];

    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_DN_STRING;
        attr->pADsValues[i].DNString = pszAttr[i];
    }
}

void PackIntArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, int *pAttr, DWORD num)
{
    DWORD    i;

    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;

    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_CLEAR;

    attr->dwADsType = ADSTYPE_INTEGER;
    attr->pADsValues = new ADSVALUE[num];

    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_INTEGER;
        attr->pADsValues[i].Integer = pAttr[i];
    }
}

void PackStrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, WCHAR *szAttr)
{
    if (szAttr)
        PackStrArrToAttr(attr, szProperty, &szAttr, 1);
    else
        PackStrArrToAttr(attr, szProperty, &szAttr, 0);
}

void PackIntToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, int Attr)
{
    PackIntArrToAttr(attr, szProperty, &Attr, 1);
}


HRESULT Delete(STRING_T DN, STRING_T RDN, STRING_T szDomain)
{
    HANDLE   hDSObject = NULL;
    WCHAR   *szFullName=NULL;
    HRESULT  hr = S_OK;

    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen(szDomain)+1+wcslen(DN)+1];
    if (!szFullName)
        return E_OUTOFMEMORY;

    wsprintf(szFullName, L"%s%s/%s", RPCCONTAINERPREFIX, szDomain, DN);

    DBGOUT(DIRSVC, "Delete:: Opening " << szFullName << "in the DS\n");
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hDSObject);

    if (SUCCEEDED(hr))
        hr = ADSIDeleteDSObject(hDSObject, RDN);

    if (hDSObject)
        ADSICloseDSObject(hDSObject);

    delete szFullName;

    return hr;
}

// if the entry exists it tries to modify other wise create.
// This function has so many parameters because the adsldpc.dll
// does not take attributes that have zero values.
//
// setting an attribute of an already existing entry, we can not
// set objectclass and in creation we can not set/clear zero valued
// attributes.
// DN       - Domain Name of the container.
// RDN      - The name of the entry to be created.
// pAttr    - attributes to be set. first one has to be objectclass.
// cAttr    - Number of attributes.
// cCreateAttr  - Number of attributes to be set if it is being created.
//        empty attributes should not be set.
// ChkEntry - A boolean flag to see if the entry was created by
//        create in which case it should delete it.
//        (Has to be set to true in case of entries.

HRESULT UpdateOrCreateEx(WCHAR *DN, WCHAR *RDN, WCHAR *szDomain, ADS_ATTR_INFO *pAttr,
		         DWORD cAttr, DWORD cCreateAttr, BOOL ChkEntry)
{
    WCHAR              * szFullName=NULL, * szParentFullName=NULL, *pszDesc = L"";
    LPWSTR               szAttrName = DESCRIPTION;
    HANDLE               hDSObject;
    DWORD                modified;
    HRESULT              hr = S_OK;
    ADS_ATTR_INFO      * pAttrGot = NULL;
    DWORD                cgot;

    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen(szDomain)+1+wcslen(RDN)+1+wcslen(DN)+1];
    if (!szFullName)
        return E_OUTOFMEMORY;
    wsprintf(szFullName, L"%s%s/%s,%s", RPCCONTAINERPREFIX, szDomain, RDN, DN);

    szParentFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen(szDomain)+1+wcslen(DN)+1];
    if (!szParentFullName) {
        delete szFullName;
        return E_OUTOFMEMORY;
    }
    wsprintf(szParentFullName, L"%s%s/%s", RPCCONTAINERPREFIX, szDomain, DN);

    DBGOUT(DIRSVC, "UpdateOrCreateEx Opening " << szFullName << "in the DS\n");

    // see whether it already exists.
    hr =  ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION, &hDSObject);

    // BUGBUG:: Bind doesn't return file not found.
    if (SUCCEEDED(hr))
    {
        if (ChkEntry)
        {
            // if it was created, delete. This value will exist for all valid entries.
            hr = ADSIGetObjectAttributes(hDSObject, &szAttrName, 1, &pAttrGot, &cgot);
            if ((SUCCEEDED(hr)) && (cgot))
            {
                pszDesc = UnpackStrFrom(pAttrGot[0]);
                if ((!pszDesc) || (wcscmp(pszDesc, CREATED_DESCRIPTION) == 0))
                {
                    ADSICloseDSObject(hDSObject);
                    hr = Delete(DN, RDN, szDomain);
                    if (SUCCEEDED(hr))
                        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                    // if we deleted we would like to recreate it.
                }
                else
                {
                    if (cAttr)
                        hr = ADSISetObjectAttributes(hDSObject, pAttr+1, cAttr, &modified);
                    ADSICloseDSObject(hDSObject);
                }
            }
        }
        else
        {
            if (cAttr)
                hr = ADSISetObjectAttributes(hDSObject, pAttr+1, cAttr, &modified);
            ADSICloseDSObject(hDSObject);
        }
    }

    if (SUCCEEDED(hr)) {
        delete szFullName;
        delete szParentFullName;
        return hr;
    }

    if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        DBGOUT(DIRSVC, "Returned hr = " << hr << "in open\n");

    if (hr == HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR))
    {
        WCHAR errbuf[256], namebuf[256];
        DWORD err;

        ADsGetLastError(&err, errbuf, 256, namebuf, 256);
        DBGOUT(DIRSVC, "Error," << err << "errbuf = " << errbuf << "namebuf = " << namebuf << "\n");

        delete szFullName;
        delete szParentFullName;
        return hr;
    }

    DBGOUT(DIRSVC, "UpdateOrCreateEx Opening " << szParentFullName << "in the DS\n");
    hr = ADSIOpenDSObject(szParentFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hDSObject);
    if (SUCCEEDED(hr))
    {
        hr = ADSICreateDSObject(hDSObject, RDN, pAttr, cCreateAttr);
        ADSICloseDSObject(hDSObject); // opened abv.
    }

    if (FAILED(hr))
        DBGOUT(DIRSVC, "Returned hr = " << hr << "in create\n");

    if (hr == HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR))
    {
        WCHAR errbuf[256], namebuf[256];
        DWORD err;

        ADsGetLastError(&err, errbuf, 256, namebuf, 256);
        DBGOUT(DIRSVC, "Error," << err << "errbuf = " << errbuf << "namebuf = " << namebuf << "\n");

        delete szFullName;
        delete szParentFullName;
        return hr;
    }

    delete szFullName;
    delete szParentFullName;
    return hr;
}

HRESULT UpdateOrCreate(WCHAR *DN, WCHAR *RDN, WCHAR *szDomain, ADS_ATTR_INFO *pAttr,
		       DWORD cAttr, DWORD cCreateAttr)
{
    return UpdateOrCreateEx(DN, RDN, szDomain, pAttr, cAttr, cCreateAttr, FALSE);
}
// for entries 1 more criteria is that the entry type might have to be modified
// if it was created by create and a group or profile tries to export to
// that.

HRESULT UpdateOrCreateEntry(WCHAR *DN, WCHAR *RDN, WCHAR *szDomain, ADS_ATTR_INFO *pAttr, DWORD cAttr, DWORD cCreateAttr)
{
    return UpdateOrCreateEx(DN, RDN, szDomain, pAttr, cAttr, cCreateAttr, TRUE);
}

// This function can be called without actually calling the addtods function
// for the corresp. server entry. Hence the call to bind to the server is in
// code. adsldp keeps the security data corresp. to the user and doesn't go
// again on the network only if there is some handle that is not yet closed.
//
// This function modifies/fills in the following structure in the DS.
//
// CLASSNAME, TRANSFERSYNTAX, INTERFACEID, BINDINGS
//

HRESULT CInterface::AddToDS()
{
    ULONG                   sz = 0;
    HRESULT                 hr = S_OK;
    RPC_SYNTAX_IDENTIFIER   in;
    STRINGGUID              szGUID;
    STRINGGUIDVERSION       szIdVersion, szXferSyntax;
    WCHAR                ** pszBindings;
    WCHAR                 * szRDN=NULL;
    WCHAR                 * DNParentName = NULL;
    ADS_ATTR_INFO           pAttr[4];
    DWORD                   i, cAttr = 3, cCreateAttr = 4, cTotalAttr = 4;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    SyntaxIdToString(myIdAndVersion(), szIdVersion);
    // interface id and version

    szRDN= new WCHAR[3+wcslen(szIdVersion)+1];

    if (!szRDN)
        return E_OUTOFMEMORY;

    wsprintf(szRDN, L"CN=%s", szIdVersion);

    PackStrToAttr(pAttr+0, CLASSNAME, RPCSERVERELEMENTCLASS);
    // class
    PackStrToAttr(pAttr+1, INTERFACEID, szIdVersion);
    // Name

    SyntaxIdToString(xferSyntaxIdAndVersion(), szXferSyntax);
    PackStrToAttr(pAttr+2, TRANSFERSYNTAX, szXferSyntax);
    // transfer syntax of the interface.

    pszBindings = new LPWSTR[sz = pBVhandles->size()];
    if (!pszBindings)
        hr = E_OUTOFMEMORY;

    // storing all the bindings.
    if (SUCCEEDED(hr))
    {
        TCSafeSkipListIterator<CStringW> BVIter(*pBVhandles);

        for (i = 0; i < sz; i++)
            pszBindings[i] = *(BVIter.next());

        if (!sz)
            cCreateAttr--;
        PackStrArrToAttr(pAttr+3, BINDINGS, pszBindings, sz);

        DBGOUT(DIRSVC, "Trying to Store Interface " << szRDN << "in the DS\n");

        DNParentName = m_pMyEntry->getFullDNAlloc();
        hr = UpdateOrCreate(DNParentName, szRDN, *(m_pMyEntry->getDomainNameDns()), pAttr,
			   cAttr, cCreateAttr);

	delete DNParentName;
    }

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Stored the Interface " << szRDN << "in the DS\n\n");

    delete pszBindings;
    delete szRDN;

    for (i = 0; i < cTotalAttr; i++)
        FreeAttr(pAttr[i]);
    return hr;
}


HRESULT CInterface::DeleteFromDS()
{
    HRESULT                 hr=S_OK;
    WCHAR                  *szRDN=NULL;
    STRINGGUIDVERSION       szIdVersion;
    RPC_SYNTAX_IDENTIFIER   in;
    WCHAR                  *DNParentName = NULL;


    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    SyntaxIdToString(myId