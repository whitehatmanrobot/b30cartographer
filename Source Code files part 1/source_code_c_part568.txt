
    IDirectDrawAggCreateSurface,
    IDirectDrawDuplicateSurface,
    IDirectDrawEnumDisplayModes,
    IDirectDrawEnumSurfaces,
    IDirectDrawFlipToGDISurface,
    IDirectDrawGetCaps,
    IDirectDrawGetDisplayMode,
    IDirectDrawGetFourCCCodes,
    IDirectDrawGetGDISurface,
    IDirectDrawGetMonitorFrequency,
    IDirectDrawGetScanLine,
    IDirectDrawGetVerticalBlankStatus,
    IDirectDrawInitialize,
    IDirectDrawRestoreDisplayMode,
    IDirectDrawAggSetCooperativeLevel,
    IDirectDrawSetDisplayMode,
    IDirectDrawWaitForVerticalBlank
};

/*
 * IDirectDraw2
 */
STDMETHODIMP IDirectDraw2AggQueryInterface(IDirectDraw2 *pDD, REFIID riid, void ** ppv)
{
    return __QI(PARENTOF(pDD)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDraw2AggAddRef(IDirectDraw2 *);
STDMETHODIMP_(ULONG) IDirectDraw2AggRelease(IDirectDraw2 *);
STDMETHODIMP IDirectDraw2AggCreateSurface(IDirectDraw2 *, LPDDSURFACEDESC pSurfaceDesc,
					  IDirectDrawSurface **ppNewSurface, IUnknown *pUnkOuter);
STDMETHODIMP IDirectDraw2AggCreatePalette(IDirectDraw2 *,DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR *, IUnknown FAR *);
STDMETHODIMP IDirectDraw2AggSetCooperativeLevel(IDirectDraw2 *, HWND, DWORD);



FORWARD0(IDirectDraw2, Compact)
FORWARD3(IDirectDraw2, CreateClipper,		DWORD, LPDIRECTDRAWCLIPPER FAR *, IUnknown *)
FORWARD2(IDirectDraw2, DuplicateSurface,	LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR *)
FORWARD4(IDirectDraw2, EnumDisplayModes,	DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK)
FORWARD4(IDirectDraw2, EnumSurfaces,		DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMSURFACESCALLBACK)
FORWARD0(IDirectDraw2, FlipToGDISurface)
FORWARD2(IDirectDraw2, GetCaps,			LPDDCAPS, LPDDCAPS)
FORWARD1(IDirectDraw2, GetDisplayMode,		LPDDSURFACEDESC)
FORWARD2(IDirectDraw2, GetFourCCCodes,		LPDWORD, LPDWORD)
FORWARD1(IDirectDraw2, GetGDISurface,		LPDIRECTDRAWSURFACE FAR *)
FORWARD1(IDirectDraw2, GetMonitorFrequency,	LPDWORD)
FORWARD1(IDirectDraw2, GetScanLine,		LPDWORD)
FORWARD1(IDirectDraw2, Initialize,		GUID *)
FORWARD1(IDirectDraw2, GetVerticalBlankStatus,	LPBOOL)
FORWARD0(IDirectDraw2, RestoreDisplayMode)
FORWARD2(IDirectDraw2, WaitForVerticalBlank,	DWORD, HANDLE)
FORWARD3(IDirectDraw2, GetAvailableVidMem,	LPDDSCAPS, LPDWORD, LPDWORD)
FORWARD5(IDirectDraw2, SetDisplayMode,		DWORD, DWORD, DWORD, DWORD, DWORD)

IDirectDraw2Vtbl g_DirectDraw2Vtbl =
{
    IDirectDraw2AggQueryInterface,
    IDirectDraw2AggAddRef,
    IDirectDraw2AggRelease,
    IDirectDraw2Compact,
    IDirectDraw2CreateClipper,
    IDirectDraw2AggCreatePalette,
    IDirectDraw2AggCreateSurface,
    IDirectDraw2DuplicateSurface,
    IDirectDraw2EnumDisplayModes,
    IDirectDraw2EnumSurfaces,
    IDirectDraw2FlipToGDISurface,
    IDirectDraw2GetCaps,
    IDirectDraw2GetDisplayMode,
    IDirectDraw2GetFourCCCodes,
    IDirectDraw2GetGDISurface,
    IDirectDraw2GetMonitorFrequency,
    IDirectDraw2GetScanLine,
    IDirectDraw2GetVerticalBlankStatus,
    IDirectDraw2Initialize,
    IDirectDraw2RestoreDisplayMode,
    IDirectDraw2AggSetCooperativeLevel,
    IDirectDraw2SetDisplayMode,
    IDirectDraw2WaitForVerticalBlank,
    IDirectDraw2GetAvailableVidMem
};


STDMETHODIMP IDirectDraw4AggQueryInterface(IDirectDraw4 *pDD, REFIID riid, void ** ppv)
{
    return __QI(PARENTOF(pDD)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDraw4AggAddRef(IDirectDraw4 *);
STDMETHODIMP_(ULONG) IDirectDraw4AggRelease(IDirectDraw4 *);
STDMETHODIMP IDirectDraw4AggCreateSurface(IDirectDraw4 *, LPDDSURFACEDESC2 pSurfaceDesc2,
				         IDirectDrawSurface4 **ppNewSurface, IUnknown *pUnkOuter);
STDMETHODIMP IDirectDraw4AggCreatePalette(IDirectDraw4 *,DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR *, IUnknown FAR *);
STDMETHODIMP IDirectDraw4AggSetCooperativeLevel(IDirectDraw4 *, HWND, DWORD);


FORWARD0(IDirectDraw4, Compact)
FORWARD3(IDirectDraw4, CreateClipper,		DWORD, LPDIRECTDRAWCLIPPER FAR *, IUnknown *)
FORWARD2(IDirectDraw4, DuplicateSurface,	LPDIRECTDRAWSURFACE4, LPDIRECTDRAWSURFACE4 FAR *)
FORWARD4(IDirectDraw4, EnumDisplayModes,	DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMMODESCALLBACK2)
FORWARD4(IDirectDraw4, EnumSurfaces,		DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMSURFACESCALLBACK2)
FORWARD0(IDirectDraw4, FlipToGDISurface)
FORWARD2(IDirectDraw4, GetCaps,			LPDDCAPS, LPDDCAPS)
FORWARD1(IDirectDraw4, GetDisplayMode,		LPDDSURFACEDESC2)
FORWARD2(IDirectDraw4, GetFourCCCodes,		LPDWORD, LPDWORD)
FORWARD1(IDirectDraw4, GetGDISurface,		LPDIRECTDRAWSURFACE4 FAR *)
FORWARD1(IDirectDraw4, GetMonitorFrequency,	LPDWORD)
FORWARD1(IDirectDraw4, GetScanLine,		LPDWORD)
FORWARD1(IDirectDraw4, Initialize,		GUID *)
FORWARD1(IDirectDraw4, GetVerticalBlankStatus,	LPBOOL)
FORWARD0(IDirectDraw4, RestoreDisplayMode)
FORWARD2(IDirectDraw4, WaitForVerticalBlank,	DWORD, HANDLE)
FORWARD3(IDirectDraw4, GetAvailableVidMem,	LPDDSCAPS2, LPDWORD, LPDWORD)
FORWARD5(IDirectDraw4, SetDisplayMode,		DWORD, DWORD, DWORD, DWORD, DWORD)
FORWARD2(IDirectDraw4, GetSurfaceFromDC,        HDC, LPDIRECTDRAWSURFACE4 *)
FORWARD0(IDirectDraw4, RestoreAllSurfaces)
FORWARD0(IDirectDraw4, TestCooperativeLevel)

IDirectDraw4Vtbl g_DirectDraw4Vtbl =
{
    IDirectDraw4AggQueryInterface,
    IDirectDraw4AggAddRef,
    IDirectDraw4AggRelease,
    IDirectDraw4Compact,
    IDirectDraw4CreateClipper,
    IDirectDraw4AggCreatePalette,
    IDirectDraw4AggCreateSurface,
    IDirectDraw4DuplicateSurface,
    IDirectDraw4EnumDisplayModes,
    IDirectDraw4EnumSurfaces,
    IDirectDraw4FlipToGDISurface,
    IDirectDraw4GetCaps,
    IDirectDraw4GetDisplayMode,
    IDirectDraw4GetFourCCCodes,
    IDirectDraw4GetGDISurface,
    IDirectDraw4GetMonitorFrequency,
    IDirectDraw4GetScanLine,
    IDirectDraw4GetVerticalBlankStatus,
    IDirectDraw4Initialize,
    IDirectDraw4RestoreDisplayMode,
    IDirectDraw4AggSetCooperativeLevel,
    IDirectDraw4SetDisplayMode,
    IDirectDraw4WaitForVerticalBlank,
    IDirectDraw4GetAvailableVidMem,
    IDirectDraw4GetSurfaceFromDC,
    IDirectDraw4RestoreAllSurfaces,
    IDirectDraw4TestCooperativeLevel
};


/*
 * IDirectDrawSurface
 */
STDMETHODIMP IDirectDrawSurfaceAggQueryInterface(IDirectDrawSurface *pDDS, REFIID riid, void ** ppv)
{
    return __QI(SURFACEOF(pDDS)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDrawSurfaceAggAddRef(IDirectDrawSurface *);
STDMETHODIMP_(ULONG) IDirectDrawSurfaceAggRelease(IDirectDrawSurface *);
STDMETHODIMP IDirectDrawSurfaceAggGetDC(IDirectDrawSurface *, HDC *);
STDMETHODIMP IDirectDrawSurfaceAggReleaseDC(IDirectDrawSurface *, HDC);
STDMETHODIMP IDirectDrawSurfaceAggLock(IDirectDrawSurface *, LPRECT,LPDDSURFACEDESC,DWORD,HANDLE);
STDMETHODIMP IDirectDrawSurfaceAggUnlock(IDirectDrawSurface *, LPVOID);
STDMETHODIMP IDirectDrawSurfaceAggSetSurfaceDesc(IDirectDrawSurface *, LPVOID);
STDMETHODIMP IDirectDrawSurfaceAggGetAttachedSurface( IDirectDrawSurface *, LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *);
STDMETHODIMP IDirectDrawSurfaceAggAddAttachedSurface( IDirectDrawSurface *, LPDIRECTDRAWSURFACE);
STDMETHODIMP IDirectDrawSurfaceAggDeleteAttachedSurface( IDirectDrawSurface *,DWORD, LPDIRECTDRAWSURFACE);
STDMETHODIMP IDirectDrawSurfaceAggFlip(IDirectDrawSurface *, LPDIRECTDRAWSURFACE, DWORD);
STDMETHODIMP IDirectDrawSurfaceAggBlt(IDirectDrawSurface *,LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX);
STDMETHODIMP IDirectDrawSurfaceAggGetPalette(IDirectDrawSurface *, LPDIRECTDRAWPALETTE FAR *);
STDMETHODIMP IDirectDrawSurfaceAggSetPalette(IDirectDrawSurface *, LPDIRECTDRAWPALETTE);
STDMETHODIMP IDirectDrawSurfaceAggGetSurfaceDesc(IDirectDrawSurface *, LPDDSURFACEDESC);

/*** IDirectDrawSurface methods ***/
FORWARD1(IDirectDrawSurface, AddOverlayDirtyRect, LPRECT)
FORWARD3(IDirectDrawSurface, BltBatch, LPDDBLTBATCH, DWORD, DWORD )
FORWARD5(IDirectDrawSurface, BltFast, DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD)
FORWARD2(IDirectDrawSurface, EnumAttachedSurfaces, LPVOID,LPDDENUMSURFACESCALLBACK)
FORWARD3(IDirectDrawSurface, EnumOverlayZOrders, DWORD,LPVOID,LPDDENUMSURFACESCALLBACK)
FORWARD1(IDirectDrawSurface, GetBltStatus, DWORD)
FORWARD1(IDirectDrawSurface, GetCaps, LPDDSCAPS)
FORWARD1(IDirectDrawSurface, GetClipper, LPDIRECTDRAWCLIPPER FAR*)
FORWARD2(IDirectDrawSurface, GetColorKey, DWORD, LPDDCOLORKEY)
FORWARD1(IDirectDrawSurface, GetFlipStatus, DWORD)
FORWARD2(IDirectDrawSurface, GetOverlayPosition, LPLONG, LPLONG )
FORWARD1(IDirectDrawSurface, GetPixelFormat, LPDDPIXELFORMAT)
FORWARD2(IDirectDrawSurface, Initialize, LPDIRECTDRAW, LPDDSURFACEDESC)
FORWARD0(IDirectDrawSurface, IsLost)
FORWARD0(IDirectDrawSurface, Restore)
FORWARD1(IDirectDrawSurface, SetClipper, LPDIRECTDRAWCLIPPER)
FORWARD2(IDirectDrawSurface, SetColorKey, DWORD, LPDDCOLORKEY)
FORWARD2(IDirectDrawSurface, SetOverlayPosition, LONG, LONG )
FORWARD5(IDirectDrawSurface, UpdateOverlay, LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX)
FORWARD1(IDirectDrawSurface, UpdateOverlayDisplay, DWORD)
FORWARD2(IDirectDrawSurface, UpdateOverlayZOrder, DWORD, LPDIRECTDRAWSURFACE)

IDirectDrawSurfaceVtbl g_DirectDrawSurfaceVtbl =
{
    IDirectDrawSurfaceAggQueryInterface,
    IDirectDrawSurfaceAggAddRef,
    IDirectDrawSurfaceAggRelease,
    IDirectDrawSurfaceAggAddAttachedSurface,
    IDirectDrawSurfaceAddOverlayDirtyRect,
    IDirectDrawSurfaceAggBlt,
    IDirectDrawSurfaceBltBatch,
    IDirectDrawSurfaceBltFast,
    IDirectDrawSurfaceAggDeleteAttachedSurface,
    IDirectDrawSurfaceEnumAttachedSurfaces,
    IDirectDrawSurfaceEnumOverlayZOrders,
    IDirectDrawSurfaceAggFlip,
    IDirectDrawSurfaceAggGetAttachedSurface,
    IDirectDrawSurfaceGetBltStatus,
    IDirectDrawSurfaceGetCaps,
    IDirectDrawSurfaceGetClipper,
    IDirectDrawSurfaceGetColorKey,
    IDirectDrawSurfaceAggGetDC,
    IDirectDrawSurfaceGetFlipStatus,
    IDirectDrawSurfaceGetOverlayPosition,
    IDirectDrawSurfaceAggGetPalette,
    IDirectDrawSurfaceGetPixelFormat,
    IDirectDrawSurfaceAggGetSurfaceDesc,
    IDirectDrawSurfaceInitialize,
    IDirectDrawSurfaceIsLost,
    IDirectDrawSurfaceAggLock,
    IDirectDrawSurfaceAggReleaseDC,
    IDirectDrawSurfaceRestore,
    IDirectDrawSurfaceSetClipper,
    IDirectDrawSurfaceSetColorKey,
    IDirectDrawSurfaceSetOverlayPosition,
    IDirectDrawSurfaceAggSetPalette,
    IDirectDrawSurfaceAggUnlock,
    IDirectDrawSurfaceUpdateOverlay,
    IDirectDrawSurfaceUpdateOverlayDisplay,
    IDirectDrawSurfaceUpdateOverlayZOrder
};

/*
 * IDirectDrawSurface2
 */
STDMETHODIMP IDirectDrawSurface2AggQueryInterface(IDirectDrawSurface2 *pDDS2, REFIID riid, void ** ppv)
{
    return __QI(SURFACEOF(pDDS2)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDrawSurface2AggAddRef(IDirectDrawSurface2 *);
STDMETHODIMP_(ULONG) IDirectDrawSurface2AggRelease(IDirectDrawSurface2 *);
STDMETHODIMP IDirectDrawSurface2AggGetDC(IDirectDrawSurface2 *, HDC *);
STDMETHODIMP IDirectDrawSurface2AggReleaseDC(IDirectDrawSurface2 *, HDC);
STDMETHODIMP IDirectDrawSurface2AggLock(IDirectDrawSurface2 *, LPRECT,LPDDSURFACEDESC,DWORD,HANDLE);
STDMETHODIMP IDirectDrawSurface2AggUnlock(IDirectDrawSurface2 *, LPVOID);
STDMETHODIMP IDirectDrawSurface2AggGetAttachedSurface( IDirectDrawSurface2 *, LPDDSCAPS, LPDIRECTDRAWSURFACE2 FAR *);
STDMETHODIMP IDirectDrawSurface2AggAddAttachedSurface( IDirectDrawSurface2 *, LPDIRECTDRAWSURFACE2);
STDMETHODIMP IDirectDrawSurface2AggDeleteAttachedSurface( IDirectDrawSurface2 *,DWORD, LPDIRECTDRAWSURFACE2);
STDMETHODIMP IDirectDrawSurface2AggFlip(IDirectDrawSurface2 *, LPDIRECTDRAWSURFACE2, DWORD);
STDMETHODIMP IDirectDrawSurface2AggBlt(IDirectDrawSurface2 *,LPRECT,LPDIRECTDRAWSURFACE2, LPRECT,DWORD, LPDDBLTFX);
STDMETHODIMP IDirectDrawSurface2AggGetPalette(IDirectDrawSurface2 *, LPDIRECTDRAWPALETTE FAR *);
STDMETHODIMP IDirectDrawSurface2AggSetPalette(IDirectDrawSurface2 *, LPDIRECTDRAWPALETTE);
STDMETHODIMP IDirectDrawSurface2AggGetDDInterface(IDirectDrawSurface2 *, LPVOID FAR *);
STDMETHODIMP IDirectDrawSurface2AggGetSurfaceDesc(IDirectDrawSurface2 *, LPDDSURFACEDESC);




/*** IDirectDrawSurface2 methods ***/
FORWARD1(IDirectDrawSurface2, AddOverlayDirtyRect, LPRECT)
FORWARD3(IDirectDrawSurface2, BltBatch, LPDDBLTBATCH, DWORD, DWORD )
FORWARD5(IDirectDrawSurface2, BltFast, DWORD,DWORD,LPDIRECTDRAWSURFACE2, LPRECT,DWORD)
FORWARD2(IDirectDrawSurface2, EnumAttachedSurfaces, LPVOID,LPDDENUMSURFACESCALLBACK)
FORWARD3(IDirectDrawSurface2, EnumOverlayZOrders, DWORD,LPVOID,LPDDENUMSURFACESCALLBACK)
FORWARD1(IDirectDrawSurface2, GetBltStatus, DWORD)
FORWARD1(IDirectDrawSurface2, GetCaps, LPDDSCAPS)
FORWARD1(IDirectDrawSurface2, GetClipper, LPDIRECTDRAWCLIPPER FAR*)
FORWARD2(IDirectDrawSurface2, GetColorKey, DWORD, LPDDCOLORKEY)
FORWARD1(IDirectDrawSurface2, GetFlipStatus, DWORD)
FORWARD2(IDirectDrawSurface2, GetOverlayPosition, LPLONG, LPLONG )
FORWARD1(IDirectDrawSurface2, GetPixelFormat, LPDDPIXELFORMAT)
FORWARD2(IDirectDrawSurface2, Initialize, LPDIRECTDRAW, LPDDSURFACEDESC)
FORWARD0(IDirectDrawSurface2, IsLost)
FORWARD0(IDirectDrawSurface2, Restore)
FORWARD1(IDirectDrawSurface2, SetClipper, LPDIRECTDRAWCLIPPER)
FORWARD2(IDirectDrawSurface2, SetColorKey, DWORD, LPDDCOLORKEY)
FORWARD2(IDirectDrawSurface2, SetOverlayPosition, LONG, LONG )
FORWARD5(IDirectDrawSurface2, UpdateOverlay, LPRECT, LPDIRECTDRAWSURFACE2,LPRECT,DWORD, LPDDOVERLAYFX)
FORWARD1(IDirectDrawSurface2, UpdateOverlayDisplay, DWORD)
FORWARD2(IDirectDrawSurface2, UpdateOverlayZOrder, DWORD, LPDIRECTDRAWSURFACE2)
FORWARD1(IDirectDrawSurface2, PageLock, DWORD)
FORWARD1(IDirectDrawSurface2, PageUnlock, DWORD)

IDirectDrawSurface2Vtbl g_DirectDrawSurface2Vtbl =
{
    IDirectDrawSurface2AggQueryInterface,
    IDirectDrawSurface2AggAddRef,
    IDirectDrawSurface2AggRelease,
    IDirectDrawSurface2AggAddAttachedSurface,
    IDirectDrawSurface2AddOverlayDirtyRect,
    IDirectDrawSurface2AggBlt,
    IDirectDrawSurface2BltBatch,
    IDirectDrawSurface2BltFast,
    IDirectDrawSurface2AggDeleteAttachedSurface,
    IDirectDrawSurface2EnumAttachedSurfaces,
    IDirectDrawSurface2EnumOverlayZOrders,
    IDirectDrawSurface2AggFlip,
    IDirectDrawSurface2AggGetAttachedSurface,
    IDirectDrawSurface2GetBltStatus,
    IDirectDrawSurface2GetCaps,
    IDirectDrawSurface2GetClipper,
    IDirectDrawSurface2GetColorKey,
    IDirectDrawSurface2AggGetDC,
    IDirectDrawSurface2GetFlipStatus,
    IDirectDrawSurface2GetOverlayPosition,
    IDirectDrawSurface2AggGetPalette,
    IDirectDrawSurface2GetPixelFormat,
    IDirectDrawSurface2AggGetSurfaceDesc,
    IDirectDrawSurface2Initialize,
    IDirectDrawSurface2IsLost,
    IDirectDrawSurface2AggLock,
    IDirectDrawSurface2AggReleaseDC,
    IDirectDrawSurface2Restore,
    IDirectDrawSurface2SetClipper,
    IDirectDrawSurface2SetColorKey,
    IDirectDrawSurface2SetOverlayPosition,
    IDirectDrawSurface2AggSetPalette,
    IDirectDrawSurface2AggUnlock,
    IDirectDrawSurface2UpdateOverlay,
    IDirectDrawSurface2UpdateOverlayDisplay,
    IDirectDrawSurface2UpdateOverlayZOrder,
    IDirectDrawSurface2AggGetDDInterface,
    IDirectDrawSurface2PageLock,
    IDirectDrawSurface2PageUnlock
};

/*
 * IDirectDrawSurface3
 */
STDMETHODIMP IDirectDrawSurface3AggQueryInterface(IDirectDrawSurface3 *pDDS3, REFIID riid, void ** ppv)
{
    return __QI(SURFACEOF(pDDS3)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDrawSurface3AggAddRef(IDirectDrawSurface3 *);
STDMETHODIMP_(ULONG) IDirectDrawSurface3AggRelease(IDirectDrawSurface3 *);
STDMETHODIMP IDirectDrawSurface3AggGetDC(IDirectDrawSurface3 *, HDC *);
STDMETHODIMP IDirectDrawSurface3AggReleaseDC(IDirectDrawSurface3 *, HDC);
STDMETHODIMP IDirectDrawSurface3AggLock(IDirectDrawSurface3 *, LPRECT,LPDDSURFACEDESC,DWORD,HANDLE);
STDMETHODIMP IDirectDrawSurface3AggUnlock(IDirectDrawSurface3 *, LPVOID);
STDMETHODIMP IDirectDrawSurface3AggSetSurfaceDesc(IDirectDrawSurface3 *, LPDDSURFACEDESC, DWORD);
STDMETHODIMP IDirectDrawSurface3AggGetAttachedSurface( IDirectDrawSurface3 *, LPDDSCAPS, LPDIRECTDRAWSURFACE3 FAR *);
STDMETHODIMP IDirectDrawSurface3AggAddAttachedSurface( IDirectDrawSurface3 *, LPDIRECTDRAWSURFACE3);
STDMETHODIMP IDirectDrawSurface3AggDeleteAttachedSurface( IDirectDrawSurface3 *,DWORD, LPDIRECTDRAWSURFACE3);
STDMETHODIMP IDirectDrawSurface3AggFlip(IDirectDrawSurface3 *, LPDIRECTDRAWSURFACE3, DWORD);
STDMETHODIMP IDirectDrawSurface3AggBlt(IDirectDrawSurface3 *,LPRECT,LPDIRECTDRAWSURFACE3, LPRECT,DWORD, LPDDBLTFX);
STDMETHODIMP IDirectDrawSurface3AggGetPalette(IDirectDrawSurface3 *, LPDIRECTDRAWPALETTE FAR *);
STDMETHODIMP IDirectDrawSurface3AggSetPalette(IDirectDrawSurface3 *, LPDIRECTDRAWPALETTE);
STDMETHODIMP IDirectDrawSurface3AggGetDDInterface(IDirectDrawSurface3 *, LPVOID FAR *);
STDMETHODIMP IDirectDrawSurface3AggGetSurfaceDesc(IDirectDrawSurface3 *, LPDDSURFACEDESC);







/*** IDirectDrawSurface3 methods ***/
FORWARD1(IDirectDrawSurface3, AddOverlayDirtyRect, LPRECT)
FORWARD3(IDirectDrawSurface3, BltBatch, LPDDBLTBATCH, DWORD, DWORD )
FORWARD5(IDirectDrawSurface3, BltFast, DWORD,DWORD,LPDIRECTDRAWSURFACE3, LPRECT,DWORD)
FORWARD2(IDirectDrawSurface3, EnumAttachedSurfaces, LPVOID,LPDDENUMSURFACESCALLBACK)
FORWARD3(IDirectDrawSurface3, EnumOverlayZOrders, DWORD,LPVOID,LPDDENUMSURFACESCALLBACK)
FORWARD2(IDirectDrawSurface3, Flip, LPDIRECTDRAWSURFACE3, DWORD)
FORWARD1(IDirectDrawSurface3, GetBltStatus, DWORD)
FORWARD1(IDirectDrawSurface3, GetCaps, LPDDSCAPS)
FORWARD1(IDirectDrawSurface3, GetClipper, LPDIRECTDRAWCLIPPER FAR*)
FORWARD2(IDirectDrawSurface3, GetColorKey, DWORD, LPDDCOLORKEY)
FORWARD1(IDirectDrawSurface3, GetFlipStatus, DWORD)
FORWARD2(IDirectDrawSurface3, GetOverlayPosition, LPLONG, LPLONG )
FORWARD1(IDirectDrawSurface3, GetPixelFormat, LPDDPIXELFORMAT)
FORWARD2(IDirectDrawSurface3, Initialize, LPDIRECTDRAW, LPDDSURFACEDESC)
FORWARD0(IDirectDrawSurface3, IsLost)
FORWARD0(IDirectDrawSurface3, Restore)
FORWARD1(IDirectDrawSurface3, SetClipper, LPDIRECTDRAWCLIPPER)
FORWARD2(IDirectDrawSurface3, SetColorKey, DWORD, LPDDCOLORKEY)
FORWARD2(IDirectDrawSurface3, SetOverlayPosition, LONG, LONG )
FORWARD5(IDirectDrawSurface3, UpdateOverlay, LPRECT, LPDIRECTDRAWSURFACE3,LPRECT,DWORD, LPDDOVERLAYFX)
FORWARD1(IDirectDrawSurface3, UpdateOverlayDisplay, DWORD)
FORWARD2(IDirectDrawSurface3, UpdateOverlayZOrder, DWORD, LPDIRECTDRAWSURFACE3)
FORWARD1(IDirectDrawSurface3, PageLock, DWORD)
FORWARD1(IDirectDrawSurface3, PageUnlock, DWORD)
FORWARD2(IDirectDrawSurface3, SetSurfaceDesc, LPDDSURFACEDESC, DWORD )

IDirectDrawSurface3Vtbl g_DirectDrawSurface3Vtbl_DX3 =
{
    IDirectDrawSurface3AggQueryInterface,
    IDirectDrawSurface3AggAddRef,
    IDirectDrawSurface3AggRelease,
    IDirectDrawSurface3AggAddAttachedSurface,
    IDirectDrawSurface3AddOverlayDirtyRect,
    IDirectDrawSurface3AggBlt,
    IDirectDrawSurface3BltBatch,
    IDirectDrawSurface3BltFast,
    IDirectDrawSurface3AggDeleteAttachedSurface,
    IDirectDrawSurface3EnumAttachedSurfaces,
    IDirectDrawSurface3EnumOverlayZOrders,
    IDirectDrawSurface3AggFlip,
    IDirectDrawSurface3AggGetAttachedSurface,
    IDirectDrawSurface3GetBltStatus,
    IDirectDrawSurface3GetCaps,
    IDirectDrawSurface3GetClipper,
    IDirectDrawSurface3GetColorKey,
    IDirectDrawSurface3AggGetDC,
    IDirectDrawSurface3GetFlipStatus,
    IDirectDrawSurface3GetOverlayPosition,
    IDirectDrawSurface3AggGetPalette,
    IDirectDrawSurface3GetPixelFormat,
    IDirectDrawSurface3AggGetSurfaceDesc,
    IDirectDrawSurface3Initialize,
    IDirectDrawSurface3IsLost,
    IDirectDrawSurface3AggLock,
    IDirectDrawSurface3AggReleaseDC,
    IDirectDrawSurface3Restore,
    IDirectDrawSurface3SetClipper,
    IDirectDrawSurface3SetColorKey,
    IDirectDrawSurface3SetOverlayPosition,
    IDirectDrawSurface3AggSetPalette,
    IDirectDrawSurface3AggUnlock,
    IDirectDrawSurface3UpdateOverlay,
    IDirectDrawSurface3UpdateOverlayDisplay,
    IDirectDrawSurface3UpdateOverlayZOrder,
    IDirectDrawSurface3AggGetDDInterface,
    IDirectDrawSurface3PageLock,
    IDirectDrawSurface3PageUnlock,
    IDirectDrawSurface3AggSetSurfaceDesc
};

IDirectDrawSurface3Vtbl g_DirectDrawSurface3Vtbl_DX5 =
{
    IDirectDrawSurface3AggQueryInterface,
    IDirectDrawSurface3AggAddRef,
    IDirectDrawSurface3AggRelease,
    IDirectDrawSurface3AggAddAttachedSurface,
    IDirectDrawSurface3AddOverlayDirtyRect,
    IDirectDrawSurface3AggBlt,
    IDirectDrawSurface3BltBatch,
    IDirectDrawSurface3BltFast,
    IDirectDrawSurface3AggDeleteAttachedSurface,
    IDirectDrawSurface3EnumAttachedSurfaces,
    IDirectDrawSurface3EnumOverlayZOrders,
    IDirectDrawSurface3AggFlip,
    IDirectDrawSurface3AggGetAttachedSurface,
    IDirectDrawSurface3GetBltStatus,
    IDirectDrawSurface3GetCaps,
    IDirectDrawSurface3GetClipper,
    IDirectDrawSurface3GetColorKey,
    IDirectDrawSurface3AggGetDC,
    IDirectDrawSurface3GetFlipStatus,
    IDirectDrawSurface3GetOverlayPosition,
    IDirectDrawSurface3AggGetPalette,
    IDirectDrawSurface3GetPixelFormat,
    IDirectDrawSurface3AggGetSurfaceDesc,
    IDirectDrawSurface3Initialize,
    IDirectDrawSurface3IsLost,
    IDirectDrawSurface3AggLock,
    IDirectDrawSurface3AggReleaseDC,
    IDirectDrawSurface3Restore,
    IDirectDrawSurface3SetClipper,
    IDirectDrawSurface3SetColorKey,
    IDirectDrawSurface3SetOverlayPosition,
    IDirectDrawSurface3AggSetPalette,
    IDirectDrawSurface3AggUnlock,
    IDirectDrawSurface3UpdateOverlay,
    IDirectDrawSurface3UpdateOverlayDisplay,
    IDirectDrawSurface3UpdateOverlayZOrder,
    IDirectDrawSurface3AggGetDDInterface,
    IDirectDrawSurface3PageLock,
    IDirectDrawSurface3PageUnlock,
    IDirectDrawSurface3SetSurfaceDesc
};

/*
 * IDirectDrawSurface4
 */
STDMETHODIMP IDirectDrawSurface4AggQueryInterface(IDirectDrawSurface4 *pDDS4, REFIID riid, void ** ppv)
{
    return __QI(SURFACEOF(pDDS4)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDrawSurface4AggAddRef(IDirectDrawSurface4 *);
STDMETHODIMP_(ULONG) IDirectDrawSurface4AggRelease(IDirectDrawSurface4 *);
STDMETHODIMP IDirectDrawSurface4AggGetDC(IDirectDrawSurface4 *, HDC *);
STDMETHODIMP IDirectDrawSurface4AggReleaseDC(IDirectDrawSurface4 *, HDC);
STDMETHODIMP IDirectDrawSurface4AggLock(IDirectDrawSurface4 *, LPRECT,LPDDSURFACEDESC2,DWORD,HANDLE);
STDMETHODIMP IDirectDrawSurface4AggUnlock(IDirectDrawSurface4 *, LPRECT);
STDMETHODIMP IDirectDrawSurface4AggSetSurfaceDesc(IDirectDrawSurface4 *, LPDDSURFACEDESC, DWORD);
STDMETHODIMP IDirectDrawSurface4AggGetAttachedSurface( IDirectDrawSurface4 *, LPDDSCAPS2, LPDIRECTDRAWSURFACE4 FAR *);
STDMETHODIMP IDirectDrawSurface4AggAddAttachedSurface( IDirectDrawSurface4 *, LPDIRECTDRAWSURFACE4);
STDMETHODIMP IDirectDrawSurface4AggDeleteAttachedSurface( IDirectDrawSurface4 *,DWORD, LPDIRECTDRAWSURFACE4);
STDMETHODIMP IDirectDrawSurface4AggFlip(IDirectDrawSurface4 *, LPDIRECTDRAWSURFACE4, DWORD);
STDMETHODIMP IDirectDrawSurface4AggBlt(IDirectDrawSurface4 *,LPRECT,LPDIRECTDRAWSURFACE4, LPRECT,DWORD, LPDDBLTFX);
STDMETHODIMP IDirectDrawSurface4AggGetPalette(IDirectDrawSurface4 *, LPDIRECTDRAWPALETTE FAR *);
STDMETHODIMP IDirectDrawSurface4AggSetPalette(IDirectDrawSurface4 *, LPDIRECTDRAWPALETTE);
STDMETHODIMP IDirectDrawSurface4AggGetDDInterface(IDirectDrawSurface4 *, LPVOID FAR *);
STDMETHODIMP IDirectDrawSurface4AggGetSurfaceDesc(IDirectDrawSurface4 *, LPDDSURFACEDESC2);







/*** IDirectDrawSurface4 methods ***/
FORWARD1(IDirectDrawSurface4, AddOverlayDirtyRect, LPRECT)
FORWARD3(IDirectDrawSurface4, BltBatch, LPDDBLTBATCH, DWORD, DWORD )
FORWARD5(IDirectDrawSurface4, BltFast, DWORD,DWORD,LPDIRECTDRAWSURFACE4, LPRECT,DWORD)
FORWARD2(IDirectDrawSurface4, EnumAttachedSurfaces, LPVOID,LPDDENUMSURFACESCALLBACK2)
FORWARD3(IDirectDrawSurface4, EnumOverlayZOrders, DWORD,LPVOID,LPDDENUMSURFACESCALLBACK2)
FORWARD2(IDirectDrawSurface4, Flip, LPDIRECTDRAWSURFACE4, DWORD)
FORWARD1(IDirectDrawSurface4, GetBltStatus, DWORD)
FORWARD1(IDirectDrawSurface4, GetCaps, LPDDSCAPS2)
FORWARD1(IDirectDrawSurface4, GetClipper, LPDIRECTDRAWCLIPPER FAR*)
FORWARD2(IDirectDrawSurface4, GetColorKey, DWORD, LPDDCOLORKEY)
FORWARD1(IDirectDrawSurface4, GetFlipStatus, DWORD)
FORWARD2(IDirectDrawSurface4, GetOverlayPosition, LPLONG, LPLONG )
FORWARD1(IDirectDrawSurface4, GetPixelFormat, LPDDPIXELFORMAT)
FORWARD2(IDirectDrawSurface4, Initialize, LPDIRECTDRAW, LPDDSURFACEDESC2)
FORWARD0(IDirectDrawSurface4, IsLost)
FORWARD0(IDirectDrawSurface4, Restore)
FORWARD1(IDirectDrawSurface4, SetClipper, LPDIRECTDRAWCLIPPER)
FORWARD2(IDirectDrawSurface4, SetColorKey, DWORD, LPDDCOLORKEY)
FORWARD2(IDirectDrawSurface4, SetOverlayPosition, LONG, LONG )
FORWARD5(IDirectDrawSurface4, UpdateOverlay, LPRECT, LPDIRECTDRAWSURFACE4,LPRECT,DWORD, LPDDOVERLAYFX)
FORWARD1(IDirectDrawSurface4, UpdateOverlayDisplay, DWORD)
FORWARD2(IDirectDrawSurface4, UpdateOverlayZOrder, DWORD, LPDIRECTDRAWSURFACE4)
FORWARD1(IDirectDrawSurface4, PageLock, DWORD)
FORWARD1(IDirectDrawSurface4, PageUnlock, DWORD)
FORWARD2(IDirectDrawSurface4, SetSurfaceDesc, LPDDSURFACEDESC2, DWORD )
FORWARD4(IDirectDrawSurface4, SetPrivateData, REFGUID, LPVOID, DWORD, DWORD )
FORWARD3(IDirectDrawSurface4, GetPrivateData, REFGUID, LPVOID, LPDWORD)
FORWARD1(IDirectDrawSurface4, FreePrivateData, REFGUID )
FORWARD1(IDirectDrawSurface4, GetUniquenessValue, LPDWORD )
FORWARD0(IDirectDrawSurface4, ChangeUniquenessValue )


IDirectDrawSurface4Vtbl g_DirectDrawSurface4Vtbl =
{
    IDirectDrawSurface4AggQueryInterface,
    IDirectDrawSurface4AggAddRef,
    IDirectDrawSurface4AggRelease,
    IDirectDrawSurface4AggAddAttachedSurface,
    IDirectDrawSurface4AddOverlayDirtyRect,
    IDirectDrawSurface4AggBlt,
    IDirectDrawSurface4BltBatch,
    IDirectDrawSurface4BltFast,
    IDirectDrawSurface4AggDeleteAttachedSurface,
    IDirectDrawSurface4EnumAttachedSurfaces,
    IDirectDrawSurface4EnumOverlayZOrders,
    IDirectDrawSurface4AggFlip,
    IDirectDrawSurface4AggGetAttachedSurface,
    IDirectDrawSurface4GetBltStatus,
    IDirectDrawSurface4GetCaps,
    IDirectDrawSurface4GetClipper,
    IDirectDrawSurface4GetColorKey,
    IDirectDrawSurface4AggGetDC,
    IDirectDrawSurface4GetFlipStatus,
    IDirectDrawSurface4GetOverlayPosition,
    IDirectDrawSurface4AggGetPalette,
    IDirectDrawSurface4GetPixelFormat,
    IDirectDrawSurface4AggGetSurfaceDesc,
    IDirectDrawSurface4Initialize,
    IDirectDrawSurface4IsLost,
    IDirectDrawSurface4AggLock,
    IDirectDrawSurface4AggReleaseDC,
    IDirectDrawSurface4Restore,
    IDirectDrawSurface4SetClipper,
    IDirectDrawSurface4SetColorKey,
    IDirectDrawSurface4SetOverlayPosition,
    IDirectDrawSurface4AggSetPalette,
    IDirectDrawSurface4AggUnlock,
    IDirectDrawSurface4UpdateOverlay,
    IDirectDrawSurface4UpdateOverlayDisplay,
    IDirectDrawSurface4UpdateOverlayZOrder,
    IDirectDrawSurface4AggGetDDInterface,
    IDirectDrawSurface4PageLock,
    IDirectDrawSurface4PageUnlock,
    IDirectDrawSurface4SetSurfaceDesc,
    IDirectDrawSurface4SetPrivateData,
    IDirectDrawSurface4GetPrivateData,
    IDirectDrawSurface4FreePrivateData,
    IDirectDrawSurface4GetUniquenessValue,
    IDirectDrawSurface4ChangeUniquenessValue
};



/*
 * IDirectDrawPalette
 */
STDMETHODIMP IDirectDrawPaletteAggQueryInterface(IDirectDrawPalette *pDDP, REFIID riid, void ** ppv)
{
    return __QI(PALETTEOF(pDDP)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDrawPaletteAggAddRef(IDirectDrawPalette *);
STDMETHODIMP_(ULONG) IDirectDrawPaletteAggRelease(IDirectDrawPalette *);
STDMETHODIMP IDirectDrawPaletteAggSetEntries(IDirectDrawPalette *,DWORD,DWORD,DWORD,LPPALETTEENTRY);

/*** IDirectDrawPalette methods ***/
FORWARD1(IDirectDrawPalette, GetCaps, LPDWORD);
FORWARD4(IDirectDrawPalette, GetEntries, DWORD,DWORD,DWORD,LPPALETTEENTRY);
FORWARD3(IDirectDrawPalette, Initialize, LPDIRECTDRAW, DWORD, LPPALETTEENTRY);

IDirectDrawPaletteVtbl g_DirectDrawPaletteVtbl =
{
    IDirectDrawPaletteAggQueryInterface,
    IDirectDrawPaletteAggAddRef,
    IDirectDrawPaletteAggRelease,
    IDirectDrawPaletteGetCaps,
    IDirectDrawPaletteGetEntries,
    IDirectDrawPaletteInitialize,
    IDirectDrawPaletteAggSetEntries
};


/*
 * InitDirectDrawInterfaces
 *
 * set up our ddraw interface data
 */
void __stdcall InitDirectDrawInterfaces(
	IDirectDraw *pDD,
	INTSTRUC_IDirectDraw *pDDInt,
	IDirectDraw2 *pDD2,
	INTSTRUC_IDirectDraw2 *pDD2Int,
        IDirectDraw4 *pDD4,
        INTSTRUC_IDirectDraw4 *pDD4Int)

{
    memcpy(pDDInt,  pDD,  sizeof(REALDDINTSTRUC));
    memcpy(pDD2Int, pDD2, sizeof(REALDDINTSTRUC));
    pDDInt->lpVtbl = &g_DirectDrawVtbl;
    pDD2Int->lpVtbl = &g_DirectDraw2Vtbl;
    if (pDD4)
    {
        memcpy(pDD4Int, pDD4, sizeof(REALDDINTSTRUC));
        pDD4Int->lpVtbl = &g_DirectDraw4Vtbl;
    }
    else
    {
        memset(pDD4Int, 0, sizeof(*pDD4Int));
    }
} /* InitDirectDrawInterfaces */


void __stdcall InitDirectDrawPaletteInterfaces(
	IDirectDrawPalette *pDDPalette,
	INTSTRUC_IDirectDrawPalette *pDDInt)

{
    memcpy(pDDInt,  pDDPalette,  sizeof(REALDDINTSTRUC));
    pDDInt->lpVtbl = &g_DirectDrawPaletteVtbl;
}

/*
 * InitSurfaceInterfaces
 *
 * set up our ddraw surface interface data
 */
void __stdcall InitSurfaceInterfaces(
			IDirectDrawSurface *pDDSurface,
			INTSTRUC_IDirectDrawSurface *pDDSInt,
			IDirectDrawSurface2 *pDDSurface2,
			INTSTRUC_IDirectDrawSurface2 *pDDS2Int,
			IDirectDrawSurface3 *pDDSurface3,
			INTSTRUC_IDirectDrawSurface3 *pDDS3Int,
			IDirectDrawSurface4 *pDDSurface4,
			INTSTRUC_IDirectDrawSurface4 *pDDS4Int
                        )
{
    memcpy(pDDSInt,  pDDSurface,  sizeof(REALDDINTSTRUC));
    pDDSInt->lpVtbl = &g_DirectDrawSurfaceVtbl;

    memcpy(pDDS2Int, pDDSurface2, sizeof(REALDDINTSTRUC));
    pDDS2Int->lpVtbl = &g_DirectDrawSurface2Vtbl;

    #pragma message( REMIND( "Would it be better to have 1 table and change the SetSurfaceDesc member?" ))
    if( pDDSurface3 != NULL )
    {
	memcpy(pDDS3Int, pDDSurface3, sizeof(REALDDINTSTRUC));
	pDDS3Int->lpVtbl = &g_DirectDrawSurface3Vtbl_DX5;
    }
    else
    {
	memcpy(pDDS3Int, pDDSurface2, sizeof(REALDDINTSTRUC));
	pDDS3Int->lpVtbl = &g_DirectDrawSurface3Vtbl_DX3;
    }

    if (pDDSurface4)
    {
        memcpy(pDDS4Int, pDDSurface4, sizeof(REALDDINTSTRUC));
        pDDS4Int->lpVtbl = &g_DirectDrawSurface4Vtbl;
    }
    else
    {
        memset(pDDS4Int, 0, sizeof(*pDDS4Int));
    }

} /* InitSurfaceInterfaces */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\d3dcaps.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dcaps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3DCAPS_H
#define _D3DCAPS_H

/* 
 *  Pull in DirectDraw include file automatically:
 */
#include <ddraw.h>

#pragma pack(4)

/* Description of capabilities of transform */

typedef struct _D3DTRANSFORMCAPS {
    DWORD dwSize;
    DWORD dwCaps;
} D3DTRANSFORMCAPS, *LPD3DTRANSFORMCAPS;

#define D3DTRANSFORMCAPS_CLIP           0x00000001L /* Will clip whilst transforming */

/* Description of capabilities of lighting */

typedef struct _D3DLIGHTINGCAPS {
    DWORD dwSize;
    DWORD dwCaps;                   /* Lighting caps */
    DWORD dwLightingModel;          /* Lighting model - RGB or mono */
    DWORD dwNumLights;              /* Number of lights that can be handled */
} D3DLIGHTINGCAPS, *LPD3DLIGHTINGCAPS;

#define D3DLIGHTINGMODEL_RGB            0x00000001L
#define D3DLIGHTINGMODEL_MONO           0x00000002L

#define D3DLIGHTCAPS_POINT              0x00000001L /* Point lights supported */
#define D3DLIGHTCAPS_SPOT               0x00000002L /* Spot lights supported */
#define D3DLIGHTCAPS_DIRECTIONAL        0x00000004L /* Directional lights supported */
#define D3DLIGHTCAPS_PARALLELPOINT      0x00000008L /* Parallel point lights supported */
#define D3DLIGHTCAPS_GLSPOT             0x00000010L /* GL syle spot lights supported */

/* Description of capabilities for each primitive type */

typedef struct _D3DPrimCaps {
    DWORD dwSize;
    DWORD dwMiscCaps;                 /* Capability flags */
    DWORD dwRasterCaps;
    DWORD dwZCmpCaps;
    DWORD dwSrcBlendCaps;
    DWORD dwDestBlendCaps;
    DWORD dwAlphaCmpCaps;
    DWORD dwShadeCaps;
    DWORD dwTextureCaps;
    DWORD dwTextureFilterCaps;
    DWORD dwTextureBlendCaps;
    DWORD dwTextureAddressCaps;
    DWORD dwStippleWidth;             /* maximum width and height of */
    DWORD dwStippleHeight;            /* of supported stipple (up to 32x32) */
} D3DPRIMCAPS, *LPD3DPRIMCAPS;

/* D3DPRIMCAPS dwMiscCaps */

#define D3DPMISCCAPS_MASKPLANES         0x00000001L
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CONFORMANT         0x00000008L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L

/* D3DPRIMCAPS dwRasterCaps */

#define D3DPRASTERCAPS_DITHER           0x00000001L
#define D3DPRASTERCAPS_ROP2             0x00000002L
#define D3DPRASTERCAPS_XOR              0x00000004L
#define D3DPRASTERCAPS_PAT              0x00000008L
#define D3DPRASTERCAPS_ZTEST            0x00000010L
#define D3DPRASTERCAPS_SUBPIXEL         0x00000020L
#define D3DPRASTERCAPS_SUBPIXELX        0x00000040L
#define D3DPRASTERCAPS_FOGVERTEX        0x00000080L
#define D3DPRASTERCAPS_FOGTABLE         0x00000100L
#define D3DPRASTERCAPS_STIPPLE          0x00000200L

/* D3DPRIMCAPS dwZCmpCaps, dwAlphaCmpCaps */

#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

/* D3DPRIMCAPS dwSourceBlendCaps, dwDestBlendCaps */

#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L

/* D3DPRIMCAPS dwShadeCaps */

#define D3DPSHADECAPS_COLORFLATMONO             0x00000001L
#define D3DPSHADECAPS_COLORFLATRGB              0x00000002L
#define D3DPSHADECAPS_COLORGOURAUDMONO          0x00000004L
#define D3DPSHADECAPS_COLORGOURAUDRGB           0x00000008L
#define D3DPSHADECAPS_COLORPHONGMONO            0x00000010L
#define D3DPSHADECAPS_COLORPHONGRGB             0x00000020L

#define D3DPSHADECAPS_SPECULARFLATMONO          0x00000040L
#define D3DPSHADECAPS_SPECULARFLATRGB           0x00000080L
#define D3DPSHADECAPS_SPECULARGOURAUDMONO       0x00000100L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB        0x00000200L
#define D3DPSHADECAPS_SPECULARPHONGMONO         0x00000400L
#define D3DPSHADECAPS_SPECULARPHONGRGB          0x00000800L

#define D3DPSHADECAPS_ALPHAFLATBLEND            0x00001000L
#define D3DPSHADECAPS_ALPHAFLATSTIPPLED         0x00002000L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND         0x00004000L
#define D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED      0x00008000L
#define D3DPSHADECAPS_ALPHAPHONGBLEND           0x00010000L
#define D3DPSHADECAPS_ALPHAPHONGSTIPPLED        0x00020000L

#define D3DPSHADECAPS_FOGFLAT                   0x00040000L
#define D3DPSHADECAPS_FOGGOURAUD                0x00080000L
#define D3DPSHADECAPS_FOGPHONG                  0x00100000L

/* D3DPRIMCAPS dwTextureCaps */

#define D3DPTEXTURECAPS_PERSPECTIVE     0x00000001L
#define D3DPTEXTURECAPS_POW2            0x00000002L
#define D3DPTEXTURECAPS_ALPHA           0x00000004L
#define D3DPTEXTURECAPS_TRANSPARENCY    0x00000008L
#define D3DPTEXTURECAPS_BORDER          0x00000010L
#define D3DPTEXTURECAPS_SQUAREONLY      0x00000020L

/* D3DPRIMCAPS dwTextureFilterCaps */

#define D3DPTFILTERCAPS_NEAREST         0x00000001L
#define D3DPTFILTERCAPS_LINEAR          0x00000002L
#define D3DPTFILTERCAPS_MIPNEAREST      0x00000004L
#define D3DPTFILTERCAPS_MIPLINEAR       0x00000008L
#define D3DPTFILTERCAPS_LINEARMIPNEAREST 0x00000010L
#define D3DPTFILTERCAPS_LINEARMIPLINEAR 0x00000020L

/* D3DPRIMCAPS dwTextureBlendCaps */

#define D3DPTBLENDCAPS_DECAL            0x00000001L
#define D3DPTBLENDCAPS_MODULATE         0x00000002L
#define D3DPTBLENDCAPS_DECALALPHA       0x00000004L
#define D3DPTBLENDCAPS_MODULATEALPHA    0x00000008L
#define D3DPTBLENDCAPS_DECALMASK        0x00000010L
#define D3DPTBLENDCAPS_MODULATEMASK     0x00000020L
#define D3DPTBLENDCAPS_COPY             0x00000040L

/* D3DPRIMCAPS dwTextureAddressCaps */
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L

/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 */
typedef struct _D3DDeviceDesc {
    DWORD            dwSize;                 /* Size of D3DDEVICEDESC structure */
    DWORD            dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;          /* Color model of device */
    DWORD            dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL             bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD            dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD            dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD            dwMaxVertexCount;       /* Maximum vertex count */
} D3DDEVICEDESC, *LPD3DDEVICEDESC;

typedef HRESULT (FAR PASCAL * LPD3DENUMDEVICESCALLBACK)(LPGUID lpGuid, LPSTR lpDeviceDescription, LPSTR lpDeviceName, LPD3DDEVICEDESC, LPD3DDEVICEDESC, LPVOID);

/* D3DDEVICEDESC dwFlags indicating valid fields */

#define D3DDD_COLORMODEL            0x00000001L /* dcmColorModel is valid */
#define D3DDD_DEVCAPS               0x00000002L /* dwDevCaps is valid */
#define D3DDD_TRANSFORMCAPS         0x00000004L /* dtcTransformCaps is valid */
#define D3DDD_LIGHTINGCAPS          0x00000008L /* dlcLightingCaps is valid */
#define D3DDD_BCLIPPING             0x00000010L /* bClipping is valid */
#define D3DDD_LINECAPS              0x00000020L /* dpcLineCaps is valid */
#define D3DDD_TRICAPS               0x00000040L /* dpcTriCaps is valid */
#define D3DDD_DEVICERENDERBITDEPTH  0x00000080L /* dwDeviceRenderBitDepth is valid */
#define D3DDD_DEVICEZBUFFERBITDEPTH 0x00000100L /* dwDeviceZBufferBitDepth is valid */
#define D3DDD_MAXBUFFERSIZE         0x00000200L /* dwMaxBufferSize is valid */
#define D3DDD_MAXVERTEXCOUNT        0x00000400L /* dwMaxVertexCount is valid */

/* D3DDEVICEDESC dwDevCaps flags */

#define D3DDEVCAPS_FLOATTLVERTEX        0x00000001L /* Device accepts floating point */
                                                    /* for post-transform vertex data */
#define D3DDEVCAPS_SORTINCREASINGZ      0x00000002L /* Device needs data sorted for increasing Z*/
#define D3DDEVCAPS_SORTDECREASINGZ      0X00000004L /* Device needs data sorted for decreasing Z*/
#define D3DDEVCAPS_SORTEXACT            0x00000008L /* Device needs data sorted exactly */

#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */

#define D3DFDS_COLORMODEL        0x00000001L /* Match color model */
#define D3DFDS_GUID              0x00000002L /* Match guid */
#define D3DFDS_HARDWARE          0x00000004L /* Match hardware/software */
#define D3DFDS_TRIANGLES         0x00000008L /* Match in triCaps */
#define D3DFDS_LINES             0x00000010L /* Match in lineCaps  */
#define D3DFDS_MISCCAPS          0x00000020L /* Match primCaps.dwMiscCaps */
#define D3DFDS_RASTERCAPS        0x00000040L /* Match primCaps.dwRasterCaps */
#define D3DFDS_ZCMPCAPS          0x00000080L /* Match primCaps.dwZCmpCaps */
#define D3DFDS_ALPHACMPCAPS      0x00000100L /* Match primCaps.dwAlphaCmpCaps */
#define D3DFDS_SRCBLENDCAPS      0x00000200L /* Match primCaps.dwSourceBlendCaps */
#define D3DFDS_DSTBLENDCAPS      0x00000400L /* Match primCaps.dwDestBlendCaps */
#define D3DFDS_SHADECAPS         0x00000800L /* Match primCaps.dwShadeCaps */
#define D3DFDS_TEXTURECAPS       0x00001000L /* Match primCaps.dwTextureCaps */
#define D3DFDS_TEXTUREFILTERCAPS 0x00002000L /* Match primCaps.dwTextureFilterCaps */
#define D3DFDS_TEXTUREBLENDCAPS  0x00004000L /* Match primCaps.dwTextureBlendCaps */
#define D3DFDS_TEXTUREADDRESSCAPS  0x00008000L /* Match primCaps.dwTextureBlendCaps */

/*
 * FindDevice arguments
 */
typedef struct _D3DFINDDEVICESEARCH {
    DWORD               dwSize;
    DWORD               dwFlags;
    BOOL                bHardware;
    D3DCOLORMODEL       dcmColorModel;
    GUID                guid;
    DWORD               dwCaps;
    D3DPRIMCAPS         dpcPrimCaps;
} D3DFINDDEVICESEARCH, *LPD3DFINDDEVICESEARCH;

typedef struct _D3DFINDDEVICERESULT {
    DWORD               dwSize;
    GUID                guid;           /* guid which matched */
    D3DDEVICEDESC       ddHwDesc;               /* hardware D3DDEVICEDESC */
    D3DDEVICEDESC       ddSwDesc;       /* software D3DDEVICEDESC */
} D3DFINDDEVICERESULT, *LPD3DFINDDEVICERESULT;

/*
 * Description of execute buffer.
 */
typedef struct _D3DExecuteBufferDesc {
    DWORD               dwSize;         /* size of this structure */
    DWORD               dwFlags;        /* flags indicating which fields are valid */
    DWORD               dwCaps;         /* capabilities of execute buffer */
    DWORD               dwBufferSize;   /* size of execute buffer data */
    LPVOID              lpData;         /* pointer to actual data */
} D3DEXECUTEBUFFERDESC, *LPD3DEXECUTEBUFFERDESC;

/* D3DEXECUTEBUFFER dwFlags indicating valid fields */

#define D3DDEB_BUFSIZE          0x00000001l     /* buffer size valid */
#define D3DDEB_CAPS             0x00000002l     /* caps valid */
#define D3DDEB_LPDATA           0x00000004l     /* lpData valid */

/* D3DEXECUTEBUFFER dwCaps */

#define D3DDEBCAPS_SYSTEMMEMORY 0x00000001l     /* buffer in system memory */
#define D3DDEBCAPS_VIDEOMEMORY  0x00000002l     /* buffer in device memory */
#define D3DDEBCAPS_MEM (D3DDEBCAPS_SYSTEMMEMORY|D3DDEBCAPS_VIDEOMEMORY)

#pragma pack()

#endif /* _D3DCAPS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\16to32.asm ===
page	,132
	.listall

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Fri Jun 20 10:27:33 1997

;Command Line: thunk -P2 -NC ddraw -t thk1632 ..\16to32.thk -o 16to32.asm 

	TITLE	$16to32.asm

	.386
	OPTION READONLY


IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16 -DIS_32
.err
ENDIF
ENDIF
IFDEF IS_16
IFDEF IS_32
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF

	OPTION SEGMENT:USE16
	.model LARGE,PASCAL

f32ptr  typedef ptr far32

externDef DDHAL32_VidMemFree:far16
externDef DDHAL32_VidMemAlloc:far16

externDef C16ThkSL01:far16
externDef __FLATCS:ABS
externDef __FLATDS:ABS


	.data

public thk1632_ThunkData16	;This symbol must be exported.
thk1632_ThunkData16	dd	31304c53h	;Protocol 'SL01'
	dd	0fa1h	;Checksum
	dd	0		;Flags.
	dd	0		;RESERVED. MUST BE ZERO.
	dd	0		;RESERVED. MUST BE ZERO.
	dd	0		;RESERVED. MUST BE ZERO.
	dd	0		;RESERVED. MUST BE ZERO.
	dd	3130424ch	;Late-binding signature 'LB01'
	dd	080000000h		;More flags.
	dd	0		;RESERVED. MUST BE ZERO.
	dw	offset thk1632_ThunkData16ApiDatabase
	dw	   seg thk1632_ThunkData16ApiDatabase


;; Api database. Each entry == 8 bytes:
;;  byte  0:     # of argument bytes.
;;  byte  1,2,3: Reserved: Must initialize to 0.
;;  dword 4:	 error return value.
public thk1632_ThunkData16ApiDatabase
thk1632_ThunkData16ApiDatabase	label	dword
	db	10
	db	0,0,0
	dd	-1
	db	14
	db	0,0,0
	dd	0




	.code ddraw


externDef ThunkConnect16:far16

public thk1632_ThunkConnect16
thk1632_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    thk1632_ThunkData16
	push	offset thk1632_ThunkData16
	push	seg    thk1632_TD32Label
	push	offset thk1632_TD32Label
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
thk1632_TD32Label label byte
	db	"thk1632_ThunkData32",0


DDHAL32_VidMemFree label far16
	mov	cx,0			; offset in jump table
	jmp	thk1632EntryCommon

DDHAL32_VidMemAlloc label far16
	mov	cx,4			; offset in jump table
	jmp	thk1632EntryCommon

;===========================================================================
; This is the common setup code for 16=>32 thunks.
;
; Entry:  cx  = offset in flat jump table
;
; Don't optimize this code: C16ThkSL01 overwrites it
; after each discard.

align
thk1632EntryCommon:
	db	0ebh, 030	;Jump short forward 30 bytes.
;;; Leave at least 30 bytes for C16ThkSL01's code patching.
	db	30 dup(0cch)	;Patch space.
	push	seg    thk1632_ThunkData16
	push	offset thk1632_ThunkData16
	pop	edx
	push	cs
	push	offset thk1632EntryCommon
	pop	eax
	jmp	C16ThkSL01

ELSE	; IS_32
	.model FLAT,STDCALL

include thk.inc
include 16to32.inc

externDef STDCALL DDHAL32_VidMemFree@12:near32
externDef STDCALL DDHAL32_VidMemAlloc@16:near32

externDef C DebugPrintf:near32

MapSLFix		proto	STDCALL  :DWORD
MapSL		proto	STDCALL  :DWORD
UnMapSLFixArray		proto	STDCALL  :DWORD, :DWORD
LocalAlloc	proto	STDCALL  :DWORD, :DWORD
LocalFree	proto	STDCALL  :DWORD

externDef	MapHInstSL:near32
externDef	MapHInstSL_PN:near32
externDef	MapHInstLS:near32
externDef	MapHInstLS_PN:near32
externDef T_DDHAL32_VIDMEMFREE:near32
externDef T_DDHAL32_VIDMEMALLOC:near32

;===========================================================================
	.code 


; This is a jump table to API-specific flat thunk code.

align
thk1632_JumpTable label dword
	dd	offset FLAT:T_DDHAL32_VIDMEMFREE
	dd	offset FLAT:T_DDHAL32_VIDMEMALLOC

thk1632_ThunkDataName label byte
	db	"thk1632_ThunkData16",0

	.data

public thk1632_ThunkData32	;This symbol must be exported.
thk1632_ThunkData32	dd	31304c53h	;Protocol 'SL01'
	dd	0fa1h	;Checksum
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Flat address of ThunkData16
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset thk1632_JumpTable - offset thk1632_ThunkDataName



	.code 


externDef ThunkConnect32@24:near32

public thk1632_ThunkConnect32@16
thk1632_ThunkConnect32@16:
	pop	edx
	push	offset thk1632_ThunkDataName
	push	offset thk1632_ThunkData32
	push	edx
	jmp	ThunkConnect32@24


;===========================================================================
; Common routines to restore the stack and registers
; and return to 16-bit code.  There is one for each
; size of 16-bit parameter list in this script.

align
ExitFlat_10:
	mov	cl,10		; parameter byte count
	mov	esp,ebp		; point to return address
	retn			; return to dispatcher

align
ExitFlat_14:
	mov	cl,14		; parameter byte count
	mov	esp,ebp		; point to return address
	retn			; return to dispatcher

;===========================================================================
T_DDHAL32_VIDMEMFREE label near32

; ebx+28   this
; ebx+26   heap
; ebx+22   ptr
	APILOGSL	DDHAL32_VidMemFree

;-------------------------------------
; create new call frame and make the call

; ptr  from: unsigned long
	push	dword ptr [ebx+22]	; to unsigned long

; heap  from: short
	movsx	eax,word ptr [ebx+26]
	push	eax			; to: long

; this  from: unsigned long
	push	dword ptr [ebx+28]	; to unsigned long

	call	DDHAL32_VidMemFree@12		; call 32-bit version
; return code unsigned long --> unsigned long
	mov	edx,eax
	rol	edx,16

;-------------------------------------
	jmp	ExitFlat_10

;===========================================================================
T_DDHAL32_VIDMEMALLOC label near32

; ebx+32   this
; ebx+30   heap
; ebx+26   width
; ebx+22   height
	APILOGSL	DDHAL32_VidMemAlloc

;-------------------------------------
; create new call frame and make the call

; height  from: unsigned long
	push	dword ptr [ebx+22]	; to unsigned long

; width  from: unsigned long
	push	dword ptr [ebx+26]	; to unsigned long

; heap  from: short
	movsx	eax,word ptr [ebx+30]
	push	eax			; to: long

; this  from: unsigned long
	push	dword ptr [ebx+32]	; to unsigned long

	call	DDHAL32_VidMemAlloc@16		; call 32-bit version
; return code unsigned long --> unsigned long
	mov	edx,eax
	rol	edx,16

;-------------------------------------
	jmp	ExitFlat_14

ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\surface.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawex.cpp
 *  Content:	new DirectDraw object support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-feb-97	ralphl	initial implementation
 *   25-feb-97	craige	minor tweaks for dx checkin; integrated IBitmapSurface
 *			stuff
 *   27-feb-97	craige	use DIBSections for surface memory ddraw 3 surfaces
 *			(icky icky icky)
 *   03-mar-97	craige	IRGBColorTable support
 *   06-mar-97	craige	support for IDirectDrawSurface3::SetBits
 *   14-mar-97  jeffort SetBits changed to reflect DX5 as SetSurfaceDesc
 *   01-apr-97  jeffort Following changes checked in:
 *                      D3DDevice and Texture interfaces supported in QueryInterface
 *                      MakeDibInfo fills in a dummy pixel mask for Z Buffers
 *                      Aligned freeing handled
 *                      Does not init (MakeDibSection) of primary surfaces
 *                      A palette is mapped in at GetDC calls
 *
 *   04-apr-97  jeffort LocalFree of bitmap info added
 *                      Addref and release added for D3D interfaces
 *
 *   09-apr-97  jeffort Added call to SetDIBColorTable at GetDC time
 *                      Support for WinNT4.0 Gold added by not creating a DIB section
 *                      and not supporting SetSurfaceDesc calls
 *                      Added support for halftone palette if no palette is
 *                      selected in at init time
 *                      Added support for proper handling of 1,2,and 4 bpp surface palettes
 *                      IBitmapSurface creation needs to set OWNDC flag
 *
 *   10-apr-97  jeffort Correct number of entries used in palette creation at GetDC time
 *
 *   16-apr-97  jeffort Check for OWNDC when creating a DibSection.  palette handling
 *                      change in GetDC of setting flags
 *   28-apr-97  jeffort Palette wrapping added/DX5 support
 *   30-apr-97  jeffort Critical section shared from ddrawex object
 *                      Attach list deleted at surface destruction time
 *                      AddAttachedSurfaces now passes in real interfaces
 *                      Palette functions pass in real interfaces to ddraw
 *                      AddRef removed from D3D interface QI's
 *   02-may-97  jeffort Deletion of implicit attached surface handled
 *                      wrapping of GetDDInterface returns our ddrawex interface
 *   06-may-97  jeffort Parameter checking, SetPalette handles null parameter
 *                      wrapping of DeleteAttachedSurface
 *
 *   08-may-97  jeffort SetPalette fixes (release should have been addref)
 *                      Better parameter checking
 *   20-may-97  jeffort NT4.0 Gold handles OWNDC as SP3 does by creating a dib
 *                      section and resets a few ddraw internal structures
 *                      These are reset at surface release time
 *   22-may-97  jeffort If a surface is being destroyed, detach any attached palette
 *                      If a SetPalette is called with NULL, and a palette
 *                      was previously attached, the member variable storing the
 *                      palette is set to NULL
 *   27-may-97  jeffort keep ref count on internal object eual to outer object
 *   02-jun-97  jeffort Temporary fix for SP3 memory leak.  Handle SP3 as NT Gold
 *                      by storing off pointer values and restoring at free
 *   17-jun-97  jeffort If releasing a surface that has explicitly attached surfaces
 *                      we now addref the inner surface (which will be released when
 *                      the inner surface we are releasing is released), and release
 *                      our outer interface so ref counting models ddraw.
 *   20-jun-97  jeffort added debug code to invaliudate objects when freed
 *                      when creating the primary surface, this is now added to the primary
 *                      surface list regardles if OWNDC is set or not
 *   27-jun-97  jeffort IDirectDrawSurface3 interface support for DX3 was not
 *                      added.  We now use an IDirectDrawSurface2 to spoof it
 *                      so we can support SetSurfaceDesc
 *   02-jul-97  jeffort Use m_bSaveDC boolean if a DX5 surface with OWNDC set
 *                      we need to not NULL out the DC when ReleaseDC is called
 *                      so that a call to GetSurfaceFromDC will work
 *   07-jul-97  jeffort Releasing DDrawEx object moved in destructor function to last step
 *   07-jul-97  jeffort Wrapped GetSurfaceDesc so correct caps bits are set
 *   10-jul-97  jeffort Added m_BMOld to reset the bitmap after releasing the one
 *                      we create
 *                      Do not add a surface to a palette list if it is already in this list
 *   18-jul-97  jeffort Added D3D MMX Device support
 *   22-jul-97  jeffort Removed IBitmapSurface and associated interfaces
 *                      Fixed problem with attach lists, and releasing implicit created surfaces
 *   02-aug-97  jeffort Added code to GetPalette to return a palette if the palette that
 *                      was set was not created with the same ddrawex object that the surface was
 *                      Added code to handle attaching surfaces that were created with different
 *                      ddrawex objects
 *   20-feb-98  stevela Added support for DX6 MMX rasterizers
 ***************************************************************************/
#include "ddfactry.h"
#include "d3d.h"

#define m_pDDSurface (m_DDSInt.m_pRealInterface)
#define m_pDDSurface2 (m_DDS2Int.m_pRealInterface)
#define m_pDDSurface3 (m_DDS3Int.m_pRealInterface)
#define m_pDDSurface4 (m_DDS4Int.m_pRealInterface)

#define DDSURFACETYPE_1 1
#define DDSURFACETYPE_2 2
#define DDSURFACETYPE_3 3
#define DDSURFACETYPE_4 4


typedef struct _ATTACHLIST
{
    DWORD 	dwFlags;
    struct _ATTACHLIST			FAR *lpLink; 	  // link to next attached surface
    struct _DDRAWI_DDRAWSURFACE_LCL	FAR *lpAttached;  // attached surface local obj
    struct _DDRAWI_DDRAWSURFACE_INT	FAR *lpIAttached; // attached surface interface
} ATTACHLIST;
typedef ATTACHLIST FAR *LPATTACHLIST;

#define DDAL_IMPLICIT 0x00000001l

/*
 * CDDSurface::CDDSurface
 *
 * Constructor for simple surface object
 */
CDDSurface::CDDSurface(
		DDSURFACEDESC *pSurfaceDesc,
		IDirectDrawSurface *pDDSurface,
		IDirectDrawSurface2 *pDDSurface2,
		IDirectDrawSurface3 *pDDSurface3,
                IDirectDrawSurface4 *pDDSurface4,
		IUnknown *pUnkOuter,
		CDirectDrawEx *pDirectDrawEx) :
    m_cRef(1),
    m_pUnkOuter(pUnkOuter != 0 ? pUnkOuter : CAST_TO_IUNKNOWN(this)),
    m_pDirectDrawEx(pDirectDrawEx),
    m_bOwnDC((pSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OWNDC) != 0),
    m_HDC(NULL)
{
    m_pDDSurface = pDDSurface;
    m_pDDSurface2 = pDDSurface2;
    m_pDDSurface3 = pDDSurface3;
    m_pDDSurface4 = pDDSurface4;
    m_DDSInt.m_pSimpleSurface = this;
    m_DDS2Int.m_pSimpleSurface = this;
    m_DDS3Int.m_pSimpleSurface = this;
    m_DDS4Int.m_pSimpleSurface = this;
    m_D3DDeviceRAMPInt = NULL;
    m_D3DDeviceRGBInt = NULL;
    m_D3DDeviceChrmInt = NULL;
    m_D3DDeviceHALInt = NULL;
    m_D3DDeviceMMXInt = NULL;
    m_D3DTextureInt = NULL;
    m_pCurrentPalette = NULL;
    m_pPrevPalette = NULL;
    m_pNextPalette = NULL;
    m_pSaveBits = NULL;
    m_bSaveDC = FALSE;
    m_pAttach = NULL;
    if (m_pDirectDrawEx->m_dwDDVer == WIN95_DX5 || m_pDirectDrawEx->m_dwDDVer == WINNT_DX5)
        InitSurfaceInterfaces( pDDSurface, &m_DDSInt, pDDSurface2, &m_DDS2Int, pDDSurface3, &m_DDS3Int, pDDSurface4, &m_DDS4Int );
    else
        InitSurfaceInterfaces( pDDSurface, &m_DDSInt, pDDSurface2, &m_DDS2Int, NULL, &m_DDS3Int, pDDSurface4, &m_DDS4Int );



    m_dwCaps = pSurfaceDesc->ddsCaps.dwCaps;
    m_hDCDib = NULL;
    m_hBMDib = NULL;
    m_pBitsDib = NULL;
    m_pDDPal = NULL;
    m_pDDPalOurs = NULL;
    m_bPrimaryPalette = FALSE;
    pDirectDrawEx->AddRef();
    pDirectDrawEx->AddSurfaceToList(this);
    //we want to know if this is the primary surface or not
    if (pSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
        m_bIsPrimary = TRUE;
    else
        m_bIsPrimary = FALSE;

    //if we created the DIBSection, and it is palettized, we need to add this to
    //the list of surfaces using the primary surface's palette
    if ( (m_bOwnDC && (pSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED1 ||
        pSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED2 ||
        pSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4 ||
        pSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)) || m_bIsPrimary)
    {
        pDirectDrawEx->AddSurfaceToPrimaryList(this);
    }
#ifdef DEBUG
    m_DebugCheckDC = NULL;
#endif
    DllAddRef();

} /* CDDSurface::CDDSurface */

/*
 * CDDSurface::MakeDibInfo
 *
 * create a dib info structure based on the surface desc + palette
 */
HRESULT CDDSurface::MakeDibInfo( LPDDSURFACEDESC pddsd, LPBITMAPINFO pbmi )
{
    DWORD                       bitcnt;

    /*
     * fill in basic values
     */
    pbmi->bmiHeader.biSize = sizeof( BITMAPINFOHEADER );
    pbmi->bmiHeader.biPlanes = 1;
    pbmi->bmiHeader.biSizeImage = 0;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrImportant = 0;

    bitcnt = pddsd->ddpfPixelFormat.dwRGBBitCount;
    pbmi->bmiHeader.biBitCount = (WORD) bitcnt;
    /*
     * fill out width, clrused, and compression fields based on bit depth
     */
    switch( bitcnt )
    {
      case 1:
        pbmi->bmiHeader.biWidth = pddsd->lPitch << 3;
        pbmi->bmiHeader.biClrUsed = 2;
        pbmi->bmiHeader.biCompression = BI_RGB;
        break;

      case 4:
        pbmi->bmiHeader.biWidth = pddsd->lPitch << 1;
        pbmi->bmiHeader.biClrUsed = 16;
        pbmi->bmiHeader.biCompression = BI_RGB;
        break;

      case 8:
        pbmi->bmiHeader.biWidth = pddsd->lPitch;
        if(pddsd->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
        {
            pbmi->bmiHeader.biClrUsed = 256;
            pbmi->bmiHeader.biCompression = BI_RGB;
        }
        else
        {
            pbmi->bmiHeader.biClrUsed = 0;
            pbmi->bmiHeader.biCompression = BI_BITFIELDS;
        }
        break;

      case 16:
        pbmi->bmiHeader.biWidth = pddsd->lPitch >> 1;
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biCompression = BI_BITFIELDS;
        break;


      case 24:
        // NOTE: we're assuming RGB format.  This is okay since we
        // don't do color conversion and neither does GDI at 24-bpp.
        pbmi->bmiHeader.biWidth = pddsd->lPitch / 3;
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biCompression = BI_RGB;
        break;

    case 32:
	pbmi->bmiHeader.biWidth = pddsd->lPitch >> 2;
	pbmi->bmiHeader.biClrUsed = 0;
	pbmi->bmiHeader.biCompression = BI_RGB;
	break;
    default:
    	{
	    char	str[256];
	    wsprintf( str, "bitcnt = %ld", bitcnt );
	    MessageBox( NULL, str, "WHAT THE HECK, PIXEL DEPTH IS BAD BAD BAD", MB_OK );
	}
    }

    /*
     * set the color masks if we need to...
     */
    if( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
    {
	DWORD	*p;
	p = (DWORD *) &pbmi->bmiColors[0];
	p[0] = pddsd->ddpfPixelFormat.dwRBitMask;
	p[1] = pddsd->ddpfPixelFormat.dwGBitMask;
	p[2] = pddsd->ddpfPixelFormat.dwBBitMask;
        //check for no masks.  Z-buffers don't have masks
        //so set a dummy value for this function call
        if (p[0] == 0 && p[1] == 0 && p[2] == 0){
            p[0]=0xF800;
            p[1]=0x07E0;
            p[2]=0x001F;
        }

	/*
	 * set the image size too
	 */
	pbmi->bmiHeader.biSizeImage = pddsd->lPitch * (int) pddsd->dwHeight;

    }

    /*
     * height is easy
     */
    pbmi->bmiHeader.biHeight= -1*(int)pddsd->dwHeight;
    /*
     * fill in the color table...
     */
    if( bitcnt <= 8 )
    {
	PALETTEENTRY		pe[256];
	int			i;
	LPDIRECTDRAWPALETTE	pddpal;
	HRESULT			hr;

	/*
	 * is there an attached palette?
	 */
	hr = m_pDDSurface->GetPalette( &pddpal );

	if( SUCCEEDED( hr ) )
	{
            //need to figure out how many entries are in here
            DWORD dwCaps;
            hr = pddpal->GetCaps(&dwCaps);
            if (SUCCEEDED(hr))
            {
                DWORD dwNumEntries;
                if (dwCaps & DDPCAPS_1BIT)
                    dwNumEntries = 1;
                else if (dwCaps & DDPCAPS_2BIT)
                    dwNumEntries = 4;
                else if (dwCaps & DDPCAPS_4BIT)
                    dwNumEntries = 16;
                else if (dwCaps & DDPCAPS_8BIT)
                    dwNumEntries = 256;
                else
                    dwNumEntries = 0;
    	        hr = pddpal->GetEntries( 0, 0, dwNumEntries, pe );
            }
	    pddpal->Release();
	}
        //if we created the DIBSection, and we are in EXCLUSIVE mode
        //then use the primary surface's palette if it exisits yet.
        else if (m_pDirectDrawEx->m_bExclusive)
        {
            //try and find the primary surface palette
            CDDPalette *pPal;

            pPal = m_pDirectDrawEx->m_pFirstPalette;
            while (pPal != NULL && pPal->m_bIsPrimary != TRUE)
                pPal = pPal->m_pNext;
            if (pPal != NULL)
            {
                DWORD dwCaps;
                hr = pPal->m_DDPInt.m_pRealInterface->GetCaps(&dwCaps);
                if (SUCCEEDED(hr))
                {
                    DWORD dwNumEntries;
                    if (dwCaps & DDPCAPS_1BIT)
                        dwNumEntries = 1;
                    else if (dwCaps & DDPCAPS_2BIT)
                        dwNumEntries = 4;
                    else if (dwCaps & DDPCAPS_4BIT)
                        dwNumEntries = 16;
                    else if (dwCaps & DDPCAPS_8BIT)
                        dwNumEntries = 256;
                    else
                        dwNumEntries = 0;
    	            hr = pPal->m_DDPInt.m_pRealInterface->GetEntries( 0, 0, dwNumEntries, pe );

                }
            }
        }

        /*
	 * nope, so use the system palette
	 */
	if( FAILED( hr ) )
	{
            HDC	hdc;
	    hdc = ::GetDC( NULL );
	    GetSystemPaletteEntries(hdc, 0, 256, pe);
	    ::ReleaseDC(NULL, hdc);
	}

	/*
	 * now copy the color table
	 */

        int iNumEntries;
        switch (bitcnt)
        {
        case 1:
            iNumEntries = 1;
            break;
        case 2:
            iNumEntries = 4;
            break;
        case 4:
            iNumEntries = 16;
            break;
        case 8:
            iNumEntries = 256;
            break;
        default:
            iNumEntries = 0;
            break;
        }

	for(i=0;i < iNumEntries;i++)
	{
	    pbmi->bmiColors[i].rgbRed = pe[i].peRed;
	    pbmi->bmiColors[i].rgbGreen = pe[i].peGreen;
	    pbmi->bmiColors[i].rgbBlue= pe[i].peBlue;
	}
    }

    return DD_OK;

} /* CDDSurface::MakeDibInfo */

/*
 * CDDSurface::MakeDIBSection()
 */
HRESULT CDDSurface::MakeDIBSection()
{
    DDSURFACEDESC	ddsd;
    DWORD		size;
    DWORD		bitcnt;
    LPBITMAPINFO	pbmi;

    /*
     * don't need to bother if the DirectDraw version isn't 3 or if it
     * isn't a system memory surface
     */
    #pragma message( REMIND( "Should we use a DIB unless the surface really is in video memory?" ))

    if( m_pDirectDrawEx->m_dwDDVer == WIN95_DX5 || m_pDirectDrawEx->m_dwDDVer == WINNT_DX5 || !(m_dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
 	return 1;
    }

    /*
     * so we need to make a dib section that is identical to this surface
     * first, get the surface desc
     */
    ddsd.dwSize = sizeof( ddsd );
    m_pDDSurface->GetSurfaceDesc( &ddsd );

    /*
     * allocate a pixel format structure
     */
    size = sizeof(BITMAPINFOHEADER);
    bitcnt = ddsd.ddpfPixelFormat.dwRGBBitCount;
    if( bitcnt <= 8)
    {
	size += (1<<bitcnt)*sizeof(RGBQUAD);
    }
    else
    {
	size += sizeof(DWORD)*3;
    }
    pbmi = (LPBITMAPINFO) LocalAlloc( LPTR, size );
    if( pbmi == NULL )
    {
	return DDERR_OUTOFMEMORY;
    }

    /*
     * flesh out the bitmap info header
     */
    MakeDibInfo( &ddsd, pbmi );

    /*
     * make the DIB section
     */
    m_hDCDib = CreateCompatibleDC(NULL);
    if( m_hDCDib != NULL )
    {
	m_hBMDib = CreateDIBSection(
		    m_hDCDib,	// the HDC
		    pbmi,		// bitmap info
		    DIB_RGB_COLORS,	// use color table in bitmap info
		    &m_pBitsDib,	// dib bits
		    NULL,		// no file handle
		    0 );		// offset into file (irrelevant)
        //free up our bitmap info struct
        LocalFree(pbmi);
	if( m_hBMDib == NULL )
	{
	    DeleteDC( m_hDCDib );
	    return DDERR_OUTOFMEMORY;
	}
	/*
	 * select our bitmap into our new DC
	 */
	m_hBMOld = (HBITMAP)SelectObject( m_hDCDib, (void *)m_hBMDib );
#ifdef DEBUG
        ASSERT(m_hBMOld != NULL);
#endif
    }
    else
    {
        //free up our local bitmap structure
        LocalFree(pbmi);
	return DDERR_OUTOFMEMORY;
    }

    return DD_OK;

} /* CDDSurface::MakeDIBSection */


HRESULT CDDSurface::SupportOwnDC()
{
    /*
     * if we want our own DC, then create one
     */
    HRESULT hr = DD_OK;
    if( m_bOwnDC )
    {
        HRESULT hrGotSurface, hrGotDC;
        IDirectDrawSurface *pTempSurface;
        HDC hdcTemp = NULL;

        /*
	 * Eat the cached HDC so owned DC surfaces won't use it.
	 */
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
	ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY;
	ddsd.dwHeight = ddsd.dwWidth = 1;
        hrGotSurface = m_pDirectDrawEx->m_DDInt.m_pRealInterface->CreateSurface(&ddsd, &pTempSurface, NULL);
        if( SUCCEEDED(hrGotSurface) )
	{
            hrGotDC = pTempSurface->GetDC(&hdcTemp);
        }

    	/*
	 * get the DC and then unlock the surface
	 * we know that GetDC does a Lock, so the Unlock will allow the
	 * DC to be used and Lock/Unlock to be used together...
	 */
	hr = m_pDDSurface->GetDC(&m_HDC);
	if( SUCCEEDED(hr) )
	{
	    m_pDDSurface->Unlock(NULL);
	}
	else
	{
	    m_bOwnDC = FALSE;	    // To prevent destructor from doing unlock trick
	    m_HDC = NULL;	    // Just to make sure...
	}
	/*
	 * clean up the extra surface/dc
	 */
        if( SUCCEEDED(hrGotSurface) )
	{
            if( SUCCEEDED(hrGotDC) )
	    {
                pTempSurface->ReleaseDC(hdcTemp);
            }
            pTempSurface->Release();
        }
    }
    return hr;
}//CDDSurface::SupportOwnDC


/*
 * CDDSurface::Init
 *
 * Initialize the surface
 */
HRESULT CDDSurface::Init()
{
    HRESULT hr = S_OK;

    hr = MakeDIBSection();
    if( FAILED( hr ) )
    {
	return hr;
    }

    /*
     * if we made the DIB section, then we need to tweak the internal
     * direct draw surface stucture (only allowed for direct draw 3)
     */
    if( hr == DD_OK )
    {
	LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
	psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) m_pDDSurface;
	/*
	 * mark the surface memory as freed, and replace the memory with
	 * our dib section memory
	 */
	psurf_int->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_MEMFREE;


        DWORD   dwOffset;
        LPVOID  lpMem;

        lpMem= (LPVOID) psurf_int->lpLcl->lpGbl->fpVidMem;
        //probably don't need this check, but it can't hurt
        if( NULL != lpMem )
        {
            if (m_pDirectDrawEx->m_dwDDVer != WINNT_DX2 && m_pDirectDrawEx->m_dwDDVer != WINNT_DX3)
            {
                //check to see if this surface has been aligned and reset the pointer if so
                if(psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER ||
                  psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE ||
                   psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN)
                {
                   dwOffset = *( (LPDWORD) ( ( (LPBYTE)lpMem ) - sizeof(DWORD) ) );
                   lpMem = (LPVOID) ( ( (LPBYTE) lpMem) - dwOffset );
                }
                //free the memory
                LocalFree(lpMem);
            }
            else
            {
                //store this value off so we can use it when we destroy the surface
                m_pSaveBits = (ULONG_PTR)lpMem;
                m_pSaveHDC = psurf_int->lpLcl->hDC;
                m_pSaveHBM = psurf_int->lpLcl->dwReserved1;
            }
        }
	psurf_int->lpLcl->lpGbl->fpVidMem = (ULONG_PTR) m_pBitsDib;
        return hr;
    }
    hr = SupportOwnDC();
    return hr;
} /* CDDSurface::Init */


void CDDSurface::CleanUpSurface()
{
    if( m_bOwnDC && m_HDC != NULL )
    {
	DDSURFACEDESC ddsd;
	ddsd.dwSize = sizeof(ddsd);
	m_pDDSurface->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);
    }	
    if( m_HDC != NULL )
    {
	m_pDDSurface->ReleaseDC(m_HDC);
    }
    if( m_hBMDib != NULL )
    {
	/* un-select our bitmap from the DC */
	SelectObject(m_hDCDib, m_hBMOld);
	DeleteObject( m_hBMDib );
    }
    if( m_hDCDib != NULL )
    {
	DeleteDC( m_hDCDib );
    }

    /*
     * clean up...
     */
    //if a palette is attached to this surface, detach it here
    if (m_pCurrentPalette != NULL)
        InternalSetPalette(NULL, 1);

    m_pDirectDrawEx->RemoveSurfaceFromList(this);
    if (m_pCurrentPalette)
        m_pCurrentPalette->RemoveSurfaceFromList(this);
    else if (m_bPrimaryPalette)
        m_pDirectDrawEx->RemoveSurfaceFromPrimaryList(this);
    //if we are running under NT4 Gold, we need to see if we modified the surface
    if ((m_pDirectDrawEx->m_dwDDVer == WINNT_DX2 || m_pDirectDrawEx->m_dwDDVer == WINNT_DX3) && m_pSaveBits != NULL)
    {
	LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
	psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) m_pDDSurface;

	psurf_int->lpLcl->lpGbl->dwGlobalFlags &= ~(DDRAWISURFGBL_MEMFREE);
 	psurf_int->lpLcl->lpGbl->fpVidMem = (FLATPTR) m_pSaveBits;
        psurf_int->lpLcl->hDC = m_pSaveHDC;
        psurf_int->lpLcl->dwReserved1 = m_pSaveHBM;
    }

}

void CDDSurface::ReleaseRealInterfaces()
{
    if( m_pDDSurface3 != NULL )
    {
   	m_pDDSurface3->Release();
    }
    m_pDDSurface2->Release();
    m_pDDSurface->Release();
    m_pDirectDrawEx->Release();

#ifdef DEBUG
    DWORD * ptr;
    ptr = (DWORD *)this;
    for (int i = 0; i < sizeof(CDDSurface) / sizeof(DWORD);i++)
        *ptr++ = 0xDEADBEEF;
#endif
    DllRelease();
}



void CDDSurface::AddSurfaceToDestroyList(CDDSurface * pSurface)
{
#ifdef DEBUG
    ASSERT(pSurface != NULL);
#endif

    ENTER_DDEX();
    if( m_pDestroyList )
    {
#ifdef DEBUG
        ASSERT(m_pDestroyList->m_pPrev == NULL);
#endif
	m_pDestroyList->m_pPrev = pSurface;
    }
    pSurface->m_pPrev = NULL;
    pSurface->m_pNext = m_pDestroyList;
    m_pDestroyList = pSurface;
    LEAVE_DDEX();
}

void CDDSurface::DeleteAttachment(IDirectDrawSurface * pOrigSurf, CDDSurface * pFirst)
{


    LPATTACHLIST lpAttach;
    IDirectDrawSurface * pSurface;
    CDDSurface * pSurfaceOuter;

    CleanUpSurface();
    //check for attached surface here
    lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(m_pDDSurface))->lpLcl->lpAttachList);
    pSurface = m_pDDSurface;
    while (lpAttach != NULL && pSurface != NULL)
    {
        if (lpAttach->dwFlags & DDAL_IMPLICIT)
        {
            lpAttach = lpAttach->lpLink;
            if (((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList)) != NULL)
                pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
            else
                pSurface = NULL;
            //scan our list of surfaces for the outer surface here
            pSurfaceOuter = m_pDirectDrawEx->m_pFirstSurface;
            while (pSurfaceOuter != NULL && pSurfaceOuter->m_DDSInt.m_pRealInterface != pSurface)
                pSurfaceOuter = pSurfaceOuter->m_pNext;
            if (pSurface != pOrigSurf && pSurfaceOuter != NULL){
                pSurfaceOuter->DeleteAttachment(pOrigSurf, pFirst);
                //and add this to our list to be deleted at the end
                pFirst->AddSurfaceToDestroyList(pSurfaceOuter);
            }
            else
                lpAttach = NULL;
        }
        else
        {
            lpAttach = lpAttach->lpLink;
            if (((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList)) != NULL)
                pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
            else
                pSurface = NULL;
            //scan our list of surfaces for the outer surface here
            pSurfaceOuter = m_pDirectDrawEx->m_pFirstSurface;
            while (pSurfaceOuter != NULL && pSurfaceOuter->m_DDSInt.m_pRealInterface != pSurface)
                pSurfaceOuter = pSurfaceOuter->m_pNext;
            if (pSurface != pOrigSurf && pSurfaceOuter != NULL){
                //when the release of the surface is done, it will do a Release on the real interface
                //of this surface, so we need to AddRef the real interface, but Release our interface here
                pSurface->AddRef();
                pSurfaceOuter->Release();

            }
        }
    }
    //we need to do the same thing for the m_pDDAttach list if it still remains
    //all of these surface were not found in the code above.  They are explicitly attached surfaces
    //that were not create with the same ddrawex object that this surface was created with
    while (m_pAttach != NULL)
    {
        DDAttachSurface * pDelete;

        pDelete = m_pAttach;
        m_pAttach = m_pAttach->pNext;
        pDelete->pSurface->m_DDSInt.m_pRealInterface->AddRef();
        pDelete->pSurface->Release();
        delete pDelete;
    }

    if( m_pDDSurface3 != NULL )
    {
   	m_pDDSurface3->Release();
    }
    HRESULT hr;
    hr = m_pDDSurface2->Release();
#ifdef DEBUG
    ASSERT(hr == 0);
#endif
    hr = m_pDDSurface->Release();
    m_pDirectDrawEx->Release();
    DllRelease();
}

/*
 * CDDSurface::~CDDSurface
*
 * Destructor
 */
CDDSurface::~CDDSurface()
{
    /*
     * if we have an OwnDC, then Lock the surface so ReleaseDC will work right...
     */

    LPATTACHLIST lpAttach;
    IDirectDrawSurface * pSurface;
    IDirectDrawSurface * pOrigSurf;
    CDDSurface * pSurfaceOuter;

    m_pDestroyList = NULL;
    CleanUpSurface();
    //check for attached surface here
    lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(m_pDDSurface))->lpLcl->lpAttachList);
    pOrigSurf = pSurface = m_pDDSurface;
    while (lpAttach != NULL && pSurface != NULL)
    {
        if (lpAttach->dwFlags & DDAL_IMPLICIT)
        {
            lpAttach = lpAttach->lpLink;
            if (((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList)) != NULL)
                pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
            else
                pSurface = NULL;
            //scan our list of surfaces for the outer surface here
            pSurfaceOuter = m_pDirectDrawEx->m_pFirstSurface;
            while (pSurfaceOuter != NULL && pSurfaceOuter->m_DDSInt.m_pRealInterface != pSurface)
                pSurfaceOuter = pSurfaceOuter->m_pNext;
            if (pSurface != pOrigSurf && pSurfaceOuter != NULL)
            {
                pSurfaceOuter->DeleteAttachment(pOrigSurf, this);
                AddSurfaceToDestroyList(pSurfaceOuter);
            }
            else
                lpAttach = NULL;
        }
        else
        {
            lpAttach = lpAttach->lpLink;
            if (((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList)) != NULL)
                pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
            else
                pSurface = NULL;
            //scan our list of surfaces for the outer surface here
            pSurfaceOuter = m_pDirectDrawEx->m_pFirstSurface;
            while (pSurfaceOuter != NULL && pSurfaceOuter->m_DDSInt.m_pRealInterface != pSurface)
                pSurfaceOuter = pSurfaceOuter->m_pNext;
            if (pSurface != pOrigSurf && pSurfaceOuter != NULL){
                //when the release of the surface is done, it will do a Release on the real interface
                //of this surface, so we need to AddRef the real interface, but Release our interface here
                pSurface->AddRef();
                pSurfaceOuter->Release();

            }
        }
    }
    //we need to do the same thing for the m_pDDAttach list if it still remains
    //all of these surface were not found in the code above.  They are explicitly attached surfaces
    //that were not create with the same ddrawex object that this surface was created with
    while (m_pAttach != NULL)
    {
        DDAttachSurface * pDelete;

        pDelete = m_pAttach;
        m_pAttach = m_pAttach->pNext;
        pDelete->pSurface->m_DDSInt.m_pRealInterface->AddRef();
        pDelete->pSurface->Release();
        delete pDelete;
    }

    if (m_pDDSurface4)
    {
        m_pDDSurface4->Release();
    }
    if( m_pDDSurface3 != NULL )
    {
   	m_pDDSurface3->Release();
    }
    HRESULT hr;

    hr = m_pDDSurface2->Release();
#ifdef DEBUG
    ASSERT(hr == 0);
#endif
    hr = m_pDDSurface->Release();
    //if we had implicit attached surface, we need to delete those here
    if (m_pDestroyList != NULL)
    {
        CDDSurface * pDelete;
        CDDSurface * pNext;
        pDelete = m_pDestroyList;
        while (pDelete != NULL)
        {
           pNext = pDelete->m_pNext;
#ifdef DEBUG
           DWORD * ptr;
           ptr = (DWORD *)pDelete;
           for (int i = 0; i < sizeof(CDDSurface) / sizeof(DWORD);i++)
                *ptr++ = 0xDEADBEEF;
#endif
           delete (void *)pDelete;
           pDelete = pNext;
        }
        m_pDestroyList = NULL;
    }
    m_pDirectDrawEx->Release();
#ifdef DEBUG
    DWORD * ptr;
    ptr = (DWORD *)this;
    for (int i = 0; i < sizeof(CDDSurface) / sizeof(DWORD);i++)
        *ptr++ = 0xDEADBEEF;
#endif
    DllRelease();

} /* CDDSurface::~CDDSurface */

/*
 * CDDSurface::CreateSimpleSurface
 *
 */
HRESULT CDDSurface::CreateSimpleSurface(
			LPDDSURFACEDESC pSurfaceDesc,
			IDirectDrawSurface *pDDSurface,
		        IDirectDrawSurface2 *pDDSurface2,
		        IDirectDrawSurface3 *pDDSurface3,
                        IDirectDrawSurface4 *pDDSurface4,
			IUnknown *pUnkOuter,
		        CDirectDrawEx *pDirectDrawEx,
			IDirectDrawSurface **ppNewDDSurf,
                        DWORD   dwFlags)
{
    HRESULT hr;
    CDDSurface *pSurface = new CDDSurface(pSurfaceDesc,
    					  pDDSurface,
					  pDDSurface2,
					  pDDSurface3,
                                          pDDSurface4,
					  pUnkOuter,
					  pDirectDrawEx);
    if( !pSurface)
    {
	return E_OUTOFMEMORY;
    }
    else
    {
        //If we are running DX5, we can turn of the m_bOwnDC if it is on
        if( pSurface->m_pDirectDrawEx->m_dwDDVer == WIN95_DX5 || pSurface->m_pDirectDrawEx->m_dwDDVer == WINNT_DX5)
        {
            pSurface->m_bOwnDC = FALSE;
            //if OWNDC is set, we need to store the DC around after a ReleasDC, check that here
            if (pSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OWNDC || ((pSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE))
                pSurface->m_bSaveDC = TRUE;
        }
        if ((pSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
            !(pSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
        {
            //we do not want to do this if we are running under WindowsNT4.0 gold
            //but we have to because of palette problems, so call for anything. . .
            if (pSurface->m_bOwnDC)
                hr = pSurface->Init();
            else
                hr = DD_OK;
        }
        else
            hr = DD_OK;
	if( SUCCEEDED(hr) )
	{
            pSurface->NonDelegatingQueryInterface(pUnkOuter ? IID_IUnknown : IID_IDirectDrawSurface, (void **)ppNewDDSurf);
        }
        //if creating our own_dc/dib section failed, then this will release the surface
        pSurface->NonDelegatingRelease();
    }
    return hr;
} /* CDDSurface::CreateSimpleSurface */



/*
 * CDDSurface::InternalGetDC
 *
 * Simple surface GetDC implementation
 */
HRESULT CDDSurface::InternalGetDC(HDC *pHDC)
{
    //palette handling was removed because we now wrap the palette functions and handle
    //setting the DIB Color table when SetEntries or SetPallette is called.
    //this will speed up the GetDc call signifigantly: JGO
    HRESULT hr = DD_OK;

    if (pHDC == NULL)
        return DDERR_INVALIDPARAMS;

    if( m_hDCDib )
    {
	*pHDC = m_hDCDib;
    }
    else if( m_bOwnDC )
    {
	*pHDC = m_HDC;
    }
    else
    {
	hr = m_pDDSurface->GetDC(pHDC);
        if (SUCCEEDED(hr))
            m_HDC = *pHDC;
    }
#ifdef DEBUG
    if ( m_DebugCheckDC)
    {
        //should we get the same DC?  We should if OWNDC is set or DATAEXCHANGE is set
        if (m_dwCaps & DDSCAPS_OWNDC || (m_dwCaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE)
            ASSERT((DWORD)*pHDC == m_DebugCheckDC);
    }
    m_DebugCheckDC = (DWORD)*pHDC;
#endif

    return hr;
} /* CDDSurface::InternalGetDC */

/*
 * CDDSurface::InternalReleaseDC
 *
 * Simple surface ReleaseDC implementation
 */
HRESULT CDDSurface::InternalReleaseDC(HDC hdc)
{

    HRESULT hr = DD_OK;

    /*
     * if we have a DIB section DC, do nothing
     */
    if( m_hDCDib != NULL )
    {
	if( hdc != m_hDCDib )
	{
	    hr = DDERR_INVALIDPARAMS;
	}
    }
    /*
     * if this is an OwnDC, do nothing
     */
    else if( m_bOwnDC )
    {
	if( hdc != m_HDC )
	{
	    hr = DDERR_INVALIDPARAMS;
	}
    }
    /*
     * allow ddraw to release the dc
     */
    else
    {
	hr = m_pDDSurface->ReleaseDC(hdc);
	if( SUCCEEDED(hr) )
	{
            if (!m_bSaveDC)
    	        m_HDC = NULL;
	}
    }
    return hr;

} /* CDDSurface::InternalReleaseDC */


/*
 * CDDSurface::InternalAddAttachedSurface
 *
 * Simple surface AddAttachedSurface implementation
 */
HRESULT CDDSurface::InternalFlip (LPDIRECTDRAWSURFACE lpDDS, DWORD dw, DWORD dwSurfaceType)
{
    HRESULT hr;

    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        INTSTRUC_IDirectDrawSurface *lpIDDS;
        lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
        if (lpIDDS == NULL)
            hr = m_pDDSurface->Flip(NULL, dw);
        else
            hr = m_pDDSurface->Flip(lpIDDS->m_pRealInterface, dw);
        break;
    case DDSURFACETYPE_2:
        INTSTRUC_IDirectDrawSurface2 *lpIDDS2;
        lpIDDS2 = ((INTSTRUC_IDirectDrawSurface2 *)(lpDDS));
        if (lpIDDS2 == NULL)
            hr = m_pDDSurface2->Flip(NULL, dw);
        else
            hr = m_pDDSurface2->Flip(lpIDDS2->m_pRealInterface, dw);
        break;
    case DDSURFACETYPE_3:
        INTSTRUC_IDirectDrawSurface3 *lpIDDS3;
        lpIDDS3 = ((INTSTRUC_IDirectDrawSurface3 *)(lpDDS));
        if (lpIDDS3 == NULL)
            hr = m_pDDSurface3->Flip(NULL, dw);
        else
            hr = m_pDDSurface3->Flip(lpIDDS3->m_pRealInterface, dw);
        break;
    case DDSURFACETYPE_4:
        INTSTRUC_IDirectDrawSurface4 *lpIDDS4;
        lpIDDS4 = ((INTSTRUC_IDirectDrawSurface4 *)(lpDDS));
        if (lpIDDS4 == NULL)
            hr = m_pDDSurface4->Flip(NULL, dw);
        else
            hr = m_pDDSurface4->Flip(lpIDDS4->m_pRealInterface, dw);
        break;
    }
    return hr;
}



HRESULT CDDSurface::InternalBlt (LPRECT lpRect1,LPDIRECTDRAWSURFACE lpDDS, LPRECT lpRect2,DWORD dw, LPDDBLTFX lpfx, DWORD dwSurfaceType)
{
    HRESULT hr;

    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        INTSTRUC_IDirectDrawSurface *lpIDDS;
        lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
        if (lpDDS != NULL)
           hr = m_pDDSurface->Blt(lpRect1, lpIDDS->m_pRealInterface, lpRect2,dw, lpfx);
        else
            hr = m_pDDSurface->Blt(lpRect1, NULL, lpRect2,dw, lpfx);
        break;
    case DDSURFACETYPE_2:
        INTSTRUC_IDirectDrawSurface2 *lpIDDS2;
        lpIDDS2 = ((INTSTRUC_IDirectDrawSurface2 *)(lpDDS));
        if (lpDDS != NULL)
           hr = m_pDDSurface2->Blt(lpRect1, lpIDDS2->m_pRealInterface, lpRect2,dw, lpfx);
        else
            hr = m_pDDSurface2->Blt(lpRect1, NULL, lpRect2,dw, lpfx);
        break;
    case DDSURFACETYPE_3:
       INTSTRUC_IDirectDrawSurface3 *lpIDDS3;
       lpIDDS3 = ((INTSTRUC_IDirectDrawSurface3 *)(lpDDS));
       if (lpDDS != NULL)
           hr = m_pDDSurface3->Blt(lpRect1, lpIDDS3->m_pRealInterface, lpRect2,dw, lpfx);
        else
            hr = m_pDDSurface3->Blt(lpRect1, NULL, lpRect2,dw, lpfx);
        break;
    case DDSURFACETYPE_4:
       INTSTRUC_IDirectDrawSurface4 *lpIDDS4;
       lpIDDS4 = ((INTSTRUC_IDirectDrawSurface4 *)(lpDDS));
       if (lpDDS != NULL)
           hr = m_pDDSurface4->Blt(lpRect1, lpIDDS4->m_pRealInterface, lpRect2,dw, lpfx);
        else
            hr = m_pDDSurface4->Blt(lpRect1, NULL, lpRect2,dw, lpfx);
        break;
    }
    return hr;
}



HRESULT CDDSurface::InternalAddAttachedSurface (LPDIRECTDRAWSURFACE lpDDS, DWORD dwSurfaceType)
{
    HRESULT hr;
    INTSTRUC_IDirectDrawSurface *lpIDDS;
    CDDSurface * pSurface;

    if (lpDDS == NULL)
        return DDERR_INVALIDPARAMS;

    lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
    pSurface = lpIDDS->m_pSimpleSurface;
    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        //make the call to the actual DDraw function
        hr = m_pDDSurface->AddAttachedSurface(pSurface->m_DDSInt.m_pRealInterface);
        break;
    case DDSURFACETYPE_2:
        hr = m_pDDSurface2->AddAttachedSurface(pSurface->m_DDS2Int.m_pRealInterface);
        break;
    case DDSURFACETYPE_3:
        hr = m_pDDSurface3->AddAttachedSurface(pSurface->m_DDS3Int.m_pRealInterface);
        break;
    case DDSURFACETYPE_4:
        hr = m_pDDSurface4->AddAttachedSurface(pSurface->m_DDS4Int.m_pRealInterface);
        break;
    }
    //if we succeeded we must do some fix up
    if (!FAILED( hr ) && lpDDS != NULL){
        //ddraw will addref the real interface
        //release that here, and addref our fake interface
        lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
        lpIDDS->m_pRealInterface->Release();
        ((INTSTRUC_IDirectDrawSurface *)(lpDDS))->m_pSimpleSurface->AddRef();
        //we need to make sure that this surface is in the ddrawex context of this surface,
        //if it is not, then we need to add it to a list
        if (m_pDirectDrawEx != lpIDDS->m_pSimpleSurface->m_pDirectDrawEx)
        {
            //this attached surface is not in the ddrawex object of this one, so add it to the attachlist
            DDAttachSurface * pAttList = new DDAttachSurface;
            if (pAttList == NULL)
                return DDERR_OUTOFMEMORY;
            //add this to the list of attached surfaces
            pAttList->pNext = m_pAttach;
            pAttList->pSurface = lpIDDS->m_pSimpleSurface;
            m_pAttach = pAttList;
        }
    }
    return hr;
}


void CDDSurface::DeleteAttachNode(CDDSurface * Surface)
{

    DDAttachSurface *pDelete;
    DDAttachSurface * pList = m_pAttach;
    //special case first in the list
    //ASSERT this!!
    if (pList != NULL)
    {
        if (pList->pSurface == Surface)
        {
            m_pAttach = m_pAttach->pNext;
            delete pList;
        }
        else
        {
            while (pList->pNext != NULL && (pList->pNext->pSurface != Surface))
            {
                pList = pList->pNext;
            }
#ifdef DEBUG
            ASSERT(pList->pNext != NULL);
#endif
            if (pList->pNext != NULL)
            {
                pDelete = pList->pNext;
                pList->pNext = pList->pNext->pNext;
                delete pDelete;
            }
        }
    }
}

HRESULT CDDSurface::InternalDeleteAttachedSurface (DWORD dwFlags, LPDIRECTDRAWSURFACE lpDDS, DWORD dwSurfaceType)
{
    HRESULT hr;
    INTSTRUC_IDirectDrawSurface *lpIDDS;
    CDDSurface * pCallSurface;
    ULONG_PTR * pSaveSurfaces;
    DWORD dwCount;


    pSaveSurfaces = NULL;
    if (lpDDS)
    {
        //just one attachment, addref the surface before it is released if it is not an
        //implicit attached surface
        lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
        lpIDDS->m_pRealInterface->AddRef();
    }
    else
    {
        LPATTACHLIST lpAttach;
        IDirectDrawSurface * pOrigSurf;
        CDDSurface * pSurfaceOuter;
        //all attached surfaces are going to be released, addref them here
        lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(m_pDDSurface))->lpLcl->lpAttachList);
        pOrigSurf = m_pDDSurface;
        dwCount = 0;
        while (lpAttach != NULL && (IDirectDrawSurface *)(lpAttach->lpIAttached) != pOrigSurf)
        {
            if (!(lpAttach->dwFlags & DDAL_IMPLICIT))
            {
                //we need to save these surfaces to be released later
                //so count how many we need in here
                dwCount++;
            }
            lpAttach = lpAttach->lpLink;
        }
        //we now need to save an array of surfaces to be Released if we succeed
        pSaveSurfaces = (ULONG_PTR *)LocalAlloc(LPTR, dwCount*sizeof(ULONG_PTR));
        if (pSaveSurfaces == NULL)
            return DDERR_OUTOFMEMORY;
        //now run the list again, call AddRef on the real interface, so that
        //the release called by ddraw will not affect anything
        //and save off the outer interfaces in our allocated array
        lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(m_pDDSurface))->lpLcl->lpAttachList);
        pOrigSurf = m_pDDSurface;
        dwCount = 0;
        while (lpAttach != NULL && (IDirectDrawSurface *)(lpAttach->lpIAttached) != pOrigSurf)
        {
            if (!(lpAttach->dwFlags & DDAL_IMPLICIT))
            {
                //we must addref the surface pointed to here
                ((IDirectDrawSurface *)(lpAttach->lpIAttached))->AddRef();
                pSurfaceOuter = m_pDirectDrawEx->m_pFirstSurface;
                while (pSurfaceOuter != NULL && pSurfaceOuter->m_DDSInt.m_pRealInterface != (IDirectDrawSurface *)(lpAttach->lpIAttached))
                    pSurfaceOuter = pSurfaceOuter->m_pNext;
                if (pSurfaceOuter != NULL)
                    pSaveSurfaces[dwCount++]= ((ULONG_PTR)(pSurfaceOuter));
            }
            lpAttach = lpAttach->lpLink;
        }
        //do the same addref for surfaces not in this ddrawex object
        DDAttachSurface * pList = m_pAttach;
        while (pList != NULL)
        {
            pList->pSurface->m_DDSInt.m_pRealInterface->AddRef();
            pList = pList->pNext;
        }
    }
    lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
    if (lpIDDS != NULL)
        pCallSurface = lpIDDS->m_pSimpleSurface;
    else
        pCallSurface = NULL;
    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        //make the call to the actual DDraw function
        if (pCallSurface != NULL)
            hr = m_pDDSurface->DeleteAttachedSurface(dwFlags, pCallSurface->m_DDSInt.m_pRealInterface);
        else
            hr = m_pDDSurface->DeleteAttachedSurface(dwFlags, NULL);
        break;
    case DDSURFACETYPE_2:
        if (pCallSurface != NULL)
            hr = m_pDDSurface2->DeleteAttachedSurface(dwFlags, pCallSurface->m_DDS2Int.m_pRealInterface);
        else
            hr = m_pDDSurface2->DeleteAttachedSurface(dwFlags, NULL);
        break;
    case DDSURFACETYPE_3:
        if (pCallSurface != NULL)
            hr = m_pDDSurface3->DeleteAttachedSurface(dwFlags, pCallSurface->m_DDS3Int.m_pRealInterface);
        else
            hr = m_pDDSurface3->DeleteAttachedSurface(dwFlags, NULL);
        break;
    case DDSURFACETYPE_4:
        if (pCallSurface != NULL)
            hr = m_pDDSurface4->DeleteAttachedSurface(dwFlags, pCallSurface->m_DDS4Int.m_pRealInterface);
        else
            hr = m_pDDSurface4->DeleteAttachedSurface(dwFlags, NULL);
        break;
    }
    //if we succeeded we must do some fix up
    if (SUCCEEDED( hr ))
    {
        if (lpDDS)
        {
            //just one attachment, release the outer surface here
            //if this is not in the same ddrawex object, then delete it from the list
            if (m_pDirectDrawEx != lpIDDS->m_pSimpleSurface->m_pDirectDrawEx)
            {
                DeleteAttachNode(lpIDDS->m_pSimpleSurface);
            }
            lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
            lpIDDS->m_pSimpleSurface->Release();

        }
        else
        {
            CDDSurface * pSurface;
            for ( DWORD i = 0; i < dwCount; i++)
            {
                pSurface = (CDDSurface *)(pSaveSurfaces[i]);
                pSurface->Release();
            }
            //do the same for any surfaces attached, not in this ddrawex object
            DDAttachSurface * pList = m_pAttach;
            while (m_pAttach != NULL)
            {
                pList = m_pAttach;
                m_pAttach = m_pAttach->pNext;
                pList->pSurface->Release();
                delete pList;
            }

        }
    }
    else
    {
        if (lpDDS)
        {
            //just one attachment, addref the surface before it is released if it is not an
            //implicit attached surface
            lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
            lpIDDS->m_pRealInterface->Release();
        }
        else
        {
            LPATTACHLIST lpAttach;
            IDirectDrawSurface * pOrigSurf;

            //all attached surfaces are going to be released, addref them here
            lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(m_pDDSurface))->lpLcl->lpAttachList);
            pOrigSurf = m_pDDSurface;
            while (lpAttach != NULL && (IDirectDrawSurface *)(lpAttach->lpIAttached) != pOrigSurf)
            {
                if (!(lpAttach->dwFlags & DDAL_IMPLICIT))
                {
                    //we must release the surface pointed to here that we addref'ed above
                    ((IDirectDrawSurface *)(lpAttach->lpIAttached))->Release();
                }
                lpAttach = lpAttach->lpLink;
            }
            //do the same for any surfaces attached, not in this ddrawex object
            DDAttachSurface * pList = m_pAttach;
            while (pList != NULL)
            {
                pList->pSurface->m_DDSInt.m_pRealInterface->Release();
                pList = pList->pNext;
            }
        }
    }
    if (pSaveSurfaces != NULL)
        LocalFree(pSaveSurfaces);
    return hr;
}




/*
 * CDDSurface::InternalGetAttachedSurface
 *
 * Simple surface GetAttachedSurface implementation
 */
HRESULT CDDSurface::InternalGetAttachedSurface(LPDDSCAPS lpDDSCaps, LPDIRECTDRAWSURFACE FAR * lpDDS, DWORD dwSurfaceType)
{

    HRESULT hr;
    INTSTRUC_IDirectDrawSurface* lpIDDS;
    DDSCAPS ddsCaps;

    if (lpDDS == NULL)
        return DDERR_INVALIDPARAMS;

    ddsCaps = *lpDDSCaps;
    //mask off owndc
    ddsCaps.dwCaps &= ~DDSCAPS_OWNDC;
    if ((ddsCaps.dwCaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE)
        ddsCaps.dwCaps &= ~DDSCAPS_DATAEXCHANGE;
    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        //make the call to the actual DDraw function
        hr = m_pDDSurface->GetAttachedSurface(&ddsCaps, lpDDS);
        break;
    case DDSURFACETYPE_2:
        hr = m_pDDSurface2->GetAttachedSurface(&ddsCaps, (LPDIRECTDRAWSURFACE2 *)lpDDS);
        break;
    case DDSURFACETYPE_3:
        hr = m_pDDSurface3->GetAttachedSurface(&ddsCaps, (LPDIRECTDRAWSURFACE3 *)lpDDS);
        break;
        // Case 4 taken care of below...
    }    //make the call to the actual DDraw function
    //if we succeeded we must do some fix up
    CDDSurface * lpSurfaceList;
    if (!FAILED( hr ) && lpDDS != NULL)
    {
         //we need to scan our list to pass back our interface
        lpSurfaceList = m_pDirectDrawEx->m_pFirstSurface;
        switch (dwSurfaceType)
        {
        case DDSURFACETYPE_1:
            while (lpSurfaceList != NULL && lpSurfaceList->m_DDSInt.m_pRealInterface != *lpDDS)
                lpSurfaceList = lpSurfaceList->m_pNext;
            if (lpSurfaceList == NULL)
            {
                //check our AttachList
                DDAttachSurface * pList = m_pAttach;
                while (pList != NULL && pList->pSurface->m_DDSInt.m_pRealInterface != *lpDDS)
                {
                   pList = pList->pNext;
                }
                if (pList != NULL)
                    lpSurfaceList = pList->pSurface;
            }
            if (lpSurfaceList != NULL)
                *lpDDS = (IDirectDrawSurface *)(&lpSurfaceList->m_DDSInt);
            break;
        case DDSURFACETYPE_2:
            while (lpSurfaceList != NULL && lpSurfaceList->m_DDS2Int.m_pRealInterface != (LPDIRECTDRAWSURFACE2)*lpDDS)
                lpSurfaceList = lpSurfaceList->m_pNext;
            if (lpSurfaceList == NULL)
            {
                //check our AttachList
                DDAttachSurface * pList = m_pAttach;
                while (pList != NULL && pList->pSurface->m_DDS2Int.m_pRealInterface != (LPDIRECTDRAWSURFACE2)*lpDDS)
                {
                   pList = pList->pNext;
                }
                if (pList != NULL)
                    lpSurfaceList = pList->pSurface;
            }

            if (lpSurfaceList != NULL)
                *lpDDS = (IDirectDrawSurface *)(&lpSurfaceList->m_DDS2Int);
            break;
        case DDSURFACETYPE_3:
            while (lpSurfaceList != NULL && lpSurfaceList->m_DDS3Int.m_pRealInterface != (LPDIRECTDRAWSURFACE3)*lpDDS)
                lpSurfaceList = lpSurfaceList->m_pNext;
            if (lpSurfaceList == NULL)
            {
                //check our AttachList
                DDAttachSurface * pList = m_pAttach;
                while (pList != NULL && pList->pSurface->m_DDS3Int.m_pRealInterface != (LPDIRECTDRAWSURFACE3)*lpDDS)
                {
                   pList = pList->pNext;
                }
                if (pList != NULL)
                    lpSurfaceList = pList->pSurface;
            }

            if (lpSurfaceList != NULL)
                *lpDDS = (IDirectDrawSurface *)(&lpSurfaceList->m_DDS3Int);
            break;
            // Case 4 taken care of below...
        }
        //ddraw will addref the obtained surface's real interface
        //release that here and addref our fake interface
        if (lpSurfaceList != NULL)
        {
            lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(*lpDDS));
            lpIDDS->m_pRealInterface->Release();
            ((INTSTRUC_IDirectDrawSurface *)(*lpDDS))->m_pSimpleSurface->AddRef();
        }
    }
    return hr;
}


HRESULT CDDSurface::InternalGetAttachedSurface4(LPDDSCAPS2 lpDDSCaps2, LPDIRECTDRAWSURFACE FAR * lpDDS)
{

    HRESULT hr;
    INTSTRUC_IDirectDrawSurface* lpIDDS;
    DDSCAPS2 ddsCaps2;

    if (lpDDS == NULL)
        return DDERR_INVALIDPARAMS;

    ddsCaps2 = *lpDDSCaps2;
    //mask off owndc
    ddsCaps2.dwCaps &= ~DDSCAPS_OWNDC;
    if ((ddsCaps2.dwCaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE)
        ddsCaps2.dwCaps &= ~DDSCAPS_DATAEXCHANGE;
    hr = m_pDDSurface4->GetAttachedSurface(&ddsCaps2, (LPDIRECTDRAWSURFACE4 *)lpDDS);

    //if we succeeded we must do some fix up
    CDDSurface * lpSurfaceList;
    if (!FAILED( hr ) && lpDDS != NULL)
    {
         //we need to scan our list to pass back our interface
        lpSurfaceList = m_pDirectDrawEx->m_pFirstSurface;
        while (lpSurfaceList != NULL && lpSurfaceList->m_DDS4Int.m_pRealInterface != (LPDIRECTDRAWSURFACE4)*lpDDS)
            lpSurfaceList = lpSurfaceList->m_pNext;
        if (lpSurfaceList == NULL)
        {
            //check our AttachList
            DDAttachSurface * pList = m_pAttach;
            while (pList != NULL && pList->pSurface->m_DDS4Int.m_pRealInterface != (LPDIRECTDRAWSURFACE4)*lpDDS)
            {
               pList = pList->pNext;
            }
            if (pList != NULL)
                lpSurfaceList = pList->pSurface;
        }

        //ddraw will addref the obtained surface's real interface
        //release that here and addref our fake interface
        if (lpSurfaceList != NULL)
        {
            *lpDDS = (IDirectDrawSurface *)(&lpSurfaceList->m_DDS4Int);
            lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(*lpDDS));
            lpIDDS->m_pRealInterface->Release();
            ((INTSTRUC_IDirectDrawSurface *)(*lpDDS))->m_pSimpleSurface->AddRef();
        }
    }
    return hr;
}


HRESULT CDDSurface::InternalGetPalette(LPDIRECTDRAWPALETTE FAR * ppPal, DWORD dwSurfaceType)
{
    HRESULT hr;

    if (ppPal == NULL)
        return DDERR_INVALIDPARAMS;

    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        //make the call to the actual DDraw function
        hr = m_pDDSurface->GetPalette(ppPal);
        break;
    case DDSURFACETYPE_2:
        hr = m_pDDSurface2->GetPalette(ppPal);
        break;
    case DDSURFACETYPE_3:
        hr = m_pDDSurface3->GetPalette(ppPal);
        break;
    case DDSURFACETYPE_4:
        hr = m_pDDSurface4->GetPalette(ppPal);
        break;
    }
    //if this succeeded, we need to return OUR interface to the palette, so scan our
    //list and return the correct palette.
    if (SUCCEEDED(hr))
    {
        INTSTRUC_IDirectDrawPalette* pIDDP;

         //we need to scan our list to pass back our interface
        CDDPalette * lpPaletteList;
        lpPaletteList = m_pDirectDrawEx->m_pFirstPalette;
        while (lpPaletteList != NULL && lpPaletteList->m_DDPInt.m_pRealInterface != *ppPal)
            lpPaletteList = lpPaletteList->m_pNext;
        if (lpPaletteList == NULL)
        {
            //this is a palette possibly, that is not in the same ddraw object as the surface
            // handle that here
            // TODO in the future, this code should be the default!

            //the returned palette should equal the real interface of the m_pCurrentPalette
#ifdef DEBUG
            ASSERT(m_pCurrentPalette != NULL);
            ASSERT(m_pCurrentPalette->m_DDPInt.m_pRealInterface == *ppPal);
#endif
            lpPaletteList = m_pCurrentPalette;
        }

        if (lpPaletteList != NULL)
        {
            *ppPal = (IDirectDrawPalette *)(&lpPaletteList->m_DDPInt);
            pIDDP = ((INTSTRUC_IDirectDrawPalette *)(*ppPal));
            pIDDP->m_pRealInterface->Release();
            pIDDP->m_pSimplePalette->AddRef();
        }
    }
    return hr;
}


HRESULT CDDSurface::InternalGetSurfaceDesc(LPDDSURFACEDESC pDesc, DWORD dwSurfaceType)
{
    HRESULT hr;

    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        hr = m_pDDSurface->GetSurfaceDesc(pDesc);
        break;
    case DDSURFACETYPE_2:
        hr = m_pDDSurface2->GetSurfaceDesc(pDesc);
        break;
    case DDSURFACETYPE_3:
        hr = m_pDDSurface3->GetSurfaceDesc(pDesc);
        break;
        // Case 4 handled below...
    }
    if (FAILED(hr))
        return hr;
    //if m_bOwnDC is set, we need to set this in the caps field
    if (m_dwCaps & DDSCAPS_OWNDC)
        //set the caps bit here
        pDesc->ddsCaps.dwCaps |= DDSCAPS_OWNDC;
    //see if data exchange was origianlly on
    if ((m_dwCaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE )
    {
        pDesc->ddsCaps.dwCaps |= DDSCAPS_DATAEXCHANGE;
        //see if OWNDC was really on
        if (!(m_dwCaps & DDSCAPS_OWNDC))
            //turn it off here
            pDesc->ddsCaps.dwCaps &= ~DDSCAPS_OWNDC;
        //see if offscreen plain was originally on
        if (m_dwCaps & DDSCAPS_OFFSCREENPLAIN)
            pDesc->ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
        //we might have turned on texture, turn it off if so
        if (!(m_dwCaps & DDSCAPS_TEXTURE))
            pDesc->ddsCaps.dwCaps &= ~DDSCAPS_TEXTURE;
    }


    return hr;
}


HRESULT CDDSurface::InternalGetSurfaceDesc4(LPDDSURFACEDESC2 pDesc2)
{
    HRESULT hr;

    hr = m_pDDSurface4->GetSurfaceDesc(pDesc2);
    if (FAILED(hr))
        return hr;
    //if m_bOwnDC is set, we need to set this in the caps field
    if (m_dwCaps & DDSCAPS_OWNDC)
        //set the caps bit here
        pDesc2->ddsCaps.dwCaps |= DDSCAPS_OWNDC;
    //see if data exchange was origianlly on
    if ((m_dwCaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE )
    {
        pDesc2->ddsCaps.dwCaps |= DDSCAPS_DATAEXCHANGE;
        //see if OWNDC was really on
        if (!(m_dwCaps & DDSCAPS_OWNDC))
            //turn it off here
            pDesc2->ddsCaps.dwCaps &= ~DDSCAPS_OWNDC;
        //see if offscreen plain was originally on
        if (m_dwCaps & DDSCAPS_OFFSCREENPLAIN)
            pDesc2->ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
        //we might have turned on texture, turn it off if so
        if (!(m_dwCaps & DDSCAPS_TEXTURE))
            pDesc2->ddsCaps.dwCaps &= ~DDSCAPS_TEXTURE;
    }


    return hr;
}


HRESULT CDDSurface::InternalSetPalette(LPDIRECTDRAWPALETTE pPal, DWORD dwSurfaceType)
{

    HRESULT hr;
    INTSTRUC_IDirectDrawPalette* pIDDP;


    pIDDP = ((INTSTRUC_IDirectDrawPalette *)(pPal));

    //a bit of ugliness herein regards to reference counting.  If this palette is
    //different from the current palette, then it will release the current palette.
    //we must protect for that before we call setpalette
    if (m_pCurrentPalette && (pPal == NULL || m_pCurrentPalette != pIDDP->m_pSimplePalette))
    {
        m_pCurrentPalette->m_DDPInt.m_pRealInterface->AddRef();
    }

    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        //make the call to the actual DDraw function
        if (pPal != NULL)
            hr = m_pDDSurface->SetPalette(pIDDP->m_pRealInterface);
        else
            hr = m_pDDSurface->SetPalette(NULL);
        break;
    case DDSURFACETYPE_2:
        if (pPal != NULL)
            hr = m_pDDSurface2->SetPalette(pIDDP->m_pRealInterface);
        else
            hr = m_pDDSurface2->SetPalette(NULL);
        break;
    case DDSURFACETYPE_3:
        if (pPal != NULL)
            hr = m_pDDSurface3->SetPalette(pIDDP->m_pRealInterface);
        else
            hr = m_pDDSurface3->SetPalette(NULL);
        break;
    case DDSURFACETYPE_4:
        if (pPal != NULL)
            hr = m_pDDSurface4->SetPalette(pIDDP->m_pRealInterface);
        else
            hr = m_pDDSurface4->SetPalette(NULL);
        break;
    }
    if (SUCCEEDED(hr))
    {
        //we must take care of reference counting here
        //if there was an old palette not equal to the current, then do a release on the old palette
        if (m_pCurrentPalette && (pPal == NULL || m_pCurrentPalette != pIDDP->m_pSimplePalette))
        {
            //release the old palette
            m_pCurrentPalette->Release();
            //if this release caused the palette to be destroyed, the palette destructor function
            //will change m_pCurrentPalette to NULL.  No worries below.
        }
        //if the new palette is NULL, we can return here
        if (pPal == NULL)
        {
            if (m_pCurrentPalette)
            {
                m_pCurrentPalette->RemoveSurfaceFromList(this);
                m_pCurrentPalette = NULL;
            }
            return hr;
        }
        //if the new palette is not equal to the old palette, then an addref was done on the
        //real interface, as above
        if (m_pCurrentPalette != pIDDP->m_pSimplePalette)
        {
            pIDDP->m_pRealInterface->Release();
            pIDDP->m_pSimplePalette->AddRef();
        }


        DWORD dwNumEntries;
        DWORD dwCaps;
        PALETTEENTRY    pe[256];
        hr = pIDDP->m_pRealInterface->GetCaps(&dwCaps);
        if (FAILED(hr))
            return hr;
        if (dwCaps & DDPCAPS_1BIT)
            dwNumEntries = 1;
        else if (dwCaps & DDPCAPS_2BIT)
            dwNumEntries = 4;
        else if (dwCaps & DDPCAPS_4BIT)
            dwNumEntries = 16;
        else if (dwCaps & DDPCAPS_8BIT)
            dwNumEntries = 256;
        else
            dwNumEntries = 0;
        hr = pIDDP->m_pRealInterface->GetEntries( 0, 0, dwNumEntries, pe);
        if (FAILED(hr))
            return hr;
        if (m_bIsPrimary)
        {
            CDDSurface *pSurface = m_pDirectDrawEx->m_pPrimaryPaletteList;
            while (pSurface != NULL)
            {
                //update the DIB COlor Table here
                pIDDP->m_pSimplePalette->SetColorTable(pSurface, pe, dwNumEntries, 0);
                pSurface = pSurface->m_pNextPalette;
            }
            //and mark this palette as being the primary
            pIDDP->m_pSimplePalette->m_bIsPrimary = TRUE;
            m_pCurrentPalette = pIDDP->m_pSimplePalette;
        }
        else
        {

            //if this surface already has a palette attached to it, then we need to remove it
            if (m_pCurrentPalette && m_pCurrentPalette != pIDDP->m_pSimplePalette)
                m_pCurrentPalette->RemoveSurfaceFromList(this);
            else if (m_bPrimaryPalette)
                //this surface will be in the list of surfaces which feed of the primary surface
                //remove it from that list
                m_pDirectDrawEx->RemoveSurfaceFromPrimaryList(this);

            //now add this surface to the palette list if already is not in the list
            if (m_pCurrentPalette != pIDDP->m_pSimplePalette)
                pIDDP->m_pSimplePalette->AddSurfaceToList(this);
            //and update this surface's DIB ColorTable
            pIDDP->m_pSimplePalette->SetColorTable(this, pe, dwNumEntries, 0);
            pIDDP->m_pSimplePalette->m_bIsPrimary = FALSE;
            m_pCurrentPalette = pIDDP->m_pSimplePalette;
        }
    }
    return hr;
}


#pragma message( REMIND( "What Lock of a rect bug in DirectDraw v3 is Ralph referring to?" ))

/*
 * CDDSurface::InternalLock
 *
 * Simple surface Lock implementation
 */
HRESULT CDDSurface::InternalLock(LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent)
{

    return m_pDDSurface->Lock(lpDestRect, lpDDSurfaceDesc, dwFlags, hEvent);

} /* CDDSurface::InternalLock */

/*
 * CDDSurface::InternalUnlock
 *
 * Simple surface Unlock implementation
 */
HRESULT CDDSurface::InternalUnlock(LPVOID lpSurfaceData)
{
    return m_pDDSurface->Unlock(lpSurfaceData);

} /* CDDSurface::InternalUnlock */

#define DEFINEPF(flags, fourcc, bpp, rMask, gMask, bMask, aMask) \
    { sizeof(DDPIXELFORMAT), (flags), (fourcc), (bpp), (rMask), (gMask), (bMask), (aMask) }

static DDPIXELFORMAT ddpfSupportedTexPFs[] =
{
/*           Type                              FOURCC BPP   Red Mask      Green Mask    Blue Mask     Alpha Mask                   */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED1,  0UL,    1UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED1 |
             DDPF_PALETTEINDEXEDTO8,           0UL,    1UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED2,  0UL,    2UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED2 |
             DDPF_PALETTEINDEXEDTO8,           0UL,    2UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED4,  0UL,    4UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED4 |
             DDPF_PALETTEINDEXEDTO8,           0UL,    4UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED8,  0UL,    8UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB,                         0UL,    8UL, 0x000000E0UL, 0x0000001CUL, 0x00000003UL, 0x00000000UL), /*  332 (RGB) */
    DEFINEPF(DDPF_RGB | DDPF_ALPHAPIXELS,      0UL,   16UL, 0x00000F00UL, 0x000000F0UL, 0x0000000FUL, 0x0000F000UL), /* 4444 (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   16UL, 0x0000F800UL, 0x000007E0UL, 0x0000001FUL, 0x00000000UL), /*  565 (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   16UL, 0x0000001FUL, 0x000007E0UL, 0x0000F800UL, 0x00000000UL), /*  565 (BGR) */
    DEFINEPF(DDPF_RGB,                         0UL,   16UL, 0x00007C00UL, 0x000003E0UL, 0x0000001FUL, 0x00000000UL), /*  555 (RGB) */
    DEFINEPF(DDPF_RGB | DDPF_ALPHAPIXELS,      0UL,   16UL, 0x00007C00UL, 0x000003E0UL, 0x0000001FUL, 0x00008000UL), /* 1555 (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   24UL, 0x00FF0000UL, 0x0000FF00UL, 0x000000FFUL, 0x00000000UL), /*  FFF (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   24UL, 0x000000FFUL, 0x0000FF00UL, 0x00FF0000UL, 0x00000000UL), /*  FFF (BGR) */
    DEFINEPF(DDPF_RGB,                         0UL,   32UL, 0x00FF0000UL, 0x0000FF00UL, 0x000000FFUL, 0x00000000UL), /* 0FFF (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   32UL, 0x000000FFUL, 0x0000FF00UL, 0x00FF0000UL, 0x00000000UL), /* 0FFF (BGR) */
    DEFINEPF(DDPF_RGB | DDPF_ALPHAPIXELS,      0UL,   32UL, 0x00FF0000UL, 0x0000FF00UL, 0x000000FFUL, 0xFF000000UL), /* FFFF (RGB) */
    DEFINEPF(DDPF_RGB | DDPF_ALPHAPIXELS,      0UL,   32UL, 0x000000FFUL, 0x0000FF00UL, 0x00FF0000UL, 0xFF000000UL)  /* FFFF (BGR) */
};
#define NUM_SUPPORTED_TEX_PFS (sizeof(ddpfSupportedTexPFs) / sizeof(ddpfSupportedTexPFs[0]))

static DDPIXELFORMAT ddpfSupportedOffScrnPFs[] =
{
/*           Type                              FOURCC BPP   Red Mask      Green Mask    Blue Mask     Alpha Mask                   */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED1,  0UL,    1UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED2,  0UL,    2UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED4,  0UL,    4UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED8,  0UL,    8UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB,                         0UL,   16UL, 0x0000F800UL, 0x000007E0UL, 0x0000001FUL, 0x00000000UL), /*  565 (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   16UL, 0x00007C00UL, 0x000003E0UL, 0x0000001FUL, 0x00000000UL), /*  555 (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   24UL, 0x00FF0000UL, 0x0000FF00UL, 0x000000FFUL, 0x00000000UL), /*  FFF (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   24UL, 0x000000FFUL, 0x0000FF00UL, 0x00FF0000UL, 0x00000000UL), /*  FFF (BGR) */
    DEFINEPF(DDPF_RGB,                         0UL,   32UL, 0x00FF0000UL, 0x0000FF00UL, 0x000000FFUL, 0x00000000UL), /* 0FFF (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   32UL, 0x000000FFUL, 0x0000FF00UL, 0x00FF0000UL, 0x00000000UL), /* 0FFF (BGR) */
};
#define NUM_SUPPORTED_OFFSCRN_PFS (sizeof(ddpfSupportedOffScrnPFs) / sizeof(ddpfSupportedOffScrnPFs[0]))

/*
 * doPixelFormatsMatch
 */
BOOL doPixelFormatsMatch(LPDDPIXELFORMAT lpddpf1, LPDDPIXELFORMAT lpddpf2)
{

    if( lpddpf1->dwFlags != lpddpf2->dwFlags )
    {
        return FALSE;
    }

    if( lpddpf1->dwFlags & DDPF_RGB )
    {
    	if( lpddpf1->dwRGBBitCount != lpddpf2->dwRGBBitCount )
	{
            return FALSE;
	}
    	if( lpddpf1->dwRBitMask != lpddpf2->dwRBitMask )
	{
	    return FALSE;
	}
    	if( lpddpf1->dwGBitMask != lpddpf2->dwGBitMask )
	{
	    return FALSE;
	}
    	if( lpddpf1->dwBBitMask != lpddpf2->dwBBitMask )
	{
	    return FALSE;
	}
    	if( lpddpf1->dwFlags & DDPF_ALPHAPIXELS )
    	{
    	    if( lpddpf1->dwRGBAlphaBitMask != lpddpf2->dwRGBAlphaBitMask )
	    {
	    	return FALSE;
	    }
    	}
    }
    else if( lpddpf1->dwFlags & DDPF_YUV )
    {
        /*
         * (CMcC) Yes, I know that all these fields are in a
         * union with the RGB ones so I could just use the same
         * bit of checking code but just in case someone messes
         * with DDPIXELFORMAT I'm going to do this explicitly.
         */
        if( lpddpf1->dwFourCC != lpddpf2->dwFourCC )
	{
            return FALSE;
	}
    	if( lpddpf1->dwYUVBitCount != lpddpf2->dwYUVBitCount )
	{
            return FALSE;
	}
    	if( lpddpf1->dwYBitMask != lpddpf2->dwYBitMask )
	{
	    return FALSE;
	}
    	if( lpddpf1->dwUBitMask != lpddpf2->dwUBitMask )
	{
	    return FALSE;
	}
    	if( lpddpf1->dwVBitMask != lpddpf2->dwVBitMask )
	{
	    return FALSE;
	}
    	if( lpddpf1->dwFlags & DDPF_ALPHAPIXELS )
    	{
    	    if( lpddpf1->dwYUVAlphaBitMask != lpddpf2->dwYUVAlphaBitMask )
	    {
	    	return FALSE;
	    }
    	}
    }
    return TRUE;

} /* doPixelFormatsMatch */

/*
 * isSupportedPixelFormat
 */
BOOL isSupportedPixelFormat(LPDDPIXELFORMAT lpddpf,
			    LPDDPIXELFORMAT lpddpfTable,
			    int             cNumEntries)
{
    int 		n;
    LPDDPIXELFORMAT	lpddCandidatePF;

    n = cNumEntries;
    lpddCandidatePF = lpddpfTable;
    while( n > 0 )
    {
    	if( doPixelFormatsMatch(lpddpf, lpddCandidatePF) )
	{
	    return TRUE;
	}
	lpddCandidatePF++;
	n--;
    }
    return FALSE;

} /* isSupportedPixelFormat */

/*
 * checkPixelFormat
 *    bitdepth != screen bitdepth
 */
HRESULT checkPixelFormat( DWORD dwscaps, LPDDPIXELFORMAT lpDDPixelFormat )
{

    if( dwscaps & DDSCAPS_TEXTURE )
    {
	if( !isSupportedPixelFormat(lpDDPixelFormat, ddpfSupportedTexPFs, NUM_SUPPORTED_TEX_PFS) )
	{
            return DDERR_INVALIDPIXELFORMAT;
	}
    }
    else if( dwscaps & DDSCAPS_OFFSCREENPLAIN )
    {
	if( !isSupportedPixelFormat(lpDDPixelFormat, ddpfSupportedOffScrnPFs, NUM_SUPPORTED_OFFSCRN_PFS) )
	{

            return DDERR_INVALIDPIXELFORMAT;
	}
    }
    return DD_OK;

} /* checkPixelFormat */

/*
 * CDDSurface::InternalSetSurfaceDesc
 *
 * Simple surface change the bits
 */
HRESULT CDDSurface::InternalSetSurfaceDesc(
		    LPDDSURFACEDESC pddsd,
		    DWORD dwFlags)
{
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf_gbl;
    DWORD			sdflags;

    if( dwFlags )
    {
	return DDERR_INVALIDPARAMS;
    }

    //do not work on DDraw2 on WindowsNT4.0Gold
    if (m_pDirectDrawEx->m_dwDDVer == WINNT_DX2)
    {
        return DDERR_UNSUPPORTED;
    }

    psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) m_pDDSurface;
    psurf_lcl = psurf_int->lpLcl;
    psurf_gbl = psurf_lcl->lpGbl;

    sdflags = pddsd->dwFlags;

    /*
     * don't allow anything but bits, height, width, pitch, and pixel format
     * to change
     */
    if( !(sdflags & (DDSD_LPSURFACE | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_PITCH )) )
    {
	return DDERR_INVALIDPARAMS;
    }

    /*
     * don't work if it wasn't put in sysmem in the first place...
     */
    if( !(psurf_gbl->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED ) )
    {
	return DDERR_UNSUPPORTED;
    }

    /*
     * gotta have a pixel format to work...
     */
    if( !(psurf_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
    	 (sdflags & DDSD_PIXELFORMAT) )
    {
	return DDERR_INVALIDSURFACETYPE;
    }

    /*
     * verify the new pixel format...
     */
    if( sdflags & DDSD_PIXELFORMAT )
    {
	DWORD	dwscaps;
	HRESULT	hr;

	/*
	 * only allow changes for textures and offscreen plain...
	 */
	dwscaps = psurf_lcl->ddsCaps.dwCaps;
	if( !(dwscaps & (DDSCAPS_TEXTURE|DDSCAPS_OFFSCREENPLAIN)) )
	{
	    return DDERR_INVALIDSURFACETYPE;
	}

	hr = checkPixelFormat( dwscaps, &pddsd->ddpfPixelFormat );
	if( FAILED( hr ) )
	{
	    return hr;
	}
    }

    /*
     * replace bits ptr...
     */
    if( sdflags & DDSD_LPSURFACE )
    {
	/*
	 * mark the surface memory as freed, and replace the memory with
	 * new user specified memory
	 */
	if( !(psurf_gbl->dwGlobalFlags & DDRAWISURFGBL_MEMFREE ) )
	{

	    DWORD   dwOffset;
	    LPVOID  lpMem;

	    lpMem= (LPVOID) psurf_int->lpLcl->lpGbl->fpVidMem;
	    //probably don't need this check, but it can't hurt
	    if( NULL != lpMem )
	    {
                if (m_pDirectDrawEx->m_dwDDVer != WINNT_DX3)
                {
                    //check to see if this surface has been aligned and reset the pointer if so
                    if(psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER ||
                      psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE ||
                       psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN)
                    {
                       dwOffset = *( (LPDWORD) ( ( (LPBYTE)lpMem ) - sizeof(DWORD) ) );
                       lpMem = (LPVOID) ( ( (LPBYTE) lpMem) - dwOffset );
                    }
                    //free the memory
                    LocalFree(lpMem);
                }
                else
                {
                    //store this value off so we can use it when we destroy the surface
                    m_pSaveBits = (ULONG_PTR)lpMem;
                    m_pSaveHDC = psurf_int->lpLcl->hDC;
                    m_pSaveHBM = psurf_int->lpLcl->dwReserved1;
                }
            }
            psurf_gbl->dwGlobalFlags |= DDRAWISURFGBL_MEMFREE;
	}
	psurf_gbl->fpVidMem = (ULONG_PTR) pddsd->lpSurface;
    }

    /*
     * replace other things
     */
    if( sdflags & DDSD_PITCH )
    {
	psurf_gbl->lPitch = pddsd->lPitch;
    }
    if( sdflags & DDSD_WIDTH )
    {
	psurf_gbl->wWidth = (WORD) pddsd->dwWidth;
    }
    if( sdflags & DDSD_HEIGHT )
    {
	psurf_gbl->wHeight = (WORD) pddsd->dwHeight;
    }
    if( sdflags & DDSD_PIXELFORMAT )
    {
	psurf_gbl->ddpfSurface = pddsd->ddpfPixelFormat;
    }
    return DD_OK;

} /* CDDSurface::InternalSetBites */


HRESULT CDDSurface::InternalGetDDInterface(LPVOID FAR *ppInt)
{
    //this is a simple function, simply addref on the m_pDirectDrawEx and return it's simple interface
    return m_pDirectDrawEx->QueryInterface(IID_IDirectDraw, ppInt);
}


/*
 * CDDSurface::QueryInterface
 *                AddRef
 *                Release
 *
 * The standard IUnknown that delegates...
 */
STDMETHODIMP CDDSurface::QueryInterface(REFIID riid, void ** ppv)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);

} /* CDirectDrawEx::QueryInterface */

STDMETHODIMP_(ULONG) CDDSurface::AddRef(void)
{
    return m_pUnkOuter->AddRef();

} /* CDirectDrawEx::AddRef */

STDMETHODIMP_(ULONG) CDDSurface::Release(void)
{
    return m_pUnkOuter->Release();

} /* CDirectDrawEx::Release */

/*
 * NonDelegating IUnknown for simple surface follows...
 */

STDMETHODIMP CDDSurface::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr;

    if (ppv == NULL)
        return E_POINTER;
    *ppv=NULL;

    if( IID_IUnknown==riid )
    {
        *ppv=(INonDelegatingUnknown *)this;
    }
    else if( IID_IDirectDrawSurface==riid )
    {
	*ppv=&m_DDSInt;
    }
    else if( IID_IDirectDrawSurface2==riid )
    {
	*ppv=&m_DDS2Int;
    }
    else if( IID_IDirectDrawSurface3==riid )
    {
	*ppv=&m_DDS3Int;
    }
    else if (IID_IDirectDrawSurface4==riid )
    {
	if (m_DDS4Int.lpVtbl)
	{
            *ppv=&m_DDS4Int;
	}
	else
	{
	    return (E_NOINTERFACE);
	}
    }
    else if (IID_IDirect3DRampDevice == riid)
    {
//#ifdef DBG
//        hr = DDERR_LEGACYUSAGE;
//#else
        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDDSurface;
        hr = lpFunc(&(m_DDSInt.lpVtbl), riid, (void **)&m_D3DDeviceRAMPInt);
        if( SUCCEEDED(hr) )
        {
            *ppv=m_D3DDeviceRAMPInt;
        }
        else
            *ppv = NULL;
//#endif
        return hr;

    }
    else if (IID_IDirect3DRGBDevice == riid)
    {
//#ifdef DBG
//        hr = DDERR_LEGACYUSAGE;
//#else
        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDDSurface;
        hr = lpFunc(&(m_DDSInt.lpVtbl), riid, (void **)&m_D3DDeviceRGBInt);
        if( SUCCEEDED(hr) )
        {
            *ppv=m_D3DDeviceRGBInt;
        }
        else
            *ppv = NULL;
//#endif
        return hr;

    }
    else if (IID_IDirect3DChrmDevice == riid)
    {
//#ifdef DBG
//        hr = DDERR_LEGACYUSAGE;
//#else
        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDDSurface;
        hr = lpFunc(&(m_DDSInt.lpVtbl), riid, (void **)&m_D3DDeviceChrmInt);
        if( SUCCEEDED(hr) )
        {
            *ppv=m_D3DDeviceChrmInt;
        }
        else
            *ppv = NULL;
//#endif
        return hr;

    }
    else if(IID_IDirect3DHALDevice == riid)
    {
//#ifdef DBG
//        hr = DDERR_LEGACYUSAGE;
//#else
        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDDSurface;
        hr = lpFunc(&(m_DDSInt.lpVtbl), riid, (void **)&m_D3DDeviceHALInt);
        if( SUCCEEDED(hr) )
        {
            *ppv=m_D3DDeviceHALInt;
        }
        else
            *ppv = NULL;
//#endif
        return hr;
    }
    else if(IID_IDirect3DMMXDevice == riid)
    {
//#ifdef DBG
//        hr = DDERR_LEGACYUSAGE;
//#else
        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDDSurface;
        hr = lpFunc(&(m_DDSInt.lpVtbl), riid, (void **)&m_D3DDeviceMMXInt);
        if( SUCCEEDED(hr) )
        {
            *ppv=m_D3DDeviceMMXInt;
        }
        else
            *ppv = NULL;
//#endif
        return hr;
    }
    else if (IID_IDirect3DTexture == riid)
    {
        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDDSurface;
        hr = lpFunc(&(m_DDSInt.lpVtbl), riid, (void **)&m_D3DTextureInt);
        if( SUCCEEDED(hr) )
        {
     	    *ppv=m_D3DTextureInt;
        }
        else
            *ppv = NULL;
        return hr;

    }
    else
    {
	   return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CDDSurface::NonDelegatingAddRef()
{
    m_pDDSurface->AddRef();
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDDSurface::NonDelegatingRelease()
{
    LONG lRefCount = InterlockedDecrement(&m_cRef);
    if (lRefCount) {
        m_pDDSurface->Release();
        return lRefCount;
    }
    delete this;
    return 0;
}

/*
 * Quick inline fns to get at our internal data...
 */
_inline CDDSurface * SURFACEOF(IDirectDrawSurface * pDDS)
{
    return ((INTSTRUC_IDirectDrawSurface *)pDDS)->m_pSimpleSurface;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface2 * pDDS2)
{
    return ((INTSTRUC_IDirectDrawSurface2 *)pDDS2)->m_pSimpleSurface;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface3 * pDDS3)
{
    return ((INTSTRUC_IDirectDrawSurface3 *)pDDS3)->m_pSimpleSurface;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface4 * pDDS4)
{
    return ((INTSTRUC_IDirectDrawSurface4 *)pDDS4)->m_pSimpleSurface;
}


/*
 * the implementation of the functions in IDirectDrawSurface that we are
 * overriding (IUnknown and GetDC, ReleaseDC, Lock, Unlock)
 */
STDMETHODIMP_(ULONG) IDirectDrawSurfaceAggAddRef(IDirectDrawSurface *pDDS)
{
    return SURFACEOF(pDDS)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDrawSurfaceAggRelease(IDirectDrawSurface *pDDS)
{
    return SURFACEOF(pDDS)->m_pUnkOuter->Release();
}


STDMETHODIMP IDirectDrawSurfaceAggGetDC(IDirectDrawSurface *pDDS, HDC * pHDC)
{
    return SURFACEOF(pDDS)->InternalGetDC(pHDC);
}


STDMETHODIMP IDirectDrawSurfaceAggGetAttachedSurface(IDirectDrawSurface *pDDS, LPDDSCAPS lpDDSCaps, LPDIRECTDRAWSURFACE FAR * lpDDS)
{
    return SURFACEOF(pDDS)->InternalGetAttachedSurface(lpDDSCaps, lpDDS, DDSURFACETYPE_1);
}

STDMETHODIMP IDirectDrawSurfaceAggAddAttachedSurface(IDirectDrawSurface *pDDS, LPDIRECTDRAWSURFACE lpDDS)
{
    return SURFACEOF(pDDS)->InternalAddAttachedSurface(lpDDS, DDSURFACETYPE_1);
}

STDMETHODIMP IDirectDrawSurfaceAggDeleteAttachedSurface(IDirectDrawSurface *pDDS, DWORD dwFlags, LPDIRECTDRAWSURFACE lpDDS)
{
    return SURFACEOF(pDDS)->InternalDeleteAttachedSurface(dwFlags, lpDDS, DDSURFACETYPE_1);
}


STDMETHODIMP IDirectDrawSurfaceAggReleaseDC(IDirectDrawSurface *pDDS, HDC hdc)
{
    return SURFACEOF(pDDS)->InternalReleaseDC(hdc);
}


STDMETHODIMP IDirectDrawSurfaceAggLock(IDirectDrawSurface *pDDS, LPRECT lpDestRect,
				       LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent)
{
    return SURFACEOF(pDDS)->InternalLock(lpDestRect, lpDDSurfaceDesc, dwFlags, hEvent);
}

STDMETHODIMP IDirectDrawSurfaceAggUnlock(IDirectDrawSurface *pDDS, LPVOID lpSurfaceData)
{
    return SURFACEOF(pDDS)->InternalUnlock(lpSurfaceData);
}

STDMETHODIMP IDirectDrawSurfaceAggFlip(IDirectDrawSurface *pDDS, LPDIRECTDRAWSURFACE lpSurf, DWORD dw)
{
    return SURFACEOF(pDDS)->InternalFlip(lpSurf, dw, DDSURFACETYPE_1);
}

STDMETHODIMP IDirectDrawSurfaceAggBlt(IDirectDrawSurface *pDDS, LPRECT lpRect1,LPDIRECTDRAWSURFACE lpDDS, LPRECT lpRect2,DWORD dw, LPDDBLTFX lpfx)
{
    return SURFACEOF(pDDS)->InternalBlt(lpRect1, lpDDS, lpRect2, dw, lpfx, DDSURFACETYPE_1);
}

STDMETHODIMP IDirectDrawSurfaceAggGetPalette(IDirectDrawSurface *pDDS, LPDIRECTDRAWPALETTE FAR * ppPal)
{
    return SURFACEOF(pDDS)->InternalGetPalette(ppPal, DDSURFACETYPE_1);
}

STDMETHODIMP IDirectDrawSurfaceAggSetPalette(IDirectDrawSurface *pDDS, LPDIRECTDRAWPALETTE pPal)
{
    return SURFACEOF(pDDS)->InternalSetPalette(pPal, DDSURFACETYPE_1);
}

STDMETHODIMP IDirectDrawSurfaceAggGetSurfaceDesc(IDirectDrawSurface *pDDS, LPDDSURFACEDESC lpDesc)
{
    return SURFACEOF(pDDS)->InternalGetSurfaceDesc(lpDesc, DDSURFACETYPE_1);
}



/*
 * the implementation of the functions in IDirectDrawSurface2 that we are
 * overriding (IUnknown and GetDC, ReleaseDC, Lock, Unlock)
 */
STDMETHODIMP_(ULONG) IDirectDrawSurface2AggAddRef(IDirectDrawSurface2 *pDDS2)
{
    return SURFACEOF(pDDS2)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDrawSurface2AggRelease(IDirectDrawSurface2 *pDDS2)
{
    return SURFACEOF(pDDS2)->m_pUnkOuter->Release();
}


STDMETHODIMP IDirectDrawSurface2AggGetDC(IDirectDrawSurface2 *pDDS2, HDC * pHDC)
{
    return SURFACEOF(pDDS2)->InternalGetDC(pHDC);
}

STDMETHODIMP IDirectDrawSurface2AggReleaseDC(IDirectDrawSurface2 *pDDS2, HDC hdc)
{
    return SURFACEOF(pDDS2)->InternalReleaseDC(hdc);
}

STDMETHODIMP IDirectDrawSurface2AggLock(IDirectDrawSurface2 *pDDS2, LPRECT lpDestRect,
				        LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent)
{
    return SURFACEOF(pDDS2)->InternalLock(lpDestRect, lpDDSurfaceDesc, dwFlags, hEvent);
}

STDMETHODIMP IDirectDrawSurface2AggUnlock(IDirectDrawSurface2 *pDDS2, LPVOID lpSurfaceData)
{
    return SURFACEOF(pDDS2)->InternalUnlock(lpSurfaceData);
}

STDMETHODIMP IDirectDrawSurface2AggGetAttachedSurface(IDirectDrawSurface2 *pDDS, LPDDSCAPS lpDDSCaps, LPDIRECTDRAWSURFACE2 FAR * lpDDS)
{
    return SURFACEOF(pDDS)->InternalGetAttachedSurface(lpDDSCaps, (IDirectDrawSurface **)lpDDS, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggAddAttachedSurface(IDirectDrawSurface2 *pDDS, LPDIRECTDRAWSURFACE2 lpDDS)
{
    return SURFACEOF(pDDS)->InternalAddAttachedSurface((IDirectDrawSurface *)lpDDS, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggDeleteAttachedSurface(IDirectDrawSurface2 *pDDS, DWORD dwFlags, LPDIRECTDRAWSURFACE2 lpDDS)
{
    return SURFACEOF(pDDS)->InternalDeleteAttachedSurface(dwFlags, (IDirectDrawSurface *)lpDDS, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggFlip(IDirectDrawSurface2 *pDDS, LPDIRECTDRAWSURFACE2 lpSurf, DWORD dw)
{
    return SURFACEOF(pDDS)->InternalFlip((LPDIRECTDRAWSURFACE)lpSurf, dw, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggBlt(IDirectDrawSurface2 *pDDS, LPRECT lpRect1,LPDIRECTDRAWSURFACE2 lpDDS, LPRECT lpRect2,DWORD dw, LPDDBLTFX lpfx)
{
    return SURFACEOF(pDDS)->InternalBlt(lpRect1, (LPDIRECTDRAWSURFACE)lpDDS, lpRect2, dw, lpfx, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggGetPalette(IDirectDrawSurface2 *pDDS, LPDIRECTDRAWPALETTE FAR * ppPal)
{
    return SURFACEOF(pDDS)->InternalGetPalette(ppPal, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggSetPalette(IDirectDrawSurface2 *pDDS, LPDIRECTDRAWPALETTE pPal)
{
    return SURFACEOF(pDDS)->InternalSetPalette(pPal, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggGetDDInterface(IDirectDrawSurface2 *pDDS, LPVOID FAR * ppInt)
{
    return SURFACEOF(pDDS)->InternalGetDDInterface(ppInt);
}

STDMETHODIMP IDirectDrawSurface2AggGetSurfaceDesc(IDirectDrawSurface2 *pDDS, LPDDSURFACEDESC lpDesc)
{
    return SURFACEOF(pDDS)->InternalGetSurfaceDesc(lpDesc, DDSURFACETYPE_2);
}


/*
 * the implementation of the functions in IDirectDrawSurface3 that we are
 * overriding (IUnknown and GetDC, ReleaseDC, Lock, Unlock, SetSurfaceDesc)
 */
STDMETHODIMP_(ULONG) IDirectDrawSurface3AggAddRef(IDirectDrawSurface3 *pDDS3)
{
    return SURFACEOF(pDDS3)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDrawSurface3AggRelease(IDirectDrawSurface3 *pDDS3)
{
    return SURFACEOF(pDDS3)->m_pUnkOuter->Release();
}


STDMETHODIMP IDirectDrawSurface3AggGetDC(IDirectDrawSurface3 *pDDS3, HDC * pHDC)
{
    return SURFACEOF(pDDS3)->InternalGetDC(pHDC);
}

STDMETHODIMP IDirectDrawSurface3AggReleaseDC(IDirectDrawSurface3 *pDDS3, HDC hdc)
{
    return SURFACEOF(pDDS3)->InternalReleaseDC(hdc);
}

STDMETHODIMP IDirectDrawSurface3AggLock(IDirectDrawSurface3 *pDDS3, LPRECT lpDestRect,
				        LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent)
{
    return SURFACEOF(pDDS3)->InternalLock(lpDestRect, lpDDSurfaceDesc, dwFlags, hEvent);
}

STDMETHODIMP IDirectDrawSurface3AggUnlock(IDirectDrawSurface3 *pDDS3, LPVOID lpSurfaceData)
{
    return SURFACEOF(pDDS3)->InternalUnlock(lpSurfaceData);
}

STDMETHODIMP IDirectDrawSurface3AggSetSurfaceDesc(IDirectDrawSurface3 *pDDS3, LPDDSURFACEDESC pddsd, DWORD dwFlags)
{
    return SURFACEOF(pDDS3)->InternalSetSurfaceDesc(pddsd, dwFlags);
}

STDMETHODIMP IDirectDrawSurface3AggGetAttachedSurface(IDirectDrawSurface3 *pDDS, LPDDSCAPS lpDDSCaps, LPDIRECTDRAWSURFACE3 FAR * lpDDS)
{
    return SURFACEOF(pDDS)->InternalGetAttachedSurface(lpDDSCaps, (IDirectDrawSurface**)lpDDS, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggAddAttachedSurface(IDirectDrawSurface3 *pDDS, LPDIRECTDRAWSURFACE3 lpDDS)
{
    return SURFACEOF(pDDS)->InternalAddAttachedSurface((IDirectDrawSurface *)lpDDS, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggDeleteAttachedSurface(IDirectDrawSurface3 *pDDS, DWORD dwFlags, LPDIRECTDRAWSURFACE3 lpDDS)
{
    return SURFACEOF(pDDS)->InternalDeleteAttachedSurface(dwFlags, (IDirectDrawSurface *)lpDDS, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggFlip(IDirectDrawSurface3 *pDDS, LPDIRECTDRAWSURFACE3 lpSurf, DWORD dw)
{
    return SURFACEOF(pDDS)->InternalFlip((LPDIRECTDRAWSURFACE)lpSurf, dw, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggBlt(IDirectDrawSurface3 *pDDS, LPRECT lpRect1,LPDIRECTDRAWSURFACE3 lpDDS, LPRECT lpRect2,DWORD dw, LPDDBLTFX lpfx)
{
    return SURFACEOF(pDDS)->InternalBlt(lpRect1, (LPDIRECTDRAWSURFACE)lpDDS, lpRect2, dw, lpfx, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggGetPalette(IDirectDrawSurface3 *pDDS, LPDIRECTDRAWPALETTE FAR * ppPal)
{
    return SURFACEOF(pDDS)->InternalGetPalette(ppPal, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggSetPalette(IDirectDrawSurface3 *pDDS, LPDIRECTDRAWPALETTE pPal)
{
    return SURFACEOF(pDDS)->InternalSetPalette(pPal, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggGetDDInterface(IDirectDrawSurface3 *pDDS, LPVOID FAR * ppInt)
{
    return SURFACEOF(pDDS)->InternalGetDDInterface(ppInt);
}


STDMETHODIMP IDirectDrawSurface3AggGetSurfaceDesc(IDirectDrawSurface3 *pDDS, LPDDSURFACEDESC lpDesc)
{
    return SURFACEOF(pDDS)->InternalGetSurfaceDesc(lpDesc, DDSURFACETYPE_3);
}


/*
 * the implementation of the functions in IDirectDrawSurface4 that we are
 * overriding (IUnknown and GetDC, ReleaseDC, Lock, Unlock, SetSurfaceDesc)
 */
STDMETHODIMP_(ULONG) IDirectDrawSurface4AggAddRef(IDirectDrawSurface4 *pDDS4)
{
    return SURFACEOF(pDDS4)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDrawSurface4AggRelease(IDirectDrawSurface4 *pDDS4)
{
    return SURFACEOF(pDDS4)->m_pUnkOuter->Release();
}

STDMETHODIMP IDirectDrawSurface4AggGetDC(IDirectDrawSurface4 *pDDS4, HDC * pHDC)
{
    return SURFACEOF(pDDS4)->InternalGetDC(pHDC);
}

STDMETHODIMP IDirectDrawSurface4AggReleaseDC(IDirectDrawSurface4 *pDDS4, HDC hdc)
{
    return SURFACEOF(pDDS4)->InternalReleaseDC(hdc);
}

STDMETHODIMP IDirectDrawSurface4AggLock(IDirectDrawSurface4 *pDDS4, LPRECT lpDestRect,
				        LPDDSURFACEDESC2 lpDDSurfaceDesc2, DWORD dwFlags, HANDLE hEvent)
{
    INTSTRUC_IDirectDrawSurface4 * pdd4 = (INTSTRUC_IDirectDrawSurface4 *)pDDS4;
    return pdd4->m_pRealInterface->Lock(lpDestRect, lpDDSurfaceDesc2, dwFlags, hEvent);
}

STDMETHODIMP IDirectDrawSurface4AggUnlock(IDirectDrawSurface4 *pDDS4, LPRECT lpRect)
{
    INTSTRUC_IDirectDrawSurface4 * pdd4 = (INTSTRUC_IDirectDrawSurface4 *)pDDS4;
    return pdd4->m_pRealInterface->Unlock(lpRect);
}

STDMETHODIMP IDirectDrawSurface4AggSetSurfaceDesc(IDirectDrawSurface4 *pDDS4, LPDDSURFACEDESC pddsd, DWORD dwFlags)
{
    return SURFACEOF(pDDS4)->InternalSetSurfaceDesc(pddsd, dwFlags);
}

STDMETHODIMP IDirectDrawSurface4AggGetAttachedSurface(IDirectDrawSurface4 *pDDS, LPDDSCAPS2 lpDDSCaps, LPDIRECTDRAWSURFACE4 FAR * lpDDS)
{
    return SURFACEOF(pDDS)->InternalGetAttachedSurface4(lpDDSCaps, (IDirectDrawSurface**)lpDDS);
}

STDMETHODIMP IDirectDrawSurface4AggAddAttachedSurface(IDirectDrawSurface4 *pDDS, LPDIRECTDRAWSURFACE4 lpDDS)
{
    return SURFACEOF(pDDS)->InternalAddAttachedSurface((IDirectDrawSurface *)lpDDS, DDSURFACETYPE_4);
}

STDMETHODIMP IDirectDrawSurface4AggDeleteAttachedSurface(IDirectDrawSurface4 *pDDS, DWORD dwFlags, LPDIRECTDRAWSURFACE4 lpDDS)
{
    return SURFACEOF(pDDS)->InternalDeleteAttachedSurface(dwFlags, (IDirectDrawSurface *)lpDDS, DDSURFACETYPE_4);
}

STDMETHODIMP IDirectDrawSurface4AggFlip(IDirectDrawSurface4 *pDDS, LPDIRECTDRAWSURFACE4 lpSurf, DWORD dw)
{
    return SURFACEOF(pDDS)->InternalFlip((LPDIRECTDRAWSURFACE)lpSurf, dw, DDSURFACETYPE_4);
}

STDMETHODIMP IDirectDrawSurface4AggBlt(IDirectDrawSurface4 *pDDS, LPRECT lpRect1,LPDIRECTDRAWSURFACE4 lpDDS, LPRECT lpRect2,DWORD dw, LPDDBLTFX lpfx)
{
    return SURFACEOF(pDDS)->InternalBlt(lpRect1, (LPDIRECTDRAWSURFACE)lpDDS, lpRect2, dw, lpfx, DDSURFACETYPE_4);
}

STDMETHODIMP IDirectDrawSurface4AggGetPalette(IDirectDrawSurface4 *pDDS, LPDIRECTDRAWPALETTE FAR * ppPal)
{
    return SURFACEOF(pDDS)->InternalGetPalette(ppPal, DDSURFACETYPE_4);
}

STDMETHODIMP IDirectDrawSurface4AggSetPalette(IDirectDrawSurface4 *pDDS, LPDIRECTDRAWPALETTE pPal)
{
    return SURFACEOF(pDDS)->InternalSetPalette(pPal, DDSURFACETYPE_4);
}

STDMETHODIMP IDirectDrawSurface4AggGetDDInterface(IDirectDrawSurface4 *pDDS, LPVOID FAR * ppInt)
{
    return SURFACEOF(pDDS)->InternalGetDDInterface(ppInt);
}

STDMETHODIMP IDirectDrawSurface4AggGetSurfaceDesc(IDirectDrawSurface4 *pDDS, LPDDSURFACEDESC2 lpDesc2)
{
    return SURFACEOF(pDDS)->InternalGetSurfaceDesc4(lpDesc2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\d3drm.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRM_H__
#define __D3DRM_H__

#include "ddraw.h"
#include "d3drmobj.h"

#ifdef __cplusplus
extern "C" {
struct IDirect3DRM;
#endif


typedef void (CDECL *D3DRMDEVICEPALETTECALLBACK)
    (LPDIRECT3DRMDEVICE lpDirect3DRMDev, LPVOID lpArg, DWORD dwIndex, LONG red, LONG green, LONG blue);

DEFINE_GUID(IID_IDirect3DRM,    0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
WIN_TYPES(IDirect3DRM, DIRECT3DRM);


/* Create a Direct3DRM API */
STDAPI Direct3DRMCreate(LPDIRECT3DRM FAR *lplpDirect3DRM);

#undef INTERFACE
#define INTERFACE IDirect3DRM

DECLARE_INTERFACE_(IDirect3DRM, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
        (THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)      (THIS_ LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(CreateMesh)       (THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER *) PURE;
    STDMETHOD(CreateFace)       (THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)  (THIS_ LPDIRECT3DRMANIMATION *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET *) PURE;
    STDMETHOD(CreateTexture)    (THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(CreateLight)      (THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
        (THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)   (THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD(CreateDevice)     (THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (   THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
        LPDIRECTDRAWSURFACE lpDDSBack, LPDIRECT3DRMDEVICE *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (   THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev,
        LPDIRECT3DRMDEVICE *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (   THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
        int width, int height, LPDIRECT3DRMDEVICE *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE *) PURE;
   
    STDMETHOD(CreateShadow)
    (   THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMLIGHT,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
        LPDIRECT3DRMVISUAL *
    ) PURE;
    STDMETHOD(CreateViewport)
    (   THIS_ LPDIRECT3DRMDEVICE, LPDIRECT3DRMFRAME, DWORD, DWORD,
        DWORD, DWORD, LPDIRECT3DRMVIEWPORT *
    ) PURE;
    STDMETHOD(CreateWrap)
    (   THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME,
        D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
        D3DVALUE ou, D3DVALUE ov,
        D3DVALUE su, D3DVALUE sv,
        LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)      (THIS_ const char *, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(LoadTextureFromResource)  (THIS_ HRSRC rs, LPDIRECT3DRMTEXTURE *) PURE;
   
    STDMETHOD(SetSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)    (THIS_ DWORD *size_return, LPSTR path_return);
    //STDMETHOD(GetSearchPath)  (THIS_ int *return_count, char ***return_path) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)       (THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)   (THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects) (THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)             
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
        D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURECALLBACK, LPVOID,
        LPDIRECT3DRMFRAME
    ) PURE;
    STDMETHOD(Tick)             (THIS_ D3DVALUE) PURE;
};

#define D3DRM_OK                        DD_OK
#define D3DRMERR_BADOBJECT              MAKE_DDHRESULT(781)
#define D3DRMERR_BADTYPE                MAKE_DDHRESULT(782)
#define D3DRMERR_BADALLOC               MAKE_DDHRESULT(783)
#define D3DRMERR_FACEUSED               MAKE_DDHRESULT(784)
#define D3DRMERR_NOTFOUND               MAKE_DDHRESULT(785)
#define D3DRMERR_NOTDONEYET             MAKE_DDHRESULT(786)
#define D3DRMERR_FILENOTFOUND           MAKE_DDHRESULT(787)
#define D3DRMERR_BADFILE                MAKE_DDHRESULT(788)
#define D3DRMERR_BADDEVICE              MAKE_DDHRESULT(789)
#define D3DRMERR_BADVALUE               MAKE_DDHRESULT(790)
#define D3DRMERR_BADMAJORVERSION        MAKE_DDHRESULT(791)
#define D3DRMERR_BADMINORVERSION        MAKE_DDHRESULT(792)
#define D3DRMERR_UNABLETOEXECUTE        MAKE_DDHRESULT(793)

#ifdef __cplusplus
};
#endif

#endif /* _D3DRMAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\d3di.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3di.h
 *  Content:	Direct3D internal include file
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id: d3di.h,v 1.26 1995/12/04 11:29:44 sjl Exp $
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   05/11/95   stevela	Initial rev with this header.
 *   11/11/95	stevela	Light code changed.
 *   21/11/95   colinmc Made Direct3D aggregatable
 *                      (so it can be QI'd off DirectDraw).
 *   23/11/95   colinmc Made Direct3D textures and devices aggregatable
 *                      (QI'd off DirectDrawSurfaces).
 *   07/12/95	stevela Merged in Colin's changes.
 *   10/12/95	stevela	Removed AGGREGATE_D3D.
 *			Removed Validate macros from here. Now in d3dpr.h
 *   02/03/96   colinmc Minor build fix
 *   17/04/96	stevela Use ddraw.h externally and ddrawp.h internally
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _D3DI_H
#define _D3DI_H

//@@BEGIN_MSINTERNAL
#include "ddrawp.h"
#if 0
//@@END_MSINTERNAL
#include "ddraw.h"
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
#include "d3d.h"

// @@BEGIN_MSINTERNAL
#if !defined(BUILD_RLAPI) && !defined(BUILD_DDDDK)
#include "ddrawi.h"
#include "rlreg.h"
#include "queue.h"
#include "object.h"
/*
typedef D3DCOLORMODEL D3DCOLORMODEL;

#define D3DCOLOR_RAMP D3DCOLOR_RAMP
#define D3DCOLOR_RGB D3DCOLOR_RGB
#define D3D_COLORMODEL D3D_COLORMODEL
*/
#endif /* !BUILD_RLAPI */
// @@END_MSINTERNAL

typedef DWORD D3DI_BUFFERHANDLE, *LPD3DI_BUFFERHANDLE;

/*
 * Internal version of executedata
 */
typedef struct _D3DI_ExecuteData {
    DWORD       dwSize;
    D3DI_BUFFERHANDLE dwHandle;		/* Handle allocated by driver */
    DWORD       dwVertexOffset;
    DWORD       dwVertexCount;
    DWORD       dwInstructionOffset;
    DWORD       dwInstructionLength;
    DWORD       dwHVertexOffset;
    D3DSTATUS   dsStatus;		/* Status after execute */
} D3DI_EXECUTEDATA, *LPD3DI_EXECUTEDATA;

/*
 * Internal version of lightdata
 */
typedef struct _D3DI_LIGHT {
    D3DLIGHTTYPE	type;
    BOOL		valid;
    D3DVALUE		red, green, blue, shade;
    D3DVECTOR		position;
    D3DVECTOR		model_position;
    D3DVECTOR		direction;
    D3DVECTOR		model_direction;
    D3DVECTOR		halfway;
    D3DVALUE		range;
    D3DVALUE		range_squared;
    D3DVALUE		falloff;
    D3DVALUE		attenuation0;
    D3DVALUE		attenuation1;
    D3DVALUE		attenuation2;
    D3DVALUE		cos_theta_by_2;
    D3DVALUE		cos_phi_by_2;
} D3DI_LIGHT, *LPD3DI_LIGHT;

// @@BEGIN_MSINTERNAL
#if !defined(BUILD_RLAPI) && !defined(BUILD_DDDDK)
#ifndef BUILD_HEL
#ifdef BUILD_D3D_LAYER
#include "driver.h"
#endif

typedef struct ID3DObjectVtbl D3DOBJECTVTBL, *LPD3DOBJECTVTBL;
typedef struct IDirect3DVtbl DIRECT3DCALLBACKS, *LPDIRECT3DCALLBACKS;
typedef struct IDirect3DDeviceVtbl DIRECT3DDEVICECALLBACKS, *LPDIRECT3DDEVICECALLBACKS;
typedef struct IDirect3DExecuteBufferVtbl DIRECT3DEXECUTEBUFFERCALLBACKS, *LPDIRECT3DEXECUTEBUFFERCALLBACKS;
typedef struct IDirect3DLightVtbl DIRECT3DLIGHTCALLBACKS, *LPDIRECT3DLIGHTCALLBACKS;
typedef struct IDirect3DMaterialVtbl DIRECT3DMATERIALCALLBACKS, *LPDIRECT3DMATERIALCALLBACKS;
typedef struct IDirect3DTextureVtbl DIRECT3DTEXTURECALLBACKS, *LPDIRECT3DTEXTURECALLBACKS;
typedef struct IDirect3DViewportVtbl DIRECT3DVIEWPORTCALLBACKS, *LPDIRECT3DVIEWPORTCALLBACKS;

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DIRECT3DI *LPDIRECT3DI;
typedef struct _DIRECT3DDEVICEI *LPDIRECT3DDEVICEI;
typedef struct _DIRECT3DEXECUTEBUFFERI *LPDIRECT3DEXECUTEBUFFERI;
typedef struct _DIRECT3DLIGHTI *LPDIRECT3DLIGHTI;
typedef struct _DIRECT3DMATERIALI *LPDIRECT3DMATERIALI;
typedef struct _DIRECT3DTEXTUREI *LPDIRECT3DTEXTUREI;
typedef struct _DIRECT3DVIEWPORTI *LPDIRECT3DVIEWPORTI;

/*
 * If we have an aggreate Direct3D we need a structure to
 * represent an interface distinct from the underlying
 * object. This is that structure. 
 */
typedef struct _DIRECT3DUNKNOWNI
{
    LPDIRECT3DCALLBACKS         lpVtbl;
    LPDIRECT3DI                 lpObj;
} DIRECT3DUNKNOWNI;
typedef struct _DIRECT3DUNKNOWNI *LPDIRECT3DUNKNOWNI;

/*
 * Internal version of Direct3D object; it has data after the vtable
 */
typedef struct _DIRECT3DI
{
    /*** Object Interface ***/
    LPDIRECT3DCALLBACKS		lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count object */

    /*** Object Relations ***/
    /* Devices */
    int				numDevs;/* Number of devices */
    LIST_HEAD(_devices, _DIRECT3DDEVICEI) devices;
    					/* Associated IDirect3DDevices */

    /* Viewports */
    int				numViewports; /* Number of viewports */
    LIST_HEAD(_viewports, _DIRECT3DVIEWPORTI) viewports;
    					/* Created IDirect3DViewports */
					
    /* Lights */
    int				numLights; /* Number of lights */
    LIST_HEAD(_lights, _DIRECT3DLIGHTI) lights;
    					/* Created IDirect3DLights */

    /* Materials */
    int				numMaterials; /* Number of materials */
    LIST_HEAD(_materials, _DIRECT3DMATERIALI) materials;
    					/* Created IDirect3DMaterials */

    /*** Object Data ***/
    unsigned long		v_next;	/* id of next viewport to be created */
    RLDDIRegistry*		lpReg;	/* Registry */

    /*
     * DirectDraw Interface
     */
    LPDDRAWI_DIRECTDRAW_INT	lpDDInt;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */
    DIRECT3DUNKNOWNI            lpThisIUnknown;   /* Our IUnknown interface */

} DIRECT3DI;

/*
 * If we have an aggreate Direct3DDevice we need a structure to
 * represent an interface distinct from the underlying
 * object. This is that structure. 
 */
typedef struct _DIRECT3DDEVICEUNKNOWNI
{
    LPDIRECT3DDEVICECALLBACKS   lpVtbl;
    LPDIRECT3DDEVICEI           lpObj;
} DIRECT3DDEVICEUNKNOWNI;
typedef struct _DIRECT3DDEVICEUNKNOWNI *LPDIRECT3DDEVICEUNKNOWNI;

/*
 * Internal version of Direct3DDevice object; it has data after the vtable
 */

#include "d3dhal.h"

typedef RLDDIDriver*  (*RLDDIDDrawCreateDriverFn)(
					LPDDRAWI_DIRECTDRAW_INT lpDDInt,
					LPDIRECTDRAWSURFACE lpDDS,
					LPDIRECTDRAWSURFACE lpZ,
					LPDIRECTDRAWPALETTE lpPal,
					LPDIRECT3DDEVICEI);

typedef HRESULT (*RLDDIGetCapsFn)(LPD3DDEVICEDESC*, LPD3DDEVICEDESC*);
typedef void (*RLDDIInitFn)(RLDDIMallocFn, RLDDIReallocFn, RLDDIFreeFn, RLDDIRaiseFn, RLDDIValue**, int, int);
typedef void (*RLDDIPushDriverFn)(RLDDIDriverStack*, RLDDIDriver*);
typedef void (*RLDDIPopDriverFn)(RLDDIDriverStack*);

typedef struct _D3DI_TEXTUREBLOCK
{
    LIST_ENTRY(_D3DI_TEXTUREBLOCK)	list;
    					/* Next block in IDirect3DTexture */
    LIST_ENTRY(_D3DI_TEXTUREBLOCK)	devList;
    					/* Next block in IDirect3DDevice */
    LPDIRECT3DDEVICEI			lpD3DDeviceI;
    LPDIRECT3DTEXTUREI			lpD3DTextureI;
    D3DTEXTUREHANDLE			hTex;
    					/* texture handle */
} D3DI_TEXTUREBLOCK;
typedef struct _D3DI_TEXTUREBLOCK *LPD3DI_TEXTUREBLOCK;

typedef struct _D3DI_MATERIALBLOCK
{
    LIST_ENTRY(_D3DI_MATERIALBLOCK)	list;
    					/* Next block in IDirect3DMaterial */
    LIST_ENTRY(_D3DI_MATERIALBLOCK)	devList;
    					/* Next block in IDirect3DDevice */
    LPDIRECT3DDEVICEI			lpD3DDeviceI;
    LPDIRECT3DMATERIALI			lpD3DMaterialI;
    D3DMATERIALHANDLE			hMat;
    					/* material handle */
} D3DI_MATERIALBLOCK;
typedef struct _D3DI_MATERIALBLOCK *LPD3DI_MATERIALBLOCK;

typedef struct _DIRECT3DDEVICEI
{
    /*** Object Interface ***/
    LPDIRECT3DDEVICECALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI			lpDirect3DI; /* parent */
    LIST_ENTRY(_DIRECT3DDEVICEI)list;	/* Next device IDirect3D */

    /* Textures */
    LIST_HEAD(_textures, _D3DI_TEXTUREBLOCK) texBlocks;
    					/* Ref to created IDirect3DTextures */

    /* Execute buffers */
    LIST_HEAD(_buffers, _DIRECT3DEXECUTEBUFFERI) buffers;
    					/* Created IDirect3DExecuteBuffers */

    /* Viewports */
    int				numViewports;
    CIRCLEQ_HEAD(_dviewports, _DIRECT3DVIEWPORTI) viewports;
    					/* Associated IDirect3DViewports */

    /* Materials */
    LIST_HEAD(_dmmaterials, _D3DI_MATERIALBLOCK) matBlocks;
    					/* Ref to associated IDirect3DMaterials */

    /*** Object Data ***/
    /* Private interfaces */
    LPD3DOBJECTVTBL		lpClassVtbl; /* Private Vtbl */
    LPD3DOBJECTVTBL		lpObjVtbl; /* Private Vtbl */

    LPD3DHAL_CALLBACKS		lpD3DHALCallbacks;
    LPD3DHAL_GLOBALDRIVERDATA	lpD3DHALGlobalDriverData;

    /* Viewports */
    unsigned long		v_id;	/* ID of last viewport rendered */

    /* Lights */
    int				numLights;
    					/* This indicates the maximum number
					   of lights that have been set in
					   the device. */

    /* Device characteristics */
    int				age;
    int				width;
    int				height;
    int				depth;
    unsigned long		red_mask, green_mask, blue_mask;

    int				dither;
    int				ramp_size;
    D3DCOLORMODEL		color_model;
    int				wireframe_options;
    D3DTEXTUREFILTER		texture_quality;
    D3DVALUE			gamma;
    unsigned char		gamma_table[256];
    int				aspectx, aspecty;
    D3DVALUE			perspective_tolerance;

    /* Library information */
#ifdef WIN32
    HINSTANCE		hDrvDll;
    char		dllname[MAXPATH];
    char		base[256];
#endif
#ifdef SHLIB
    void*		so;
#endif

    /* Are we in a scene? */
    BOOL		bInScene;

    /* Our Device type */
    GUID		guid;

    /* GetCaps function from the library */
    RLDDIGetCapsFn	GetCapsFn;

    /* Functions required to build driver */
    RLDDIInitFn		RLDDIInit;
    RLDDIPushDriverFn	RLDDIPushDriver;
    RLDDIPopDriverFn	RLDDIPopDriver;
    RLDDIDDrawCreateDriverFn	RLDDIDDrawCreateDriver;

    /* Device description */
    D3DDEVICEDESC	d3dHWDevDesc;
    D3DDEVICEDESC	d3dHELDevDesc;

    /* Driver stack */
    RLDDIDriverStack*	stack;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */
    DIRECT3DDEVICEUNKNOWNI      lpThisIUnknown;   /* Our IUnknown interface */

} DIRECT3DDEVICEI;

/*
 * Internal version of Direct3DExecuteBuffer object;
 * it has data after the vtable
 */
typedef struct _DIRECT3DEXECUTEBUFFERI
{
    /*** Object Interface ***/
    LPDIRECT3DEXECUTEBUFFERCALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DDEVICEI		lpD3DDeviceI; /* Parent */
    LIST_ENTRY(_DIRECT3DEXECUTEBUFFERI)list;
    					/* Next buffer in IDirect3D */

    /*** Object Data ***/
    DWORD			pid;	/* Process locking execute buffer */
    D3DEXECUTEBUFFERDESC	debDesc;
    					/* Description of the buffer */
    D3DEXECUTEDATA		exData;	/* Execute Data */
    BOOL			locked;	/* Is the buffer locked */

    D3DI_BUFFERHANDLE		hBuf;
    					/* Execute buffer handle */
} DIRECT3DEXECUTEBUFFERI;

/*
 * Internal version of Direct3DLight object;
 * it has data after the vtable
 */
typedef struct _DIRECT3DLIGHTI
{
    /*** Object Interface ***/
    LPDIRECT3DLIGHTCALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI			lpDirect3DI; /* Parent */
    LIST_ENTRY(_DIRECT3DLIGHTI)list;
    					/* Next light in IDirect3D */

    LPDIRECT3DVIEWPORTI		lpD3DViewportI; /* Guardian */
    CIRCLEQ_ENTRY(_DIRECT3DLIGHTI)light_list;
    					/* Next light in IDirect3DViewport */

    /*** Object Data ***/
    D3DLIGHT			dlLight;/* Data describing light */
    D3DI_LIGHT			diLightData;
    					/* Internal representation of light */
} DIRECT3DLIGHTI;

/*
 * Internal version of Direct3DMaterial object;
 * it has data after the vtable
 */
typedef struct _DIRECT3DMATERIALI
{
    /*** Object Interface ***/
    LPDIRECT3DMATERIALCALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI			lpDirect3DI; /* Parent */
    LIST_ENTRY(_DIRECT3DMATERIALI)list;
    					/* Next MATERIAL in IDirect3D */

    LIST_HEAD(_mblocks, _D3DI_MATERIALBLOCK)blocks;
    					/* devices we're associated with */

    /*** Object Data ***/
    D3DMATERIAL			dmMaterial; /* Data describing material */
    BOOL			bRes;	/* Is this material reserved in the driver */
} DIRECT3DMATERIALI;

/*
 * If we have an aggreate Direct3DTexture we need a structure
 * to represent an unknown interface distinct from the underlying
 * object. This is that structure. 
 */
typedef struct _DIRECT3DTEXTUREUNKNOWNI
{
    LPDIRECT3DTEXTURECALLBACKS  lpVtbl;
    LPDIRECT3DTEXTUREI          lpObj;
} DIRECT3DTEXTUREUNKNOWNI;
typedef struct _DIRECT3DTEXTUREUNKNOWNI *LPDIRECT3DTEXTUREUNKNOWNI;

/*
 * Internal version of Direct3DTexture object; it has data after the vtable
 */
typedef struct _DIRECT3DTEXTUREI
{
    /*** Object Interface ***/
    LPDIRECT3DTEXTURECALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */


    /*** Object Relations ***/
    LIST_HEAD(_blocks, _D3DI_TEXTUREBLOCK) blocks;
    					/* Devices we're associated with */

    /*** Object Data ***/
    LPDIRECTDRAWSURFACE		lpDDS;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */
    DIRECT3DTEXTUREUNKNOWNI     lpThisIUnknown;   /* Our IUnknown interface */
    BOOL			bIsPalettized;

} DIRECT3DTEXTUREI;

/*
 * Internal version of Direct3DViewport object; it has data after the vtable
 */
typedef struct _DIRECT3DVIEWPORTI
{
    /*** Object Interface ***/
    LPDIRECT3DVIEWPORTCALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations */
    LPDIRECT3DI			lpDirect3DI; /* Parent */
    LIST_ENTRY(_DIRECT3DVIEWPORTI)list;
    					/* Next viewport in IDirect3D */

    LPDIRECT3DDEVICEI		lpD3DDeviceI; /* Guardian */
    CIRCLEQ_ENTRY(_DIRECT3DVIEWPORTI)vw_list;
    					/* Next viewport in IDirect3DDevice */
					
    /* Lights */
    int				numLights;
    CIRCLEQ_HEAD(_dlights, _DIRECT3DLIGHTI) lights;
    					/* Associated IDirect3DLights */

    /*** Object Data ***/
    unsigned long		v_id;	/* Id for this viewport */
    D3DVIEWPORT			v_data;

    BOOL			have_background;
    D3DMATERIALHANDLE		background;
    					/* Background material */
    BOOL			have_depth;
    LPDIRECTDRAWSURFACE		depth;	/* Background depth */
    
    BOOL			bLightsChanged;
    					/* Have the lights changed since they
					   were last collected? */
    DWORD			clrCount; /* Number of rects allocated */
    LPD3DRECT			clrRects; /* Rects used for clearing */
} DIRECT3DVIEWPORTI;

/*
 * Picking stuff.
 */
typedef struct _D3DI_PICKDATA {
    D3DI_EXECUTEDATA*	exe;
    D3DPICKRECORD*	records;
    int			pick_count;
    D3DRECT		pick;
} D3DI_PICKDATA, *LPD3DI_PICKDATA;

/*
 * Direct3D memory allocation
 */

/*
 * Register a set of functions to be used in place of malloc, realloc
 * and free for memory allocation.  The functions D3DMalloc, D3DRealloc
 * and D3DFree will use these functions.  The default is to use the
 * ANSI C library routines malloc, realloc and free.
 */
typedef LPVOID (*D3DMALLOCFUNCTION)(size_t);
typedef LPVOID (*D3DREALLOCFUNCTION)(LPVOID, size_t);
typedef VOID (*D3DFREEFUNCTION)(LPVOID);

/*
 * Allocate size bytes of memory and return a pointer to it in *p_return.
 * Returns D3DERR_BADALLOC with *p_return unchanged if the allocation fails.
 */
HRESULT D3DAPI 		D3DMalloc(LPVOID* p_return, size_t size);

/*
 * Change the size of an allocated block of memory.  A pointer to the
 * block is passed in in *p_inout.  If *p_inout is NULL then a new
 * block is allocated.  If the reallocation is successful, *p_inout is
 * changed to point to the new block.  If the allocation fails,
 * *p_inout is unchanged and D3DERR_BADALLOC is returned.
 */
HRESULT D3DAPI 		D3DRealloc(LPVOID* p_inout, size_t size);

/*
 * Free a block of memory previously allocated with D3DMalloc or
 * D3DRealloc.
 */
VOID D3DAPI		D3DFree(LPVOID p);

/*
 * Used for raising errors from the driver.
 */
HRESULT D3DAPI D3DRaise(HRESULT);

/*
 * Convert RLDDI error codes to D3D error codes
 */
#define RLDDITOD3DERR(_errcode) (RLDDIToD3DErrors[_errcode])
extern HRESULT RLDDIToD3DErrors[];

/*
 * maths
 */
#if 1 /* defined(STACK_CALL) && defined(__WATCOMC__) */
D3DVALUE D3DIPow(D3DVALUE, D3DVALUE);
#else
#define D3DIPow(v,p)	DTOVAL(pow(VALTOD(v), VALTOD(p)))
#endif

/*
 * Light utils
 */
void D3DI_DeviceMarkLightEnd(LPDIRECT3DDEVICEI, int);
void D3DI_UpdateLightInternal(LPDIRECT3DLIGHTI);
void D3DI_VectorNormalise12(LPD3DVECTOR v);
D3DTEXTUREHANDLE D3DI_FindTextureHandle(LPDIRECT3DTEXTUREI, LPDIRECT3DDEVICEI);
void D3DI_SetTextureHandle(LPDIRECT3DTEXTUREI, LPDIRECT3DDEVICEI, D3DTEXTUREHANDLE);
void D3DI_RemoveTextureBlock(LPD3DI_TEXTUREBLOCK);
void D3DI_RemoveMaterialBlock(LPD3DI_MATERIALBLOCK);

extern BOOL D3DI_isHALValid(LPD3DHAL_CALLBACKS);

#ifdef BUILD_D3D_LAYER
extern RLDDIValue* RLDDIFInvSqrtTable;
#endif

#ifdef __cplusplus
};
#endif

#endif /* BUILD_HEL */
#endif /* !BUILD_RLAPI */
// @@END_MSINTERNAL

#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\d3drmwin.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRMWIN_H__
#define __D3DRMWIN_H__

#ifndef WIN32
#define WIN32
#endif

#include "d3drm.h"
#include "ddraw.h"
#include "d3d.h"

/*
 * GUIDS used by Direct3DRM Windows interface
 */
DEFINE_GUID(IID_IDirect3DRMWinDevice,   0xc5016cc0, 0xd273, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

WIN_TYPES(IDirect3DRMWinDevice, DIRECT3DRMWINDEVICE);

#undef INTERFACE
#define INTERFACE IDirect3DRMWinDevice

DECLARE_INTERFACE_(IDirect3DRMWinDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWinDevice methods
     */

    /* Repaint the window with the last frame which was rendered. */
    STDMETHOD(HandlePaint)(THIS_ HDC hdc) PURE;

    /* Respond to a WM_ACTIVATE message. */
    STDMETHOD(HandleActivate)(THIS_ WORD wparam) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\d3drmdef.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRMDEFS_H__
#define __D3DRMDEFS_H__

#include <stddef.h>
#include "d3dtypes.h"

#ifdef WIN32
#define D3DRMAPI  __stdcall
#else
#define D3DRMAPI
#endif

#if defined(__cplusplus)
extern "C" {
#endif

#ifndef TRUE
#define FALSE 0
#define TRUE 1
#endif

typedef struct _D3DRMVECTOR4D
{   D3DVALUE x, y, z, w;
} D3DRMVECTOR4D, *LPD3DRMVECTOR4D;

typedef D3DVALUE D3DRMMATRIX4D[4][4];

typedef struct _D3DRMQUATERNION
{   D3DVALUE s;
    D3DVECTOR v;
} D3DRMQUATERNION, *LPD3DRMQUATERNION;

typedef struct _D3DRMBOX
{   D3DVECTOR min, max;
} D3DRMBOX, *LPD3DRMBOX;

typedef void (*D3DRMWRAPCALLBACK)
    (LPD3DVECTOR, int* u, int* v, LPD3DVECTOR a, LPD3DVECTOR b, LPVOID);

typedef enum _D3DRMLIGHTTYPE
{   D3DRMLIGHT_AMBIENT,
    D3DRMLIGHT_POINT,
    D3DRMLIGHT_SPOT,
    D3DRMLIGHT_DIRECTIONAL,
    D3DRMLIGHT_PARALLELPOINT
} D3DRMLIGHTTYPE, *LPD3DRMLIGHTTYPE;

typedef enum _D3DRMSHADEMODE {
    D3DRMSHADE_FLAT     = 0,
    D3DRMSHADE_GOURAUD  = 1,
    D3DRMSHADE_PHONG    = 2,

    D3DRMSHADE_MASK     = 7,
    D3DRMSHADE_MAX      = 8
} D3DRMSHADEMODE, *LPD3DRMSHADEMODE;

typedef enum _D3DRMLIGHTMODE {
    D3DRMLIGHT_OFF      = 0 * D3DRMSHADE_MAX,
    D3DRMLIGHT_ON       = 1 * D3DRMSHADE_MAX,

    D3DRMLIGHT_MASK     = 7 * D3DRMSHADE_MAX,
    D3DRMLIGHT_MAX      = 8 * D3DRMSHADE_MAX
} D3DRMLIGHTMODE, *LPD3DRMLIGHTMODE;

typedef enum _D3DRMFILLMODE {
    D3DRMFILL_POINTS    = 0 * D3DRMLIGHT_MAX,
    D3DRMFILL_WIREFRAME = 1 * D3DRMLIGHT_MAX,
    D3DRMFILL_SOLID     = 2 * D3DRMLIGHT_MAX,

    D3DRMFILL_MASK      = 7 * D3DRMLIGHT_MAX,
    D3DRMFILL_MAX       = 8 * D3DRMLIGHT_MAX
} D3DRMFILLMODE, *LPD3DRMFILLMODE;

typedef DWORD D3DRMRENDERQUALITY, *LPD3DRMRENDERQUALITY;

#define D3DRMRENDER_WIREFRAME   (D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_WIREFRAME)
#define D3DRMRENDER_UNLITFLAT   (D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_SOLID)
#define D3DRMRENDER_FLAT        (D3DRMSHADE_FLAT+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_GOURAUD     (D3DRMSHADE_GOURAUD+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_PHONG       (D3DRMSHADE_PHONG+D3DRMLIGHT_ON+D3DRMFILL_SOLID)

typedef enum _D3DRMTEXTUREQUALITY
{   D3DRMTEXTURE_NEAREST,               /* choose nearest texel */
    D3DRMTEXTURE_LINEAR,                /* interpolate 4 texels */
    D3DRMTEXTURE_MIPNEAREST,            /* nearest texel in nearest mipmap  */
    D3DRMTEXTURE_MIPLINEAR,             /* interpolate 2 texels from 2 mipmaps */
    D3DRMTEXTURE_LINEARMIPNEAREST,      /* interpolate 4 texels in nearest mipmap */
    D3DRMTEXTURE_LINEARMIPLINEAR        /* interpolate 8 texels from 2 mipmaps */
} D3DRMTEXTUREQUALITY, *LPD3DRMTEXTUREQUALITY;

typedef enum _D3DRMCOMBINETYPE
{   D3DRMCOMBINE_REPLACE,
    D3DRMCOMBINE_BEFORE,
    D3DRMCOMBINE_AFTER
} D3DRMCOMBINETYPE, *LPD3DRMCOMBINETYPE;

typedef D3DCOLORMODEL D3DRMCOLORMODEL, *LPD3DRMCOLORMODEL;

typedef enum _D3DRMPALETTEFLAGS
{   D3DRMPALETTE_FREE,                  /* renderer may use this entry freely */
    D3DRMPALETTE_READONLY,              /* fixed but may be used by renderer */
    D3DRMPALETTE_RESERVED               /* may not be used by renderer */
} D3DRMPALETTEFLAGS, *LPD3DRMPALETTEFLAGS;

typedef struct _D3DRMPALETTEENTRY
{   unsigned char red;          /* 0 .. 255 */
    unsigned char green;        /* 0 .. 255 */
    unsigned char blue;         /* 0 .. 255 */
    unsigned char flags;        /* one of D3DRMPALETTEFLAGS */
} D3DRMPALETTEENTRY, *LPD3DRMPALETTEENTRY;

typedef struct _D3DRMIMAGE
{   int width, height;          /* width and height in pixels */
    int aspectx, aspecty;       /* aspect ratio for non-square pixels */
    int depth;                  /* bits per pixel */
    int rgb;                    /* if false, pixels are indices into a
                                   palette otherwise, pixels encode
                                   RGB values. */
    int bytes_per_line;         /* number of bytes of memory for a
                                   scanline. This must be a multiple
                                   of 4. */
    void* buffer1;              /* memory to render into (first buffer). */
    void* buffer2;              /* second rendering buffer for double
                                   buffering, set to NULL for single
                                   buffering. */
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    unsigned long alpha_mask;   /* if rgb is true, these are masks for
                                   the red, green and blue parts of a
                                   pixel.  Otherwise, these are masks
                                   for the significant bits of the
                                   red, green and blue elements in the
                                   palette.  For instance, most SVGA
                                   displays use 64 intensities of red,
                                   green and blue, so the masks should
                                   all be set to 0xfc. */
    int palette_size;           /* number of entries in palette */
    D3DRMPALETTEENTRY* palette; /* description of the palette (only if
                                   rgb is false).  Must be (1<<depth)
                                   elements. */
} D3DRMIMAGE, *LPD3DRMIMAGE;

typedef enum _D3DRMWRAPTYPE
{   D3DRMWRAP_FLAT,
    D3DRMWRAP_CYLINDER,
    D3DRMWRAP_SPHERE,
    D3DRMWRAP_CHROME
} D3DRMWRAPTYPE, *LPD3DRMWRAPTYPE;

#define D3DRMWIREFRAME_CULL             1 /* cull backfaces */
#define D3DRMWIREFRAME_HIDDENLINE       2 /* lines are obscured by closer objects */

typedef enum _D3DRMPROJECTIONTYPE
{   D3DRMPROJECT_PERSPECTIVE,
    D3DRMPROJECT_ORTHOGRAPHIC
} D3DRMPROJECTIONTYPE, *LPD3DRMPROJECTIONTYPE;

typedef enum _D3DRMXOFFORMAT
{   D3DRMXOF_BINARY,
    D3DRMXOF_COMPRESSED,
    D3DRMXOF_TEXT
} D3DRMXOFFORMAT, *LPD3DRMXOFFORMAT;

typedef DWORD D3DRMSAVEOPTIONS;
#define D3DRMXOFSAVE_NORMALS 1
#define D3DRMXOFSAVE_TEXTURECOORDINATES 2
#define D3DRMXOFSAVE_MATERIALS 4
#define D3DRMXOFSAVE_TEXTURENAMES 8
#define D3DRMXOFSAVE_ALL 15
#define D3DRMXOFSAVE_TEMPLATES 16

typedef enum _D3DRMCOLORSOURCE
{   D3DRMCOLOR_FROMFACE,
    D3DRMCOLOR_FROMVERTEX
} D3DRMCOLORSOURCE, *LPD3DRMCOLORSOURCE;

typedef enum _D3DRMFRAMECONSTRAINT
{   D3DRMCONSTRAIN_Z,           /* use only X and Y rotations */
    D3DRMCONSTRAIN_Y,           /* use only X and Z rotations */
    D3DRMCONSTRAIN_X            /* use only Y and Z rotations */
} D3DRMFRAMECONSTRAINT, *LPD3DRMFRAMECONSTRAINT;

typedef enum _D3DRMMATERIALMODE
{   D3DRMMATERIAL_FROMMESH,
    D3DRMMATERIAL_FROMPARENT,
    D3DRMMATERIAL_FROMFRAME
} D3DRMMATERIALMODE, *LPD3DRMMATERIALMODE;

typedef enum _D3DRMFOGMODE
{   D3DRMFOG_LINEAR,            /* linear between start and end */
    D3DRMFOG_EXPONENTIAL,       /* density * exp(-distance) */
    D3DRMFOG_EXPONENTIALSQUARED /* density * exp(-distance*distance) */
} D3DRMFOGMODE, *LPD3DRMFOGMODE;

typedef enum _D3DRMZBUFFERMODE {
    D3DRMZBUFFER_FROMPARENT,    /* default */
    D3DRMZBUFFER_ENABLE,        /* enable zbuffering */
    D3DRMZBUFFER_DISABLE        /* disable zbuffering */
} D3DRMZBUFFERMODE, *LPD3DRMZBUFFERMODE;

typedef enum _D3DRMSORTMODE {
    D3DRMSORT_FROMPARENT,       /* default */
    D3DRMSORT_NONE,             /* don't sort child frames */
    D3DRMSORT_FRONTTOBACK,      /* sort child frames front-to-back */
    D3DRMSORT_BACKTOFRONT       /* sort child frames back-to-front */
} D3DRMSORTMODE, *LPD3DRMSORTMODE;

typedef DWORD D3DRMANIMATIONOPTIONS;
#define D3DRMANIMATION_OPEN 0x01L
#define D3DRMANIMATION_CLOSED 0x02L
#define D3DRMANIMATION_LINEARPOSITION 0x04L
#define D3DRMANIMATION_SPLINEPOSITION 0x08L
#define D3DRMANIMATION_SCALEANDROTATION 0x00000010L
#define D3DRMANIMATION_POSITION 0x00000020L

typedef DWORD D3DRMLOADOPTIONS;

#define D3DRMLOAD_FROMFILE  0x00L
#define D3DRMLOAD_FROMRESOURCE 0x01L
#define D3DRMLOAD_FROMMEMORY 0x02L
#define D3DRMLOAD_FROMSTREAM 0x04L

#define D3DRMLOAD_BYNAME 0x10L
#define D3DRMLOAD_BYPOSITION 0x20L
#define D3DRMLOAD_BYGUID 0x40L
#define D3DRMLOAD_FIRST 0x80L

#define D3DRMLOAD_INSTANCEBYREFERENCE 0x100L
#define D3DRMLOAD_INSTANCEBYCOPYING 0x200L

typedef struct _D3DRMLOADRESOURCE {
  HMODULE hModule;
  LPCTSTR lpName;
  LPCTSTR lpType;
} D3DRMLOADRESOURCE, *LPD3DRMLOADRESOURCE;

typedef struct _D3DRMLOADMEMORY {
  LPVOID lpMemory;
  DWORD dSize;
} D3DRMLOADMEMORY, *LPD3DRMLOADMEMORY;

typedef enum _D3DRMUSERVISUALREASON {
    D3DRMUSERVISUAL_CANSEE,
    D3DRMUSERVISUAL_RENDER
} D3DRMUSERVISUALREASON, *LPD3DRMUSERVISUALREASON;


typedef DWORD D3DRMMAPPING, D3DRMMAPPINGFLAG, *LPD3DRMMAPPING;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPU = 1;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPV = 2;
static const D3DRMMAPPINGFLAG D3DRMMAP_PERSPCORRECT = 4;

typedef struct _D3DRMVERTEX
{   D3DVECTOR       position;
    D3DVECTOR       normal;
    D3DVALUE        tu, tv;
    D3DCOLOR        color;
} D3DRMVERTEX, *LPD3DRMVERTEX;

typedef LONG D3DRMGROUPINDEX; /* group indexes begin a 0 */
static const D3DRMGROUPINDEX D3DRMGROUP_ALLGROUPS = -1;

/*
 * Create a color from three components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI        D3DRMCreateColorRGB(D3DVALUE red,
                                          D3DVALUE green,
                                          D3DVALUE blue);

/*
 * Create a color from four components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI        D3DRMCreateColorRGBA(D3DVALUE red,
                                                 D3DVALUE green,
                                                 D3DVALUE blue,
                                                 D3DVALUE alpha);

/*
 * Get the red component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetRed(D3DCOLOR);

/*
 * Get the green component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetGreen(D3DCOLOR);

/*
 * Get the blue component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetBlue(D3DCOLOR);

/*
 * Get the alpha component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetAlpha(D3DCOLOR);

/*
 * Add two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorAdd(LPD3DVECTOR d,
                                          LPD3DVECTOR s1,
                                          LPD3DVECTOR s2);

/*
 * Subtract two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorSubtract(LPD3DVECTOR d,
                                               LPD3DVECTOR s1,
                                               LPD3DVECTOR s2);
/*
 * Reflect a ray about a given normal.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorReflect(LPD3DVECTOR d,
                                              LPD3DVECTOR ray,
                                              LPD3DVECTOR norm);

/*
 * Calculate the vector cross product.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorCrossProduct(LPD3DVECTOR d,
                                                   LPD3DVECTOR s1,
                                                   LPD3DVECTOR s2);
/*
 * Return the vector dot product.
 */
extern D3DVALUE                 D3DRMAPI D3DRMVectorDotProduct(LPD3DVECTOR s1,
                                                 LPD3DVECTOR s2);

/*
 * Scale a vector so that its modulus is 1.  Returns its argument or
 * NULL if there was an error (e.g. a zero vector was passed).
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorNormalize(LPD3DVECTOR);
#define D3DRMVectorNormalise D3DRMVectorNormalize

/*
 * Return the length of a vector (e.g. sqrt(x*x + y*y + z*z)).
 */
extern D3DVALUE                 D3DRMAPI D3DRMVectorModulus(LPD3DVECTOR v);

/*
 * Set the rotation part of a matrix to be a rotation of theta radians
 * around the given axis.
 */

extern LPD3DVECTOR      D3DRMAPI D3DRMVectorRotate(LPD3DVECTOR r, LPD3DVECTOR v, LPD3DVECTOR axis, D3DVALUE theta);

/*
 * Scale a vector uniformly in all three axes
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorScale(LPD3DVECTOR d, LPD3DVECTOR s, D3DVALUE factor);

/*
 * Return a random unit vector
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorRandom(LPD3DVECTOR d);

/*
 * Returns a unit quaternion that represents a rotation of theta radians
 * around the given axis.
 */

extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionFromRotation(LPD3DRMQUATERNION quat,
                                                              LPD3DVECTOR v,
                                                              D3DVALUE theta);

/*
 * Calculate the product of two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionMultiply(LPD3DRMQUATERNION q,
                                                          LPD3DRMQUATERNION a,
                                                          LPD3DRMQUATERNION b);

/*
 * Interpolate between two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionSlerp(LPD3DRMQUATERNION q,
                                                       LPD3DRMQUATERNION a,
                                                       LPD3DRMQUATERNION b,
                                                       D3DVALUE alpha);

/*
 * Calculate the matrix for the rotation that a unit quaternion represents
 */
extern void             D3DRMAPI D3DRMMatrixFromQuaternion(D3DRMMATRIX4D dmMat, LPD3DRMQUATERNION lpDqQuat);


#if defined(__cplusplus)
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\ddrawex.h ===
//	Header file for DirectDrawEx functionality

#ifndef __DDRAWEXH__
#define __DDRAWEXH__

#ifdef __cplusplus
extern "C" {
#endif

#include <ddraw.h>

// {4FD2A832-86C8-11d0-8FCA-00C04FD9189D}
DEFINE_GUID(CLSID_DirectDrawFactory, 
0x4fd2a832, 0x86c8, 0x11d0, 0x8f, 0xca, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

DEFINE_GUID(IID_IDirectDrawFactory, 
0x4fd2a833, 0x86c8, 0x11d0, 0x8f, 0xca, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

#define DDSD_LPSURFACE		0x00000800l

#ifndef DIRECTDRAW_VERSION

//these are not included in DX3 include files, define them here
//DEFINE_GUID( IID_IDirect3DRampDevice,   0xF2086B20,0x259F,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
//DEFINE_GUID( IID_IDirect3DRGBDevice,    0xA4665C60,0x2673,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
//DEFINE_GUID( IID_IDirect3DHALDevice,    0x84E63dE0,0x46AA,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );



DEFINE_GUID( IID_IDirectDrawSurface3,
0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );

typedef struct IDirectDrawSurface3		FAR *LPDIRECTDRAWSURFACE3;

#undef INTERFACE
#define INTERFACE IDirectDrawSurface3
DECLARE_INTERFACE_( IDirectDrawSurface3, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE3, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE3, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE3, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE3 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE3,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE3) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC, DWORD ) PURE;
};
#endif




#define	DDSCAPS_DATAEXCHANGE	(DDSCAPS_SYSTEMMEMORY|DDSCAPS_VIDEOMEMORY)

#undef	INTERFACE
#define INTERFACE IDirectDrawFactory

DECLARE_INTERFACE_(IDirectDrawFactory, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawFactory methods ***/
    STDMETHOD(CreateDirectDraw) (THIS_ GUID * pGUID, HWND hWnd, DWORD dwCoopLevelFlags, DWORD dwReserved, IUnknown *pUnkOuter, IDirectDraw **ppDirectDraw) PURE;
    STDMETHOD(DirectDrawEnumerate) (THIS_ LPDDENUMCALLBACK lpCallback, LPVOID lpContext) PURE;
};


 
// {618F8AD4-8B7A-11d0-8FCC-00C04FD9189D}
DEFINE_GUID(IID_IDirectDraw3, 
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

typedef struct IDirectDraw3		FAR *LPDIRECTDRAW3;

#undef	INTERFACE
#define INTERFACE IDirectDraw3

DECLARE_INTERFACE_(IDirectDraw3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
    /*** IDirectDraw3 methods ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, IDirectDrawSurface **) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw3_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw3_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw3_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw3_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw3_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw3_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw3_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw3_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw3_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw3_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw3_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw3_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw3_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw3_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw3_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw3_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw3_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw3_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw3_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw3_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw3_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw3_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw3_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw3_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw3_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#endif

 
/*===========================================================================
 *
 *
 * DIRECTDRAWEX RETURN CODES
 *
 * The return values from DirectDrawEx Commands and Surface that return an
 * HRESULT are codes from DirectDrawEx concerning the results of the action
 * requested by DirectDrawEx.
 *
 *==========================================================================*/

/*
 * An attempt was made to load ddraw.dll
 */
#define DDERR_LOADFAILED                        MAKE_DDHRESULT( 901 )

/*
 * Unable to determine module/os version number
 */
#define DDERR_BADVERSIONINFO                    MAKE_DDHRESULT( 902 )

/*
 * Unable to determine address of ddraw.dll exported symbol (DirectDrawCreate or
 * DirectDrawEnumerate).
 */
#define DDERR_BADPROCADDRESS                    MAKE_DDHRESULT( 903 )

/*
 * Legacy usage: do not use QI() to create D3D device objects from surface objects.  
 * Use IDirect3D2::CreateDevice()
 */
#define DDERR_LEGACYUSAGE                       MAKE_DDHRESULT( 904 )


#ifdef __cplusplus
}
#endif


#endif // __DDRAWEXH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\ddraw.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw.h
 *  Content:    DirectDraw include file
 *
 ***************************************************************************/

#ifndef __DDRAW_INCLUDED__
#define __DDRAW_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown            void
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#define _FACDD  0x876
#define MAKE_DDHRESULT( code )  MAKE_HRESULT( 1, _FACDD, code )

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDraw objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( CLSID_DirectDraw,                  0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35 );
DEFINE_GUID( CLSID_DirectDrawClipper,           0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw,                   0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDraw2,                  0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDrawSurface,            0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawSurface2,           0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27 );

DEFINE_GUID( IID_IDirectDrawPalette,            0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawClipper,            0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
                 
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDirectDraw                      FAR *LPDIRECTDRAW;
typedef struct IDirectDraw2                     FAR *LPDIRECTDRAW2;
typedef struct IDirectDrawSurface               FAR *LPDIRECTDRAWSURFACE;
typedef struct IDirectDrawSurface2              FAR *LPDIRECTDRAWSURFACE2;

typedef struct IDirectDrawPalette               FAR *LPDIRECTDRAWPALETTE;
typedef struct IDirectDrawClipper               FAR *LPDIRECTDRAWCLIPPER;

typedef struct _DDFXROP                 FAR *LPDDFXROP;
typedef struct _DDSURFACEDESC           FAR *LPDDSURFACEDESC;

/*
 * API's
 */
#if (defined (WIN32) || defined( _WIN32 ) ) && !defined( _NO_COM )
//#if defined( _WIN32 ) && !defined( _NO_ENUM )
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKA)(GUID FAR *, LPSTR, LPSTR, LPVOID);
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID);
    extern HRESULT WINAPI DirectDrawEnumerateW( LPDDENUMCALLBACKW lpCallback, LPVOID lpContext );
    extern HRESULT WINAPI DirectDrawEnumerateA( LPDDENUMCALLBACKA lpCallback, LPVOID lpContext );
    #ifdef UNICODE
        typedef LPDDENUMCALLBACKW       LPDDENUMCALLBACK;
        #define DirectDrawEnumerate     DirectDrawEnumerateW
    #else
        typedef LPDDENUMCALLBACKA       LPDDENUMCALLBACK;
        #define DirectDrawEnumerate     DirectDrawEnumerateA
    #endif
    extern HRESULT WINAPI DirectDrawCreate( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );
    extern HRESULT WINAPI DirectDrawCreateClipper( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
    #ifdef WINNT
        //This is the user-mode entry stub to the kernel mode procedure.
        extern HRESULT NtDirectDrawCreate( GUID FAR *lpGUID, HANDLE *lplpDD, IUnknown FAR *pUnkOuter );
    #endif
#endif

#define REGSTR_KEY_DDHW_DESCRIPTION     "Description"
#define REGSTR_KEY_DDHW_DRIVERNAME      "DriverName"
#define REGSTR_PATH_DDHW                "Hardware\\DirectDrawDrivers"

#define DDCREATE_HARDWAREONLY           0x00000001l
#define DDCREATE_EMULATIONONLY          0x00000002l

#ifdef WINNT
typedef long HRESULT;
#endif

//#ifndef WINNT
typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK)(LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK)(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC, LPVOID);
//#endif
/*
 * DDCOLORKEY
 */
typedef struct _DDCOLORKEY
{
    DWORD       dwColorSpaceLowValue;   // low boundary of color space that is to 
                                        // be treated as Color Key, inclusive
    DWORD       dwColorSpaceHighValue;  // high boundary of color space that is 
                                        // to be treated as Color Key, inclusive
} DDCOLORKEY;

typedef DDCOLORKEY FAR* LPDDCOLORKEY;

/*
 * DDBLTFX
 * Used to pass override information to the DIRECTDRAWSURFACE callback Blt.
 */
typedef struct _DDBLTFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwDDFX;                         // FX operations
    DWORD       dwROP;                          // Win32 raster operations
    DWORD       dwDDROP;                        // Raster operations new for DirectDraw
    DWORD       dwRotationAngle;                // Rotation angle for blt
    DWORD       dwZBufferOpCode;                // ZBuffer compares
    DWORD       dwZBufferLow;                   // Low limit of Z buffer
    DWORD       dwZBufferHigh;                  // High limit of Z buffer
    DWORD       dwZBufferBaseDest;              // Destination base value
    DWORD       dwZDestConstBitDepth;           // Bit depth used to specify Z constant for destination
    union
    {
        DWORD   dwZDestConst;                   // Constant to use as Z buffer for dest
        LPDIRECTDRAWSURFACE lpDDSZBufferDest;   // Surface to use as Z buffer for dest
    };
    DWORD       dwZSrcConstBitDepth;            // Bit depth used to specify Z constant for source
    union
    {
        DWORD   dwZSrcConst;                    // Constant to use as Z buffer for src
        LPDIRECTDRAWSURFACE lpDDSZBufferSrc;    // Surface to use as Z buffer for src
    };
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Alpha for edge blending
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as Alpha Channel
    };
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as Alpha Channel
    };
    union
    {
        DWORD   dwFillColor;                    // color in RGB or Palettized
        DWORD   dwFillDepth;                    // depth value for z-buffer
        LPDIRECTDRAWSURFACE lpDDSPattern;       // Surface to use as pattern
    };
    DDCOLORKEY  ddckDestColorkey;               // DestColorkey override
    DDCOLORKEY  ddckSrcColorkey;                // SrcColorkey override
} DDBLTFX;

typedef DDBLTFX FAR* LPDDBLTFX;


/*
 * DDSCAPS
 */
typedef struct _DDSCAPS
{
    DWORD       dwCaps;         // capabilities of surface wanted
} DDSCAPS;

typedef DDSCAPS FAR* LPDDSCAPS; 

/*
 * DDCAPS
 */
#define DD_ROP_SPACE            (256/32)        // space required to store ROP array

typedef struct _DDCAPS
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
    DWORD       dwSVBCaps;              // driver specific capabilities for System->Vmem blts
    DWORD       dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
    DWORD       dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
    DWORD       dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD       dwVSBCaps;              // driver specific capabilities for Vmem->System blts
    DWORD       dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
    DWORD       dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
    DWORD       dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD       dwSSBCaps;              // driver specific capabilities for System->System blts
    DWORD       dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
    DWORD       dwSSBFXCaps;            // driver FX capabilities for System->System blts
    DWORD       dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD       dwReserved4;            // reserved
    DWORD       dwReserved5;            // reserved
    DWORD       dwReserved6;            // reserved
} DDCAPS;

typedef DDCAPS FAR* LPDDCAPS;



/*
 * DDPIXELFORMAT
 */
typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
        DWORD   dwRGBBitCount;          // how many bits per pixel
        DWORD   dwYUVBitCount;          // how many bits per pixel
        DWORD   dwZBufferBitDepth;      // how many bits for z buffers
        DWORD   dwAlphaBitDepth;        // how many bits for alpha channels
    };
    union
    {
    DWORD   dwRBitMask;   // mask for red bit
    DWORD   dwYBitMask;   // mask for Y bits
    };
    union
    {
    DWORD   dwGBitMask;	  // mask for green bits
    DWORD   dwUBitMask;   // mask for U bits
    };
    union
    {
    DWORD   dwBBitMask;   // mask for blue bits
    DWORD   dwVBitMask;   // mask for V bits
    };
    union
    {
    DWORD   dwRGBAlphaBitMask; // mask for alpha channel
    DWORD   dwYUVAlphaBitMask; // mask for alpha channel
    };
} DDPIXELFORMAT;

typedef DDPIXELFORMAT FAR* LPDDPIXELFORMAT;

/*
 * DDOVERLAYFX
 */
typedef struct _DDOVERLAYFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Constant to use as alpha for edge blend
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as alpha channel for dest
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as alpha channel for dest
    };
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as alpha channel for src
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as alpha channel for src
    };
    DDCOLORKEY  dckDestColorkey;                // DestColorkey override
    DDCOLORKEY  dckSrcColorkey;                 // DestColorkey override
    DWORD       dwDDFX;                         // Overlay FX
    DWORD       dwFlags;                        // flags
} DDOVERLAYFX;

typedef DDOVERLAYFX FAR *LPDDOVERLAYFX;

/*
 * DDBLTBATCH: BltBatch entry structure
 */
typedef struct _DDBLTBATCH
{
    LPRECT              lprDest;
    LPDIRECTDRAWSURFACE lpDDSSrc;
    LPRECT              lprSrc;
    DWORD               dwFlags;
    LPDDBLTFX           lpDDBltFx;
} DDBLTBATCH;

typedef DDBLTBATCH FAR * LPDDBLTBATCH;

/*
 * callbacks
 */
typedef DWORD   (FAR PASCAL *LPCLIPPERCALLBACK)(LPDIRECTDRAWCLIPPER lpDDClipper, HWND hWnd, DWORD code, LPVOID lpContext );
#ifdef STREAMING
typedef DWORD   (FAR PASCAL *LPSURFACESTREAMINGCALLBACK)(DWORD);
#endif


/*
 * INTERACES FOLLOW:
 *      IDirectDraw
 *      IDirectDrawClipper
 *      IDirectDrawPalette
 *      IDirectDrawSurface
 */

/*
 * IDirectDraw 
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw
DECLARE_INTERFACE_( IDirectDraw, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->lpVtbl->SetDisplayMode(p, a, b, c)
#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw2
DECLARE_INTERFACE_( IDirectDraw2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw2_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw2_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw2_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw2_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw2_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw2_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw2_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw2_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw2_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw2_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw2_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#endif

#endif

/*
 * IDirectDrawPalette
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawPalette
DECLARE_INTERFACE_( IDirectDrawPalette, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawPalette methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD, LPPALETTEENTRY) PURE;
    STDMETHOD(SetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawPalette_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawPalette_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawPalette_GetCaps(p, a)                (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->lpVtbl->GetEntries(p, a, b, c, d)
#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->lpVtbl->Initialize(p, a, b, c)
#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->lpVtbl->SetEntries(p, a, b, c, d)
#endif

#endif

/*
 * IDirectDrawClipper
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawClipper
DECLARE_INTERFACE_( IDirectDrawClipper, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawClipper methods ***/
    STDMETHOD(GetClipList)(THIS_ LPRECT, LPRGNDATA, LPDWORD) PURE;
    STDMETHOD(GetHWnd)(THIS_ HWND FAR *) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD) PURE;
    STDMETHOD(IsClipListChanged)(THIS_ BOOL FAR *) PURE;
    STDMETHOD(SetClipList)(THIS_ LPRGNDATA,DWORD) PURE;
    STDMETHOD(SetHWnd)(THIS_ DWORD, HWND ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawClipper_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawClipper_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->lpVtbl->GetClipList(p, a, b, c)
#define IDirectDrawClipper_GetHWnd(p, a)            (p)->lpVtbl->GetHWnd(p, a)
#define IDirectDrawClipper_Initialize(p, a, b)      (p)->lpVtbl->Initialize(p, a, b)
#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->lpVtbl->IsClipListChanged(p, a)
#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->lpVtbl->SetClipList(p, a, b)
#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->lpVtbl->SetHWnd(p, a, b)
#endif

#endif

/*
 * IDirectDrawSurface and related interfaces
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawSurface
DECLARE_INTERFACE_( IDirectDrawSurface, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#endif

/*
 * IDirectDrawSurface2 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface2
DECLARE_INTERFACE_( IDirectDrawSurface2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE2, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE2, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE2, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE2 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE2,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE2) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface2_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface2_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface2_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface2_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface2_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface2_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface2_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface2_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface2_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface2_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface2_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#endif


#endif


/*
 * DDSURFACEDESC
 */
typedef struct _DDSURFACEDESC
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure
    DWORD               dwFlags;                // determines what fields are valid
    DWORD               dwHeight;               // height of surface to be created
    DWORD               dwWidth;                // width of input surface
    LONG                lPitch;                 // distance to start of next line (return value only)
    DWORD               dwBackBufferCount;      // number of back buffers requested
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requested
        DWORD           dwZBufferBitDepth;      // depth of Z buffer requested
        DWORD           dwRefreshRate;          // refresh rate (used when display mode is described)
    };
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested
    DWORD               dwReserved;             // reserved
    LPVOID              lpSurface;              // pointer to the associated surface memory
    DDCOLORKEY          ddckCKDestOverlay;      // color key for destination overlay use
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use
    DDPIXELFORMAT       ddpfPixelFormat;        // pixel format description of the surface
    DDSCAPS             ddsCaps;                // direct draw surface capabilities
} DDSURFACEDESC;

/*
 * ddsCaps field is valid.
 */
#define DDSD_CAPS               0x00000001l     // default

/*
 * dwHeight field is valid.
 */
#define DDSD_HEIGHT             0x00000002l

/*
 * dwWidth field is valid.
 */
#define DDSD_WIDTH              0x00000004l

/*
 * lPitch is valid.
 */
#define DDSD_PITCH              0x00000008l

/*
 * dwBackBufferCount is valid.
 */
#define DDSD_BACKBUFFERCOUNT    0x00000020l

/*
 * dwZBufferBitDepth is valid.
 */
#define DDSD_ZBUFFERBITDEPTH    0x00000040l

/*
 * dwAlphaBitDepth is valid.
 */
#define DDSD_ALPHABITDEPTH      0x00000080l



/*
 * ddpfPixelFormat is valid.
 */
#define DDSD_PIXELFORMAT        0x00001000l

/*
 * ddckCKDestOverlay is valid.
 */
#define DDSD_CKDESTOVERLAY      0x00002000l

/*
 * ddckCKDestBlt is valid.
 */
#define DDSD_CKDESTBLT          0x00004000l

/*
 * ddckCKSrcOverlay is valid.
 */
#define DDSD_CKSRCOVERLAY       0x00008000l

/*
 * ddckCKSrcBlt is valid.
 */
#define DDSD_CKSRCBLT           0x00010000l

/*
 * dwMipMapCount is valid.
 */
#define DDSD_MIPMAPCOUNT        0x00020000l

 /*
  * dwRefreshRate is valid
  */
#define DDSD_REFRESHRATE        0x00040000l

/*
 * All input fields are valid. 
 */
#define DDSD_ALL                0x0007f9eel


/*============================================================================
 *
 * Direct Draw Capability Flags
 *
 * These flags are used to describe the capabilities of a given Surface.
 * All flags are bit flags. 
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAWSURFACE CAPABILITY FLAGS
 *
 ****************************************************************************/
/*
 * This bit currently has no meaning.
 */
#define DDSCAPS_3D                              0x00000001l

/*
 * Indicates that this surface contains alpha information.  The pixel
 * format must be interrogated to determine whether this surface
 * contains only alpha information or alpha information interlaced
 * with pixel color data (e.g. RGBA or YUVA).
 */
#define DDSCAPS_ALPHA                           0x00000002l

/*
 * Indicates that this surface is a backbuffer.  It is generally
 * set by CreateSurface when the DDSCAPS_FLIP capability bit is set.
 * It indicates that this surface is THE back buffer of a surface
 * flipping structure.  DirectDraw supports N surfaces in a
 * surface flipping structure.  Only the surface that immediately
 * precedeces the DDSCAPS_FRONTBUFFER has this capability bit set.
 * The other surfaces are identified as back buffers by the presence
 * of the DDSCAPS_FLIP capability, their attachment order, and the
 * absence of the DDSCAPS_FRONTBUFFER and DDSCAPS_BACKBUFFER
 * capabilities.  The bit is sent to CreateSurface when a standalone
 * back buffer is being created.  This surface could be attached to
 * a front buffer and/or back buffers to form a flipping surface
 * structure after the CreateSurface call.  See AddAttachments for
 * a detailed description of the behaviors in this case.
 */
#define DDSCAPS_BACKBUFFER                      0x00000004l

/*
 * Indicates a complex surface structure is being described.  A
 * complex surface structure results in the creation of more than
 * one surface.  The additional surfaces are attached to the root
 * surface.  The complex structure can only be destroyed by
 * destroying the root.
 */
#define DDSCAPS_COMPLEX                         0x00000008l

/*
 * Indicates that this surface is a part of a surface flipping structure.
 * When it is passed to CreateSurface the DDSCAPS_FRONTBUFFER and
 * DDSCAP_BACKBUFFER bits are not set.  They are set by CreateSurface
 * on the resulting creations.  The dwBackBufferCount field in the
 * DDSURFACEDESC structure must be set to at least 1 in order for
 * the CreateSurface call to succeed.  The DDSCAPS_COMPLEX capability
 * must always be set with creating multiple surfaces through CreateSurface.
 */
#define DDSCAPS_FLIP                            0x00000010l

/*
 * Indicates that this surface is THE front buffer of a surface flipping
 * structure.  It is generally set by CreateSurface when the DDSCAPS_FLIP
 * capability bit is set.
 * If this capability is sent to CreateSurface then a standalonw front buffer
 * is created.  This surface will not have the DDSCAPS_FLIP capability.
 * It can be attached to other back buffers to form a flipping structure.
 * See AddAttachments for a detailed description of the behaviors in this
 * case.
 */
#define DDSCAPS_FRONTBUFFER                     0x00000020l

/*
 * Indicates that this surface is any offscreen surface that is not an overlay,
 * texture, zbuffer, front buffer, back buffer, or alpha surface.  It is used
 * to identify plain vanilla surfaces.
 */
#define DDSCAPS_OFFSCREENPLAIN                  0x00000040l

/*
 * Indicates that this surface is an overlay.  It may or may not be directly visible
 * depending on whether or not it is currently being overlayed onto the primary 
 * surface.  DDSCAPS_VISIBLE can be used to determine whether or not it is being 
 * overlayed at the moment. 
 */
#define DDSCAPS_OVERLAY                         0x00000080l

/*
 * Indicates that unique DirectDrawPalette objects can be created and
 * attached to this surface.
 */
#define DDSCAPS_PALETTE                         0x00000100l

/*
 * Indicates that this surface is the primary surface.  The primary
 * surface represents what the user is seeing at the moment.
 */
#define DDSCAPS_PRIMARYSURFACE                  0x00000200l

/*
 * Indicates that this surface is the primary surface for the left eye.
 * The primary surface for the left eye represents what the user is seeing
 * at the moment with the users left eye.  When this surface is created the
 * DDSCAPS_PRIMARYSURFACE represents what the user is seeing with the users
 * right eye.
 */
#define DDSCAPS_PRIMARYSURFACELEFT              0x00000400l

/*
 * Indicates that this surface memory was allocated in system memory
 */
#define DDSCAPS_SYSTEMMEMORY                    0x00000800l

/*
 * Indicates that this surface can be used as a 3D texture.  It does not
 * indicate whether or not the surface is being used for that purpose.
 */
#define DDSCAPS_TEXTURE                         0x00001000l

/*
 * Indicates that a surface may be a destination for 3D rendering.  This
 * bit must be set in order to query for a Direct3D Device Interface 
 * from this surface.
 */
#define DDSCAPS_3DDEVICE                        0x00002000l

/*
 * Indicates that this surface exists in video memory.
 */
#define DDSCAPS_VIDEOMEMORY                     0x00004000l

/*
 * Indicates that changes made to this surface are immediately visible.  
 * It is always set for the primary surface and is set for overlays while
 * they are being overlayed and texture maps while they are being textured.
 */
#define DDSCAPS_VISIBLE                         0x00008000l

/*
 * Indicates that only writes are permitted to the surface.  Read accesses 
 * from the surface may or may not generate a protection fault, but the 
 * results of a read from this surface will not be meaningful.  READ ONLY.
 */
#define DDSCAPS_WRITEONLY                       0x00010000l

/*
 * Indicates that this surface is a z buffer. A z buffer does not contain
 * displayable information.  Instead it contains bit depth information that is
 * used to determine which pixels are visible and which are obscured. 
 */
#define DDSCAPS_ZBUFFER                         0x00020000l

/*
 * Indicates surface will have a DC associated long term
 */
#define DDSCAPS_OWNDC                           0x00040000l

/*
 * Indicates surface should be able to receive live video
 */
#define DDSCAPS_LIVEVIDEO                       0x00080000l

/*
 * Indicates surface should be able to have a stream decompressed
 * to it by the hardware.
 */
#define DDSCAPS_HWCODEC                         0x00100000l

/*
 * Surface is a 320x200 or 320x240 ModeX surface
 */
#define DDSCAPS_MODEX                           0x00200000l

/*
 * Indicates surface is one level of a mip-map. This surface will
 * be attached to other DDSCAPS_MIPMAP surfaces to form the mip-map.
 * This can be done explicitly, by creating a number of surfaces and
 * attaching them with AddAttachedSurface or by implicitly by CreateSurface.
 * If this bit is set then DDSCAPS_TEXTURE must also be set.
 */
#define DDSCAPS_MIPMAP                          0x00400000l



/*
 * Indicates that memory for the surface is not allocated until the surface
 * is loaded (via the Direct3D texture Load() function).
 */
#define DDSCAPS_ALLOCONLOAD                     0x04000000l



 /****************************************************************************
 *
 * DIRECTDRAW DRIVER CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Display hardware has 3D acceleration.
 */
#define DDCAPS_3D                       0x00000001l

/*
 * Indicates that DirectDraw will support only dest rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundaryDest boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYDEST        0x00000002l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in 
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeDest multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZEDEST            0x00000004l
/*
 * Indicates that DirectDraw will support only source rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundarySrc boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYSRC         0x00000008l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in 
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeSrc multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZESRC             0x00000010l

/*
 * Indicates that DirectDraw will create video memory surfaces that have a stride 
 * alignment equal to DIRECTDRAWCAPS.dwAlignStride.  READ ONLY.
 */
#define DDCAPS_ALIGNSTRIDE              0x00000020l

/*
 * Display hardware is capable of blt operations.
 */
#define DDCAPS_BLT                      0x00000040l

/*
 * Display hardware is capable of asynchronous blt operations.
 */
#define DDCAPS_BLTQUEUE                 0x00000080l

/*
 * Display hardware is capable of color space conversions during the blt operation.
 */
#define DDCAPS_BLTFOURCC                0x00000100l

/*
 * Display hardware is capable of stretching during blt operations.
 */
#define DDCAPS_BLTSTRETCH               0x00000200l

/*
 * Display hardware is shared with GDI.
 */
#define DDCAPS_GDI                      0x00000400l

/*
 * Display hardware can overlay.
 */
#define DDCAPS_OVERLAY                  0x00000800l

/*
 * Set if display hardware supports overlays but can not clip them.
 */
#define DDCAPS_OVERLAYCANTCLIP          0x00001000l

/*
 * Indicates that overlay hardware is capable of color space conversions during
 * the overlay operation.
 */
#define DDCAPS_OVERLAYFOURCC            0x00002000l

/*
 * Indicates that stretching can be done by the overlay hardware.
 */
#define DDCAPS_OVERLAYSTRETCH           0x00004000l

/*
 * Indicates that unique DirectDrawPalettes can be created for DirectDrawSurfaces
 * other than the primary surface.
 */
#define DDCAPS_PALETTE                  0x00008000l

/*
 * Indicates that palette changes can be syncd with the veritcal refresh.
 */
#define DDCAPS_PALETTEVSYNC             0x00010000l

/*
 * Display hardware can return the current scan line.
 */
#define DDCAPS_READSCANLINE             0x00020000l

/*
 * Display hardware has stereo vision capabilities.  DDSCAPS_PRIMARYSURFACELEFT 
 * can be created.
 */
#define DDCAPS_STEREOVIEW               0x00040000l

/*
 * Display hardware is capable of generating a vertical blank interrupt.
 */
#define DDCAPS_VBI                      0x00080000l

/*
 * Supports the use of z buffers with blt operations.
 */
#define DDCAPS_ZBLTS                    0x00100000l

/*
 * Supports Z Ordering of overlays.
 */
#define DDCAPS_ZOVERLAYS                0x00200000l

/*
 * Supports color key
 */
#define DDCAPS_COLORKEY                 0x00400000l

/*
 * Supports alpha surfaces
 */
#define DDCAPS_ALPHA                    0x00800000l

/*
 * colorkey is hardware assisted(DDCAPS_COLORKEY will also be set)
 */
#define DDCAPS_COLORKEYHWASSIST         0x01000000l

/*
 * no hardware support at all
 */
#define DDCAPS_NOHARDWARE               0x02000000l

/*
 * Display hardware is capable of color fill with bltter
 */
#define DDCAPS_BLTCOLORFILL             0x04000000l

/*
 * Display hardware is bank switched, and potentially very slow at
 * random access to VRAM.
 */
#define DDCAPS_BANKSWITCHED             0x08000000l

/*
 * Display hardware is capable of depth filling Z-buffers with bltter
 */
#define DDCAPS_BLTDEPTHFILL             0x10000000l

/*
 * Display hardware is capable of clipping while bltting.
 */
#define DDCAPS_CANCLIP                  0x20000000l

/*
 * Display hardware is capable of clipping while stretch bltting.
 */
#define DDCAPS_CANCLIPSTRETCHED         0x40000000l

/*
 * Display hardware is capable of bltting to or from system memory
 */
#define DDCAPS_CANBLTSYSMEM             0x80000000l


 /****************************************************************************
 *
 * MORE DIRECTDRAW DRIVER CAPABILITY FLAGS (dwCaps2)
 *
 ****************************************************************************/

/*
 * Display hardware is certified
 */
#define DDCAPS2_CERTIFIED               0x00000001l

/*
 * Driver cannot interleave 2D operations (lock and blt) to surfaces with
 * Direct3D rendering operations between calls to BeginScene() and EndScene()
 */
#define DDCAPS2_NO2DDURING3DSCENE       0x00000002l

/****************************************************************************
 *
 * DIRECTDRAW FX ALPHA CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAEDGEBLEND         0x00000001l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha 
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELS            0x00000002l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha 
 * information in the pixel format can be 1,2,4, or 8.  The alpha value 
 * becomes more transparent as the alpha value increases.  (0 is opaque.) 
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELSNEG         0x00000004l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACES          0x00000008l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.  
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACESNEG       0x00000010l

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND     0x00000020l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha 
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELS        0x00000040l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha 
 * information in the pixel format can be 1,2,4, or 8.  The alpha value 
 * becomes more transparent as the alpha value increases.  (0 is opaque.) 
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG     0x00000080l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACES      0x00000100l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.  
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACESNEG   0x00000200l

/****************************************************************************
 *
 * DIRECTDRAW FX CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Uses arithmetic operations to stretch and shrink surfaces during blt
 * rather than pixel doubling techniques.  Along the Y axis.
 */
#define DDFXCAPS_BLTARITHSTRETCHY       0x00000020l

/*
 * Uses arithmetic operations to stretch during blt
 * rather than pixel doubling techniques.  Along the Y axis. Only
 * works for x1, x2, etc.
 */
#define DDFXCAPS_BLTARITHSTRETCHYN      0x00000010l

/*
 * Supports mirroring left to right in blt.
 */
#define DDFXCAPS_BLTMIRRORLEFTRIGHT     0x00000040l

/*
 * Supports mirroring top to bottom in blt.
 */
#define DDFXCAPS_BLTMIRRORUPDOWN        0x00000080l

/*
 * Supports arbitrary rotation for blts.
 */
#define DDFXCAPS_BLTROTATION            0x00000100l

/*
 * Supports 90 degree rotations for blts.
 */
#define DDFXCAPS_BLTROTATION90          0x00000200l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKX             0x00000400l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKXN            0x00000800l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for blts.  
 */
#define DDFXCAPS_BLTSHRINKY             0x00001000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.  
 */
#define DDFXCAPS_BLTSHRINKYN            0x00002000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHX            0x00004000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHXN           0x00008000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for blts.  
 */
#define DDFXCAPS_BLTSTRETCHY            0x00010000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.  
 */
#define DDFXCAPS_BLTSTRETCHYN           0x00020000l

/*
 * Uses arithmetic operations to stretch and shrink surfaces during 
 * overlay rather than pixel doubling techniques.  Along the Y axis 
 * for overlays.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHY   0x00040000l

/*
 * Uses arithmetic operations to stretch surfaces during 
 * overlay rather than pixel doubling techniques.  Along the Y axis 
 * for overlays. Only works for x1, x2, etc.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHYN  0x00000008l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKX         0x00080000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKXN        0x00100000l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for overlays.  
 */
#define DDFXCAPS_OVERLAYSHRINKY         0x00200000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.  
 */
#define DDFXCAPS_OVERLAYSHRINKYN        0x00400000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHX        0x00800000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHXN       0x01000000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for overlays.  
 */
#define DDFXCAPS_OVERLAYSTRETCHY        0x02000000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.  
 */
#define DDFXCAPS_OVERLAYSTRETCHYN       0x04000000l

/*
 * DirectDraw supports mirroring of overlays across the vertical axis
 */
#define DDFXCAPS_OVERLAYMIRRORLEFTRIGHT 0x08000000l

/*
 * DirectDraw supports mirroring of overlays across the horizontal axis
 */
#define DDFXCAPS_OVERLAYMIRRORUPDOWN    0x10000000l

/****************************************************************************
 *
 * DIRECTDRAW STEREO VIEW CAPABILITIES
 *
 ****************************************************************************/

/*
 * The stereo view is accomplished via enigma encoding.
 */
#define DDSVCAPS_ENIGMA                 0x00000001l

/*
 * The stereo view is accomplished via high frequency flickering.
 */
#define DDSVCAPS_FLICKER                0x00000002l

/*
 * The stereo view is accomplished via red and blue filters applied
 * to the left and right eyes.  All images must adapt their colorspaces
 * for this process.
 */
#define DDSVCAPS_REDBLUE                0x00000004l

/*
 * The stereo view is accomplished with split screen technology.
 */
#define DDSVCAPS_SPLIT                  0x00000008l

/****************************************************************************
 *
 * DIRECTDRAWPALETTE CAPABILITIES
 *
 ****************************************************************************/

/*
 * Index is 4 bits.  There are sixteen color entries in the palette table.
 */
#define DDPCAPS_4BIT                    0x00000001l

/*
 * Index is onto a 8 bit color index.  This field is only valid with the
 * DDPCAPS_1BIT, DDPCAPS_2BIT or DDPCAPS_4BIT capability and the target
 * surface is in 8bpp. Each color entry is one byte long and is an index
 * into destination surface's 8bpp palette.
 */
#define DDPCAPS_8BITENTRIES             0x00000002l

/*
 * Index is 8 bits.  There are 256 color entries in the palette table.
 */
#define DDPCAPS_8BIT                    0x00000004l

/*
 * Indicates that this DIRECTDRAWPALETTE should use the palette color array
 * passed into the lpDDColorArray parameter to initialize the DIRECTDRAWPALETTE
 * object.
 */
#define DDPCAPS_INITIALIZE              0x00000008l

/*
 * This palette is the one attached to the primary surface.  Changing this
 * table has immediate effect on the display unless DDPSETPAL_VSYNC is specified
 * and supported.
 */
#define DDPCAPS_PRIMARYSURFACE          0x00000010l

/*
 * This palette is the one attached to the primary surface left.  Changing
 * this table has immediate effect on the display for the left eye unless
 * DDPSETPAL_VSYNC is specified and supported.
 */
#define DDPCAPS_PRIMARYSURFACELEFT      0x00000020l

/*
 * This palette can have all 256 entries defined
 */
#define DDPCAPS_ALLOW256                0x00000040l

/*
 * This palette can have modifications to it synced with the monitors
 * refresh rate.
 */
#define DDPCAPS_VSYNC                   0x00000080l

/*
 * Index is 1 bit.  There are two color entries in the palette table.
 */
#define DDPCAPS_1BIT                    0x00000100l

/*
 * Index is 2 bit.  There are four color entries in the palette table.
 */
#define DDPCAPS_2BIT                    0x00000200l


/****************************************************************************
 *
 * DIRECTDRAWPALETTE SETENTRY CONSTANTS
 *
 ****************************************************************************/


/****************************************************************************
 *
 * DIRECTDRAWPALETTE GETENTRY CONSTANTS
 *
 ****************************************************************************/

/* 0 is the only legal value */

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPALETTE CONSTANTS
 *
 ****************************************************************************/


/****************************************************************************
 *
 * DIRECTDRAW BITDEPTH CONSTANTS
 *
 * NOTE:  These are only used to indicate supported bit depths.   These
 * are flags only, they are not to be used as an actual bit depth.   The
 * absolute numbers 1, 2, 4, 8, 16, 24 and 32 are used to indicate actual
 * bit depths in a surface or for changing the display mode.
 *
 ****************************************************************************/

/*
 * 1 bit per pixel.
 */
#define DDBD_1                  0x00004000l

/*
 * 2 bits per pixel.
 */
#define DDBD_2                  0x00002000l

/*
 * 4 bits per pixel.
 */
#define DDBD_4                  0x00001000l

/*
 * 8 bits per pixel.
 */
#define DDBD_8                  0x00000800l

/*
 * 16 bits per pixel.
 */
#define DDBD_16                 0x00000400l

/*
 * 24 bits per pixel.
 */
#define DDBD_24                 0X00000200l

/*
 * 32 bits per pixel.
 */
#define DDBD_32                 0x00000100l

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SET/GET COLOR KEY FLAGS
 *
 ****************************************************************************/

/*
 * Set if the structure contains a color space.  Not set if the structure
 * contains a single color key.
 */
#define DDCKEY_COLORSPACE       0x00000001l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for blt operations.
 */
#define DDCKEY_DESTBLT          0x00000002l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for overlay operations.
 */
#define DDCKEY_DESTOVERLAY      0x00000004l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for blt operations.
 */
#define DDCKEY_SRCBLT           0x00000008l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for overlay operations.
 */
#define DDCKEY_SRCOVERLAY       0x00000010l


/****************************************************************************
 *
 * DIRECTDRAW COLOR KEY CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports transparent blting using a color key to identify the replaceable 
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLT                      0x00000001l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACE              0x00000002l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACEYUV           0x00000004l

/*
 * Supports transparent blting using a color key to identify the replaceable 
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTYUV                   0x00000008l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the surface
 * being overlayed for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAY                  0x00000010l

/*
 * Supports a color space as the color key for the destination for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACE          0x00000020l

/*
 * Supports a color space as the color key for the destination for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV       0x00000040l

/*
 * Supports only one active destination color key value for visible overlay
 * surfaces.
 */
#define DDCKEYCAPS_DESTOVERLAYONEACTIVE         0x00000080l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the 
 * surface being overlayed for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYYUV               0x00000100l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLT                       0x00000200l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACE               0x00000400l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACEYUV            0x00000800l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTYUV                    0x00001000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAY                   0x00002000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACE           0x00004000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV        0x00008000l

/*
 * Supports only one active source color key value for visible
 * overlay surfaces.
 */
#define DDCKEYCAPS_SRCOVERLAYONEACTIVE          0x00010000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYYUV                0x00020000l

/*
 * there are no bandwidth trade-offs for using colorkey with an overlay
 */
#define DDCKEYCAPS_NOCOSTOVERLAY                0x00040000l


/****************************************************************************
 *
 * DIRECTDRAW PIXELFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * The surface has alpha channel information in the pixel format.
 */
#define DDPF_ALPHAPIXELS                        0x00000001l

/*
 * The pixel format contains alpha only information
 */
#define DDPF_ALPHA                              0x00000002l

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l

/*
 * The surface is 4-bit color indexed.
 */
#define DDPF_PALETTEINDEXED4                    0x00000008l

/*
 * The surface is indexed into a palette which stores indices
 * into the destination surface's 8-bit palette.
 */
#define DDPF_PALETTEINDEXEDTO8                  0x00000010l

/*
 * The surface is 8-bit color indexed.
 */
#define DDPF_PALETTEINDEXED8                    0x00000020l

/*
 * The RGB data in the pixel format structure is valid.
 */
#define DDPF_RGB                                0x00000040l

/*
 * The surface will accept pixel data in the format specified
 * and compress it during the write.
 */
#define DDPF_COMPRESSED                         0x00000080l

/*
 * The surface will accept RGB data and translate it during
 * the write to YUV data.  The format of the data to be written
 * will be contained in the pixel format structure.  The DDPF_RGB
 * flag will be set. 
 */
#define DDPF_RGBTOYUV                           0x00000100l

/*
 * pixel format is YUV - YUV data in pixel format struct is valid
 */
#define DDPF_YUV                                0x00000200l

/*
 * pixel format is a z buffer only surface
 */
#define DDPF_ZBUFFER                            0x00000400l

/*
 * The surface is 1-bit color indexed.
 */
#define DDPF_PALETTEINDEXED1                    0x00000800l

/*
 * The surface is 2-bit color indexed.
 */
#define DDPF_PALETTEINDEXED2                    0x00001000l

/*===========================================================================
 *
 *
 * DIRECTDRAW CALLBACK FLAGS
 *
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAW ENUMSURFACES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate all of the surfaces that meet the search criterion.
 */
#define DDENUMSURFACES_ALL                      0x00000001l

/*
 * A search hit is a surface that matches the surface description.
 */
#define DDENUMSURFACES_MATCH                    0x00000002l

/*
 * A search hit is a surface that does not match the surface description.
 */
#define DDENUMSURFACES_NOMATCH                  0x00000004l

/*
 * Enumerate the first surface that can be created which meets the search criterion.
 */
#define DDENUMSURFACES_CANBECREATED             0x00000008l

/*
 * Enumerate the surfaces that already exist that meet the search criterion.
 */
#define DDENUMSURFACES_DOESEXIST                0x00000010l


/****************************************************************************
 *
 * DIRECTDRAW ENUMDISPLAYMODES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate Modes with different refresh rates.  EnumDisplayModes guarantees
 * that a particular mode will be enumerated only once.  This flag specifies whether
 * the refresh rate is taken into account when determining if a mode is unique.
 */
#define DDEDM_REFRESHRATES                      0x00000001l


/****************************************************************************
 *
 * DIRECTDRAW SETCOOPERATIVELEVEL FLAGS
 *
 ****************************************************************************/

/*
 * Exclusive mode owner will be responsible for the entire primary surface.
 * GDI can be ignored. used with DD
 */
#define DDSCL_FULLSCREEN                        0x00000001l

/*
 * allow CTRL_ALT_DEL to work while in fullscreen exclusive mode 
 */
#define DDSCL_ALLOWREBOOT                       0x00000002l

/*
 * prevents DDRAW from modifying the application window.
 * prevents DDRAW from minimize/restore the application window on activation.
 */
#define DDSCL_NOWINDOWCHANGES                   0x00000004l

/*
 * app wants to work as a regular Windows application
 */
#define DDSCL_NORMAL                            0x00000008l

/*
 * app wants exclusive access
 */
#define DDSCL_EXCLUSIVE                         0x00000010l


/*
 * app can deal with non-windows display modes
 */
#define DDSCL_ALLOWMODEX                        0x00000040l


/****************************************************************************
 *
 * DIRECTDRAW BLT FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHADEST                         0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDBLTFX structure as the alpha channel
 * for the destination surface for this blt.
 */
#define DDBLT_ALPHADESTCONSTOVERRIDE            0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHADESTNEG                      0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDBLTFX structure as the alpha
 * channel for the destination for this blt.
 */
#define DDBLT_ALPHADESTSURFACEOVERRIDE          0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDBLTFX structure as the alpha channel
 * for the edges of the image that border the color key colors.
 */
#define DDBLT_ALPHAEDGEBLEND                    0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHASRC                          0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCCONSTOVERRIDE             0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHASRCNEG                       0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt. 
 */
#define DDBLT_ALPHASRCSURFACEOVERRIDE           0x00000100l

/*
 * Do this blt asynchronously through the FIFO in the order received.  If
 * there is no room in the hardware FIFO fail the call.
 */
#define DDBLT_ASYNC                             0x00000200l

/*
 * Uses the dwFillColor field in the DDBLTFX structure as the RGB color
 * to fill the destination rectangle on the destination surface with.
 */
#define DDBLT_COLORFILL                         0x00000400l

/*
 * Uses the dwDDFX field in the DDBLTFX structure to specify the effects
 * to use for the blt.
 */
#define DDBLT_DDFX                              0x00000800l

/*
 * Uses the dwDDROPS field in the DDBLTFX structure to specify the ROPS
 * that are not part of the Win32 API.
 */
#define DDBLT_DDROPS                            0x00001000l

/*
 * Use the color key associated with the destination surface.
 */
#define DDBLT_KEYDEST                           0x00002000l

/*
 * Use the dckDestColorkey field in the DDBLTFX structure as the color key
 * for the destination surface.
 */
#define DDBLT_KEYDESTOVERRIDE                   0x00004000l

/*
 * Use the color key associated with the source surface.
 */
#define DDBLT_KEYSRC                            0x00008000l

/*
 * Use the dckSrcColorkey field in the DDBLTFX structure as the color key
 * for the source surface.
 */
#define DDBLT_KEYSRCOVERRIDE                    0x00010000l

/*
 * Use the dwROP field in the DDBLTFX structure for the raster operation
 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
 */
#define DDBLT_ROP                               0x00020000l

/*
 * Use the dwRotationAngle field in the DDBLTFX structure as the angle
 * (specified in 1/100th of a degree) to rotate the surface.
 */
#define DDBLT_ROTATIONANGLE                     0x00040000l

/*
 * Z-buffered blt using the z-buffers attached to the source and destination
 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
 * z-buffer opcode.
 */
#define DDBLT_ZBUFFER                           0x00080000l

/*
 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the destination.
 */
#define DDBLT_ZBUFFERDESTCONSTOVERRIDE          0x00100000l

/*
 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the destination.
 */
#define DDBLT_ZBUFFERDESTOVERRIDE               0x00200000l

/*
 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the source.
 */
#define DDBLT_ZBUFFERSRCCONSTOVERRIDE           0x00400000l

/*
 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the source.
 */
#define DDBLT_ZBUFFERSRCOVERRIDE                0x00800000l

/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */
#define DDBLT_WAIT                              0x01000000l

/*
 * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
 * to fill the destination rectangle on the destination Z-buffer surface
 * with.
 */
#define DDBLT_DEPTHFILL                         0x02000000l


/****************************************************************************
 *
 * BLTFAST FLAGS
 *
 ****************************************************************************/

#define DDBLTFAST_NOCOLORKEY                    0x00000000
#define DDBLTFAST_SRCCOLORKEY                   0x00000001
#define DDBLTFAST_DESTCOLORKEY                  0x00000002
#define DDBLTFAST_WAIT                          0x00000010

/****************************************************************************
 *
 * FLIP FLAGS
 *
 ****************************************************************************/

#define DDFLIP_WAIT                          0x00000001l


/****************************************************************************
 *
 * DIRECTDRAW SURFACE OVERLAY FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for the
 * destination overlay.
 */
#define DDOVER_ALPHADEST                        0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDOVERLAYFX structure as the
 * destination alpha channel for this overlay.
 */
#define DDOVER_ALPHADESTCONSTOVERRIDE           0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. 
 */
#define DDOVER_ALPHADESTNEG                     0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDOVERLAYFX structure as the alpha
 * channel destination for this overlay.
 */
#define DDOVER_ALPHADESTSURFACEOVERRIDE         0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDOVERLAYFX structure as the alpha
 * channel for the edges of the image that border the color key colors.
 */
#define DDOVER_ALPHAEDGEBLEND                   0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the source alpha channel for this overlay.
 */
#define DDOVER_ALPHASRC                         0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDOVERLAYFX structure as the source
 * alpha channel for this overlay.
 */
#define DDOVER_ALPHASRCCONSTOVERRIDE            0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases.
 */
#define DDOVER_ALPHASRCNEG                      0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDOVERLAYFX structure as the alpha channel
 * source for this overlay.
 */
#define DDOVER_ALPHASRCSURFACEOVERRIDE          0x00000100l

/*
 * Turn this overlay off.
 */
#define DDOVER_HIDE                             0x00000200l

/*
 * Use the color key associated with the destination surface.
 */
#define DDOVER_KEYDEST                          0x00000400l

/*
 * Use the dckDestColorkey field in the DDOVERLAYFX structure as the color key
 * for the destination surface
 */
#define DDOVER_KEYDESTOVERRIDE                  0x00000800l

/*
 * Use the color key associated with the source surface.
 */
#define DDOVER_KEYSRC                           0x00001000l

/*
 * Use the dckSrcColorkey field in the DDOVERLAYFX structure as the color key
 * for the source surface.
 */
#define DDOVER_KEYSRCOVERRIDE                   0x00002000l

/*
 * Turn this overlay on.
 */
#define DDOVER_SHOW                             0x00004000l

/*
 * Add a dirty rect to an emulated overlayed surface.
 */
#define DDOVER_ADDDIRTYRECT                     0x00008000l

/*
 * Redraw all dirty rects on an emulated overlayed surface.
 */
#define DDOVER_REFRESHDIRTYRECTS                0x00010000l

/*
 * Redraw the entire surface on an emulated overlayed surface.
 */
#define DDOVER_REFRESHALL                      0x00020000l


/*
 * Use the overlay FX flags to define special overlay FX
 */
#define DDOVER_DDFX                             0x00080000l


/****************************************************************************
 *
 * DIRECTDRAWSURFACE LOCK FLAGS
 *
 ****************************************************************************/

/*
 * The default.  Set to indicate that Lock should return a valid memory pointer
 * to the top of the specified rectangle.  If no rectangle is specified then a
 * pointer to the top of the surface is returned.
 */
#define DDLOCK_SURFACEMEMORYPTR                 0x00000000L     // default

/*
 * Set to indicate that Lock should wait until it can obtain a valid memory
 * pointer before returning.  If this bit is set, Lock will never return 
 * DDERR_WASSTILLDRAWING.
 */
#define DDLOCK_WAIT                             0x00000001L

/*
 * Set if an event handle is being passed to Lock.  Lock will trigger the event
 * when it can return the surface memory pointer requested.
 */
#define DDLOCK_EVENT                            0x00000002L

/*
 * Indicates that the surface being locked will only be read from.
 */
#define DDLOCK_READONLY                         0x00000010L

/*
 * Indicates that the surface being locked will only be written to
 */
#define DDLOCK_WRITEONLY                        0x00000020L


/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGELOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGEUNLOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE BLT FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this blt.
 */
#define DDBLTFX_ARITHSTRETCHY                   0x00000001l

/*
 * Do this blt mirroring the surface left to right.  Spin the
 * surface around its y-axis.
 */
#define DDBLTFX_MIRRORLEFTRIGHT                 0x00000002l

/*
 * Do this blt mirroring the surface up and down.  Spin the surface
 * around its x-axis.
 */
#define DDBLTFX_MIRRORUPDOWN                    0x00000004l

/*
 * Schedule this blt to avoid tearing.
 */
#define DDBLTFX_NOTEARING                       0x00000008l

/*
 * Do this blt rotating the surface one hundred and eighty degrees.
 */
#define DDBLTFX_ROTATE180                       0x00000010l

/*
 * Do this blt rotating the surface two hundred and seventy degrees.
 */
#define DDBLTFX_ROTATE270                       0x00000020l

/*
 * Do this blt rotating the surface ninety degrees.
 */
#define DDBLTFX_ROTATE90                        0x00000040l

/*
 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
 * specified to limit the bits copied from the source surface.
 */
#define DDBLTFX_ZBUFFERRANGE                    0x00000080l

/*
 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
 * before comparing it with the desting z values.
 */
#define DDBLTFX_ZBUFFERBASEDEST                 0x00000100l

/****************************************************************************
 *
 * DIRECTDRAWSURFACE OVERLAY FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this overlay.
 */
#define DDOVERFX_ARITHSTRETCHY                  0x00000001l

/*
 * Mirror the overlay across the vertical axis
 */
#define DDOVERFX_MIRRORLEFTRIGHT                0x00000002l

/*
 * Mirror the overlay across the horizontal axis
 */
#define DDOVERFX_MIRRORUPDOWN                   0x00000004l

/****************************************************************************
 *
 * DIRECTDRAW WAITFORVERTICALBLANK FLAGS
 *
 ****************************************************************************/

/*
 * return when the vertical blank interval begins
 */
#define DDWAITVB_BLOCKBEGIN                     0x00000001l

/*
 * set up an event to trigger when the vertical blank begins
 */
#define DDWAITVB_BLOCKBEGINEVENT                0x00000002l

/*
 * return when the vertical blank interval ends and display begins
 */
#define DDWAITVB_BLOCKEND                       0x00000004l

/****************************************************************************
 *
 * DIRECTDRAW GETFLIPSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to flip now?
 */
#define DDGFS_CANFLIP                   0x00000001l

/*
 * is the last flip finished?
 */
#define DDGFS_ISFLIPDONE                0x00000002l

/****************************************************************************
 *
 * DIRECTDRAW GETBLTSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to blt now?
 */
#define DDGBS_CANBLT                    0x00000001l

/*
 * is the blt to the surface finished?
 */
#define DDGBS_ISBLTDONE                 0x00000002l


/****************************************************************************
 *
 * DIRECTDRAW ENUMOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate overlays back to front.
 */
#define DDENUMOVERLAYZ_BACKTOFRONT      0x00000000l

/*
 * Enumerate overlays front to back
 */
#define DDENUMOVERLAYZ_FRONTTOBACK      0x00000001l

/****************************************************************************
 *
 * DIRECTDRAW UPDATEOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Send overlay to front
 */
#define DDOVERZ_SENDTOFRONT             0x00000000l

/*
 * Send overlay to back
 */
#define DDOVERZ_SENDTOBACK              0x00000001l

/*
 * Move Overlay forward
 */
#define DDOVERZ_MOVEFORWARD             0x00000002l

/*
 * Move Overlay backward
 */
#define DDOVERZ_MOVEBACKWARD            0x00000003l

/*
 * Move Overlay in front of relative surface
 */
#define DDOVERZ_INSERTINFRONTOF         0x00000004l

/*
 * Move Overlay in back of relative surface
 */
#define DDOVERZ_INSERTINBACKOF          0x00000005l

/*===========================================================================
 *
 *
 * DIRECTDRAW RETURN CODES
 *
 * The return values from DirectDraw Commands and Surface that return an HRESULT
 * are codes from DirectDraw concerning the results of the action
 * requested by DirectDraw.
 *
 *==========================================================================*/

/*
 * Status is OK
 *
 * Issued by: DirectDraw Commands and all callbacks
 */
#define DD_OK                                   0

/****************************************************************************
 *
 * DIRECTDRAW ENUMCALLBACK RETURN VALUES
 *
 * EnumCallback returns are used to control the flow of the DIRECTDRAW and
 * DIRECTDRAWSURFACE object enumerations.   They can only be returned by
 * enumeration callback routines.
 *
 ****************************************************************************/

/*
 * stop the enumeration
 */
#define DDENUMRET_CANCEL                        0

/*
 * continue the enumeration
 */
#define DDENUMRET_OK                            1

/****************************************************************************
 *
 * DIRECTDRAW ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

/*
 * This object is already initialized
 */
#define DDERR_ALREADYINITIALIZED                MAKE_DDHRESULT( 5 )

/*
 * This surface can not be attached to the requested surface.
 */
#define DDERR_CANNOTATTACHSURFACE               MAKE_DDHRESULT( 10 )

/*
 * This surface can not be detached from the requested surface.
 */
#define DDERR_CANNOTDETACHSURFACE               MAKE_DDHRESULT( 20 )

/*
 * Support is currently not available.
 */
#define DDERR_CURRENTLYNOTAVAIL                 MAKE_DDHRESULT( 40 )

/*
 * An exception was encountered while performing the requested operation
 */
#define DDERR_EXCEPTION                         MAKE_DDHRESULT( 55 )

/*
 * Generic failure.
 */
#define DDERR_GENERIC                           E_FAIL

/*
 * Height of rectangle provided is not a multiple of reqd alignment
 */
#define DDERR_HEIGHTALIGN                       MAKE_DDHRESULT( 90 )

/*
 * Unable to match primary surface creation request with existing 
 * primary surface.
 */
#define DDERR_INCOMPATIBLEPRIMARY               MAKE_DDHRESULT( 95 )

/*
 * One or more of the caps bits passed to the callback are incorrect.
 */
#define DDERR_INVALIDCAPS                       MAKE_DDHRESULT( 100 )

/*
 * DirectDraw does not support provided Cliplist.
 */
#define DDERR_INVALIDCLIPLIST                   MAKE_DDHRESULT( 110 )

/*
 * DirectDraw does not support the requested mode
 */
#define DDERR_INVALIDMODE                       MAKE_DDHRESULT( 120 )

/*
 * DirectDraw received a pointer that was an invalid DIRECTDRAW object.
 */
#define DDERR_INVALIDOBJECT                     MAKE_DDHRESULT( 130 )

/*
 * One or more of the parameters passed to the callback function are
 * incorrect.
 */
#define DDERR_INVALIDPARAMS                     E_INVALIDARG

/*
 * pixel format was invalid as specified
 */
#define DDERR_INVALIDPIXELFORMAT                MAKE_DDHRESULT( 145 )

/*
 * Rectangle provided was invalid.
 */
#define DDERR_INVALIDRECT                       MAKE_DDHRESULT( 150 )

/*
 * Operation could not be carried out because one or more surfaces are locked
 */
#define DDERR_LOCKEDSURFACES                    MAKE_DDHRESULT( 160 )

/*
 * There is no 3D present.
 */
#define DDERR_NO3D                              MAKE_DDHRESULT( 170 )

/*
 * Operation could not be carried out because there is no alpha accleration
 * hardware present or available.
 */
#define DDERR_NOALPHAHW                         MAKE_DDHRESULT( 180 )


/*
 * no clip list available
 */
#define DDERR_NOCLIPLIST                        MAKE_DDHRESULT( 205 )

/*
 * Operation could not be carried out because there is no color conversion
 * hardware present or available.
 */
#define DDERR_NOCOLORCONVHW                     MAKE_DDHRESULT( 210 )

/*
 * Create function called without DirectDraw object method SetCooperativeLevel
 * being called.
 */
#define DDERR_NOCOOPERATIVELEVELSET             MAKE_DDHRESULT( 212 )

/*
 * Surface doesn't currently have a color key
 */
#define DDERR_NOCOLORKEY                        MAKE_DDHRESULT( 215 )

/*
 * Operation could not be carried out because there is no hardware support
 * of the dest color key.
 */
#define DDERR_NOCOLORKEYHW                      MAKE_DDHRESULT( 220 )

/*
 * No DirectDraw support possible with current display driver
 */
#define DDERR_NODIRECTDRAWSUPPORT               MAKE_DDHRESULT( 222 )

/*
 * Operation requires the application to have exclusive mode but the
 * application does not have exclusive mode.
 */
#define DDERR_NOEXCLUSIVEMODE                   MAKE_DDHRESULT( 225 )

/*
 * Flipping visible surfaces is not supported.
 */
#define DDERR_NOFLIPHW                          MAKE_DDHRESULT( 230 )

/*
 * There is no GDI present.
 */
#define DDERR_NOGDI                             MAKE_DDHRESULT( 240 )

/*
 * Operation could not be carried out because there is no hardware present
 * or available.
 */
#define DDERR_NOMIRRORHW                        MAKE_DDHRESULT( 250 )

/*
 * Requested item was not found
 */
#define DDERR_NOTFOUND                          MAKE_DDHRESULT( 255 )

/*
 * Operation could not be carried out because there is no overlay hardware
 * present or available.
 */
#define DDERR_NOOVERLAYHW                       MAKE_DDHRESULT( 260 )

/*
 * Operation could not be carried out because there is no appropriate raster
 * op hardware present or available.
 */
#define DDERR_NORASTEROPHW                      MAKE_DDHRESULT( 280 )

/*
 * Operation could not be carried out because there is no rotation hardware
 * present or available.
 */
#define DDERR_NOROTATIONHW                      MAKE_DDHRESULT( 290 )

/*
 * Operation could not be carried out because there is no hardware support
 * for stretching
 */
#define DDERR_NOSTRETCHHW                       MAKE_DDHRESULT( 310 )

/*
 * DirectDrawSurface is not in 4 bit color palette and the requested operation
 * requires 4 bit color palette.
 */
#define DDERR_NOT4BITCOLOR                      MAKE_DDHRESULT( 316 )

/*
 * DirectDrawSurface is not in 4 bit color index palette and the requested
 * operation requires 4 bit color index palette.
 */
#define DDERR_NOT4BITCOLORINDEX                 MAKE_DDHRESULT( 317 )

/*
 * DirectDraw Surface is not in 8 bit color mode and the requested operation
 * requires 8 bit color.
 */
#define DDERR_NOT8BITCOLOR                      MAKE_DDHRESULT( 320 )

/*
 * Operation could not be carried out because there is no texture mapping
 * hardware present or available.
 */
#define DDERR_NOTEXTUREHW                       MAKE_DDHRESULT( 330 )

/*
 * Operation could not be carried out because there is no hardware support
 * for vertical blank synchronized operations.
 */
#define DDERR_NOVSYNCHW                         MAKE_DDHRESULT( 335 )

/*
 * Operation could not be carried out because there is no hardware support
 * for zbuffer blting.
 */
#define DDERR_NOZBUFFERHW                       MAKE_DDHRESULT( 340 )

/*
 * Overlay surfaces could not be z layered based on their BltOrder because
 * the hardware does not support z layering of overlays.
 */
#define DDERR_NOZOVERLAYHW                      MAKE_DDHRESULT( 350 )

/*
 * The hardware needed for the requested operation has already been
 * allocated.
 */
#define DDERR_OUTOFCAPS                         MAKE_DDHRESULT( 360 )

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFMEMORY                       E_OUTOFMEMORY

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFVIDEOMEMORY                  MAKE_DDHRESULT( 380 )

/*
 * hardware does not support clipped overlays
 */
#define DDERR_OVERLAYCANTCLIP                   MAKE_DDHRESULT( 382 )

/*
 * Can only have ony color key active at one time for overlays
 */
#define DDERR_OVERLAYCOLORKEYONLYONEACTIVE      MAKE_DDHRESULT( 384 )

/*
 * Access to this palette is being refused because the palette is already
 * locked by another thread.
 */
#define DDERR_PALETTEBUSY                       MAKE_DDHRESULT( 387 )

/*
 * No src color key specified for this operation.
 */
#define DDERR_COLORKEYNOTSET                    MAKE_DDHRESULT( 400 )

/*
 * This surface is already attached to the surface it is being attached to.
 */
#define DDERR_SURFACEALREADYATTACHED            MAKE_DDHRESULT( 410 )

/*
 * This surface is already a dependency of the surface it is being made a
 * dependency of.
 */
#define DDERR_SURFACEALREADYDEPENDENT           MAKE_DDHRESULT( 420 )

/*
 * Access to this surface is being refused because the surface is already
 * locked by another thread.
 */
#define DDERR_SURFACEBUSY                       MAKE_DDHRESULT( 430 )

/*
 * Access to this surface is being refused because no driver exists
 * which can supply a pointer to the surface.
 * This is most likely to happen when attempting to lock the primary
 * surface when no DCI provider is present.
 */
#define DDERR_CANTLOCKSURFACE                   MAKE_DDHRESULT( 435 )

/*
 * Access to Surface refused because Surface is obscured.
 */
#define DDERR_SURFACEISOBSCURED                 MAKE_DDHRESULT( 440 )

/*
 * Access to this surface is being refused because the surface is gone.
 * The DIRECTDRAWSURFACE object representing this surface should 
 * have Restore called on it.
 */
#define DDERR_SURFACELOST                       MAKE_DDHRESULT( 450 )

/*
 * The requested surface is not attached.
 */
#define DDERR_SURFACENOTATTACHED                MAKE_DDHRESULT( 460 )

/*
 * Height requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGHEIGHT                      MAKE_DDHRESULT( 470 )

/*
 * Size requested by DirectDraw is too large --  The individual height and
 * width are OK.
 */
#define DDERR_TOOBIGSIZE                        MAKE_DDHRESULT( 480 )

/*
 * Width requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGWIDTH                       MAKE_DDHRESULT( 490 )

/*
 * Action not supported.
 */
#define DDERR_UNSUPPORTED                       E_NOTIMPL

/*
 * FOURCC format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDFORMAT                 MAKE_DDHRESULT( 510 )

/*
 * Bitmask in the pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDMASK                   MAKE_DDHRESULT( 520 )

/*
 * vertical blank is in progress
 */
#define DDERR_VERTICALBLANKINPROGRESS           MAKE_DDHRESULT( 537 )

/*
 * Informs DirectDraw that the previous Blt which is transfering information
 * to or from this Surface is incomplete.
 */
#define DDERR_WASSTILLDRAWING                   MAKE_DDHRESULT( 540 )

/*
 * Rectangle provided was not horizontally aligned on reqd. boundary
 */
#define DDERR_XALIGN                            MAKE_DDHRESULT( 560 )

/*
 * The GUID passed to DirectDrawCreate is not a valid DirectDraw driver
 * identifier.
 */
#define DDERR_INVALIDDIRECTDRAWGUID             MAKE_DDHRESULT( 561 )

/*
 * A DirectDraw object representing this driver has already been created
 * for this process.
 */
#define DDERR_DIRECTDRAWALREADYCREATED          MAKE_DDHRESULT( 562 )

/*
 * A hardware only DirectDraw object creation was attempted but the driver
 * did not support any hardware.
 */
#define DDERR_NODIRECTDRAWHW                    MAKE_DDHRESULT( 563 )

/*
 * this process already has created a primary surface
 */
#define DDERR_PRIMARYSURFACEALREADYEXISTS       MAKE_DDHRESULT( 564 )

/*
 * software emulation not available.
 */
#define DDERR_NOEMULATION                       MAKE_DDHRESULT( 565 )

/*
 * region passed to Clipper::GetClipList is too small.
 */
#define DDERR_REGIONTOOSMALL                    MAKE_DDHRESULT( 566 )

/*
 * an attempt was made to set a clip list for a clipper objec that
 * is already monitoring an hwnd.
 */
#define DDERR_CLIPPERISUSINGHWND                MAKE_DDHRESULT( 567 )

/*
 * No clipper object attached to surface object
 */
#define DDERR_NOCLIPPERATTACHED                 MAKE_DDHRESULT( 568 )

/*
 * Clipper notification requires an HWND or
 * no HWND has previously been set as the CooperativeLevel HWND.
 */
#define DDERR_NOHWND                            MAKE_DDHRESULT( 569 )

/*
 * HWND used by DirectDraw CooperativeLevel has been subclassed,
 * this prevents DirectDraw from restoring state.
 */
#define DDERR_HWNDSUBCLASSED                    MAKE_DDHRESULT( 570 )

/*
 * The CooperativeLevel HWND has already been set.
 * It can not be reset while the process has surfaces or palettes created.
 */
#define DDERR_HWNDALREADYSET                    MAKE_DDHRESULT( 571 )

/*
 * No palette object attached to this surface.
 */
#define DDERR_NOPALETTEATTACHED                 MAKE_DDHRESULT( 572 )

/*
 * No hardware support for 16 or 256 color palettes.
 */
#define DDERR_NOPALETTEHW                       MAKE_DDHRESULT( 573 )

/*
 * If a clipper object is attached to the source surface passed into a
 * BltFast call.
 */
#define DDERR_BLTFASTCANTCLIP                   MAKE_DDHRESULT( 574 )

/*
 * No blter.
 */
#define DDERR_NOBLTHW                           MAKE_DDHRESULT( 575 )

/*
 * No DirectDraw ROP hardware.
 */
#define DDERR_NODDROPSHW                        MAKE_DDHRESULT( 576 )

/*
 * returned when GetOverlayPosition is called on a hidden overlay
 */
#define DDERR_OVERLAYNOTVISIBLE                 MAKE_DDHRESULT( 577 )

/*
 * returned when GetOverlayPosition is called on a overlay that UpdateOverlay
 * has never been called on to establish a destionation.
 */
#define DDERR_NOOVERLAYDEST                     MAKE_DDHRESULT( 578 )

/*
 * returned when the position of the overlay on the destionation is no longer
 * legal for that destionation.
 */
#define DDERR_INVALIDPOSITION                   MAKE_DDHRESULT( 579 )

/*
 * returned when an overlay member is called for a non-overlay surface
 */
#define DDERR_NOTAOVERLAYSURFACE                MAKE_DDHRESULT( 580 )
 
/*
 * An attempt was made to set the cooperative level when it was already
 * set to exclusive.
 */
#define DDERR_EXCLUSIVEMODEALREADYSET           MAKE_DDHRESULT( 581 )

/*
 * An attempt has been made to flip a surface that is not flippable.
 */
#define DDERR_NOTFLIPPABLE                      MAKE_DDHRESULT( 582 )

/*
 * Can't duplicate primary & 3D surfaces, or surfaces that are implicitly
 * created.
 */
#define DDERR_CANTDUPLICATE                     MAKE_DDHRESULT( 583 )

/*
 * Surface was not locked.  An attempt to unlock a surface that was not
 * locked at all, or by this process, has been attempted.
 */
#define DDERR_NOTLOCKED                         MAKE_DDHRESULT( 584 )

/*
 * Windows can not create any more DCs
 */
#define DDERR_CANTCREATEDC                      MAKE_DDHRESULT( 585 )

/*
 * No DC was ever created for this surface.
 */
#define DDERR_NODC                              MAKE_DDHRESULT( 586 )

/*
 * This surface can not be restored because it was created in a different
 * mode.
 */
#define DDERR_WRONGMODE                         MAKE_DDHRESULT( 587 )

/*
 * This surface can not be restored because it is an implicitly created
 * surface.
 */
#define DDERR_IMPLICITLYCREATED                 MAKE_DDHRESULT( 588 )

/*
 * The surface being used is not a palette-based surface
 */
#define DDERR_NOTPALETTIZED                     MAKE_DDHRESULT( 589 )


/*
 * The display is currently in an unsupported mode
 */
#define DDERR_UNSUPPORTEDMODE                   MAKE_DDHRESULT( 590 )

/*
 * Operation could not be carried out because there is no mip-map
 * texture mapping hardware present or available.
 */
#define DDERR_NOMIPMAPHW                        MAKE_DDHRESULT( 591 )

/*
 * The requested action could not be performed because the surface was of
 * the wrong type.
 */
#define DDERR_INVALIDSURFACETYPE                MAKE_DDHRESULT( 592 )



/*
 * A DC has already been returned for this surface. Only one DC can be 
 * retrieved per surface.
 */
#define DDERR_DCALREADYCREATED                  MAKE_DDHRESULT( 620 )

/*
 * The attempt to page lock a surface failed.
 */
#define DDERR_CANTPAGELOCK                      MAKE_DDHRESULT( 640 )

/*
 * The attempt to page unlock a surface failed.
 */
#define DDERR_CANTPAGEUNLOCK                    MAKE_DDHRESULT( 660 )

/*
 * An attempt was made to page unlock a surface with no outstanding page locks.
 */
#define DDERR_NOTPAGELOCKED                     MAKE_DDHRESULT( 680 )

/*
 * An attempt was made to invoke an interface member of a DirectDraw object
 * created by CoCreateInstance() before it was initialized.
 */
#define DDERR_NOTINITIALIZED                    CO_E_NOTINITIALIZED

/* Alpha bit depth constants */


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\d3drmobj.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef _D3DRMOBJ_H_
#define _D3DRMOBJ_H_

#include <objbase.h> /* Use Windows header files */
#define VIRTUAL

#include "d3drmdef.h"
#include "d3d.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The methods for IUnknown
 */
#define IUNKNOWN_METHODS(kind) \
    STDMETHOD(QueryInterface)           (THIS_ REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD_(ULONG, AddRef)           (THIS) kind; \
    STDMETHOD_(ULONG, Release)          (THIS) kind

/*
 * The methods for IDirect3DRMObject
 */
#define IDIRECT3DRMOBJECT_METHODS(kind) \
    STDMETHOD(Clone)                    (THIS_ LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD(AddDestroyCallback)       (THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(DeleteDestroyCallback)    (THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(SetAppData)               (THIS_ DWORD data) kind; \
    STDMETHOD_(DWORD, GetAppData)       (THIS) kind; \
    STDMETHOD(SetName)                  (THIS_ LPCSTR) kind; \
    STDMETHOD(GetName)                  (THIS_ LPDWORD lpdwSize, LPSTR lpName) kind; \
    STDMETHOD(GetClassName)             (THIS_ LPDWORD lpdwSize, LPSTR lpName) kind


#define WIN_TYPES(itype, ptype) \
    typedef interface itype FAR *LP##ptype, FAR **LPLP##ptype

WIN_TYPES(IDirect3DRMObject, DIRECT3DRMOBJECT);
WIN_TYPES(IDirect3DRMDevice, DIRECT3DRMDEVICE);
WIN_TYPES(IDirect3DRMViewport, DIRECT3DRMVIEWPORT);
WIN_TYPES(IDirect3DRMFrame, DIRECT3DRMFRAME);
WIN_TYPES(IDirect3DRMVisual, DIRECT3DRMVISUAL);
WIN_TYPES(IDirect3DRMMesh, DIRECT3DRMMESH);
WIN_TYPES(IDirect3DRMMeshBuilder, DIRECT3DRMMESHBUILDER);
WIN_TYPES(IDirect3DRMFace, DIRECT3DRMFACE);
WIN_TYPES(IDirect3DRMLight, DIRECT3DRMLIGHT);
WIN_TYPES(IDirect3DRMTexture, DIRECT3DRMTEXTURE);
WIN_TYPES(IDirect3DRMWrap, DIRECT3DRMWRAP);
WIN_TYPES(IDirect3DRMMaterial, DIRECT3DRMMATERIAL);
WIN_TYPES(IDirect3DRMAnimation, DIRECT3DRMANIMATION);
WIN_TYPES(IDirect3DRMAnimationSet, DIRECT3DRMANIMATIONSET);
WIN_TYPES(IDirect3DRMUserVisual, DIRECT3DRMUSERVISUAL);
WIN_TYPES(IDirect3DRMShadow, DIRECT3DRMSHADOW);
WIN_TYPES(IDirect3DRMArray, DIRECT3DRMOBJECTARRAY);
WIN_TYPES(IDirect3DRMDeviceArray, DIRECT3DRMDEVICEARRAY);
WIN_TYPES(IDirect3DRMFaceArray, DIRECT3DRMFACEARRAY);
WIN_TYPES(IDirect3DRMViewportArray, DIRECT3DRMVIEWPORTARRAY);
WIN_TYPES(IDirect3DRMFrameArray, DIRECT3DRMFRAMEARRAY);
WIN_TYPES(IDirect3DRMVisualArray, DIRECT3DRMVISUALARRAY);
WIN_TYPES(IDirect3DRMPickedArray, DIRECT3DRMPICKEDARRAY);
WIN_TYPES(IDirect3DRMLightArray, DIRECT3DRMLIGHTARRAY);

/*
 * Direct3DRM Object classes
 */
DEFINE_GUID(CLSID_CDirect3DRMDevice,        0x4fa3568e, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMViewport,      0x4fa3568f, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFrame,         0x4fa35690, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMesh,          0x4fa35691, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMeshBuilder,   0x4fa35692, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFace,          0x4fa35693, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMLight,         0x4fa35694, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMTexture,       0x4fa35695, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMWrap,          0x4fa35696, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMaterial,      0x4fa35697, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimation,     0x4fa35698, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimationSet,  0x4fa35699, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMUserVisual,    0x4fa3569a, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMShadow,        0x4fa3569b, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

/*
 * Direct3DRM Object interfaces
 */
DEFINE_GUID(IID_IDirect3DRMObject,          0xeb16cb00, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMDevice,          0xe9e19280, 0x6e05, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewport,        0xeb16cb02, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrame,           0xeb16cb03, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMVisual,          0xeb16cb04, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMesh,            0xa3a80d01, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder,     0xa3a80d02, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFace,            0xeb16cb07, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLight,           0xeb16cb08, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture,         0xeb16cb09, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMWrap,            0xeb16cb0a, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial,        0xeb16cb0b, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimation,       0xeb16cb0d, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationSet,    0xeb16cb0e, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMDeviceArray,     0xeb16cb10, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewportArray,   0xeb16cb11, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrameArray,      0xeb16cb12, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMVisualArray,     0xeb16cb13, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLightArray,      0xeb16cb14, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMPickedArray,     0xeb16cb16, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFaceArray,       0xeb16cb17, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMUserVisual,      0x59163de0, 0x6d43, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow,          0xaf359780, 0x6ba3, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

typedef void (CDECL *D3DRMOBJECTCALLBACK)(LPDIRECT3DRMOBJECT obj, LPVOID arg);
typedef void (CDECL *D3DRMFRAMEMOVECALLBACK)(LPDIRECT3DRMFRAME obj, LPVOID arg, D3DVALUE delta);
typedef void (CDECL *D3DRMUPDATECALLBACK)(LPDIRECT3DRMDEVICE obj, LPVOID arg, int, LPD3DRECT);
typedef int (CDECL *D3DRMUSERVISUALCALLBACK)
    (   LPDIRECT3DRMUSERVISUAL obj, LPVOID arg, D3DRMUSERVISUALREASON reason,
        LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view
    );
typedef HRESULT (CDECL *D3DRMLOADTEXTURECALLBACK)
    (char *tex_name, void *arg, LPDIRECT3DRMTEXTURE *);
typedef void (CDECL *D3DRMLOADCALLBACK)
    (LPDIRECT3DRMOBJECT object, REFIID objectguid, LPVOID arg);



typedef struct _D3DRMPICKDESC
{
    ULONG       ulFaceIdx;
    LONG        lGroupIdx;
    D3DVECTOR   vPosition;

} D3DRMPICKDESC, *LPD3DRMPICKDESC;

#undef INTERFACE
#define INTERFACE IDirect3DRMObject

/*
 * Base class
 */
DECLARE_INTERFACE_(IDirect3DRMObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMVisual

DECLARE_INTERFACE_(IDirect3DRMVisual, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice

DECLARE_INTERFACE_(IDirect3DRMDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMViewport

DECLARE_INTERFACE_(IDirect3DRMViewport, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMViewport methods
     */
    STDMETHOD(Init)
    (   THIS_ LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMFRAME camera,
        DWORD xpos, DWORD ypos, DWORD width, DWORD height
    ) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMFRAME) PURE;

    STDMETHOD(SetFront)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetBack)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetField)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUniformScaling)(THIS_ BOOL) PURE;
    STDMETHOD(SetCamera)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(SetProjection)(THIS_ D3DRMPROJECTIONTYPE) PURE;
    STDMETHOD(Transform)(THIS_ D3DRMVECTOR4D *d, D3DVECTOR *s) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DRMVECTOR4D *s) PURE;
    STDMETHOD(Configure)(THIS_ LONG x, LONG y, DWORD width, DWORD height) PURE;
    STDMETHOD(ForceUpdate)(THIS_ DWORD x1, DWORD y1, DWORD x2, DWORD y2) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE left, D3DVALUE right, D3DVALUE bottom, D3DVALUE top) PURE;

    STDMETHOD(GetCamera)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DRMDEVICE *) PURE;
    STDMETHOD(GetPlane)(THIS_ D3DVALUE *left, D3DVALUE *right, D3DVALUE *bottom, D3DVALUE *top) PURE;
    STDMETHOD(Pick)(THIS_ LONG x, LONG y, LPDIRECT3DRMPICKEDARRAY *return_visuals) PURE;

    STDMETHOD_(BOOL, GetUniformScaling)(THIS) PURE;
    STDMETHOD_(LONG, GetX)(THIS) PURE;
    STDMETHOD_(LONG, GetY)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetField)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetBack)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetFront)(THIS) PURE;
    STDMETHOD_(D3DRMPROJECTIONTYPE, GetProjection)(THIS) PURE;
    STDMETHOD(GetDirect3DViewport)(THIS_ LPDIRECT3DVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame

DECLARE_INTERFACE_(IDirect3DRMFrame, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DRMMATRIX4D return_matrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDIRECT3DRMVISUALARRAY *visuals) PURE;
    STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME target, LPDIRECT3DRMFRAME reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (   THIS_ LPDIRECT3DRMFRAME reference,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMesh

DECLARE_INTERFACE_(IDirect3DRMMesh, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMesh methods
     */
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(AddGroup)(THIS_ unsigned vCount, unsigned fCount, unsigned vPerFace, unsigned *fData, D3DRMGROUPINDEX *returnId) PURE;
    STDMETHOD(SetVertices)(THIS_ D3DRMGROUPINDEX id, unsigned index, unsigned count, D3DRMVERTEX *values) PURE;
    STDMETHOD(SetGroupColor)(THIS_ D3DRMGROUPINDEX id, D3DCOLOR value) PURE;
    STDMETHOD(SetGroupColorRGB)(THIS_ D3DRMGROUPINDEX id, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetGroupMapping)(THIS_ D3DRMGROUPINDEX id, D3DRMMAPPING value) PURE;
    STDMETHOD(SetGroupQuality)(THIS_ D3DRMGROUPINDEX id, D3DRMRENDERQUALITY value) PURE;
    STDMETHOD(SetGroupMaterial)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMMATERIAL value) PURE;
    STDMETHOD(SetGroupTexture)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMTEXTURE value) PURE;

    STDMETHOD_(unsigned, GetGroupCount)(THIS) PURE;
    STDMETHOD(GetGroup)(THIS_ D3DRMGROUPINDEX id, unsigned *vCount, unsigned *fCount, unsigned *vPerFace, DWORD *fDataSize, unsigned *fData) PURE;
    STDMETHOD(GetVertices)(THIS_ D3DRMGROUPINDEX id, DWORD index, DWORD count, D3DRMVERTEX *returnPtr) PURE;
    STDMETHOD_(D3DCOLOR, GetGroupColor)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD_(D3DRMMAPPING, GetGroupMapping)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetGroupQuality)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD(GetGroupMaterial)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMMATERIAL *returnPtr) PURE;
    STDMETHOD(GetGroupTexture)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMTEXTURE *returnPtr) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMShadow

DECLARE_INTERFACE_(IDirect3DRMShadow, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMShadow methods
     */
    STDMETHOD(Init)
    (   THIS_ LPDIRECT3DRMVISUAL visual, LPDIRECT3DRMLIGHT light,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz
    ) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFace

DECLARE_INTERFACE_(IDirect3DRMFace, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFace methods
     */
     STDMETHOD(AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
     STDMETHOD(AddVertexAndNormalIndexed)(THIS_ DWORD vertex, DWORD normal) PURE;
     STDMETHOD(SetColorRGB)(THIS_ D3DVALUE, D3DVALUE, D3DVALUE) PURE;
     STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
     STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
     STDMETHOD(SetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE u, D3DVALUE v) PURE;
     STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
     STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;

     STDMETHOD(GetVertex)(THIS_ DWORD index, D3DVECTOR *vertex, D3DVECTOR *normal) PURE;
     STDMETHOD(GetVertices)(THIS_ DWORD *vertex_count, D3DVECTOR *coords, D3DVECTOR *normals);
     STDMETHOD(GetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE *u, D3DVALUE *v) PURE;
     STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
     STDMETHOD(GetNormal)(THIS_ D3DVECTOR *) PURE;
     STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
     STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL *) PURE;

     STDMETHOD_(int, GetVertexCount)(THIS) PURE;
     STDMETHOD_(int, GetVertexIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(int, GetTextureCoordinateIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(AddFaces)
    (   THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
        DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;

    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetVertices)
    (   THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;

    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE*) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;

    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMLight

DECLARE_INTERFACE_(IDirect3DRMLight, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMLight methods
     */
    STDMETHOD(SetType)(THIS_ D3DRMLIGHTTYPE) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetRange)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUmbra)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetPenumbra)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetConstantAttenuation)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetLinearAttenuation)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetQuadraticAttenuation)(THIS_ D3DVALUE) PURE;

    STDMETHOD_(D3DVALUE, GetRange)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetUmbra)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetPenumbra)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetConstantAttenuation)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetLinearAttenuation)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetQuadraticAttenuation)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD_(D3DRMLIGHTTYPE, GetType)(THIS) PURE;

    STDMETHOD(SetEnableFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(GetEnableFrame)(THIS_ LPDIRECT3DRMFRAME*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture

DECLARE_INTERFACE_(IDirect3DRMTexture, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ BOOL pixels, BOOL palette) PURE;

    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMWrap

DECLARE_INTERFACE_(IDirect3DRMWrap, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWrap methods
     */
    STDMETHOD(Init)
    (   THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME ref,
        D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
        D3DVALUE ou, D3DVALUE ov,
        D3DVALUE su, D3DVALUE sv
    ) PURE;
    STDMETHOD(Apply)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(ApplyRelative)(THIS_ LPDIRECT3DRMFRAME frame, LPDIRECT3DRMOBJECT) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMaterial

DECLARE_INTERFACE_(IDirect3DRMMaterial, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMaterial methods
     */
    STDMETHOD(SetPower)(THIS_ D3DVALUE power) PURE;
    STDMETHOD(SetSpecular)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD(SetEmissive)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;

    STDMETHOD_(D3DVALUE, GetPower)(THIS) PURE;
    STDMETHOD(GetSpecular)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetEmissive)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimation

DECLARE_INTERFACE_(IDirect3DRMAnimation, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimation methods
     */
    STDMETHOD(SetOptions)(THIS_ D3DRMANIMATIONOPTIONS flags) PURE;
    STDMETHOD(AddRotateKey)(THIS_ D3DVALUE time, D3DRMQUATERNION *q) PURE;
    STDMETHOD(AddPositionKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScaleKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(DeleteKey)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(SetFrame)(THIS_ LPDIRECT3DRMFRAME frame) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;

    STDMETHOD_(D3DRMANIMATIONOPTIONS, GetOptions)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationSet

DECLARE_INTERFACE_(IDirect3DRMAnimationSet, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimationSet methods
     */
    STDMETHOD(AddAnimation)(THIS_ LPDIRECT3DRMANIMATION aid) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg, LPDIRECT3DRMFRAME parent)PURE;
    STDMETHOD(DeleteAnimation)(THIS_ LPDIRECT3DRMANIMATION aid) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMUserVisual

DECLARE_INTERFACE_(IDirect3DRMUserVisual, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMUserVisual methods
     */
    STDMETHOD(Init)(THIS_ D3DRMUSERVISUALCALLBACK fn, void *arg) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMArray

DECLARE_INTERFACE_(IDirect3DRMArray, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    /* No GetElement method as it would get overloaded
     * in derived classes, and overloading is
     * a no-no in COM
     */
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDeviceArray

DECLARE_INTERFACE_(IDirect3DRMDeviceArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMDEVICE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrameArray

DECLARE_INTERFACE_(IDirect3DRMFrameArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMFRAME *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMViewportArray

DECLARE_INTERFACE_(IDirect3DRMViewportArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMVisualArray

DECLARE_INTERFACE_(IDirect3DRMVisualArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMPickedArray

DECLARE_INTERFACE_(IDirect3DRMPickedArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetPick)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *, LPDIRECT3DRMFRAMEARRAY *, LPD3DRMPICKDESC) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMLightArray

DECLARE_INTERFACE_(IDirect3DRMLightArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMLIGHT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFaceArray

DECLARE_INTERFACE_(IDirect3DRMFaceArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMFACE *) PURE;
};

#ifdef __cplusplus
};
#endif
#endif /* _D3DRMOBJ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\d3dtypes.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dtypes.h
 *  Content:    Direct3D types include file
 *
 ***************************************************************************/

#ifndef _D3DTYPES_H_
#define _D3DTYPES_H_

#ifndef WIN32
#include "subwtype.h"
#else
#include <windows.h>
#endif

#include <ddraw.h>

#pragma pack(4)

#if defined(__cplusplus)
extern "C"
{
#endif

/* D3DVALUE is the fundamental Direct3D fractional data type */

#define D3DVALP(val, prec) ((float)(val))
#define D3DVAL(val) ((float)(val))
typedef float D3DVALUE, *LPD3DVALUE;
#define D3DDivide(a, b)    (float)((double) (a) / (double) (b))
#define D3DMultiply(a, b)    ((a) * (b))

typedef LONG D3DFIXED;

#ifndef RGB_MAKE
/*
 * Format of CI colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |         color index           |   fraction    |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define CI_GETALPHA(ci)    ((ci) >> 24)
#define CI_GETINDEX(ci)    (((ci) >> 8) & 0xffff)
#define CI_GETFRACTION(ci) ((ci) & 0xff)
#define CI_ROUNDINDEX(ci)  CI_GETINDEX((ci) + 0x80)
#define CI_MASKALPHA(ci)   ((ci) & 0xffffff)
#define CI_MAKE(a, i, f)    (((a) << 24) | ((i) << 8) | (f))

/*
 * Format of RGBA colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGBA_GETALPHA(rgb)      ((rgb) >> 24)
#define RGBA_GETRED(rgb)        (((rgb) >> 16) & 0xff)
#define RGBA_GETGREEN(rgb)      (((rgb) >> 8) & 0xff)
#define RGBA_GETBLUE(rgb)       ((rgb) & 0xff)
#define RGBA_MAKE(r, g, b, a)   ((D3DCOLOR) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b)))

/* D3DRGB and D3DRGBA may be used as initialisers for D3DCOLORs
 * The float values must be in the range 0..1
 */
#define D3DRGB(r, g, b) \
    (0xff000000L | ( ((long)((r) * 255)) << 16) | (((long)((g) * 255)) << 8) | (long)((b) * 255))
#define D3DRGBA(r, g, b, a) \
    (   (((long)((a) * 255)) << 24) | (((long)((r) * 255)) << 16) \
    |   (((long)((g) * 255)) << 8) | (long)((b) * 255) \
    )

/*
 * Format of RGB colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    ignored    |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGB_GETRED(rgb)         (((rgb) >> 16) & 0xff)
#define RGB_GETGREEN(rgb)       (((rgb) >> 8) & 0xff)
#define RGB_GETBLUE(rgb)        ((rgb) & 0xff)
#define RGBA_SETALPHA(rgba, x) (((x) << 24) | ((rgba) & 0x00ffffff))
#define RGB_MAKE(r, g, b)       ((D3DCOLOR) (((r) << 16) | ((g) << 8) | (b)))
#define RGBA_TORGB(rgba)       ((D3DCOLOR) ((rgba) & 0xffffff))
#define RGB_TORGBA(rgb)        ((D3DCOLOR) ((rgb) | 0xff000000))

#endif

/*
 * Flags for Enumerate functions
 */

/*
 * Stop the enumeration
 */
#define D3DENUMRET_CANCEL                        DDENUMRET_CANCEL

/*
 * Continue the enumeration
 */
#define D3DENUMRET_OK                            DDENUMRET_OK

typedef HRESULT (WINAPI* LPD3DVALIDATECALLBACK)(LPVOID lpUserArg, DWORD dwOffset);
typedef HRESULT (WINAPI* LPD3DENUMTEXTUREFORMATSCALLBACK)(LPDDSURFACEDESC lpDdsd, LPVOID lpContext);

typedef DWORD D3DCOLOR, D3DCOLOR, *LPD3DCOLOR;

typedef DWORD D3DMATERIALHANDLE, *LPD3DMATERIALHANDLE;
typedef DWORD D3DTEXTUREHANDLE, *LPD3DTEXTUREHANDLE;
typedef DWORD D3DMATRIXHANDLE, *LPD3DMATRIXHANDLE;

typedef struct _D3DCOLORVALUE {
    union {
        D3DVALUE r;
        D3DVALUE dvR;
    };
    union {
        D3DVALUE g;
        D3DVALUE dvG;
    };
    union {
        D3DVALUE b;
        D3DVALUE dvB;
    };
    union {
        D3DVALUE a;
        D3DVALUE dvA;
    };
} D3DCOLORVALUE;

typedef struct _D3DRECT {
    union {
        LONG x1;
        LONG lX1;
    };
    union {
        LONG y1;
        LONG lY1;
    };
    union {
        LONG x2;
        LONG lX2;
    };
    union {
        LONG y2;
        LONG lY2;
    };
} D3DRECT, *LPD3DRECT;

typedef struct _D3DVECTOR {
    union {
        D3DVALUE x;
        D3DVALUE dvX;
    };
    union {
        D3DVALUE y;
        D3DVALUE dvY;
    };
    union {
        D3DVALUE z;
        D3DVALUE dvZ;
    };
} D3DVECTOR, *LPD3DVECTOR;


/*
 * Vertex data types supported in an ExecuteBuffer.
 */

/*
 * Homogeneous vertices
 */

typedef struct _D3DHVERTEX {
    DWORD           dwFlags;        /* Homogeneous clipping flags */
    union {
        D3DVALUE    hx;
        D3DVALUE    dvHX;
    };
    union {
        D3DVALUE    hy;
        D3DVALUE    dvHY;
    };
    union {
        D3DVALUE    hz;
        D3DVALUE    dvHZ;
    };
} D3DHVERTEX, *LPD3DHVERTEX;

/*
 * Transformed/lit vertices
 */
typedef struct _D3DTLVERTEX {
    union {
        D3DVALUE    sx;             /* Screen coordinates */
        D3DVALUE    dvSX;
    };
    union {
        D3DVALUE    sy;
        D3DVALUE    dvSY;
    };
    union {
        D3DVALUE    sz;
        D3DVALUE    dvSZ;
    };
    union {
        D3DVALUE    rhw;            /* Reciprocal of homogeneous w */
        D3DVALUE    dvRHW;
    };
    union {
        D3DCOLOR    color;          /* Vertex color */
        D3DCOLOR    dcColor;
    };
    union {
        D3DCOLOR    specular;       /* Specular component of vertex */
        D3DCOLOR    dcSpecular;
    };
    union {
        D3DVALUE    tu;             /* Texture coordinates */
        D3DVALUE    dvTU;
    };
    union {
        D3DVALUE    tv;
        D3DVALUE    dvTV;
    };
} D3DTLVERTEX, *LPD3DTLVERTEX;

/*
 * Untransformed/lit vertices
 */
typedef struct _D3DLVERTEX {
    union {
        D3DVALUE     x;             /* Homogeneous coordinates */
        D3DVALUE     dvX;
    };
    union {
        D3DVALUE     y;
        D3DVALUE     dvY;
    };
    union {
        D3DVALUE     z;
        D3DVALUE     dvZ;
    };
    DWORD            dwReserved;
    union {
        D3DCOLOR     color;         /* Vertex color */
        D3DCOLOR     dcColor;
    };
    union {
        D3DCOLOR     specular;      /* Specular component of vertex */
        D3DCOLOR     dcSpecular;
    };
    union {
        D3DVALUE     tu;            /* Texture coordinates */
        D3DVALUE     dvTU;
    };
    union {
        D3DVALUE     tv;
        D3DVALUE     dvTV;
    };
} D3DLVERTEX, *LPD3DLVERTEX;

/*
 * Untransformed/unlit vertices
 */

typedef struct _D3DVERTEX {
    union {
        D3DVALUE     x;             /* Homogeneous coordinates */
        D3DVALUE     dvX;
    };
    union {
        D3DVALUE     y;
        D3DVALUE     dvY;
    };
    union {
        D3DVALUE     z;
        D3DVALUE     dvZ;
    };
    union {
        D3DVALUE     nx;            /* Normal */
        D3DVALUE     dvNX;
    };
    union {
        D3DVALUE     ny;
        D3DVALUE     dvNY;
    };
    union {
        D3DVALUE     nz;
        D3DVALUE     dvNZ;
    };
    union {
        D3DVALUE     tu;            /* Texture coordinates */
        D3DVALUE     dvTU;
    };
    union {
        D3DVALUE     tv;
        D3DVALUE     dvTV;
    };
} D3DVERTEX, *LPD3DVERTEX;

/*
 * Matrix, viewport, and tranformation structures and definitions.
 */

typedef struct _D3DMATRIX {
    D3DVALUE        _11, _12, _13, _14;
    D3DVALUE        _21, _22, _23, _24;
    D3DVALUE        _31, _32, _33, _34;
    D3DVALUE        _41, _42, _43, _44;
} D3DMATRIX, *LPD3DMATRIX;

typedef struct _D3DVIEWPORT {
    DWORD       dwSize;
    DWORD       dwX;
    DWORD       dwY;            /* Top left */
    DWORD       dwWidth;
    DWORD       dwHeight;       /* Dimensions */
    D3DVALUE    dvScaleX;       /* Scale homogeneous to screen */
    D3DVALUE    dvScaleY;       /* Scale homogeneous to screen */
    D3DVALUE    dvMaxX;         /* Min/max homogeneous x coord */
    D3DVALUE    dvMaxY;         /* Min/max homogeneous y coord */
    D3DVALUE    dvMinZ;
    D3DVALUE    dvMaxZ;         /* Min/max homogeneous z coord */
} D3DVIEWPORT, *LPD3DVIEWPORT;

/*
 * Values for clip fields.
 */
#define D3DCLIP_LEFT                            0x00000001L
#define D3DCLIP_RIGHT                           0x00000002L
#define D3DCLIP_TOP                             0x00000004L
#define D3DCLIP_BOTTOM                          0x00000008L
#define D3DCLIP_FRONT                           0x00000010L
#define D3DCLIP_BACK                            0x00000020L
#define D3DCLIP_GEN0                            0x00000040L
#define D3DCLIP_GEN1                            0x00000080L
#define D3DCLIP_GEN2                            0x00000100L
#define D3DCLIP_GEN3                            0x00000200L
#define D3DCLIP_GEN4                            0x00000400L
#define D3DCLIP_GEN5                            0x00000800L

/*
 * Values for d3d status.
 */
#define D3DSTATUS_CLIPUNIONLEFT                 D3DCLIP_LEFT
#define D3DSTATUS_CLIPUNIONRIGHT                D3DCLIP_RIGHT
#define D3DSTATUS_CLIPUNIONTOP                  D3DCLIP_TOP
#define D3DSTATUS_CLIPUNIONBOTTOM               D3DCLIP_BOTTOM
#define D3DSTATUS_CLIPUNIONFRONT                D3DCLIP_FRONT
#define D3DSTATUS_CLIPUNIONBACK                 D3DCLIP_BACK
#define D3DSTATUS_CLIPUNIONGEN0                 D3DCLIP_GEN0
#define D3DSTATUS_CLIPUNIONGEN1                 D3DCLIP_GEN1
#define D3DSTATUS_CLIPUNIONGEN2                 D3DCLIP_GEN2
#define D3DSTATUS_CLIPUNIONGEN3                 D3DCLIP_GEN3
#define D3DSTATUS_CLIPUNIONGEN4                 D3DCLIP_GEN4
#define D3DSTATUS_CLIPUNIONGEN5                 D3DCLIP_GEN5

#define D3DSTATUS_CLIPINTERSECTIONLEFT          0x00001000L
#define D3DSTATUS_CLIPINTERSECTIONRIGHT         0x00002000L
#define D3DSTATUS_CLIPINTERSECTIONTOP           0x00004000L
#define D3DSTATUS_CLIPINTERSECTIONBOTTOM        0x00008000L
#define D3DSTATUS_CLIPINTERSECTIONFRONT         0x00010000L
#define D3DSTATUS_CLIPINTERSECTIONBACK          0x00020000L
#define D3DSTATUS_CLIPINTERSECTIONGEN0          0x00040000L
#define D3DSTATUS_CLIPINTERSECTIONGEN1          0x00080000L
#define D3DSTATUS_CLIPINTERSECTIONGEN2          0x00100000L
#define D3DSTATUS_CLIPINTERSECTIONGEN3          0x00200000L
#define D3DSTATUS_CLIPINTERSECTIONGEN4          0x00400000L
#define D3DSTATUS_CLIPINTERSECTIONGEN5          0x00800000L
#define D3DSTATUS_ZNOTVISIBLE                   0x01000000L

#define D3DSTATUS_CLIPUNIONALL  (               \
            D3DSTATUS_CLIPUNIONLEFT     |       \
            D3DSTATUS_CLIPUNIONRIGHT    |       \
            D3DSTATUS_CLIPUNIONTOP      |       \
            D3DSTATUS_CLIPUNIONBOTTOM   |       \
            D3DSTATUS_CLIPUNIONFRONT    |       \
            D3DSTATUS_CLIPUNIONBACK     |       \
            D3DSTATUS_CLIPUNIONGEN0     |       \
            D3DSTATUS_CLIPUNIONGEN1     |       \
            D3DSTATUS_CLIPUNIONGEN2     |       \
            D3DSTATUS_CLIPUNIONGEN3     |       \
            D3DSTATUS_CLIPUNIONGEN4     |       \
            D3DSTATUS_CLIPUNIONGEN5             \
            )

#define D3DSTATUS_CLIPINTERSECTIONALL   (               \
            D3DSTATUS_CLIPINTERSECTIONLEFT      |       \
            D3DSTATUS_CLIPINTERSECTIONRIGHT     |       \
            D3DSTATUS_CLIPINTERSECTIONTOP       |       \
            D3DSTATUS_CLIPINTERSECTIONBOTTOM    |       \
            D3DSTATUS_CLIPINTERSECTIONFRONT     |       \
            D3DSTATUS_CLIPINTERSECTIONBACK      |       \
            D3DSTATUS_CLIPINTERSECTIONGEN0      |       \
            D3DSTATUS_CLIPINTERSECTIONGEN1      |       \
            D3DSTATUS_CLIPINTERSECTIONGEN2      |       \
            D3DSTATUS_CLIPINTERSECTIONGEN3      |       \
            D3DSTATUS_CLIPINTERSECTIONGEN4      |       \
            D3DSTATUS_CLIPINTERSECTIONGEN5              \
            )

#define D3DSTATUS_DEFAULT       (                       \
            D3DSTATUS_CLIPINTERSECTIONALL       |       \
            D3DSTATUS_ZNOTVISIBLE)


/*
 * Options for direct transform calls
 */
#define D3DTRANSFORM_CLIPPED       0x00000001l
#define D3DTRANSFORM_UNCLIPPED     0x00000002l

typedef struct _D3DTRANSFORMDATA {
    DWORD           dwSize;
    LPVOID          lpIn;           /* Input vertices */
    DWORD           dwInSize;       /* Stride of input vertices */
    LPVOID          lpOut;          /* Output vertices */
    DWORD           dwOutSize;      /* Stride of output vertices */
    LPD3DHVERTEX    lpHOut;         /* Output homogeneous vertices */
    DWORD           dwClip;         /* Clipping hint */
    DWORD           dwClipIntersection;
    DWORD           dwClipUnion;    /* Union of all clip flags */
    D3DRECT         drExtent;       /* Extent of transformed vertices */
} D3DTRANSFORMDATA, *LPD3DTRANSFORMDATA;

/*
 * Structure defining position and direction properties for lighting.
 */
typedef struct _D3DLIGHTINGELEMENT {
    D3DVECTOR dvPosition;           /* Lightable point in model space */
    D3DVECTOR dvNormal;             /* Normalised unit vector */
} D3DLIGHTINGELEMENT, *LPD3DLIGHTINGELEMENT;

/*
 * Structure defining material properties for lighting.
 */
typedef struct _D3DMATERIAL {
    DWORD               dwSize;
    union {
        D3DCOLORVALUE   diffuse;        /* Diffuse color RGBA */
        D3DCOLORVALUE   dcvDiffuse;
    };
    union {
        D3DCOLORVALUE   ambient;        /* Ambient color RGB */
        D3DCOLORVALUE   dcvAmbient;
    };
    union {
        D3DCOLORVALUE   specular;       /* Specular 'shininess' */
        D3DCOLORVALUE   dcvSpecular;
    };
    union {
        D3DCOLORVALUE   emissive;       /* Emissive color RGB */
        D3DCOLORVALUE   dcvEmissive;
    };
    union {
        D3DVALUE        power;          /* Sharpness if specular highlight */
        D3DVALUE        dvPower;
    };
    D3DTEXTUREHANDLE    hTexture;       /* Handle to texture map */
    DWORD               dwRampSize;
} D3DMATERIAL, *LPD3DMATERIAL;

typedef enum _D3DLIGHTTYPE {
    D3DLIGHT_POINT          = 1,
    D3DLIGHT_SPOT           = 2,
    D3DLIGHT_DIRECTIONAL    = 3,
    D3DLIGHT_PARALLELPOINT  = 4,
    D3DLIGHT_GLSPOT         = 5,
} D3DLIGHTTYPE;

/*
 * Structure defining a light source and its properties.
 */
typedef struct _D3DLIGHT {
    DWORD           dwSize;
    D3DLIGHTTYPE    dltType;            /* Type of light source */
    D3DCOLORVALUE   dcvColor;           /* Color of light */
    D3DVECTOR       dvPosition;         /* Position in world space */
    D3DVECTOR       dvDirection;        /* Direction in world space */
    D3DVALUE        dvRange;            /* Cutoff range */
    D3DVALUE        dvFalloff;          /* Falloff */
    D3DVALUE        dvAttenuation0;     /* Constant attenuation */
    D3DVALUE        dvAttenuation1;     /* Linear attenuation */
    D3DVALUE        dvAttenuation2;     /* Quadratic attenuation */
    D3DVALUE        dvTheta;            /* Inner angle of spotlight cone */
    D3DVALUE        dvPhi;              /* Outer angle of spotlight cone */
} D3DLIGHT, *LPD3DLIGHT;

typedef struct _D3DLIGHTDATA {
    DWORD                dwSize;
    LPD3DLIGHTINGELEMENT lpIn;          /* Input positions and normals */
    DWORD                dwInSize;      /* Stride of input elements */
    LPD3DTLVERTEX        lpOut;         /* Output colors */
    DWORD                dwOutSize;     /* Stride of output colors */
} D3DLIGHTDATA, *LPD3DLIGHTDATA;

typedef enum _D3DCOLORMODEL {
    D3DCOLOR_MONO           = 1,
    D3DCOLOR_RGB            = 2,
} D3DCOLORMODEL;

/*
 * Options for clearing
 */
#define D3DCLEAR_TARGET            0x00000001l /* Clear target surface */
#define D3DCLEAR_ZBUFFER           0x00000002l /* Clear target z buffer */

/*
 * Execute buffers are allocated via Direct3D.  These buffers may then
 * be filled by the application with instructions to execute along with
 * vertex data.
 */

/*
 * Supported op codes for execute instructions.
 */
typedef enum _D3DOPCODE {
    D3DOP_POINT                 = 1,
    D3DOP_LINE                  = 2,
    D3DOP_TRIANGLE              = 3,
    D3DOP_MATRIXLOAD            = 4,
    D3DOP_MATRIXMULTIPLY        = 5,
    D3DOP_STATETRANSFORM        = 6,
    D3DOP_STATELIGHT            = 7,
    D3DOP_STATERENDER           = 8,
    D3DOP_PROCESSVERTICES       = 9,
    D3DOP_TEXTURELOAD           = 10,
    D3DOP_EXIT                  = 11,
    D3DOP_BRANCHFORWARD         = 12,
    D3DOP_SPAN                  = 13,
    D3DOP_SETSTATUS             = 14,
} D3DOPCODE;

typedef struct _D3DINSTRUCTION {
    BYTE bOpcode;   /* Instruction opcode */
    BYTE bSize;     /* Size of each instruction data unit */
    WORD wCount;    /* Count of instruction data units to follow */
} D3DINSTRUCTION, *LPD3DINSTRUCTION;

/*
 * Structure for texture loads
 */
typedef struct _D3DTEXTURELOAD {
    D3DTEXTUREHANDLE hDestTexture;
    D3DTEXTUREHANDLE hSrcTexture;
} D3DTEXTURELOAD, *LPD3DTEXTURELOAD;

/*
 * Structure for picking
 */
typedef struct _D3DPICKRECORD {
    BYTE     bOpcode;
    BYTE     bPad;
    DWORD    dwOffset;
    D3DVALUE dvZ;
} D3DPICKRECORD, *LPD3DPICKRECORD;

/*
 * The following defines the rendering states which can be set in the
 * execute buffer.
 */

typedef enum _D3DSHADEMODE {
    D3DSHADE_FLAT              = 1,
    D3DSHADE_GOURAUD           = 2,
    D3DSHADE_PHONG             = 3,
} D3DSHADEMODE;

typedef enum _D3DFILLMODE {
    D3DFILL_POINT              = 1,
    D3DFILL_WIREFRAME          = 2,
    D3DFILL_SOLID              = 3,
} D3DFILLMODE;

typedef struct _D3DLINEPATTERN {
    WORD        wRepeatFactor;
    WORD        wLinePattern;
} D3DLINEPATTERN;

typedef enum _D3DTEXTUREFILTER {
    D3DFILTER_NEAREST          = 1,
    D3DFILTER_LINEAR           = 2,
    D3DFILTER_MIPNEAREST       = 3,
    D3DFILTER_MIPLINEAR        = 4,
    D3DFILTER_LINEARMIPNEAREST = 5,
    D3DFILTER_LINEARMIPLINEAR  = 6,
} D3DTEXTUREFILTER;

typedef enum _D3DBLEND {
    D3DBLEND_ZERO              = 1,
    D3DBLEND_ONE               = 2,
    D3DBLEND_SRCCOLOR          = 3,
    D3DBLEND_INVSRCCOLOR       = 4,
    D3DBLEND_SRCALPHA          = 5,
    D3DBLEND_INVSRCALPHA       = 6,
    D3DBLEND_DESTALPHA         = 7,
    D3DBLEND_INVDESTALPHA      = 8,
    D3DBLEND_DESTCOLOR         = 9,
    D3DBLEND_INVDESTCOLOR      = 10,
    D3DBLEND_SRCALPHASAT       = 11,
    D3DBLEND_BOTHSRCALPHA      = 12,
    D3DBLEND_BOTHINVSRCALPHA   = 13,
} D3DBLEND;

typedef enum _D3DTEXTUREBLEND {
    D3DTBLEND_DECAL            = 1,
    D3DTBLEND_MODULATE         = 2,
    D3DTBLEND_DECALALPHA       = 3,
    D3DTBLEND_MODULATEALPHA    = 4,
    D3DTBLEND_DECALMASK        = 5,
    D3DTBLEND_MODULATEMASK     = 6,
    D3DTBLEND_COPY             = 7,
} D3DTEXTUREBLEND;

typedef enum _D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP           = 1,
    D3DTADDRESS_MIRROR         = 2,
    D3DTADDRESS_CLAMP          = 3,
} D3DTEXTUREADDRESS;

typedef enum _D3DCULL {
    D3DCULL_NONE               = 1,
    D3DCULL_CW                 = 2,
    D3DCULL_CCW                = 3,
} D3DCULL;

typedef enum _D3DCMPFUNC {
    D3DCMP_NEVER               = 1,
    D3DCMP_LESS                = 2,
    D3DCMP_EQUAL               = 3,
    D3DCMP_LESSEQUAL           = 4,
    D3DCMP_GREATER             = 5,
    D3DCMP_NOTEQUAL            = 6,
    D3DCMP_GREATEREQUAL        = 7,
    D3DCMP_ALWAYS              = 8,
} D3DCMPFUNC;

typedef enum _D3DFOGMODE {
    D3DFOG_NONE                = 0,
    D3DFOG_EXP                 = 1,
    D3DFOG_EXP2                = 2,
    D3DFOG_LINEAR              = 3
} D3DFOGMODE;

/*
 * Amount to add to a state to generate the override for that state.
 */
#define D3DSTATE_OVERRIDE_BIAS          256

/*
 * A state which sets the override flag for the specified state type.
 */
#define D3DSTATE_OVERRIDE(type) ((DWORD) (type) + D3DSTATE_OVERRIDE_BIAS)

typedef enum _D3DTRANSFORMSTATETYPE {
    D3DTRANSFORMSTATE_WORLD           = 1,
    D3DTRANSFORMSTATE_VIEW            = 2,
    D3DTRANSFORMSTATE_PROJECTION      = 3,
} D3DTRANSFORMSTATETYPE;

typedef enum _D3DLIGHTSTATETYPE {
    D3DLIGHTSTATE_MATERIAL            = 1,
    D3DLIGHTSTATE_AMBIENT             = 2,
    D3DLIGHTSTATE_COLORMODEL          = 3,
    D3DLIGHTSTATE_FOGMODE             = 4,
    D3DLIGHTSTATE_FOGSTART            = 5,
    D3DLIGHTSTATE_FOGEND              = 6,
    D3DLIGHTSTATE_FOGDENSITY          = 7,
} D3DLIGHTSTATETYPE;

typedef enum _D3DRENDERSTATETYPE {
    D3DRENDERSTATE_TEXTUREHANDLE      = 1,    /* Texture handle */
    D3DRENDERSTATE_ANTIALIAS          = 2,    /* Antialiasing prim edges */
    D3DRENDERSTATE_TEXTUREADDRESS     = 3,    /* D3DTEXTUREADDRESS      */
    D3DRENDERSTATE_TEXTUREPERSPECTIVE = 4,    /* TRUE for perspective correction */
    D3DRENDERSTATE_WRAPU              = 5,    /* TRUE for wrapping in u */
    D3DRENDERSTATE_WRAPV              = 6,    /* TRUE for wrapping in v */
    D3DRENDERSTATE_ZENABLE            = 7,    /* TRUE to enable z test */
    D3DRENDERSTATE_FILLMODE           = 8,    /* D3DFILL_MODE            */
    D3DRENDERSTATE_SHADEMODE          = 9,    /* D3DSHADEMODE */
    D3DRENDERSTATE_LINEPATTERN        = 10,   /* D3DLINEPATTERN */
    D3DRENDERSTATE_MONOENABLE         = 11,   /* TRUE to enable mono rasterization */
    D3DRENDERSTATE_ROP2               = 12,   /* ROP2 */
    D3DRENDERSTATE_PLANEMASK          = 13,   /* DWORD physical plane mask */
    D3DRENDERSTATE_ZWRITEENABLE       = 14,   /* TRUE to enable z writes */
    D3DRENDERSTATE_ALPHATESTENABLE    = 15,   /* TRUE to enable alpha tests */
    D3DRENDERSTATE_LASTPIXEL          = 16,   /* TRUE for last-pixel on lines */
    D3DRENDERSTATE_TEXTUREMAG         = 17,   /* D3DTEXTUREFILTER */
    D3DRENDERSTATE_TEXTUREMIN         = 18,   /* D3DTEXTUREFILTER */
    D3DRENDERSTATE_SRCBLEND           = 19,   /* D3DBLEND */
    D3DRENDERSTATE_DESTBLEND          = 20,   /* D3DBLEND */
    D3DRENDERSTATE_TEXTUREMAPBLEND    = 21,   /* D3DTEXTUREBLEND */
    D3DRENDERSTATE_CULLMODE           = 22,   /* D3DCULL */
    D3DRENDERSTATE_ZFUNC              = 23,   /* D3DCMPFUNC */
    D3DRENDERSTATE_ALPHAREF           = 24,   /* D3DFIXED */
    D3DRENDERSTATE_ALPHAFUNC          = 25,   /* D3DCMPFUNC */
    D3DRENDERSTATE_DITHERENABLE       = 26,   /* TRUE to enable dithering */
    D3DRENDERSTATE_BLENDENABLE        = 27,   /* TRUE to enable alpha blending */
    D3DRENDERSTATE_FOGENABLE          = 28,   /* TRUE to enable fog */
    D3DRENDERSTATE_SPECULARENABLE     = 29,   /* TRUE to enable specular */
    D3DRENDERSTATE_ZVISIBLE           = 30,   /* TRUE to enable z checking */
    D3DRENDERSTATE_SUBPIXEL           = 31,   /* TRUE to enable subpixel correction */
    D3DRENDERSTATE_SUBPIXELX          = 32,   /* TRUE to enable correction in X only */
    D3DRENDERSTATE_STIPPLEDALPHA      = 33,   /* TRUE to enable stippled alpha */
    D3DRENDERSTATE_FOGCOLOR           = 34,   /* D3DCOLOR */
    D3DRENDERSTATE_FOGTABLEMODE       = 35,   /* D3DFOGMODE */
    D3DRENDERSTATE_FOGTABLESTART      = 36,   /* Fog table start        */
    D3DRENDERSTATE_FOGTABLEEND        = 37,   /* Fog table end          */
    D3DRENDERSTATE_FOGTABLEDENSITY    = 38,   /* Fog table density      */
    D3DRENDERSTATE_STIPPLEENABLE      = 39,   /* TRUE to enable stippling */
    D3DRENDERSTATE_STIPPLEPATTERN00   = 64,   /* Stipple pattern 01...  */      
    D3DRENDERSTATE_STIPPLEPATTERN01   = 65,
    D3DRENDERSTATE_STIPPLEPATTERN02   = 66,
    D3DRENDERSTATE_STIPPLEPATTERN03   = 67,
    D3DRENDERSTATE_STIPPLEPATTERN04   = 68,
    D3DRENDERSTATE_STIPPLEPATTERN05   = 69,
    D3DRENDERSTATE_STIPPLEPATTERN06   = 70,
    D3DRENDERSTATE_STIPPLEPATTERN07   = 71,
    D3DRENDERSTATE_STIPPLEPATTERN08   = 72,
    D3DRENDERSTATE_STIPPLEPATTERN09   = 73,
    D3DRENDERSTATE_STIPPLEPATTERN10   = 74,
    D3DRENDERSTATE_STIPPLEPATTERN11   = 75,
    D3DRENDERSTATE_STIPPLEPATTERN12   = 76,
    D3DRENDERSTATE_STIPPLEPATTERN13   = 77,
    D3DRENDERSTATE_STIPPLEPATTERN14   = 78,
    D3DRENDERSTATE_STIPPLEPATTERN15   = 79,
    D3DRENDERSTATE_STIPPLEPATTERN16   = 80,
    D3DRENDERSTATE_STIPPLEPATTERN17   = 81,
    D3DRENDERSTATE_STIPPLEPATTERN18   = 82,
    D3DRENDERSTATE_STIPPLEPATTERN19   = 83,
    D3DRENDERSTATE_STIPPLEPATTERN20   = 84,
    D3DRENDERSTATE_STIPPLEPATTERN21   = 85,
    D3DRENDERSTATE_STIPPLEPATTERN22   = 86,
    D3DRENDERSTATE_STIPPLEPATTERN23   = 87,
    D3DRENDERSTATE_STIPPLEPATTERN24   = 88,
    D3DRENDERSTATE_STIPPLEPATTERN25   = 89,
    D3DRENDERSTATE_STIPPLEPATTERN26   = 90,
    D3DRENDERSTATE_STIPPLEPATTERN27   = 91,
    D3DRENDERSTATE_STIPPLEPATTERN28   = 92,
    D3DRENDERSTATE_STIPPLEPATTERN29   = 93,
    D3DRENDERSTATE_STIPPLEPATTERN30   = 94,
    D3DRENDERSTATE_STIPPLEPATTERN31   = 95,
} D3DRENDERSTATETYPE;

#define D3DRENDERSTATE_STIPPLEPATTERN(y) (D3DRENDERSTATE_STIPPLEPATTERN00 + (y))

typedef struct _D3DSTATE {
    union {
        D3DTRANSFORMSTATETYPE   dtstTransformStateType;
        D3DLIGHTSTATETYPE       dlstLightStateType;
        D3DRENDERSTATETYPE      drstRenderStateType;
    };
    union {
        DWORD                   dwArg[1];
        D3DVALUE                dvArg[1];
    };
} D3DSTATE, *LPD3DSTATE;

/*
 * Operation used to load matrices
 * hDstMat = hSrcMat
 */
typedef struct _D3DMATRIXLOAD {
    D3DMATRIXHANDLE hDestMatrix;   /* Destination matrix */
    D3DMATRIXHANDLE hSrcMatrix;   /* Source matrix */
} D3DMATRIXLOAD, *LPD3DMATRIXLOAD;

/*
 * Operation used to multiply matrices
 * hDstMat = hSrcMat1 * hSrcMat2
 */
typedef struct _D3DMATRIXMULTIPLY {
    D3DMATRIXHANDLE hDestMatrix;   /* Destination matrix */
    D3DMATRIXHANDLE hSrcMatrix1;  /* First source matrix */
    D3DMATRIXHANDLE hSrcMatrix2;  /* Second source matrix */
} D3DMATRIXMULTIPLY, *LPD3DMATRIXMULTIPLY;

/*
 * Operation used to transform and light vertices.
 */
typedef struct _D3DPROCESSVERTICES {
    DWORD        dwFlags;    /* Do we transform or light or just copy? */
    WORD         wStart;     /* Index to first vertex in source */
    WORD         wDest;      /* Index to first vertex in local buffer */
    DWORD        dwCount;    /* Number of vertices to be processed */
    DWORD        dwReserved; /* Must be zero */
} D3DPROCESSVERTICES, *LPD3DPROCESSVERTICES;

#define D3DPROCESSVERTICES_TRANSFORMLIGHT       0x00000000L
#define D3DPROCESSVERTICES_TRANSFORM            0x00000001L
#define D3DPROCESSVERTICES_COPY                 0x00000002L
#define D3DPROCESSVERTICES_OPMASK               0x00000007L

#define D3DPROCESSVERTICES_UPDATEEXTENTS        0x00000008L
#define D3DPROCESSVERTICES_NOCOLOR              0x00000010L


/*
 * Triangle flags
 */
 
/*
 * Tri strip and fan flags.
 * START loads all three vertices
 * EVEN and ODD load just v3 with even or odd culling
 * START_FLAT contains a count from 0 to 29 that allows the
 * whole strip or fan to be culled in one hit.
 * e.g. for a quad len = 1
 */
#define D3DTRIFLAG_START                        0x00000000L
#define D3DTRIFLAG_STARTFLAT(len) (len)         /* 0 < len < 30 */
#define D3DTRIFLAG_ODD                          0x0000001eL
#define D3DTRIFLAG_EVEN                         0x0000001fL

/*
 * Triangle edge flags
 * enable edges for wireframe or antialiasing
 */
#define D3DTRIFLAG_EDGEENABLE1                  0x00000100L /* v0-v1 edge */
#define D3DTRIFLAG_EDGEENABLE2                  0x00000200L /* v1-v2 edge */
#define D3DTRIFLAG_EDGEENABLE3                  0x00000400L /* v2-v0 edge */
#define D3DTRIFLAG_EDGEENABLETRIANGLE \
        (D3DTRIFLAG_EDGEENABLE1 | D3DTRIFLAG_EDGEENABLE2 | D3DTRIFLAG_EDGEENABLE3)
        
/*
 * Primitive structures and related defines.  Vertex offsets are to types
 * D3DVERTEX, D3DLVERTEX, or D3DTLVERTEX.
 */

/*
 * Triangle list primitive structure
 */
typedef struct _D3DTRIANGLE {
    union {
        WORD    v1;            /* Vertex indices */
        WORD    wV1;
    };
    union {
        WORD    v2;
        WORD    wV2;
    };
    union {
        WORD    v3;
        WORD    wV3;
    };
    WORD        wFlags;       /* Edge (and other) flags */
} D3DTRIANGLE, *LPD3DTRIANGLE;

/*
 * Line strip structure.
 * The instruction count - 1 defines the number of line segments.
 */
typedef struct _D3DLINE {
    union {
        WORD    v1;            /* Vertex indices */
        WORD    wV1;
    };
    union {
        WORD    v2;
        WORD    wV2;
    };
} D3DLINE, *LPD3DLINE;

/*
 * Span structure
 * Spans join a list of points with the same y value.
 * If the y value changes, a new span is started.
 */
typedef struct _D3DSPAN {
    WORD        wCount; /* Number of spans */
    WORD        wFirst; /* Index to first vertex */
} D3DSPAN, *LPD3DSPAN;

/*
 * Point structure
 */
typedef struct _D3DPOINT {
    WORD        wCount;         /* number of points         */
    WORD        wFirst;         /* index to first vertex    */
} D3DPOINT, *LPD3DPOINT;


/*
 * Forward branch structure.
 * Mask is logically anded with the driver status mask
 * if the result equals 'value', the branch is taken.
 */
typedef struct _D3DBRANCH {
    DWORD       dwMask;         /* Bitmask against D3D status */
    DWORD       dwValue;
    BOOL        bNegate;        /* TRUE to negate comparison */
    DWORD       dwOffset;       /* How far to branch forward (0 for exit)*/
} D3DBRANCH, *LPD3DBRANCH;

/*
 * Status used for set status instruction.
 * The D3D status is initialised on device creation
 * and is modified by all execute calls.
 */
typedef struct _D3DSTATUS {
    DWORD       dwFlags;        /* Do we set extents or status */
    DWORD       dwStatus;       /* D3D status */
    D3DRECT     drExtent;
} D3DSTATUS, *LPD3DSTATUS;

#define D3DSETSTATUS_STATUS             0x00000001L
#define D3DSETSTATUS_EXTENTS            0x00000002L
#define D3DSETSTATUS_ALL        (D3DSETSTATUS_STATUS | D3DSETSTATUS_EXTENTS)

/*
 * Statistics structure
 */
typedef struct _D3DSTATS {
    DWORD        dwSize;
    DWORD        dwTrianglesDrawn;
    DWORD        dwLinesDrawn;
    DWORD        dwPointsDrawn;
    DWORD        dwSpansDrawn;
    DWORD        dwVerticesProcessed;
} D3DSTATS, *LPD3DSTATS;

/*
 * Execute options.
 * When calling using D3DEXECUTE_UNCLIPPED all the primitives 
 * inside the buffer must be contained within the viewport.
 */
#define D3DEXECUTE_CLIPPED       0x00000001l
#define D3DEXECUTE_UNCLIPPED     0x00000002l

typedef struct _D3DEXECUTEDATA {
    DWORD       dwSize;
    DWORD       dwVertexOffset;
    DWORD       dwVertexCount;
    DWORD       dwInstructionOffset;
    DWORD       dwInstructionLength;
    DWORD       dwHVertexOffset;
    D3DSTATUS   dsStatus;       /* Status after execute */
} D3DEXECUTEDATA, *LPD3DEXECUTEDATA;

/*
 * Palette flags.
 * This are or'ed with the peFlags in the PALETTEENTRYs passed to DirectDraw.
 */
#define D3DPAL_FREE     0x00    /* Renderer may use this entry freely */
#define D3DPAL_READONLY 0x40    /* Renderer may not set this entry */
#define D3DPAL_RESERVED 0x80    /* Renderer may not use this entry */

#if defined(__cplusplus)
};
#endif

#pragma pack()

#endif /* _D3DTYPES_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\ddrawi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawi.h
 *  Content:	DirectDraw internal header file
 *		Used by DirectDraw and by the display drivers.
 *@@BEGIN_MSINTERNAL
 *		See ddrawpr.h for all information private to DirectDraw.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   25-dec-94	craige	initial implementation
 *   06-jan-95	craige	video memory manager integration
 *   13-jan-95	craige	re-worked to updated spec + ongoing work
 *   21-jan-95	craige	made 32-bit + ongoing work
 *   31-jan-95	craige	and even more ongoing work...
 *   04-feb-95	craige	performance tuning, ongoing work
 *   22-feb-95	craige	use critical sections on Win95
 *   02-mar-95	craige	work work work
 *   06-mar-95	craige 	HEL integration
 *   11-mar-95	craige	palette stuff
 *   17-mar-95	craige	COM interface
 *   19-mar-95	craige	use HRESULTs, use same process list handling for
 *			driver objects as surface and palette
 *   20-mar-95	craige	new CSECT work
 *   23-mar-95	craige	attachment work
 *   27-mar-95	craige	linear or rectangular vidmem
 *   28-mar-95	craige	RGBQUAD -> PALETTEENTRY; other palette stuff
 *   29-mar-95	craige	removed Eitherxxx caps from DIRECTDRAW
 *   31-mar-95	craige	use critical sections with palettes
 *   04-apr-95	craige	palette tweaks
 *   06-apr-95	craige	split out process list stuff
 *   10-apr-95	craige	bug 3,16 - palette issues
 *   13-apr-95	craige	EricEng's little contribution to our being late
 *   06-may-95	craige	use driver-level csects only
 *   09-may-95	craige	escape call to get 32-bit DLL
 *   14-may-95	craige	cleaned out obsolete junk
 *   15-may-95	craige	made separate VMEM struct for rect & linear
 *   24-may-95  kylej   removed obsolete ZOrder variables
 *   24-may-95	craige	removed dwOrigNumHeaps
 *   28-may-95	craige	cleaned up HAL: added GetBltStatus;GetFlipStatus;
 *			GetScanLine
 *   02-jun-95	craige	added PROCESS_LIST2 to DIRECTDRAW object; removed
 *			hWndPal from DIRECTDRAW object; added lpDDSurface
 *			to DIRECTDRAWPALETTE object
 *   06-jun-95	craige	maintain entire primary surface in DIRECTDRAW object
 *   07-jun-95	craige	moved DCLIST to PROCESSLIST
 *   10-jun-95	craige	split out vmemmgr stuff
 *   12-jun-95	craige	new process list stuff
 *   16-jun-95	craige	removed fpVidMemOrig; new surface structure
 *   20-jun-95  kylej   added is_excl field to DDHAL_CREATEPALETTEDATA struct
 *   21-jun-95	craige	added DirectDrawClipper object; removed clipping
 *			info from surface object
 *   22-jun-95	craige	more clipping work
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   27-jun-95	craige	added dwModeCreatedIn to surface
 *   30-jun-95	kylej	removed lpPrimarySurface, dwZDepth, dwAlphaDepth
 *			from direct draw object.  Modified some surface and
 *                      direct draw object flags.
 *   01-jul-95	craige	hide composition & streaming stuff
 *   02-jul-95	craige	added extra reserved field for HEL
 *   03-jul-95	craige	YEEHAW: new driver struct; added pUnkOuter to all objects
 *   09-jul-95	craige	track win16lock info in driver struct; added
 *			DDHAL_DRIVER_NOCKEYHW
 *   10-jul-95	craige	support SetOverlayPosition
 *   13-jul-95	craige	removed old junk from ddraw object; added new mode stuff;
 *			changed Get/SetOverlayPosition to use longs;
 *			fixed duplicate flag in DDRAWIPAL_xxx
 *   14-jul-95	craige	added VIDMEM_ISHEAP
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset;
 *			palette bugs
 *   22-jul-95	craige	bug 230 - unsupported starting modes
 *   29-jul-95  toddla  remove unused palette stuff
 *   31-jul-95  toddla  added DD_HAL_VERSION
 *   01-aug-95  toddla  added dwPDevice to DDRAWI_DIRECTDRAW_GBL
 *   10-aug-95	craige	added VALID_ALIGNMENT
 *   13-aug-95	craige	internal/external version of DD_HAL_VERSION
 *   21-aug-95	craige	mode X support
 *   27-aug-95	craige	bug 742: added DDRAWIPAL_ALLOW256
 *   08-nov-95  colinmc added DDRAWIPAL flags to support 1, 2 and 4 bit
 *                      RGB and indexed palettes
 *   21-nov-95  colinmc made Direct3D a queryable interface off DirectDraw
 *   23-nov-95  colinmc made Direct3D textures and devices queryable off
 *                      DirectDraw surfaces
 *   09-dec-95  colinmc execute buffer support
 *   12-dec-95  colinmc shared back and z-buffer support (run away, run away...)
 *   22-dec-95  colinmc Direct3D support no longer conditional
 *   02-jan-96	kylej	New interface structures, no vtbl in local objects
 *   10-jan-96  colinmc Aggregate IUnknowns of surfaces now maintained as
 *                      list
 *   18-jan-96  jeffno  Changed free entries in DDRAW_GBL and SURFACE_LCL to NT
 *                      kernel-mode handles
 *   29-jan-96  colinmc Aggregated IUnknowns now stored in additional
 *                      surface structure
 *   09-feb-96  colinmc Addition of lost surface flag to local surface
 *                      objects
 *   17-feb-96  colinmc Fixed execute buffer size restriction problem
 *   01-mar-96	kylej	Change DDCAPS size
 *   03-mar-96  colinmc Hack to keep interim drivers working
 *   13-mar-96	craige	Bug 7528: hw that doesn't have modex
 *   14-mar-96  colinmc Class factory support for clippers
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   13-apr-96  colinmc Bug 17736: no notification to driver of when GDI
 *                      frame buffer is being displayed
 *   16-apr-96	kylej	Bug 17900: DBLNODE struct incompatible with ddraw 1
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __DDRAWI_INCLUDED__
#define __DDRAWI_INCLUDED__

/*
 * METAQUESTION: Why are Windows handles stored as DWORDs instead of
 *		 their proper types?
 * METAANSWER:   To make the thunk to the 16-bit side completely painless.
 */

#define OBJECT_ISROOT			0x80000000l	// object is root object

/*
 * stuff for drivers
 */
#ifndef _WIN32
typedef long	HRESULT;
typedef LPVOID  REFIID;
typedef void    GUID;
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif

//@@BEGIN_MSINTERNAL
// Include ddrawp.h for DirectDraw and D3D builds.  DDK includes ddraw.h
#ifdef MSBUILD
    #include "ddrawp.h"
#else
//@@END_MSINTERNAL
    #include "ddraw.h"
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
#include "dmemmgr.h"

#ifndef _WIN32
/*
 * these error codes are DIFFERENT in Win32 and Win16!!!!
 */
#undef	E_NOTIMPL
#undef	E_OUTOFMEMORY
#undef	E_INVALIDARG
#undef	E_FAIL
#define E_NOTIMPL                        0x80004001L
#define E_OUTOFMEMORY                    0x8007000EL
#define E_INVALIDARG                     0x80070057L
#define E_FAIL                           0x80004005L
#endif


#define DDUNSUPPORTEDMODE		((DWORD) -1)


#define VALID_ALIGNMENT( align ) (!((align == 0) || (align % 2) != 0 ))

/*
 * List of processes attached to a DirectDraw object
 */
typedef struct _PROCESS_LIST
{
    struct _PROCESS_LIST	FAR *lpLink;
    DWORD			dwProcessId;
    DWORD			dwRefCnt;
    DWORD			dwAlphaDepth;
    DWORD			dwZDepth;
} PROCESS_LIST;
typedef PROCESS_LIST	FAR *LPPROCESS_LIST;

/*
 * DeleteFromActiveProcessList return codes
 */
#define	DELETED_OK			0
#define	DELETED_LASTONE			1
#define	DELETED_NOTFOUND		2

#define DDBLT_ANYALPHA \
		(DDBLT_ALPHASRCSURFACEOVERRIDE | \
		DDBLT_ALPHASRCCONSTOVERRIDE | \
		DDBLT_ALPHASRC | \
		DDBLT_ALPHADESTSURFACEOVERRIDE | \
		DDBLT_ALPHADESTCONSTOVERRIDE | \
		DDBLT_ALPHADEST)

#define DDOVER_ANYALPHA \
		(DDOVER_ALPHASRCSURFACEOVERRIDE | \
		DDOVER_ALPHASRCCONSTOVERRIDE | \
		DDOVER_ALPHASRC | \
		DDOVER_ALPHADESTSURFACEOVERRIDE | \
		DDOVER_ALPHADESTCONSTOVERRIDE | \
		DDOVER_ALPHADEST)


typedef struct IDirectDrawClipperVtbl DIRECTDRAWCLIPPERCALLBACKS;
typedef struct IDirectDrawPaletteVtbl DIRECTDRAWPALETTECALLBACKS;
typedef struct IDirectDrawSurfaceVtbl DIRECTDRAWSURFACECALLBACKS;
typedef struct IDirectDrawSurface2Vtbl DIRECTDRAWSURFACE2CALLBACKS;
//@@BEGIN_MSINTERNAL
#ifdef STREAMING
typedef struct IDirectDrawSurfaceStreamingVtbl DIRECTDRAWSURFACESTREAMINGCALLBACKS;
#endif
#ifdef COMPOSITION
typedef struct IDirectDrawSurfaceCompositionVtbl DIRECTDRAWSURFACECOMPOSITIONCALLBACKS;
#endif
//@@END_MSINTERNAL
typedef struct IDirectDrawVtbl DIRECTDRAWCALLBACKS;
typedef struct IDirectDraw2Vtbl DIRECTDRAW2CALLBACKS;

typedef DIRECTDRAWCLIPPERCALLBACKS FAR *LPDIRECTDRAWCLIPPERCALLBACKS;
typedef DIRECTDRAWPALETTECALLBACKS FAR *LPDIRECTDRAWPALETTECALLBACKS;
typedef DIRECTDRAWSURFACECALLBACKS FAR *LPDIRECTDRAWSURFACECALLBACKS;
//@@BEGIN_MSINTERNAL
#ifdef STREAMING
typedef DIRECTDRAWSURFACESTREAMINGCALLBACKS FAR *LPDIRECTDRAWSURFACESTREAMINGCALLBACKS;
#endif
#ifdef COMPOSITION
typedef DIRECTDRAWSURFACECOMPOSITIONCALLBACKS FAR *LPDIRECTDRAWSURFACECOMPOSITIONCALLBACKS;
#endif
//@@END_MSINTERNAL
typedef DIRECTDRAWCALLBACKS FAR *LPDIRECTDRAWCALLBACKS;

#ifdef __cplusplus
extern "C" {
#endif

#if defined( IS_32 ) || defined( WIN32 ) || defined( _WIN32 )
    #undef IS_32
    #define IS_32
    #define DDAPI		WINAPI
    #define EXTERN_DDAPI	WINAPI
#else
    #define DDAPI		__loadds WINAPI
    #define EXTERN_DDAPI	__export WINAPI
#endif

/*
 * DCI escape
 */
#ifndef DCICOMMAND
#define DCICOMMAND		3075		// escape value
#endif

/*
 * this is the DirectDraw version
 * passed to the driver in DCICMD.dwVersion
 */
#define DD_VERSION              0x00000200l

/*
 * this is the HAL version.
 * the driver returns this number from QUERYESCSUPPORT/DCICOMMAND
 */
#define DD_HAL_VERSION          0x0100
//@@BEGIN_MSINTERNAL
#define DD_HAL_VERSION_EXTERNAL	0x0100
#undef DD_HAL_VERSION
#define DD_HAL_VERSION		0x00ff	// special internal version
//@@END_MSINTERNAL

#ifndef _INC_DCIDDI
/*
 * Used by DirectDraw to provide input parameters for the DCICOMMAND escape
 * This matches the structure in the obsolete DCI 1.0
 */
typedef struct _DCICMD
{
    DWORD	dwCommand;			// command
    DWORD	dwParam1;
    DWORD 	dwParam2;
    DWORD       dwVersion;                      // DirectDraw version
    DWORD	dwReserved;
} DCICMD;

typedef  DCICMD FAR *LPDCICMD;
#endif

#define DDCREATEDRIVEROBJECT	10		// create an object
#define DDGET32BITDRIVERNAME	11		// get a 32-bit driver name
#define DDNEWCALLBACKFNS	12		// new callback fns coming

typedef struct
{
    char	szName[260];			// 32-bit driver name
    char	szEntryPoint[64];		// entry point
    DWORD	dwContext;			// context to pass to entry point
} DD32BITDRIVERDATA, FAR *LPDD32BITDRIVERDATA;

typedef DWORD   (FAR PASCAL *LPDD32BITDRIVERINIT)(DWORD dwContext);

/*
 * pointer to video meory
 */
typedef unsigned long	FLATPTR;

/*
 * indicates that DDRAW.DLL has been unloaded...
 */
#define DDRAW_DLL_UNLOADED	(LPVOID) 1

/*
 * critical section types
 */
typedef LPVOID		CSECT_HANDLE;
#ifdef NOUSE_CRITSECTS
typedef xxx			CSECT;			// generate an error for now
#else
#if defined( IS_32 ) && !defined( _NOCSECT_TYPE )
typedef CRITICAL_SECTION	CSECT;
typedef CSECT			*LPCSECT;
#else
typedef struct
{
    DWORD	vals[6];
} CSECT;
typedef void			FAR *LPCSECT;
#endif
#endif

/*
 * DLL names
 */
#define DDHAL_DRIVER_DLLNAME	"DDRAW16.DLL"
#define DDHAL_APP_DLLNAME	"DDRAW.DLL"

/*
 * maximum size of a driver name
 */
#define MAX_DRIVER_NAME		12

/*
 * largest palette supported
 */
#define MAX_PALETTE_SIZE	256

/*
 * pre-declare pointers to structs containing data for DDHAL fns
 */
typedef struct _DDHAL_CREATEPALETTEDATA FAR *LPDDHAL_CREATEPALETTEDATA;
typedef struct _DDHAL_CREATESURFACEDATA FAR *LPDDHAL_CREATESURFACEDATA;
typedef struct _DDHAL_CANCREATESURFACEDATA FAR *LPDDHAL_CANCREATESURFACEDATA;
typedef struct _DDHAL_WAITFORVERTICALBLANKDATA FAR *LPDDHAL_WAITFORVERTICALBLANKDATA;
typedef struct _DDHAL_DESTROYDRIVERDATA FAR *LPDDHAL_DESTROYDRIVERDATA;
typedef struct _DDHAL_SETMODEDATA FAR *LPDDHAL_SETMODEDATA;
typedef struct _DDHAL_DRVSETCOLORKEYDATA FAR *LPDDHAL_DRVSETCOLORKEYDATA;
typedef struct _DDHAL_GETSCANLINEDATA FAR *LPDDHAL_GETSCANLINEDATA;

typedef struct _DDHAL_DESTROYPALETTEDATA FAR *LPDDHAL_DESTROYPALETTEDATA;
typedef struct _DDHAL_SETENTRIESDATA FAR *LPDDHAL_SETENTRIESDATA;

typedef struct _DDHAL_BLTDATA FAR *LPDDHAL_BLTDATA;
typedef struct _DDHAL_LOCKDATA FAR *LPDDHAL_LOCKDATA;
typedef struct _DDHAL_UNLOCKDATA FAR *LPDDHAL_UNLOCKDATA;
typedef struct _DDHAL_UPDATEOVERLAYDATA FAR *LPDDHAL_UPDATEOVERLAYDATA;
typedef struct _DDHAL_SETOVERLAYPOSITIONDATA FAR *LPDDHAL_SETOVERLAYPOSITIONDATA;
typedef struct _DDHAL_SETPALETTEDATA FAR *LPDDHAL_SETPALETTEDATA;
typedef struct _DDHAL_FLIPDATA FAR *LPDDHAL_FLIPDATA;
typedef struct _DDHAL_DESTROYSURFACEDATA FAR *LPDDHAL_DESTROYSURFACEDATA;
typedef struct _DDHAL_SETCLIPLISTDATA FAR *LPDDHAL_SETCLIPLISTDATA;
typedef struct _DDHAL_ADDATTACHEDSURFACEDATA FAR *LPDDHAL_ADDATTACHEDSURFACEDATA;
typedef struct _DDHAL_SETCOLORKEYDATA FAR *LPDDHAL_SETCOLORKEYDATA;
typedef struct _DDHAL_GETBLTSTATUSDATA FAR *LPDDHAL_GETBLTSTATUSDATA;
typedef struct _DDHAL_GETFLIPSTATUSDATA FAR *LPDDHAL_GETFLIPSTATUSDATA;
typedef struct _DDHAL_SETEXCLUSIVEMODEDATA FAR *LPDDHAL_SETEXCLUSIVEMODEDATA;
typedef struct _DDHAL_FLIPTOGDISURFACEDATA FAR *LPDDHAL_FLIPTOGDISURFACEDATA;

/*
 * value in the fpVidMem; indicates dwBlockSize is valid (surface object)
 */
#define DDHAL_PLEASEALLOC_BLOCKSIZE	0x00000002l

/*
 * video memory data structures (passed in DDHALINFO)
 */
typedef struct _VIDMEM
{
    DWORD		dwFlags;	// flags
    FLATPTR		fpStart;	// start of memory chunk
    union
    {
	FLATPTR		fpEnd;		// end of memory chunk
	DWORD		dwWidth;	// width of chunk (rectanglar memory)
    };
    DDSCAPS		ddsCaps;		// what this memory CANNOT be used for
    DDSCAPS		ddsCapsAlt;	// what this memory CANNOT be used for if it must
    union
    {
	LPVMEMHEAP	lpHeap;		// heap pointer, used by DDRAW
	DWORD		dwHeight;	// height of chunk (rectanguler memory)
    };
} VIDMEM;
typedef VIDMEM FAR *LPVIDMEM;

/*
 * flags for vidmem struct
 */
#define VIDMEM_ISLINEAR		0x00000001l
#define VIDMEM_ISRECTANGULAR	0x00000002l
#define VIDMEM_ISHEAP		0x00000004l

typedef struct _VIDMEMINFO
{
    FLATPTR		fpPrimary;		// pointer to primary surface
    DWORD		dwFlags;		// flags
    DWORD		dwDisplayWidth;		// current display width
    DWORD		dwDisplayHeight;	// current display height
    LONG		lDisplayPitch;		// current display pitch
    DDPIXELFORMAT	ddpfDisplay;		// pixel format of display
    DWORD		dwOffscreenAlign;	// byte alignment for offscreen surfaces
    DWORD		dwOverlayAlign;		// byte alignment for overlays
    DWORD		dwTextureAlign;		// byte alignment for textures
    DWORD		dwZBufferAlign;		// byte alignment for z buffers
    DWORD		dwAlphaAlign;		// byte alignment for alpha 
    DWORD		dwNumHeaps;		// number of memory heaps in vmList
    LPVIDMEM		pvmList;		// array of heaps
} VIDMEMINFO;
typedef VIDMEMINFO FAR *LPVIDMEMINFO;

/*
 * These structures contain the entry points in the display driver that
 * DDRAW will call.   Entries that the display driver does not care about
 * should be NULL.   Passed to DDRAW in DDHALINFO.
 */
typedef struct _DDRAWI_DIRECTDRAW_INT FAR    *LPDDRAWI_DIRECTDRAW_INT;
typedef struct _DDRAWI_DIRECTDRAW_LCL FAR    *LPDDRAWI_DIRECTDRAW_LCL;
typedef struct _DDRAWI_DIRECTDRAW_GBL FAR    *LPDDRAWI_DIRECTDRAW_GBL;
typedef struct _DDRAWI_DDRAWSURFACE_GBL FAR  *LPDDRAWI_DDRAWSURFACE_GBL;
typedef struct _DDRAWI_DDRAWPALETTE_GBL FAR  *LPDDRAWI_DDRAWPALETTE_GBL;
typedef struct _DDRAWI_DDRAWPALETTE_INT FAR  *LPDDRAWI_DDRAWPALETTE_INT;
typedef struct _DDRAWI_DDRAWCLIPPER_INT FAR  *LPDDRAWI_DDRAWCLIPPER_INT;
typedef struct _DDRAWI_DDRAWCLIPPER_GBL FAR  *LPDDRAWI_DDRAWCLIPPER_GBL;
typedef struct _DDRAWI_DDRAWSURFACE_MORE FAR *LPDDRAWI_DDRAWSURFACE_MORE;
typedef struct _DDRAWI_DDRAWSURFACE_LCL FAR  *LPDDRAWI_DDRAWSURFACE_LCL;
typedef struct _DDRAWI_DDRAWSURFACE_INT FAR  *LPDDRAWI_DDRAWSURFACE_INT;
//@@BEGIN_MSINTERNAL
#ifdef STREAMING
typedef struct _DDRAWI_DIRECTDRAWSURFACESTREAMING FAR *LPDDRAWI_DDRAWSURFACE_GBLSTREAMING;
#endif
//@@END_MSINTERNAL
typedef struct _DDRAWI_DDRAWPALETTE_LCL FAR  *LPDDRAWI_DDRAWPALETTE_LCL;
typedef struct _DDRAWI_DDRAWCLIPPER_LCL FAR  *LPDDRAWI_DDRAWCLIPPER_LCL;

//@@BEGIN_MSINTERNAL
#ifdef CLIPPER_NOTIFY
/*
 * WINWATCH structure
 */
typedef struct _WINWATCH
{
    LPDDRAWI_DDRAWCLIPPER_LCL lpDDClipper;

    struct _WINWATCH	FAR *next;	// next
    struct _WINWATCH	FAR *next16;	// next (16-bit)

    struct _WINWATCH	FAR *self32;	// self ptr
    struct _WINWATCH	FAR *self16;	// self ptr (16-bit)

    DWORD		hWnd;		// window handle

    LPCLIPPERCALLBACK	lpCallback;	// callback to call
    LPVOID		lpContext;	// context for callback
    WORD		fNotify;	// need notify

    WORD		fDirty;		// changed
    DWORD		dwRDSize;	// size of rgn data
    /*
     * STUFF AFTER THIS ONLY FOR 16-BIT SIDE, SIZES ARE DIFFERENT
     */
    RECT		rect;		// intersection rect
    RGNDATA		NEAR *prd16;	// 16-bit pointer to region data

} WINWATCH, FAR *LPWINWATCH;
#endif
//@@END_MSINTERNAL

/*
 * List of IUnknowns aggregated by a DirectDraw surface.
 */
typedef struct _IUNKNOWN_LIST
{
    struct _IUNKNOWN_LIST FAR *lpLink;
    GUID                  FAR *lpGuid;
    IUnknown              FAR *lpIUnknown;
} IUNKNOWN_LIST;
typedef IUNKNOWN_LIST FAR *LPIUNKNOWN_LIST;

/*
 * hardware emulation layer stuff
 */
typedef BOOL	(FAR PASCAL *LPDDHEL_INIT)(LPDDRAWI_DIRECTDRAW_GBL,BOOL);

/*
 * DIRECTDRAW object callbacks
 */
typedef DWORD	(FAR PASCAL *LPDDHAL_SETCOLORKEY)(LPDDHAL_DRVSETCOLORKEYDATA );
typedef DWORD	(FAR PASCAL *LPDDHAL_CANCREATESURFACE)(LPDDHAL_CANCREATESURFACEDATA );
typedef DWORD	(FAR PASCAL *LPDDHAL_WAITFORVERTICALBLANK)(LPDDHAL_WAITFORVERTICALBLANKDATA );
typedef DWORD	(FAR PASCAL *LPDDHAL_CREATESURFACE)(LPDDHAL_CREATESURFACEDATA);
typedef DWORD	(FAR PASCAL *LPDDHAL_DESTROYDRIVER)(LPDDHAL_DESTROYDRIVERDATA);
typedef DWORD	(FAR PASCAL *LPDDHAL_SETMODE)(LPDDHAL_SETMODEDATA);
typedef DWORD	(FAR PASCAL *LPDDHAL_CREATEPALETTE)(LPDDHAL_CREATEPALETTEDATA);
typedef DWORD	(FAR PASCAL *LPDDHAL_GETSCANLINE)(LPDDHAL_GETSCANLINEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_SETEXCLUSIVEMODE)(LPDDHAL_SETEXCLUSIVEMODEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_FLIPTOGDISURFACE)(LPDDHAL_FLIPTOGDISURFACEDATA);

typedef struct _DDHAL_DDCALLBACKS
{
    DWORD			 dwSize;
    DWORD			 dwFlags;
    LPDDHAL_DESTROYDRIVER	 DestroyDriver;
    LPDDHAL_CREATESURFACE	 CreateSurface;
    LPDDHAL_SETCOLORKEY		 SetColorKey;
    LPDDHAL_SETMODE		 SetMode;
    LPDDHAL_WAITFORVERTICALBLANK WaitForVerticalBlank;
    LPDDHAL_CANCREATESURFACE	 CanCreateSurface;
    LPDDHAL_CREATEPALETTE	 CreatePalette;
    LPDDHAL_GETSCANLINE		 GetScanLine;
    LPDDHAL_SETEXCLUSIVEMODE     SetExclusiveMode;
    LPDDHAL_FLIPTOGDISURFACE     FlipToGDISurface;
} DDHAL_DDCALLBACKS;

typedef DDHAL_DDCALLBACKS FAR *LPDDHAL_DDCALLBACKS;

#define DDHAL_CB32_DESTROYDRIVER	0x00000001l
#define DDHAL_CB32_CREATESURFACE	0x00000002l
#define DDHAL_CB32_SETCOLORKEY		0x00000004l
#define DDHAL_CB32_SETMODE		0x00000008l
#define DDHAL_CB32_WAITFORVERTICALBLANK	0x00000010l
#define DDHAL_CB32_CANCREATESURFACE	0x00000020l
#define DDHAL_CB32_CREATEPALETTE	0x00000040l
#define DDHAL_CB32_GETSCANLINE		0x00000080l
#define DDHAL_CB32_SETEXCLUSIVEMODE     0x00000100l
#define DDHAL_CB32_FLIPTOGDISURFACE     0x00000200l

/*
 * DIRECTDRAWPALETTE object callbacks
 */
typedef DWORD	(FAR PASCAL *LPDDHALPALCB_DESTROYPALETTE)(LPDDHAL_DESTROYPALETTEDATA );
typedef DWORD	(FAR PASCAL *LPDDHALPALCB_SETENTRIES)(LPDDHAL_SETENTRIESDATA );

typedef struct _DDHAL_DDPALETTECALLBACKS
{
    DWORD			dwSize;
    DWORD			dwFlags;
    LPDDHALPALCB_DESTROYPALETTE	DestroyPalette;
    LPDDHALPALCB_SETENTRIES	SetEntries;
} DDHAL_DDPALETTECALLBACKS;

typedef DDHAL_DDPALETTECALLBACKS FAR *LPDDHAL_DDPALETTECALLBACKS;

#define DDHAL_PALCB32_DESTROYPALETTE	0x00000001l
#define DDHAL_PALCB32_SETENTRIES	0x00000002l

/*
 * DIRECTDRAWSURFACE object callbacks
 */
typedef DWORD	(FAR PASCAL *LPDDHALSURFCB_LOCK)(LPDDHAL_LOCKDATA);
typedef DWORD	(FAR PASCAL *LPDDHALSURFCB_UNLOCK)(LPDDHAL_UNLOCKDATA);
typedef DWORD	(FAR PASCAL *LPDDHALSURFCB_BLT)(LPDDHAL_BLTDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_UPDATEOVERLAY)(LPDDHAL_UPDATEOVERLAYDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_SETOVERLAYPOSITION)(LPDDHAL_SETOVERLAYPOSITIONDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_SETPALETTE)(LPDDHAL_SETPALETTEDATA);
typedef DWORD	(FAR PASCAL *LPDDHALSURFCB_FLIP)(LPDDHAL_FLIPDATA);
typedef DWORD	(FAR PASCAL *LPDDHALSURFCB_DESTROYSURFACE)(LPDDHAL_DESTROYSURFACEDATA);
typedef DWORD	(FAR PASCAL *LPDDHALSURFCB_SETCLIPLIST)(LPDDHAL_SETCLIPLISTDATA);
typedef DWORD	(FAR PASCAL *LPDDHALSURFCB_ADDATTACHEDSURFACE)(LPDDHAL_ADDATTACHEDSURFACEDATA);
typedef DWORD	(FAR PASCAL *LPDDHALSURFCB_SETCOLORKEY)(LPDDHAL_SETCOLORKEYDATA);
typedef DWORD	(FAR PASCAL *LPDDHALSURFCB_GETBLTSTATUS)(LPDDHAL_GETBLTSTATUSDATA);
typedef DWORD	(FAR PASCAL *LPDDHALSURFCB_GETFLIPSTATUS)(LPDDHAL_GETFLIPSTATUSDATA);


typedef struct _DDHAL_DDSURFACECALLBACKS
{
    DWORD				dwSize;
    DWORD				dwFlags;
    LPDDHALSURFCB_DESTROYSURFACE	DestroySurface;
    LPDDHALSURFCB_FLIP			Flip;
    LPDDHALSURFCB_SETCLIPLIST		SetClipList;
    LPDDHALSURFCB_LOCK			Lock;
    LPDDHALSURFCB_UNLOCK		Unlock;
    LPDDHALSURFCB_BLT			Blt;
    LPDDHALSURFCB_SETCOLORKEY		SetColorKey;
    LPDDHALSURFCB_ADDATTACHEDSURFACE	AddAttachedSurface;
    LPDDHALSURFCB_GETBLTSTATUS		GetBltStatus;
    LPDDHALSURFCB_GETFLIPSTATUS		GetFlipStatus;
    LPDDHALSURFCB_UPDATEOVERLAY		UpdateOverlay;
    LPDDHALSURFCB_SETOVERLAYPOSITION	SetOverlayPosition;
    LPVOID				reserved4;
    LPDDHALSURFCB_SETPALETTE		SetPalette;
} DDHAL_DDSURFACECALLBACKS;
typedef DDHAL_DDSURFACECALLBACKS FAR *LPDDHAL_DDSURFACECALLBACKS;

#define DDHAL_SURFCB32_DESTROYSURFACE		0x00000001l
#define DDHAL_SURFCB32_FLIP			0x00000002l
#define DDHAL_SURFCB32_SETCLIPLIST		0x00000004l
#define DDHAL_SURFCB32_LOCK			0x00000008l
#define DDHAL_SURFCB32_UNLOCK			0x00000010l
#define DDHAL_SURFCB32_BLT			0x00000020l
#define DDHAL_SURFCB32_SETCOLORKEY		0x00000040l
#define DDHAL_SURFCB32_ADDATTACHEDSURFACE	0x00000080l
#define DDHAL_SURFCB32_GETBLTSTATUS  		0x00000100l
#define DDHAL_SURFCB32_GETFLIPSTATUS  		0x00000200l
#define DDHAL_SURFCB32_UPDATEOVERLAY		0x00000400l
#define DDHAL_SURFCB32_SETOVERLAYPOSITION	0x00000800l
#define DDHAL_SURFCB32_RESERVED4		0x00001000l
#define DDHAL_SURFCB32_SETPALETTE		0x00002000l

/*
 * DIRECTDRAWEXEBUF pseudo object callbacks
 *
 * NOTE: Execute buffers are not a distinct object type, they piggy back off
 * the surface data structures and high level API. However, they have their
 * own HAL callbacks as they may have different driver semantics from "normal"
 * surfaces. They also piggy back off the HAL data structures.
 *
 * !!! NOTE: Need to resolve whether we export execute buffer copying as a
 * blit or some other from of copy instruction.
 */
typedef DWORD	(FAR PASCAL *LPDDHALEXEBUFCB_CANCREATEEXEBUF)(LPDDHAL_CANCREATESURFACEDATA );
typedef DWORD	(FAR PASCAL *LPDDHALEXEBUFCB_CREATEEXEBUF)(LPDDHAL_CREATESURFACEDATA);
typedef DWORD	(FAR PASCAL *LPDDHALEXEBUFCB_DESTROYEXEBUF)(LPDDHAL_DESTROYSURFACEDATA);
typedef DWORD	(FAR PASCAL *LPDDHALEXEBUFCB_LOCKEXEBUF)(LPDDHAL_LOCKDATA);
typedef DWORD	(FAR PASCAL *LPDDHALEXEBUFCB_UNLOCKEXEBUF)(LPDDHAL_UNLOCKDATA);

typedef struct _DDHAL_DDEXEBUFCALLBACKS
{
    DWORD				dwSize;
    DWORD				dwFlags;
    LPDDHALEXEBUFCB_CANCREATEEXEBUF	CanCreateExecuteBuffer;
    LPDDHALEXEBUFCB_CREATEEXEBUF	CreateExecuteBuffer;
    LPDDHALEXEBUFCB_DESTROYEXEBUF	DestroyExecuteBuffer;
    LPDDHALEXEBUFCB_LOCKEXEBUF		LockExecuteBuffer;
    LPDDHALEXEBUFCB_UNLOCKEXEBUF	UnlockExecuteBuffer;
} DDHAL_DDEXEBUFCALLBACKS;
typedef DDHAL_DDEXEBUFCALLBACKS FAR *LPDDHAL_DDEXEBUFCALLBACKS;

#define DDHAL_EXEBUFCB32_CANCREATEEXEBUF	0x00000001l
#define DDHAL_EXEBUFCB32_CREATEEXEBUF		0x00000002l
#define DDHAL_EXEBUFCB32_DESTROYEXEBUF		0x00000004l
#define DDHAL_EXEBUFCB32_LOCKEXEBUF		0x00000008l
#define DDHAL_EXEBUFCB32_UNLOCKEXEBUF		0x00000010l

/*
 * CALLBACK RETURN VALUES
 *				        * these are values returned by the driver from the above callback routines
 */
/*
 * indicates that the display driver didn't do anything with the call
 */
#define DDHAL_DRIVER_NOTHANDLED		0x00000000l

/*
 * indicates that the display driver handled the call; HRESULT value is valid
 */
#define DDHAL_DRIVER_HANDLED		0x00000001l

/*
 * indicates that the display driver couldn't handle the call because it
 * ran out of color key hardware resources
 */
#define DDHAL_DRIVER_NOCKEYHW		0x00000002l

/*
 * DDRAW palette interface struct
 */
typedef struct _DDRAWI_DDRAWPALETTE_INT
{
    LPVOID				lpVtbl;		// pointer to array of interface methods
    LPDDRAWI_DDRAWPALETTE_LCL		lpLcl;		// pointer to interface data
    LPDDRAWI_DDRAWPALETTE_INT		lpLink;		// link to next interface
    DWORD				dwIntRefCnt;	// interface reference count
} DDRAWI_DDRAWPALETTE_INT;

/*
 * DDRAW internal version of DIRECTDRAWPALETTE object; it has data after the vtable
 */
typedef struct _DDRAWI_DDRAWPALETTE_GBL
{
    DWORD			dwRefCnt;	// reference count
    DWORD			dwFlags;	// flags
    LPDDRAWI_DIRECTDRAW_LCL	lpDD_lcl;	// PRIVATE: DIRECTDRAW object
    DWORD			dwProcessId;	// owning process
    LPPALETTEENTRY              lpColorTable;   // array of palette entries
    union
    {
        DWORD			dwReserved1;	// reserved for use by display driver
        HPALETTE                hHELGDIPalette;
    };
} DDRAWI_DDRAWPALETTE_GBL;

/*
 * (CMcC) The palette no longer maintains a back pointer to the owning surface
 * (there may now be many owning surfaces). So the lpDDSurface is now dwReserved0
 * (this mod. assumes that sizeof(DWORD) == sizeof(LPDDRAWI_DDRAWSURFACE_LCL). A
 * fairly safe assumption I think.
 */
typedef struct _DDRAWI_DDRAWPALETTE_LCL
{
    DWORD				lpPalMore;	// pointer to additional local data
    LPDDRAWI_DDRAWPALETTE_GBL	 	lpGbl;		// pointer to data
    DWORD				dwUnused0;	// not currently used.
    DWORD				dwLocalRefCnt; 	// local ref cnt
    IUnknown				FAR *pUnkOuter;	// outer IUnknown
    LPDDRAWI_DIRECTDRAW_LCL		lpDD_lcl;	// pointer to owning local driver object
    DWORD				dwReserved1;	// reserved for use by display driver
} DDRAWI_DDRAWPALETTE_LCL;

#define DDRAWIPAL_256		0x00000001l	// 256 entry palette
#define DDRAWIPAL_16		0x00000002l	// 16 entry palette
#define	DDRAWIPAL_GDI   	0x00000004l	// palette allocated through GDI
#define DDRAWIPAL_STORED_8	0x00000008l	// palette stored as 8bpp/entry
#define DDRAWIPAL_STORED_16	0x00000010l	// palette stored as 16bpp/entry
#define DDRAWIPAL_STORED_24	0x00000020l	// palette stored as 24bpp/entry
#define	DDRAWIPAL_EXCLUSIVE	0x00000040l	// palette being used in exclusive mode
#define	DDRAWIPAL_INHEL		0x00000080l	// palette is done in the hel
#define DDRAWIPAL_DIRTY         0x00000100l     // gdi palette out 'o sync
#define DDRAWIPAL_ALLOW256	0x00000200l	// can fully update palette
#define DDRAWIPAL_4             0x00000400l     // 4 entry palette
#define DDRAWIPAL_2             0x00000800l     // 2 entry palette
#define DDRAWIPAL_STORED_8INDEX 0x00001000l     // palatte stored as 8-bit index into dst palette

/*
 * DDRAW clipper interface struct
 */
typedef struct _DDRAWI_DDRAWCLIPPER_INT
{
    LPVOID				lpVtbl;		// pointer to array of interface methods
    LPDDRAWI_DDRAWCLIPPER_LCL		lpLcl;		// pointer to interface data
    LPDDRAWI_DDRAWCLIPPER_INT		lpLink;		// link to next interface
    DWORD				dwIntRefCnt;	// interface reference count
} DDRAWI_DDRAWCLIPPER_INT;

/*
 * DDRAW internal version of DIRECTDRAWCLIPPER object; it has data after the vtable
 */
typedef struct _DDRAWI_DDRAWCLIPPER_GBL
{
    DWORD			dwRefCnt;	// reference count
    DWORD			dwFlags;	// flags
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// PRIVATE: DIRECTDRAW object
    DWORD			dwProcessId;	// owning process
    DWORD			dwReserved1;	// reserved for use by display driver
    DWORD			hWnd;		// window
    LPRGNDATA			lpStaticClipList; // clip list set by app
    #ifdef CLIPPER_NOTIFY
	LPWINWATCH		lpWW;		// window watch data
    #endif
} DDRAWI_DDRAWCLIPPER_GBL;

/*
 * (CMcC) As with palettes, the clipper no longer maintains a back pointer to the
 * owning surface (there may now be many owning surfaces). So the lpDDSurface
 * is now dwReserved0 (this mod. assumes that sizeof(DWORD) ==
 * sizeof(LPDDRAWI_DDRAWSURFACE_LCL). A fairly safe assumption I think.
 */
typedef struct _DDRAWI_DDRAWCLIPPER_LCL
{
    DWORD				lpClipMore;	// pointer to additional local data
    LPDDRAWI_DDRAWCLIPPER_GBL	 	lpGbl;		// pointer to data
    LPDDRAWI_DIRECTDRAW_LCL		lpDD_lcl;	// pointer to owning local DD object
    DWORD				dwLocalRefCnt;	// local ref cnt
    IUnknown				FAR *pUnkOuter;	// outer IUnknown
    LPDDRAWI_DIRECTDRAW_INT		lpDD_int;	// pointer to owning DD object interface
    DWORD				dwReserved1;	// reserved for use by display driver
} DDRAWI_DDRAWCLIPPER_LCL;

#define DDRAWICLIP_WATCHWINDOW		0x00000001l
#define DDRAWICLIP_ISINITIALIZED        0x00000002l

/*
 * ATTACHLIST - internally used to maintain list of attached surfaces
 */
typedef struct _ATTACHLIST
{
    DWORD				dwFlags;
    struct _ATTACHLIST			FAR *lpLink; 	  // link to next attached surface
    struct _DDRAWI_DDRAWSURFACE_LCL	FAR *lpAttached;  // attached surface local obj
    struct _DDRAWI_DDRAWSURFACE_INT	FAR *lpIAttached; // attached surface interface
} ATTACHLIST;
typedef ATTACHLIST FAR *LPATTACHLIST;
#define DDAL_IMPLICIT		0x00000001l

/*
 * DBLNODE - a node in a doubly-linked list of surface interfaces
 */
typedef struct _DBLNODE
{
    struct  _DBLNODE                    FAR *next;  // link to next node
    struct  _DBLNODE                    FAR *prev;  // link to previous node
    LPDDRAWI_DDRAWSURFACE_LCL           object;     // link to object
    LPDDRAWI_DDRAWSURFACE_INT		object_int; // object interface
} DBLNODE;
typedef DBLNODE FAR *LPDBLNODE;

/*
 * ACCESSRECTLIST - internally used to all rectangles that are accessed on a surface
 */
typedef struct _ACCESSRECTLIST
{
    struct _ACCESSRECTLIST FAR	*lpLink; 	// link to next attached surface
    RECT			rDest;		// rectangle being used
    LPDDRAWI_DIRECTDRAW_LCL	lpOwner;	// owning local object
    LPVOID			lpSurfaceData;	// associated screen ptr
} ACCESSRECTLIST;
typedef ACCESSRECTLIST FAR *LPACCESSRECTLIST;

/*
 * DDRAW surface interface struct
 */
typedef struct _DDRAWI_DDRAWSURFACE_INT
{
    LPVOID				lpVtbl;		// pointer to array of interface methods
    LPDDRAWI_DDRAWSURFACE_LCL		lpLcl;		// pointer to interface data
    LPDDRAWI_DDRAWSURFACE_INT		lpLink;		// link to next interface
    DWORD				dwIntRefCnt;	// interface reference count
} DDRAWI_DDRAWSURFACE_INT;

/*
 * DDRAW internal version of DIRECTDRAWSURFACE struct
 *
 * the GBL structure is global data for all duplicate objects
 */
typedef struct _DDRAWI_DDRAWSURFACE_GBL
{
    DWORD			dwRefCnt;	// reference count
    DWORD			dwGlobalFlags;	// global flags
    union
    {
	LPACCESSRECTLIST	lpRectList;	// list of accesses
	DWORD			dwBlockSizeY;	// block size that display driver requested (return)
    };
    union
    {
	LPVMEMHEAP		lpVidMemHeap;	// heap vidmem was alloc'ed from
	DWORD			dwBlockSizeX;	// block size that display driver requested (return)
    };
    union
    {
	LPDDRAWI_DIRECTDRAW_GBL lpDD; 		// internal DIRECTDRAW object
	LPVOID			lpDDHandle; 	// handle to internal DIRECTDRAW object
						// for use by display driver
						// when calling fns in DDRAW16.DLL
    };
    FLATPTR			fpVidMem;	// pointer to video memory
    union
    {
	LONG			lPitch;		// pitch of surface
	DWORD                   dwLinearSize;   // linear size of non-rectangular surface
    };
    WORD			wHeight;	// height of surface
    WORD			wWidth;		// width of surface
    DWORD			dwUsageCount;	// number of access to this surface
    DWORD			dwReserved1;	// reserved for use by display driver
    //
    // NOTE: this part of the structure is ONLY allocated if the pixel
    //	     format differs from that of the primary display
    //
    DDPIXELFORMAT		ddpfSurface;	// pixel format of surface

} DDRAWI_DDRAWSURFACE_GBL;

/*
 * a structure holding additional LCL surface information (can't simply be appended
 * to the LCL structure as that structure is of variable size).
 */
typedef struct _DDRAWI_DDRAWSURFACE_MORE
{
    DWORD			dwSize;
    IUNKNOWN_LIST		FAR *lpIUnknowns;   // IUnknowns aggregated by this surface
    LPDDRAWI_DIRECTDRAW_LCL	lpDD_lcl;	    // Pointer to the DirectDraw local object
    DWORD			dwPageLockCount;    // count of pagelocks
    DWORD			dwBytesAllocated;   // size of sys mem allocated
    LPDDRAWI_DIRECTDRAW_INT	lpDD_int;	    // Pointer to the DirectDraw interface
    DWORD                       dwMipMapCount;      // Number of mip-map levels in the chain
    LPDDRAWI_DDRAWCLIPPER_INT	lpDDIClipper;	    // Interface to attached clipper object
} DDRAWI_DDRAWSURFACE_MORE;

/*
 * the LCL structure is local data for each individual surface object
 */
struct _DDRAWI_DDRAWSURFACE_LCL
{
    LPDDRAWI_DDRAWSURFACE_MORE		lpSurfMore;	// pointer to additional local data
    LPDDRAWI_DDRAWSURFACE_GBL		lpGbl;		// pointer to surface shared data
    DWORD                               hDDSurface;     // NT Kernel-mode handle was dwUnused0
    LPATTACHLIST			lpAttachList;	// link to surfaces we attached to
    LPATTACHLIST			lpAttachListFrom;// link to surfaces that attached to this one
    DWORD				dwLocalRefCnt;	// object refcnt
    DWORD				dwProcessId;	// owning process
    DWORD				dwFlags;	// flags
    DDSCAPS				ddsCaps;	// capabilities of surface
    union
    {
	LPDDRAWI_DDRAWPALETTE_INT 	lpDDPalette; 	// associated palette
	LPDDRAWI_DDRAWPALETTE_INT 	lp16DDPalette; 	// 16-bit ptr to associated palette
    };
    union
    {
	LPDDRAWI_DDRAWCLIPPER_LCL 	lpDDClipper; 	// associated clipper
	LPDDRAWI_DDRAWCLIPPER_INT 	lp16DDClipper; 	// 16-bit ptr to associated clipper
    };
    DWORD				dwModeCreatedIn;
    DWORD				dwBackBufferCount; // number of back buffers created
    DDCOLORKEY				ddckCKDestBlt;	// color key for destination blt use
    DDCOLORKEY				ddckCKSrcBlt;	// color key for source blt use
//    IUnknown				FAR *pUnkOuter;	// outer IUnknown
    DWORD				hDC;		// owned dc
    DWORD				dwReserved1;	// reserved for use by display driver

    /*
     * NOTE: this part of the structure is ONLY allocated if the surface
     *	     can be used for overlays.  ddckCKSrcOverlay MUST NOT BE MOVED
     *	     from the start of this area.
     */
    DDCOLORKEY				ddckCKSrcOverlay;// color key for source overlay use
    DDCOLORKEY				ddckCKDestOverlay;// color key for destination overlay use
    LPDDRAWI_DDRAWSURFACE_INT		lpSurfaceOverlaying; // surface we are overlaying
    DBLNODE				dbnOverlayNode; 
    /*
     * overlay rectangle, used by DDHEL
     */
    RECT				rcOverlaySrc;
    RECT				rcOverlayDest;
    /*
     * the below values are kept here for ddhel. they're set by UpdateOverlay,
     * they're used whenever the overlays are redrawn.
     */
    DWORD				dwClrXparent; 	// the *actual* color key (override, colorkey, or CLR_INVALID)
    DWORD				dwAlpha; 	// the per surface alpha
    /*
     * overlay position
     */
    LONG				lOverlayX;	// current x position
    LONG				lOverlayY;	// current y position
};
typedef struct _DDRAWI_DDRAWSURFACE_LCL DDRAWI_DDRAWSURFACE_LCL;

//@@BEGIN_MSINTERNAL
#ifdef STREAMING
struct _DDRAWI_DIRECTDRAWSURFACESTREAMING
{
    LPVOID				lpVtbl;		// pointer to array of callback fns
    LPDDRAWI_DDRAWSURFACE_GBL		lpGbl;		// pointer to surface data
    DWORD				dwLocalRefCnt;	// object refcnt
    DWORD				dwProcessId;	// owning process
    LPSURFACESTREAMINGCALLBACK		lpCallback;	// callback
};
typedef struct _DDRAWI_DIRECTDRAWSURFACESTREAMING DDRAWI_DIRECTDRAWSURFACESTREAMING;
#endif
//@@END_MSINTERNAL

#define DDRAWISURFGBL_MEMFREE		0x00000001L	// video memory has been freed
#define DDRAWISURFGBL_SYSMEMREQUESTED	0x00000002L	// surface is in system memory at request of user
#define DDRAWISURFGBL_ISGDISURFACE      0x00000004L     // This surface represents what GDI thinks is front buffer
/*
 * NOTE: This flag was previously DDRAWISURFGBL_INVALID. This flags has been retired
 * and replaced by DDRAWISURF_INVALID in the local object.
 */
#define DDRAWISURFGBL_RESERVED0		0x80000000L	// Reserved flag

#define DDRAWISURF_ATTACHED		0x00000001L	// surface is attached to another
#define DDRAWISURF_IMPLICITCREATE 	0x00000002L	// surface implicitly created
#define DDRAWISURF_ISFREE		0x00000004L	// surface already freed (temp flag)
#define DDRAWISURF_ATTACHED_FROM 	0x00000008L	// surface has others attached to it
#define DDRAWISURF_IMPLICITROOT		0x00000010L	// surface root of implicit creation
#define DDRAWISURF_PARTOFPRIMARYCHAIN	0x00000020L	// surface is part of primary chain
#define DDRAWISURF_DATAISALIASED	0x00000040L	// used for thunking
#define DDRAWISURF_HASDC		0x00000080L	// has a DC
#define DDRAWISURF_HASCKEYDESTOVERLAY	0x00000100L	// surface has CKDestOverlay
#define DDRAWISURF_HASCKEYDESTBLT	0x00000200L	// surface has CKDestBlt
#define DDRAWISURF_HASCKEYSRCOVERLAY	0x00000400L	// surface has CKSrcOverlay
#define DDRAWISURF_HASCKEYSRCBLT	0x00000800L	// surface has CKSrcBlt
#define DDRAWISURF_LOCKEXCLUDEDCURSOR	0x00001000L	// surface was locked and excluded cursor
#define DDRAWISURF_HASPIXELFORMAT	0x00002000L	// surface structure has pixel format data
#define DDRAWISURF_HASOVERLAYDATA	0x00004000L	// surface structure has overlay data
#define DDRAWISURF_xxxxxxxxxxx5		0x00008000L	// spare bit
#define DDRAWISURF_SW_CKEYDESTOVERLAY	0x00010000L	// surface expects to process colorkey in software
#define DDRAWISURF_SW_CKEYDESTBLT	0x00020000L	// surface expects to process colorkey in software
#define DDRAWISURF_SW_CKEYSRCOVERLAY	0x00040000L	// surface expects to process colorkey in software
#define DDRAWISURF_SW_CKEYSRCBLT	0x00080000L	// surface expects to process colorkey in software
#define DDRAWISURF_HW_CKEYDESTOVERLAY	0x00100000L	// surface expects to process colorkey in hardware
#define DDRAWISURF_HW_CKEYDESTBLT	0x00200000L	// surface expects to process colorkey in hardware
#define DDRAWISURF_HW_CKEYSRCOVERLAY	0x00400000L	// surface expects to process colorkey in hardware
#define DDRAWISURF_HW_CKEYSRCBLT	0x00800000L	// surface expects to process colorkey in hardware
#define DDRAWISURF_xxxxxxxxxxx6 	0x01000000L	// spare bit
#define DDRAWISURF_HELCB		0x02000000L	// surface is the ddhel cb. must call hel for lock/blt.
#define DDRAWISURF_FRONTBUFFER		0x04000000L	// surface was originally a front buffer
#define DDRAWISURF_BACKBUFFER		0x08000000L	// surface was originally backbuffer
#define DDRAWISURF_INVALID              0x10000000L     // surface has been invalidated by mode set
#define DDRAWISURF_DCIBUSY              0x20000000L     // HEL has turned off BUSY so DCI would work
#define DDRAWISURF_GETDCNULL            0x40000000L     // getdc could not lock and so returned GetDC(NULL)


/*
 * rop stuff
 */
#define ROP_HAS_SOURCE		0x00000001l
#define ROP_HAS_PATTERN		0x00000002l
#define	ROP_HAS_SOURCEPATTERN	ROP_HAS_SOURCE | ROP_HAS_PATTERN

/*
 * mode information
 */
typedef struct _DDHALMODEINFO
{
    DWORD	dwWidth;		// width (in pixels) of mode
    DWORD	dwHeight;		// height (in pixels) of mode
    LONG	lPitch;			// pitch (in bytes) of mode
    DWORD	dwBPP;			// bits per pixel
    WORD	wFlags;			// flags
    WORD	wRefreshRate;		// refresh rate
    DWORD	dwRBitMask;		// red bit mask
    DWORD	dwGBitMask;		// green bit mask
    DWORD	dwBBitMask;		// blue bit mask
    DWORD	dwAlphaBitMask;		// alpha bit mask
} DDHALMODEINFO;
typedef DDHALMODEINFO FAR *LPDDHALMODEINFO;

#define DDMODEINFO_PALETTIZED	0x0001	// mode is palettized
#define DDMODEINFO_MODEX        0x0002  // mode is a modex mode
#define DDMODEINFO_UNSUPPORTED	0x0004	// mode is not supported by driver

//@@BEGIN_MSINTERNAL
#define DDMODEINFO_VALID        0x0003  // valid
//@@END_MSINTERNAL

/*
 * DDRAW interface struct
 */
typedef struct _DDRAWI_DIRECTDRAW_INT
{
    LPVOID				lpVtbl;		// pointer to array of interface methods
    LPDDRAWI_DIRECTDRAW_LCL		lpLcl;		// pointer to interface data
    LPDDRAWI_DIRECTDRAW_INT		lpLink;		// link to next interface
    DWORD				dwIntRefCnt;	// interface reference count
} DDRAWI_DIRECTDRAW_INT;

/*
 * DDRAW version of DirectDraw object; it has data after the vtable
 *
 * all entries marked as PRIVATE are not for use by the display driver
 */
typedef struct _DDHAL_CALLBACKS
{
    DDHAL_DDCALLBACKS		cbDDCallbacks;	// addresses in display driver for DIRECTDRAW object HAL
    DDHAL_DDSURFACECALLBACKS	cbDDSurfaceCallbacks; // addresses in display driver for DIRECTDRAWSURFACE object HAL
    DDHAL_DDPALETTECALLBACKS	cbDDPaletteCallbacks; // addresses in display driver for DIRECTDRAWPALETTE object HAL
    DDHAL_DDCALLBACKS		HALDD; 		// HAL for DIRECTDRAW object
    DDHAL_DDSURFACECALLBACKS	HALDDSurface; 	// HAL for DIRECTDRAWSURFACE object
    DDHAL_DDPALETTECALLBACKS	HALDDPalette; 	// HAL for DIRECTDRAWPALETTE object
    DDHAL_DDCALLBACKS		HELDD; 		// HEL for DIRECTDRAW object
    DDHAL_DDSURFACECALLBACKS	HELDDSurface; 	// HEL for DIRECTDRAWSURFACE object
    DDHAL_DDPALETTECALLBACKS	HELDDPalette; 	// HEL for DIRECTDRAWPALETTE object
    DDHAL_DDEXEBUFCALLBACKS     cbDDExeBufCallbacks; // addresses in display driver for DIRECTDRAWEXEBUF pseudo object HAL
    DDHAL_DDEXEBUFCALLBACKS     HALDDExeBuf;    // HAL for DIRECTDRAWEXEBUF pseudo object
    DDHAL_DDEXEBUFCALLBACKS     HELDDExeBuf;    // HEL for DIRECTDRAWEXEBUF preudo object
 } DDHAL_CALLBACKS, far *LPDDHAL_CALLBACKS;
     

typedef struct _DDRAWI_DIRECTDRAW_GBL
{
    DWORD			dwRefCnt;	// reference count
    DWORD			dwFlags;	// flags
    FLATPTR			fpPrimaryOrig;	// primary surf vid mem. ptr
    DDCAPS			ddCaps;		// driver caps
    DWORD			dwUnused1[10];	// not currently used
    LPDDHAL_CALLBACKS		lpDDCBtmp;	// HAL callbacks
    LPDDRAWI_DDRAWSURFACE_INT	dsList;		// PRIVATE: list of all surfaces
    LPDDRAWI_DDRAWPALETTE_INT	palList;	// PRIVATE: list of all palettes
    LPDDRAWI_DDRAWCLIPPER_INT	clipperList;	// PRIVATE: list of all clippers
    LPDDRAWI_DIRECTDRAW_GBL	lp16DD;		// PRIVATE: 16-bit ptr to this struct
    DWORD			dwMaxOverlays;	// maximum number of overlays
    DWORD			dwCurrOverlays;	// current number of visible overlays
    DWORD			dwMonitorFrequency; // monitor frequency in current mode
    DDCAPS			ddHELCaps;	// HEL capabilities
    DWORD			dwUnused2[50];	// not currently used
    DDCOLORKEY			ddckCKDestOverlay; // color key for destination overlay use
    DDCOLORKEY			ddckCKSrcOverlay; // color key for source overlay use
    VIDMEMINFO			vmiData;	// info about vid memory
    LPVOID			lpDriverHandle;	// handle for use by display driver
    						// to call fns in DDRAW16.DLL
    LPDDRAWI_DIRECTDRAW_LCL	lpExclusiveOwner;   // PRIVATE: exclusive local object
    DWORD			dwModeIndex;	// current mode index
    DWORD			dwModeIndexOrig;// original mode index
    DWORD			dwNumFourCC;	// number of fourcc codes supported
    DWORD			FAR *lpdwFourCC;// PRIVATE: fourcc codes supported
    DWORD			dwNumModes;	// number of modes supported
    LPDDHALMODEINFO		lpModeInfo;	// PRIVATE: mode information
    PROCESS_LIST		plProcessList;	// PRIVATE: list of processes using driver
    DWORD                       dwSurfaceLockCount; // total number of outstanding locks
    DWORD                       dwFree1;        // PRIVATE: was system color table
    DWORD                       dwFree2;        // PRIVATE: was original palette
    DWORD                       hDD;            // PRIVATE: NT Kernel-mode handle (was dwFree3).
    char			cDriverName[MAX_DRIVER_NAME]; // Driver Name
    DWORD			dwReserved1;	// reserved for use by display driver
    DWORD			dwReserved2;	// reserved for use by display driver
    DBLNODE                     dbnOverlayRoot; // The root node of the doubly-
                                                // linked list of overlay z orders.
    volatile LPWORD             lpwPDeviceFlags;// driver physical device flags
    DWORD                       dwPDevice;      // driver physical device (16:16 pointer)
    DWORD			dwWin16LockCnt;	// count on win16 holds
    LPDDRAWI_DIRECTDRAW_LCL	lpWin16LockOwner;   // object owning Win16 Lock
    DWORD			hInstance;	// instance handle of driver
    DWORD			dwEvent16;	// 16-bit event
    DWORD                       dwSaveNumModes; // saved number of modes supported
    /*  Version 2 fields */
    DWORD                       lpD3DGlobalDriverData;	// Global D3D Data
    DWORD                       lpD3DHALCallbacks;	// D3D HAL Callbacks
    DDCAPS			ddBothCaps;	// logical AND of driver and HEL caps
} DDRAWI_DIRECTDRAW_GBL;

typedef struct _DDRAWI_DIRECTDRAW_LCL
{
    DWORD			lpDDMore;	    // pointer to additional local data
    LPDDRAWI_DIRECTDRAW_GBL     lpGbl;		    // pointer to data
    DWORD			dwUnused0;	    // not currently used
    DWORD                       dwLocalFlags;	    // local flags (DDRAWILCL_)
    DWORD                       dwLocalRefCnt;	    // local ref cnt
    DWORD                       dwProcessId;	    // owning process id
    IUnknown                    FAR *pUnkOuter;	    // outer IUnknown
    DWORD                       dwObsolete1;
    DWORD                       hWnd;
    DWORD			hDC;
    DWORD			dwErrorMode;
    LPDDRAWI_DDRAWSURFACE_INT	lpPrimary;
    LPDDRAWI_DDRAWSURFACE_INT	lpCB;
    DWORD			dwPreferredMode;
    //------- Fields added in Version 2.0 -------
    HINSTANCE                   hD3DInstance;	    // Handle of Direct3D's DLL.
    IUnknown                    FAR *pD3DIUnknown;  // Direct3D's aggregated IUnknown.
    LPDDHAL_CALLBACKS		lpDDCB;		    // HAL callbacks
#ifdef SHAREDZ
    LPDDRAWI_DDRAWSURFACE_INT   lpSharedZ;	    // Shared z-buffer (if any).
    LPDDRAWI_DDRAWSURFACE_INT   lpSharedBack;	    // Shared back-buffer (if any).
#endif
    DWORD			hDSVxd;		    // handle to dsound.vxd
} DDRAWI_DIRECTDRAW_LCL;

#define DDRAWILCL_HASEXCLUSIVEMODE	0x00000001l
#define DDRAWILCL_ISFULLSCREEN		0x00000002l
#define DDRAWILCL_SETCOOPCALLED		0x00000004l
#define	DDRAWILCL_ACTIVEYES		0x00000008l
#define	DDRAWILCL_ACTIVENO		0x00000010l
#define DDRAWILCL_HOOKEDHWND		0x00000020l
#define DDRAWILCL_ALLOWMODEX            0x00000040l
#define DDRAWILCL_V1SCLBEHAVIOUR	0x00000080l
#define DDRAWILCL_MODEHASBEENCHANGED    0x00000100l

#define DDRAWI_xxxxxxxxx1		0x00000001l     // unused
#define DDRAWI_xxxxxxxxx2       	0x00000002l	// unused
#define DDRAWI_xxxxxxxxx3		0x00000004l	// unused
#define DDRAWI_xxxxxxxxx4		0x00000008l	// unused
#define DDRAWI_MODEX			0x00000010l	// driver is using modex
#define DDRAWI_DISPLAYDRV		0x00000020l	// driver is display driver
#define DDRAWI_FULLSCREEN		0x00000040l	// driver in fullscreen mode
#define DDRAWI_MODECHANGED		0x00000080l	// display mode has been changed
#define DDRAWI_NOHARDWARE		0x00000100l	// no driver hardware at all
#define DDRAWI_PALETTEINIT		0x00000200l	// GDI palette stuff has been initalized
#define DDRAWI_NOEMULATION		0x00000400l	// no emulation at all
#define DDRAWI_HASCKEYDESTOVERLAY 	0x00000800l	// driver has CKDestOverlay
#define DDRAWI_HASCKEYSRCOVERLAY	0x00001000l	// driver has CKSrcOverlay
#define DDRAWI_HASGDIPALETTE		0x00002000l	// GDI palette exists on primary surface
#define DDRAWI_EMULATIONINITIALIZED	0x00004000l	// emulation is initialized
#define DDRAWI_HASGDIPALETTE_EXCLUSIVE	0x00008000l 	// exclusive mode palette
#define DDRAWI_MODEXILLEGAL		0x00010000l	// modex is not supported by this hardware
#define DDRAWI_FLIPPEDTOGDI             0x00020000l     // driver has been flipped to show GDI surface

//@@BEGIN_MSINTERNAL
/*
 * The following structure is equivalent to the DDHALINFO structure defined in DirectDraw 1.0.
 * It is used by DirectDraw internally to interpret the DDHALINFO information passed from drivers written
 * prior to DirectDraw 2.0.  New applications and drivers should use the DDHALINFO structure defined after
 * this one.  DirectDraw distinguishes between the structures via the dwSize field.
 */
typedef struct _DDHALINFO_V1
{
    DWORD			dwSize;
    LPDDHAL_DDCALLBACKS		lpDDCallbacks;		// direct draw object callbacks
    LPDDHAL_DDSURFACECALLBACKS	lpDDSurfaceCallbacks;	// surface object callbacks
    LPDDHAL_DDPALETTECALLBACKS	lpDDPaletteCallbacks;	// palette object callbacks
    VIDMEMINFO			vmiData;		// video memory info
    DDCAPS_V1			ddCaps;			// hw specific caps
    DWORD			dwMonitorFrequency;	// monitor frequency in current mode
    DWORD			hWndListBox;		// list box for debug output
    DWORD			dwModeIndex;		// current mode: index into array
    LPDWORD			lpdwFourCC;		// fourcc codes supported
    DWORD			dwNumModes;		// number of modes supported
    LPDDHALMODEINFO		lpModeInfo;		// mode information
    DWORD			dwFlags;		// create flags
    LPVOID			lpPDevice;		// physical device ptr
    DWORD			hInstance;		// instance handle of driver
} DDHALINFO_V1;
typedef DDHALINFO_V1 FAR *LPDDHALINFO_V1;
#define DDHALINFOSIZE_V1 sizeof( DDHALINFO_V1)

/*
 * CAUTION: Size of the interm DDHALSTRUCTURE (post V1.0 pre V2.0)
 * Here temporarily only. Added (03/02/96). Should be removed by
 * (03/07/96). If not come and get me. colinmc
 */
#define DDHALINFOSIZE_VINTERIM           \
    (DDHALINFOSIZE_V1 +                  \
    (sizeof(DWORD) * 2UL) +              \
    (sizeof(LPDDHAL_DDEXEBUFCALLBACKS)))

//@@END_MSINTERNAL
/*
 * structure for display driver to call DDHAL_Create with
 */
typedef struct _DDHALINFO
{
    DWORD			dwSize;
    LPDDHAL_DDCALLBACKS		lpDDCallbacks;		// direct draw object callbacks
    LPDDHAL_DDSURFACECALLBACKS	lpDDSurfaceCallbacks;	// surface object callbacks
    LPDDHAL_DDPALETTECALLBACKS	lpDDPaletteCallbacks;	// palette object callbacks
    VIDMEMINFO			vmiData;		// video memory info
    DDCAPS			ddCaps;			// hw specific caps
    DWORD			dwMonitorFrequency;	// monitor frequency in current mode
    DWORD			hWndListBox;		// list box for debug output
    DWORD			dwModeIndex;		// current mode: index into array
    LPDWORD			lpdwFourCC;		// fourcc codes supported
    DWORD			dwNumModes;		// number of modes supported
    LPDDHALMODEINFO		lpModeInfo;		// mode information
    DWORD			dwFlags;		// create flags
    LPVOID			lpPDevice;		// physical device ptr
    DWORD			hInstance;		// instance handle of driver
    //------- Fields added in Version 2.0 -------
    DWORD	                lpD3DGlobalDriverData;	// D3D global Data
    DWORD		        lpD3DHALCallbacks;	// D3D callbacks
    LPDDHAL_DDEXEBUFCALLBACKS   lpDDExeBufCallbacks;    // Execute buffer pseudo object callbacks
} DDHALINFO;
typedef DDHALINFO FAR *LPDDHALINFO;
#define DDHALINFOSIZE_V2 sizeof( DDHALINFO )

#define DDHALINFO_ISPRIMARYDISPLAY	0x00000001l	// indicates driver is primary display driver
#define DDHALINFO_MODEXILLEGAL		0x00000002l	// indicates this hardware does not support modex modes

/*
 * DDRAW16.DLL entry points
 */
typedef BOOL (DDAPI *LPDDHAL_SETINFO)( LPDDHALINFO lpDDHalInfo, BOOL reset );
typedef FLATPTR (DDAPI *LPDDHAL_VIDMEMALLOC)( LPDDRAWI_DIRECTDRAW_GBL lpDD, int heap, DWORD dwWidth, DWORD dwHeight );
typedef void (DDAPI *LPDDHAL_VIDMEMFREE)( LPDDRAWI_DIRECTDRAW_GBL lpDD, int heap, FLATPTR fpMem );

extern BOOL DDAPI DDHAL_SetInfo( LPDDHALINFO lpDDHALInfo, BOOL reset );
extern FLATPTR DDAPI DDHAL_VidMemAlloc( LPDDRAWI_DIRECTDRAW_GBL lpDD, int heap, DWORD dwWidth, DWORD dwHeight );
extern void DDAPI DDHAL_VidMemFree( LPDDRAWI_DIRECTDRAW_GBL lpDD, int heap, FLATPTR fpMem );


typedef struct
{
    DWORD		dwSize;
    LPDDHAL_SETINFO	lpSetInfo;
    LPDDHAL_VIDMEMALLOC	lpVidMemAlloc;
    LPDDHAL_VIDMEMFREE	lpVidMemFree;
} DDHALDDRAWFNS;
typedef DDHALDDRAWFNS FAR *LPDDHALDDRAWFNS;

/****************************************************************************
 *
 * DDHAL structures for Surface Object callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL Blt fn
 */
typedef struct _DDHAL_BLTDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDDestSurface;// dest surface
    RECTL			rDest;		// dest rect
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSrcSurface;	// src surface
    RECTL			rSrc;		// src rect
    DWORD			dwFlags;	// blt flags
    DWORD			dwROPFlags;	// ROP flags (valid for ROPS only)
    DDBLTFX			bltFX;		// blt FX
    HRESULT			ddRVal;		// return value
    LPDDHALSURFCB_BLT		Blt;		// PRIVATE: ptr to callback
    BOOL                        IsClipped;      // clipped blt?
    RECTL			rOrigDest;	// unclipped dest rect
						// (only valid if IsClipped)
    RECTL			rOrigSrc;	// unclipped src rect
						// (only valid if IsClipped)
    DWORD			dwRectCnt;	// count of dest rects
						// (only valid if IsClipped)
    LPRECT			prDestRects;	// array of dest rects
						// (only valid if IsClipped)
} DDHAL_BLTDATA;

/*
 * structure for passing information to DDHAL Lock fn
 */
typedef struct _DDHAL_LOCKDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSurface;	// surface struct
    DWORD			bHasRect;	// rArea is valid
    RECTL			rArea;		// area being locked
    LPVOID			lpSurfData;	// pointer to screen memory (return value)
    HRESULT			ddRVal;		// return value
    LPDDHALSURFCB_LOCK          Lock;           // PRIVATE: ptr to callback
    DWORD                       dwFlags;        // DDLOCK flags
} DDHAL_LOCKDATA;

/*
 * structure for passing information to DDHAL Unlock fn
 */
typedef struct _DDHAL_UNLOCKDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSurface;	// surface struct
    HRESULT			ddRVal;         // return value
    LPDDHALSURFCB_UNLOCK	Unlock;		// PRIVATE: ptr to callback
} DDHAL_UNLOCKDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DDHAL_UPDATEOVERLAYDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDDestSurface;// dest surface
    RECTL			rDest;		// dest rect
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSrcSurface;	// src surface
    RECTL			rSrc;		// src rect
    DWORD			dwFlags;	// flags
    DDOVERLAYFX			overlayFX;	// overlay FX
    HRESULT			ddRVal;		// return value
    LPDDHALSURFCB_UPDATEOVERLAY UpdateOverlay;	// PRIVATE: ptr to callback
} DDHAL_UPDATEOVERLAYDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DDHAL_SETOVERLAYPOSITIONDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSrcSurface;	// src surface
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDDestSurface;// dest surface
    LONG			lXPos;		// x position
    LONG			lYPos;		// y position
    HRESULT			ddRVal;		// return value
    LPDDHALSURFCB_SETOVERLAYPOSITION SetOverlayPosition; // PRIVATE: ptr to callback
} DDHAL_SETOVERLAYPOSITIONDATA;
/*
 * structure for passing information to DDHAL SetPalette fn
 */
typedef struct _DDHAL_SETPALETTEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSurface;	// surface struct
    LPDDRAWI_DDRAWPALETTE_GBL	lpDDPalette;	// palette to set to surface
    HRESULT			ddRVal;		// return value
    LPDDHALSURFCB_SETPALETTE	SetPalette;	// PRIVATE: ptr to callback
    BOOL                        Attach;         // attach this palette?
} DDHAL_SETPALETTEDATA;

/*
 * structure for passing information to DDHAL Flip fn
 */
typedef struct _DDHAL_FLIPDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL	lpSurfCurr;	// current surface
    LPDDRAWI_DDRAWSURFACE_LCL	lpSurfTarg;	// target surface (to flip to)
    DWORD			dwFlags;	// flags
    HRESULT			ddRVal;		// return value
    LPDDHALSURFCB_FLIP		Flip;		// PRIVATE: ptr to callback
} DDHAL_FLIPDATA;

/*
 * structure for passing information to DDHAL DestroySurface fn
 */
typedef struct _DDHAL_DESTROYSURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSurface;	// surface struct
    HRESULT			ddRVal;		// return value
    LPDDHALSURFCB_DESTROYSURFACE DestroySurface;// PRIVATE: ptr to callback
} DDHAL_DESTROYSURFACEDATA;

/*
 * structure for passing information to DDHAL SetClipList fn
 */
typedef struct _DDHAL_SETCLIPLISTDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSurface;	// surface struct
    HRESULT			ddRVal;		// return value
    LPDDHALSURFCB_SETCLIPLIST	SetClipList;	// PRIVATE: ptr to callback
} DDHAL_SETCLIPLISTDATA;

/*
 * structure for passing information to DDHAL AddAttachedSurface fn
 */
typedef struct _DDHAL_ADDATTACHEDSURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL		lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL		lpDDSurface;	// surface struct
    LPDDRAWI_DDRAWSURFACE_LCL		lpSurfAttached;	// surface to attach
    HRESULT				ddRVal;		// return value
    LPDDHALSURFCB_ADDATTACHEDSURFACE	AddAttachedSurface; // PRIVATE: ptr to callback
} DDHAL_ADDATTACHEDSURFACEDATA;

/*
 * structure for passing information to DDHAL SetColorKey fn
 */
typedef struct _DDHAL_SETCOLORKEYDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSurface;	// surface struct
    DWORD 			dwFlags;	// flags
    DDCOLORKEY 			ckNew;		// new color key
    HRESULT			ddRVal;		// return value
    LPDDHALSURFCB_SETCOLORKEY	SetColorKey;	// PRIVATE: ptr to callback
} DDHAL_SETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetBltStatus fn
 */
typedef struct _DDHAL_GETBLTSTATUSDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSurface;	// surface struct
    DWORD			dwFlags;	// flags
    HRESULT			ddRVal;		// return value
    LPDDHALSURFCB_GETBLTSTATUS	GetBltStatus;	// PRIVATE: ptr to callback
} DDHAL_GETBLTSTATUSDATA;

/*
 * structure for passing information to DDHAL GetFlipStatus fn
 */
typedef struct _DDHAL_GETFLIPSTATUSDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSurface;	// surface struct
    DWORD			dwFlags;	// flags
    HRESULT			ddRVal;		// return value
    LPDDHALSURFCB_GETFLIPSTATUS	GetFlipStatus;	// PRIVATE: ptr to callback
} DDHAL_GETFLIPSTATUSDATA;

/****************************************************************************
 *
 * DDHAL structures for Palette Object callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL DestroyPalette fn
 */
typedef struct _DDHAL_DESTROYPALETTEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWPALETTE_GBL	lpDDPalette;	// palette struct
    HRESULT			ddRVal;		// return value
    LPDDHALPALCB_DESTROYPALETTE	DestroyPalette;	// PRIVATE: ptr to callback
} DDHAL_DESTROYPALETTEDATA;

/*
 * structure for passing information to DDHAL SetEntries fn
 */
typedef struct _DDHAL_SETENTRIESDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWPALETTE_GBL	lpDDPalette;	// palette struct
    DWORD			dwBase;		// base palette index
    DWORD			dwNumEntries;	// number of palette entries
    LPPALETTEENTRY		lpEntries;	// color table
    HRESULT			ddRVal;		// return value
    LPDDHALPALCB_SETENTRIES	SetEntries;	// PRIVATE: ptr to callback
} DDHAL_SETENTRIESDATA;

/****************************************************************************
 *
 * DDHAL structures for Driver Object callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL CreateSurface fn
 */
typedef struct _DDHAL_CREATESURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDSURFACEDESC		lpDDSurfaceDesc;// description of surface being created
    LPDDRAWI_DDRAWSURFACE_LCL	FAR *lplpSList;	// list of created surface objects
    DWORD			dwSCnt;		// number of surfaces in SList
    HRESULT			ddRVal;		// return value
    LPDDHAL_CREATESURFACE	CreateSurface;	// PRIVATE: ptr to callback
} DDHAL_CREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CanCreateSurface fn
 */
typedef struct _DDHAL_CANCREATESURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;			// driver struct
    LPDDSURFACEDESC		lpDDSurfaceDesc;	// description of surface being created
    DWORD			bIsDifferentPixelFormat;// pixel format differs from primary surface
    HRESULT			ddRVal;			// return value
    LPDDHAL_CANCREATESURFACE	CanCreateSurface;	// PRIVATE: ptr to callback
} DDHAL_CANCREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CreatePalette fn
 */
typedef struct _DDHAL_CREATEPALETTEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    LPDDRAWI_DDRAWPALETTE_GBL	lpDDPalette;	// ddraw palette struct
    LPPALETTEENTRY 		lpColorTable; 	// colors to go in palette
    HRESULT			ddRVal;		// return value
    LPDDHAL_CREATEPALETTE	CreatePalette;	// PRIVATE: ptr to callback
    BOOL                        is_excl;        // process has exclusive mode
} DDHAL_CREATEPALETTEDATA;

/*
 * Return if the vertical blank is in progress 
 */
#define DDWAITVB_I_TESTVB			0x80000006l

/*
 * structure for passing information to DDHAL WaitForVerticalBlank fn
 */
typedef struct _DDHAL_WAITFORVERTICALBLANKDATA
{
    LPDDRAWI_DIRECTDRAW_GBL		lpDD;		// driver struct
    DWORD				dwFlags;	// flags
    DWORD				bIsInVB;	// is in vertical blank
    DWORD				hEvent;		// event
    HRESULT				ddRVal;		// return value
    LPDDHAL_WAITFORVERTICALBLANK	WaitForVerticalBlank; // PRIVATE: ptr to callback
} DDHAL_WAITFORVERTICALBLANKDATA;

/*
 * structure for passing information to DDHAL DestroyDriver fn
 */
typedef struct _DDHAL_DESTROYDRIVERDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;	// driver struct
    HRESULT			ddRVal;	// return value
    LPDDHAL_DESTROYDRIVER	DestroyDriver;	// PRIVATE: ptr to callback
} DDHAL_DESTROYDRIVERDATA;

/*
 * structure for passing information to DDHAL SetMode fn
 */
typedef struct _DDHAL_SETMODEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL lpDD;		// driver struct
    DWORD		dwModeIndex;	// new mode
    HRESULT		ddRVal;		// return value
    LPDDHAL_SETMODE	SetMode;	// PRIVATE: ptr to callback
    BOOL                inexcl;         // in exclusive mode
    BOOL		useRefreshRate;	// use the refresh rate data in the mode info
} DDHAL_SETMODEDATA;

/*
 * structure for passing information to DDHAL driver SetColorKey fn
 */
typedef struct _DDHAL_DRVSETCOLORKEYDATA
{
    LPDDRAWI_DDRAWSURFACE_LCL	lpDDSurface;	// surface struct
    DWORD 			dwFlags;	// flags
    DDCOLORKEY 			ckNew;		// new color key
    HRESULT			ddRVal;		// return value
    LPDDHAL_SETCOLORKEY		SetColorKey;	// PRIVATE: ptr to callback
} DDHAL_DRVSETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetScanLine fn
 */
typedef struct _DDHAL_GETSCANLINEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL	lpDD;		// driver struct
    DWORD			dwScanLine;	// returned scan line
    HRESULT			ddRVal;		// return value
    LPDDHAL_GETSCANLINE		GetScanLine;	// PRIVATE: ptr to callback
} DDHAL_GETSCANLINEDATA;

/*
 * structure for passing information to DDHAL SetExclusiveMode fn
 */
typedef struct _DDHAL_SETEXCLUSIVEMODEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL    lpDD;             // driver struct
    DWORD                      dwEnterExcl;      // TRUE if entering exclusive mode, FALSE is leaving
    DWORD                      dwReserved;       // reserved for future use
    HRESULT                    ddRVal;           // return value
    LPDDHAL_SETEXCLUSIVEMODE   SetExclusiveMode; // PRIVATE: ptr to callback
} DDHAL_SETEXCLUSIVEMODEDATA;

/*
 * structure for passing information to DDHAL FlipToGDISurface fn
 */
typedef struct _DDHAL_FLIPTOGDISURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL    lpDD;		 // driver struct
    DWORD                      dwToGDI;          // TRUE if flipping to the GDI surface, FALSE if flipping away
    DWORD                      dwReserved;       // reserved for future use
    HRESULT		       ddRVal;		 // return value
    LPDDHAL_FLIPTOGDISURFACE   FlipToGDISurface; // PRIVATE: ptr to callback
} DDHAL_FLIPTOGDISURFACEDATA;

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\ddrawp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddraw.h
 *  Content:	DirectDraw include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-dec-94	craige	initial implementation
 *   13-jan-95	craige	updated
 *   31-jan-95	craige	and even more ongoing work...
 *   01-mar-95	craige	flags with Get/SetExclusiveMode
 *   07-mar-95	craige	FourCC code stuff
 *   08-mar-95	craige	blt/overlay stretch distinction, bunch of new APIs
 *   11-mar-95	craige	palette stuff
 *   17-mar-95	craige	COM interface
 *   20-mar-95	craige	Get/SetExclusiveMode->Get/SetExclusiveModeOwner,
 *			flags with CreateSurface and DuplicateSurface
 *   28-mar-95	craige	removed Get/SetColorKey, added FlipToGDISurface to
 *			IDirectDraw; switched to PALETTEENTRY from RGBQUAD
 *   01-apr-95	craige	happy fun joy updated header file THANK YOU ERIC
 *   06-apr-95	craige	added dwVidMemTotal, dwVidMemFree to DDCAPS
 *   13-apr-95	craige	EricEng's little contribution to our being late
 *   15-apr-95	craige	GetBltStatus, added flag to GetFlipStatus
 *   12-may-95	craige	added GUIDS;DirectDrawEnumerate
 *   19-may-95	craige	added DDSEMO_ALLOWREBOOT
 *   23-may-95	craige	have driver GetCaps return HEL caps; added Flush,
 *			GetBatchLimit, SetBatchLimit to IDirectDraw
 *   24-may-95  kylej   removed obsolete ZOrder variables
 *   24-may-95	craige	added Restore
 *   28-may-95	craige	added DDCAPS_COLORKEY_HWASSIST; Unicode support
 *   04-jun-95	craige	added IsLost
 *   05-jun-95	craige	removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *			change GarbageCollect to Compact
 *   06-jun-95	craige	removed GetExclusiveModeOwner; added parm to
 *			SetExclusiveMode
 *   15-jun-95	craige	new surface interfaces: IDirectDrawSurfaceNotification,
 *			IDirectDrawSurfaceComposition
 *   19-jun-95	craige	rationalized INVALIDxxx to DDERR_INVALIDOBJECT
 *   20-jun-95  kylej   added DDERR_CANNOTDETACHSURFACE
 *   21-jun-95	craige	added DirectDrawClipper object; removed clipping
 *			info from surface object
 *   24-jun-95	craige	added DDBLTFAST_xxx flags
 *   27-jun-95	craige	removed Flush,Set/GetBatchLimit; added BltBatch
 *   30-jun-95  kylej   added DDERR_INCOMPATIBLEPRIMARY
 *   30-jun-95	craige	added dest align as well as src
 *   01-jul-95	craige	hide composition & streaming stuff; added DDERR_EXCEPTION
 *   02-jul-95	craige	hide clipper notification stuff; futzed with DDSCAPS
 *			position in structures
 *   03-jul-95  kylej   changed EnumSurfaces declaration
 *   03-jul-95	craige	added pUnkOuter to all Create fns; added object ptr
 *			to CreateSurface, removed lpClipList and lpDDSurface
 *			from surface desc.
 *   05-jul-95	craige	added Initialize members to all interfaces to allow
 *			for full COM integration
 *   09-jul-95	craige	added DDERR_LOCKEDSURFACES; changed SetExclusiveMode
 *			to SetCooperativeLevel
 *   10-jul-95  kylej   added mirroring caps and overlay FX flags
 *   12-jul-95	craige	added DDSCAPS_OWNDC
 *   13-jul-95	craige	changed Get/SetOverlayPosition to take LONGs
 *   14-jul-95	craige	added dwFlags to DDOVERLAYFX
 *   15-jul-95	craige	set DDCAPS_NOHARDWARE
 *   15-jul-95	ericeng changed EnumSurface callback param order, BltBatch
 * 			params, moved all Const var references to a consistent
 *			location, removed failure mode for height alignment
 *   18-jul-95	craige	removed Flush from surface object
 *   27-jul-95	craige	added DDCAPS_BLTCOLORFILL
 *   31-jul-95	craige	added DDCAPS_BANKSWITCHED, validation flags
 *   02-aug-95	craige	added dwMinOverlayStretch/dwMaxOverlayStretch to DDCAPS
 *   10-aug-95  toddla  added DDBLT_WAIT, DDBLTFAST_WAIT, DDLOCK_WAIT, DDFLIP_WAIT
 *   13-aug-95	craige	added dwCaps2 and reserved fields to DDCAPS; added
 *			DDCAPS2_CERTIFIED; named alpha caps properly;
 *			flags parm for Flip
 *   13-aug-95  toddla  added DDSCL_DONTHOOKHWND
 *   19-aug-95	ericeng added DDCAPS2_LIVEVIDEO and DDCAPS2_HWCODEC
 *   21-aug-95	craige	mode X support
 *   27-aug-95	craige	bug 742: added DDPCAPS_256
 *			bug 738: use GUID instead of IID
 *   22-sep-95	craige	bug 1268,1269:  getbltstatus/getflipstatus flags wrong
 *   09-nov-95  colinmc added support for 1, 2 and 4 bit RGB and indexed
 *                      palettes
 *   27-nov-95  colinmc new member to return available vram of a given type
 *                      (determined by DDSCAPS).
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consistency with Direct3D
 *   05-dec-95  colinmc added mip-map support
 *   09-dec-95  colinmc added execute buffer support
 *   13-dec-95  colinmc added shared back and z-buffer support
 *   18-dec-95  colinmc added valid caps mask for surface caps
 *   25-dec-95	craige	changed IDirectDrawV2 to IDirectDraw2
 *   31-dec-95	craige	added CLSID_DirectDraw
 *   04-jan-96  colinmc added explicit support for z-buffer clears
 *   12-feb-96	kylej	added  Interface
 *   23-feb-96	kylej	added IDirectDrawSurface2 Interface
 *   01-mar-96	kylej	new ddcaps structure
 *   06-mar-96	kylej	changed HANDLEs to DWORDs
 *   13-mar-96	kylej	added DD_Surface_GetDDInterface in IDirectDrawSurface2
 *   14-mar-96  colinmc added CLSID_DirectDrawClipper and added the clipper
 *                      creation API function back in
 *   21-mar-96  colinmc Bug 13316: Unitialized interfaces
 *   24-mar-96  colinmc Bug 14321: Structure change to allow flippable mip
 *                      map chains with a single call
 *   26-mar-96  colinmc Bug 14470: Compressed surface support
 *   15-apr-96  colinmc Bug 16855: Can't pass NULL to Initialize in C++
 *   19-apr-96  colinmc Bug 18059: News caps bit to flag that you can't do
 *                      2D during 3D.
 *   01-may-96  colinmc Bug 20005: InternalLock does not check for lost
 *                      surfaces
 *   28-jun-96  colinmc Bug 2122: Misleading bit depth comments in
 *                      DDPIXELFORMAT
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDRAW_INCLUDED__
#define __DDRAW_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#define _FACDD	0x876
#define MAKE_DDHRESULT( code )	MAKE_HRESULT( 1, _FACDD, code )

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDraw objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( CLSID_DirectDraw,			0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35 );
DEFINE_GUID( CLSID_DirectDrawClipper,           0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw,			0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDraw2,                  0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDrawSurface,		0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawSurface2,		0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27 );

//@@BEGIN_MSINTERNAL
#ifdef STREAMING
DEFINE_GUID( IID_IDirectDrawSurfaceStreaming,	0x6C14DB82,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
#endif
#ifdef COMPOSITION
DEFINE_GUID( IID_IDirectDrawSurfaceComposition,	0x6C14DB83,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
#endif
//@@END_MSINTERNAL
DEFINE_GUID( IID_IDirectDrawPalette,		0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawClipper,		0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
                 
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
struct IDirectDrawSurfaceComposition;
#endif
#ifdef STREAMING
struct IDirectDrawSurfaceStreaming;
#endif
//@@END_MSINTERNAL
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDirectDraw			FAR *LPDIRECTDRAW;
typedef struct IDirectDraw2			FAR *LPDIRECTDRAW2;
typedef struct IDirectDrawSurface		FAR *LPDIRECTDRAWSURFACE;
typedef struct IDirectDrawSurface2		FAR *LPDIRECTDRAWSURFACE2;

//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
typedef struct IDirectDrawSurfaceComposition	FAR *LPDIRECTDRAWSURFACECOMPOSITION;
#endif
#ifdef STREAMING
typedef struct IDirectDrawSurfaceStreaming	FAR *LPDIRECTDRAWSURFACESTREAMING;
#endif
//@@END_MSINTERNAL
typedef struct IDirectDrawPalette		FAR *LPDIRECTDRAWPALETTE;
typedef struct IDirectDrawClipper		FAR *LPDIRECTDRAWCLIPPER;

typedef struct _DDFXROP			FAR *LPDDFXROP;
typedef struct _DDSURFACEDESC		FAR *LPDDSURFACEDESC;

/*
 * API's
 */
#if (defined (WIN32) || defined( _WIN32 ) ) && !defined( _NO_COM )
//#if defined( _WIN32 ) && !defined( _NO_ENUM )
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKA)(GUID FAR *, LPSTR, LPSTR, LPVOID);
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID);
    extern HRESULT WINAPI DirectDrawEnumerateW( LPDDENUMCALLBACKW lpCallback, LPVOID lpContext );
    extern HRESULT WINAPI DirectDrawEnumerateA( LPDDENUMCALLBACKA lpCallback, LPVOID lpContext );
    #ifdef UNICODE
	typedef LPDDENUMCALLBACKW 	LPDDENUMCALLBACK;
	#define DirectDrawEnumerate	DirectDrawEnumerateW
    #else
	typedef LPDDENUMCALLBACKA 	LPDDENUMCALLBACK;
	#define DirectDrawEnumerate	DirectDrawEnumerateA
    #endif
    extern HRESULT WINAPI DirectDrawCreate( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );
    extern HRESULT WINAPI DirectDrawCreateClipper( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
    #ifdef WINNT
	//This is the user-mode entry stub to the kernel mode procedure.
	extern HRESULT NtDirectDrawCreate( GUID FAR *lpGUID, HANDLE *lplpDD, IUnknown FAR *pUnkOuter );
    #endif
#endif

#define REGSTR_KEY_DDHW_DESCRIPTION	"Description"
#define REGSTR_KEY_DDHW_DRIVERNAME	"DriverName"
#define REGSTR_PATH_DDHW		"Hardware\\DirectDrawDrivers"

#define DDCREATE_HARDWAREONLY		0x00000001l
#define DDCREATE_EMULATIONONLY		0x00000002l

#if defined (WINNT) || !defined(WIN32)
typedef long HRESULT;
#endif

//#ifndef WINNT
typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK)(LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK)(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC, LPVOID);
//#endif
/*
 * DDCOLORKEY
 */
typedef struct _DDCOLORKEY
{
    DWORD	dwColorSpaceLowValue;	// low boundary of color space that is to 
					// be treated as Color Key, inclusive
    DWORD	dwColorSpaceHighValue;	// high boundary of color space that is 
					// to be treated as Color Key, inclusive
} DDCOLORKEY;

typedef DDCOLORKEY FAR* LPDDCOLORKEY;

/*
 * DDBLTFX
 * Used to pass override information to the DIRECTDRAWSURFACE callback Blt.
 */
typedef struct _DDBLTFX
{
    DWORD	dwSize;				// size of structure
    DWORD	dwDDFX;				// FX operations
    DWORD	dwROP;				// Win32 raster operations
    DWORD	dwDDROP;			// Raster operations new for DirectDraw
    DWORD	dwRotationAngle;		// Rotation angle for blt
    DWORD	dwZBufferOpCode;		// ZBuffer compares
    DWORD	dwZBufferLow;			// Low limit of Z buffer
    DWORD	dwZBufferHigh;			// High limit of Z buffer
    DWORD	dwZBufferBaseDest;		// Destination base value
    DWORD	dwZDestConstBitDepth;		// Bit depth used to specify Z constant for destination
    union
    {
	DWORD	dwZDestConst;			// Constant to use as Z buffer for dest
	LPDIRECTDRAWSURFACE lpDDSZBufferDest;	// Surface to use as Z buffer for dest
    };
    DWORD	dwZSrcConstBitDepth;		// Bit depth used to specify Z constant for source
    union
    {
	DWORD	dwZSrcConst;			// Constant to use as Z buffer for src
	LPDIRECTDRAWSURFACE lpDDSZBufferSrc;	// Surface to use as Z buffer for src
    };
    DWORD	dwAlphaEdgeBlendBitDepth;	// Bit depth used to specify constant for alpha edge blend
    DWORD	dwAlphaEdgeBlend;		// Alpha for edge blending
    DWORD	dwReserved;
    DWORD	dwAlphaDestConstBitDepth;	// Bit depth used to specify alpha constant for destination
    union
    {
	DWORD	dwAlphaDestConst;		// Constant to use as Alpha Channel
	LPDIRECTDRAWSURFACE lpDDSAlphaDest;	// Surface to use as Alpha Channel
    };
    DWORD	dwAlphaSrcConstBitDepth;	// Bit depth used to specify alpha constant for source
    union
    {
	DWORD	dwAlphaSrcConst;		// Constant to use as Alpha Channel
	LPDIRECTDRAWSURFACE lpDDSAlphaSrc;	// Surface to use as Alpha Channel
    };
    union
    {
	DWORD	dwFillColor;			// color in RGB or Palettized
	DWORD   dwFillDepth;                    // depth value for z-buffer
	LPDIRECTDRAWSURFACE lpDDSPattern;	// Surface to use as pattern
    };
    DDCOLORKEY	ddckDestColorkey;		// DestColorkey override
    DDCOLORKEY	ddckSrcColorkey;		// SrcColorkey override
} DDBLTFX;

typedef DDBLTFX FAR* LPDDBLTFX;

//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
/*
 * DDCOMPOSEFX
 * Used to pass override information to the DIRECTDRAWSURFACE callback Compose.
 */
typedef DWORD	(FAR PASCAL *LPCOMPOSECALLBACK)(DWORD);
typedef struct _DDCOMPOSEFX
{
    DWORD	dwSize;				// size of structure
    DWORD	dwDDFX;				// FX operations
    DWORD	dwROP;				// Win32 raster operations
    DWORD	dwDDROP;			// Raster operations new for DirectDraw
    DWORD	dwRotationAngle;		// Rotation angle for blt
    DWORD	dwZBufferOpCode;		// ZBuffer compares
    DWORD	dwZBufferLow;			// Low limit of Z buffer
    DWORD	dwZBufferHigh;			// High limit of Z buffer
    DWORD	dwZBufferBaseDest;		// Destination base value
    DWORD	dwZDestConstBitDepth;		// Bit depth used to specify Z constant for destination
    union
    {
	DWORD	dwZDestConst;			// Constant to use as Z buffer for dest
	LPDIRECTDRAWSURFACE lpDDSZBufferDest;	// Surface to use as Z buffer for dest
    };
    DWORD	dwZSrcConstBitDepth;		// Bit depth used to specify Z constant for source
    union
    {
	DWORD	dwZSrcConst;			// Constant to use as Z buffer for src
	LPDIRECTDRAWSURFACE lpDDSZBufferSrc;	// Surface to use as Z buffer for src
    };
    DWORD	dwAlphaEdgeBlendBitDepth;	// Bit depth used to specify constant for alpha edge blend
    DWORD	dwAlphaEdgeBlend;		// Alpha for edge blending
    DWORD	dwReserved;
    DWORD	dwAlphaDestConstBitDepth;	// Bit depth used to specify alpha constant for destination
    union
    {
	DWORD	dwAlphaDestConst;		// Constant to use as Alpha Channel 
	LPDIRECTDRAWSURFACE lpDDSAlphaDest;	// Surface to use as Alpha Channel
    };
    DWORD	dwAlphaSrcConstBitDepth;	// Bit depth used to specify alpha constant for source
    union
    {
	DWORD	dwAlphaSrcConst;		// Constant to use as Alpha Channel 
	LPDIRECTDRAWSURFACE lpDDSAlphaSrc;	// Surface to use as Alpha Channel
    };
    union
    {
	DWORD	dwFillColor;			// color in RGB or Palettized
	LPDIRECTDRAWSURFACE lpDDSPattern;	// Surface to use as pattern
    };
    DDCOLORKEY	ddckDestColorkey;		// DestColorkey override
    DDCOLORKEY	ddckSrcColorkey;		// SrcColorkey override
    DWORD	dwRepeat;			// how many times to repeat the composition command
    LPCOMPOSECALLBACK	lpfnCallback;		// function to call prior to execution of each compose command
} DDCOMPOSEFX;

typedef DDCOMPOSEFX FAR* LPDDCOMPOSEFX;
#endif
//@@END_MSINTERNAL

/*
 * DDSCAPS
 */
typedef struct _DDSCAPS
{
    DWORD	dwCaps;		// capabilities of surface wanted
} DDSCAPS;

typedef DDSCAPS FAR* LPDDSCAPS; 

/*
 * DDCAPS
 */
#define DD_ROP_SPACE		(256/32)	// space required to store ROP array
//@@BEGIN_MSINTERNAL
/*
 * This structure represents the DDCAPS structure released in DirectDraw 1.0.  It is used internally
 * by DirectDraw to interpret caps passed into ddraw by drivers written prior to the release of DirectDraw 2.0.
 * New applications should use the DDCAPS structure defined below.
 */
typedef struct _DDCAPS_V1
{
    DWORD	dwSize;			// size of the DDDRIVERCAPS structure
    DWORD	dwCaps;			// driver specific capabilities
    DWORD	dwCaps2;		// more driver specific capabilites
    DWORD	dwCKeyCaps;		// color key capabilities of the surface
    DWORD	dwFXCaps;		// driver specific stretching and effects capabilites
    DWORD	dwFXAlphaCaps;		// alpha driver specific capabilities
    DWORD	dwPalCaps;		// palette capabilities
    DWORD	dwSVCaps;		// stereo vision capabilities
    DWORD	dwAlphaBltConstBitDepths;	// DDBD_2,4,8
    DWORD	dwAlphaBltPixelBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaBltSurfaceBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaOverlayConstBitDepths;	// DDBD_2,4,8
    DWORD	dwAlphaOverlayPixelBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD	dwZBufferBitDepths;		// DDBD_8,16,24,32
    DWORD	dwVidMemTotal;		// total amount of video memory
    DWORD	dwVidMemFree;		// amount of free video memory
    DWORD	dwMaxVisibleOverlays;	// maximum number of visible overlays
    DWORD	dwCurrVisibleOverlays;	// current number of visible overlays
    DWORD	dwNumFourCCCodes;	// number of four cc codes
    DWORD	dwAlignBoundarySrc;	// source rectangle alignment
    DWORD	dwAlignSizeSrc;		// source rectangle byte size
    DWORD	dwAlignBoundaryDest;	// dest rectangle alignment
    DWORD	dwAlignSizeDest;	// dest rectangle byte size
    DWORD	dwAlignStrideAlign;	// stride alignment
    DWORD	dwRops[DD_ROP_SPACE];	// ROPS supported
    DDSCAPS	ddsCaps;		// DDSCAPS structure has all the general capabilities
    DWORD	dwMinOverlayStretch;	// minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxOverlayStretch;	// maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMinLiveVideoStretch;	// minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxLiveVideoStretch;	// maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMinHwCodecStretch;	// minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxHwCodecStretch;	// maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwReserved1;		// reserved
    DWORD	dwReserved2;		// reserved
    DWORD	dwReserved3;		// reserved
} DDCAPS_V1;

typedef DDCAPS_V1 FAR* LPDDCAPS_V1;
//@@END_MSINTERNAL

typedef struct _DDCAPS
{
    DWORD	dwSize;			// size of the DDDRIVERCAPS structure
    DWORD	dwCaps;			// driver specific capabilities
    DWORD	dwCaps2;		// more driver specific capabilites
    DWORD	dwCKeyCaps;		// color key capabilities of the surface
    DWORD	dwFXCaps;		// driver specific stretching and effects capabilites
    DWORD	dwFXAlphaCaps;		// alpha driver specific capabilities
    DWORD	dwPalCaps;		// palette capabilities
    DWORD	dwSVCaps;		// stereo vision capabilities
    DWORD	dwAlphaBltConstBitDepths;	// DDBD_2,4,8
    DWORD	dwAlphaBltPixelBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaBltSurfaceBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaOverlayConstBitDepths;	// DDBD_2,4,8
    DWORD	dwAlphaOverlayPixelBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD	dwZBufferBitDepths;		// DDBD_8,16,24,32
    DWORD	dwVidMemTotal;		// total amount of video memory
    DWORD	dwVidMemFree;		// amount of free video memory
    DWORD	dwMaxVisibleOverlays;	// maximum number of visible overlays
    DWORD	dwCurrVisibleOverlays;	// current number of visible overlays
    DWORD	dwNumFourCCCodes;	// number of four cc codes
    DWORD	dwAlignBoundarySrc;	// source rectangle alignment
    DWORD	dwAlignSizeSrc;		// source rectangle byte size
    DWORD	dwAlignBoundaryDest;	// dest rectangle alignment
    DWORD	dwAlignSizeDest;	// dest rectangle byte size
    DWORD	dwAlignStrideAlign;	// stride alignment
    DWORD	dwRops[DD_ROP_SPACE];	// ROPS supported
    DDSCAPS	ddsCaps;		// DDSCAPS structure has all the general capabilities
    DWORD	dwMinOverlayStretch;	// minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxOverlayStretch;	// maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMinLiveVideoStretch;	// minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxLiveVideoStretch;	// maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMinHwCodecStretch;	// minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxHwCodecStretch;	// maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwReserved1;		// reserved
    DWORD	dwReserved2;		// reserved
    DWORD	dwReserved3;		// reserved
    DWORD	dwSVBCaps;		// driver specific capabilities for System->Vmem blts
    DWORD	dwSVBCKeyCaps;		// driver color key capabilities for System->Vmem blts
    DWORD	dwSVBFXCaps;		// driver FX capabilities for System->Vmem blts
    DWORD	dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD	dwVSBCaps;		// driver specific capabilities for Vmem->System blts
    DWORD	dwVSBCKeyCaps;		// driver color key capabilities for Vmem->System blts
    DWORD	dwVSBFXCaps;		// driver FX capabilities for Vmem->System blts
    DWORD	dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD	dwSSBCaps;		// driver specific capabilities for System->System blts
    DWORD	dwSSBCKeyCaps;		// driver color key capabilities for System->System blts
    DWORD	dwSSBFXCaps;		// driver FX capabilities for System->System blts
    DWORD	dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD	dwReserved4;		// reserved
    DWORD	dwReserved5;		// reserved
    DWORD	dwReserved6;		// reserved
} DDCAPS;

typedef DDCAPS FAR* LPDDCAPS;



/*
 * DDPIXELFORMAT
 */
typedef struct _DDPIXELFORMAT
{
    DWORD	dwSize;			// size of structure
    DWORD	dwFlags;		// pixel format flags
    DWORD	dwFourCC;		// (FOURCC code)
    union
    {
	DWORD	dwRGBBitCount;		// how many bits per pixel
	DWORD	dwYUVBitCount;		// how many bits per pixel
	DWORD	dwZBufferBitDepth;	// how many bits for z buffers
	DWORD	dwAlphaBitDepth;	// how many bits for alpha channels
    };
    union
    {
    DWORD   dwRBitMask;   // mask for red bit
    DWORD   dwYBitMask;   // mask for Y bits
    };
    union
    {
    DWORD   dwGBitMask;	  // mask for green bits
    DWORD   dwUBitMask;   // mask for U bits
    };
    union
    {
    DWORD   dwBBitMask;   // mask for blue bits
    DWORD   dwVBitMask;   // mask for V bits
    };
    union
    {
    DWORD   dwRGBAlphaBitMask; // mask for alpha channel
    DWORD   dwYUVAlphaBitMask; // mask for alpha channel
    };
} DDPIXELFORMAT;

typedef DDPIXELFORMAT FAR* LPDDPIXELFORMAT;

/*
 * DDOVERLAYFX
 */
typedef struct _DDOVERLAYFX
{
    DWORD	dwSize;				// size of structure
    DWORD	dwAlphaEdgeBlendBitDepth;	// Bit depth used to specify constant for alpha edge blend
    DWORD	dwAlphaEdgeBlend;		// Constant to use as alpha for edge blend
    DWORD	dwReserved;
    DWORD	dwAlphaDestConstBitDepth;	// Bit depth used to specify alpha constant for destination
    union
    {
	DWORD	dwAlphaDestConst;		// Constant to use as alpha channel for dest
	LPDIRECTDRAWSURFACE lpDDSAlphaDest;	// Surface to use as alpha channel for dest
    };
    DWORD	dwAlphaSrcConstBitDepth;	// Bit depth used to specify alpha constant for source
    union
    {
	DWORD	dwAlphaSrcConst;		// Constant to use as alpha channel for src
	LPDIRECTDRAWSURFACE lpDDSAlphaSrc;	// Surface to use as alpha channel for src
    };
    DDCOLORKEY	dckDestColorkey;		// DestColorkey override
    DDCOLORKEY	dckSrcColorkey;			// DestColorkey override
    DWORD       dwDDFX;                         // Overlay FX
    DWORD	dwFlags;			// flags
} DDOVERLAYFX;

typedef DDOVERLAYFX FAR *LPDDOVERLAYFX;

/*
 * DDBLTBATCH: BltBatch entry structure
 */
typedef struct _DDBLTBATCH
{
    LPRECT		lprDest;
    LPDIRECTDRAWSURFACE	lpDDSSrc;
    LPRECT		lprSrc;
    DWORD		dwFlags;
    LPDDBLTFX		lpDDBltFx;
} DDBLTBATCH;

typedef DDBLTBATCH FAR * LPDDBLTBATCH;

/*
 * callbacks
 */
typedef DWORD	(FAR PASCAL *LPCLIPPERCALLBACK)(LPDIRECTDRAWCLIPPER lpDDClipper, HWND hWnd, DWORD code, LPVOID lpContext );
#ifdef STREAMING
typedef DWORD	(FAR PASCAL *LPSURFACESTREAMINGCALLBACK)(DWORD);
#endif

//@@BEGIN_MSINTERNAL
#ifdef CLIPPER_NOTIFY
/*
 * values passed into the clipper callback
 */
#ifndef WINWATCHNOTIFY_START
    #define WINWATCHNOTIFY_START        0
    #define WINWATCHNOTIFY_STOP         1
    #define WINWATCHNOTIFY_DESTROY      2
    #define WINWATCHNOTIFY_CHANGING     3
    #define WINWATCHNOTIFY_CHANGED      4
#endif
#endif
//@@END_MSINTERNAL

/*
 * INTERACES FOLLOW:
 *	IDirectDraw
 *	IDirectDrawClipper
 *	IDirectDrawPalette
 *	IDirectDrawSurface
 *@@BEGIN_MSINTERNAL
 *	IDirectDrawSurfaceStreaming
 *	IDirectDrawSurfaceComposition
 *	IDirectDrawSurfaceClipperEx
 *		// this would allow multiple clipper objects to be attached
 *		// to the same destination
 *@@END_MSINTERNAL
 */

/*
 * IDirectDraw 
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw
DECLARE_INTERFACE_( IDirectDraw, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->lpVtbl->SetDisplayMode(p, a, b, c)
#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw2
DECLARE_INTERFACE_( IDirectDraw2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw2_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw2_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw2_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw2_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw2_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw2_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw2_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw2_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw2_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw2_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw2_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#endif

#endif

/*
 * IDirectDrawPalette
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawPalette
DECLARE_INTERFACE_( IDirectDrawPalette, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawPalette methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD, LPPALETTEENTRY) PURE;
    STDMETHOD(SetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawPalette_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawPalette_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawPalette_GetCaps(p, a)                (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->lpVtbl->GetEntries(p, a, b, c, d)
#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->lpVtbl->Initialize(p, a, b, c)
#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->lpVtbl->SetEntries(p, a, b, c, d)
#endif

#endif

/*
 * IDirectDrawClipper
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawClipper
DECLARE_INTERFACE_( IDirectDrawClipper, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawClipper methods ***/
    STDMETHOD(GetClipList)(THIS_ LPRECT, LPRGNDATA, LPDWORD) PURE;
    STDMETHOD(GetHWnd)(THIS_ HWND FAR *) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD) PURE;
    STDMETHOD(IsClipListChanged)(THIS_ BOOL FAR *) PURE;
    STDMETHOD(SetClipList)(THIS_ LPRGNDATA,DWORD) PURE;
    STDMETHOD(SetHWnd)(THIS_ DWORD, HWND ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawClipper_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawClipper_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->lpVtbl->GetClipList(p, a, b, c)
#define IDirectDrawClipper_GetHWnd(p, a)            (p)->lpVtbl->GetHWnd(p, a)
#define IDirectDrawClipper_Initialize(p, a, b)      (p)->lpVtbl->Initialize(p, a, b)
#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->lpVtbl->IsClipListChanged(p, a)
#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->lpVtbl->SetClipList(p, a, b)
#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->lpVtbl->SetHWnd(p, a, b)
#endif

#endif

/*
 * IDirectDrawSurface and related interfaces
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawSurface
DECLARE_INTERFACE_( IDirectDrawSurface, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#endif

/*
 * IDirectDrawSurface2 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface2
DECLARE_INTERFACE_( IDirectDrawSurface2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE2, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE2, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE2, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE2 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE2,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE2) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface2_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface2_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface2_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface2_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface2_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface2_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface2_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface2_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface2_GetDDInterface(p,a)		 (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface2_PageLock(p,a)		 (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface2_PageUnlock(p,a)		 (p)->lpVtbl->PageUnlock(p,a)
#endif

//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
#undef INTERFACE
#define INTERFACE IDirectDrawSurfaceComposition
DECLARE_INTERFACE_( IDirectDrawSurfaceComposition, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurfaceComposition methods ***/
    STDMETHOD(AddSurfaceDependency)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(Compose)(THIS_ LPRECT,LPDIRECTDRAWSURFACE,LPRECT,DWORD,LPDDCOMPOSEFX) PURE;
    STDMETHOD(DeleteSurfaceDependency)(THIS_ DWORD,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(DestLock)(THIS) PURE;
    STDMETHOD(DestUnlock)(THIS) PURE;
    STDMETHOD(EnumSurfaceDependencies)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(GetCompositionOrder)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetCompositionOrder)(THIS_ DWORD) PURE;
};
#endif

#ifdef STREAMING
#undef INTERFACE
#define INTERFACE IDirectDrawSurfaceStreaming
DECLARE_INTERFACE_( IDirectDrawSurfaceStreaming, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurfaceStreaming methods ***/
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(SetNotificationCallback)(THIS_ DWORD,LPSURFACESTREAMINGCALLBACK) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
};
#endif
//@@END_MSINTERNAL

#endif

//@@BEGIN_MSINTERNAL
#ifdef CLIPPER_NOTIFY
/*
 * DIRECTDRAWCLIPPER FLAGS
 */
#define DDCLIPPER_WATCHWINDOW	0x00000001l
#endif
//@@END_MSINTERNAL

/*
 * DDSURFACEDESC
 */
typedef struct _DDSURFACEDESC
{
    DWORD		dwSize;			// size of the DDSURFACEDESC structure
    DWORD		dwFlags;		// determines what fields are valid
    DWORD		dwHeight;		// height of surface to be created
    DWORD		dwWidth;		// width of input surface
    LONG		lPitch;			// distance to start of next line (return value only)
    DWORD		dwBackBufferCount;	// number of back buffers requested
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requested
	DWORD		dwZBufferBitDepth;	// depth of Z buffer requested
	DWORD		dwRefreshRate;		// refresh rate (used when display mode is described)
    };
    DWORD		dwAlphaBitDepth;	// depth of alpha buffer requested
//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
    DWORD		dwCompositionOrder;	// blt order for the surface, 0 is background
#else
//@@END_MSINTERNAL
    DWORD		dwReserved;		// reserved
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
    LPVOID		lpSurface;		// pointer to the associated surface memory
    DDCOLORKEY		ddckCKDestOverlay;	// color key for destination overlay use
    DDCOLORKEY		ddckCKDestBlt;		// color key for destination blt use
    DDCOLORKEY		ddckCKSrcOverlay;	// color key for source overlay use
    DDCOLORKEY		ddckCKSrcBlt;		// color key for source blt use
    DDPIXELFORMAT	ddpfPixelFormat;	// pixel format description of the surface
    DDSCAPS		ddsCaps;		// direct draw surface capabilities
} DDSURFACEDESC;

/*
 * ddsCaps field is valid.
 */
#define DDSD_CAPS		0x00000001l	// default

/*
 * dwHeight field is valid.
 */
#define DDSD_HEIGHT		0x00000002l

/*
 * dwWidth field is valid.
 */
#define DDSD_WIDTH		0x00000004l

/*
 * lPitch is valid.
 */
#define DDSD_PITCH		0x00000008l

/*
 * dwBackBufferCount is valid.
 */
#define DDSD_BACKBUFFERCOUNT	0x00000020l

/*
 * dwZBufferBitDepth is valid.
 */
#define DDSD_ZBUFFERBITDEPTH	0x00000040l

/*
 * dwAlphaBitDepth is valid.
 */
#define DDSD_ALPHABITDEPTH	0x00000080l

//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
/*
 * dwCompositionOrder is valid.
 */
#define DDSD_COMPOSITIONORDER	0x00000100l
#endif
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
/*
 * lpSurface is valid.
 */
#define DDSD_LPSURFACE		0x00000800l
//@@END_MSINTERNAL

/*
 * ddpfPixelFormat is valid.
 */
#define DDSD_PIXELFORMAT	0x00001000l

/*
 * ddckCKDestOverlay is valid.
 */
#define DDSD_CKDESTOVERLAY	0x00002000l

/*
 * ddckCKDestBlt is valid.
 */
#define DDSD_CKDESTBLT		0x00004000l

/*
 * ddckCKSrcOverlay is valid.
 */
#define DDSD_CKSRCOVERLAY	0x00008000l

/*
 * ddckCKSrcBlt is valid.
 */
#define DDSD_CKSRCBLT		0x00010000l

/*
 * dwMipMapCount is valid.
 */
#define DDSD_MIPMAPCOUNT        0x00020000l

 /*
  * dwRefreshRate is valid
  */
#define DDSD_REFRESHRATE	0x00040000l

/*
 * All input fields are valid. 
 */
#define DDSD_ALL		0x0007f9eel

//@@BEGIN_MSINTERNAL
/*
 * DDMODEDESC
 */
typedef struct _DDMODEDESC
{
    DWORD		dwSize;			// size of structure
    DWORD		dwFlags;		// enumeration flags
    DWORD		dwMonitorFrequency;	// frequency of monitor in mode
    DDSURFACEDESC	ddsdSurfaceDesc;	// surface being enumerated
} DDMODEDESC;

typedef DDMODEDESC FAR* LPDDMODEDESC;
//@@END_MSINTERNAL

/*============================================================================
 *
 * Direct Draw Capability Flags
 *
 * These flags are used to describe the capabilities of a given Surface.
 * All flags are bit flags. 
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAWSURFACE CAPABILITY FLAGS
 *
 ****************************************************************************/
/*
 * This bit currently has no meaning.
 */
#define DDSCAPS_3D				0x00000001l

/*
 * Indicates that this surface contains alpha information.  The pixel
 * format must be interrogated to determine whether this surface
 * contains only alpha information or alpha information interlaced
 * with pixel color data (e.g. RGBA or YUVA).
 */
#define DDSCAPS_ALPHA				0x00000002l

/*
 * Indicates that this surface is a backbuffer.	 It is generally
 * set by CreateSurface when the DDSCAPS_FLIP capability bit is set.
 * It indicates that this surface is THE back buffer of a surface
 * flipping structure.	DirectDraw supports N surfaces in a
 * surface flipping structure.	Only the surface that immediately
 * precedeces the DDSCAPS_FRONTBUFFER has this capability bit set.
 * The other surfaces are identified as back buffers by the presence
 * of the DDSCAPS_FLIP capability, their attachment order, and the
 * absence of the DDSCAPS_FRONTBUFFER and DDSCAPS_BACKBUFFER
 * capabilities.  The bit is sent to CreateSurface when a standalone
 * back buffer is being created.  This surface could be attached to
 * a front buffer and/or back buffers to form a flipping surface
 * structure after the CreateSurface call.  See AddAttachments for
 * a detailed description of the behaviors in this case.
 */
#define DDSCAPS_BACKBUFFER			0x00000004l

/*
 * Indicates a complex surface structure is being described.  A
 * complex surface structure results in the creation of more than
 * one surface.	 The additional surfaces are attached to the root
 * surface.  The complex structure can only be destroyed by
 * destroying the root.
 */
#define DDSCAPS_COMPLEX				0x00000008l

/*
 * Indicates that this surface is a part of a surface flipping structure.
 * When it is passed to CreateSurface the DDSCAPS_FRONTBUFFER and
 * DDSCAP_BACKBUFFER bits are not set.	They are set by CreateSurface
 * on the resulting creations.	The dwBackBufferCount field in the
 * DDSURFACEDESC structure must be set to at least 1 in order for
 * the CreateSurface call to succeed.  The DDSCAPS_COMPLEX capability
 * must always be set with creating multiple surfaces through CreateSurface.
 */
#define DDSCAPS_FLIP				0x00000010l

/*
 * Indicates that this surface is THE front buffer of a surface flipping
 * structure.  It is generally set by CreateSurface when the DDSCAPS_FLIP
 * capability bit is set.
 * If this capability is sent to CreateSurface then a standalonw front buffer
 * is created.	This surface will not have the DDSCAPS_FLIP capability.
 * It can be attached to other back buffers to form a flipping structure.
 * See AddAttachments for a detailed description of the behaviors in this
 * case.
 */
#define DDSCAPS_FRONTBUFFER			0x00000020l

/*
 * Indicates that this surface is any offscreen surface that is not an overlay,
 * texture, zbuffer, front buffer, back buffer, or alpha surface.  It is used
 * to identify plain vanilla surfaces.
 */
#define DDSCAPS_OFFSCREENPLAIN			0x00000040l

/*
 * Indicates that this surface is an overlay.  It may or may not be directly visible
 * depending on whether or not it is currently being overlayed onto the primary 
 * surface.  DDSCAPS_VISIBLE can be used to determine whether or not it is being 
 * overlayed at the moment. 
 */
#define DDSCAPS_OVERLAY				0x00000080l

/*
 * Indicates that unique DirectDrawPalette objects can be created and
 * attached to this surface.
 */
#define DDSCAPS_PALETTE				0x00000100l

/*
 * Indicates that this surface is the primary surface.	The primary
 * surface represents what the user is seeing at the moment.
 */
#define DDSCAPS_PRIMARYSURFACE			0x00000200l

/*
 * Indicates that this surface is the primary surface for the left eye.
 * The primary surface for the left eye represents what the user is seeing
 * at the moment with the users left eye.  When this surface is created the
 * DDSCAPS_PRIMARYSURFACE represents what the user is seeing with the users
 * right eye.
 */
#define DDSCAPS_PRIMARYSURFACELEFT		0x00000400l

/*
 * Indicates that this surface memory was allocated in system memory
 */
#define DDSCAPS_SYSTEMMEMORY			0x00000800l

/*
 * Indicates that this surface can be used as a 3D texture.  It does not
 * indicate whether or not the surface is being used for that purpose.
 */
#define DDSCAPS_TEXTURE			        0x00001000l

/*
 * Indicates that a surface may be a destination for 3D rendering.  This
 * bit must be set in order to query for a Direct3D Device Interface 
 * from this surface.
 */
#define DDSCAPS_3DDEVICE                        0x00002000l

/*
 * Indicates that this surface exists in video memory.
 */
#define DDSCAPS_VIDEOMEMORY			0x00004000l

/*
 * Indicates that changes made to this surface are immediately visible.	 
 * It is always set for the primary surface and is set for overlays while
 * they are being overlayed and texture maps while they are being textured.
 */
#define DDSCAPS_VISIBLE				0x00008000l

/*
 * Indicates that only writes are permitted to the surface.  Read accesses 
 * from the surface may or may not generate a protection fault, but the 
 * results of a read from this surface will not be meaningful.	READ ONLY.
 */
#define DDSCAPS_WRITEONLY			0x00010000l

/*
 * Indicates that this surface is a z buffer. A z buffer does not contain
 * displayable information.  Instead it contains bit depth information that is
 * used to determine which pixels are visible and which are obscured. 
 */
#define DDSCAPS_ZBUFFER				0x00020000l

/*
 * Indicates surface will have a DC associated long term
 */
#define DDSCAPS_OWNDC				0x00040000l

/*
 * Indicates surface should be able to receive live video
 */
#define DDSCAPS_LIVEVIDEO			0x00080000l

/*
 * Indicates surface should be able to have a stream decompressed
 * to it by the hardware.
 */
#define DDSCAPS_HWCODEC				0x00100000l

/*
 * Surface is a 320x200 or 320x240 ModeX surface
 */
#define DDSCAPS_MODEX				0x00200000l

/*
 * Indicates surface is one level of a mip-map. This surface will
 * be attached to other DDSCAPS_MIPMAP surfaces to form the mip-map.
 * This can be done explicitly, by creating a number of surfaces and
 * attaching them with AddAttachedSurface or by implicitly by CreateSurface.
 * If this bit is set then DDSCAPS_TEXTURE must also be set.
 */
#define DDSCAPS_MIPMAP                          0x00400000l

//@@BEGIN_MSINTERNAL
/*
 * Indicates the surface is an execute buffer, i.e., a linear chunk of system
 * or video memory that holds a Direct3D display list. This cap. is MS internal
 * only as Direct3D will use it to create surfaces but it is not externally
 * visible via the DirectDraw API.
 */
#define DDSCAPS_EXECUTEBUFFER                   0x00800000l
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef SHAREDZ

/*
 * Indicates that this Z buffer surface can be shared with other DirectDraw
 * applications. This does not necessarily mean that this surface is
 * currently being shared with other processes but only that it can be. If 
 * this bit is set then DDSCAPS_ZBUFFER must also be set.
 */
#define DDSCAPS_SHAREDZBUFFER                   0x01000000l

/*
 * Indicates that this backbuffer surface can be shared with other DirectDraw
 * applications. This does not necessarily mean that this surface is
 * currently being shared with other processes but only that it can be. If 
 * this bit is set than DDSCAPS_BACKBUFFER must also be set (it may also be
 * set if a backbuffer is being created implicitly with as past of a complex
 * flippable chain).
 */
#define DDSCAPS_SHAREDBACKBUFFER                0x02000000l

#endif
//@@END_MSINTERNAL

/*
 * Indicates that memory for the surface is not allocated until the surface
 * is loaded (via the Direct3D texture Load() function).
 */
#define DDSCAPS_ALLOCONLOAD                     0x04000000l


//@@BEGIN_MSINTERNAL
#ifdef SHAREDZ
#define DDSCAPS_VALID                           0x07ffffffl
#else
#define DDSCAPS_VALID                           0x04ffffffl
#endif
//@@END_MSINTERNAL

 /****************************************************************************
 *
 * DIRECTDRAW DRIVER CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Display hardware has 3D acceleration.
 */
#define DDCAPS_3D			0x00000001l

/*
 * Indicates that DirectDraw will support only dest rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundaryDest boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYDEST	0x00000002l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in 
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeDest multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZEDEST		0x00000004l
/*
 * Indicates that DirectDraw will support only source rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundarySrc boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYSRC		0x00000008l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in 
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeSrc multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZESRC		0x00000010l

/*
 * Indicates that DirectDraw will create video memory surfaces that have a stride 
 * alignment equal to DIRECTDRAWCAPS.dwAlignStride.  READ ONLY.
 */
#define DDCAPS_ALIGNSTRIDE		0x00000020l

/*
 * Display hardware is capable of blt operations.
 */
#define DDCAPS_BLT			0x00000040l

/*
 * Display hardware is capable of asynchronous blt operations.
 */
#define DDCAPS_BLTQUEUE			0x00000080l

/*
 * Display hardware is capable of color space conversions during the blt operation.
 */
#define DDCAPS_BLTFOURCC		0x00000100l

/*
 * Display hardware is capable of stretching during blt operations.
 */
#define DDCAPS_BLTSTRETCH		0x00000200l

/*
 * Display hardware is shared with GDI.
 */
#define DDCAPS_GDI			0x00000400l

/*
 * Display hardware can overlay.
 */
#define DDCAPS_OVERLAY			0x00000800l

/*
 * Set if display hardware supports overlays but can not clip them.
 */
#define DDCAPS_OVERLAYCANTCLIP		0x00001000l

/*
 * Indicates that overlay hardware is capable of color space conversions during
 * the overlay operation.
 */
#define DDCAPS_OVERLAYFOURCC		0x00002000l

/*
 * Indicates that stretching can be done by the overlay hardware.
 */
#define DDCAPS_OVERLAYSTRETCH		0x00004000l

/*
 * Indicates that unique DirectDrawPalettes can be created for DirectDrawSurfaces
 * other than the primary surface.
 */
#define DDCAPS_PALETTE			0x00008000l

/*
 * Indicates that palette changes can be syncd with the veritcal refresh.
 */
#define DDCAPS_PALETTEVSYNC		0x00010000l

/*
 * Display hardware can return the current scan line.
 */
#define DDCAPS_READSCANLINE		0x00020000l

/*
 * Display hardware has stereo vision capabilities.  DDSCAPS_PRIMARYSURFACELEFT 
 * can be created.
 */
#define DDCAPS_STEREOVIEW		0x00040000l

/*
 * Display hardware is capable of generating a vertical blank interrupt.
 */
#define DDCAPS_VBI			0x00080000l

/*
 * Supports the use of z buffers with blt operations.
 */
#define DDCAPS_ZBLTS			0x00100000l

/*
 * Supports Z Ordering of overlays.
 */
#define DDCAPS_ZOVERLAYS		0x00200000l

/*
 * Supports color key
 */
#define DDCAPS_COLORKEY			0x00400000l

/*
 * Supports alpha surfaces
 */
#define DDCAPS_ALPHA			0x00800000l

/*
 * colorkey is hardware assisted(DDCAPS_COLORKEY will also be set)
 */
#define DDCAPS_COLORKEYHWASSIST		0x01000000l

/*
 * no hardware support at all
 */
#define DDCAPS_NOHARDWARE		0x02000000l

/*
 * Display hardware is capable of color fill with bltter
 */
#define DDCAPS_BLTCOLORFILL		0x04000000l

/*
 * Display hardware is bank switched, and potentially very slow at
 * random access to VRAM.
 */
#define DDCAPS_BANKSWITCHED		0x08000000l

/*
 * Display hardware is capable of depth filling Z-buffers with bltter
 */
#define DDCAPS_BLTDEPTHFILL		0x10000000l

/*
 * Display hardware is capable of clipping while bltting.
 */
#define DDCAPS_CANCLIP			0x20000000l

/*
 * Display hardware is capable of clipping while stretch bltting.
 */
#define DDCAPS_CANCLIPSTRETCHED		0x40000000l

/*
 * Display hardware is capable of bltting to or from system memory
 */
#define DDCAPS_CANBLTSYSMEM		0x80000000l


 /****************************************************************************
 *
 * MORE DIRECTDRAW DRIVER CAPABILITY FLAGS (dwCaps2)
 *
 ****************************************************************************/

/*
 * Display hardware is certified
 */
#define DDCAPS2_CERTIFIED		0x00000001l

/*
 * Driver cannot interleave 2D operations (lock and blt) to surfaces with
 * Direct3D rendering operations between calls to BeginScene() and EndScene()
 */
#define DDCAPS2_NO2DDURING3DSCENE       0x00000002l

/****************************************************************************
 *
 * DIRECTDRAW FX ALPHA CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAEDGEBLEND		0x00000001l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha 
 * information in the pixel format can be 1,2,4, or 8.	The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELS		0x00000002l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha 
 * information in the pixel format can be 1,2,4, or 8.	The alpha value 
 * becomes more transparent as the alpha value increases.  (0 is opaque.) 
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELSNEG		0x00000004l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.	 The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACES		0x00000008l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.  
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)	 This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACESNEG	0x00000010l

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND	0x00000020l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha 
 * information in the pixel format can be 1,2,4, or 8.	The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELS	0x00000040l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha 
 * information in the pixel format can be 1,2,4, or 8.	The alpha value 
 * becomes more transparent as the alpha value increases.  (0 is opaque.) 
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG	0x00000080l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.	 The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACES	0x00000100l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.  
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)	 This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACESNEG	0x00000200l

/****************************************************************************
 *
 * DIRECTDRAW FX CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Uses arithmetic operations to stretch and shrink surfaces during blt
 * rather than pixel doubling techniques.  Along the Y axis.
 */
#define DDFXCAPS_BLTARITHSTRETCHY	0x00000020l

/*
 * Uses arithmetic operations to stretch during blt
 * rather than pixel doubling techniques.  Along the Y axis. Only
 * works for x1, x2, etc.
 */
#define DDFXCAPS_BLTARITHSTRETCHYN	0x00000010l

/*
 * Supports mirroring left to right in blt.
 */
#define DDFXCAPS_BLTMIRRORLEFTRIGHT	0x00000040l

/*
 * Supports mirroring top to bottom in blt.
 */
#define DDFXCAPS_BLTMIRRORUPDOWN	0x00000080l

/*
 * Supports arbitrary rotation for blts.
 */
#define DDFXCAPS_BLTROTATION		0x00000100l

/*
 * Supports 90 degree rotations for blts.
 */
#define DDFXCAPS_BLTROTATION90		0x00000200l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKX		0x00000400l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKXN		0x00000800l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for blts.  
 */
#define DDFXCAPS_BLTSHRINKY		0x00001000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.  
 */
#define DDFXCAPS_BLTSHRINKYN		0x00002000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHX		0x00004000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHXN		0x00008000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for blts.  
 */
#define DDFXCAPS_BLTSTRETCHY		0x00010000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.  
 */
#define DDFXCAPS_BLTSTRETCHYN		0x00020000l

/*
 * Uses arithmetic operations to stretch and shrink surfaces during 
 * overlay rather than pixel doubling techniques.  Along the Y axis 
 * for overlays.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHY	0x00040000l

/*
 * Uses arithmetic operations to stretch surfaces during 
 * overlay rather than pixel doubling techniques.  Along the Y axis 
 * for overlays. Only works for x1, x2, etc.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHYN	0x00000008l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKX		0x00080000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKXN	0x00100000l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for overlays.	
 */
#define DDFXCAPS_OVERLAYSHRINKY		0x00200000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.	
 */
#define DDFXCAPS_OVERLAYSHRINKYN	0x00400000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHX	0x00800000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHXN	0x01000000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for overlays.	
 */
#define DDFXCAPS_OVERLAYSTRETCHY	0x02000000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.	
 */
#define DDFXCAPS_OVERLAYSTRETCHYN	0x04000000l

/*
 * DirectDraw supports mirroring of overlays across the vertical axis
 */
#define DDFXCAPS_OVERLAYMIRRORLEFTRIGHT	0x08000000l

/*
 * DirectDraw supports mirroring of overlays across the horizontal axis
 */
#define DDFXCAPS_OVERLAYMIRRORUPDOWN	0x10000000l

/****************************************************************************
 *
 * DIRECTDRAW STEREO VIEW CAPABILITIES
 *
 ****************************************************************************/

/*
 * The stereo view is accomplished via enigma encoding.
 */
#define DDSVCAPS_ENIGMA			0x00000001l

/*
 * The stereo view is accomplished via high frequency flickering.
 */
#define DDSVCAPS_FLICKER		0x00000002l

/*
 * The stereo view is accomplished via red and blue filters applied
 * to the left and right eyes.	All images must adapt their colorspaces
 * for this process.
 */
#define DDSVCAPS_REDBLUE		0x00000004l

/*
 * The stereo view is accomplished with split screen technology.
 */
#define DDSVCAPS_SPLIT			0x00000008l

/****************************************************************************
 *
 * DIRECTDRAWPALETTE CAPABILITIES
 *
 ****************************************************************************/

/*
 * Index is 4 bits.  There are sixteen color entries in the palette table.
 */
#define DDPCAPS_4BIT			0x00000001l

/*
 * Index is onto a 8 bit color index.  This field is only valid with the
 * DDPCAPS_1BIT, DDPCAPS_2BIT or DDPCAPS_4BIT capability and the target
 * surface is in 8bpp. Each color entry is one byte long and is an index
 * into destination surface's 8bpp palette.
 */
#define DDPCAPS_8BITENTRIES		0x00000002l

/*
 * Index is 8 bits.  There are 256 color entries in the palette table.
 */
#define DDPCAPS_8BIT			0x00000004l

/*
 * Indicates that this DIRECTDRAWPALETTE should use the palette color array
 * passed into the lpDDColorArray parameter to initialize the DIRECTDRAWPALETTE
 * object.
 */
#define DDPCAPS_INITIALIZE		0x00000008l

/*
 * This palette is the one attached to the primary surface.  Changing this
 * table has immediate effect on the display unless DDPSETPAL_VSYNC is specified
 * and supported.
 */
#define DDPCAPS_PRIMARYSURFACE		0x00000010l

/*
 * This palette is the one attached to the primary surface left.  Changing
 * this table has immediate effect on the display for the left eye unless
 * DDPSETPAL_VSYNC is specified and supported.
 */
#define DDPCAPS_PRIMARYSURFACELEFT	0x00000020l

/*
 * This palette can have all 256 entries defined
 */
#define DDPCAPS_ALLOW256		0x00000040l

/*
 * This palette can have modifications to it synced with the monitors
 * refresh rate.
 */
#define DDPCAPS_VSYNC			0x00000080l

/*
 * Index is 1 bit.  There are two color entries in the palette table.
 */
#define DDPCAPS_1BIT			0x00000100l

/*
 * Index is 2 bit.  There are four color entries in the palette table.
 */
#define DDPCAPS_2BIT			0x00000200l

//@@BEGIN_MSINTERNAL
#define DDPCAPS_VALID			0x000003ffl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWPALETTE SETENTRY CONSTANTS
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
/*
 * Palette changes take effect immediately.
 */
#define DDPSETPAL_IMMEDIATE		0x00000000l	// default

/*
 * Palette changes should take effect during the vertical blank to avoid
 * palette tearing.
 */
#define DDPSETPAL_VSYNC			0x00000002l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWPALETTE GETENTRY CONSTANTS
 *
 ****************************************************************************/

/* 0 is the only legal value */

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPALETTE CONSTANTS
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
/*
 * Palette change takes effect immediately.
 */
#define DDSETPAL_IMMEDIATE		0x00000000l	// default

/*
 * Palette change should take effect during the vertical blank to avoid
 * palette tearing.
 */
#define DDSETPAL_VSYNC			0x00000002l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW BITDEPTH CONSTANTS
 *
 * NOTE:  These are only used to indicate supported bit depths.   These
 * are flags only, they are not to be used as an actual bit depth.   The
 * absolute numbers 1, 2, 4, 8, 16, 24 and 32 are used to indicate actual
 * bit depths in a surface or for changing the display mode.
 *
 ****************************************************************************/

/*
 * 1 bit per pixel.
 */
#define DDBD_1			0x00004000l

/*
 * 2 bits per pixel.
 */
#define DDBD_2			0x00002000l

/*
 * 4 bits per pixel.
 */
#define DDBD_4			0x00001000l

/*
 * 8 bits per pixel.
 */
#define DDBD_8			0x00000800l

/*
 * 16 bits per pixel.
 */
#define DDBD_16			0x00000400l

/*
 * 24 bits per pixel.
 */
#define DDBD_24			0X00000200l

/*
 * 32 bits per pixel.
 */
#define DDBD_32			0x00000100l

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SET/GET COLOR KEY FLAGS
 *
 ****************************************************************************/

/*
 * Set if the structure contains a color space.	 Not set if the structure
 * contains a single color key.
 */
#define DDCKEY_COLORSPACE	0x00000001l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for blt operations.
 */
#define DDCKEY_DESTBLT		0x00000002l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for overlay operations.
 */
#define DDCKEY_DESTOVERLAY	0x00000004l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for blt operations.
 */
#define DDCKEY_SRCBLT		0x00000008l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for overlay operations.
 */
#define DDCKEY_SRCOVERLAY	0x00000010l

//@@BEGIN_MSINTERNAL
#define DDCKEY_VALID		0x0000001fl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW COLOR KEY CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports transparent blting using a color key to identify the replaceable 
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLT			0x00000001l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACE		0x00000002l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACEYUV		0x00000004l

/*
 * Supports transparent blting using a color key to identify the replaceable 
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTYUV			0x00000008l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the surface
 * being overlayed for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAY			0x00000010l

/*
 * Supports a color space as the color key for the destination for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACE		0x00000020l

/*
 * Supports a color space as the color key for the destination for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV	0x00000040l

/*
 * Supports only one active destination color key value for visible overlay
 * surfaces.
 */
#define DDCKEYCAPS_DESTOVERLAYONEACTIVE		0x00000080l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the 
 * surface being overlayed for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYYUV		0x00000100l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLT			0x00000200l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACE		0x00000400l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACEYUV		0x00000800l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTYUV			0x00001000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAY			0x00002000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACE		0x00004000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV	0x00008000l

/*
 * Supports only one active source color key value for visible
 * overlay surfaces.
 */
#define DDCKEYCAPS_SRCOVERLAYONEACTIVE		0x00010000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYYUV		0x00020000l

/*
 * there are no bandwidth trade-offs for using colorkey with an overlay
 */
#define DDCKEYCAPS_NOCOSTOVERLAY		0x00040000l


/****************************************************************************
 *
 * DIRECTDRAW PIXELFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * The surface has alpha channel information in the pixel format.
 */
#define DDPF_ALPHAPIXELS			0x00000001l

/*
 * The pixel format contains alpha only information
 */
#define DDPF_ALPHA				0x00000002l

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC				0x00000004l

/*
 * The surface is 4-bit color indexed.
 */
#define DDPF_PALETTEINDEXED4			0x00000008l

/*
 * The surface is indexed into a palette which stores indices
 * into the destination surface's 8-bit palette.
 */
#define DDPF_PALETTEINDEXEDTO8			0x00000010l

/*
 * The surface is 8-bit color indexed.
 */
#define DDPF_PALETTEINDEXED8			0x00000020l

/*
 * The RGB data in the pixel format structure is valid.
 */
#define DDPF_RGB				0x00000040l

/*
 * The surface will accept pixel data in the format specified
 * and compress it during the write.
 */
#define DDPF_COMPRESSED				0x00000080l

/*
 * The surface will accept RGB data and translate it during
 * the write to YUV data.  The format of the data to be written
 * will be contained in the pixel format structure.  The DDPF_RGB
 * flag will be set. 
 */
#define DDPF_RGBTOYUV				0x00000100l

/*
 * pixel format is YUV - YUV data in pixel format struct is valid
 */
#define DDPF_YUV				0x00000200l

/*
 * pixel format is a z buffer only surface
 */
#define DDPF_ZBUFFER				0x00000400l

/*
 * The surface is 1-bit color indexed.
 */
#define DDPF_PALETTEINDEXED1			0x00000800l

/*
 * The surface is 2-bit color indexed.
 */
#define DDPF_PALETTEINDEXED2			0x00001000l

/*===========================================================================
 *
 *
 * DIRECTDRAW CALLBACK FLAGS
 *
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAW ENUMSURFACES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate all of the surfaces that meet the search criterion.
 */
#define DDENUMSURFACES_ALL			0x00000001l

/*
 * A search hit is a surface that matches the surface description.
 */
#define DDENUMSURFACES_MATCH			0x00000002l

/*
 * A search hit is a surface that does not match the surface description.
 */
#define DDENUMSURFACES_NOMATCH			0x00000004l

/*
 * Enumerate the first surface that can be created which meets the search criterion.
 */
#define DDENUMSURFACES_CANBECREATED		0x00000008l

/*
 * Enumerate the surfaces that already exist that meet the search criterion.
 */
#define DDENUMSURFACES_DOESEXIST		0x00000010l

//@@BEGIN_MSINTERNAL
#define DDENUMSURFACES_VALID			0x0000001fl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW ENUMDISPLAYMODES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate Modes with different refresh rates.  EnumDisplayModes guarantees
 * that a particular mode will be enumerated only once.  This flag specifies whether
 * the refresh rate is taken into account when determining if a mode is unique.
 */
#define DDEDM_REFRESHRATES			0x00000001l

//@@BEGIN_MSINTERNAL
#define DDEDM_VALID				0x00000001l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW SETCOOPERATIVELEVEL FLAGS
 *
 ****************************************************************************/

/*
 * Exclusive mode owner will be responsible for the entire primary surface.
 * GDI can be ignored. used with DD
 */
#define DDSCL_FULLSCREEN			0x00000001l

/*
 * allow CTRL_ALT_DEL to work while in fullscreen exclusive mode 
 */
#define DDSCL_ALLOWREBOOT			0x00000002l

/*
 * prevents DDRAW from modifying the application window.
 * prevents DDRAW from minimize/restore the application window on activation.
 */
#define DDSCL_NOWINDOWCHANGES			0x00000004l

/*
 * app wants to work as a regular Windows application
 */
#define DDSCL_NORMAL				0x00000008l

/*
 * app wants exclusive access
 */
#define DDSCL_EXCLUSIVE                         0x00000010l

//@@BEGIN_MSINTERNAL
/*
 * dont hook window proc, only valid for non-exclusive
 */
#define DDSCL_DONTHOOKHWND                      0x00000020l
//@@END_MSINTERNAL

/*
 * app can deal with non-windows display modes
 */
#define DDSCL_ALLOWMODEX                        0x00000040l

//@@BEGIN_MSINTERNAL
#define DDSCL_VALID                             0x0000007Fl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW BLT FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHADEST				0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDBLTFX structure as the alpha channel
 * for the destination surface for this blt.
 */
#define DDBLT_ALPHADESTCONSTOVERRIDE		0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHADESTNEG			0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDBLTFX structure as the alpha
 * channel for the destination for this blt.
 */
#define DDBLT_ALPHADESTSURFACEOVERRIDE		0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDBLTFX structure as the alpha channel
 * for the edges of the image that border the color key colors.
 */
#define DDBLT_ALPHAEDGEBLEND			0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHASRC				0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCCONSTOVERRIDE		0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHASRCNEG			0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt. 
 */
#define DDBLT_ALPHASRCSURFACEOVERRIDE		0x00000100l

/*
 * Do this blt asynchronously through the FIFO in the order received.  If
 * there is no room in the hardware FIFO fail the call.
 */
#define DDBLT_ASYNC				0x00000200l

/*
 * Uses the dwFillColor field in the DDBLTFX structure as the RGB color
 * to fill the destination rectangle on the destination surface with.
 */
#define DDBLT_COLORFILL				0x00000400l

/*
 * Uses the dwDDFX field in the DDBLTFX structure to specify the effects
 * to use for the blt.
 */
#define DDBLT_DDFX				0x00000800l

/*
 * Uses the dwDDROPS field in the DDBLTFX structure to specify the ROPS
 * that are not part of the Win32 API.
 */
#define DDBLT_DDROPS				0x00001000l

/*
 * Use the color key associated with the destination surface.
 */
#define DDBLT_KEYDEST				0x00002000l

/*
 * Use the dckDestColorkey field in the DDBLTFX structure as the color key
 * for the destination surface.
 */
#define DDBLT_KEYDESTOVERRIDE			0x00004000l

/*
 * Use the color key associated with the source surface.
 */
#define DDBLT_KEYSRC				0x00008000l

/*
 * Use the dckSrcColorkey field in the DDBLTFX structure as the color key
 * for the source surface.
 */
#define DDBLT_KEYSRCOVERRIDE			0x00010000l

/*
 * Use the dwROP field in the DDBLTFX structure for the raster operation
 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
 */
#define DDBLT_ROP				0x00020000l

/*
 * Use the dwRotationAngle field in the DDBLTFX structure as the angle
 * (specified in 1/100th of a degree) to rotate the surface.
 */
#define DDBLT_ROTATIONANGLE			0x00040000l

/*
 * Z-buffered blt using the z-buffers attached to the source and destination
 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
 * z-buffer opcode.
 */
#define DDBLT_ZBUFFER				0x00080000l

/*
 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the destination.
 */
#define DDBLT_ZBUFFERDESTCONSTOVERRIDE		0x00100000l

/*
 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the destination.
 */
#define DDBLT_ZBUFFERDESTOVERRIDE		0x00200000l

/*
 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the source.
 */
#define DDBLT_ZBUFFERSRCCONSTOVERRIDE		0x00400000l

/*
 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the source.
 */
#define DDBLT_ZBUFFERSRCOVERRIDE                0x00800000l

/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */
#define DDBLT_WAIT                              0x01000000l

/*
 * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
 * to fill the destination rectangle on the destination Z-buffer surface
 * with.
 */
#define DDBLT_DEPTHFILL				0x02000000l

//@@BEGIN_MSINTERNAL
#define DDBLT_VALID                             0x03ffffffl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * BLTFAST FLAGS
 *
 ****************************************************************************/

#define DDBLTFAST_NOCOLORKEY                    0x00000000
#define DDBLTFAST_SRCCOLORKEY                   0x00000001
#define DDBLTFAST_DESTCOLORKEY                  0x00000002
#define DDBLTFAST_WAIT                          0x00000010
//@@BEGIN_MSINTERNAL
#define DDBLTFAST_COLORKEY_MASK                 0x0000000F
#define DDBLTFAST_VALID                         0x00000013
//@@END_MSINTERNAL

/****************************************************************************
 *
 * FLIP FLAGS
 *
 ****************************************************************************/

#define DDFLIP_WAIT                          0x00000001l
//@@BEGIN_MSINTERNAL
#define DDFLIP_VALID                         0x00000001l
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
/****************************************************************************
 *
 * DIRECTDRAW COMP FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for this blt.
 */
#define DDCOMP_ALPHADEST			0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDCOMPOSEFX structure as the alpha channel
 * for the destination surface for this blt.
 */
#define DDCOMP_ALPHADESTCONSTOVERRIDE		0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. (0 is opaque)
 */
#define DDCOMP_ALPHADESTNEG			0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDCOMPOSEFX structure as the alpha
 * channel for the destination for this blt.
 */
#define DDCOMP_ALPHADESTSURFACEOVERRIDE		0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDCOMPOSEFX structure as the alpha channel
 * for the edges of the image that border the color key colors.
 */
#define DDCOMP_ALPHAEDGEBLEND			0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the alpha channel for this blt.
 */
#define DDCOMP_ALPHASRC				0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDCOMPOSEFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDCOMP_ALPHASRCCONSTOVERRIDE		0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases. (0 is opaque)
 */
#define DDCOMP_ALPHASRCNEG			0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDCOMPOSEFX structure as the alpha channel
 * for the source for this blt. 
 */
#define DDCOMP_ALPHASRCSURFACEOVERRIDE		0x00000100l

/*
 * Before performing this blt invoke the callback specified by the lpfnCallback
 * field in the DDCOMPOSEFX structure.
 */
#define DDCOMP_CALLBACK				0x00000200l

/*
 * Uses the dwFillColor field in the DDCOMPOSEFX structure as the RGB color
 * to fill the destination rectangle on the destination surface with.
 */
#define DDCOMP_COLORFILL			0x00000400l

/*
 * Uses the dwDDFX field in the DDCOMPOSEFX structure to specify the effects
 * to use for the blt.
 */
#define DDCOMP_DDFX				0x00000800l

/*
 * Uses the dwDDROPS field in the DDCOMPOSEFX structure to specify the ROPS
 * that are not part of the Win32 API.
 */
#define DDCOMP_DDROPS				0x00001000l

/*
 * Use the color key associated with the destination surface.
 */
#define DDCOMP_KEYDEST				0x00002000l

/*
 * Use the dckDestColorkey field in the DDCOMPOSEFX structure as the color key
 * for the destination surface.
 */
#define DDCOMP_KEYDESTOVERRIDE			0x00004000l

/*
 * Use the color key associated with the source surface.
 */
#define DDCOMP_KEYSRC				0x00008000l

/*
 * Use the dckSrcColorkey field in the DDCOMPOSEFX structure as the color key
 * for the source surface.
 */
#define DDCOMP_KEYSRCOVERRIDE			0x00010000l

/*
 * Do this blt when DestUnlock is called for the last time on the source surface.
 */
#define DDCOMP_ONDESTUNLOCK			0x00020000l

/*
 * Do this blt when Flip is called on the source surface.
 */
#define DDCOMP_ONFLIP				0x00040000l

/*
 * Do this blt when Unlock is called for the last time on the source surface.
 */
#define DDCOMP_ONUNLOCK				0x00080000l

/*
 * Repeat this composition blt the number of times specified in the dwRepeat
 * field of the DDCOMPOSEFX structure
 */
#define DDCOMP_REPEAT				0x00100000l

/*
 * Use the dwROP field in the DDCOMPOSEFX structure for the raster operation
 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
 */
#define DDCOMP_ROP				0x00200000l

/*
 * Use the dwRotationAngle field in the DDCOMPOSEFX structure as the angle
 * (specified in 1/100th of a degree) to rotate the surface.
 */
#define DDCOMP_ROTATIONANGLE			0x00400000l

/*
 * Z-buffered blt using the z-buffers attached to the source and destination
 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
 * z-buffer opcode.
 */
#define DDCOMP_ZBUFFER				0x00800000l

/*
 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
 * in the DDCOMPOSEFX structure as the z-buffer and z-buffer opcode respectively
 * for the destination.
 */
#define DDCOMP_ZBUFFERDESTCONSTOVERRIDE		0x01000000l

/*
 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
 * field in the DDCOMPOSEFX structure as the z-buffer and z-buffer opcode
 * respectively for the destination.
 */
#define DDCOMP_ZBUFFERDESTOVERRIDE		0x02000000l

/*
 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
 * in the DDCOMPOSEFX structure as the z-buffer and z-buffer opcode respectively
 * for the source.
 */
#define DDCOMP_ZBUFFERSRCCONSTOVERRIDE		0x04000000l

/*
 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
 * field in the DDCOMPOSEFX structure as the z-buffer and z-buffer opcode
 * respectively for the source.
 */
#define DDCOMP_ZBUFFERSRCOVERRIDE		0x08000000l
#endif
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW SURFACE OVERLAY FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for the
 * destination overlay.
 */
#define DDOVER_ALPHADEST			0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDOVERLAYFX structure as the
 * destination alpha channel for this overlay.
 */
#define DDOVER_ALPHADESTCONSTOVERRIDE		0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. 
 */
#define DDOVER_ALPHADESTNEG			0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDOVERLAYFX structure as the alpha
 * channel destination for this overlay.
 */
#define DDOVER_ALPHADESTSURFACEOVERRIDE		0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDOVERLAYFX structure as the alpha
 * channel for the edges of the image that border the color key colors.
 */
#define DDOVER_ALPHAEDGEBLEND			0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the source alpha channel for this overlay.
 */
#define DDOVER_ALPHASRC				0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDOVERLAYFX structure as the source
 * alpha channel for this overlay.
 */
#define DDOVER_ALPHASRCCONSTOVERRIDE		0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases.
 */
#define DDOVER_ALPHASRCNEG			0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDOVERLAYFX structure as the alpha channel
 * source for this overlay.
 */
#define DDOVER_ALPHASRCSURFACEOVERRIDE		0x00000100l

/*
 * Turn this overlay off.
 */
#define DDOVER_HIDE				0x00000200l

/*
 * Use the color key associated with the destination surface.
 */
#define DDOVER_KEYDEST				0x00000400l

/*
 * Use the dckDestColorkey field in the DDOVERLAYFX structure as the color key
 * for the destination surface
 */
#define DDOVER_KEYDESTOVERRIDE			0x00000800l

/*
 * Use the color key associated with the source surface.
 */
#define DDOVER_KEYSRC				0x00001000l

/*
 * Use the dckSrcColorkey field in the DDOVERLAYFX structure as the color key
 * for the source surface.
 */
#define DDOVER_KEYSRCOVERRIDE			0x00002000l

/*
 * Turn this overlay on.
 */
#define DDOVER_SHOW				0x00004000l

/*
 * Add a dirty rect to an emulated overlayed surface.
 */
#define DDOVER_ADDDIRTYRECT                     0x00008000l

/*
 * Redraw all dirty rects on an emulated overlayed surface.
 */
#define DDOVER_REFRESHDIRTYRECTS		0x00010000l

/*
 * Redraw the entire surface on an emulated overlayed surface.
 */
#define DDOVER_REFRESHALL                      0x00020000l

//@@BEGIN_MSINTERNAL
/*
 * Force redrawing onto the destination surface without regard for the background
 */
#define DDOVER_REFRESHPOUND                  	0x00040000l
//@@END_MSINTERNAL

/*
 * Use the overlay FX flags to define special overlay FX
 */
#define DDOVER_DDFX                       	0x00080000l

//@@BEGIN_MSINTERNAL
#define DDOVER_VALID				0x000fffffl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWSURFACE LOCK FLAGS
 *
 ****************************************************************************/

/*
 * The default.	 Set to indicate that Lock should return a valid memory pointer
 * to the top of the specified rectangle.  If no rectangle is specified then a
 * pointer to the top of the surface is returned.
 */
#define DDLOCK_SURFACEMEMORYPTR			0x00000000L	// default

/*
 * Set to indicate that Lock should wait until it can obtain a valid memory
 * pointer before returning.  If this bit is set, Lock will never return 
 * DDERR_WASSTILLDRAWING.
 */
#define DDLOCK_WAIT				0x00000001L

/*
 * Set if an event handle is being passed to Lock.  Lock will trigger the event
 * when it can return the surface memory pointer requested.
 */
#define DDLOCK_EVENT				0x00000002L

/*
 * Indicates that the surface being locked will only be read from.
 */
#define DDLOCK_READONLY				0x00000010L

/*
 * Indicates that the surface being locked will only be written to
 */
#define DDLOCK_WRITEONLY			0x00000020L

//@@BEGIN_MSINTERNAL
/* 
 * Indicates that InternalLock should set the busy bit and Win16 lock
 * for surfaces not explicitly in system memory.
 */
#define DDLOCK_TAKE_WIN16                       0x00000040L

/* 
 * Indicates that InternalLock should set the busy bit and Win16 lock
 * for surfaces in video memory only
 */
#define DDLOCK_TAKE_WIN16_VRAM                  0x00000080L

/*
 * Indicates that InternalLock should check for lost surfaces. By
 * default it does not.
 */
#define DDLOCK_FAILLOSTSURFACES                 0x00000100L

/* 
 * An aggregate of all the valid flags
 */
#define DDLOCK_VALID				0x00000031L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGELOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */

//@@BEGIN_MSINTERNAL
#define DDPAGELOCK_VALID			0x00000000L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGEUNLOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */

//@@BEGIN_MSINTERNAL
#define DDPAGEUNLOCK_VALID			0x00000000L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWSURFACE BLT FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this blt.
 */
#define DDBLTFX_ARITHSTRETCHY			0x00000001l

/*
 * Do this blt mirroring the surface left to right.  Spin the
 * surface around its y-axis.
 */
#define DDBLTFX_MIRRORLEFTRIGHT			0x00000002l

/*
 * Do this blt mirroring the surface up and down.  Spin the surface
 * around its x-axis.
 */
#define DDBLTFX_MIRRORUPDOWN			0x00000004l

/*
 * Schedule this blt to avoid tearing.
 */
#define DDBLTFX_NOTEARING			0x00000008l

/*
 * Do this blt rotating the surface one hundred and eighty degrees.
 */
#define DDBLTFX_ROTATE180			0x00000010l

/*
 * Do this blt rotating the surface two hundred and seventy degrees.
 */
#define DDBLTFX_ROTATE270			0x00000020l

/*
 * Do this blt rotating the surface ninety degrees.
 */
#define DDBLTFX_ROTATE90			0x00000040l

/*
 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
 * specified to limit the bits copied from the source surface.
 */
#define DDBLTFX_ZBUFFERRANGE			0x00000080l

/*
 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
 * before comparing it with the desting z values.
 */
#define DDBLTFX_ZBUFFERBASEDEST			0x00000100l

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * DIRECTDRAWSURFACE COMP FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this blt.
 */
#define DDCOMPFX_ARITHSTRETCHY			0x00000001l

/*
 * Do this blt mirroring the surface left to right.  Spin the
 * surface around its y-axis.
 */
#define DDCOMPFX_MIRRORLEFTRIGHT		0x00000002l

/*
 * Do this blt mirroring the surface up and down.  Spin the surface
 * around its x-axis.
 */
#define DDCOMPFX_MIRRORUPDOWN			0x00000004l

/*
 * Schedule this blt to avoid tearing.
 */
#define DDCOMPFX_NOTEARING			0x00000008l

/*
 * Do this blt rotating the surface one hundred and eighty degrees.
 */
#define DDCOMPFX_ROTATE180			0x00000010l

/*
 * Do this blt rotating the surface two hundred and seventy degrees.
 */
#define DDCOMPFX_ROTATE270			0x00000020l

/*
 * Do this blt rotating the surface ninety degrees.
 */
#define DDCOMPFX_ROTATE90			0x00000040l

/*
 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
 * specified to limit the bits copied from the source surface.
 */
#define DDCOMPFX_ZBUFFERRANGE			0x00000080l

/*
 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
 * before comparing it with the desting z values.
 */
#define DDCOMPFX_ZBUFFERBASEDEST		0x00000100l
//@@END_MSINTERNAL
/****************************************************************************
 *
 * DIRECTDRAWSURFACE OVERLAY FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this overlay.
 */
#define DDOVERFX_ARITHSTRETCHY			0x00000001l

/*
 * Mirror the overlay across the vertical axis
 */
#define DDOVERFX_MIRRORLEFTRIGHT		0x00000002l

/*
 * Mirror the overlay across the horizontal axis
 */
#define DDOVERFX_MIRRORUPDOWN			0x00000004l

/****************************************************************************
 *
 * DIRECTDRAW WAITFORVERTICALBLANK FLAGS
 *
 ****************************************************************************/

/*
 * return when the vertical blank interval begins
 */
#define DDWAITVB_BLOCKBEGIN			0x00000001l

/*
 * set up an event to trigger when the vertical blank begins
 */
#define DDWAITVB_BLOCKBEGINEVENT		0x00000002l

/*
 * return when the vertical blank interval ends and display begins
 */
#define DDWAITVB_BLOCKEND			0x00000004l

/****************************************************************************
 *
 * DIRECTDRAW GETFLIPSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to flip now?
 */
#define DDGFS_CANFLIP			0x00000001l

/*
 * is the last flip finished?
 */
#define DDGFS_ISFLIPDONE		0x00000002l
// @@BEGIN_MSINTERNAL
#define DDGFS_VALID                     0x00000003l
// @@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW GETBLTSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to blt now?
 */
#define DDGBS_CANBLT			0x00000001l

/*
 * is the blt to the surface finished?
 */
#define DDGBS_ISBLTDONE			0x00000002l

// @@BEGIN_MSINTERNAL
#define DDGBS_VALID                     0x00000003l
// @@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW ENUMOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate overlays back to front.
 */
#define DDENUMOVERLAYZ_BACKTOFRONT	0x00000000l

/*
 * Enumerate overlays front to back
 */
#define DDENUMOVERLAYZ_FRONTTOBACK	0x00000001l

/****************************************************************************
 *
 * DIRECTDRAW UPDATEOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Send overlay to front
 */
#define DDOVERZ_SENDTOFRONT		0x00000000l

/*
 * Send overlay to back
 */
#define DDOVERZ_SENDTOBACK		0x00000001l

/*
 * Move Overlay forward
 */
#define DDOVERZ_MOVEFORWARD		0x00000002l

/*
 * Move Overlay backward
 */
#define DDOVERZ_MOVEBACKWARD		0x00000003l

/*
 * Move Overlay in front of relative surface
 */
#define DDOVERZ_INSERTINFRONTOF		0x00000004l

/*
 * Move Overlay in back of relative surface
 */
#define DDOVERZ_INSERTINBACKOF		0x00000005l

/*===========================================================================
 *
 *
 * DIRECTDRAW RETURN CODES
 *
 * The return values from DirectDraw Commands and Surface that return an HRESULT
 * are codes from DirectDraw concerning the results of the action
 * requested by DirectDraw.
 *
 *==========================================================================*/

/*
 * Status is OK
 *
 * Issued by: DirectDraw Commands and all callbacks
 */
//@@BEGIN_MSINTERNAL
#define DD_OK_HANDLED				1
#define DD_OK_NOTHANDLED			0
//@@END_MSINTERNAL
#define DD_OK					0

/****************************************************************************
 *
 * DIRECTDRAW ENUMCALLBACK RETURN VALUES
 *
 * EnumCallback returns are used to control the flow of the DIRECTDRAW and
 * DIRECTDRAWSURFACE object enumerations.   They can only be returned by
 * enumeration callback routines.
 *
 ****************************************************************************/

/*
 * stop the enumeration
 */
#define DDENUMRET_CANCEL			0

/*
 * continue the enumeration
 */
#define DDENUMRET_OK				1

/****************************************************************************
 *
 * DIRECTDRAW ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

/*
 * This object is already initialized
 */
#define DDERR_ALREADYINITIALIZED		MAKE_DDHRESULT( 5 )

/*
 * This surface can not be attached to the requested surface.
 */
#define DDERR_CANNOTATTACHSURFACE		MAKE_DDHRESULT( 10 )

/*
 * This surface can not be detached from the requested surface.
 */
#define DDERR_CANNOTDETACHSURFACE		MAKE_DDHRESULT( 20 )

/*
 * Support is currently not available.
 */
#define DDERR_CURRENTLYNOTAVAIL			MAKE_DDHRESULT( 40 )

/*
 * An exception was encountered while performing the requested operation
 */
#define DDERR_EXCEPTION				MAKE_DDHRESULT( 55 )

/*
 * Generic failure.
 */
#define DDERR_GENERIC				E_FAIL

/*
 * Height of rectangle provided is not a multiple of reqd alignment
 */
#define DDERR_HEIGHTALIGN			MAKE_DDHRESULT( 90 )

/*
 * Unable to match primary surface creation request with existing 
 * primary surface.
 */
#define DDERR_INCOMPATIBLEPRIMARY		MAKE_DDHRESULT( 95 )

/*
 * One or more of the caps bits passed to the callback are incorrect.
 */
#define DDERR_INVALIDCAPS			MAKE_DDHRESULT( 100 )

/*
 * DirectDraw does not support provided Cliplist.
 */
#define DDERR_INVALIDCLIPLIST			MAKE_DDHRESULT( 110 )

/*
 * DirectDraw does not support the requested mode
 */
#define DDERR_INVALIDMODE			MAKE_DDHRESULT( 120 )

/*
 * DirectDraw received a pointer that was an invalid DIRECTDRAW object.
 */
#define DDERR_INVALIDOBJECT			MAKE_DDHRESULT( 130 )

/*
 * One or more of the parameters passed to the callback function are
 * incorrect.
 */
#define DDERR_INVALIDPARAMS			E_INVALIDARG

/*
 * pixel format was invalid as specified
 */
#define DDERR_INVALIDPIXELFORMAT		MAKE_DDHRESULT( 145 )

/*
 * Rectangle provided was invalid.
 */
#define DDERR_INVALIDRECT			MAKE_DDHRESULT( 150 )

/*
 * Operation could not be carried out because one or more surfaces are locked
 */
#define DDERR_LOCKEDSURFACES			MAKE_DDHRESULT( 160 )

/*
 * There is no 3D present.
 */
#define DDERR_NO3D				MAKE_DDHRESULT( 170 )

/*
 * Operation could not be carried out because there is no alpha accleration
 * hardware present or available.
 */
#define DDERR_NOALPHAHW				MAKE_DDHRESULT( 180 )

// @@BEGIN_MSINTERNAL
/*
 * Operation could not be carried out because there is no hardware support
 * for synchronizing blts to avoid tearing.
 */
#define DDERR_NOANTITEARHW			MAKE_DDHRESULT( 190 )

/*
 * Operation could not be carried out because there is no hardware support
 * for asynchronous blting.
 */
#define DDERR_NOBLTQUEUEHW			MAKE_DDHRESULT( 200 )
// @@END_MSINTERNAL

/*
 * no clip list available
 */
#define DDERR_NOCLIPLIST			MAKE_DDHRESULT( 205 )

/*
 * Operation could not be carried out because there is no color conversion
 * hardware present or available.
 */
#define DDERR_NOCOLORCONVHW			MAKE_DDHRESULT( 210 )

/*
 * Create function called without DirectDraw object method SetCooperativeLevel
 * being called.
 */
#define DDERR_NOCOOPERATIVELEVELSET		MAKE_DDHRESULT( 212 )

/*
 * Surface doesn't currently have a color key
 */
#define DDERR_NOCOLORKEY			MAKE_DDHRESULT( 215 )

/*
 * Operation could not be carried out because there is no hardware support
 * of the dest color key.
 */
#define DDERR_NOCOLORKEYHW			MAKE_DDHRESULT( 220 )

/*
 * No DirectDraw support possible with current display driver
 */
#define DDERR_NODIRECTDRAWSUPPORT		MAKE_DDHRESULT( 222 )

/*
 * Operation requires the application to have exclusive mode but the
 * application does not have exclusive mode.
 */
#define DDERR_NOEXCLUSIVEMODE			MAKE_DDHRESULT( 225 )

/*
 * Flipping visible surfaces is not supported.
 */
#define DDERR_NOFLIPHW				MAKE_DDHRESULT( 230 )

/*
 * There is no GDI present.
 */
#define DDERR_NOGDI				MAKE_DDHRESULT( 240 )

/*
 * Operation could not be carried out because there is no hardware present
 * or available.
 */
#define DDERR_NOMIRRORHW			MAKE_DDHRESULT( 250 )

/*
 * Requested item was not found
 */
#define DDERR_NOTFOUND				MAKE_DDHRESULT( 255 )

/*
 * Operation could not be carried out because there is no overlay hardware
 * present or available.
 */
#define DDERR_NOOVERLAYHW			MAKE_DDHRESULT( 260 )

/*
 * Operation could not be carried out because there is no appropriate raster
 * op hardware present or available.
 */
#define DDERR_NORASTEROPHW			MAKE_DDHRESULT( 280 )

/*
 * Operation could not be carried out because there is no rotation hardware
 * present or available.
 */
#define DDERR_NOROTATIONHW			MAKE_DDHRESULT( 290 )

/*
 * Operation could not be carried out because there is no hardware support
 * for stretching
 */
#define DDERR_NOSTRETCHHW			MAKE_DDHRESULT( 310 )

/*
 * DirectDrawSurface is not in 4 bit color palette and the requested operation
 * requires 4 bit color palette.
 */
#define DDERR_NOT4BITCOLOR			MAKE_DDHRESULT( 316 )

/*
 * DirectDrawSurface is not in 4 bit color index palette and the requested
 * operation requires 4 bit color index palette.
 */
#define DDERR_NOT4BITCOLORINDEX			MAKE_DDHRESULT( 317 )

/*
 * DirectDraw Surface is not in 8 bit color mode and the requested operation
 * requires 8 bit color.
 */
#define DDERR_NOT8BITCOLOR			MAKE_DDHRESULT( 320 )

/*
 * Operation could not be carried out because there is no texture mapping
 * hardware present or available.
 */
#define DDERR_NOTEXTUREHW			MAKE_DDHRESULT( 330 )

/*
 * Operation could not be carried out because there is no hardware support
 * for vertical blank synchronized operations.
 */
#define DDERR_NOVSYNCHW				MAKE_DDHRESULT( 335 )

/*
 * Operation could not be carried out because there is no hardware support
 * for zbuffer blting.
 */
#define DDERR_NOZBUFFERHW			MAKE_DDHRESULT( 340 )

/*
 * Overlay surfaces could not be z layered based on their BltOrder because
 * the hardware does not support z layering of overlays.
 */
#define DDERR_NOZOVERLAYHW			MAKE_DDHRESULT( 350 )

/*
 * The hardware needed for the requested operation has already been
 * allocated.
 */
#define DDERR_OUTOFCAPS				MAKE_DDHRESULT( 360 )

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFMEMORY			E_OUTOFMEMORY

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFVIDEOMEMORY			MAKE_DDHRESULT( 380 )

/*
 * hardware does not support clipped overlays
 */
#define DDERR_OVERLAYCANTCLIP			MAKE_DDHRESULT( 382 )

/*
 * Can only have ony color key active at one time for overlays
 */
#define DDERR_OVERLAYCOLORKEYONLYONEACTIVE	MAKE_DDHRESULT( 384 )

/*
 * Access to this palette is being refused because the palette is already
 * locked by another thread.
 */
#define DDERR_PALETTEBUSY			MAKE_DDHRESULT( 387 )

/*
 * No src color key specified for this operation.
 */
#define DDERR_COLORKEYNOTSET			MAKE_DDHRESULT( 400 )

/*
 * This surface is already attached to the surface it is being attached to.
 */
#define DDERR_SURFACEALREADYATTACHED		MAKE_DDHRESULT( 410 )

/*
 * This surface is already a dependency of the surface it is being made a
 * dependency of.
 */
#define DDERR_SURFACEALREADYDEPENDENT		MAKE_DDHRESULT( 420 )

/*
 * Access to this surface is being refused because the surface is already
 * locked by another thread.
 */
#define DDERR_SURFACEBUSY			MAKE_DDHRESULT( 430 )

/*
 * Access to this surface is being refused because no driver exists
 * which can supply a pointer to the surface.
 * This is most likely to happen when attempting to lock the primary
 * surface when no DCI provider is present.
 */
#define DDERR_CANTLOCKSURFACE                   MAKE_DDHRESULT( 435 )

/*
 * Access to Surface refused because Surface is obscured.
 */
#define DDERR_SURFACEISOBSCURED			MAKE_DDHRESULT( 440 )

/*
 * Access to this surface is being refused because the surface is gone.
 * The DIRECTDRAWSURFACE object representing this surface should 
 * have Restore called on it.
 */
#define DDERR_SURFACELOST			MAKE_DDHRESULT( 450 )

/*
 * The requested surface is not attached.
 */
#define DDERR_SURFACENOTATTACHED		MAKE_DDHRESULT( 460 )

/*
 * Height requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGHEIGHT			MAKE_DDHRESULT( 470 )

/*
 * Size requested by DirectDraw is too large --	 The individual height and
 * width are OK.
 */
#define DDERR_TOOBIGSIZE			MAKE_DDHRESULT( 480 )

/*
 * Width requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGWIDTH			MAKE_DDHRESULT( 490 )

/*
 * Action not supported.
 */
#define DDERR_UNSUPPORTED			E_NOTIMPL

/*
 * FOURCC format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDFORMAT			MAKE_DDHRESULT( 510 )

/*
 * Bitmask in the pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDMASK			MAKE_DDHRESULT( 520 )

/*
 * vertical blank is in progress
 */
#define DDERR_VERTICALBLANKINPROGRESS		MAKE_DDHRESULT( 537 )

/*
 * Informs DirectDraw that the previous Blt which is transfering information
 * to or from this Surface is incomplete.
 */
#define DDERR_WASSTILLDRAWING			MAKE_DDHRESULT( 540 )

/*
 * Rectangle provided was not horizontally aligned on reqd. boundary
 */
#define DDERR_XALIGN				MAKE_DDHRESULT( 560 )

/*
 * The GUID passed to DirectDrawCreate is not a valid DirectDraw driver
 * identifier.
 */
#define DDERR_INVALIDDIRECTDRAWGUID		MAKE_DDHRESULT( 561 )

/*
 * A DirectDraw object representing this driver has already been created
 * for this process.
 */
#define DDERR_DIRECTDRAWALREADYCREATED		MAKE_DDHRESULT( 562 )

/*
 * A hardware only DirectDraw object creation was attempted but the driver
 * did not support any hardware.
 */
#define DDERR_NODIRECTDRAWHW			MAKE_DDHRESULT( 563 )

/*
 * this process already has created a primary surface
 */
#define DDERR_PRIMARYSURFACEALREADYEXISTS	MAKE_DDHRESULT( 564 )

/*
 * software emulation not available.
 */
#define DDERR_NOEMULATION			MAKE_DDHRESULT( 565 )

/*
 * region passed to Clipper::GetClipList is too small.
 */
#define DDERR_REGIONTOOSMALL			MAKE_DDHRESULT( 566 )

/*
 * an attempt was made to set a clip list for a clipper objec that
 * is already monitoring an hwnd.
 */
#define DDERR_CLIPPERISUSINGHWND		MAKE_DDHRESULT( 567 )

/*
 * No clipper object attached to surface object
 */
#define DDERR_NOCLIPPERATTACHED			MAKE_DDHRESULT( 568 )

/*
 * Clipper notification requires an HWND or
 * no HWND has previously been set as the CooperativeLevel HWND.
 */
#define DDERR_NOHWND				MAKE_DDHRESULT( 569 )

/*
 * HWND used by DirectDraw CooperativeLevel has been subclassed,
 * this prevents DirectDraw from restoring state.
 */
#define DDERR_HWNDSUBCLASSED			MAKE_DDHRESULT( 570 )

/*
 * The CooperativeLevel HWND has already been set.
 * It can not be reset while the process has surfaces or palettes created.
 */
#define DDERR_HWNDALREADYSET			MAKE_DDHRESULT( 571 )

/*
 * No palette object attached to this surface.
 */
#define DDERR_NOPALETTEATTACHED			MAKE_DDHRESULT( 572 )

/*
 * No hardware support for 16 or 256 color palettes.
 */
#define DDERR_NOPALETTEHW			MAKE_DDHRESULT( 573 )

/*
 * If a clipper object is attached to the source surface passed into a
 * BltFast call.
 */
#define DDERR_BLTFASTCANTCLIP			MAKE_DDHRESULT( 574 )

/*
 * No blter.
 */
#define DDERR_NOBLTHW				MAKE_DDHRESULT( 575 )

/*
 * No DirectDraw ROP hardware.
 */
#define DDERR_NODDROPSHW			MAKE_DDHRESULT( 576 )

/*
 * returned when GetOverlayPosition is called on a hidden overlay
 */
#define DDERR_OVERLAYNOTVISIBLE			MAKE_DDHRESULT( 577 )

/*
 * returned when GetOverlayPosition is called on a overlay that UpdateOverlay
 * has never been called on to establish a destionation.
 */
#define DDERR_NOOVERLAYDEST			MAKE_DDHRESULT( 578 )

/*
 * returned when the position of the overlay on the destionation is no longer
 * legal for that destionation.
 */
#define DDERR_INVALIDPOSITION			MAKE_DDHRESULT( 579 )

/*
 * returned when an overlay member is called for a non-overlay surface
 */
#define DDERR_NOTAOVERLAYSURFACE		MAKE_DDHRESULT( 580 )
 
/*
 * An attempt was made to set the cooperative level when it was already
 * set to exclusive.
 */
#define DDERR_EXCLUSIVEMODEALREADYSET		MAKE_DDHRESULT( 581 )

/*
 * An attempt has been made to flip a surface that is not flippable.
 */
#define DDERR_NOTFLIPPABLE			MAKE_DDHRESULT( 582 )

/*
 * Can't duplicate primary & 3D surfaces, or surfaces that are implicitly
 * created.
 */
#define DDERR_CANTDUPLICATE			MAKE_DDHRESULT( 583 )

/*
 * Surface was not locked.  An attempt to unlock a surface that was not
 * locked at all, or by this process, has been attempted.
 */
#define DDERR_NOTLOCKED				MAKE_DDHRESULT( 584 )

/*
 * Windows can not create any more DCs
 */
#define DDERR_CANTCREATEDC			MAKE_DDHRESULT( 585 )

/*
 * No DC was ever created for this surface.
 */
#define DDERR_NODC				MAKE_DDHRESULT( 586 )

/*
 * This surface can not be restored because it was created in a different
 * mode.
 */
#define DDERR_WRONGMODE				MAKE_DDHRESULT( 587 )

/*
 * This surface can not be restored because it is an implicitly created
 * surface.
 */
#define DDERR_IMPLICITLYCREATED			MAKE_DDHRESULT( 588 )

/*
 * The surface being used is not a palette-based surface
 */
#define DDERR_NOTPALETTIZED			MAKE_DDHRESULT( 589 )


/*
 * The display is currently in an unsupported mode
 */
#define DDERR_UNSUPPORTEDMODE			MAKE_DDHRESULT( 590 )

/*
 * Operation could not be carried out because there is no mip-map
 * texture mapping hardware present or available.
 */
#define DDERR_NOMIPMAPHW			MAKE_DDHRESULT( 591 )

/*
 * The requested action could not be performed because the surface was of
 * the wrong type.
 */
#define DDERR_INVALIDSURFACETYPE                MAKE_DDHRESULT( 592 )

// @@BEGIN_MSINTERNAL
/*
 * Operation could not be carried out because there is no hardware support
 * for execute buffers.
 */
#define DDERR_NOEXECUTEBUFFERHW			MAKE_DDHRESULT( 593 )
// @@END_MSINTERNAL

// @@BEGIN_MSINTERNAL
#ifdef SHAREDZ

/*
 * This process has already created a shared Z buffer
 */
#define DDERR_SHAREDZBUFFERALREADYEXISTS        MAKE_DDHRESULT( 594 )

/*
 * Unable to match shared Z buffer creation request with existing
 * shared Z buffer.
 */
#define DDERR_INCOMPATIBLESHAREDZBUFFER         MAKE_DDHRESULT( 595 )

/*
 * This process has already created a shared backbuffer
 */
#define DDERR_SHAREDBACKBUFFERALREADYEXISTS     MAKE_DDHRESULT( 596 )

/*
 * Unable to match shared backbuffer creation request with existing 
 * shared backbuffer.
 */
#define DDERR_INCOMPATIBLESHAREDBACKBUFFER      MAKE_DDHRESULT( 597 )

/*
 * Operation could not be carried out because there is no hardware support
 * for shared Z buffers.
 */
#define DDERR_NOSHAREDZBUFFERHW                 MAKE_DDHRESULT( 598 )

/*
 * Operation could not be carried out because there is no hardware support
 * for shared backbuffers.
 */
#define DDERR_NOSHAREDBACKBUFFERHW              MAKE_DDHRESULT( 599 )

#endif
// @@END_MSINTERNAL

/*
 * A DC has already been returned for this surface. Only one DC can be 
 * retrieved per surface.
 */
#define DDERR_DCALREADYCREATED			MAKE_DDHRESULT( 620 )

/*
 * The attempt to page lock a surface failed.
 */
#define DDERR_CANTPAGELOCK			MAKE_DDHRESULT( 640 )

/*
 * The attempt to page unlock a surface failed.
 */
#define DDERR_CANTPAGEUNLOCK			MAKE_DDHRESULT( 660 )

/*
 * An attempt was made to page unlock a surface with no outstanding page locks.
 */
#define DDERR_NOTPAGELOCKED			MAKE_DDHRESULT( 680 )

/*
 * An attempt was made to invoke an interface member of a DirectDraw object
 * created by CoCreateInstance() before it was initialized.
 */
#define DDERR_NOTINITIALIZED                    CO_E_NOTINITIALIZED

/* Alpha bit depth constants */

//@@BEGIN_MSINTERNAL
/*
 * 1 bit alpha constants
 */

/*
 * Completely transparent. Colors being blended with this constant do not affect
 * the final result.
 */
#define DDALPHA1_TRANSPARENT			0

/*
 * Completely opaque. Colors being blended with this constant are the final result.
 */
#define DDALPHA1_OPAQUE				1

/*
 * 2 bit alpha constants
 */

/*
 * Completely transparent. Colors being blended with this constant do not effect
 * the final result.
 */
#define DDALPHA2_TRANSPARENT			0

/*
 * 50-50 blend.	 Colors being blended with this constant effect the final result
 * with 50% of their color.
 */
#define DDALPHA2_50				2

/*
 * Completely opaque. Colors being blended with this constant are the final result.
 */
#define DDALPHA2_OPAQUE				3

/*
 * 4 bit alpha constants
 */

/*
 * Completely transparent. Colors being blended with this constant do not effect
 * the final result.
 */
#define DDALPHA4_TRANSPARENT			0

/*
 * Opaque modifier is multiplied by any value between 0 and _OPAQUE to
 * establish gradients of alpha blending.
 */
#define DDALPHA4_OPAQUEMOD			1

/*
 * 50-50 blend.	 Colors being blended with this constant effect the final result
 * with 50% of their color.
 */
#define DDALPHA4_50				8

/*
 * Completely opaque. Colors being blended with this constant are the final result.
 */
#define DDALPHA4_OPAQUE				15

/*
 * 8 bit alpha constants
 */

/*
 * Completely transparent. Colors being blended with this constant do not effect
 * the final result.
 */
#define DDALPHA8_TRANSPARENT			0

/*
 * Opaque modifier is multiplied by any value between 0 and _OPAQUE to
 * establish gradients of alpha blending.
 */
#define DDALPHA8_OPAQUEMOD			1

/*
 * 50-50 blend.	 Colors being blended with this constant effect the final result
 * with 50% of their color.
 */
#define DDALPHA8_50				128
/*
 * Completely opaque. Colors being blended with this constant are the final result.
 */
#define DDALPHA8_OPAQUE				255
//@@END_MSINTERNAL

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\d3dcaps.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dcaps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3DCAPS_H
#define _D3DCAPS_H

/*
 *  Pull in DirectDraw include file automatically:
 */
#include <ddraw.h>

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0600
#endif

#pragma pack(4)

/* Description of capabilities of transform */

typedef struct _D3DTRANSFORMCAPS {
    DWORD dwSize;
    DWORD dwCaps;
} D3DTRANSFORMCAPS, *LPD3DTRANSFORMCAPS;

#define D3DTRANSFORMCAPS_CLIP           0x00000001L /* Will clip whilst transforming */

/* Description of capabilities of lighting */

typedef struct _D3DLIGHTINGCAPS {
    DWORD dwSize;
    DWORD dwCaps;                   /* Lighting caps */
    DWORD dwLightingModel;          /* Lighting model - RGB or mono */
    DWORD dwNumLights;              /* Number of lights that can be handled */
} D3DLIGHTINGCAPS, *LPD3DLIGHTINGCAPS;

#define D3DLIGHTINGMODEL_RGB            0x00000001L
#define D3DLIGHTINGMODEL_MONO           0x00000002L

#define D3DLIGHTCAPS_POINT              0x00000001L /* Point lights supported */
#define D3DLIGHTCAPS_SPOT               0x00000002L /* Spot lights supported */
#define D3DLIGHTCAPS_DIRECTIONAL        0x00000004L /* Directional lights supported */
#define D3DLIGHTCAPS_PARALLELPOINT      0x00000008L /* Parallel point lights supported */
#if(DIRECT3D_VERSION < 0x500)
#define D3DLIGHTCAPS_GLSPOT             0x00000010L /* GL syle spot lights supported */
#endif

/* Description of capabilities for each primitive type */

typedef struct _D3DPrimCaps {
    DWORD dwSize;
    DWORD dwMiscCaps;                 /* Capability flags */
    DWORD dwRasterCaps;
    DWORD dwZCmpCaps;
    DWORD dwSrcBlendCaps;
    DWORD dwDestBlendCaps;
    DWORD dwAlphaCmpCaps;
    DWORD dwShadeCaps;
    DWORD dwTextureCaps;
    DWORD dwTextureFilterCaps;
    DWORD dwTextureBlendCaps;
    DWORD dwTextureAddressCaps;
    DWORD dwStippleWidth;             /* maximum width and height of */
    DWORD dwStippleHeight;            /* of supported stipple (up to 32x32) */
} D3DPRIMCAPS, *LPD3DPRIMCAPS;

/* D3DPRIMCAPS dwMiscCaps */

#define D3DPMISCCAPS_MASKPLANES         0x00000001L
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CONFORMANT         0x00000008L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L

/* D3DPRIMCAPS dwRasterCaps */

#define D3DPRASTERCAPS_DITHER                   0x00000001L
#define D3DPRASTERCAPS_ROP2                     0x00000002L
#define D3DPRASTERCAPS_XOR                      0x00000004L
#define D3DPRASTERCAPS_PAT                      0x00000008L
#define D3DPRASTERCAPS_ZTEST                    0x00000010L
#define D3DPRASTERCAPS_SUBPIXEL                 0x00000020L
#define D3DPRASTERCAPS_SUBPIXELX                0x00000040L
#define D3DPRASTERCAPS_FOGVERTEX                0x00000080L
#define D3DPRASTERCAPS_FOGTABLE                 0x00000100L
#define D3DPRASTERCAPS_STIPPLE                  0x00000200L
#define D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   0x00000400L
#define D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT 0x00000800L
#define D3DPRASTERCAPS_ANTIALIASEDGES           0x00001000L
#define D3DPRASTERCAPS_MIPMAPLODBIAS            0x00002000L
#define D3DPRASTERCAPS_ZBIAS                    0x00004000L
#define D3DPRASTERCAPS_ZBUFFERLESSHSR           0x00008000L
#define D3DPRASTERCAPS_FOGRANGE                 0x00010000L
#define D3DPRASTERCAPS_ANISOTROPY               0x00020000L
#define D3DPRASTERCAPS_WBUFFER                      0x00040000L
#define D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT   0x00080000L
#define D3DPRASTERCAPS_WFOG                         0x00100000L

/* D3DPRIMCAPS dwZCmpCaps, dwAlphaCmpCaps */

#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

/* D3DPRIMCAPS dwSourceBlendCaps, dwDestBlendCaps */

#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L

/* D3DPRIMCAPS dwShadeCaps */

#define D3DPSHADECAPS_COLORFLATMONO             0x00000001L
#define D3DPSHADECAPS_COLORFLATRGB              0x00000002L
#define D3DPSHADECAPS_COLORGOURAUDMONO          0x00000004L
#define D3DPSHADECAPS_COLORGOURAUDRGB           0x00000008L
#define D3DPSHADECAPS_COLORPHONGMONO            0x00000010L
#define D3DPSHADECAPS_COLORPHONGRGB             0x00000020L

#define D3DPSHADECAPS_SPECULARFLATMONO          0x00000040L
#define D3DPSHADECAPS_SPECULARFLATRGB           0x00000080L
#define D3DPSHADECAPS_SPECULARGOURAUDMONO       0x00000100L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB        0x00000200L
#define D3DPSHADECAPS_SPECULARPHONGMONO         0x00000400L
#define D3DPSHADECAPS_SPECULARPHONGRGB          0x00000800L

#define D3DPSHADECAPS_ALPHAFLATBLEND            0x00001000L
#define D3DPSHADECAPS_ALPHAFLATSTIPPLED         0x00002000L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND         0x00004000L
#define D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED      0x00008000L
#define D3DPSHADECAPS_ALPHAPHONGBLEND           0x00010000L
#define D3DPSHADECAPS_ALPHAPHONGSTIPPLED        0x00020000L

#define D3DPSHADECAPS_FOGFLAT                   0x00040000L
#define D3DPSHADECAPS_FOGGOURAUD                0x00080000L
#define D3DPSHADECAPS_FOGPHONG                  0x00100000L

/* D3DPRIMCAPS dwTextureCaps */

/*
 * Perspective-correct texturing is supported
 */
#define D3DPTEXTURECAPS_PERSPECTIVE     0x00000001L

/*
 * Power-of-2 texture dimensions are required
 */
#define D3DPTEXTURECAPS_POW2            0x00000002L

/*
 * Alpha in texture pixels is supported
 */
#define D3DPTEXTURECAPS_ALPHA           0x00000004L

/*
 * Color-keyed textures are supported
 */
#define D3DPTEXTURECAPS_TRANSPARENCY    0x00000008L

/*
 * obsolete, see D3DPTADDRESSCAPS_BORDER
 */
#define D3DPTEXTURECAPS_BORDER          0x00000010L

/*
 * Only square textures are supported
 */
#define D3DPTEXTURECAPS_SQUAREONLY      0x00000020L

/*
 * Texture indices are not scaled by the texture size prior
 * to interpolation.
 */
#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L

/*
 * Device can draw alpha from texture palettes
 */
#define D3DPTEXTURECAPS_ALPHAPALETTE    0x00000080L


/* D3DPRIMCAPS dwTextureFilterCaps */

#define D3DPTFILTERCAPS_NEAREST         0x00000001L
#define D3DPTFILTERCAPS_LINEAR          0x00000002L
#define D3DPTFILTERCAPS_MIPNEAREST      0x00000004L
#define D3DPTFILTERCAPS_MIPLINEAR       0x00000008L
#define D3DPTFILTERCAPS_LINEARMIPNEAREST 0x00000010L
#define D3DPTFILTERCAPS_LINEARMIPLINEAR 0x00000020L

/* Device3 Min Filter */
#define D3DPTFILTERCAPS_MINFPOINT       0x00000100L
#define D3DPTFILTERCAPS_MINFLINEAR      0x00000200L
#define D3DPTFILTERCAPS_MINFANISOTROPIC 0x00000400L

/* Device3 Mip Filter */
#define D3DPTFILTERCAPS_MIPFPOINT       0x00010000L
#define D3DPTFILTERCAPS_MIPFLINEAR      0x00020000L

/* Device3 Mag Filter */
#define D3DPTFILTERCAPS_MAGFPOINT         0x01000000L
#define D3DPTFILTERCAPS_MAGFLINEAR        0x02000000L
#define D3DPTFILTERCAPS_MAGFANISOTROPIC   0x04000000L
#define D3DPTFILTERCAPS_MAGFAFLATCUBIC    0x08000000L
#define D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC 0x10000000L

/* D3DPRIMCAPS dwTextureBlendCaps */

#define D3DPTBLENDCAPS_DECAL            0x00000001L
#define D3DPTBLENDCAPS_MODULATE         0x00000002L
#define D3DPTBLENDCAPS_DECALALPHA       0x00000004L
#define D3DPTBLENDCAPS_MODULATEALPHA    0x00000008L
#define D3DPTBLENDCAPS_DECALMASK        0x00000010L
#define D3DPTBLENDCAPS_MODULATEMASK     0x00000020L
#define D3DPTBLENDCAPS_COPY             0x00000040L
#define D3DPTBLENDCAPS_ADD              0x00000080L

/* D3DPRIMCAPS dwTextureAddressCaps */
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L
#define D3DPTADDRESSCAPS_BORDER         0x00000008L
#define D3DPTADDRESSCAPS_INDEPENDENTUV  0x00000010L


/* D3DDEVICEDESC dwStencilCaps */

#define D3DSTENCILCAPS_KEEP     0x00000001L
#define D3DSTENCILCAPS_ZERO     0x00000002L
#define D3DSTENCILCAPS_REPLACE  0x00000004L
#define D3DSTENCILCAPS_INCRSAT  0x00000008L
#define D3DSTENCILCAPS_DECRSAT  0x00000010L
#define D3DSTENCILCAPS_INVERT   0x00000020L
#define D3DSTENCILCAPS_INCR     0x00000040L
#define D3DSTENCILCAPS_DECR     0x00000080L

/* D3DDEVICEDESC dwTextureOpCaps */

#define D3DTEXOPCAPS_DISABLE                    0x00000001L
#define D3DTEXOPCAPS_SELECTARG1                 0x00000002L
#define D3DTEXOPCAPS_SELECTARG2                 0x00000004L
#define D3DTEXOPCAPS_MODULATE                   0x00000008L
#define D3DTEXOPCAPS_MODULATE2X                 0x00000010L
#define D3DTEXOPCAPS_MODULATE4X                 0x00000020L
#define D3DTEXOPCAPS_ADD                        0x00000040L
#define D3DTEXOPCAPS_ADDSIGNED                  0x00000080L
#define D3DTEXOPCAPS_ADDSIGNED2X                0x00000100L
#define D3DTEXOPCAPS_SUBTRACT                   0x00000200L
#define D3DTEXOPCAPS_ADDSMOOTH                  0x00000400L
#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA          0x00000800L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHA          0x00001000L
#define D3DTEXOPCAPS_BLENDFACTORALPHA           0x00002000L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        0x00004000L
#define D3DTEXOPCAPS_BLENDCURRENTALPHA          0x00008000L
#define D3DTEXOPCAPS_PREMODULATE                0x00010000L
#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     0x00020000L
#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     0x00040000L
#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  0x00080000L
#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  0x00100000L
#define D3DTEXOPCAPS_BUMPENVMAP                 0x00200000L
#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        0x00400000L
#define D3DTEXOPCAPS_DOTPRODUCT3                0x00800000L


/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 */
typedef struct _D3DDeviceDesc {
    DWORD            dwSize;                 /* Size of D3DDEVICEDESC structure */
    DWORD            dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;          /* Color model of device */
    DWORD            dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL             bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD            dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD            dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD            dwMaxVertexCount;       /* Maximum vertex count */
#if(DIRECT3D_VERSION >= 0x0500)
    // *** New fields for DX5 *** //

    // Width and height caps are 0 for legacy HALs.
    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
    // New fields for DX6
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;

    // Guard band that the rasterizer can accommodate
    // Screen-space vertices inside this space but outside the viewport
    // will get clipped properly.
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;

    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;

    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

#endif /* DIRECT3D_VERSION >= 0x0600 */
} D3DDEVICEDESC, *LPD3DDEVICEDESC;

#define D3DDEVICEDESCSIZE (sizeof(D3DDEVICEDESC))

typedef HRESULT (FAR PASCAL * LPD3DENUMDEVICESCALLBACK)(GUID FAR *lpGuid, LPSTR lpDeviceDescription, LPSTR lpDeviceName, LPD3DDEVICEDESC, LPD3DDEVICEDESC, LPVOID);

/* D3DDEVICEDESC dwFlags indicating valid fields */

#define D3DDD_COLORMODEL            0x00000001L /* dcmColorModel is valid */
#define D3DDD_DEVCAPS               0x00000002L /* dwDevCaps is valid */
#define D3DDD_TRANSFORMCAPS         0x00000004L /* dtcTransformCaps is valid */
#define D3DDD_LIGHTINGCAPS          0x00000008L /* dlcLightingCaps is valid */
#define D3DDD_BCLIPPING             0x00000010L /* bClipping is valid */
#define D3DDD_LINECAPS              0x00000020L /* dpcLineCaps is valid */
#define D3DDD_TRICAPS               0x00000040L /* dpcTriCaps is valid */
#define D3DDD_DEVICERENDERBITDEPTH  0x00000080L /* dwDeviceRenderBitDepth is valid */
#define D3DDD_DEVICEZBUFFERBITDEPTH 0x00000100L /* dwDeviceZBufferBitDepth is valid */
#define D3DDD_MAXBUFFERSIZE         0x00000200L /* dwMaxBufferSize is valid */
#define D3DDD_MAXVERTEXCOUNT        0x00000400L /* dwMaxVertexCount is valid */

/* D3DDEVICEDESC dwDevCaps flags */

#define D3DDEVCAPS_FLOATTLVERTEX        0x00000001L /* Device accepts floating point */
                                                    /* for post-transform vertex data */
#define D3DDEVCAPS_SORTINCREASINGZ      0x00000002L /* Device needs data sorted for increasing Z */
#define D3DDEVCAPS_SORTDECREASINGZ      0X00000004L /* Device needs data sorted for decreasing Z */
#define D3DDEVCAPS_SORTEXACT            0x00000008L /* Device needs data sorted exactly */

#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */
#define D3DDEVCAPS_DRAWPRIMTLVERTEX     0x00000400L /* Device can draw TLVERTEX primitives */
#define D3DDEVCAPS_CANRENDERAFTERFLIP   0x00000800L /* Device can render without waiting for flip to complete */
#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM 0x00001000L /* Device can texture from nonlocal video memory */

#define D3DFDS_COLORMODEL        0x00000001L /* Match color model */
#define D3DFDS_GUID              0x00000002L /* Match guid */
#define D3DFDS_HARDWARE          0x00000004L /* Match hardware/software */
#define D3DFDS_TRIANGLES         0x00000008L /* Match in triCaps */
#define D3DFDS_LINES             0x00000010L /* Match in lineCaps  */
#define D3DFDS_MISCCAPS          0x00000020L /* Match primCaps.dwMiscCaps */
#define D3DFDS_RASTERCAPS        0x00000040L /* Match primCaps.dwRasterCaps */
#define D3DFDS_ZCMPCAPS          0x00000080L /* Match primCaps.dwZCmpCaps */
#define D3DFDS_ALPHACMPCAPS      0x00000100L /* Match primCaps.dwAlphaCmpCaps */
#define D3DFDS_SRCBLENDCAPS      0x00000200L /* Match primCaps.dwSourceBlendCaps */
#define D3DFDS_DSTBLENDCAPS      0x00000400L /* Match primCaps.dwDestBlendCaps */
#define D3DFDS_SHADECAPS         0x00000800L /* Match primCaps.dwShadeCaps */
#define D3DFDS_TEXTURECAPS       0x00001000L /* Match primCaps.dwTextureCaps */
#define D3DFDS_TEXTUREFILTERCAPS 0x00002000L /* Match primCaps.dwTextureFilterCaps */
#define D3DFDS_TEXTUREBLENDCAPS  0x00004000L /* Match primCaps.dwTextureBlendCaps */
#define D3DFDS_TEXTUREADDRESSCAPS  0x00008000L /* Match primCaps.dwTextureBlendCaps */

/*
 * FindDevice arguments
 */
typedef struct _D3DFINDDEVICESEARCH {
    DWORD               dwSize;
    DWORD               dwFlags;
    BOOL                bHardware;
    D3DCOLORMODEL       dcmColorModel;
    GUID                guid;
    DWORD               dwCaps;
    D3DPRIMCAPS         dpcPrimCaps;
} D3DFINDDEVICESEARCH, *LPD3DFINDDEVICESEARCH;

typedef struct _D3DFINDDEVICERESULT {
    DWORD               dwSize;
    GUID                guid;           /* guid which matched */
    D3DDEVICEDESC       ddHwDesc;       /* hardware D3DDEVICEDESC */
    D3DDEVICEDESC       ddSwDesc;       /* software D3DDEVICEDESC */
} D3DFINDDEVICERESULT, *LPD3DFINDDEVICERESULT;

/*
 * Description of execute buffer.
 */
typedef struct _D3DExecuteBufferDesc {
    DWORD               dwSize;         /* size of this structure */
    DWORD               dwFlags;        /* flags indicating which fields are valid */
    DWORD               dwCaps;         /* capabilities of execute buffer */
    DWORD               dwBufferSize;   /* size of execute buffer data */
    LPVOID              lpData;         /* pointer to actual data */
} D3DEXECUTEBUFFERDESC, *LPD3DEXECUTEBUFFERDESC;

/* D3DEXECUTEBUFFER dwFlags indicating valid fields */

#define D3DDEB_BUFSIZE          0x00000001l     /* buffer size valid */
#define D3DDEB_CAPS             0x00000002l     /* caps valid */
#define D3DDEB_LPDATA           0x00000004l     /* lpData valid */

/* D3DEXECUTEBUFFER dwCaps */

#define D3DDEBCAPS_SYSTEMMEMORY 0x00000001l     /* buffer in system memory */
#define D3DDEBCAPS_VIDEOMEMORY  0x00000002l     /* buffer in device memory */
#define D3DDEBCAPS_MEM (D3DDEBCAPS_SYSTEMMEMORY|D3DDEBCAPS_VIDEOMEMORY)

#pragma pack()

#endif /* _D3DCAPS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\dwininfo.h ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	wndinfo.h
 *  Content:	Direct Draw window information structure
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   08-jul-95	craige	initial implementation
 *   18-jul-95	craige	keep track of dsound/ddraw hooks with flags
 *   13-aug-95  toddla  added WININFO_ACTIVELIE
 *   09-sep-95  toddla  added WININFO_INACTIVATEAPP
 *   17-may-96  colinmc Bug 23029: Removed WININFO_WASICONIC
 *
 ***************************************************************************/

#ifndef __WNDINFO_INCLUDED__
#define __WNDINFO_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WINDOWINFO
{
    DWORD                       dwSmag;
    struct _WINDOWINFO		*lpLink;
    WNDPROC			lpDSoundCallback;
    HWND			hWnd;
    WNDPROC			lpWndProc;
    DWORD			dwPid;
    DWORD			dwFlags;
    struct
    {
	LPDDRAWI_DIRECTDRAW_LCL	lpDD_lcl;
	DWORD			dwDDFlags;
    } DDInfo;
} WINDOWINFO, *LPWINDOWINFO;

#define WININFO_MAGIC                   0x42954295l
#define WININFO_DDRAWHOOKED		0x00000001l
#define WININFO_DSOUNDHOOKED		0x00000002l
#define WININFO_ZOMBIE                  0x00000008l
#define WININFO_UNHOOK                  0x00000010l
#define WININFO_IGNORENEXTALTTAB	0x00000020l
#define WININFO_SELFSIZE                0x00000040l
#define WININFO_INACTIVATEAPP           0x00000080l

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\dmemmgr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dmemmgr.h
 *  Content:	Direct Memory Manager include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   10-jun-95	craige	initial implementation
 *   18-jun-95	craige	pitch in VidMemInit
 *   17-jul-95	craige	added VidMemLargestFree
 *   29-nov-95  colinmc added VidMemAmountAllocated
 *@@END_MSINTERNAL
 ***************************************************************************/

#ifndef __DMEMMGR_INCLUDED__
#define __DMEMMGR_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

/*
 * pointer to video meory
 */
typedef unsigned long	FLATPTR;

/*
 * video memory manager structures
 */
typedef struct _VMEML
{
    struct _VMEML 	FAR *next;
    FLATPTR		ptr;
    DWORD		size;
} VMEML, FAR *LPVMEML, FAR * FAR *LPLPVMEML;

typedef struct _VMEMR
{
    struct _VMEMR 	FAR *next;
    struct _VMEMR       FAR *prev;
    struct _VMEMR 	FAR *pUp;
    struct _VMEMR 	FAR *pDown;
    struct _VMEMR 	FAR *pLeft;
    struct _VMEMR 	FAR *pRight;
    FLATPTR		ptr;
    DWORD		size;
    DWORD               x;
    DWORD               y;
    DWORD               cx;
    DWORD               cy;
    DWORD		flags;
} VMEMR, FAR *LPVMEMR, FAR * FAR *LPLPVMEMR;

#ifdef NT_KERNEL_HEAPS
typedef void VMEMHEAP;
#else
typedef struct _VMEMHEAP
{
    DWORD		dwFlags;
    DWORD               stride;
    LPVOID		freeList;
    LPVOID		allocList;
} VMEMHEAP;
#endif

typedef VMEMHEAP FAR *LPVMEMHEAP;

#define VMEMHEAP_LINEAR			0x00000001l
#define VMEMHEAP_RECTANGULAR		0x00000002l

extern FLATPTR	WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD width, DWORD height );
extern void WINAPI VidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

//@@BEGIN_MSINTERNAL
extern LPVMEMHEAP WINAPI VidMemInit( DWORD flags, FLATPTR start, FLATPTR end_or_width, DWORD height, DWORD pitch );
extern void WINAPI VidMemFini( LPVMEMHEAP pvmh );
extern DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh );
extern DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh );
extern DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh );
extern void WINAPI VidMemGetRectStride( LPVMEMHEAP pvmh, LPLONG newstride );
//@@END_MSINTERNAL

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\d3d.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3d.h
 *  Content:    Direct3D include file
 *
 ****************************************************************************/

#ifndef _D3D_H_
#define _D3D_H_


#include <stdlib.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#define D3DAPI WINAPI

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0600
#endif

/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)
DEFINE_GUID( IID_IDirect3D,             0x3BBA0080,0x2421,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3D2,            0x6aae1ec1,0x662a,0x11d0,0x88,0x9d,0x00,0xaa,0x00,0xbb,0xb7,0x6a);
DEFINE_GUID( IID_IDirect3D3,            0xbb223240,0xe72b,0x11d0,0xa9,0xb4,0x00,0xaa,0x00,0xc0,0x99,0x3e);

DEFINE_GUID( IID_IDirect3DRampDevice,   0xF2086B20,0x259F,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DRGBDevice,    0xA4665C60,0x2673,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DHALDevice,    0x84E63dE0,0x46AA,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMMXDevice,    0x881949a1,0xd6f3,0x11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );

DEFINE_GUID( IID_IDirect3DRefDevice,    0x50936643, 0x13e9, 0x11d1, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DNullDevice, 0x8767df22, 0xbacc, 0x11d1, 0x89, 0x69, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);

DEFINE_GUID( IID_IDirect3DDevice,       0x64108800,0x957d,0X11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
DEFINE_GUID( IID_IDirect3DDevice2,  0x93281501, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DDevice3,  0xb0ab3b60, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);

DEFINE_GUID( IID_IDirect3DTexture,      0x2CDCD9E0,0x25A0,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DTexture2, 0x93281502, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DLight,        0x4417C142,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMaterial,     0x4417C144,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMaterial2,    0x93281503, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DMaterial3,    0xca9c46f4, 0xd3c5, 0x11d1, 0xb7, 0x5a, 0x0, 0x60, 0x8, 0x52, 0xb3, 0x12);
DEFINE_GUID( IID_IDirect3DExecuteBuffer,0x4417C145,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport,     0x4417C146,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport2,    0x93281500, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DViewport3,    0xb0ab3b61, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
DEFINE_GUID( IID_IDirect3DVertexBuffer, 0x7a503555, 0x4a83, 0x11d1, 0xa5, 0xdb, 0x0, 0xa0, 0xc9, 0x3, 0x67, 0xf8);
#endif

#ifdef __cplusplus
struct IDirect3D;
struct IDirect3D2;
struct IDirect3D3;
struct IDirect3DDevice;
struct IDirect3DDevice2;
struct IDirect3DDevice3;
struct IDirect3DExecuteBuffer;
struct IDirect3DLight;
struct IDirect3DMaterial;
struct IDirect3DMaterial2;
struct IDirect3DTexture;
struct IDirect3DTexture2;
struct IDirect3DViewport;
struct IDirect3DViewport2;
struct IDirect3DViewport3;
struct IDirect3DVertexBuffer;
typedef struct IDirect3D        *LPDIRECT3D;
typedef struct IDirect3D2       *LPDIRECT3D2;
typedef struct IDirect3D3       *LPDIRECT3D3;
typedef struct IDirect3DDevice      *LPDIRECT3DDEVICE;
typedef struct IDirect3DDevice2     *LPDIRECT3DDEVICE2;
typedef struct IDirect3DDevice3     *LPDIRECT3DDEVICE3;
typedef struct IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef struct IDirect3DLight       *LPDIRECT3DLIGHT;
typedef struct IDirect3DMaterial    *LPDIRECT3DMATERIAL;
typedef struct IDirect3DMaterial2   *LPDIRECT3DMATERIAL2;
typedef struct IDirect3DMaterial3   *LPDIRECT3DMATERIAL3;
typedef struct IDirect3DTexture     *LPDIRECT3DTEXTURE;
typedef struct IDirect3DTexture2        *LPDIRECT3DTEXTURE2;
typedef struct IDirect3DViewport    *LPDIRECT3DVIEWPORT;
typedef struct IDirect3DViewport2   *LPDIRECT3DVIEWPORT2;
typedef struct IDirect3DViewport3   *LPDIRECT3DVIEWPORT3;
typedef struct IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;

#else

typedef struct IDirect3D        *LPDIRECT3D;
typedef struct IDirect3D2       *LPDIRECT3D2;
typedef struct IDirect3D3       *LPDIRECT3D3;
typedef struct IDirect3DDevice      *LPDIRECT3DDEVICE;
typedef struct IDirect3DDevice2     *LPDIRECT3DDEVICE2;
typedef struct IDirect3DDevice3     *LPDIRECT3DDEVICE3;
typedef struct IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef struct IDirect3DLight       *LPDIRECT3DLIGHT;
typedef struct IDirect3DMaterial    *LPDIRECT3DMATERIAL;
typedef struct IDirect3DMaterial2   *LPDIRECT3DMATERIAL2;
typedef struct IDirect3DMaterial3   *LPDIRECT3DMATERIAL3;
typedef struct IDirect3DTexture     *LPDIRECT3DTEXTURE;
typedef struct IDirect3DTexture2        *LPDIRECT3DTEXTURE2;
typedef struct IDirect3DViewport    *LPDIRECT3DVIEWPORT;
typedef struct IDirect3DViewport2   *LPDIRECT3DVIEWPORT2;
typedef struct IDirect3DViewport3   *LPDIRECT3DVIEWPORT3;
typedef struct IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;

#endif

#include "d3dtypes.h"
#include "d3dcaps.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Direct3D interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3D

DECLARE_INTERFACE_(IDirect3D, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D methods ***/
    STDMETHOD(Initialize)(THIS_ REFCLSID) PURE;
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateLight)(THIS_ LPDIRECT3DLIGHT*,IUnknown*) PURE;
    STDMETHOD(CreateMaterial)(THIS_ LPDIRECT3DMATERIAL*,IUnknown*) PURE;
    STDMETHOD(CreateViewport)(THIS_ LPDIRECT3DVIEWPORT*,IUnknown*) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH,LPD3DFINDDEVICERESULT) PURE;
};

typedef struct IDirect3D *LPDIRECT3D;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3D_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D_CreateLight(p,a,b) (p)->lpVtbl->CreateLight(p,a,b)
#define IDirect3D_CreateMaterial(p,a,b) (p)->lpVtbl->CreateMaterial(p,a,b)
#define IDirect3D_CreateViewport(p,a,b) (p)->lpVtbl->CreateViewport(p,a,b)
#define IDirect3D_FindDevice(p,a,b) (p)->lpVtbl->FindDevice(p,a,b)
#else
#define IDirect3D_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D_AddRef(p) (p)->AddRef()
#define IDirect3D_Release(p) (p)->Release()
#define IDirect3D_Initialize(p,a) (p)->Initialize(a)
#define IDirect3D_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D_CreateLight(p,a,b) (p)->CreateLight(a,b)
#define IDirect3D_CreateMaterial(p,a,b) (p)->CreateMaterial(a,b)
#define IDirect3D_CreateViewport(p,a,b) (p)->CreateViewport(a,b)
#define IDirect3D_FindDevice(p,a,b) (p)->FindDevice(a,b)
#endif

#undef INTERFACE
#define INTERFACE IDirect3D2

DECLARE_INTERFACE_(IDirect3D2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D2 methods ***/
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateLight)(THIS_ LPDIRECT3DLIGHT*,IUnknown*) PURE;
    STDMETHOD(CreateMaterial)(THIS_ LPDIRECT3DMATERIAL2*,IUnknown*) PURE;
    STDMETHOD(CreateViewport)(THIS_ LPDIRECT3DVIEWPORT2*,IUnknown*) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH,LPD3DFINDDEVICERESULT) PURE;
    STDMETHOD(CreateDevice)(THIS_ REFCLSID,LPDIRECTDRAWSURFACE,LPDIRECT3DDEVICE2*) PURE;
};

typedef struct IDirect3D2 *LPDIRECT3D2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D2_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D2_CreateLight(p,a,b) (p)->lpVtbl->CreateLight(p,a,b)
#define IDirect3D2_CreateMaterial(p,a,b) (p)->lpVtbl->CreateMaterial(p,a,b)
#define IDirect3D2_CreateViewport(p,a,b) (p)->lpVtbl->CreateViewport(p,a,b)
#define IDirect3D2_FindDevice(p,a,b) (p)->lpVtbl->FindDevice(p,a,b)
#define IDirect3D2_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#else
#define IDirect3D2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D2_AddRef(p) (p)->AddRef()
#define IDirect3D2_Release(p) (p)->Release()
#define IDirect3D2_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D2_CreateLight(p,a,b) (p)->CreateLight(a,b)
#define IDirect3D2_CreateMaterial(p,a,b) (p)->CreateMaterial(a,b)
#define IDirect3D2_CreateViewport(p,a,b) (p)->CreateViewport(a,b)
#define IDirect3D2_FindDevice(p,a,b) (p)->FindDevice(a,b)
#define IDirect3D2_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#endif

#undef INTERFACE
#define INTERFACE IDirect3D3

DECLARE_INTERFACE_(IDirect3D3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D3 methods ***/
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateLight)(THIS_ LPDIRECT3DLIGHT*,LPUNKNOWN) PURE;
    STDMETHOD(CreateMaterial)(THIS_ LPDIRECT3DMATERIAL3*,LPUNKNOWN) PURE;
    STDMETHOD(CreateViewport)(THIS_ LPDIRECT3DVIEWPORT3*,LPUNKNOWN) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH,LPD3DFINDDEVICERESULT) PURE;
    STDMETHOD(CreateDevice)(THIS_ REFCLSID,LPDIRECTDRAWSURFACE4,LPDIRECT3DDEVICE3*,LPUNKNOWN) PURE;
    STDMETHOD(CreateVertexBuffer)(THIS_ LPD3DVERTEXBUFFERDESC,LPDIRECT3DVERTEXBUFFER*,DWORD,LPUNKNOWN) PURE;
    STDMETHOD(EnumZBufferFormats)(THIS_ REFCLSID,LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(EvictManagedTextures)(THIS) PURE;
};

typedef struct IDirect3D3 *LPDIRECT3D3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D3_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D3_CreateLight(p,a,b) (p)->lpVtbl->CreateLight(p,a,b)
#define IDirect3D3_CreateMaterial(p,a,b) (p)->lpVtbl->CreateMaterial(p,a,b)
#define IDirect3D3_CreateViewport(p,a,b) (p)->lpVtbl->CreateViewport(p,a,b)
#define IDirect3D3_FindDevice(p,a,b) (p)->lpVtbl->FindDevice(p,a,b)
#define IDirect3D3_CreateDevice(p,a,b,c,d) (p)->lpVtbl->CreateDevice(p,a,b,c,d)
#define IDirect3D3_CreateVertexBuffer(p,a,b,c,d) (p)->lpVtbl->CreateVertexBuffer(p,a,b,c,d)
#define IDirect3D3_EnumZBufferFormats(p,a,b,c) (p)->lpVtbl->EnumZBufferFormats(p,a,b,c)
#define IDirect3D3_EvictManagedTextures(p) (p)->lpVtbl->EvictManagedTextures(p)
#else
#define IDirect3D3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D3_AddRef(p) (p)->AddRef()
#define IDirect3D3_Release(p) (p)->Release()
#define IDirect3D3_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D3_CreateLight(p,a,b) (p)->CreateLight(a,b)
#define IDirect3D3_CreateMaterial(p,a,b) (p)->CreateMaterial(a,b)
#define IDirect3D3_CreateViewport(p,a,b) (p)->CreateViewport(a,b)
#define IDirect3D3_FindDevice(p,a,b) (p)->FindDevice(a,b)
#define IDirect3D3_CreateDevice(p,a,b,c,d) (p)->CreateDevice(a,b,c,d)
#define IDirect3D3_CreateVertexBuffer(p,a,b,c,d) (p)->CreateVertexBuffer(a,b,c,d)
#define IDirect3D3_EnumZBufferFormats(p,a,b,c) (p)->EnumZBufferFormats(a,b,c)
#define IDirect3D3_EvictManagedTextures(p) (p)->EvictManagedTextures()
#endif

/*
 * Direct3D Device interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DDevice

DECLARE_INTERFACE_(IDirect3DDevice, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D,LPGUID,LPD3DDEVICEDESC) PURE;
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC,LPD3DDEVICEDESC) PURE;
    STDMETHOD(SwapTextureHandles)(THIS_ LPDIRECT3DTEXTURE,LPDIRECT3DTEXTURE) PURE;
    STDMETHOD(CreateExecuteBuffer)(THIS_ LPD3DEXECUTEBUFFERDESC,LPDIRECT3DEXECUTEBUFFER*,IUnknown*) PURE;
    STDMETHOD(GetStats)(THIS_ LPD3DSTATS) PURE;
    STDMETHOD(Execute)(THIS_ LPDIRECT3DEXECUTEBUFFER,LPDIRECT3DVIEWPORT,DWORD) PURE;
    STDMETHOD(AddViewport)(THIS_ LPDIRECT3DVIEWPORT) PURE;
    STDMETHOD(DeleteViewport)(THIS_ LPDIRECT3DVIEWPORT) PURE;
    STDMETHOD(NextViewport)(THIS_ LPDIRECT3DVIEWPORT,LPDIRECT3DVIEWPORT*,DWORD) PURE;
    STDMETHOD(Pick)(THIS_ LPDIRECT3DEXECUTEBUFFER,LPDIRECT3DVIEWPORT,DWORD,LPD3DRECT) PURE;
    STDMETHOD(GetPickRecords)(THIS_ LPDWORD,LPD3DPICKRECORD) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMTEXTUREFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateMatrix)(THIS_ LPD3DMATRIXHANDLE) PURE;
    STDMETHOD(SetMatrix)(THIS_ D3DMATRIXHANDLE,const LPD3DMATRIX) PURE;
    STDMETHOD(GetMatrix)(THIS_ D3DMATRIXHANDLE,LPD3DMATRIX) PURE;
    STDMETHOD(DeleteMatrix)(THIS_ D3DMATRIXHANDLE) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D*) PURE;
};

typedef struct IDirect3DDevice *LPDIRECT3DDEVICE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirect3DDevice_GetCaps(p,a,b) (p)->lpVtbl->GetCaps(p,a,b)
#define IDirect3DDevice_SwapTextureHandles(p,a,b) (p)->lpVtbl->SwapTextureHandles(p,a,b)
#define IDirect3DDevice_CreateExecuteBuffer(p,a,b,c) (p)->lpVtbl->CreateExecuteBuffer(p,a,b,c)
#define IDirect3DDevice_GetStats(p,a) (p)->lpVtbl->GetStats(p,a)
#define IDirect3DDevice_Execute(p,a,b,c) (p)->lpVtbl->Execute(p,a,b,c)
#define IDirect3DDevice_AddViewport(p,a) (p)->lpVtbl->AddViewport(p,a)
#define IDirect3DDevice_DeleteViewport(p,a) (p)->lpVtbl->DeleteViewport(p,a)
#define IDirect3DDevice_NextViewport(p,a,b,c) (p)->lpVtbl->NextViewport(p,a,b,c)
#define IDirect3DDevice_Pick(p,a,b,c,d) (p)->lpVtbl->Pick(p,a,b,c,d)
#define IDirect3DDevice_GetPickRecords(p,a,b) (p)->lpVtbl->GetPickRecords(p,a,b)
#define IDirect3DDevice_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice_CreateMatrix(p,a) (p)->lpVtbl->CreateMatrix(p,a)
#define IDirect3DDevice_SetMatrix(p,a,b) (p)->lpVtbl->SetMatrix(p,a,b)
#define IDirect3DDevice_GetMatrix(p,a,b) (p)->lpVtbl->GetMatrix(p,a,b)
#define IDirect3DDevice_DeleteMatrix(p,a) (p)->lpVtbl->DeleteMatrix(p,a)
#define IDirect3DDevice_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#else
#define IDirect3DDevice_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice_AddRef(p) (p)->AddRef()
#define IDirect3DDevice_Release(p) (p)->Release()
#define IDirect3DDevice_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirect3DDevice_GetCaps(p,a,b) (p)->GetCaps(a,b)
#define IDirect3DDevice_SwapTextureHandles(p,a,b) (p)->SwapTextureHandles(a,b)
#define IDirect3DDevice_CreateExecuteBuffer(p,a,b,c) (p)->CreateExecuteBuffer(a,b,c)
#define IDirect3DDevice_GetStats(p,a) (p)->GetStats(a)
#define IDirect3DDevice_Execute(p,a,b,c) (p)->Execute(a,b,c)
#define IDirect3DDevice_AddViewport(p,a) (p)->AddViewport(a)
#define IDirect3DDevice_DeleteViewport(p,a) (p)->DeleteViewport(a)
#define IDirect3DDevice_NextViewport(p,a,b,c) (p)->NextViewport(a,b,c)
#define IDirect3DDevice_Pick(p,a,b,c,d) (p)->Pick(a,b,c,d)
#define IDirect3DDevice_GetPickRecords(p,a,b) (p)->GetPickRecords(a,b)
#define IDirect3DDevice_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice_CreateMatrix(p,a) (p)->CreateMatrix(a)
#define IDirect3DDevice_SetMatrix(p,a,b) (p)->SetMatrix(a,b)
#define IDirect3DDevice_GetMatrix(p,a,b) (p)->GetMatrix(a,b)
#define IDirect3DDevice_DeleteMatrix(p,a) (p)->DeleteMatrix(a)
#define IDirect3DDevice_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice_EndScene(p) (p)->EndScene()
#define IDirect3DDevice_GetDirect3D(p,a) (p)->GetDirect3D(a)
#endif

#undef INTERFACE
#define INTERFACE IDirect3DDevice2

DECLARE_INTERFACE_(IDirect3DDevice2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice2 methods ***/
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC,LPD3DDEVICEDESC) PURE;
    STDMETHOD(SwapTextureHandles)(THIS_ LPDIRECT3DTEXTURE2,LPDIRECT3DTEXTURE2) PURE;
    STDMETHOD(GetStats)(THIS_ LPD3DSTATS) PURE;
    STDMETHOD(AddViewport)(THIS_ LPDIRECT3DVIEWPORT2) PURE;
    STDMETHOD(DeleteViewport)(THIS_ LPDIRECT3DVIEWPORT2) PURE;
    STDMETHOD(NextViewport)(THIS_ LPDIRECT3DVIEWPORT2,LPDIRECT3DVIEWPORT2*,DWORD) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMTEXTUREFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D2*) PURE;
    STDMETHOD(SetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT2) PURE;
    STDMETHOD(GetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT2 *) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE,DWORD) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD(Begin)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,DWORD) PURE;
    STDMETHOD(BeginIndexed)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(Vertex)(THIS_ LPVOID) PURE;
    STDMETHOD(Index)(THIS_ WORD) PURE;
    STDMETHOD(End)(THIS_ DWORD) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE,DWORD) PURE;
    STDMETHOD(GetLightState)(THIS_ D3DLIGHTSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetLightState)(THIS_ D3DLIGHTSTATETYPE,DWORD) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,LPVOID,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(SetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(GetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
};

typedef struct IDirect3DDevice2 *LPDIRECT3DDEVICE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice2_GetCaps(p,a,b) (p)->lpVtbl->GetCaps(p,a,b)
#define IDirect3DDevice2_SwapTextureHandles(p,a,b) (p)->lpVtbl->SwapTextureHandles(p,a,b)
#define IDirect3DDevice2_GetStats(p,a) (p)->lpVtbl->GetStats(p,a)
#define IDirect3DDevice2_AddViewport(p,a) (p)->lpVtbl->AddViewport(p,a)
#define IDirect3DDevice2_DeleteViewport(p,a) (p)->lpVtbl->DeleteViewport(p,a)
#define IDirect3DDevice2_NextViewport(p,a,b,c) (p)->lpVtbl->NextViewport(p,a,b,c)
#define IDirect3DDevice2_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice2_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice2_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice2_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice2_SetCurrentViewport(p,a) (p)->lpVtbl->SetCurrentViewport(p,a)
#define IDirect3DDevice2_GetCurrentViewport(p,a) (p)->lpVtbl->GetCurrentViewport(p,a)
#define IDirect3DDevice2_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice2_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice2_Begin(p,a,b,c) (p)->lpVtbl->Begin(p,a,b,c)
#define IDirect3DDevice2_BeginIndexed(p,a,b,c,d,e) (p)->lpVtbl->BeginIndexed(p,a,b,c,d,e)
#define IDirect3DDevice2_Vertex(p,a) (p)->lpVtbl->Vertex(p,a)
#define IDirect3DDevice2_Index(p,a) (p)->lpVtbl->Index(p,a)
#define IDirect3DDevice2_End(p,a) (p)->lpVtbl->End(p,a)
#define IDirect3DDevice2_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice2_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice2_GetLightState(p,a,b) (p)->lpVtbl->GetLightState(p,a,b)
#define IDirect3DDevice2_SetLightState(p,a,b) (p)->lpVtbl->SetLightState(p,a,b)
#define IDirect3DDevice2_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice2_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice2_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice2_DrawPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice2_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e,f,g)
#define IDirect3DDevice2_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice2_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#else
#define IDirect3DDevice2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice2_AddRef(p) (p)->AddRef()
#define IDirect3DDevice2_Release(p) (p)->Release()
#define IDirect3DDevice2_GetCaps(p,a,b) (p)->GetCaps(a,b)
#define IDirect3DDevice2_SwapTextureHandles(p,a,b) (p)->SwapTextureHandles(a,b)
#define IDirect3DDevice2_GetStats(p,a) (p)->GetStats(a)
#define IDirect3DDevice2_AddViewport(p,a) (p)->AddViewport(a)
#define IDirect3DDevice2_DeleteViewport(p,a) (p)->DeleteViewport(a)
#define IDirect3DDevice2_NextViewport(p,a,b,c) (p)->NextViewport(a,b,c)
#define IDirect3DDevice2_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice2_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice2_EndScene(p) (p)->EndScene()
#define IDirect3DDevice2_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice2_SetCurrentViewport(p,a) (p)->SetCurrentViewport(a)
#define IDirect3DDevice2_GetCurrentViewport(p,a) (p)->GetCurrentViewport(a)
#define IDirect3DDevice2_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice2_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice2_Begin(p,a,b,c) (p)->Begin(a,b,c)
#define IDirect3DDevice2_BeginIndexed(p,a,b,c,d,e) (p)->BeginIndexed(a,b,c,d,e)
#define IDirect3DDevice2_Vertex(p,a) (p)->Vertex(a)
#define IDirect3DDevice2_Index(p,a) (p)->Index(a)
#define IDirect3DDevice2_End(p,a) (p)->End(a)
#define IDirect3DDevice2_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice2_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice2_GetLightState(p,a,b) (p)->GetLightState(a,b)
#define IDirect3DDevice2_SetLightState(p,a,b) (p)->SetLightState(a,b)
#define IDirect3DDevice2_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice2_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice2_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice2_DrawPrimitive(p,a,b,c,d,e) (p)->DrawPrimitive(a,b,c,d,e)
#define IDirect3DDevice2_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitive(a,b,c,d,e,f,g)
#define IDirect3DDevice2_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice2_GetClipStatus(p,a) (p)->GetClipStatus(a)
#endif

#undef INTERFACE
#define INTERFACE IDirect3DDevice3

DECLARE_INTERFACE_(IDirect3DDevice3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice3 methods ***/
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC,LPD3DDEVICEDESC) PURE;
    STDMETHOD(GetStats)(THIS_ LPD3DSTATS) PURE;
    STDMETHOD(AddViewport)(THIS_ LPDIRECT3DVIEWPORT3) PURE;
    STDMETHOD(DeleteViewport)(THIS_ LPDIRECT3DVIEWPORT3) PURE;
    STDMETHOD(NextViewport)(THIS_ LPDIRECT3DVIEWPORT3,LPDIRECT3DVIEWPORT3*,DWORD) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D3*) PURE;
    STDMETHOD(SetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT3) PURE;
    STDMETHOD(GetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT3 *) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE4,DWORD) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE4 *) PURE;
    STDMETHOD(Begin)(THIS_ D3DPRIMITIVETYPE,DWORD,DWORD) PURE;
    STDMETHOD(BeginIndexed)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(Vertex)(THIS_ LPVOID) PURE;
    STDMETHOD(Index)(THIS_ WORD) PURE;
    STDMETHOD(End)(THIS_ DWORD) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE,DWORD) PURE;
    STDMETHOD(GetLightState)(THIS_ D3DLIGHTSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetLightState)(THIS_ D3DLIGHTSTATETYPE,DWORD) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(SetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(GetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(DrawPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER,DWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(ComputeSphereVisibility)(THIS_ LPD3DVECTOR,LPD3DVALUE,DWORD,DWORD,LPDWORD) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD,LPDIRECT3DTEXTURE2 *) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD,LPDIRECT3DTEXTURE2) PURE;
    STDMETHOD(GetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,DWORD) PURE;
    STDMETHOD(ValidateDevice)(THIS_ LPDWORD) PURE;
};

typedef struct IDirect3DDevice3 *LPDIRECT3DDEVICE3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice3_GetCaps(p,a,b) (p)->lpVtbl->GetCaps(p,a,b)
#define IDirect3DDevice3_GetStats(p,a) (p)->lpVtbl->GetStats(p,a)
#define IDirect3DDevice3_AddViewport(p,a) (p)->lpVtbl->AddViewport(p,a)
#define IDirect3DDevice3_DeleteViewport(p,a) (p)->lpVtbl->DeleteViewport(p,a)
#define IDirect3DDevice3_NextViewport(p,a,b,c) (p)->lpVtbl->NextViewport(p,a,b,c)
#define IDirect3DDevice3_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice3_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice3_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice3_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice3_SetCurrentViewport(p,a) (p)->lpVtbl->SetCurrentViewport(p,a)
#define IDirect3DDevice3_GetCurrentViewport(p,a) (p)->lpVtbl->GetCurrentViewport(p,a)
#define IDirect3DDevice3_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice3_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice3_Begin(p,a,b,c) (p)->lpVtbl->Begin(p,a,b,c)
#define IDirect3DDevice3_BeginIndexed(p,a,b,c,d,e) (p)->lpVtbl->BeginIndexed(p,a,b,c,d,e)
#define IDirect3DDevice3_Vertex(p,a) (p)->lpVtbl->Vertex(p,a)
#define IDirect3DDevice3_Index(p,a) (p)->lpVtbl->Index(p,a)
#define IDirect3DDevice3_End(p,a) (p)->lpVtbl->End(p,a)
#define IDirect3DDevice3_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice3_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice3_GetLightState(p,a,b) (p)->lpVtbl->GetLightState(p,a,b)
#define IDirect3DDevice3_SetLightState(p,a,b) (p)->lpVtbl->SetLightState(p,a,b)
#define IDirect3DDevice3_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice3_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice3_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice3_DrawPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e,f,g)
#define IDirect3DDevice3_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice3_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#define IDirect3DDevice3_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveStrided(p,a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g)
#define IDirect3DDevice3_DrawPrimitiveVB(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveVB(p,a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveVB(p,a,b,c,d,e) (p)->lpVtbl->DrawIndexedPrimitiveVB(p,a,b,c,d,e)
#define IDirect3DDevice3_ComputeSphereVisibility(p,a,b,c,d,e) (p)->lpVtbl->ComputeSphereVisibility(p,a,b,c,d,e)
#define IDirect3DDevice3_GetTexture(p,a,b) (p)->lpVtbl->GetTexture(p,a,b)
#define IDirect3DDevice3_SetTexture(p,a,b) (p)->lpVtbl->SetTexture(p,a,b)
#define IDirect3DDevice3_GetTextureStageState(p,a,b,c) (p)->lpVtbl->GetTextureStageState(p,a,b,c)
#define IDirect3DDevice3_SetTextureStageState(p,a,b,c) (p)->lpVtbl->SetTextureStageState(p,a,b,c)
#define IDirect3DDevice3_ValidateDevice(p,a) (p)->lpVtbl->ValidateDevice(p,a)
#else
#define IDirect3DDevice3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice3_AddRef(p) (p)->AddRef()
#define IDirect3DDevice3_Release(p) (p)->Release()
#define IDirect3DDevice3_GetCaps(p,a,b) (p)->GetCaps(a,b)
#define IDirect3DDevice3_GetStats(p,a) (p)->GetStats(a)
#define IDirect3DDevice3_AddViewport(p,a) (p)->AddViewport(a)
#define IDirect3DDevice3_DeleteViewport(p,a) (p)->DeleteViewport(a)
#define IDirect3DDevice3_NextViewport(p,a,b,c) (p)->NextViewport(a,b,c)
#define IDirect3DDevice3_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice3_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice3_EndScene(p) (p)->EndScene()
#define IDirect3DDevice3_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice3_SetCurrentViewport(p,a) (p)->SetCurrentViewport(a)
#define IDirect3DDevice3_GetCurrentViewport(p,a) (p)->GetCurrentViewport(a)
#define IDirect3DDevice3_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice3_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice3_Begin(p,a,b,c) (p)->Begin(a,b,c)
#define IDirect3DDevice3_BeginIndexed(p,a,b,c,d,e) (p)->BeginIndexed(a,b,c,d,e)
#define IDirect3DDevice3_Vertex(p,a) (p)->Vertex(a)
#define IDirect3DDevice3_Index(p,a) (p)->Index(a)
#define IDirect3DDevice3_End(p,a) (p)->End(a)
#define IDirect3DDevice3_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice3_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice3_GetLightState(p,a,b) (p)->GetLightState(a,b)
#define IDirect3DDevice3_SetLightState(p,a,b) (p)->SetLightState(a,b)
#define IDirect3DDevice3_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice3_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice3_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice3_DrawPrimitive(p,a,b,c,d,e) (p)->DrawPrimitive(a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitive(a,b,c,d,e,f,g)
#define IDirect3DDevice3_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice3_GetClipStatus(p,a) (p)->GetClipStatus(a)
#define IDirect3DDevice3_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->DrawPrimitiveStrided(a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitiveStrided(a,b,c,d,e,f,g)
#define IDirect3DDevice3_DrawPrimitiveVB(p,a,b,c,d,e) (p)->DrawPrimitiveVB(a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveVB(p,a,b,c,d,e) (p)->DrawIndexedPrimitiveVB(a,b,c,d,e)
#define IDirect3DDevice3_ComputeSphereVisibility(p,a,b,c,d,e) (p)->ComputeSphereVisibility(a,b,c,d,e)
#define IDirect3DDevice3_GetTexture(p,a,b) (p)->GetTexture(a,b)
#define IDirect3DDevice3_SetTexture(p,a,b) (p)->SetTexture(a,b)
#define IDirect3DDevice3_GetTextureStageState(p,a,b,c) (p)->GetTextureStageState(a,b,c)
#define IDirect3DDevice3_SetTextureStageState(p,a,b,c) (p)->SetTextureStageState(a,b,c)
#define IDirect3DDevice3_ValidateDevice(p,a) (p)->ValidateDevice(a)
#endif

/*
 * Execute Buffer interface
 */
#undef INTERFACE
#define INTERFACE IDirect3DExecuteBuffer

DECLARE_INTERFACE_(IDirect3DExecuteBuffer, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DExecuteBuffer methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3DDEVICE,LPD3DEXECUTEBUFFERDESC) PURE;
    STDMETHOD(Lock)(THIS_ LPD3DEXECUTEBUFFERDESC) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(SetExecuteData)(THIS_ LPD3DEXECUTEDATA) PURE;
    STDMETHOD(GetExecuteData)(THIS_ LPD3DEXECUTEDATA) PURE;
    STDMETHOD(Validate)(THIS_ LPDWORD,LPD3DVALIDATECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD) PURE;
};

typedef struct IDirect3DExecuteBuffer *LPDIRECT3DEXECUTEBUFFER;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DExecuteBuffer_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DExecuteBuffer_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DExecuteBuffer_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DExecuteBuffer_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirect3DExecuteBuffer_Lock(p,a) (p)->lpVtbl->Lock(p,a)
#define IDirect3DExecuteBuffer_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DExecuteBuffer_SetExecuteData(p,a) (p)->lpVtbl->SetExecuteData(p,a)
#define IDirect3DExecuteBuffer_GetExecuteData(p,a) (p)->lpVtbl->GetExecuteData(p,a)
#define IDirect3DExecuteBuffer_Validate(p,a,b,c,d) (p)->lpVtbl->Validate(p,a,b,c,d)
#define IDirect3DExecuteBuffer_Optimize(p,a) (p)->lpVtbl->Optimize(p,a)
#else
#define IDirect3DExecuteBuffer_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DExecuteBuffer_AddRef(p) (p)->AddRef()
#define IDirect3DExecuteBuffer_Release(p) (p)->Release()
#define IDirect3DExecuteBuffer_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirect3DExecuteBuffer_Lock(p,a) (p)->Lock(a)
#define IDirect3DExecuteBuffer_Unlock(p) (p)->Unlock()
#define IDirect3DExecuteBuffer_SetExecuteData(p,a) (p)->SetExecuteData(a)
#define IDirect3DExecuteBuffer_GetExecuteData(p,a) (p)->GetExecuteData(a)
#define IDirect3DExecuteBuffer_Validate(p,a,b,c,d) (p)->Validate(a,b,c,d)
#define IDirect3DExecuteBuffer_Optimize(p,a) (p)->Optimize(a)
#endif

/*
 * Light interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DLight

DECLARE_INTERFACE_(IDirect3DLight, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DLight methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(SetLight)(THIS_ LPD3DLIGHT) PURE;
    STDMETHOD(GetLight)(THIS_ LPD3DLIGHT) PURE;
};

typedef struct IDirect3DLight *LPDIRECT3DLIGHT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DLight_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DLight_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DLight_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DLight_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DLight_SetLight(p,a) (p)->lpVtbl->SetLight(p,a)
#define IDirect3DLight_GetLight(p,a) (p)->lpVtbl->GetLight(p,a)
#else
#define IDirect3DLight_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DLight_AddRef(p) (p)->AddRef()
#define IDirect3DLight_Release(p) (p)->Release()
#define IDirect3DLight_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DLight_SetLight(p,a) (p)->SetLight(a)
#define IDirect3DLight_GetLight(p,a) (p)->GetLight(a)
#endif

/*
 * Material interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DMaterial

DECLARE_INTERFACE_(IDirect3DMaterial, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DMaterial methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE,LPD3DMATERIALHANDLE) PURE;
    STDMETHOD(Reserve)(THIS) PURE;
    STDMETHOD(Unreserve)(THIS) PURE;
};

typedef struct IDirect3DMaterial *LPDIRECT3DMATERIAL;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DMaterial_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DMaterial_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DMaterial_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DMaterial_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DMaterial_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#define IDirect3DMaterial_Reserve(p) (p)->lpVtbl->Reserve(p)
#define IDirect3DMaterial_Unreserve(p) (p)->lpVtbl->Unreserve(p)
#else
#define IDirect3DMaterial_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DMaterial_AddRef(p) (p)->AddRef()
#define IDirect3DMaterial_Release(p) (p)->Release()
#define IDirect3DMaterial_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DMaterial_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DMaterial_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DMaterial_GetHandle(p,a,b) (p)->GetHandle(a,b)
#define IDirect3DMaterial_Reserve(p) (p)->Reserve()
#define IDirect3DMaterial_Unreserve(p) (p)->Unreserve()
#endif

#undef INTERFACE
#define INTERFACE IDirect3DMaterial2

DECLARE_INTERFACE_(IDirect3DMaterial2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DMaterial2 methods ***/
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE2,LPD3DMATERIALHANDLE) PURE;
};

typedef struct IDirect3DMaterial2 *LPDIRECT3DMATERIAL2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DMaterial2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DMaterial2_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DMaterial2_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DMaterial2_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#else
#define IDirect3DMaterial2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DMaterial2_AddRef(p) (p)->AddRef()
#define IDirect3DMaterial2_Release(p) (p)->Release()
#define IDirect3DMaterial2_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DMaterial2_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DMaterial2_GetHandle(p,a,b) (p)->GetHandle(a,b)
#endif

#undef INTERFACE
#define INTERFACE IDirect3DMaterial3

DECLARE_INTERFACE_(IDirect3DMaterial3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DMaterial3 methods ***/
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE3,LPD3DMATERIALHANDLE) PURE;
};

typedef struct IDirect3DMaterial3 *LPDIRECT3DMATERIAL3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DMaterial3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DMaterial3_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DMaterial3_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DMaterial3_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#else
#define IDirect3DMaterial3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DMaterial3_AddRef(p) (p)->AddRef()
#define IDirect3DMaterial3_Release(p) (p)->Release()
#define IDirect3DMaterial3_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DMaterial3_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DMaterial3_GetHandle(p,a,b) (p)->GetHandle(a,b)
#endif

/*
 * Texture interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DTexture

DECLARE_INTERFACE_(IDirect3DTexture, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DTexture methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3DDEVICE,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE,LPD3DTEXTUREHANDLE) PURE;
    STDMETHOD(PaletteChanged)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Load)(THIS_ LPDIRECT3DTEXTURE) PURE;
    STDMETHOD(Unload)(THIS) PURE;
};

typedef struct IDirect3DTexture *LPDIRECT3DTEXTURE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DTexture_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DTexture_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirect3DTexture_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#define IDirect3DTexture_PaletteChanged(p,a,b) (p)->lpVtbl->PaletteChanged(p,a,b)
#define IDirect3DTexture_Load(p,a) (p)->lpVtbl->Load(p,a)
#define IDirect3DTexture_Unload(p) (p)->lpVtbl->Unload(p)
#else
#define IDirect3DTexture_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DTexture_AddRef(p) (p)->AddRef()
#define IDirect3DTexture_Release(p) (p)->Release()
#define IDirect3DTexture_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirect3DTexture_GetHandle(p,a,b) (p)->GetHandle(a,b)
#define IDirect3DTexture_PaletteChanged(p,a,b) (p)->PaletteChanged(a,b)
#define IDirect3DTexture_Load(p,a) (p)->Load(a)
#define IDirect3DTexture_Unload(p) (p)->Unload()
#endif

#undef INTERFACE
#define INTERFACE IDirect3DTexture2

DECLARE_INTERFACE_(IDirect3DTexture2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DTexture2 methods ***/
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE2,LPD3DTEXTUREHANDLE) PURE;
    STDMETHOD(PaletteChanged)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Load)(THIS_ LPDIRECT3DTEXTURE2) PURE;
};

typedef struct IDirect3DTexture2 *LPDIRECT3DTEXTURE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DTexture2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DTexture2_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#define IDirect3DTexture2_PaletteChanged(p,a,b) (p)->lpVtbl->PaletteChanged(p,a,b)
#define IDirect3DTexture2_Load(p,a) (p)->lpVtbl->Load(p,a)
#else
#define IDirect3DTexture2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DTexture2_AddRef(p) (p)->AddRef()
#define IDirect3DTexture2_Release(p) (p)->Release()
#define IDirect3DTexture2_GetHandle(p,a,b) (p)->GetHandle(a,b)
#define IDirect3DTexture2_PaletteChanged(p,a,b) (p)->PaletteChanged(a,b)
#define IDirect3DTexture2_Load(p,a) (p)->Load(a)
#endif

/*
 * Viewport interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DViewport

DECLARE_INTERFACE_(IDirect3DViewport, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DViewport methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices)(THIS_ DWORD,LPD3DTRANSFORMDATA,DWORD,LPDWORD) PURE;
    STDMETHOD(LightElements)(THIS_ DWORD,LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground)(THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground)(THIS_ LPD3DMATERIALHANDLE,LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE*,LPBOOL) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight)(THIS_ LPDIRECT3DLIGHT,LPDIRECT3DLIGHT*,DWORD) PURE;
};

typedef struct IDirect3DViewport *LPDIRECT3DVIEWPORT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DViewport_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DViewport_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DViewport_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DViewport_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DViewport_TransformVertices(p,a,b,c,d) (p)->lpVtbl->TransformVertices(p,a,b,c,d)
#define IDirect3DViewport_LightElements(p,a,b) (p)->lpVtbl->LightElements(p,a,b)
#define IDirect3DViewport_SetBackground(p,a) (p)->lpVtbl->SetBackground(p,a)
#define IDirect3DViewport_GetBackground(p,a,b) (p)->lpVtbl->GetBackground(p,a,b)
#define IDirect3DViewport_SetBackgroundDepth(p,a) (p)->lpVtbl->SetBackgroundDepth(p,a)
#define IDirect3DViewport_GetBackgroundDepth(p,a,b) (p)->lpVtbl->GetBackgroundDepth(p,a,b)
#define IDirect3DViewport_Clear(p,a,b,c) (p)->lpVtbl->Clear(p,a,b,c)
#define IDirect3DViewport_AddLight(p,a) (p)->lpVtbl->AddLight(p,a)
#define IDirect3DViewport_DeleteLight(p,a) (p)->lpVtbl->DeleteLight(p,a)
#define IDirect3DViewport_NextLight(p,a,b,c) (p)->lpVtbl->NextLight(p,a,b,c)
#else
#define IDirect3DViewport_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DViewport_AddRef(p) (p)->AddRef()
#define IDirect3DViewport_Release(p) (p)->Release()
#define IDirect3DViewport_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DViewport_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DViewport_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DViewport_TransformVertices(p,a,b,c,d) (p)->TransformVertices(a,b,c,d)
#define IDirect3DViewport_LightElements(p,a,b) (p)->LightElements(a,b)
#define IDirect3DViewport_SetBackground(p,a) (p)->SetBackground(a)
#define IDirect3DViewport_GetBackground(p,a,b) (p)->GetBackground(a,b)
#define IDirect3DViewport_SetBackgroundDepth(p,a) (p)->SetBackgroundDepth(a)
#define IDirect3DViewport_GetBackgroundDepth(p,a,b) (p)->GetBackgroundDepth(a,b)
#define IDirect3DViewport_Clear(p,a,b,c) (p)->Clear(a,b,c)
#define IDirect3DViewport_AddLight(p,a) (p)->AddLight(a)
#define IDirect3DViewport_DeleteLight(p,a) (p)->DeleteLight(a)
#define IDirect3DViewport_NextLight(p,a,b,c) (p)->NextLight(a,b,c)
#endif

#undef INTERFACE
#define INTERFACE IDirect3DViewport2

DECLARE_INTERFACE_(IDirect3DViewport2, IDirect3DViewport)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DViewport methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices)(THIS_ DWORD,LPD3DTRANSFORMDATA,DWORD,LPDWORD) PURE;
    STDMETHOD(LightElements)(THIS_ DWORD,LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground)(THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground)(THIS_ LPD3DMATERIALHANDLE,LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE*,LPBOOL) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight)(THIS_ LPDIRECT3DLIGHT,LPDIRECT3DLIGHT*,DWORD) PURE;
    STDMETHOD(GetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
    STDMETHOD(SetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
};

typedef struct IDirect3DViewport2 *LPDIRECT3DVIEWPORT2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DViewport2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DViewport2_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DViewport2_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DViewport2_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DViewport2_TransformVertices(p,a,b,c,d) (p)->lpVtbl->TransformVertices(p,a,b,c,d)
#define IDirect3DViewport2_LightElements(p,a,b) (p)->lpVtbl->LightElements(p,a,b)
#define IDirect3DViewport2_SetBackground(p,a) (p)->lpVtbl->SetBackground(p,a)
#define IDirect3DViewport2_GetBackground(p,a,b) (p)->lpVtbl->GetBackground(p,a,b)
#define IDirect3DViewport2_SetBackgroundDepth(p,a) (p)->lpVtbl->SetBackgroundDepth(p,a)
#define IDirect3DViewport2_GetBackgroundDepth(p,a,b) (p)->lpVtbl->GetBackgroundDepth(p,a,b)
#define IDirect3DViewport2_Clear(p,a,b,c) (p)->lpVtbl->Clear(p,a,b,c)
#define IDirect3DViewport2_AddLight(p,a) (p)->lpVtbl->AddLight(p,a)
#define IDirect3DViewport2_DeleteLight(p,a) (p)->lpVtbl->DeleteLight(p,a)
#define IDirect3DViewport2_NextLight(p,a,b,c) (p)->lpVtbl->NextLight(p,a,b,c)
#define IDirect3DViewport2_GetViewport2(p,a) (p)->lpVtbl->GetViewport2(p,a)
#define IDirect3DViewport2_SetViewport2(p,a) (p)->lpVtbl->SetViewport2(p,a)
#else
#define IDirect3DViewport2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DViewport2_AddRef(p) (p)->AddRef()
#define IDirect3DViewport2_Release(p) (p)->Release()
#define IDirect3DViewport2_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DViewport2_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DViewport2_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DViewport2_TransformVertices(p,a,b,c,d) (p)->TransformVertices(a,b,c,d)
#define IDirect3DViewport2_LightElements(p,a,b) (p)->LightElements(a,b)
#define IDirect3DViewport2_SetBackground(p,a) (p)->SetBackground(a)
#define IDirect3DViewport2_GetBackground(p,a,b) (p)->GetBackground(a,b)
#define IDirect3DViewport2_SetBackgroundDepth(p,a) (p)->SetBackgroundDepth(a)
#define IDirect3DViewport2_GetBackgroundDepth(p,a,b) (p)->GetBackgroundDepth(a,b)
#define IDirect3DViewport2_Clear(p,a,b,c) (p)->Clear(a,b,c)
#define IDirect3DViewport2_AddLight(p,a) (p)->AddLight(a)
#define IDirect3DViewport2_DeleteLight(p,a) (p)->DeleteLight(a)
#define IDirect3DViewport2_NextLight(p,a,b,c) (p)->NextLight(a,b,c)
#define IDirect3DViewport2_GetViewport2(p,a) (p)->GetViewport2(a)
#define IDirect3DViewport2_SetViewport2(p,a) (p)->SetViewport2(a)
#endif


#undef INTERFACE
#define INTERFACE IDirect3DViewport3

DECLARE_INTERFACE_(IDirect3DViewport3, IDirect3DViewport2)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DViewport2 methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices)(THIS_ DWORD,LPD3DTRANSFORMDATA,DWORD,LPDWORD) PURE;
    STDMETHOD(LightElements)(THIS_ DWORD,LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground)(THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground)(THIS_ LPD3DMATERIALHANDLE,LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(GetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE4*,LPBOOL) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight)(THIS_ LPDIRECT3DLIGHT,LPDIRECT3DLIGHT*,DWORD) PURE;
    STDMETHOD(GetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
    STDMETHOD(SetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
    STDMETHOD(Clear2)(THIS_ DWORD,LPD3DRECT,DWORD,D3DCOLOR,D3DVALUE,DWORD) PURE;
};

typedef struct IDirect3DViewport3 *LPDIRECT3DVIEWPORT3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DViewport3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DViewport3_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DViewport3_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DViewport3_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DViewport3_TransformVertices(p,a,b,c,d) (p)->lpVtbl->TransformVertices(p,a,b,c,d)
#define IDirect3DViewport3_LightElements(p,a,b) (p)->lpVtbl->LightElements(p,a,b)
#define IDirect3DViewport3_SetBackground(p,a) (p)->lpVtbl->SetBackground(p,a)
#define IDirect3DViewport3_GetBackground(p,a,b) (p)->lpVtbl->GetBackground(p,a,b)
#define IDirect3DViewport3_SetBackgroundDepth(p,a) (p)->lpVtbl->SetBackgroundDepth(p,a)
#define IDirect3DViewport3_GetBackgroundDepth(p,a,b) (p)->lpVtbl->GetBackgroundDepth(p,a,b)
#define IDirect3DViewport3_Clear(p,a,b,c) (p)->lpVtbl->Clear(p,a,b,c)
#define IDirect3DViewport3_AddLight(p,a) (p)->lpVtbl->AddLight(p,a)
#define IDirect3DViewport3_DeleteLight(p,a) (p)->lpVtbl->DeleteLight(p,a)
#define IDirect3DViewport3_NextLight(p,a,b,c) (p)->lpVtbl->NextLight(p,a,b,c)
#define IDirect3DViewport3_GetViewport2(p,a) (p)->lpVtbl->GetViewport2(p,a)
#define IDirect3DViewport3_SetViewport2(p,a) (p)->lpVtbl->SetViewport2(p,a)
#define IDirect3DViewport3_Clear2(p,a,b,c,d,e,f) (p)->lpVtbl->Clear2(p,a,b,c,d,e,f)
#else
#define IDirect3DViewport3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DViewport3_AddRef(p) (p)->AddRef()
#define IDirect3DViewport3_Release(p) (p)->Release()
#define IDirect3DViewport3_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DViewport3_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DViewport3_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DViewport3_TransformVertices(p,a,b,c,d) (p)->TransformVertices(a,b,c,d)
#define IDirect3DViewport3_LightElements(p,a,b) (p)->LightElements(a,b)
#define IDirect3DViewport3_SetBackground(p,a) (p)->SetBackground(a)
#define IDirect3DViewport3_GetBackground(p,a,b) (p)->GetBackground(a,b)
#define IDirect3DViewport3_SetBackgroundDepth(p,a) (p)->SetBackgroundDepth(a)
#define IDirect3DViewport3_GetBackgroundDepth(p,a,b) (p)->GetBackgroundDepth(a,b)
#define IDirect3DViewport3_Clear(p,a,b,c) (p)->Clear(a,b,c)
#define IDirect3DViewport3_AddLight(p,a) (p)->AddLight(a)
#define IDirect3DViewport3_DeleteLight(p,a) (p)->DeleteLight(a)
#define IDirect3DViewport3_NextLight(p,a,b,c) (p)->NextLight(a,b,c)
#define IDirect3DViewport3_GetViewport2(p,a) (p)->GetViewport2(a)
#define IDirect3DViewport3_SetViewport2(p,a) (p)->SetViewport2(a)
#define IDirect3DViewport3_Clear2(p,a,b,c,d,e,f) (p)->Clear2(a,b,c,d,e,f)
#endif

#undef INTERFACE
#define INTERFACE IDirect3DVertexBuffer

DECLARE_INTERFACE_(IDirect3DVertexBuffer, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVertexBuffer methods ***/
    STDMETHOD(Lock)(THIS_ DWORD,LPVOID*,LPDWORD) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(ProcessVertices)(THIS_ DWORD,DWORD,DWORD,LPDIRECT3DVERTEXBUFFER,DWORD,LPDIRECT3DDEVICE3,DWORD) PURE;
    STDMETHOD(GetVertexBufferDesc)(THIS_ LPD3DVERTEXBUFFERDESC) PURE;
    STDMETHOD(Optimize)(THIS_ LPDIRECT3DDEVICE3,DWORD) PURE;
};

typedef struct IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexBuffer_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexBuffer_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexBuffer_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexBuffer_Lock(p,a,b,c) (p)->lpVtbl->Lock(p,a,b,c)
#define IDirect3DVertexBuffer_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DVertexBuffer_ProcessVertices(p,a,b,c,d,e,f,g) (p)->lpVtbl->ProcessVertices(p,a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer_GetVertexBufferDesc(p,a) (p)->lpVtbl->GetVertexBufferDesc(p,a)
#define IDirect3DVertexBuffer_Optimize(p,a,b) (p)->lpVtbl->Optimize(p,a,b)
#else
#define IDirect3DVertexBuffer_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexBuffer_AddRef(p) (p)->AddRef()
#define IDirect3DVertexBuffer_Release(p) (p)->Release()
#define IDirect3DVertexBuffer_Lock(p,a,b,c) (p)->Lock(a,b,c)
#define IDirect3DVertexBuffer_Unlock(p) (p)->Unlock()
#define IDirect3DVertexBuffer_ProcessVertices(p,a,b,c,d,e,f,g) (p)->ProcessVertices(a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer_GetVertexBufferDesc(p,a) (p)->GetVertexBufferDesc(a)
#define IDirect3DVertexBuffer_Optimize(p,a,b) (p)->Optimize(a,b)
#endif

/****************************************************************************
 *
 * Flags for IDirect3DDevice::NextViewport
 *
 ****************************************************************************/

/*
 * Return the next viewport
 */
#define D3DNEXT_NEXT    0x00000001l

/*
 * Return the first viewport
 */
#define D3DNEXT_HEAD    0x00000002l

/*
 * Return the last viewport
 */
#define D3DNEXT_TAIL    0x00000004l


/****************************************************************************
 *
 * Flags for DrawPrimitive/DrawIndexedPrimitive
 *   Also valid for Begin/BeginIndexed
 *   Also valid for VertexBuffer::CreateVertexBuffer
 ****************************************************************************/

/*
 * Wait until the device is ready to draw the primitive
 * This will cause DP to not return DDERR_WASSTILLDRAWING
 */
#define D3DDP_WAIT                  0x00000001l

/*
 * Hint that the primitives have been clipped by the application.
 */
#define D3DDP_DONOTCLIP             0x00000004l

/*
 * Hint that the extents need not be updated.
 */
#define D3DDP_DONOTUPDATEEXTENTS    0x00000008l


/*
 * Hint that the lighting should not be applied on vertices.
 */

#define D3DDP_DONOTLIGHT            0x00000010l


/*
 * Direct3D Errors
 * DirectDraw error codes are used when errors not specified here.
 */
#define D3D_OK              DD_OK
#define D3DERR_BADMAJORVERSION      MAKE_DDHRESULT(700)
#define D3DERR_BADMINORVERSION      MAKE_DDHRESULT(701)

/*
 * An invalid device was requested by the application.
 */
#define D3DERR_INVALID_DEVICE   MAKE_DDHRESULT(705)
#define D3DERR_INITFAILED       MAKE_DDHRESULT(706)

/*
 * SetRenderTarget attempted on a device that was
 * QI'd off the render target.
 */
#define D3DERR_DEVICEAGGREGATED MAKE_DDHRESULT(707)

#define D3DERR_EXECUTE_CREATE_FAILED    MAKE_DDHRESULT(710)
#define D3DERR_EXECUTE_DESTROY_FAILED   MAKE_DDHRESULT(711)
#define D3DERR_EXECUTE_LOCK_FAILED  MAKE_DDHRESULT(712)
#define D3DERR_EXECUTE_UNLOCK_FAILED    MAKE_DDHRESULT(713)
#define D3DERR_EXECUTE_LOCKED       MAKE_DDHRESULT(714)
#define D3DERR_EXECUTE_NOT_LOCKED   MAKE_DDHRESULT(715)

#define D3DERR_EXECUTE_FAILED       MAKE_DDHRESULT(716)
#define D3DERR_EXECUTE_CLIPPED_FAILED   MAKE_DDHRESULT(717)

#define D3DERR_TEXTURE_NO_SUPPORT   MAKE_DDHRESULT(720)
#define D3DERR_TEXTURE_CREATE_FAILED    MAKE_DDHRESULT(721)
#define D3DERR_TEXTURE_DESTROY_FAILED   MAKE_DDHRESULT(722)
#define D3DERR_TEXTURE_LOCK_FAILED  MAKE_DDHRESULT(723)
#define D3DERR_TEXTURE_UNLOCK_FAILED    MAKE_DDHRESULT(724)
#define D3DERR_TEXTURE_LOAD_FAILED  MAKE_DDHRESULT(725)
#define D3DERR_TEXTURE_SWAP_FAILED  MAKE_DDHRESULT(726)
#define D3DERR_TEXTURE_LOCKED       MAKE_DDHRESULT(727)
#define D3DERR_TEXTURE_NOT_LOCKED   MAKE_DDHRESULT(728)
#define D3DERR_TEXTURE_GETSURF_FAILED   MAKE_DDHRESULT(729)

#define D3DERR_MATRIX_CREATE_FAILED MAKE_DDHRESULT(730)
#define D3DERR_MATRIX_DESTROY_FAILED    MAKE_DDHRESULT(731)
#define D3DERR_MATRIX_SETDATA_FAILED    MAKE_DDHRESULT(732)
#define D3DERR_MATRIX_GETDATA_FAILED    MAKE_DDHRESULT(733)
#define D3DERR_SETVIEWPORTDATA_FAILED   MAKE_DDHRESULT(734)

#define D3DERR_INVALIDCURRENTVIEWPORT   MAKE_DDHRESULT(735)
#define D3DERR_INVALIDPRIMITIVETYPE     MAKE_DDHRESULT(736)
#define D3DERR_INVALIDVERTEXTYPE        MAKE_DDHRESULT(737)
#define D3DERR_TEXTURE_BADSIZE          MAKE_DDHRESULT(738)
#define D3DERR_INVALIDRAMPTEXTURE       MAKE_DDHRESULT(739)

#define D3DERR_MATERIAL_CREATE_FAILED   MAKE_DDHRESULT(740)
#define D3DERR_MATERIAL_DESTROY_FAILED  MAKE_DDHRESULT(741)
#define D3DERR_MATERIAL_SETDATA_FAILED  MAKE_DDHRESULT(742)
#define D3DERR_MATERIAL_GETDATA_FAILED  MAKE_DDHRESULT(743)

#define D3DERR_INVALIDPALETTE           MAKE_DDHRESULT(744)

#define D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY MAKE_DDHRESULT(745)
#define D3DERR_ZBUFF_NEEDS_VIDEOMEMORY  MAKE_DDHRESULT(746)
#define D3DERR_SURFACENOTINVIDMEM       MAKE_DDHRESULT(747)

#define D3DERR_LIGHT_SET_FAILED     MAKE_DDHRESULT(750)
#define D3DERR_LIGHTHASVIEWPORT     MAKE_DDHRESULT(751)
#define D3DERR_LIGHTNOTINTHISVIEWPORT           MAKE_DDHRESULT(752)

#define D3DERR_SCENE_IN_SCENE       MAKE_DDHRESULT(760)
#define D3DERR_SCENE_NOT_IN_SCENE   MAKE_DDHRESULT(761)
#define D3DERR_SCENE_BEGIN_FAILED   MAKE_DDHRESULT(762)
#define D3DERR_SCENE_END_FAILED     MAKE_DDHRESULT(763)

#define D3DERR_INBEGIN                  MAKE_DDHRESULT(770)
#define D3DERR_NOTINBEGIN               MAKE_DDHRESULT(771)
#define D3DERR_NOVIEWPORTS              MAKE_DDHRESULT(772)
#define D3DERR_VIEWPORTDATANOTSET       MAKE_DDHRESULT(773)
#define D3DERR_VIEWPORTHASNODEVICE      MAKE_DDHRESULT(774)
#define D3DERR_NOCURRENTVIEWPORT        MAKE_DDHRESULT(775)

#define D3DERR_INVALIDVERTEXFORMAT              MAKE_DDHRESULT(2048)

/*
 * Attempted to CreateTexture on a surface that had a color key
 */
#define D3DERR_COLORKEYATTACHED                 MAKE_DDHRESULT(2050)

#define D3DERR_VERTEXBUFFEROPTIMIZED            MAKE_DDHRESULT(2060)
#define D3DERR_VBUF_CREATE_FAILED               MAKE_DDHRESULT(2061)
#define D3DERR_VERTEXBUFFERLOCKED               MAKE_DDHRESULT(2062)

#define D3DERR_ZBUFFER_NOTPRESENT               MAKE_DDHRESULT(2070)
#define D3DERR_STENCILBUFFER_NOTPRESENT         MAKE_DDHRESULT(2071)

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_DDHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION                MAKE_DDHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_DDHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION                MAKE_DDHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_DDHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_DDHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_DDHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_DDHRESULT(2079)



#ifdef __cplusplus
};
#endif

#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\d3drm.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRM_H__
#define __D3DRM_H__

#include "ddraw.h"

#ifdef __cplusplus
struct IDirect3DRM;
#endif

typedef struct IDirect3DRM *LPDIRECT3DRM;

#include "d3drmobj.h"

#ifdef __cplusplus
extern "C" {
#endif


DEFINE_GUID(IID_IDirect3DRM,    0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRM2,   0x4516ecc8, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRM3,   0x2e34065, 0xc243, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
WIN_TYPES(IDirect3DRM, DIRECT3DRM);
WIN_TYPES(IDirect3DRM2, DIRECT3DRM2);
WIN_TYPES(IDirect3DRM3, DIRECT3DRM3);

/*
 * Direct3DRM Object Class (for CoCreateInstance())
 */
DEFINE_GUID(CLSID_CDirect3DRM,  0x4516ec41, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);


/* Create a Direct3DRM API */
STDAPI Direct3DRMCreate(LPDIRECT3DRM FAR *lplpDirect3DRM);

#undef INTERFACE
#define INTERFACE IDirect3DRM

DECLARE_INTERFACE_(IDirect3DRM, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
        (THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)      (THIS_ LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(CreateMesh)       (THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER *) PURE;
    STDMETHOD(CreateFace)       (THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)  (THIS_ LPDIRECT3DRMANIMATION *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET *) PURE;
    STDMETHOD(CreateTexture)    (THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(CreateLight)      (THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
        (THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)   (THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD(CreateDevice)     (THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (   THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
        LPDIRECTDRAWSURFACE lpDDSBack, LPDIRECT3DRMDEVICE *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (   THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev,
        LPDIRECT3DRMDEVICE *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (   THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
        int width, int height, LPDIRECT3DRMDEVICE *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE *) PURE;
   
    STDMETHOD(CreateShadow)
    (   THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMLIGHT,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
        LPDIRECT3DRMVISUAL *
    ) PURE;
    STDMETHOD(CreateViewport)
    (   THIS_ LPDIRECT3DRMDEVICE, LPDIRECT3DRMFRAME, DWORD, DWORD,
        DWORD, DWORD, LPDIRECT3DRMVIEWPORT *
    ) PURE;
    STDMETHOD(CreateWrap)
    (   THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME,
        D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
        D3DVALUE ou, D3DVALUE ov,
        D3DVALUE su, D3DVALUE sv,
        LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)      (THIS_ const char *, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(LoadTextureFromResource)  (THIS_ HRSRC rs, LPDIRECT3DRMTEXTURE *) PURE;
   
    STDMETHOD(SetSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)    (THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)       (THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)   (THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects) (THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)             
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
        D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURECALLBACK, LPVOID,
        LPDIRECT3DRMFRAME
    ) PURE;
    STDMETHOD(Tick)             (THIS_ D3DVALUE) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRM2

DECLARE_INTERFACE_(IDirect3DRM2, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
        (THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)      (THIS_ LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME2 *) PURE;
    STDMETHOD(CreateMesh)       (THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER2 *) PURE;
    STDMETHOD(CreateFace)       (THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)  (THIS_ LPDIRECT3DRMANIMATION *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET *) PURE;
    STDMETHOD(CreateTexture)    (THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE2 *) PURE;
    STDMETHOD(CreateLight)      (THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
        (THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)   (THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD(CreateDevice)     (THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE2 *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (   THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
        LPDIRECTDRAWSURFACE lpDDSBack, LPDIRECT3DRMDEVICE2 *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (   THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev,
        LPDIRECT3DRMDEVICE2 *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (   THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
        int width, int height, LPDIRECT3DRMDEVICE2 *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE2 *) PURE;
   
    STDMETHOD(CreateShadow)
    (   THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMLIGHT,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
        LPDIRECT3DRMVISUAL *
    ) PURE;
    STDMETHOD(CreateViewport)
    (   THIS_ LPDIRECT3DRMDEVICE, LPDIRECT3DRMFRAME, DWORD, DWORD,
        DWORD, DWORD, LPDIRECT3DRMVIEWPORT *
    ) PURE;
    STDMETHOD(CreateWrap)
    (   THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME,
        D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
        D3DVALUE ou, D3DVALUE ov,
        D3DVALUE su, D3DVALUE sv,
        LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)      (THIS_ const char *, LPDIRECT3DRMTEXTURE2 *) PURE;
    STDMETHOD(LoadTextureFromResource)  (THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType, LPDIRECT3DRMTEXTURE2 *) PURE;
   
    STDMETHOD(SetSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)    (THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)       (THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)   (THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects) (THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)             
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
        D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURECALLBACK, LPVOID,
        LPDIRECT3DRMFRAME
    ) PURE;
    STDMETHOD(Tick)             (THIS_ D3DVALUE) PURE;

    STDMETHOD(CreateProgressiveMesh)(THIS_ LPDIRECT3DRMPROGRESSIVEMESH *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRM3

DECLARE_INTERFACE_(IDirect3DRM3, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
        (THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)      (THIS_ LPDIRECT3DRMFRAME3, LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(CreateMesh)       (THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER3 *) PURE;
    STDMETHOD(CreateFace)       (THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)  (THIS_ LPDIRECT3DRMANIMATION2 *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET2 *) PURE;
    STDMETHOD(CreateTexture)    (THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(CreateLight)      (THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
        (THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)   (THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL2 *) PURE;
    STDMETHOD(CreateDevice)     (THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE3 *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (   THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
        LPDIRECTDRAWSURFACE lpDDSBack, DWORD dwFlags, LPDIRECT3DRMDEVICE3 *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (   THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev,
        LPDIRECT3DRMDEVICE3 *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (   THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
        int width, int height, LPDIRECT3DRMDEVICE3 *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE3 *) PURE;
   
    STDMETHOD(CreateShadow)
    (   THIS_ LPUNKNOWN, LPDIRECT3DRMLIGHT,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
        LPDIRECT3DRMSHADOW2 *
    ) PURE;
    STDMETHOD(CreateViewport)
    (   THIS_ LPDIRECT3DRMDEVICE3, LPDIRECT3DRMFRAME3, DWORD, DWORD,
        DWORD, DWORD, LPDIRECT3DRMVIEWPORT2 *
    ) PURE;
    STDMETHOD(CreateWrap)
    (   THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME3,
        D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
        D3DVALUE ou, D3DVALUE ov,
        D3DVALUE su, D3DVALUE sv,
        LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)      (THIS_ const char *, LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(LoadTextureFromResource)  (THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType, LPDIRECT3DRMTEXTURE3 *) PURE;
   
    STDMETHOD(SetSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)    (THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)       (THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)   (THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects) (THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)             
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
        D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURE3CALLBACK, LPVOID,
        LPDIRECT3DRMFRAME3
    ) PURE;
    STDMETHOD(Tick)             (THIS_ D3DVALUE) PURE;

    STDMETHOD(CreateProgressiveMesh)(THIS_ LPDIRECT3DRMPROGRESSIVEMESH *) PURE;

    /* Used with IDirect3DRMObject2 */
    STDMETHOD(RegisterClient)   (THIS_ REFGUID rguid, LPDWORD lpdwID) PURE;
    STDMETHOD(UnregisterClient) (THIS_ REFGUID rguid) PURE;

    STDMETHOD(CreateClippedVisual) (THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMCLIPPEDVISUAL *) PURE;
    STDMETHOD(SetOptions) (THIS_ DWORD);
    STDMETHOD(GetOptions) (THIS_ LPDWORD);
};

#define D3DRM_OK                        DD_OK
#define D3DRMERR_BADOBJECT              MAKE_DDHRESULT(781)
#define D3DRMERR_BADTYPE                MAKE_DDHRESULT(782)
#define D3DRMERR_BADALLOC               MAKE_DDHRESULT(783)
#define D3DRMERR_FACEUSED               MAKE_DDHRESULT(784)
#define D3DRMERR_NOTFOUND               MAKE_DDHRESULT(785)
#define D3DRMERR_NOTDONEYET             MAKE_DDHRESULT(786)
#define D3DRMERR_FILENOTFOUND           MAKE_DDHRESULT(787)
#define D3DRMERR_BADFILE                MAKE_DDHRESULT(788)
#define D3DRMERR_BADDEVICE              MAKE_DDHRESULT(789)
#define D3DRMERR_BADVALUE               MAKE_DDHRESULT(790)
#define D3DRMERR_BADMAJORVERSION        MAKE_DDHRESULT(791)
#define D3DRMERR_BADMINORVERSION        MAKE_DDHRESULT(792)
#define D3DRMERR_UNABLETOEXECUTE        MAKE_DDHRESULT(793)
#define D3DRMERR_LIBRARYNOTFOUND        MAKE_DDHRESULT(794)
#define D3DRMERR_INVALIDLIBRARY         MAKE_DDHRESULT(795)
#define D3DRMERR_PENDING                MAKE_DDHRESULT(796)
#define D3DRMERR_NOTENOUGHDATA          MAKE_DDHRESULT(797)
#define D3DRMERR_REQUESTTOOLARGE        MAKE_DDHRESULT(798)
#define D3DRMERR_REQUESTTOOSMALL        MAKE_DDHRESULT(799)
#define D3DRMERR_CONNECTIONLOST         MAKE_DDHRESULT(800)
#define D3DRMERR_LOADABORTED            MAKE_DDHRESULT(801)
#define D3DRMERR_NOINTERNET             MAKE_DDHRESULT(802)
#define D3DRMERR_BADCACHEFILE           MAKE_DDHRESULT(803)
#define D3DRMERR_BOXNOTSET              MAKE_DDHRESULT(804)
#define D3DRMERR_BADPMDATA              MAKE_DDHRESULT(805)
#define D3DRMERR_CLIENTNOTREGISTERED    MAKE_DDHRESULT(806)
#define D3DRMERR_NOTCREATEDFROMDDS      MAKE_DDHRESULT(807)
#define D3DRMERR_NOSUCHKEY              MAKE_DDHRESULT(808)
#define D3DRMERR_INCOMPATABLEKEY        MAKE_DDHRESULT(809)
#define D3DRMERR_ELEMENTINUSE           MAKE_DDHRESULT(810)
#define D3DRMERR_TEXTUREFORMATNOTFOUND  MAKE_DDHRESULT(811)

#ifdef __cplusplus
};
#endif

#endif /* _D3DRMAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\d3drmobj.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef _D3DRMOBJ_H_
#define _D3DRMOBJ_H_

#include <objbase.h> /* Use Windows header files */
#define VIRTUAL
#include "d3drmdef.h"

#include "d3d.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The methods for IUnknown
 */
#define IUNKNOWN_METHODS(kind) \
    STDMETHOD(QueryInterface)           (THIS_ REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD_(ULONG, AddRef)           (THIS) kind; \
    STDMETHOD_(ULONG, Release)          (THIS) kind

/*
 * The methods for IDirect3DRMObject
 */
#define IDIRECT3DRMOBJECT_METHODS(kind) \
    STDMETHOD(Clone)                    (THIS_ LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD(AddDestroyCallback)       (THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(DeleteDestroyCallback)    (THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(SetAppData)               (THIS_ DWORD data) kind; \
    STDMETHOD_(DWORD, GetAppData)       (THIS) kind; \
    STDMETHOD(SetName)                  (THIS_ LPCSTR) kind; \
    STDMETHOD(GetName)                  (THIS_ LPDWORD lpdwSize, LPSTR lpName) kind; \
    STDMETHOD(GetClassName)             (THIS_ LPDWORD lpdwSize, LPSTR lpName) kind


#define WIN_TYPES(itype, ptype) \
    typedef interface itype FAR *LP##ptype, FAR **LPLP##ptype

WIN_TYPES(IDirect3DRMObject, DIRECT3DRMOBJECT);
WIN_TYPES(IDirect3DRMObject2, DIRECT3DRMOBJECT2);
WIN_TYPES(IDirect3DRMDevice, DIRECT3DRMDEVICE);
WIN_TYPES(IDirect3DRMDevice2, DIRECT3DRMDEVICE2);
WIN_TYPES(IDirect3DRMDevice3, DIRECT3DRMDEVICE3);
WIN_TYPES(IDirect3DRMViewport, DIRECT3DRMVIEWPORT);
WIN_TYPES(IDirect3DRMViewport2, DIRECT3DRMVIEWPORT2);
WIN_TYPES(IDirect3DRMFrame, DIRECT3DRMFRAME);
WIN_TYPES(IDirect3DRMFrame2, DIRECT3DRMFRAME2);
WIN_TYPES(IDirect3DRMFrame3, DIRECT3DRMFRAME3);
WIN_TYPES(IDirect3DRMVisual, DIRECT3DRMVISUAL);
WIN_TYPES(IDirect3DRMMesh, DIRECT3DRMMESH);
WIN_TYPES(IDirect3DRMMeshBuilder, DIRECT3DRMMESHBUILDER);
WIN_TYPES(IDirect3DRMMeshBuilder2, DIRECT3DRMMESHBUILDER2);
WIN_TYPES(IDirect3DRMMeshBuilder3, DIRECT3DRMMESHBUILDER3);
WIN_TYPES(IDirect3DRMFace, DIRECT3DRMFACE);
WIN_TYPES(IDirect3DRMLight, DIRECT3DRMLIGHT);
WIN_TYPES(IDirect3DRMTexture, DIRECT3DRMTEXTURE);
WIN_TYPES(IDirect3DRMTexture2, DIRECT3DRMTEXTURE2);
WIN_TYPES(IDirect3DRMTexture3, DIRECT3DRMTEXTURE3);
WIN_TYPES(IDirect3DRMWrap, DIRECT3DRMWRAP);
WIN_TYPES(IDirect3DRMMaterial, DIRECT3DRMMATERIAL);
WIN_TYPES(IDirect3DRMMaterial2, DIRECT3DRMMATERIAL2);
WIN_TYPES(IDirect3DRMInterpolator, DIRECT3DRMINTERPOLATOR);
WIN_TYPES(IDirect3DRMAnimation, DIRECT3DRMANIMATION);
WIN_TYPES(IDirect3DRMAnimation2, DIRECT3DRMANIMATION2);
WIN_TYPES(IDirect3DRMAnimationSet, DIRECT3DRMANIMATIONSET);
WIN_TYPES(IDirect3DRMAnimationSet2, DIRECT3DRMANIMATIONSET2);
WIN_TYPES(IDirect3DRMUserVisual, DIRECT3DRMUSERVISUAL);
WIN_TYPES(IDirect3DRMShadow, DIRECT3DRMSHADOW);
WIN_TYPES(IDirect3DRMShadow2, DIRECT3DRMSHADOW2);
WIN_TYPES(IDirect3DRMArray, DIRECT3DRMARRAY);
WIN_TYPES(IDirect3DRMObjectArray, DIRECT3DRMOBJECTARRAY);
WIN_TYPES(IDirect3DRMDeviceArray, DIRECT3DRMDEVICEARRAY);
WIN_TYPES(IDirect3DRMFaceArray, DIRECT3DRMFACEARRAY);
WIN_TYPES(IDirect3DRMViewportArray, DIRECT3DRMVIEWPORTARRAY);
WIN_TYPES(IDirect3DRMFrameArray, DIRECT3DRMFRAMEARRAY);
WIN_TYPES(IDirect3DRMAnimationArray, DIRECT3DRMANIMATIONARRAY);
WIN_TYPES(IDirect3DRMVisualArray, DIRECT3DRMVISUALARRAY);
WIN_TYPES(IDirect3DRMPickedArray, DIRECT3DRMPICKEDARRAY);
WIN_TYPES(IDirect3DRMPicked2Array, DIRECT3DRMPICKED2ARRAY);
WIN_TYPES(IDirect3DRMLightArray, DIRECT3DRMLIGHTARRAY);
WIN_TYPES(IDirect3DRMProgressiveMesh, DIRECT3DRMPROGRESSIVEMESH);
WIN_TYPES(IDirect3DRMClippedVisual, DIRECT3DRMCLIPPEDVISUAL);

/*
 * Direct3DRM Object classes
 */
DEFINE_GUID(CLSID_CDirect3DRMDevice,        0x4fa3568e, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMViewport,      0x4fa3568f, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFrame,         0x4fa35690, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMesh,          0x4fa35691, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMeshBuilder,   0x4fa35692, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFace,          0x4fa35693, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMLight,         0x4fa35694, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMTexture,       0x4fa35695, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMWrap,          0x4fa35696, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMaterial,      0x4fa35697, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimation,     0x4fa35698, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimationSet,  0x4fa35699, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMUserVisual,    0x4fa3569a, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMShadow,        0x4fa3569b, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMViewportInterpolator, 
0xde9eaa1, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMFrameInterpolator, 
0xde9eaa2, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMMeshInterpolator, 
0xde9eaa3, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMLightInterpolator, 
0xde9eaa6, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMMaterialInterpolator, 
0xde9eaa7, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMTextureInterpolator, 
0xde9eaa8, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMProgressiveMesh, 0x4516ec40, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMClippedVisual,   0x5434e72d, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);


/*
 * Direct3DRM Object interfaces
 */
DEFINE_GUID(IID_IDirect3DRMObject,          0xeb16cb00, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMObject2,         0x4516ec7c, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice,          0xe9e19280, 0x6e05, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMDevice2,         0x4516ec78, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice3,     0x549f498b, 0xbfeb, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMViewport,        0xeb16cb02, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewport2,   0x4a1b1be6, 0xbfed, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMFrame,           0xeb16cb03, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrame2,          0xc3dfbd60, 0x3988, 0x11d0, 0x9e, 0xc2, 0x0, 0x0, 0xc0, 0x29, 0x1a, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFrame3,              0xff6b7f70, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMVisual,          0xeb16cb04, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMesh,            0xa3a80d01, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder,     0xa3a80d02, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder2,    0x4516ec77, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder3,    0xff6b7f71, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMFace,            0xeb16cb07, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLight,           0xeb16cb08, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture,         0xeb16cb09, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture2,        0x120f30c0, 0x1629, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);
DEFINE_GUID(IID_IDirect3DRMTexture3,        0xff6b7f73, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMWrap,            0xeb16cb0a, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial,        0xeb16cb0b, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial2,       0xff6b7f75, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimation,       0xeb16cb0d, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimation2,      0xff6b7f77, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimationSet,    0xeb16cb0e, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationSet2,   0xff6b7f79, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMObjectArray,     0x242f6bc2, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDeviceArray,     0xeb16cb10, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewportArray,   0xeb16cb11, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrameArray,      0xeb16cb12, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMVisualArray,     0xeb16cb13, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLightArray,      0xeb16cb14, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMPickedArray,     0xeb16cb16, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFaceArray,       0xeb16cb17, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationArray, 
0xd5f1cae0, 0x4bd7, 0x11d1, 0xb9, 0x74, 0x0, 0x60, 0x8, 0x3e, 0x45, 0xf3);
DEFINE_GUID(IID_IDirect3DRMUserVisual,      0x59163de0, 0x6d43, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow,          0xaf359780, 0x6ba3, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow2,         0x86b44e25, 0x9c82, 0x11d1, 0xbb, 0xb, 0x0, 0xa0, 0xc9, 0x81, 0xa0, 0xa6);
DEFINE_GUID(IID_IDirect3DRMInterpolator,    0x242f6bc1, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMProgressiveMesh, 0x4516ec79, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMPicked2Array,    0x4516ec7b, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMClippedVisual,   0x5434e733, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);

typedef void (__cdecl *D3DRMOBJECTCALLBACK)(LPDIRECT3DRMOBJECT obj, LPVOID arg);
typedef void (__cdecl *D3DRMFRAMEMOVECALLBACK)(LPDIRECT3DRMFRAME obj, LPVOID arg, D3DVALUE delta);
typedef void (__cdecl *D3DRMFRAME3MOVECALLBACK)(LPDIRECT3DRMFRAME3 obj, LPVOID arg, D3DVALUE delta);
typedef void (__cdecl *D3DRMUPDATECALLBACK)(LPDIRECT3DRMDEVICE obj, LPVOID arg, int, LPD3DRECT);
typedef void (__cdecl *D3DRMDEVICE3UPDATECALLBACK)(LPDIRECT3DRMDEVICE3 obj, LPVOID arg, int, LPD3DRECT);
typedef int (__cdecl *D3DRMUSERVISUALCALLBACK)
    (   LPDIRECT3DRMUSERVISUAL obj, LPVOID arg, D3DRMUSERVISUALREASON reason,
        LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view
    );
typedef HRESULT (__cdecl *D3DRMLOADTEXTURECALLBACK)
    (char *tex_name, void *arg, LPDIRECT3DRMTEXTURE *);
typedef HRESULT (__cdecl *D3DRMLOADTEXTURE3CALLBACK)
    (char *tex_name, void *arg, LPDIRECT3DRMTEXTURE3 *);
typedef void (__cdecl *D3DRMLOADCALLBACK)
    (LPDIRECT3DRMOBJECT object, REFIID objectguid, LPVOID arg);

typedef HRESULT (__cdecl *D3DRMDOWNSAMPLECALLBACK)
    (LPDIRECT3DRMTEXTURE3 lpDirect3DRMTexture, LPVOID pArg,
     LPDIRECTDRAWSURFACE pDDSSrc, LPDIRECTDRAWSURFACE pDDSDst);
typedef HRESULT (__cdecl *D3DRMVALIDATIONCALLBACK)
    (LPDIRECT3DRMTEXTURE3 lpDirect3DRMTexture, LPVOID pArg,
     DWORD dwFlags, DWORD dwcRects, LPRECT pRects);


typedef struct _D3DRMPICKDESC
{
    ULONG       ulFaceIdx;
    LONG        lGroupIdx;
    D3DVECTOR   vPosition;

} D3DRMPICKDESC, *LPD3DRMPICKDESC;

typedef struct _D3DRMPICKDESC2
{
    ULONG       ulFaceIdx;
    LONG        lGroupIdx;
    D3DVECTOR   dvPosition;
    D3DVALUE    tu;
    D3DVALUE    tv;
    D3DVECTOR   dvNormal;
    D3DCOLOR    dcColor;

} D3DRMPICKDESC2, *LPD3DRMPICKDESC2;

#undef INTERFACE
#define INTERFACE IDirect3DRMObject

/*
 * Base class
 */
DECLARE_INTERFACE_(IDirect3DRMObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMObject2

DECLARE_INTERFACE_(IDirect3DRMObject2, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    /*
     * IDirect3DRMObject2 methods
     */
    STDMETHOD(AddDestroyCallback)(THIS_ D3DRMOBJECTCALLBACK lpFunc, LPVOID pvArg) PURE;
    STDMETHOD(Clone)(THIS_ LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj) PURE; \
    STDMETHOD(DeleteDestroyCallback)(THIS_ D3DRMOBJECTCALLBACK lpFunc, LPVOID pvArg) PURE; \
    STDMETHOD(GetClientData)(THIS_ DWORD dwID, LPVOID* lplpvData) PURE;
    STDMETHOD(GetDirect3DRM)(THIS_ LPDIRECT3DRM* lplpDirect3DRM) PURE;
    STDMETHOD(GetName)(THIS_ LPDWORD lpdwSize, LPSTR lpName) PURE;
    STDMETHOD(SetClientData)(THIS_ DWORD dwID, LPVOID lpvData, DWORD dwFlags) PURE;
    STDMETHOD(SetName)(THIS_ LPCSTR lpName) PURE;
    STDMETHOD(GetAge)(THIS_ DWORD dwFlags, LPDWORD pdwAge) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMVisual

DECLARE_INTERFACE_(IDirect3DRMVisual, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice

DECLARE_INTERFACE_(IDirect3DRMDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice2

DECLARE_INTERFACE_(IDirect3DRMDevice2, IDirect3DRMDevice)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;

    /*
     * IDirect3DRMDevice2 methods
     */
    STDMETHOD(InitFromD3D2)(THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSBack) PURE;
    STDMETHOD(SetRenderMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(DWORD, GetRenderMode)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice2)(THIS_ LPDIRECT3DDEVICE2 *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice3

DECLARE_INTERFACE_(IDirect3DRMDevice3, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMDEVICE3UPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMDEVICE3UPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;

    /*
     * IDirect3DRMDevice2 methods
     */
    STDMETHOD(InitFromD3D2)(THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSBack, DWORD dwFlags) PURE;
    STDMETHOD(SetRenderMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(DWORD, GetRenderMode)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice2)(THIS_ LPDIRECT3DDEVICE2 *) PURE;

    /*
     * IDirect3DRMDevice3 methods
     */
    STDMETHOD(FindPreferredTextureFormat)(THIS_ DWORD dwBitDepths, DWORD dwFlags, LPDDPIXELFORMAT lpDDPF) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMViewport

DECLARE_INTERFACE_(IDirect3DRMViewport, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMViewport methods
     */
    STDMETHOD(Init)
    (   THIS_ LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMFRAME camera,
        DWORD xpos, DWORD ypos, DWORD width, DWORD height
    ) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMFRAME) PURE;

    STDMETHOD(SetFront)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetBack)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetField)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUniformScaling)(THIS_ BOOL) PURE;
    STDMETHOD(SetCamera)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(SetProjection)(THIS_ D3DRMPROJECTIONTYPE) PURE;
    STDMETHOD(Transform)(THIS_ D3DRMVECTOR4D *d, D3DVECTOR *s) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DRMVECTOR4D *s) PURE;
    STDMETHOD(Configure)(THIS_ LONG x, LONG y, DWORD width, DWORD height) PURE;
    STDMETHOD(ForceUpdate)(THIS_ DWORD x1, DWORD y1, DWORD x2, DWORD y2) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE left, D3DVALUE right, D3DVALUE bottom, D3DVALUE top) PURE;

    STDMETHOD(GetCamera)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DRMDEVICE *) PURE;
    STDMETHOD(GetPlane)(THIS_ D3DVALUE *left, D3DVALUE *right, D3DVALUE *bottom, D3DVALUE *top) PURE;
    STDMETHOD(Pick)(THIS_ LONG x, LONG y, LPDIRECT3DRMPICKEDARRAY *return_visuals) PURE;

    STDMETHOD_(BOOL, GetUniformScaling)(THIS) PURE;
    STDMETHOD_(LONG, GetX)(THIS) PURE;
    STDMETHOD_(LONG, GetY)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetField)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetBack)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetFront)(THIS) PURE;
    STDMETHOD_(D3DRMPROJECTIONTYPE, GetProjection)(THIS) PURE;
    STDMETHOD(GetDirect3DViewport)(THIS_ LPDIRECT3DVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMViewport2
DECLARE_INTERFACE_(IDirect3DRMViewport2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMViewport2 methods
     */
    STDMETHOD(Init)
    (   THIS_ LPDIRECT3DRMDEVICE3 dev, LPDIRECT3DRMFRAME3 camera,
        DWORD xpos, DWORD ypos, DWORD width, DWORD height
    ) PURE;
    STDMETHOD(Clear)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMFRAME3) PURE;

    STDMETHOD(SetFront)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetBack)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetField)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUniformScaling)(THIS_ BOOL) PURE;
    STDMETHOD(SetCamera)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(SetProjection)(THIS_ D3DRMPROJECTIONTYPE) PURE;
    STDMETHOD(Transform)(THIS_ D3DRMVECTOR4D *d, D3DVECTOR *s) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DRMVECTOR4D *s) PURE;
    STDMETHOD(Configure)(THIS_ LONG x, LONG y, DWORD width, DWORD height) PURE;
    STDMETHOD(ForceUpdate)(THIS_ DWORD x1, DWORD y1, DWORD x2, DWORD y2) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE left, D3DVALUE right, D3DVALUE bottom, D3DVALUE top) PURE;

    STDMETHOD(GetCamera)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DRMDEVICE3 *) PURE;
    STDMETHOD(GetPlane)(THIS_ D3DVALUE *left, D3DVALUE *right, D3DVALUE *bottom, D3DVALUE *top) PURE;
    STDMETHOD(Pick)(THIS_ LONG x, LONG y, LPDIRECT3DRMPICKEDARRAY *return_visuals) PURE;

    STDMETHOD_(BOOL, GetUniformScaling)(THIS) PURE;
    STDMETHOD_(LONG, GetX)(THIS) PURE;
    STDMETHOD_(LONG, GetY)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetField)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetBack)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetFront)(THIS) PURE;
    STDMETHOD_(D3DRMPROJECTIONTYPE, GetProjection)(THIS) PURE;
    STDMETHOD(GetDirect3DViewport)(THIS_ LPDIRECT3DVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame

DECLARE_INTERFACE_(IDirect3DRMFrame, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DRMMATRIX4D return_matrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDIRECT3DRMVISUALARRAY *visuals) PURE;
    STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME target, LPDIRECT3DRMFRAME reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (   THIS_ LPDIRECT3DRMFRAME reference,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame2

DECLARE_INTERFACE_(IDirect3DRMFrame2, IDirect3DRMFrame)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DRMMATRIX4D return_matrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDIRECT3DRMVISUALARRAY *visuals) PURE;
    STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME target, LPDIRECT3DRMFRAME reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (   THIS_ LPDIRECT3DRMFRAME reference,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;

    /*
     * IDirect3DRMFrame2 methods
     */
    STDMETHOD(AddMoveCallback2)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg, DWORD dwFlags) PURE;
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD_(BOOL, GetBoxEnable)(THIS) PURE;
    STDMETHOD(GetAxes)(THIS_ LPD3DVECTOR dir, LPD3DVECTOR up);
    STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD_(BOOL, GetInheritAxes)(THIS);
    STDMETHOD(GetHierarchyBox)(THIS_ LPD3DRMBOX) PURE;

    STDMETHOD(SetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(SetBoxEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetAxes)(THIS_ D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
                       D3DVALUE ux, D3DVALUE uy, D3DVALUE uz);
    STDMETHOD(SetInheritAxes)(THIS_ BOOL inherit_from_parent);
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetQuaternion)(THIS_ LPDIRECT3DRMFRAME reference, D3DRMQUATERNION *q) PURE;

    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DRMRAY ray, DWORD dwFlags, LPDIRECT3DRMPICKED2ARRAY *return_visuals) PURE;
    STDMETHOD(Save)(THIS_ LPCSTR filename, D3DRMXOFFORMAT d3dFormat, 
                    D3DRMSAVEOPTIONS d3dSaveFlags);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame3

DECLARE_INTERFACE_(IDirect3DRMFrame3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame3 methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME3 child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAME3MOVECALLBACK, VOID *arg, DWORD dwFlags) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(GetTransform)(THIS_ LPDIRECT3DRMFRAME3 reference,
                             D3DRMMATRIX4D rmMatrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDWORD lpdwCount, LPUNKNOWN *) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME3 target, LPDIRECT3DRMFRAME3 reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAME3MOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (   THIS_ LPDIRECT3DRMFRAME3 reference,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD_(BOOL, GetBoxEnable)(THIS) PURE;
    STDMETHOD(GetAxes)(THIS_ LPD3DVECTOR dir, LPD3DVECTOR up);
    STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2 *) PURE;
    STDMETHOD_(BOOL, GetInheritAxes)(THIS);
    STDMETHOD(GetHierarchyBox)(THIS_ LPD3DRMBOX) PURE;

    STDMETHOD(SetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(SetBoxEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetAxes)(THIS_ D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
                       D3DVALUE ux, D3DVALUE uy, D3DVALUE uz);
    STDMETHOD(SetInheritAxes)(THIS_ BOOL inherit_from_parent);
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
    STDMETHOD(SetQuaternion)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DRMQUATERNION *q) PURE;

    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DRMRAY ray, DWORD dwFlags, LPDIRECT3DRMPICKED2ARRAY *return_visuals) PURE;
    STDMETHOD(Save)(THIS_ LPCSTR filename, D3DRMXOFFORMAT d3dFormat, 
                    D3DRMSAVEOPTIONS d3dSaveFlags);
    STDMETHOD(TransformVectors)(THIS_ LPDIRECT3DRMFRAME3 reference,
                                DWORD dwNumVectors,
                                LPD3DVECTOR lpDstVectors,
                                LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(InverseTransformVectors)(THIS_ LPDIRECT3DRMFRAME3 reference,
                                       DWORD dwNumVectors,
                                       LPD3DVECTOR lpDstVectors,
                                       LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(SetTraversalOptions)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetTraversalOptions)(THIS_ LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetSceneFogMethod)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetSceneFogMethod)(THIS_ LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetMaterialOverride)(THIS_ LPD3DRMMATERIALOVERRIDE) PURE;
    STDMETHOD(GetMaterialOverride)(THIS_ LPD3DRMMATERIALOVERRIDE) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMesh

DECLARE_INTERFACE_(IDirect3DRMMesh, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMesh methods
     */
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(AddGroup)(THIS_ unsigned vCount, unsigned fCount, unsigned vPerFace, unsigned *fData, D3DRMGROUPINDEX *returnId) PURE;
    STDMETHOD(SetVertices)(THIS_ D3DRMGROUPINDEX id, unsigned index, unsigned count, D3DRMVERTEX *values) PURE;
    STDMETHOD(SetGroupColor)(THIS_ D3DRMGROUPINDEX id, D3DCOLOR value) PURE;
    STDMETHOD(SetGroupColorRGB)(THIS_ D3DRMGROUPINDEX id, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetGroupMapping)(THIS_ D3DRMGROUPINDEX id, D3DRMMAPPING value) PURE;
    STDMETHOD(SetGroupQuality)(THIS_ D3DRMGROUPINDEX id, D3DRMRENDERQUALITY value) PURE;
    STDMETHOD(SetGroupMaterial)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMMATERIAL value) PURE;
    STDMETHOD(SetGroupTexture)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMTEXTURE value) PURE;

    STDMETHOD_(unsigned, GetGroupCount)(THIS) PURE;
    STDMETHOD(GetGroup)(THIS_ D3DRMGROUPINDEX id, unsigned *vCount, unsigned *fCount, unsigned *vPerFace, DWORD *fDataSize, unsigned *fData) PURE;
    STDMETHOD(GetVertices)(THIS_ D3DRMGROUPINDEX id, DWORD index, DWORD count, D3DRMVERTEX *returnPtr) PURE;
    STDMETHOD_(D3DCOLOR, GetGroupColor)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD_(D3DRMMAPPING, GetGroupMapping)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetGroupQuality)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD(GetGroupMaterial)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMMATERIAL *returnPtr) PURE;
    STDMETHOD(GetGroupTexture)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMTEXTURE *returnPtr) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMProgressiveMesh

DECLARE_INTERFACE_(IDirect3DRMProgressiveMesh, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMProgressiveMesh methods
     */
    STDMETHOD(Load) (THIS_ LPVOID lpObjLocation, LPVOID lpObjId, 
                     D3DRMLOADOPTIONS dloLoadflags, D3DRMLOADTEXTURECALLBACK lpCallback,
                     LPVOID lpArg) PURE;
    STDMETHOD(GetLoadStatus) (THIS_ LPD3DRMPMESHLOADSTATUS lpStatus) PURE;
    STDMETHOD(SetMinRenderDetail) (THIS_ D3DVALUE d3dVal) PURE;
    STDMETHOD(Abort) (THIS_ DWORD dwFlags) PURE;
    
    STDMETHOD(GetFaceDetail) (THIS_ LPDWORD lpdwCount) PURE;
    STDMETHOD(GetVertexDetail) (THIS_ LPDWORD lpdwCount) PURE;
    STDMETHOD(SetFaceDetail) (THIS_ DWORD dwCount) PURE;
    STDMETHOD(SetVertexDetail) (THIS_ DWORD dwCount) PURE;
    STDMETHOD(GetFaceDetailRange) (THIS_ LPDWORD lpdwMin, LPDWORD lpdwMax) PURE;
    STDMETHOD(GetVertexDetailRange) (THIS_ LPDWORD lpdwMin, LPDWORD lpdwMax) PURE;
    STDMETHOD(GetDetail) (THIS_ D3DVALUE *lpdvVal) PURE;
    STDMETHOD(SetDetail) (THIS_ D3DVALUE d3dVal) PURE;

    STDMETHOD(RegisterEvents) (THIS_ HANDLE hEvent, DWORD dwFlags, DWORD dwReserved) PURE;
    STDMETHOD(CreateMesh) (THIS_ LPDIRECT3DRMMESH *lplpD3DRMMesh) PURE;
    STDMETHOD(Duplicate) (THIS_ LPDIRECT3DRMPROGRESSIVEMESH *lplpD3DRMPMesh) PURE;
    STDMETHOD(GetBox) (THIS_ LPD3DRMBOX lpBBox) PURE;
    STDMETHOD(SetQuality) (THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(GetQuality) (THIS_ LPD3DRMRENDERQUALITY lpdwquality) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMShadow

DECLARE_INTERFACE_(IDirect3DRMShadow, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMShadow methods
     */
    STDMETHOD(Init)
    (   THIS_ LPDIRECT3DRMVISUAL visual, LPDIRECT3DRMLIGHT light,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz
    ) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMShadow2

DECLARE_INTERFACE_(IDirect3DRMShadow2, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMShadow methods
     */
    STDMETHOD(Init)
    (   THIS_ LPUNKNOWN pUNK, LPDIRECT3DRMLIGHT light,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz
    ) PURE;

    /*
     * IDirect3DRMShadow2 methods
     */
    STDMETHOD(GetVisual)(THIS_ LPDIRECT3DRMVISUAL *) PURE;
    STDMETHOD(SetVisual)(THIS_ LPUNKNOWN pUNK, DWORD) PURE;
    STDMETHOD(GetLight)(THIS_ LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(SetLight)(THIS_ LPDIRECT3DRMLIGHT, DWORD) PURE;
    STDMETHOD(GetPlane)(THIS_ LPD3DVALUE px, LPD3DVALUE py, LPD3DVALUE pz,
                        LPD3DVALUE nx, LPD3DVALUE ny, LPD3DVALUE nz) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE px, D3DVALUE py, D3DVALUE pz,
                        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz, DWORD) PURE;
    STDMETHOD(GetOptions)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetOptions)(THIS_ DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFace

DECLARE_INTERFACE_(IDirect3DRMFace, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFace methods
     */
     STDMETHOD(AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
     STDMETHOD(AddVertexAndNormalIndexed)(THIS_ DWORD vertex, DWORD normal) PURE;
     STDMETHOD(SetColorRGB)(THIS_ D3DVALUE, D3DVALUE, D3DVALUE) PURE;
     STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
     STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
     STDMETHOD(SetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE u, D3DVALUE v) PURE;
     STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
     STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;

     STDMETHOD(GetVertex)(THIS_ DWORD index, D3DVECTOR *vertex, D3DVECTOR *normal) PURE;
     STDMETHOD(GetVertices)(THIS_ DWORD *vertex_count, D3DVECTOR *coords, D3DVECTOR *normals);
     STDMETHOD(GetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE *u, D3DVALUE *v) PURE;
     STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
     STDMETHOD(GetNormal)(THIS_ D3DVECTOR *) PURE;
     STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
     STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL *) PURE;

     STDMETHOD_(int, GetVertexCount)(THIS) PURE;
     STDMETHOD_(int, GetVertexIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(int, GetTextureCoordinateIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(AddFaces)
    (   THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
        DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;

    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetVertices)
    (   THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;

    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE*) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;

    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder2

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder2, IDirect3DRMMeshBuilder)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(AddFaces)
    (   THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
        DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;

    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetVertices)
    (   THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;

    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE*) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;

    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;

    /*
     * IDirect3DRMMeshBuilder2 methods
     */
    STDMETHOD(GenerateNormals2)(THIS_ D3DVALUE crease, DWORD dwFlags) PURE;
    STDMETHOD(GetFace)(THIS_ DWORD index, LPDIRECT3DRMFACE*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder3

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder3 methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS_ D3DVALUE crease, DWORD dwFlags) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER3) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(AddFaces)
    (   THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
        DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetGeometry)
    (   THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;
    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE*) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;
    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;
    STDMETHOD(GetFace)(THIS_ DWORD index, LPDIRECT3DRMFACE*) PURE;
    STDMETHOD(GetVertex)(THIS_ DWORD dwIndex, LPD3DVECTOR lpVector) PURE;
    STDMETHOD(GetNormal)(THIS_ DWORD dwIndex, LPD3DVECTOR lpVector) PURE;
    STDMETHOD(DeleteVertices)(THIS_ DWORD dwIndexFirst, DWORD dwCount) PURE;
    STDMETHOD(DeleteNormals)(THIS_ DWORD dwIndexFirst, DWORD dwCount) PURE;
    STDMETHOD(DeleteFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(Empty)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(AddFacesIndexed)(THIS_ DWORD dwFlags, DWORD *lpdwvIndices, DWORD *dwIndexFirst, DWORD *dwCount) PURE;
    STDMETHOD(CreateSubMesh)(THIS_ LPUNKNOWN *) PURE;
    STDMETHOD(GetParentMesh)(THIS_ DWORD, LPUNKNOWN *) PURE;
    STDMETHOD(GetSubMeshes)(THIS_ LPDWORD lpdwCount, LPUNKNOWN *) PURE;
    STDMETHOD(DeleteSubMesh)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD(Enable)(THIS_ DWORD) PURE;
    STDMETHOD(GetEnable)(THIS_ DWORD *) PURE;
    STDMETHOD(AddTriangles)(THIS_ DWORD dwFlags, DWORD dwFormat,
                            DWORD dwVertexCount, LPVOID lpvData) PURE;
    STDMETHOD(SetVertices)(THIS_ DWORD dwIndexFirst, DWORD dwCount, LPD3DVECTOR) PURE;
    STDMETHOD(GetVertices)(THIS_ DWORD dwIndexFirst, LPDWORD lpdwCount, LPD3DVECTOR) PURE;
    STDMETHOD(SetNormals)(THIS_ DWORD dwIndexFirst, DWORD dwCount, LPD3DVECTOR) PURE;
    STDMETHOD(GetNormals)(THIS_ DWORD dwIndexFirst, LPDWORD lpdwCount, LPD3DVECTOR) PURE;
    STDMETHOD_(int, GetNormalCount)(THIS) PURE;
};  

#undef INTERFACE
#define INTERFACE IDirect3DRMLight

DECLARE_INTERFACE_(IDirect3DRMLight, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMLight methods
     */
    STDMETHOD(SetType)(THIS_ D3DRMLIGHTTYPE) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetRange)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUmbra)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetPenumbra)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetConstantAttenuation)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetLinearAttenuation)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetQuadraticAttenuation)(THIS_ D3DVALUE) PURE;

    STDMETHOD_(D3DVALUE, GetRange)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetUmbra)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetPenumbra)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetConstantAttenuation)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetLinearAttenuation)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetQuadraticAttenuation)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD_(D3DRMLIGHTTYPE, GetType)(THIS) PURE;

    STDMETHOD(SetEnableFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(GetEnableFrame)(THIS_ LPDIRECT3DRMFRAME*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture

DECLARE_INTERFACE_(IDirect3DRMTexture, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ BOOL pixels, BOOL palette) PURE;

    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture2

DECLARE_INTERFACE_(IDirect3DRMTexture2, IDirect3DRMTexture)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ BOOL pixels, BOOL palette) PURE;

    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;

    /*
     * IDirect3DRMTexture2 methods
     */
    STDMETHOD(InitFromImage)(THIS_ LPD3DRMIMAGE) PURE;
    STDMETHOD(InitFromResource2)(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType) PURE;
    STDMETHOD(GenerateMIPMap)(THIS_ DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture3

DECLARE_INTERFACE_(IDirect3DRMTexture3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture3 methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ DWORD dwFlags, DWORD dwcRects, LPRECT pRects) PURE;
    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;
    STDMETHOD(InitFromImage)(THIS_ LPD3DRMIMAGE) PURE;
    STDMETHOD(InitFromResource2)(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType) PURE;
    STDMETHOD(GenerateMIPMap)(THIS_ DWORD) PURE;
    STDMETHOD(GetSurface)(THIS_ DWORD dwFlags, LPDIRECTDRAWSURFACE* lplpDDS) PURE;
    STDMETHOD(SetCacheOptions)(THIS_ LONG lImportance, DWORD dwFlags) PURE;
    STDMETHOD(GetCacheOptions)(THIS_ LPLONG lplImportance, LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetDownsampleCallback)(THIS_ D3DRMDOWNSAMPLECALLBACK pCallback, LPVOID pArg) PURE;
    STDMETHOD(SetValidationCallback)(THIS_ D3DRMVALIDATIONCALLBACK pCallback, LPVOID pArg) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMWrap

DECLARE_INTERFACE_(IDirect3DRMWrap, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWrap methods
     */
    STDMETHOD(Init)
    (   THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME ref,
        D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
        D3DVALUE ou, D3DVALUE ov,
        D3DVALUE su, D3DVALUE sv
    ) PURE;
    STDMETHOD(Apply)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(ApplyRelative)(THIS_ LPDIRECT3DRMFRAME frame, LPDIRECT3DRMOBJECT) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMaterial

DECLARE_INTERFACE_(IDirect3DRMMaterial, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMaterial methods
     */
    STDMETHOD(SetPower)(THIS_ D3DVALUE power) PURE;
    STDMETHOD(SetSpecular)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD(SetEmissive)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;

    STDMETHOD_(D3DVALUE, GetPower)(THIS) PURE;
    STDMETHOD(GetSpecular)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetEmissive)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMMaterial2

DECLARE_INTERFACE_(IDirect3DRMMaterial2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMaterial2 methods
     */
    STDMETHOD(SetPower)(THIS_ D3DVALUE power) PURE;
    STDMETHOD(SetSpecular)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD(SetEmissive)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD_(D3DVALUE, GetPower)(THIS) PURE;
    STDMETHOD(GetSpecular)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetEmissive)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetAmbient)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(SetAmbient)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMAnimation

DECLARE_INTERFACE_(IDirect3DRMAnimation, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimation methods
     */
    STDMETHOD(SetOptions)(THIS_ D3DRMANIMATIONOPTIONS flags) PURE;
    STDMETHOD(AddRotateKey)(THIS_ D3DVALUE time, D3DRMQUATERNION *q) PURE;
    STDMETHOD(AddPositionKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScaleKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(DeleteKey)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(SetFrame)(THIS_ LPDIRECT3DRMFRAME frame) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;

    STDMETHOD_(D3DRMANIMATIONOPTIONS, GetOptions)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimation2

DECLARE_INTERFACE_(IDirect3DRMAnimation2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimation2 methods
     */
    STDMETHOD(SetOptions)(THIS_ D3DRMANIMATIONOPTIONS flags) PURE;
    STDMETHOD(AddRotateKey)(THIS_ D3DVALUE time, D3DRMQUATERNION *q) PURE;
    STDMETHOD(AddPositionKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScaleKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(DeleteKey)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(SetFrame)(THIS_ LPDIRECT3DRMFRAME3 frame) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;

    STDMETHOD_(D3DRMANIMATIONOPTIONS, GetOptions)(THIS) PURE;
    STDMETHOD(GetFrame)(THIS_ LPDIRECT3DRMFRAME3 *lpD3DFrame) PURE;
    STDMETHOD(DeleteKeyByID)(THIS_ DWORD dwID) PURE;
    STDMETHOD(AddKey)(THIS_ LPD3DRMANIMATIONKEY lpKey) PURE;
    STDMETHOD(ModifyKey)(THIS_ LPD3DRMANIMATIONKEY lpKey) PURE;
    STDMETHOD(GetKeys)(THIS_ D3DVALUE dvTimeMin,
                       D3DVALUE dvTimeMax, LPDWORD lpdwNumKeys,
                       LPD3DRMANIMATIONKEY lpKey);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationSet

DECLARE_INTERFACE_(IDirect3DRMAnimationSet, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimationSet methods
     */
    STDMETHOD(AddAnimation)(THIS_ LPDIRECT3DRMANIMATION aid) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg, LPDIRECT3DRMFRAME parent)PURE;
    STDMETHOD(DeleteAnimation)(THIS_ LPDIRECT3DRMANIMATION aid) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationSet2

DECLARE_INTERFACE_(IDirect3DRMAnimationSet2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimationSet2 methods
     */
    STDMETHOD(AddAnimation)(THIS_ LPDIRECT3DRMANIMATION2 aid) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg, LPDIRECT3DRMFRAME3 parent)PURE;
    STDMETHOD(DeleteAnimation)(THIS_ LPDIRECT3DRMANIMATION2 aid) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(GetAnimations)(THIS_ LPDIRECT3DRMANIMATIONARRAY *) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMUserVisual

DECLARE_INTERFACE_(IDirect3DRMUserVisual, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMUserVisual methods
     */
    STDMETHOD(Init)(THIS_ D3DRMUSERVISUALCALLBACK fn, void *arg) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMArray

DECLARE_INTERFACE_(IDirect3DRMArray, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    /* No GetElement method as it would get overloaded
     * in derived classes, and overloading is
     * a no-no in COM
     */
};

#undef INTERFACE
#define INTERFACE IDirect3DRMObjectArray

DECLARE_INTERFACE_(IDirect3DRMObjectArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMOBJECT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDeviceArray

DECLARE_INTERFACE_(IDirect3DRMDeviceArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMDEVICE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrameArray

DECLARE_INTERFACE_(IDirect3DRMFrameArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMFRAME *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMViewportArray

DECLARE_INTERFACE_(IDirect3DRMViewportArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMVisualArray

DECLARE_INTERFACE_(IDirect3DRMVisualArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationArray

DECLARE_INTERFACE_(IDirect3DRMAnimationArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMANIMATION2 *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMPickedArray

DECLARE_INTERFACE_(IDirect3DRMPickedArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetPick)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *, LPDIRECT3DRMFRAMEARRAY *, LPD3DRMPICKDESC) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMLightArray

DECLARE_INTERFACE_(IDirect3DRMLightArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMLIGHT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFaceArray

DECLARE_INTERFACE_(IDirect3DRMFaceArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMFACE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMPicked2Array

DECLARE_INTERFACE_(IDirect3DRMPicked2Array, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetPick)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *, LPDIRECT3DRMFRAMEARRAY *, LPD3DRMPICKDESC2) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMInterpolator

DECLARE_INTERFACE_(IDirect3DRMInterpolator, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMInterpolator methods
     */
    STDMETHOD(AttachObject)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(GetAttachedObjects)(THIS_ LPDIRECT3DRMOBJECTARRAY *) PURE;
    STDMETHOD(DetachObject)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(SetIndex)(THIS_ D3DVALUE) PURE;
    STDMETHOD_(D3DVALUE, GetIndex)(THIS) PURE;
    STDMETHOD(Interpolate)(THIS_ D3DVALUE, LPDIRECT3DRMOBJECT, D3DRMINTERPOLATIONOPTIONS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMClippedVisual

DECLARE_INTERFACE_(IDirect3DRMClippedVisual, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMClippedVisual methods
     */
    STDMETHOD(Init) (THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(AddPlane) (THIS_ LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD, LPDWORD) PURE;
    STDMETHOD(DeletePlane)(THIS_ DWORD, DWORD) PURE;
    STDMETHOD(GetPlaneIDs)(THIS_ LPDWORD, LPDWORD, DWORD) PURE;
    STDMETHOD(GetPlane) (THIS_ DWORD, LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD) PURE;
    STDMETHOD(SetPlane) (THIS_ DWORD, LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD) PURE;
};

#ifdef __cplusplus
};
#endif
#endif /* _D3DRMOBJ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\d3drmwin.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRMWIN_H__
#define __D3DRMWIN_H__

#ifndef WIN32
#define WIN32
#endif

#include "d3drm.h"

#include "ddraw.h"
#include "d3d.h"

/*
 * GUIDS used by Direct3DRM Windows interface
 */
DEFINE_GUID(IID_IDirect3DRMWinDevice,   0xc5016cc0, 0xd273, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

WIN_TYPES(IDirect3DRMWinDevice, DIRECT3DRMWINDEVICE);

#undef INTERFACE
#define INTERFACE IDirect3DRMWinDevice

DECLARE_INTERFACE_(IDirect3DRMWinDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWinDevice methods
     */

    /* Repaint the window with the last frame which was rendered. */
    STDMETHOD(HandlePaint)(THIS_ HDC hdc) PURE;

    /* Respond to a WM_ACTIVATE message. */
    STDMETHOD(HandleActivate)(THIS_ WORD wparam) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\d3drmdef.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRMDEFS_H__
#define __D3DRMDEFS_H__

#include <stddef.h>
#include "d3dtypes.h"

#ifdef WIN32
#define D3DRMAPI  __stdcall
#else
#define D3DRMAPI
#endif

#if defined(__cplusplus)
extern "C" {
#endif

#ifndef TRUE
#define FALSE 0
#define TRUE 1
#endif

typedef struct _D3DRMVECTOR4D
{   D3DVALUE x, y, z, w;
} D3DRMVECTOR4D, *LPD3DRMVECTOR4D;

typedef D3DVALUE D3DRMMATRIX4D[4][4];

typedef struct _D3DRMQUATERNION
{   D3DVALUE s;
    D3DVECTOR v;
} D3DRMQUATERNION, *LPD3DRMQUATERNION;

typedef struct _D3DRMRAY
{   D3DVECTOR dvDir;
    D3DVECTOR dvPos;
} D3DRMRAY, *LPD3DRMRAY;

typedef struct _D3DRMBOX
{   D3DVECTOR min, max;
} D3DRMBOX, *LPD3DRMBOX;

typedef void (*D3DRMWRAPCALLBACK)
    (LPD3DVECTOR, int* u, int* v, LPD3DVECTOR a, LPD3DVECTOR b, LPVOID);

typedef enum _D3DRMLIGHTTYPE
{   D3DRMLIGHT_AMBIENT,
    D3DRMLIGHT_POINT,
    D3DRMLIGHT_SPOT,
    D3DRMLIGHT_DIRECTIONAL,
    D3DRMLIGHT_PARALLELPOINT
} D3DRMLIGHTTYPE, *LPD3DRMLIGHTTYPE;

typedef enum _D3DRMSHADEMODE {
    D3DRMSHADE_FLAT     = 0,
    D3DRMSHADE_GOURAUD  = 1,
    D3DRMSHADE_PHONG    = 2,

    D3DRMSHADE_MASK     = 7,
    D3DRMSHADE_MAX      = 8
} D3DRMSHADEMODE, *LPD3DRMSHADEMODE;

typedef enum _D3DRMLIGHTMODE {
    D3DRMLIGHT_OFF      = 0 * D3DRMSHADE_MAX,
    D3DRMLIGHT_ON       = 1 * D3DRMSHADE_MAX,

    D3DRMLIGHT_MASK     = 7 * D3DRMSHADE_MAX,
    D3DRMLIGHT_MAX      = 8 * D3DRMSHADE_MAX
} D3DRMLIGHTMODE, *LPD3DRMLIGHTMODE;

typedef enum _D3DRMFILLMODE {
    D3DRMFILL_POINTS    = 0 * D3DRMLIGHT_MAX,
    D3DRMFILL_WIREFRAME = 1 * D3DRMLIGHT_MAX,
    D3DRMFILL_SOLID     = 2 * D3DRMLIGHT_MAX,

    D3DRMFILL_MASK      = 7 * D3DRMLIGHT_MAX,
    D3DRMFILL_MAX       = 8 * D3DRMLIGHT_MAX
} D3DRMFILLMODE, *LPD3DRMFILLMODE;

typedef DWORD D3DRMRENDERQUALITY, *LPD3DRMRENDERQUALITY;

#define D3DRMRENDER_WIREFRAME   (D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_WIREFRAME)
#define D3DRMRENDER_UNLITFLAT   (D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_SOLID)
#define D3DRMRENDER_FLAT        (D3DRMSHADE_FLAT+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_GOURAUD     (D3DRMSHADE_GOURAUD+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_PHONG       (D3DRMSHADE_PHONG+D3DRMLIGHT_ON+D3DRMFILL_SOLID)

#define D3DRMRENDERMODE_BLENDEDTRANSPARENCY     1
#define D3DRMRENDERMODE_SORTEDTRANSPARENCY      2
#define D3DRMRENDERMODE_LIGHTINMODELSPACE       8
#define D3DRMRENDERMODE_VIEWDEPENDENTSPECULAR   16

typedef enum _D3DRMTEXTUREQUALITY
{   D3DRMTEXTURE_NEAREST,               /* choose nearest texel */
    D3DRMTEXTURE_LINEAR,                /* interpolate 4 texels */
    D3DRMTEXTURE_MIPNEAREST,            /* nearest texel in nearest mipmap  */
    D3DRMTEXTURE_MIPLINEAR,             /* interpolate 2 texels from 2 mipmaps */
    D3DRMTEXTURE_LINEARMIPNEAREST,      /* interpolate 4 texels in nearest mipmap */
    D3DRMTEXTURE_LINEARMIPLINEAR        /* interpolate 8 texels from 2 mipmaps */
} D3DRMTEXTUREQUALITY, *LPD3DRMTEXTUREQUALITY;

/*
 * Texture flags
 */
#define D3DRMTEXTURE_FORCERESIDENT          0x00000001 /* texture should be kept in video memory */
#define D3DRMTEXTURE_STATIC                 0x00000002 /* texture will not change */
#define D3DRMTEXTURE_DOWNSAMPLEPOINT        0x00000004 /* point filtering should be used when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLEBILINEAR     0x00000008 /* bilinear filtering should be used when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLEREDUCEDEPTH  0x00000010 /* reduce bit depth when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLENONE         0x00000020 /* texture should never be downsampled */
#define D3DRMTEXTURE_CHANGEDPIXELS          0x00000040 /* pixels have changed */
#define D3DRMTEXTURE_CHANGEDPALETTE         0x00000080 /* palette has changed */
#define D3DRMTEXTURE_INVALIDATEONLY         0x00000100 /* dirty regions are invalid */

/*
 * Shadow flags
 */
#define D3DRMSHADOW_TRUEALPHA               0x00000001 /* shadow should render without artifacts when true alpha is on */

typedef enum _D3DRMCOMBINETYPE
{   D3DRMCOMBINE_REPLACE,
    D3DRMCOMBINE_BEFORE,
    D3DRMCOMBINE_AFTER
} D3DRMCOMBINETYPE, *LPD3DRMCOMBINETYPE;

typedef D3DCOLORMODEL D3DRMCOLORMODEL, *LPD3DRMCOLORMODEL;

typedef enum _D3DRMPALETTEFLAGS
{   D3DRMPALETTE_FREE,                  /* renderer may use this entry freely */
    D3DRMPALETTE_READONLY,              /* fixed but may be used by renderer */
    D3DRMPALETTE_RESERVED               /* may not be used by renderer */
} D3DRMPALETTEFLAGS, *LPD3DRMPALETTEFLAGS;

typedef struct _D3DRMPALETTEENTRY
{   unsigned char red;          /* 0 .. 255 */
    unsigned char green;        /* 0 .. 255 */
    unsigned char blue;         /* 0 .. 255 */
    unsigned char flags;        /* one of D3DRMPALETTEFLAGS */
} D3DRMPALETTEENTRY, *LPD3DRMPALETTEENTRY;

typedef struct _D3DRMIMAGE
{   int width, height;          /* width and height in pixels */
    int aspectx, aspecty;       /* aspect ratio for non-square pixels */
    int depth;                  /* bits per pixel */
    int rgb;                    /* if false, pixels are indices into a
                                   palette otherwise, pixels encode
                                   RGB values. */
    int bytes_per_line;         /* number of bytes of memory for a
                                   scanline. This must be a multiple
                                   of 4. */
    void* buffer1;              /* memory to render into (first buffer). */
    void* buffer2;              /* second rendering buffer for double
                                   buffering, set to NULL for single
                                   buffering. */
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    unsigned long alpha_mask;   /* if rgb is true, these are masks for
                                   the red, green and blue parts of a
                                   pixel.  Otherwise, these are masks
                                   for the significant bits of the
                                   red, green and blue elements in the
                                   palette.  For instance, most SVGA
                                   displays use 64 intensities of red,
                                   green and blue, so the masks should
                                   all be set to 0xfc. */
    int palette_size;           /* number of entries in palette */
    D3DRMPALETTEENTRY* palette; /* description of the palette (only if
                                   rgb is false).  Must be (1<<depth)
                                   elements. */
} D3DRMIMAGE, *LPD3DRMIMAGE;

typedef enum _D3DRMWRAPTYPE
{   D3DRMWRAP_FLAT,
    D3DRMWRAP_CYLINDER,
    D3DRMWRAP_SPHERE,
    D3DRMWRAP_CHROME
} D3DRMWRAPTYPE, *LPD3DRMWRAPTYPE;

#define D3DRMWIREFRAME_CULL             1 /* cull backfaces */
#define D3DRMWIREFRAME_HIDDENLINE       2 /* lines are obscured by closer objects */

/*
 * Do not use righthanded perspective in Viewport2::SetProjection().
 * Set up righthanded mode by using IDirect3DRM3::SetOptions().
 */
typedef enum _D3DRMPROJECTIONTYPE
{   D3DRMPROJECT_PERSPECTIVE,
    D3DRMPROJECT_ORTHOGRAPHIC,
    D3DRMPROJECT_RIGHTHANDPERSPECTIVE, /* Only valid pre-DX6 */
    D3DRMPROJECT_RIGHTHANDORTHOGRAPHIC /* Only valid pre-DX6 */
} D3DRMPROJECTIONTYPE, *LPD3DRMPROJECTIONTYPE;

#define D3DRMOPTIONS_LEFTHANDED  0x00000001L /* Default */
#define D3DRMOPTIONS_RIGHTHANDED 0x00000002L

typedef enum _D3DRMXOFFORMAT
{   D3DRMXOF_BINARY,
    D3DRMXOF_COMPRESSED,
    D3DRMXOF_TEXT
} D3DRMXOFFORMAT, *LPD3DRMXOFFORMAT;

typedef DWORD D3DRMSAVEOPTIONS;
#define D3DRMXOFSAVE_NORMALS 1
#define D3DRMXOFSAVE_TEXTURECOORDINATES 2
#define D3DRMXOFSAVE_MATERIALS 4
#define D3DRMXOFSAVE_TEXTURENAMES 8
#define D3DRMXOFSAVE_ALL 15
#define D3DRMXOFSAVE_TEMPLATES 16
#define D3DRMXOFSAVE_TEXTURETOPOLOGY 32

typedef enum _D3DRMCOLORSOURCE
{   D3DRMCOLOR_FROMFACE,
    D3DRMCOLOR_FROMVERTEX
} D3DRMCOLORSOURCE, *LPD3DRMCOLORSOURCE;

typedef enum _D3DRMFRAMECONSTRAINT
{   D3DRMCONSTRAIN_Z,           /* use only X and Y rotations */
    D3DRMCONSTRAIN_Y,           /* use only X and Z rotations */
    D3DRMCONSTRAIN_X            /* use only Y and Z rotations */
} D3DRMFRAMECONSTRAINT, *LPD3DRMFRAMECONSTRAINT;

typedef enum _D3DRMMATERIALMODE
{   D3DRMMATERIAL_FROMMESH,
    D3DRMMATERIAL_FROMPARENT,
    D3DRMMATERIAL_FROMFRAME
} D3DRMMATERIALMODE, *LPD3DRMMATERIALMODE;

typedef enum _D3DRMFOGMODE
{   D3DRMFOG_LINEAR,            /* linear between start and end */
    D3DRMFOG_EXPONENTIAL,       /* density * exp(-distance) */
    D3DRMFOG_EXPONENTIALSQUARED /* density * exp(-distance*distance) */
} D3DRMFOGMODE, *LPD3DRMFOGMODE;

typedef enum _D3DRMZBUFFERMODE {
    D3DRMZBUFFER_FROMPARENT,    /* default */
    D3DRMZBUFFER_ENABLE,        /* enable zbuffering */
    D3DRMZBUFFER_DISABLE        /* disable zbuffering */
} D3DRMZBUFFERMODE, *LPD3DRMZBUFFERMODE;

typedef enum _D3DRMSORTMODE {
    D3DRMSORT_FROMPARENT,       /* default */
    D3DRMSORT_NONE,             /* don't sort child frames */
    D3DRMSORT_FRONTTOBACK,      /* sort child frames front-to-back */
    D3DRMSORT_BACKTOFRONT       /* sort child frames back-to-front */
} D3DRMSORTMODE, *LPD3DRMSORTMODE;

typedef struct _D3DRMMATERIALOVERRIDE
{
    DWORD         dwSize;       /* Size of this structure */
    DWORD         dwFlags;      /* Indicate which fields are valid */
    D3DCOLORVALUE dcDiffuse;    /* RGBA */
    D3DCOLORVALUE dcAmbient;    /* RGB */
    D3DCOLORVALUE dcEmissive;   /* RGB */
    D3DCOLORVALUE dcSpecular;   /* RGB */
    D3DVALUE      dvPower;
    LPUNKNOWN     lpD3DRMTex;
} D3DRMMATERIALOVERRIDE, *LPD3DRMMATERIALOVERRIDE;

#define D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAONLY     0x00000001L
#define D3DRMMATERIALOVERRIDE_DIFFUSE_RGBONLY       0x00000002L
#define D3DRMMATERIALOVERRIDE_DIFFUSE               0x00000003L
#define D3DRMMATERIALOVERRIDE_AMBIENT               0x00000004L
#define D3DRMMATERIALOVERRIDE_EMISSIVE              0x00000008L
#define D3DRMMATERIALOVERRIDE_SPECULAR              0x00000010L
#define D3DRMMATERIALOVERRIDE_POWER                 0x00000020L
#define D3DRMMATERIALOVERRIDE_TEXTURE               0x00000040L
#define D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAMULTIPLY 0x00000080L
#define D3DRMMATERIALOVERRIDE_ALL                   0x000000FFL

#define D3DRMFPTF_ALPHA                           0x00000001L
#define D3DRMFPTF_NOALPHA                         0x00000002L
#define D3DRMFPTF_PALETTIZED                      0x00000004L
#define D3DRMFPTF_NOTPALETTIZED                   0x00000008L

/*
 * Values for flags in RM3::CreateDeviceFromSurface
 */
#define D3DRMDEVICE_NOZBUFFER           0x00000001L

/*
 * Values for flags in Object2::SetClientData
 */
#define D3DRMCLIENTDATA_NONE            0x00000001L
#define D3DRMCLIENTDATA_LOCALFREE       0x00000002L
#define D3DRMCLIENTDATA_IUNKNOWN        0x00000004L

/*
 * Values for flags in Frame2::AddMoveCallback.
 */
#define D3DRMCALLBACK_PREORDER          0
#define D3DRMCALLBACK_POSTORDER         1

/*
 * Values for flags in MeshBuilder2::RayPick.
 */
#define D3DRMRAYPICK_ONLYBOUNDINGBOXES          1
#define D3DRMRAYPICK_IGNOREFURTHERPRIMITIVES    2
#define D3DRMRAYPICK_INTERPOLATEUV              4
#define D3DRMRAYPICK_INTERPOLATECOLOR           8
#define D3DRMRAYPICK_INTERPOLATENORMAL          0x10    

/*
 * Values for flags in MeshBuilder3::AddFacesIndexed.
 */
#define D3DRMADDFACES_VERTICESONLY              1

/*
 * Values for flags in MeshBuilder2::GenerateNormals.
 */
#define D3DRMGENERATENORMALS_PRECOMPACT         1
#define D3DRMGENERATENORMALS_USECREASEANGLE     2

/*
 * Values for MeshBuilder3::GetParentMesh
 */
#define D3DRMMESHBUILDER_DIRECTPARENT           1
#define D3DRMMESHBUILDER_ROOTMESH               2

/*
 * Flags for MeshBuilder3::Enable
 */
#define D3DRMMESHBUILDER_RENDERENABLE   0x00000001L
#define D3DRMMESHBUILDER_PICKENABLE     0x00000002L

/*
 * Flags for Object2::GetAge when used with MeshBuilders
 */
#define D3DRMMESHBUILDERAGE_GEOMETRY    0x00000001L
#define D3DRMMESHBUILDERAGE_MATERIALS   0x00000002L
#define D3DRMMESHBUILDERAGE_TEXTURES    0x00000004L

/*
 * Format flags for MeshBuilder3::AddTriangles.
 */
#define D3DRMFVF_TYPE                   0x00000001L
#define D3DRMFVF_NORMAL                 0x00000002L
#define D3DRMFVF_COLOR                  0x00000004L
#define D3DRMFVF_TEXTURECOORDS          0x00000008L

#define D3DRMVERTEX_STRIP               0x00000001L
#define D3DRMVERTEX_FAN                 0x00000002L
#define D3DRMVERTEX_LIST                0x00000004L

/*
 * Values for flags in Viewport2::Clear2
 */
#define D3DRMCLEAR_TARGET               0x00000001L
#define D3DRMCLEAR_ZBUFFER              0x00000002L
#define D3DRMCLEAR_DIRTYRECTS           0x00000004L
#define D3DRMCLEAR_ALL                  (D3DRMCLEAR_TARGET | \
                                         D3DRMCLEAR_ZBUFFER | \
                                         D3DRMCLEAR_DIRTYRECTS)

/*
 * Values for flags in Frame3::SetSceneFogMethod
 */
#define D3DRMFOGMETHOD_VERTEX          0x00000001L
#define D3DRMFOGMETHOD_TABLE           0x00000002L
#define D3DRMFOGMETHOD_ANY             0x00000004L

/*
 * Values for flags in Frame3::SetTraversalOptions
 */
#define D3DRMFRAME_RENDERENABLE        0x00000001L
#define D3DRMFRAME_PICKENABLE          0x00000002L

typedef DWORD D3DRMANIMATIONOPTIONS;
#define D3DRMANIMATION_OPEN 0x01L
#define D3DRMANIMATION_CLOSED 0x02L
#define D3DRMANIMATION_LINEARPOSITION 0x04L
#define D3DRMANIMATION_SPLINEPOSITION 0x08L
#define D3DRMANIMATION_SCALEANDROTATION 0x00000010L
#define D3DRMANIMATION_POSITION 0x00000020L

typedef DWORD D3DRMINTERPOLATIONOPTIONS;
#define D3DRMINTERPOLATION_OPEN 0x01L
#define D3DRMINTERPOLATION_CLOSED 0x02L
#define D3DRMINTERPOLATION_NEAREST 0x0100L
#define D3DRMINTERPOLATION_LINEAR 0x04L
#define D3DRMINTERPOLATION_SPLINE 0x08L
#define D3DRMINTERPOLATION_VERTEXCOLOR 0x40L
#define D3DRMINTERPOLATION_SLERPNORMALS 0x80L

typedef DWORD D3DRMLOADOPTIONS;

#define D3DRMLOAD_FROMFILE  0x00L
#define D3DRMLOAD_FROMRESOURCE 0x01L
#define D3DRMLOAD_FROMMEMORY 0x02L
#define D3DRMLOAD_FROMSTREAM 0x04L
#define D3DRMLOAD_FROMURL 0x08L

#define D3DRMLOAD_BYNAME 0x10L
#define D3DRMLOAD_BYPOSITION 0x20L
#define D3DRMLOAD_BYGUID 0x40L
#define D3DRMLOAD_FIRST 0x80L

#define D3DRMLOAD_INSTANCEBYREFERENCE 0x100L
#define D3DRMLOAD_INSTANCEBYCOPYING 0x200L

#define D3DRMLOAD_ASYNCHRONOUS 0x400L

typedef struct _D3DRMLOADRESOURCE {
  HMODULE hModule;
  LPCTSTR lpName;
  LPCTSTR lpType;
} D3DRMLOADRESOURCE, *LPD3DRMLOADRESOURCE;

typedef struct _D3DRMLOADMEMORY {
  LPVOID lpMemory;
  DWORD dSize;
} D3DRMLOADMEMORY, *LPD3DRMLOADMEMORY;

#define D3DRMPMESHSTATUS_VALID 0x01L
#define D3DRMPMESHSTATUS_INTERRUPTED 0x02L
#define D3DRMPMESHSTATUS_BASEMESHCOMPLETE 0x04L
#define D3DRMPMESHSTATUS_COMPLETE 0x08L
#define D3DRMPMESHSTATUS_RENDERABLE 0x10L

#define D3DRMPMESHEVENT_BASEMESH 0x01L
#define D3DRMPMESHEVENT_COMPLETE 0x02L

typedef struct _D3DRMPMESHLOADSTATUS {
  DWORD dwSize;            // Size of this structure
  DWORD dwPMeshSize;       // Total Size (bytes)
  DWORD dwBaseMeshSize;    // Total Size of the Base Mesh
  DWORD dwBytesLoaded;     // Total bytes loaded
  DWORD dwVerticesLoaded;  // Number of vertices loaded
  DWORD dwFacesLoaded;     // Number of faces loaded
  HRESULT dwLoadResult;    // Result of the load operation
  DWORD dwFlags;
} D3DRMPMESHLOADSTATUS, *LPD3DRMPMESHLOADSTATUS;

typedef enum _D3DRMUSERVISUALREASON {
    D3DRMUSERVISUAL_CANSEE,
    D3DRMUSERVISUAL_RENDER
} D3DRMUSERVISUALREASON, *LPD3DRMUSERVISUALREASON;


typedef struct _D3DRMANIMATIONKEY 
{
    DWORD dwSize;
    DWORD dwKeyType;
    D3DVALUE dvTime;
    DWORD dwID;
#if (!defined __cplusplus) || (!defined D3D_OVERLOADS)
    union 
    {
        D3DRMQUATERNION dqRotateKey;
        D3DVECTOR dvScaleKey;
        D3DVECTOR dvPositionKey;
    };
#else
    /*
     * We do this as D3D_OVERLOADS defines constructors for D3DVECTOR,
     * this can then not be used in a union.  Use the inlines provided
     * to extract and set the required component.
     */
    D3DVALUE dvK[4];
#endif
} D3DRMANIMATIONKEY;
typedef D3DRMANIMATIONKEY *LPD3DRMANIMATIONKEY;

#if (defined __cplusplus) && (defined D3D_OVERLOADS)
inline VOID
D3DRMAnimationGetRotateKey(const D3DRMANIMATIONKEY& rmKey,
                           D3DRMQUATERNION& rmQuat)
{
    rmQuat.s = rmKey.dvK[0];
    rmQuat.v = D3DVECTOR(rmKey.dvK[1], rmKey.dvK[2], rmKey.dvK[3]);
}

inline VOID
D3DRMAnimationGetScaleKey(const D3DRMANIMATIONKEY& rmKey,
                          D3DVECTOR& dvVec)
{
    dvVec = D3DVECTOR(rmKey.dvK[0], rmKey.dvK[1], rmKey.dvK[2]);
}

inline VOID
D3DRMAnimationGetPositionKey(const D3DRMANIMATIONKEY& rmKey,
                             D3DVECTOR& dvVec)
{
    dvVec = D3DVECTOR(rmKey.dvK[0], rmKey.dvK[1], rmKey.dvK[2]);
}
inline VOID
D3DRMAnimationSetRotateKey(D3DRMANIMATIONKEY& rmKey,
                           const D3DRMQUATERNION& rmQuat)
{
    rmKey.dvK[0] = rmQuat.s;
    rmKey.dvK[1] = rmQuat.v.x;
    rmKey.dvK[2] = rmQuat.v.y;
    rmKey.dvK[3] = rmQuat.v.z;
}

inline VOID
D3DRMAnimationSetScaleKey(D3DRMANIMATIONKEY& rmKey,
                          const D3DVECTOR& dvVec)
{
    rmKey.dvK[0] = dvVec.x;
    rmKey.dvK[1] = dvVec.y;
    rmKey.dvK[2] = dvVec.z;
}

inline VOID
D3DRMAnimationSetPositionKey(D3DRMANIMATIONKEY& rmKey,
                             const D3DVECTOR& dvVec)
{
    rmKey.dvK[0] = dvVec.x;
    rmKey.dvK[1] = dvVec.y;
    rmKey.dvK[2] = dvVec.z;
}
#endif

#define D3DRMANIMATION_ROTATEKEY 0x01
#define D3DRMANIMATION_SCALEKEY 0x02
#define D3DRMANIMATION_POSITIONKEY 0x03


typedef DWORD D3DRMMAPPING, D3DRMMAPPINGFLAG, *LPD3DRMMAPPING;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPU = 1;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPV = 2;
static const D3DRMMAPPINGFLAG D3DRMMAP_PERSPCORRECT = 4;

typedef struct _D3DRMVERTEX
{   D3DVECTOR       position;
    D3DVECTOR       normal;
    D3DVALUE        tu, tv;
    D3DCOLOR        color;
} D3DRMVERTEX, *LPD3DRMVERTEX;

typedef LONG D3DRMGROUPINDEX; /* group indexes begin a 0 */
static const D3DRMGROUPINDEX D3DRMGROUP_ALLGROUPS = -1;

/*
 * Create a color from three components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI        D3DRMCreateColorRGB(D3DVALUE red,
                                          D3DVALUE green,
                                          D3DVALUE blue);

/*
 * Create a color from four components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI        D3DRMCreateColorRGBA(D3DVALUE red,
                                                 D3DVALUE green,
                                                 D3DVALUE blue,
                                                 D3DVALUE alpha);

/*
 * Get the red component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetRed(D3DCOLOR);

/*
 * Get the green component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetGreen(D3DCOLOR);

/*
 * Get the blue component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetBlue(D3DCOLOR);

/*
 * Get the alpha component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetAlpha(D3DCOLOR);

/*
 * Add two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorAdd(LPD3DVECTOR d,
                                          LPD3DVECTOR s1,
                                          LPD3DVECTOR s2);

/*
 * Subtract two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorSubtract(LPD3DVECTOR d,
                                               LPD3DVECTOR s1,
                                               LPD3DVECTOR s2);
/*
 * Reflect a ray about a given normal.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorReflect(LPD3DVECTOR d,
                                              LPD3DVECTOR ray,
                                              LPD3DVECTOR norm);

/*
 * Calculate the vector cross product.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorCrossProduct(LPD3DVECTOR d,
                                                   LPD3DVECTOR s1,
                                                   LPD3DVECTOR s2);
/*
 * Return the vector dot product.
 */
extern D3DVALUE                 D3DRMAPI D3DRMVectorDotProduct(LPD3DVECTOR s1,
                                                 LPD3DVECTOR s2);

/*
 * Scale a vector so that its modulus is 1.  Returns its argument or
 * NULL if there was an error (e.g. a zero vector was passed).
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorNormalize(LPD3DVECTOR);
#define D3DRMVectorNormalise D3DRMVectorNormalize

/*
 * Return the length of a vector (e.g. sqrt(x*x + y*y + z*z)).
 */
extern D3DVALUE                 D3DRMAPI D3DRMVectorModulus(LPD3DVECTOR v);

/*
 * Set the rotation part of a matrix to be a rotation of theta radians
 * around the given axis.
 */

extern LPD3DVECTOR      D3DRMAPI D3DRMVectorRotate(LPD3DVECTOR r, LPD3DVECTOR v, LPD3DVECTOR axis, D3DVALUE theta);

/*
 * Scale a vector uniformly in all three axes
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorScale(LPD3DVECTOR d, LPD3DVECTOR s, D3DVALUE factor);

/*
 * Return a random unit vector
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorRandom(LPD3DVECTOR d);

/*
 * Returns a unit quaternion that represents a rotation of theta radians
 * around the given axis.
 */

extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionFromRotation(LPD3DRMQUATERNION quat,
                                                              LPD3DVECTOR v,
                                                              D3DVALUE theta);

/*
 * Calculate the product of two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionMultiply(LPD3DRMQUATERNION q,
                                                          LPD3DRMQUATERNION a,
                                                          LPD3DRMQUATERNION b);

/*
 * Interpolate between two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionSlerp(LPD3DRMQUATERNION q,
                                                       LPD3DRMQUATERNION a,
                                                       LPD3DRMQUATERNION b,
                                                       D3DVALUE alpha);

/*
 * Calculate the matrix for the rotation that a unit quaternion represents
 */
extern void             D3DRMAPI D3DRMMatrixFromQuaternion(D3DRMMATRIX4D dmMat, LPD3DRMQUATERNION lpDqQuat);

/*
 * Calculate the quaternion that corresponds to a rotation matrix
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionFromMatrix(LPD3DRMQUATERNION, D3DRMMATRIX4D);


#if defined(__cplusplus)
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\d3dtypes.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dtypes.h
 *  Content:    Direct3D types include file
 *
 ***************************************************************************/

#ifndef _D3DTYPES_H_
#define _D3DTYPES_H_

#include <windows.h>

#include <float.h>
#include <ddraw.h>

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0600
#endif

#pragma pack(4)


/* D3DVALUE is the fundamental Direct3D fractional data type */

#define D3DVALP(val, prec) ((float)(val))
#define D3DVAL(val) ((float)(val))
typedef float D3DVALUE, *LPD3DVALUE;
#define D3DDivide(a, b)    (float)((double) (a) / (double) (b))
#define D3DMultiply(a, b)    ((a) * (b))

typedef LONG D3DFIXED;

#ifndef RGB_MAKE
/*
 * Format of CI colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |         color index           |   fraction    |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define CI_GETALPHA(ci)    ((ci) >> 24)
#define CI_GETINDEX(ci)    (((ci) >> 8) & 0xffff)
#define CI_GETFRACTION(ci) ((ci) & 0xff)
#define CI_ROUNDINDEX(ci)  CI_GETINDEX((ci) + 0x80)
#define CI_MASKALPHA(ci)   ((ci) & 0xffffff)
#define CI_MAKE(a, i, f)    (((a) << 24) | ((i) << 8) | (f))

/*
 * Format of RGBA colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGBA_GETALPHA(rgb)      ((rgb) >> 24)
#define RGBA_GETRED(rgb)        (((rgb) >> 16) & 0xff)
#define RGBA_GETGREEN(rgb)      (((rgb) >> 8) & 0xff)
#define RGBA_GETBLUE(rgb)       ((rgb) & 0xff)
#define RGBA_MAKE(r, g, b, a)   ((D3DCOLOR) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b)))

/* D3DRGB and D3DRGBA may be used as initialisers for D3DCOLORs
 * The float values must be in the range 0..1
 */
#define D3DRGB(r, g, b) \
    (0xff000000L | ( ((long)((r) * 255)) << 16) | (((long)((g) * 255)) << 8) | (long)((b) * 255))
#define D3DRGBA(r, g, b, a) \
    (   (((long)((a) * 255)) << 24) | (((long)((r) * 255)) << 16) \
    |   (((long)((g) * 255)) << 8) | (long)((b) * 255) \
    )

/*
 * Format of RGB colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    ignored    |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGB_GETRED(rgb)         (((rgb) >> 16) & 0xff)
#define RGB_GETGREEN(rgb)       (((rgb) >> 8) & 0xff)
#define RGB_GETBLUE(rgb)        ((rgb) & 0xff)
#define RGBA_SETALPHA(rgba, x) (((x) << 24) | ((rgba) & 0x00ffffff))
#define RGB_MAKE(r, g, b)       ((D3DCOLOR) (((r) << 16) | ((g) << 8) | (b)))
#define RGBA_TORGB(rgba)       ((D3DCOLOR) ((rgba) & 0xffffff))
#define RGB_TORGBA(rgb)        ((D3DCOLOR) ((rgb) | 0xff000000))

#endif

/*
 * Flags for Enumerate functions
 */

/*
 * Stop the enumeration
 */
#define D3DENUMRET_CANCEL                        DDENUMRET_CANCEL

/*
 * Continue the enumeration
 */
#define D3DENUMRET_OK                            DDENUMRET_OK

typedef HRESULT (WINAPI* LPD3DVALIDATECALLBACK)(LPVOID lpUserArg, DWORD dwOffset);
typedef HRESULT (WINAPI* LPD3DENUMTEXTUREFORMATSCALLBACK)(LPDDSURFACEDESC lpDdsd, LPVOID lpContext);
typedef HRESULT (WINAPI* LPD3DENUMPIXELFORMATSCALLBACK)(LPDDPIXELFORMAT lpDDPixFmt, LPVOID lpContext);

typedef DWORD D3DCOLOR, *LPD3DCOLOR;

typedef DWORD D3DMATERIALHANDLE, *LPD3DMATERIALHANDLE;
typedef DWORD D3DTEXTUREHANDLE, *LPD3DTEXTUREHANDLE;
typedef DWORD D3DMATRIXHANDLE, *LPD3DMATRIXHANDLE;

typedef struct _D3DCOLORVALUE {
    union {
    D3DVALUE r;
    D3DVALUE dvR;
    };
    union {
    D3DVALUE g;
    D3DVALUE dvG;
    };
    union {
    D3DVALUE b;
    D3DVALUE dvB;
    };
    union {
    D3DVALUE a;
    D3DVALUE dvA;
    };
} D3DCOLORVALUE, *LPD3DCOLORVALUE;

typedef struct _D3DRECT {
    union {
    LONG x1;
    LONG lX1;
    };
    union {
    LONG y1;
    LONG lY1;
    };
    union {
    LONG x2;
    LONG lX2;
    };
    union {
    LONG y2;
    LONG lY2;
    };
} D3DRECT, *LPD3DRECT;

typedef struct _D3DVECTOR {
    union {
    D3DVALUE x;
    D3DVALUE dvX;
    };
    union {
    D3DVALUE y;
    D3DVALUE dvY;
    };
    union {
    D3DVALUE z;
    D3DVALUE dvZ;
    };
#if (defined __cplusplus) && (defined D3D_OVERLOADS)

public:

    // =====================================
    // Constructors
    // =====================================

    _D3DVECTOR() { }
    _D3DVECTOR(D3DVALUE f);
    _D3DVECTOR(D3DVALUE _x, D3DVALUE _y, D3DVALUE _z);
    _D3DVECTOR(const D3DVALUE f[3]);

    // =====================================
    // Access grants
    // =====================================

    const D3DVALUE&operator[](int i) const;
    D3DVALUE&operator[](int i);

    // =====================================
    // Assignment operators
    // =====================================

    _D3DVECTOR& operator += (const _D3DVECTOR& v);
    _D3DVECTOR& operator -= (const _D3DVECTOR& v);
    _D3DVECTOR& operator *= (const _D3DVECTOR& v);
    _D3DVECTOR& operator /= (const _D3DVECTOR& v);
    _D3DVECTOR& operator *= (D3DVALUE s);
    _D3DVECTOR& operator /= (D3DVALUE s);

    // =====================================
    // Unary operators
    // =====================================

    friend _D3DVECTOR operator + (const _D3DVECTOR& v);
    friend _D3DVECTOR operator - (const _D3DVECTOR& v);


    // =====================================
    // Binary operators
    // =====================================

    // Addition and subtraction
        friend _D3DVECTOR operator + (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR operator - (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
    // Scalar multiplication and division
        friend _D3DVECTOR operator * (const _D3DVECTOR& v, D3DVALUE s);
        friend _D3DVECTOR operator * (D3DVALUE s, const _D3DVECTOR& v);
        friend _D3DVECTOR operator / (const _D3DVECTOR& v, D3DVALUE s);
    // Memberwise multiplication and division
        friend _D3DVECTOR operator * (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR operator / (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Vector dominance
        friend int operator < (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend int operator <= (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Bitwise equality
        friend int operator == (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Length-related functions
        friend D3DVALUE SquareMagnitude (const _D3DVECTOR& v);
        friend D3DVALUE Magnitude (const _D3DVECTOR& v);

    // Returns vector with same direction and unit length
        friend _D3DVECTOR Normalize (const _D3DVECTOR& v);

    // Return min/max component of the input vector
        friend D3DVALUE Min (const _D3DVECTOR& v);
        friend D3DVALUE Max (const _D3DVECTOR& v);

    // Return memberwise min/max of input vectors
        friend _D3DVECTOR Minimize (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR Maximize (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Dot and cross product
        friend D3DVALUE DotProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR CrossProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

#endif
} D3DVECTOR, *LPD3DVECTOR;

/*
 * Vertex data types supported in an ExecuteBuffer.
 */

/*
 * Homogeneous vertices
 */

typedef struct _D3DHVERTEX {
    DWORD           dwFlags;        /* Homogeneous clipping flags */
    union {
    D3DVALUE    hx;
    D3DVALUE    dvHX;
    };
    union {
    D3DVALUE    hy;
    D3DVALUE    dvHY;
    };
    union {
    D3DVALUE    hz;
    D3DVALUE    dvHZ;
    };
} D3DHVERTEX, *LPD3DHVERTEX;

/*
 * Transformed/lit vertices
 */
typedef struct _D3DTLVERTEX {
    union {
    D3DVALUE    sx;             /* Screen coordinates */
    D3DVALUE    dvSX;
    };
    union {
    D3DVALUE    sy;
    D3DVALUE    dvSY;
    };
    union {
    D3DVALUE    sz;
    D3DVALUE    dvSZ;
    };
    union {
    D3DVALUE    rhw;        /* Reciprocal of homogeneous w */
    D3DVALUE    dvRHW;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DCOLOR    specular;       /* Specular component of vertex */
    D3DCOLOR    dcSpecular;
    };
    union {
    D3DVALUE    tu;             /* Texture coordinates */
    D3DVALUE    dvTU;
    };
    union {
    D3DVALUE    tv;
    D3DVALUE    dvTV;
    };
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _D3DTLVERTEX() { }
    _D3DTLVERTEX(const D3DVECTOR& v, float _rhw,
                 D3DCOLOR _color, D3DCOLOR _specular,
                 float _tu, float _tv)
        { sx = v.x; sy = v.y; sz = v.z; rhw = _rhw;
          color = _color; specular = _specular;
          tu = _tu; tv = _tv;
        }
#endif
} D3DTLVERTEX, *LPD3DTLVERTEX;

/*
 * Untransformed/lit vertices
 */
typedef struct _D3DLVERTEX {
    union {
    D3DVALUE     x;             /* Homogeneous coordinates */
    D3DVALUE     dvX;
    };
    union {
    D3DVALUE     y;
    D3DVALUE     dvY;
    };
    union {
    D3DVALUE     z;
    D3DVALUE     dvZ;
    };
    DWORD            dwReserved;
    union {
    D3DCOLOR     color;         /* Vertex color */
    D3DCOLOR     dcColor;
    };
    union {
    D3DCOLOR     specular;      /* Specular component of vertex */
    D3DCOLOR     dcSpecular;
    };
    union {
    D3DVALUE     tu;            /* Texture coordinates */
    D3DVALUE     dvTU;
    };
    union {
    D3DVALUE     tv;
    D3DVALUE     dvTV;
    };
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _D3DLVERTEX() { }
    _D3DLVERTEX(const D3DVECTOR& v,
                D3DCOLOR _color, D3DCOLOR _specular,
                float _tu, float _tv)
        { x = v.x; y = v.y; z = v.z; dwReserved = 0;
          color = _color; specular = _specular;
          tu = _tu; tv = _tv;
        }
#endif
} D3DLVERTEX, *LPD3DLVERTEX;

/*
 * Untransformed/unlit vertices
 */

typedef struct _D3DVERTEX {
    union {
    D3DVALUE     x;             /* Homogeneous coordinates */
    D3DVALUE     dvX;
    };
    union {
    D3DVALUE     y;
    D3DVALUE     dvY;
    };
    union {
    D3DVALUE     z;
    D3DVALUE     dvZ;
    };
    union {
    D3DVALUE     nx;            /* Normal */
    D3DVALUE     dvNX;
    };
    union {
    D3DVALUE     ny;
    D3DVALUE     dvNY;
    };
    union {
    D3DVALUE     nz;
    D3DVALUE     dvNZ;
    };
    union {
    D3DVALUE     tu;            /* Texture coordinates */
    D3DVALUE     dvTU;
    };
    union {
    D3DVALUE     tv;
    D3DVALUE     dvTV;
    };
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _D3DVERTEX() { }
    _D3DVERTEX(const D3DVECTOR& v, const D3DVECTOR& n, float _tu, float _tv)
        { x = v.x; y = v.y; z = v.z;
          nx = n.x; ny = n.y; nz = n.z;
          tu = _tu; tv = _tv;
        }
#endif
} D3DVERTEX, *LPD3DVERTEX;


/*
 * Matrix, viewport, and tranformation structures and definitions.
 */

typedef struct _D3DMATRIX {
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    union {
        struct {
#endif

            D3DVALUE        _11, _12, _13, _14;
            D3DVALUE        _21, _22, _23, _24;
            D3DVALUE        _31, _32, _33, _34;
            D3DVALUE        _41, _42, _43, _44;

#if (defined __cplusplus) && (defined D3D_OVERLOADS)
        };
        D3DVALUE m[4][4];
    };
    _D3DMATRIX() { }
    _D3DMATRIX( D3DVALUE _m00, D3DVALUE _m01, D3DVALUE _m02, D3DVALUE _m03,
                D3DVALUE _m10, D3DVALUE _m11, D3DVALUE _m12, D3DVALUE _m13,
                D3DVALUE _m20, D3DVALUE _m21, D3DVALUE _m22, D3DVALUE _m23,
                D3DVALUE _m30, D3DVALUE _m31, D3DVALUE _m32, D3DVALUE _m33
        )
        {
                m[0][0] = _m00; m[0][1] = _m01; m[0][2] = _m02; m[0][3] = _m03;
                m[1][0] = _m10; m[1][1] = _m11; m[1][2] = _m12; m[1][3] = _m13;
                m[2][0] = _m20; m[2][1] = _m21; m[2][2] = _m22; m[2][3] = _m23;
                m[3][0] = _m30; m[3][1] = _m31; m[3][2] = _m32; m[3][3] = _m33;
        }

    D3DVALUE& operator()(int iRow, int iColumn) { return m[iRow][iColumn]; }
    const D3DVALUE& operator()(int iRow, int iColumn) const { return m[iRow][iColumn]; }
    friend _D3DMATRIX operator* (const _D3DMATRIX&, const _D3DMATRIX&);
#endif
} D3DMATRIX, *LPD3DMATRIX;

#if (defined __cplusplus) && (defined D3D_OVERLOADS)
#include "d3dvec.inl"
#endif

typedef struct _D3DVIEWPORT {
    DWORD       dwSize;
    DWORD       dwX;
    DWORD       dwY;        /* Top left */
    DWORD       dwWidth;
    DWORD       dwHeight;   /* Dimensions */
    D3DVALUE    dvScaleX;   /* Scale homogeneous to screen */
    D3DVALUE    dvScaleY;   /* Scale homogeneous to screen */
    D3DVALUE    dvMaxX;     /* Min/max homogeneous x coord */
    D3DVALUE    dvMaxY;     /* Min/max homogeneous y coord */
    D3DVALUE    dvMinZ;
    D3DVALUE    dvMaxZ;     /* Min/max homogeneous z coord */
} D3DVIEWPORT, *LPD3DVIEWPORT;

typedef struct _D3DVIEWPORT2 {
    DWORD       dwSize;
    DWORD       dwX;
    DWORD       dwY;        /* Viewport Top left */
    DWORD       dwWidth;
    DWORD       dwHeight;   /* Viewport Dimensions */
    D3DVALUE    dvClipX;        /* Top left of clip volume */
    D3DVALUE    dvClipY;
    D3DVALUE    dvClipWidth;    /* Clip Volume Dimensions */
    D3DVALUE    dvClipHeight;
    D3DVALUE    dvMinZ;         /* Min/max of clip Volume */
    D3DVALUE    dvMaxZ;
} D3DVIEWPORT2, *LPD3DVIEWPORT2;

/*
 * Values for clip fields.
 */
#define D3DCLIP_LEFT                0x00000001L
#define D3DCLIP_RIGHT               0x00000002L
#define D3DCLIP_TOP             0x00000004L
#define D3DCLIP_BOTTOM              0x00000008L
#define D3DCLIP_FRONT               0x00000010L
#define D3DCLIP_BACK                0x00000020L
#define D3DCLIP_GEN0                0x00000040L
#define D3DCLIP_GEN1                0x00000080L
#define D3DCLIP_GEN2                0x00000100L
#define D3DCLIP_GEN3                0x00000200L
#define D3DCLIP_GEN4                0x00000400L
#define D3DCLIP_GEN5                0x00000800L

/*
 * Values for d3d status.
 */
#define D3DSTATUS_CLIPUNIONLEFT         D3DCLIP_LEFT
#define D3DSTATUS_CLIPUNIONRIGHT        D3DCLIP_RIGHT
#define D3DSTATUS_CLIPUNIONTOP          D3DCLIP_TOP
#define D3DSTATUS_CLIPUNIONBOTTOM       D3DCLIP_BOTTOM
#define D3DSTATUS_CLIPUNIONFRONT        D3DCLIP_FRONT
#define D3DSTATUS_CLIPUNIONBACK         D3DCLIP_BACK
#define D3DSTATUS_CLIPUNIONGEN0         D3DCLIP_GEN0
#define D3DSTATUS_CLIPUNIONGEN1         D3DCLIP_GEN1
#define D3DSTATUS_CLIPUNIONGEN2         D3DCLIP_GEN2
#define D3DSTATUS_CLIPUNIONGEN3         D3DCLIP_GEN3
#define D3DSTATUS_CLIPUNIONGEN4         D3DCLIP_GEN4
#define D3DSTATUS_CLIPUNIONGEN5         D3DCLIP_GEN5

#define D3DSTATUS_CLIPINTERSECTIONLEFT      0x00001000L
#define D3DSTATUS_CLIPINTERSECTIONRIGHT     0x00002000L
#define D3DSTATUS_CLIPINTERSECTIONTOP       0x00004000L
#define D3DSTATUS_CLIPINTERSECTIONBOTTOM    0x00008000L
#define D3DSTATUS_CLIPINTERSECTIONFRONT     0x00010000L
#define D3DSTATUS_CLIPINTERSECTIONBACK      0x00020000L
#define D3DSTATUS_CLIPINTERSECTIONGEN0      0x00040000L
#define D3DSTATUS_CLIPINTERSECTIONGEN1      0x00080000L
#define D3DSTATUS_CLIPINTERSECTIONGEN2      0x00100000L
#define D3DSTATUS_CLIPINTERSECTIONGEN3      0x00200000L
#define D3DSTATUS_CLIPINTERSECTIONGEN4      0x00400000L
#define D3DSTATUS_CLIPINTERSECTIONGEN5      0x00800000L
#define D3DSTATUS_ZNOTVISIBLE               0x01000000L
/* Do not use 0x80000000 for any status flags in future as it is reserved */

#define D3DSTATUS_CLIPUNIONALL  (       \
        D3DSTATUS_CLIPUNIONLEFT |   \
        D3DSTATUS_CLIPUNIONRIGHT    |   \
        D3DSTATUS_CLIPUNIONTOP  |   \
        D3DSTATUS_CLIPUNIONBOTTOM   |   \
        D3DSTATUS_CLIPUNIONFRONT    |   \
        D3DSTATUS_CLIPUNIONBACK |   \
        D3DSTATUS_CLIPUNIONGEN0 |   \
        D3DSTATUS_CLIPUNIONGEN1 |   \
        D3DSTATUS_CLIPUNIONGEN2 |   \
        D3DSTATUS_CLIPUNIONGEN3 |   \
        D3DSTATUS_CLIPUNIONGEN4 |   \
        D3DSTATUS_CLIPUNIONGEN5     \
        )

#define D3DSTATUS_CLIPINTERSECTIONALL   (       \
        D3DSTATUS_CLIPINTERSECTIONLEFT  |   \
        D3DSTATUS_CLIPINTERSECTIONRIGHT |   \
        D3DSTATUS_CLIPINTERSECTIONTOP   |   \
        D3DSTATUS_CLIPINTERSECTIONBOTTOM    |   \
        D3DSTATUS_CLIPINTERSECTIONFRONT |   \
        D3DSTATUS_CLIPINTERSECTIONBACK  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN0  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN1  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN2  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN3  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN4  |   \
        D3DSTATUS_CLIPINTERSECTIONGEN5      \
        )

#define D3DSTATUS_DEFAULT   (           \
        D3DSTATUS_CLIPINTERSECTIONALL   |   \
        D3DSTATUS_ZNOTVISIBLE)


/*
 * Options for direct transform calls
 */
#define D3DTRANSFORM_CLIPPED       0x00000001l
#define D3DTRANSFORM_UNCLIPPED     0x00000002l

typedef struct _D3DTRANSFORMDATA {
    DWORD           dwSize;
    LPVOID      lpIn;           /* Input vertices */
    DWORD           dwInSize;       /* Stride of input vertices */
    LPVOID      lpOut;          /* Output vertices */
    DWORD           dwOutSize;      /* Stride of output vertices */
    LPD3DHVERTEX    lpHOut;         /* Output homogeneous vertices */
    DWORD           dwClip;         /* Clipping hint */
    DWORD           dwClipIntersection;
    DWORD           dwClipUnion;    /* Union of all clip flags */
    D3DRECT         drExtent;       /* Extent of transformed vertices */
} D3DTRANSFORMDATA, *LPD3DTRANSFORMDATA;

/*
 * Structure defining position and direction properties for lighting.
 */
typedef struct _D3DLIGHTINGELEMENT {
    D3DVECTOR dvPosition;           /* Lightable point in model space */
    D3DVECTOR dvNormal;             /* Normalised unit vector */
} D3DLIGHTINGELEMENT, *LPD3DLIGHTINGELEMENT;

/*
 * Structure defining material properties for lighting.
 */
typedef struct _D3DMATERIAL {
    DWORD           dwSize;
    union {
    D3DCOLORVALUE   diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   dcvDiffuse;
    };
    union {
    D3DCOLORVALUE   ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   dcvAmbient;
    };
    union {
    D3DCOLORVALUE   specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   dcvSpecular;
    };
    union {
    D3DCOLORVALUE   emissive;       /* Emissive color RGB */
    D3DCOLORVALUE   dcvEmissive;
    };
    union {
    D3DVALUE        power;          /* Sharpness if specular highlight */
    D3DVALUE        dvPower;
    };
    D3DTEXTUREHANDLE    hTexture;       /* Handle to texture map */
    DWORD           dwRampSize;
} D3DMATERIAL, *LPD3DMATERIAL;

typedef enum _D3DLIGHTTYPE {
    D3DLIGHT_POINT          = 1,
    D3DLIGHT_SPOT           = 2,
    D3DLIGHT_DIRECTIONAL    = 3,
    D3DLIGHT_PARALLELPOINT  = 4,
#if(DIRECT3D_VERSION < 0x0500) // For backward compatible headers
    D3DLIGHT_GLSPOT         = 5,
#endif
    D3DLIGHT_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DLIGHTTYPE;

/*
 * Structure defining a light source and its properties.
 */
typedef struct _D3DLIGHT {
    DWORD           dwSize;
    D3DLIGHTTYPE    dltType;            /* Type of light source */
    D3DCOLORVALUE   dcvColor;       /* Color of light */
    D3DVECTOR       dvPosition;     /* Position in world space */
    D3DVECTOR       dvDirection;        /* Direction in world space */
    D3DVALUE        dvRange;            /* Cutoff range */
    D3DVALUE        dvFalloff;          /* Falloff */
    D3DVALUE        dvAttenuation0;     /* Constant attenuation */
    D3DVALUE        dvAttenuation1;     /* Linear attenuation */
    D3DVALUE        dvAttenuation2;     /* Quadratic attenuation */
    D3DVALUE        dvTheta;            /* Inner angle of spotlight cone */
    D3DVALUE        dvPhi;              /* Outer angle of spotlight cone */
} D3DLIGHT, *LPD3DLIGHT;

/*
 * Structure defining a light source and its properties.
 */

/* flags bits */
#define D3DLIGHT_ACTIVE         0x00000001
#define D3DLIGHT_NO_SPECULAR    0x00000002

/* maximum valid light range */
#define D3DLIGHT_RANGE_MAX      ((float)sqrt(FLT_MAX))

typedef struct _D3DLIGHT2 {
    DWORD           dwSize;
    D3DLIGHTTYPE    dltType;        /* Type of light source */
    D3DCOLORVALUE   dcvColor;       /* Color of light */
    D3DVECTOR       dvPosition;     /* Position in world space */
    D3DVECTOR       dvDirection;    /* Direction in world space */
    D3DVALUE        dvRange;        /* Cutoff range */
    D3DVALUE        dvFalloff;      /* Falloff */
    D3DVALUE        dvAttenuation0; /* Constant attenuation */
    D3DVALUE        dvAttenuation1; /* Linear attenuation */
    D3DVALUE        dvAttenuation2; /* Quadratic attenuation */
    D3DVALUE        dvTheta;        /* Inner angle of spotlight cone */
    D3DVALUE        dvPhi;          /* Outer angle of spotlight cone */
    DWORD           dwFlags;
} D3DLIGHT2, *LPD3DLIGHT2;

typedef struct _D3DLIGHTDATA {
    DWORD                dwSize;
    LPD3DLIGHTINGELEMENT lpIn;      /* Input positions and normals */
    DWORD                dwInSize;  /* Stride of input elements */
    LPD3DTLVERTEX        lpOut;     /* Output colors */
    DWORD                dwOutSize; /* Stride of output colors */
} D3DLIGHTDATA, *LPD3DLIGHTDATA;

/*
 * Before DX5, these values were in an enum called
 * D3DCOLORMODEL. This was not correct, since they are
 * bit flags. A driver can surface either or both flags
 * in the dcmColorModel member of D3DDEVICEDESC.
 */
#define D3DCOLOR_MONO   1
#define D3DCOLOR_RGB    2

typedef DWORD D3DCOLORMODEL;

/*
 * Options for clearing
 */
#define D3DCLEAR_TARGET            0x00000001l  /* Clear target surface */
#define D3DCLEAR_ZBUFFER           0x00000002l  /* Clear target z buffer */
#define D3DCLEAR_STENCIL           0x00000004l  /* Clear stencil planes */

/*
 * Execute buffers are allocated via Direct3D.  These buffers may then
 * be filled by the application with instructions to execute along with
 * vertex data.
 */

/*
 * Supported op codes for execute instructions.
 */
typedef enum _D3DOPCODE {
    D3DOP_POINT                 = 1,
    D3DOP_LINE                  = 2,
    D3DOP_TRIANGLE      = 3,
    D3DOP_MATRIXLOAD        = 4,
    D3DOP_MATRIXMULTIPLY    = 5,
    D3DOP_STATETRANSFORM        = 6,
    D3DOP_STATELIGHT        = 7,
    D3DOP_STATERENDER       = 8,
    D3DOP_PROCESSVERTICES       = 9,
    D3DOP_TEXTURELOAD       = 10,
    D3DOP_EXIT                  = 11,
    D3DOP_BRANCHFORWARD     = 12,
    D3DOP_SPAN          = 13,
    D3DOP_SETSTATUS     = 14,
    D3DOP_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DOPCODE;

typedef struct _D3DINSTRUCTION {
    BYTE bOpcode;   /* Instruction opcode */
    BYTE bSize;     /* Size of each instruction data unit */
    WORD wCount;    /* Count of instruction data units to follow */
} D3DINSTRUCTION, *LPD3DINSTRUCTION;

/*
 * Structure for texture loads
 */
typedef struct _D3DTEXTURELOAD {
    D3DTEXTUREHANDLE hDestTexture;
    D3DTEXTUREHANDLE hSrcTexture;
} D3DTEXTURELOAD, *LPD3DTEXTURELOAD;

/*
 * Structure for picking
 */
typedef struct _D3DPICKRECORD {
    BYTE     bOpcode;
    BYTE     bPad;
    DWORD    dwOffset;
    D3DVALUE dvZ;
} D3DPICKRECORD, *LPD3DPICKRECORD;

/*
 * The following defines the rendering states which can be set in the
 * execute buffer.
 */

typedef enum _D3DSHADEMODE {
    D3DSHADE_FLAT              = 1,
    D3DSHADE_GOURAUD           = 2,
    D3DSHADE_PHONG             = 3,
    D3DSHADE_FORCE_DWORD       = 0x7fffffff, /* force 32-bit size enum */
} D3DSHADEMODE;

typedef enum _D3DFILLMODE {
    D3DFILL_POINT          = 1,
    D3DFILL_WIREFRAME          = 2,
    D3DFILL_SOLID          = 3,
    D3DFILL_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DFILLMODE;

typedef struct _D3DLINEPATTERN {
    WORD    wRepeatFactor;
    WORD    wLinePattern;
} D3DLINEPATTERN;

typedef enum _D3DTEXTUREFILTER {
    D3DFILTER_NEAREST          = 1,
    D3DFILTER_LINEAR           = 2,
    D3DFILTER_MIPNEAREST       = 3,
    D3DFILTER_MIPLINEAR        = 4,
    D3DFILTER_LINEARMIPNEAREST = 5,
    D3DFILTER_LINEARMIPLINEAR  = 6,
    D3DFILTER_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREFILTER;

typedef enum _D3DBLEND {
    D3DBLEND_ZERO              = 1,
    D3DBLEND_ONE               = 2,
    D3DBLEND_SRCCOLOR          = 3,
    D3DBLEND_INVSRCCOLOR       = 4,
    D3DBLEND_SRCALPHA          = 5,
    D3DBLEND_INVSRCALPHA       = 6,
    D3DBLEND_DESTALPHA         = 7,
    D3DBLEND_INVDESTALPHA      = 8,
    D3DBLEND_DESTCOLOR         = 9,
    D3DBLEND_INVDESTCOLOR      = 10,
    D3DBLEND_SRCALPHASAT       = 11,
    D3DBLEND_BOTHSRCALPHA      = 12,
    D3DBLEND_BOTHINVSRCALPHA   = 13,
    D3DBLEND_FORCE_DWORD       = 0x7fffffff, /* force 32-bit size enum */
} D3DBLEND;

typedef enum _D3DTEXTUREBLEND {
    D3DTBLEND_DECAL            = 1,
    D3DTBLEND_MODULATE         = 2,
    D3DTBLEND_DECALALPHA       = 3,
    D3DTBLEND_MODULATEALPHA    = 4,
    D3DTBLEND_DECALMASK        = 5,
    D3DTBLEND_MODULATEMASK     = 6,
    D3DTBLEND_COPY             = 7,
    D3DTBLEND_ADD              = 8,
    D3DTBLEND_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREBLEND;

typedef enum _D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP           = 1,
    D3DTADDRESS_MIRROR         = 2,
    D3DTADDRESS_CLAMP          = 3,
    D3DTADDRESS_BORDER         = 4,
    D3DTADDRESS_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREADDRESS;

typedef enum _D3DCULL {
    D3DCULL_NONE               = 1,
    D3DCULL_CW                 = 2,
    D3DCULL_CCW                = 3,
    D3DCULL_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DCULL;

typedef enum _D3DCMPFUNC {
    D3DCMP_NEVER               = 1,
    D3DCMP_LESS                = 2,
    D3DCMP_EQUAL               = 3,
    D3DCMP_LESSEQUAL           = 4,
    D3DCMP_GREATER             = 5,
    D3DCMP_NOTEQUAL            = 6,
    D3DCMP_GREATEREQUAL        = 7,
    D3DCMP_ALWAYS              = 8,
    D3DCMP_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DCMPFUNC;

typedef enum _D3DSTENCILOP {
    D3DSTENCILOP_KEEP           = 1,
    D3DSTENCILOP_ZERO           = 2,
    D3DSTENCILOP_REPLACE        = 3,
    D3DSTENCILOP_INCRSAT        = 4,
    D3DSTENCILOP_DECRSAT        = 5,
    D3DSTENCILOP_INVERT         = 6,
    D3DSTENCILOP_INCR           = 7,
    D3DSTENCILOP_DECR           = 8,
    D3DSTENCILOP_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DSTENCILOP;

typedef enum _D3DFOGMODE {
    D3DFOG_NONE                = 0,
    D3DFOG_EXP                 = 1,
    D3DFOG_EXP2                = 2,
    D3DFOG_LINEAR              = 3,
    D3DFOG_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DFOGMODE;

typedef enum _D3DZBUFFERTYPE {
    D3DZB_FALSE                 = 0,
    D3DZB_TRUE                  = 1, // Z buffering
    D3DZB_USEW                  = 2, // W buffering
    D3DZB_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DZBUFFERTYPE;

typedef enum _D3DANTIALIASMODE {
    D3DANTIALIAS_NONE          = 0,
    D3DANTIALIAS_SORTDEPENDENT = 1,
    D3DANTIALIAS_SORTINDEPENDENT = 2,
    D3DANTIALIAS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DANTIALIASMODE;

// Vertex types supported by Direct3D
typedef enum _D3DVERTEXTYPE {
    D3DVT_VERTEX        = 1,
    D3DVT_LVERTEX       = 2,
    D3DVT_TLVERTEX      = 3,
    D3DVT_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DVERTEXTYPE;

// Primitives supported by draw-primitive API
typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST     = 1,
    D3DPT_LINELIST      = 2,
    D3DPT_LINESTRIP     = 3,
    D3DPT_TRIANGLELIST  = 4,
    D3DPT_TRIANGLESTRIP = 5,
    D3DPT_TRIANGLEFAN   = 6,
    D3DPT_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DPRIMITIVETYPE;

/*
 * Amount to add to a state to generate the override for that state.
 */
#define D3DSTATE_OVERRIDE_BIAS      256

/*
 * A state which sets the override flag for the specified state type.
 */
#define D3DSTATE_OVERRIDE(type) (D3DRENDERSTATETYPE)(((DWORD) (type) + D3DSTATE_OVERRIDE_BIAS))

typedef enum _D3DTRANSFORMSTATETYPE {
    D3DTRANSFORMSTATE_WORLD           = 1,
    D3DTRANSFORMSTATE_VIEW            = 2,
    D3DTRANSFORMSTATE_PROJECTION      = 3,
    D3DTRANSFORMSTATE_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
} D3DTRANSFORMSTATETYPE;

typedef enum _D3DLIGHTSTATETYPE {
    D3DLIGHTSTATE_MATERIAL          = 1,
    D3DLIGHTSTATE_AMBIENT           = 2,
    D3DLIGHTSTATE_COLORMODEL        = 3,
    D3DLIGHTSTATE_FOGMODE           = 4,
    D3DLIGHTSTATE_FOGSTART          = 5,
    D3DLIGHTSTATE_FOGEND            = 6,
    D3DLIGHTSTATE_FOGDENSITY        = 7,
    D3DLIGHTSTATE_COLORVERTEX       = 8,
    D3DLIGHTSTATE_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DLIGHTSTATETYPE;

typedef enum _D3DRENDERSTATETYPE {
    D3DRENDERSTATE_TEXTUREHANDLE      = 1,    /* Texture handle for legacy interfaces (Texture,Texture2) */
    D3DRENDERSTATE_ANTIALIAS          = 2,    /* D3DANTIALIASMODE */
    D3DRENDERSTATE_TEXTUREADDRESS     = 3,    /* D3DTEXTUREADDRESS  */
    D3DRENDERSTATE_TEXTUREPERSPECTIVE = 4,    /* TRUE for perspective correction */
    D3DRENDERSTATE_WRAPU          = 5,    /* TRUE for wrapping in u */
    D3DRENDERSTATE_WRAPV          = 6,    /* TRUE for wrapping in v */
    D3DRENDERSTATE_ZENABLE            = 7,    /* D3DZBUFFERTYPE (or TRUE/FALSE for legacy) */
    D3DRENDERSTATE_FILLMODE           = 8,    /* D3DFILL_MODE        */
    D3DRENDERSTATE_SHADEMODE          = 9,    /* D3DSHADEMODE */
    D3DRENDERSTATE_LINEPATTERN        = 10,   /* D3DLINEPATTERN */
    D3DRENDERSTATE_MONOENABLE         = 11,   /* TRUE to enable mono rasterization */
    D3DRENDERSTATE_ROP2               = 12,   /* ROP2 */
    D3DRENDERSTATE_PLANEMASK          = 13,   /* DWORD physical plane mask */
    D3DRENDERSTATE_ZWRITEENABLE       = 14,   /* TRUE to enable z writes */
    D3DRENDERSTATE_ALPHATESTENABLE    = 15,   /* TRUE to enable alpha tests */
    D3DRENDERSTATE_LASTPIXEL          = 16,   /* TRUE for last-pixel on lines */
    D3DRENDERSTATE_TEXTUREMAG         = 17,   /* D3DTEXTUREFILTER */
    D3DRENDERSTATE_TEXTUREMIN         = 18,   /* D3DTEXTUREFILTER */
    D3DRENDERSTATE_SRCBLEND           = 19,   /* D3DBLEND */
    D3DRENDERSTATE_DESTBLEND          = 20,   /* D3DBLEND */
    D3DRENDERSTATE_TEXTUREMAPBLEND    = 21,   /* D3DTEXTUREBLEND */
    D3DRENDERSTATE_CULLMODE           = 22,   /* D3DCULL */
    D3DRENDERSTATE_ZFUNC              = 23,   /* D3DCMPFUNC */
    D3DRENDERSTATE_ALPHAREF           = 24,   /* D3DFIXED */
    D3DRENDERSTATE_ALPHAFUNC          = 25,   /* D3DCMPFUNC */
    D3DRENDERSTATE_DITHERENABLE       = 26,   /* TRUE to enable dithering */
    D3DRENDERSTATE_ALPHABLENDENABLE        = 27,   /* TRUE to enable alpha blending */
    D3DRENDERSTATE_FOGENABLE          = 28,   /* TRUE to enable fog */
    D3DRENDERSTATE_SPECULARENABLE     = 29,   /* TRUE to enable specular */
    D3DRENDERSTATE_ZVISIBLE           = 30,   /* TRUE to enable z checking */
    D3DRENDERSTATE_SUBPIXEL       = 31,   /* TRUE to enable subpixel correction */
    D3DRENDERSTATE_SUBPIXELX          = 32,   /* TRUE to enable correction in X only */
    D3DRENDERSTATE_STIPPLEDALPHA      = 33,   /* TRUE to enable stippled alpha */
    D3DRENDERSTATE_FOGCOLOR           = 34,   /* D3DCOLOR */
    D3DRENDERSTATE_FOGTABLEMODE       = 35,   /* D3DFOGMODE */
    D3DRENDERSTATE_FOGTABLESTART      = 36,   /* Fog table start    */
    D3DRENDERSTATE_FOGTABLEEND        = 37,   /* Fog table end      */
    D3DRENDERSTATE_FOGTABLEDENSITY    = 38,   /* Fog table density  */
    D3DRENDERSTATE_STIPPLEENABLE      = 39,   /* TRUE to enable stippling */
    D3DRENDERSTATE_EDGEANTIALIAS      = 40,   /* TRUE to enable edge antialiasing */
    D3DRENDERSTATE_COLORKEYENABLE     = 41,   /* TRUE to enable source colorkeyed textures */
    D3DRENDERSTATE_BORDERCOLOR        = 43,   /* Border color for texturing w/border */
    D3DRENDERSTATE_TEXTUREADDRESSU    = 44,   /* Texture addressing mode for U coordinate */
    D3DRENDERSTATE_TEXTUREADDRESSV    = 45,   /* Texture addressing mode for V coordinate */
    D3DRENDERSTATE_MIPMAPLODBIAS      = 46,   /* D3DVALUE Mipmap LOD bias */
    D3DRENDERSTATE_ZBIAS              = 47,   /* LONG Z bias */
    D3DRENDERSTATE_RANGEFOGENABLE     = 48,   /* Enables range-based fog */
    D3DRENDERSTATE_ANISOTROPY         = 49,   /* Max. anisotropy. 1 = no anisotropy */
    D3DRENDERSTATE_FLUSHBATCH         = 50,   /* Explicit flush for DP batching (DX5 Only) */
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT=51, /* BOOL enable sort-independent transparency */
    D3DRENDERSTATE_STENCILENABLE      = 52,   /* BOOL enable/disable stenciling */
    D3DRENDERSTATE_STENCILFAIL        = 53,   /* D3DSTENCILOP to do if stencil test fails */
    D3DRENDERSTATE_STENCILZFAIL       = 54,   /* D3DSTENCILOP to do if stencil test passes and Z test fails */
    D3DRENDERSTATE_STENCILPASS        = 55,   /* D3DSTENCILOP to do if both stencil and Z tests pass */
    D3DRENDERSTATE_STENCILFUNC        = 56,   /* D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
    D3DRENDERSTATE_STENCILREF         = 57,   /* Reference value used in stencil test */
    D3DRENDERSTATE_STENCILMASK        = 58,   /* Mask value used in stencil test */
    D3DRENDERSTATE_STENCILWRITEMASK   = 59,   /* Write mask applied to values written to stencil buffer */
    D3DRENDERSTATE_TEXTUREFACTOR      = 60,   /* D3DCOLOR used for multi-texture blend */
    D3DRENDERSTATE_STIPPLEPATTERN00   = 64,   /* Stipple pattern 01...  */
    D3DRENDERSTATE_STIPPLEPATTERN01   = 65,
    D3DRENDERSTATE_STIPPLEPATTERN02   = 66,
    D3DRENDERSTATE_STIPPLEPATTERN03   = 67,
    D3DRENDERSTATE_STIPPLEPATTERN04   = 68,
    D3DRENDERSTATE_STIPPLEPATTERN05   = 69,
    D3DRENDERSTATE_STIPPLEPATTERN06   = 70,
    D3DRENDERSTATE_STIPPLEPATTERN07   = 71,
    D3DRENDERSTATE_STIPPLEPATTERN08   = 72,
    D3DRENDERSTATE_STIPPLEPATTERN09   = 73,
    D3DRENDERSTATE_STIPPLEPATTERN10   = 74,
    D3DRENDERSTATE_STIPPLEPATTERN11   = 75,
    D3DRENDERSTATE_STIPPLEPATTERN12   = 76,
    D3DRENDERSTATE_STIPPLEPATTERN13   = 77,
    D3DRENDERSTATE_STIPPLEPATTERN14   = 78,
    D3DRENDERSTATE_STIPPLEPATTERN15   = 79,
    D3DRENDERSTATE_STIPPLEPATTERN16   = 80,
    D3DRENDERSTATE_STIPPLEPATTERN17   = 81,
    D3DRENDERSTATE_STIPPLEPATTERN18   = 82,
    D3DRENDERSTATE_STIPPLEPATTERN19   = 83,
    D3DRENDERSTATE_STIPPLEPATTERN20   = 84,
    D3DRENDERSTATE_STIPPLEPATTERN21   = 85,
    D3DRENDERSTATE_STIPPLEPATTERN22   = 86,
    D3DRENDERSTATE_STIPPLEPATTERN23   = 87,
    D3DRENDERSTATE_STIPPLEPATTERN24   = 88,
    D3DRENDERSTATE_STIPPLEPATTERN25   = 89,
    D3DRENDERSTATE_STIPPLEPATTERN26   = 90,
    D3DRENDERSTATE_STIPPLEPATTERN27   = 91,
    D3DRENDERSTATE_STIPPLEPATTERN28   = 92,
    D3DRENDERSTATE_STIPPLEPATTERN29   = 93,
    D3DRENDERSTATE_STIPPLEPATTERN30   = 94,
    D3DRENDERSTATE_STIPPLEPATTERN31   = 95,

    /*
     * 128 values [128, 255] are reserved for texture coordinate wrap flags.
     * These are constructed with the D3DWRAP_U and D3DWRAP_V macros. Using
     * a flags word preserves forward compatibility with texture coordinates
     * that are >2D.
     */
    D3DRENDERSTATE_WRAP0              = 128,  /* wrap for 1st texture coord. set */
    D3DRENDERSTATE_WRAP1              = 129,  /* wrap for 2nd texture coord. set */
    D3DRENDERSTATE_WRAP2              = 130,  /* wrap for 3rd texture coord. set */
    D3DRENDERSTATE_WRAP3              = 131,  /* wrap for 4th texture coord. set */
    D3DRENDERSTATE_WRAP4              = 132,  /* wrap for 5th texture coord. set */
    D3DRENDERSTATE_WRAP5              = 133,  /* wrap for 6th texture coord. set */
    D3DRENDERSTATE_WRAP6              = 134,  /* wrap for 7th texture coord. set */
    D3DRENDERSTATE_WRAP7              = 135,  /* wrap for 8th texture coord. set */
    D3DRENDERSTATE_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DRENDERSTATETYPE;

// For back-compatibility with legacy compilations
#define D3DRENDERSTATE_BLENDENABLE      D3DRENDERSTATE_ALPHABLENDENABLE


// Bias to apply to the texture coordinate set to apply a wrap to.
#define D3DRENDERSTATE_WRAPBIAS                 128UL

/* Flags to construct the WRAP render states */
#define D3DWRAP_U   0x00000001L
#define D3DWRAP_V   0x00000002L


#define D3DRENDERSTATE_STIPPLEPATTERN(y) (D3DRENDERSTATE_STIPPLEPATTERN00 + (y))

typedef struct _D3DSTATE {
    union {
    D3DTRANSFORMSTATETYPE   dtstTransformStateType;
    D3DLIGHTSTATETYPE   dlstLightStateType;
    D3DRENDERSTATETYPE  drstRenderStateType;
    };
    union {
    DWORD           dwArg[1];
    D3DVALUE        dvArg[1];
    };
} D3DSTATE, *LPD3DSTATE;

/*
 * Operation used to load matrices
 * hDstMat = hSrcMat
 */
typedef struct _D3DMATRIXLOAD {
    D3DMATRIXHANDLE hDestMatrix;   /* Destination matrix */
    D3DMATRIXHANDLE hSrcMatrix;   /* Source matrix */
} D3DMATRIXLOAD, *LPD3DMATRIXLOAD;

/*
 * Operation used to multiply matrices
 * hDstMat = hSrcMat1 * hSrcMat2
 */
typedef struct _D3DMATRIXMULTIPLY {
    D3DMATRIXHANDLE hDestMatrix;   /* Destination matrix */
    D3DMATRIXHANDLE hSrcMatrix1;  /* First source matrix */
    D3DMATRIXHANDLE hSrcMatrix2;  /* Second source matrix */
} D3DMATRIXMULTIPLY, *LPD3DMATRIXMULTIPLY;

/*
 * Operation used to transform and light vertices.
 */
typedef struct _D3DPROCESSVERTICES {
    DWORD        dwFlags;    /* Do we transform or light or just copy? */
    WORD         wStart;     /* Index to first vertex in source */
    WORD         wDest;      /* Index to first vertex in local buffer */
    DWORD        dwCount;    /* Number of vertices to be processed */
    DWORD    dwReserved; /* Must be zero */
} D3DPROCESSVERTICES, *LPD3DPROCESSVERTICES;

#define D3DPROCESSVERTICES_TRANSFORMLIGHT   0x00000000L
#define D3DPROCESSVERTICES_TRANSFORM        0x00000001L
#define D3DPROCESSVERTICES_COPY         0x00000002L
#define D3DPROCESSVERTICES_OPMASK       0x00000007L

#define D3DPROCESSVERTICES_UPDATEEXTENTS    0x00000008L
#define D3DPROCESSVERTICES_NOCOLOR      0x00000010L




/*
 * State enumerants for per-stage texture processing.
 */
typedef enum _D3DTEXTURESTAGESTATETYPE
{
    D3DTSS_COLOROP        =  1, /* D3DTEXTUREOP - per-stage blending controls for color channels */
    D3DTSS_COLORARG1      =  2, /* D3DTA_* (texture arg) */
    D3DTSS_COLORARG2      =  3, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAOP        =  4, /* D3DTEXTUREOP - per-stage blending controls for alpha channel */
    D3DTSS_ALPHAARG1      =  5, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAARG2      =  6, /* D3DTA_* (texture arg) */
    D3DTSS_BUMPENVMAT00   =  7, /* D3DVALUE (bump mapping matrix) */
    D3DTSS_BUMPENVMAT01   =  8, /* D3DVALUE (bump mapping matrix) */
    D3DTSS_BUMPENVMAT10   =  9, /* D3DVALUE (bump mapping matrix) */
    D3DTSS_BUMPENVMAT11   = 10, /* D3DVALUE (bump mapping matrix) */
    D3DTSS_TEXCOORDINDEX  = 11, /* identifies which set of texture coordinates index this texture */
    D3DTSS_ADDRESS        = 12, /* D3DTEXTUREADDRESS for both coordinates */
    D3DTSS_ADDRESSU       = 13, /* D3DTEXTUREADDRESS for U coordinate */
    D3DTSS_ADDRESSV       = 14, /* D3DTEXTUREADDRESS for V coordinate */
    D3DTSS_BORDERCOLOR    = 15, /* D3DCOLOR */
    D3DTSS_MAGFILTER      = 16, /* D3DTEXTUREMAGFILTER filter to use for magnification */
    D3DTSS_MINFILTER      = 17, /* D3DTEXTUREMINFILTER filter to use for minification */
    D3DTSS_MIPFILTER      = 18, /* D3DTEXTUREMIPFILTER filter to use between mipmaps during minification */
    D3DTSS_MIPMAPLODBIAS  = 19, /* D3DVALUE Mipmap LOD bias */
    D3DTSS_MAXMIPLEVEL    = 20, /* DWORD 0..(n-1) LOD index of largest map to use (0 == largest) */
    D3DTSS_MAXANISOTROPY  = 21, /* DWORD maximum anisotropy */
    D3DTSS_BUMPENVLSCALE  = 22, /* D3DVALUE scale for bump map luminance */
    D3DTSS_BUMPENVLOFFSET = 23, /* D3DVALUE offset for bump map luminance */
    D3DTSS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTURESTAGESTATETYPE;

/*
 * Enumerations for COLOROP and ALPHAOP texture blending operations set in
 * texture processing stage controls in D3DRENDERSTATE.
 */
typedef enum _D3DTEXTUREOP
{
// Control
    D3DTOP_DISABLE    = 1,      // disables stage
    D3DTOP_SELECTARG1 = 2,      // the default
    D3DTOP_SELECTARG2 = 3,

// Modulate
    D3DTOP_MODULATE   = 4,      // multiply args together
    D3DTOP_MODULATE2X = 5,      // multiply and  1 bit
    D3DTOP_MODULATE4X = 6,      // multiply and  2 bits

// Add
    D3DTOP_ADD          =  7,   // add arguments together
    D3DTOP_ADDSIGNED    =  8,   // add with -0.5 bias
    D3DTOP_ADDSIGNED2X  =  9,   // as above but left  1 bit
    D3DTOP_SUBTRACT     = 10,   // Arg1 - Arg2, with no saturation
    D3DTOP_ADDSMOOTH    = 11,   // add 2 args, subtract product
                                // Arg1 + Arg2 - Arg1*Arg2
                                // = Arg1 + (1-Arg1)*Arg2

// Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
    D3DTOP_BLENDDIFFUSEALPHA    = 12, // iterated alpha
    D3DTOP_BLENDTEXTUREALPHA    = 13, // texture alpha
    D3DTOP_BLENDFACTORALPHA     = 14, // alpha from D3DRENDERSTATE_TEXTUREFACTOR
    // Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
    D3DTOP_BLENDTEXTUREALPHAPM  = 15, // texture alpha
    D3DTOP_BLENDCURRENTALPHA    = 16, // by alpha of current color

// Specular mapping
    D3DTOP_PREMODULATE            = 17,     // modulate with next texture before use
    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
                                            // COLOROP only
    D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
                                            // COLOROP only
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
                                            // COLOROP only
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
                                            // COLOROP only

// Bump mapping
    D3DTOP_BUMPENVMAP           = 22, // per pixel env map perturbation
    D3DTOP_BUMPENVMAPLUMINANCE  = 23, // with luminance channel
    // This can do either diffuse or specular bump mapping with correct input.
    // Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
    // where each component has been scaled and offset to make it signed.
    // The result is replicated into all four (including alpha) channels.
    // This is a valid COLOROP only.
    D3DTOP_DOTPRODUCT3          = 24,

    D3DTOP_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREOP;

/*
 * Values for COLORARG1,2 and ALPHAARG1,2 texture blending operations
 * set in texture processing stage controls in D3DRENDERSTATE.
 */
#define D3DTA_SELECTMASK        0x0000000f  // mask for arg selector
#define D3DTA_DIFFUSE           0x00000000  // select diffuse color
#define D3DTA_CURRENT           0x00000001  // select result of previous stage
#define D3DTA_TEXTURE           0x00000002  // select texture color
#define D3DTA_TFACTOR           0x00000003  // select RENDERSTATE_TEXTUREFACTOR

#define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x
#define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components

/*
 *  IDirect3DTexture2 State Filter Types
 */
typedef enum _D3DTEXTUREMAGFILTER
{
    D3DTFG_POINT        = 1,    // nearest
    D3DTFG_LINEAR       = 2,    // linear interpolation
    D3DTFG_FLATCUBIC    = 3,    // cubic
    D3DTFG_GAUSSIANCUBIC = 4,   // different cubic kernel
    D3DTFG_ANISOTROPIC  = 5,    //
    D3DTFG_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREMAGFILTER;

typedef enum _D3DTEXTUREMINFILTER
{
    D3DTFN_POINT        = 1,    // nearest
    D3DTFN_LINEAR       = 2,    // linear interpolation
    D3DTFN_ANISOTROPIC  = 3,    //
    D3DTFN_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREMINFILTER;

typedef enum _D3DTEXTUREMIPFILTER
{
    D3DTFP_NONE         = 1,    // mipmapping disabled (use MAG filter)
    D3DTFP_POINT        = 2,    // nearest
    D3DTFP_LINEAR       = 3,    // linear interpolation
    D3DTFP_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREMIPFILTER;


/*
 * Triangle flags
 */

/*
 * Tri strip and fan flags.
 * START loads all three vertices
 * EVEN and ODD load just v3 with even or odd culling
 * START_FLAT contains a count from 0 to 29 that allows the
 * whole strip or fan to be culled in one hit.
 * e.g. for a quad len = 1
 */
#define D3DTRIFLAG_START            0x00000000L
#define D3DTRIFLAG_STARTFLAT(len) (len)     /* 0 < len < 30 */
#define D3DTRIFLAG_ODD              0x0000001eL
#define D3DTRIFLAG_EVEN             0x0000001fL

/*
 * Triangle edge flags
 * enable edges for wireframe or antialiasing
 */
#define D3DTRIFLAG_EDGEENABLE1          0x00000100L /* v0-v1 edge */
#define D3DTRIFLAG_EDGEENABLE2          0x00000200L /* v1-v2 edge */
#define D3DTRIFLAG_EDGEENABLE3          0x00000400L /* v2-v0 edge */
#define D3DTRIFLAG_EDGEENABLETRIANGLE \
        (D3DTRIFLAG_EDGEENABLE1 | D3DTRIFLAG_EDGEENABLE2 | D3DTRIFLAG_EDGEENABLE3)

/*
 * Primitive structures and related defines.  Vertex offsets are to types
 * D3DVERTEX, D3DLVERTEX, or D3DTLVERTEX.
 */

/*
 * Triangle list primitive structure
 */
typedef struct _D3DTRIANGLE {
    union {
    WORD    v1;            /* Vertex indices */
    WORD    wV1;
    };
    union {
    WORD    v2;
    WORD    wV2;
    };
    union {
    WORD    v3;
    WORD    wV3;
    };
    WORD        wFlags;       /* Edge (and other) flags */
} D3DTRIANGLE, *LPD3DTRIANGLE;

/*
 * Line list structure.
 * The instruction count defines the number of line segments.
 */
typedef struct _D3DLINE {
    union {
    WORD    v1;            /* Vertex indices */
    WORD    wV1;
    };
    union {
    WORD    v2;
    WORD    wV2;
    };
} D3DLINE, *LPD3DLINE;

/*
 * Span structure
 * Spans join a list of points with the same y value.
 * If the y value changes, a new span is started.
 */
typedef struct _D3DSPAN {
    WORD    wCount; /* Number of spans */
    WORD    wFirst; /* Index to first vertex */
} D3DSPAN, *LPD3DSPAN;

/*
 * Point structure
 */
typedef struct _D3DPOINT {
    WORD    wCount;     /* number of points     */
    WORD    wFirst;     /* index to first vertex    */
} D3DPOINT, *LPD3DPOINT;


/*
 * Forward branch structure.
 * Mask is logically anded with the driver status mask
 * if the result equals 'value', the branch is taken.
 */
typedef struct _D3DBRANCH {
    DWORD   dwMask;     /* Bitmask against D3D status */
    DWORD   dwValue;
    BOOL    bNegate;        /* TRUE to negate comparison */
    DWORD   dwOffset;   /* How far to branch forward (0 for exit)*/
} D3DBRANCH, *LPD3DBRANCH;

/*
 * Status used for set status instruction.
 * The D3D status is initialised on device creation
 * and is modified by all execute calls.
 */
typedef struct _D3DSTATUS {
    DWORD       dwFlags;    /* Do we set extents or status */
    DWORD   dwStatus;   /* D3D status */
    D3DRECT drExtent;
} D3DSTATUS, *LPD3DSTATUS;

#define D3DSETSTATUS_STATUS     0x00000001L
#define D3DSETSTATUS_EXTENTS        0x00000002L
#define D3DSETSTATUS_ALL    (D3DSETSTATUS_STATUS | D3DSETSTATUS_EXTENTS)

typedef struct _D3DCLIPSTATUS {
    DWORD dwFlags; /* Do we set 2d extents, 3D extents or status */
    DWORD dwStatus; /* Clip status */
    float minx, maxx; /* X extents */
    float miny, maxy; /* Y extents */
    float minz, maxz; /* Z extents */
} D3DCLIPSTATUS, *LPD3DCLIPSTATUS;

#define D3DCLIPSTATUS_STATUS        0x00000001L
#define D3DCLIPSTATUS_EXTENTS2      0x00000002L
#define D3DCLIPSTATUS_EXTENTS3      0x00000004L

/*
 * Statistics structure
 */
typedef struct _D3DSTATS {
    DWORD        dwSize;
    DWORD        dwTrianglesDrawn;
    DWORD        dwLinesDrawn;
    DWORD        dwPointsDrawn;
    DWORD        dwSpansDrawn;
    DWORD        dwVerticesProcessed;
} D3DSTATS, *LPD3DSTATS;

/*
 * Execute options.
 * When calling using D3DEXECUTE_UNCLIPPED all the primitives
 * inside the buffer must be contained within the viewport.
 */
#define D3DEXECUTE_CLIPPED       0x00000001l
#define D3DEXECUTE_UNCLIPPED     0x00000002l

typedef struct _D3DEXECUTEDATA {
    DWORD       dwSize;
    DWORD       dwVertexOffset;
    DWORD       dwVertexCount;
    DWORD       dwInstructionOffset;
    DWORD       dwInstructionLength;
    DWORD       dwHVertexOffset;
    D3DSTATUS   dsStatus;   /* Status after execute */
} D3DEXECUTEDATA, *LPD3DEXECUTEDATA;

/*
 * Palette flags.
 * This are or'ed with the peFlags in the PALETTEENTRYs passed to DirectDraw.
 */
#define D3DPAL_FREE 0x00    /* Renderer may use this entry freely */
#define D3DPAL_READONLY 0x40    /* Renderer may not set this entry */
#define D3DPAL_RESERVED 0x80    /* Renderer may not use this entry */



typedef struct _D3DVERTEXBUFFERDESC {
    DWORD dwSize;
    DWORD dwCaps;
    DWORD dwFVF;
    DWORD dwNumVertices;
} D3DVERTEXBUFFERDESC, *LPD3DVERTEXBUFFERDESC;

/* These correspond to DDSCAPS_* flags */
#define D3DVBCAPS_SYSTEMMEMORY      0x00000800l
#define D3DVBCAPS_WRITEONLY         0x00010000l
#define D3DVBCAPS_OPTIMIZED         0x80000000l

/* Vertex Operations for ProcessVertices */
#define D3DVOP_LIGHT       (1 << 10)
#define D3DVOP_TRANSFORM   (1 << 0)
#define D3DVOP_CLIP        (1 << 2)
#define D3DVOP_EXTENTS     (1 << 3)

//-------------------------------------------------------------------

// Flexible vertex format bits
//
#define D3DFVF_RESERVED0        0x001
#define D3DFVF_POSITION_MASK    0x00E
#define D3DFVF_XYZ              0x002
#define D3DFVF_XYZRHW           0x004
#define D3DFVF_NORMAL           0x010
#define D3DFVF_RESERVED1        0x020
#define D3DFVF_DIFFUSE          0x040
#define D3DFVF_SPECULAR         0x080

#define D3DFVF_TEXCOUNT_MASK    0xf00
#define D3DFVF_TEXCOUNT_SHIFT   8
#define D3DFVF_TEX0             0x000
#define D3DFVF_TEX1             0x100
#define D3DFVF_TEX2             0x200
#define D3DFVF_TEX3             0x300
#define D3DFVF_TEX4             0x400
#define D3DFVF_TEX5             0x500
#define D3DFVF_TEX6             0x600
#define D3DFVF_TEX7             0x700
#define D3DFVF_TEX8             0x800

#define D3DFVF_RESERVED2        0xf000  // 4 reserved bits

#define D3DFVF_VERTEX ( D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1 )
#define D3DFVF_LVERTEX ( D3DFVF_XYZ | D3DFVF_RESERVED1 | D3DFVF_DIFFUSE | \
                         D3DFVF_SPECULAR | D3DFVF_TEX1 )
#define D3DFVF_TLVERTEX ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | \
                          D3DFVF_TEX1 )

typedef struct _D3DDP_PTRSTRIDE
{
    LPVOID lpvData;
    DWORD  dwStride;
} D3DDP_PTRSTRIDE;

#define D3DDP_MAXTEXCOORD 8

typedef struct _D3DDRAWPRIMITIVESTRIDEDDATA
{
    D3DDP_PTRSTRIDE position;
    D3DDP_PTRSTRIDE normal;
    D3DDP_PTRSTRIDE diffuse;
    D3DDP_PTRSTRIDE specular;
    D3DDP_PTRSTRIDE textureCoords[D3DDP_MAXTEXCOORD];
} D3DDRAWPRIMITIVESTRIDEDDATA, *LPD3DDRAWPRIMITIVESTRIDEDDATA;
//---------------------------------------------------------------------
// ComputeSphereVisibility return values
//
#define D3DVIS_INSIDE_FRUSTUM       0
#define D3DVIS_INTERSECT_FRUSTUM    1
#define D3DVIS_OUTSIDE_FRUSTUM      2
#define D3DVIS_INSIDE_LEFT          0
#define D3DVIS_INTERSECT_LEFT       (1 << 2)
#define D3DVIS_OUTSIDE_LEFT         (2 << 2)
#define D3DVIS_INSIDE_RIGHT         0
#define D3DVIS_INTERSECT_RIGHT      (1 << 4)
#define D3DVIS_OUTSIDE_RIGHT        (2 << 4)
#define D3DVIS_INSIDE_TOP           0
#define D3DVIS_INTERSECT_TOP        (1 << 6)
#define D3DVIS_OUTSIDE_TOP          (2 << 6)
#define D3DVIS_INSIDE_BOTTOM        0
#define D3DVIS_INTERSECT_BOTTOM     (1 << 8)
#define D3DVIS_OUTSIDE_BOTTOM       (2 << 8)
#define D3DVIS_INSIDE_NEAR          0
#define D3DVIS_INTERSECT_NEAR       (1 << 10)
#define D3DVIS_OUTSIDE_NEAR         (2 << 10)
#define D3DVIS_INSIDE_FAR           0
#define D3DVIS_INTERSECT_FAR        (1 << 12)
#define D3DVIS_OUTSIDE_FAR          (2 << 12)

#define D3DVIS_MASK_FRUSTUM         (3 << 0)
#define D3DVIS_MASK_LEFT            (3 << 2)
#define D3DVIS_MASK_RIGHT           (3 << 4)
#define D3DVIS_MASK_TOP             (3 << 6)
#define D3DVIS_MASK_BOTTOM          (3 << 8)
#define D3DVIS_MASK_NEAR            (3 << 10)
#define D3DVIS_MASK_FAR             (3 << 12)


#pragma pack()
#endif /* _D3DTYPES_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\ddraw.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddraw.h
 *  Content:	DirectDraw include file
 *
 ***************************************************************************/

#ifndef __DDRAW_INCLUDED__
#define __DDRAW_INCLUDED__

/*
 * If you wish an application built against the newest version of DirectDraw
 * to run against an older DirectDraw run time then define DIRECTDRAW_VERSION
 * to be the earlies version of DirectDraw you wish to run against. For,
 * example if you wish an application to run against a DX 3 runtime define
 * DIRECTDRAW_VERSION to be 0x0300.
 */
#ifndef   DIRECTDRAW_VERSION
#define   DIRECTDRAW_VERSION 0x0600
#endif /* DIRECTDRAW_VERSION */

#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#if !defined( NT_BUILD_ENVIRONMENT ) && !defined(WINNT)
	#define CO_E_NOTINITIALIZED 0x800401F0L
#endif
#endif

#define _FACDD	0x876
#define MAKE_DDHRESULT( code )	MAKE_HRESULT( 1, _FACDD, code )

#ifdef __cplusplus
extern "C" {
#endif

//
// For compilers that don't support nameless unions, do a
//
// #define NONAMELESSUNION
//
// before #include <ddraw.h>
//
#ifndef DUMMYUNIONNAMEN
#if defined(__cplusplus) || !defined(NONAMELESSUNION)
#define DUMMYUNIONNAMEN(n)
#else
#define DUMMYUNIONNAMEN(n)      u##n
#endif
#endif

/*
 * GUIDS used by DirectDraw objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )

DEFINE_GUID( CLSID_DirectDraw,			0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35 );
DEFINE_GUID( CLSID_DirectDrawClipper,           0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw,			0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDraw2,                  0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw4,                  0x9c59509a,0x39bd,0x11d1,0x8c,0x4a,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( IID_IDirectDrawSurface,		0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawSurface2,		0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27 );
DEFINE_GUID( IID_IDirectDrawSurface3,           0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );
DEFINE_GUID( IID_IDirectDrawSurface4,           0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B );

DEFINE_GUID( IID_IDirectDrawPalette,		0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawClipper,		0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawColorControl, 	0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawGammaControl,       0x69C11C3E,0xB46B,0x11D1,0xAD,0x7A,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );

#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDirectDraw              FAR *LPDIRECTDRAW;
typedef struct IDirectDraw2             FAR *LPDIRECTDRAW2;
typedef struct IDirectDraw4             FAR *LPDIRECTDRAW4;
typedef struct IDirectDrawSurface       FAR *LPDIRECTDRAWSURFACE;
typedef struct IDirectDrawSurface2      FAR *LPDIRECTDRAWSURFACE2;
typedef struct IDirectDrawSurface3      FAR *LPDIRECTDRAWSURFACE3;
typedef struct IDirectDrawSurface4      FAR *LPDIRECTDRAWSURFACE4;

typedef struct IDirectDrawPalette		FAR *LPDIRECTDRAWPALETTE;
typedef struct IDirectDrawClipper		FAR *LPDIRECTDRAWCLIPPER;
typedef struct IDirectDrawColorControl		FAR *LPDIRECTDRAWCOLORCONTROL;
typedef struct IDirectDrawGammaControl          FAR *LPDIRECTDRAWGAMMACONTROL;

typedef struct _DDFXROP			FAR *LPDDFXROP;
typedef struct _DDSURFACEDESC		FAR *LPDDSURFACEDESC;
typedef struct _DDSURFACEDESC2		FAR *LPDDSURFACEDESC2;
typedef struct _DDCOLORCONTROL 		FAR *LPDDCOLORCONTROL;

/*
 * API's
 */
#if (defined (WIN32) || defined( _WIN32 ) ) && !defined( _NO_COM )
//#if defined( _WIN32 ) && !defined( _NO_ENUM )
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKA)(GUID FAR *, LPSTR, LPSTR, LPVOID);
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID);
    extern HRESULT WINAPI DirectDrawEnumerateW( LPDDENUMCALLBACKW lpCallback, LPVOID lpContext );
    extern HRESULT WINAPI DirectDrawEnumerateA( LPDDENUMCALLBACKA lpCallback, LPVOID lpContext );
    /*
     * Protect against old SDKs
     */
    #ifndef SM_CMONITORS
        #define HMONITOR    HANDLE
    #endif
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKEXA)(GUID FAR *, LPSTR, LPSTR, LPVOID, HMONITOR);
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKEXW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID, HMONITOR);
    extern HRESULT WINAPI DirectDrawEnumerateExW( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DWORD dwFlags);
    extern HRESULT WINAPI DirectDrawEnumerateExA( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DWORD dwFlags);
    typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEXA)( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DWORD dwFlags);
    typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEXW)( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DWORD dwFlags);

    #ifdef UNICODE
	typedef LPDDENUMCALLBACKW 	    LPDDENUMCALLBACK;
	#define DirectDrawEnumerate	    DirectDrawEnumerateW
	typedef LPDDENUMCALLBACKEXW 	    LPDDENUMCALLBACKEX;
	typedef LPDIRECTDRAWENUMERATEEXW        LPDIRECTDRAWENUMERATEEX;
	#define DirectDrawEnumerateEx	    DirectDrawEnumerateExW
    #else
	typedef LPDDENUMCALLBACKA 	    LPDDENUMCALLBACK;
	#define DirectDrawEnumerate	    DirectDrawEnumerateA
	typedef LPDDENUMCALLBACKEXA 	    LPDDENUMCALLBACKEX;
    	typedef LPDIRECTDRAWENUMERATEEXA        LPDIRECTDRAWENUMERATEEX;
        #define DirectDrawEnumerateEx	    DirectDrawEnumerateExA
    #endif
    extern HRESULT WINAPI DirectDrawCreate( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );
    extern HRESULT WINAPI DirectDrawCreateClipper( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
#endif
/*
 * Flags for DirectDrawEnumerateEx
 * DirectDrawEnumerateEx supercedes DirectDrawEnumerate. You must use GetProcAddress to
 * obtain a function pointer (of type LPDIRECTDRAWENUMERATEEX) to DirectDrawEnumerateEx.
 * By default, only the primary display device is enumerated.
 * DirectDrawEnumerate is equivalent to DirectDrawEnumerate(,,DDENUM_NONDISPLAYDEVICES)
 */

/*
 * This flag causes enumeration of any GDI display devices which are part of
 * the Windows Desktop
 */
#define DDENUM_ATTACHEDSECONDARYDEVICES     0x00000001L

/*
 * This flag causes enumeration of any GDI display devices which are not
 * part of the Windows Desktop
 */
#define DDENUM_DETACHEDSECONDARYDEVICES     0x00000002L

/*
 * This flag causes enumeration of non-display devices
 */
#define DDENUM_NONDISPLAYDEVICES            0x00000004L


#define REGSTR_KEY_DDHW_DESCRIPTION	"Description"
#define REGSTR_KEY_DDHW_DRIVERNAME	"DriverName"
#define REGSTR_PATH_DDHW		"Hardware\\DirectDrawDrivers"

#define DDCREATE_HARDWAREONLY		0x00000001l
#define DDCREATE_EMULATIONONLY		0x00000002l

#if defined(WINNT) || !defined(WIN32)
typedef long HRESULT;
#endif

//#ifndef WINNT
typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK)(LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK2)(LPDDSURFACEDESC2, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK)(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK2)(LPDIRECTDRAWSURFACE4, LPDDSURFACEDESC2, LPVOID);
//#endif

/*
 * Generic pixel format with 8-bit RGB and alpha components
 */
typedef struct _DDRGBA
{
    BYTE red;
    BYTE green;
    BYTE blue;
    BYTE alpha;
} DDRGBA;

typedef DDRGBA FAR *LPDDRGBA;

/*
 * DDCOLORKEY
 */
typedef struct _DDCOLORKEY
{
    DWORD	dwColorSpaceLowValue;	// low boundary of color space that is to
					// be treated as Color Key, inclusive
    DWORD	dwColorSpaceHighValue;	// high boundary of color space that is
					// to be treated as Color Key, inclusive
} DDCOLORKEY;

typedef DDCOLORKEY FAR* LPDDCOLORKEY;

/*
 * DDBLTFX
 * Used to pass override information to the DIRECTDRAWSURFACE callback Blt.
 */
typedef struct _DDBLTFX
{
    DWORD	dwSize;				// size of structure
    DWORD	dwDDFX;				// FX operations
    DWORD	dwROP;				// Win32 raster operations
    DWORD	dwDDROP;			// Raster operations new for DirectDraw
    DWORD	dwRotationAngle;		// Rotation angle for blt
    DWORD	dwZBufferOpCode;		// ZBuffer compares
    DWORD	dwZBufferLow;			// Low limit of Z buffer
    DWORD	dwZBufferHigh;			// High limit of Z buffer
    DWORD	dwZBufferBaseDest;		// Destination base value
    DWORD	dwZDestConstBitDepth;		// Bit depth used to specify Z constant for destination
    union
    {
	DWORD	dwZDestConst;			// Constant to use as Z buffer for dest
	LPDIRECTDRAWSURFACE lpDDSZBufferDest;	// Surface to use as Z buffer for dest
    } DUMMYUNIONNAMEN(1);
    DWORD	dwZSrcConstBitDepth;		// Bit depth used to specify Z constant for source
    union
    {
	DWORD	dwZSrcConst;			// Constant to use as Z buffer for src
	LPDIRECTDRAWSURFACE lpDDSZBufferSrc;	// Surface to use as Z buffer for src
    } DUMMYUNIONNAMEN(2);
    DWORD	dwAlphaEdgeBlendBitDepth;	// Bit depth used to specify constant for alpha edge blend
    DWORD	dwAlphaEdgeBlend;		// Alpha for edge blending
    DWORD	dwReserved;
    DWORD	dwAlphaDestConstBitDepth;	// Bit depth used to specify alpha constant for destination
    union
    {
	DWORD	dwAlphaDestConst;		// Constant to use as Alpha Channel
	LPDIRECTDRAWSURFACE lpDDSAlphaDest;	// Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(3);
    DWORD	dwAlphaSrcConstBitDepth;	// Bit depth used to specify alpha constant for source
    union
    {
	DWORD	dwAlphaSrcConst;		// Constant to use as Alpha Channel
	LPDIRECTDRAWSURFACE lpDDSAlphaSrc;	// Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(4);
    union
    {
	DWORD	dwFillColor;			// color in RGB or Palettized
	DWORD   dwFillDepth;                    // depth value for z-buffer
	DWORD	dwFillPixel;			// pixel value for RGBA or RGBZ
	LPDIRECTDRAWSURFACE lpDDSPattern;	// Surface to use as pattern
    } DUMMYUNIONNAMEN(5);
    DDCOLORKEY	ddckDestColorkey;		// DestColorkey override
    DDCOLORKEY	ddckSrcColorkey;		// SrcColorkey override
} DDBLTFX;

typedef DDBLTFX FAR* LPDDBLTFX;


/*
 * DDSCAPS
 */
typedef struct _DDSCAPS
{
    DWORD	dwCaps;		// capabilities of surface wanted
} DDSCAPS;

typedef DDSCAPS FAR* LPDDSCAPS;


/*
 * DDOSCAPS
 */
typedef struct _DDOSCAPS
{
    DWORD	dwCaps;		// capabilities of surface wanted
} DDOSCAPS;

typedef DDOSCAPS FAR* LPDDOSCAPS;

/*
 * This structure is used internally by DirectDraw.
 */
typedef struct _DDSCAPSEX
{
    DWORD       dwCaps2;
    DWORD       dwCaps3;
    DWORD       dwCaps4;
} DDSCAPSEX, FAR * LPDDSCAPSEX;

/*
 * DDSCAPS2
 */
typedef struct _DDSCAPS2
{
    DWORD	dwCaps;		// capabilities of surface wanted
    DWORD       dwCaps2;
    DWORD       dwCaps3;
    DWORD       dwCaps4;
} DDSCAPS2;

typedef DDSCAPS2 FAR* LPDDSCAPS2;

/*
 * DDCAPS
 */
#define DD_ROP_SPACE		(256/32)	// space required to store ROP array

#if DIRECTDRAW_VERSION >= 0x0500
/*
 * This structure is the DDCAPS structure as it was in version 2 and 3 of Direct X.
 * It is present for back compatability.
 */
typedef struct _DDCAPS_DX3
{
    DWORD	dwSize;			// size of the DDDRIVERCAPS structure
    DWORD	dwCaps;			// driver specific capabilities
    DWORD	dwCaps2;		// more driver specific capabilites
    DWORD	dwCKeyCaps;		// color key capabilities of the surface
    DWORD	dwFXCaps;		// driver specific stretching and effects capabilites
    DWORD	dwFXAlphaCaps;		// alpha driver specific capabilities
    DWORD	dwPalCaps;		// palette capabilities
    DWORD	dwSVCaps;		// stereo vision capabilities
    DWORD	dwAlphaBltConstBitDepths;	// DDBD_2,4,8
    DWORD	dwAlphaBltPixelBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaBltSurfaceBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaOverlayConstBitDepths;	// DDBD_2,4,8
    DWORD	dwAlphaOverlayPixelBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD	dwZBufferBitDepths;		// DDBD_8,16,24,32
    DWORD	dwVidMemTotal;		// total amount of video memory
    DWORD	dwVidMemFree;		// amount of free video memory
    DWORD	dwMaxVisibleOverlays;	// maximum number of visible overlays
    DWORD	dwCurrVisibleOverlays;	// current number of visible overlays
    DWORD	dwNumFourCCCodes;	// number of four cc codes
    DWORD	dwAlignBoundarySrc;	// source rectangle alignment
    DWORD	dwAlignSizeSrc;		// source rectangle byte size
    DWORD	dwAlignBoundaryDest;	// dest rectangle alignment
    DWORD	dwAlignSizeDest;	// dest rectangle byte size
    DWORD	dwAlignStrideAlign;	// stride alignment
    DWORD	dwRops[DD_ROP_SPACE];	// ROPS supported
    DDSCAPS	ddsCaps;		// DDSCAPS structure has all the general capabilities
    DWORD	dwMinOverlayStretch;	// minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxOverlayStretch;	// maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMinLiveVideoStretch;	// minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxLiveVideoStretch;	// maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMinHwCodecStretch;	// minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxHwCodecStretch;	// maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwReserved1;		// reserved
    DWORD	dwReserved2;		// reserved
    DWORD	dwReserved3;		// reserved
    DWORD	dwSVBCaps;		// driver specific capabilities for System->Vmem blts
    DWORD	dwSVBCKeyCaps;		// driver color key capabilities for System->Vmem blts
    DWORD	dwSVBFXCaps;		// driver FX capabilities for System->Vmem blts
    DWORD	dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD	dwVSBCaps;		// driver specific capabilities for Vmem->System blts
    DWORD	dwVSBCKeyCaps;		// driver color key capabilities for Vmem->System blts
    DWORD	dwVSBFXCaps;		// driver FX capabilities for Vmem->System blts
    DWORD	dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD	dwSSBCaps;		// driver specific capabilities for System->System blts
    DWORD	dwSSBCKeyCaps;		// driver color key capabilities for System->System blts
    DWORD	dwSSBFXCaps;		// driver FX capabilities for System->System blts
    DWORD	dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD	dwReserved4;		// reserved
    DWORD	dwReserved5;		// reserved
    DWORD	dwReserved6;		// reserved
} DDCAPS_DX3;
typedef DDCAPS_DX3 FAR* LPDDCAPS_DX3;
#endif /* DIRECTDRAW_VERSION >= 0x0500 */

#if DIRECTDRAW_VERSION >= 0x0600
/*
 * This structure is the DDCAPS structure as it was in version 5 of Direct X.
 * It is present for back compatability.
 */
typedef struct _DDCAPS_DX5
{
/*  0*/ DWORD	dwSize;			// size of the DDDRIVERCAPS structure
/*  4*/ DWORD	dwCaps;			// driver specific capabilities
/*  8*/ DWORD	dwCaps2;		// more driver specific capabilites
/*  c*/ DWORD	dwCKeyCaps;		// color key capabilities of the surface
/* 10*/ DWORD	dwFXCaps;		// driver specific stretching and effects capabilites
/* 14*/ DWORD	dwFXAlphaCaps;		// alpha driver specific capabilities
/* 18*/ DWORD	dwPalCaps;		// palette capabilities
/* 1c*/ DWORD	dwSVCaps;		// stereo vision capabilities
/* 20*/ DWORD	dwAlphaBltConstBitDepths;	// DDBD_2,4,8
/* 24*/ DWORD	dwAlphaBltPixelBitDepths;	// DDBD_1,2,4,8
/* 28*/ DWORD	dwAlphaBltSurfaceBitDepths;	// DDBD_1,2,4,8
/* 2c*/ DWORD	dwAlphaOverlayConstBitDepths;	// DDBD_2,4,8
/* 30*/ DWORD	dwAlphaOverlayPixelBitDepths;	// DDBD_1,2,4,8
/* 34*/ DWORD	dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD	dwZBufferBitDepths;		// DDBD_8,16,24,32
/* 3c*/ DWORD	dwVidMemTotal;		// total amount of video memory
/* 40*/ DWORD	dwVidMemFree;		// amount of free video memory
/* 44*/ DWORD	dwMaxVisibleOverlays;	// maximum number of visible overlays
/* 48*/ DWORD	dwCurrVisibleOverlays;	// current number of visible overlays
/* 4c*/ DWORD	dwNumFourCCCodes;	// number of four cc codes
/* 50*/ DWORD	dwAlignBoundarySrc;	// source rectangle alignment
/* 54*/ DWORD	dwAlignSizeSrc;		// source rectangle byte size
/* 58*/ DWORD	dwAlignBoundaryDest;	// dest rectangle alignment
/* 5c*/ DWORD	dwAlignSizeDest;	// dest rectangle byte size
/* 60*/ DWORD	dwAlignStrideAlign;	// stride alignment
/* 64*/ DWORD	dwRops[DD_ROP_SPACE];	// ROPS supported
/* 84*/ DDSCAPS	ddsCaps;		// DDSCAPS structure has all the general capabilities
/* 88*/ DWORD	dwMinOverlayStretch;	// minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD	dwMaxOverlayStretch;	// maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD	dwMinLiveVideoStretch;	// minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD	dwMaxLiveVideoStretch;	// maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD	dwMinHwCodecStretch;	// minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD	dwMaxHwCodecStretch;	// maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD	dwReserved1;		// reserved
/* a4*/ DWORD	dwReserved2;		// reserved
/* a8*/ DWORD	dwReserved3;		// reserved
/* ac*/ DWORD	dwSVBCaps;		// driver specific capabilities for System->Vmem blts
/* b0*/ DWORD	dwSVBCKeyCaps;		// driver color key capabilities for System->Vmem blts
/* b4*/ DWORD	dwSVBFXCaps;		// driver FX capabilities for System->Vmem blts
/* b8*/ DWORD	dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD	dwVSBCaps;		// driver specific capabilities for Vmem->System blts
/* dc*/ DWORD	dwVSBCKeyCaps;		// driver color key capabilities for Vmem->System blts
/* e0*/ DWORD	dwVSBFXCaps;		// driver FX capabilities for Vmem->System blts
/* e4*/ DWORD	dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD	dwSSBCaps;		// driver specific capabilities for System->System blts
/*108*/ DWORD	dwSSBCKeyCaps;		// driver color key capabilities for System->System blts
/*10c*/ DWORD	dwSSBFXCaps;		// driver FX capabilities for System->System blts
/*110*/ DWORD	dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
// Members added for DX5:
/*130*/ DWORD	dwMaxVideoPorts;	// maximum number of usable video ports
/*134*/ DWORD	dwCurrVideoPorts;	// current number of video ports used
/*138*/ DWORD	dwSVBCaps2;		// more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD	dwNLVBCaps;		  // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD	dwNLVBCaps2;		  // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD	dwNLVBCKeyCaps;		  // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD	dwNLVBFXCaps;		  // driver FX capabilities for non-local->local blts
/*14c*/ DWORD	dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
} DDCAPS_DX5;

typedef DDCAPS_DX5 FAR* LPDDCAPS_DX5;
#endif /* DIRECTDRAW_VERSION >= 0x0600 */

typedef struct _DDCAPS
{
/*  0*/ DWORD	dwSize;			// size of the DDDRIVERCAPS structure
/*  4*/ DWORD	dwCaps;			// driver specific capabilities
/*  8*/ DWORD	dwCaps2;		// more driver specific capabilites
/*  c*/ DWORD	dwCKeyCaps;		// color key capabilities of the surface
/* 10*/ DWORD	dwFXCaps;		// driver specific stretching and effects capabilites
/* 14*/ DWORD	dwFXAlphaCaps;		// alpha caps
/* 18*/ DWORD	dwPalCaps;		// palette capabilities
/* 1c*/ DWORD	dwSVCaps;		// stereo vision capabilities
/* 20*/ DWORD	dwAlphaBltConstBitDepths;	// DDBD_2,4,8
/* 24*/ DWORD	dwAlphaBltPixelBitDepths;	// DDBD_1,2,4,8
/* 28*/ DWORD	dwAlphaBltSurfaceBitDepths;	// DDBD_1,2,4,8
/* 2c*/ DWORD	dwAlphaOverlayConstBitDepths;	// DDBD_2,4,8
/* 30*/ DWORD	dwAlphaOverlayPixelBitDepths;	// DDBD_1,2,4,8
/* 34*/ DWORD	dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD	dwZBufferBitDepths;		// DDBD_8,16,24,32
/* 3c*/ DWORD	dwVidMemTotal;		// total amount of video memory
/* 40*/ DWORD	dwVidMemFree;		// amount of free video memory
/* 44*/ DWORD	dwMaxVisibleOverlays;	// maximum number of visible overlays
/* 48*/ DWORD	dwCurrVisibleOverlays;	// current number of visible overlays
/* 4c*/ DWORD	dwNumFourCCCodes;	// number of four cc codes
/* 50*/ DWORD	dwAlignBoundarySrc;	// source rectangle alignment
/* 54*/ DWORD	dwAlignSizeSrc;		// source rectangle byte size
/* 58*/ DWORD	dwAlignBoundaryDest;	// dest rectangle alignment
/* 5c*/ DWORD	dwAlignSizeDest;	// dest rectangle byte size
/* 60*/ DWORD	dwAlignStrideAlign;	// stride alignment
/* 64*/ DWORD	dwRops[DD_ROP_SPACE];	// ROPS supported
/* 84*/ DWORD   dwReservedCaps;         // Was DDSCAPS	ddsCaps;
/* 88*/ DWORD	dwMinOverlayStretch;	// minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD	dwMaxOverlayStretch;	// maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD	dwMinLiveVideoStretch;	// minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD	dwMaxLiveVideoStretch;	// maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD	dwMinHwCodecStretch;	// minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD	dwMaxHwCodecStretch;	// maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD	dwReserved1;		// reserved
/* a4*/ DWORD	dwReserved2;		// reserved
/* a8*/ DWORD	dwReserved3;		// reserved
/* ac*/ DWORD	dwSVBCaps;		// driver specific capabilities for System->Vmem blts
/* b0*/ DWORD	dwSVBCKeyCaps;		// driver color key capabilities for System->Vmem blts
/* b4*/ DWORD	dwSVBFXCaps;		// driver FX capabilities for System->Vmem blts
/* b8*/ DWORD	dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD	dwVSBCaps;		// driver specific capabilities for Vmem->System blts
/* dc*/ DWORD	dwVSBCKeyCaps;		// driver color key capabilities for Vmem->System blts
/* e0*/ DWORD	dwVSBFXCaps;		// driver FX capabilities for Vmem->System blts
/* e4*/ DWORD	dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD	dwSSBCaps;		// driver specific capabilities for System->System blts
/*108*/ DWORD	dwSSBCKeyCaps;		// driver color key capabilities for System->System blts
/*10c*/ DWORD	dwSSBFXCaps;		// driver FX capabilities for System->System blts
/*110*/ DWORD	dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
#if       DIRECTDRAW_VERSION >= 0x0500
/*130*/ DWORD	dwMaxVideoPorts;	// maximum number of usable video ports
/*134*/ DWORD	dwCurrVideoPorts;	// current number of video ports used
/*138*/ DWORD	dwSVBCaps2;		// more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD	dwNLVBCaps;		  // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD	dwNLVBCaps2;		  // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD	dwNLVBCKeyCaps;		  // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD	dwNLVBFXCaps;		  // driver FX capabilities for non-local->local blts
/*14c*/ DWORD	dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
#if       DIRECTDRAW_VERSION >= 0x0600
// Members added for DX6 release
/*16c*/ DDSCAPS2 ddsCaps;               // Surface Caps
#endif /* DIRECTDRAW_VERSION >= 0x0600 */
#else  /* DIRECTDRAW_VERSION >= 0x0500 */
/*130*/ DWORD	dwReserved4;		// reserved
/*134*/ DWORD	dwReserved5;		// reserved
/*138*/ DWORD	dwReserved6;		// reserved
#endif /* DIRECTDRAW_VERSION >= 0x0500 */
} DDCAPS;

typedef DDCAPS FAR* LPDDCAPS;



/*
 * DDPIXELFORMAT
 */
typedef struct _DDPIXELFORMAT
{
    DWORD	dwSize;			// size of structure
    DWORD	dwFlags;		// pixel format flags
    DWORD	dwFourCC;		// (FOURCC code)
    union
    {
	DWORD	dwRGBBitCount;		// how many bits per pixel
	DWORD	dwYUVBitCount;		// how many bits per pixel
	DWORD	dwZBufferBitDepth;	// how many total bits/pixel in z buffer (including any stencil bits)
	DWORD	dwAlphaBitDepth;	// how many bits for alpha channels
	DWORD   dwLuminanceBitCount;	// how many bits per pixel
        DWORD   dwBumpBitCount;         // how many bits per "buxel", total
    } DUMMYUNIONNAMEN(1);
    union
    {
	DWORD	dwRBitMask;		// mask for red bit
	DWORD	dwYBitMask;		// mask for Y bits
	DWORD   dwStencilBitDepth;	// how many stencil bits (note: dwZBufferBitDepth-dwStencilBitDepth is total Z-only bits)
	DWORD   dwLuminanceBitMask;	// mask for luminance bits
        DWORD   dwBumpDuBitMask;        // mask for bump map U delta bits
    } DUMMYUNIONNAMEN(2);
    union
    {
	DWORD	dwGBitMask;		// mask for green bits
	DWORD	dwUBitMask;		// mask for U bits
	DWORD   dwZBitMask;		// mask for Z bits
        DWORD   dwBumpDvBitMask;        // mask for bump map V delta bits
    } DUMMYUNIONNAMEN(3);
    union
    {
	DWORD	dwBBitMask;		// mask for blue bits
	DWORD	dwVBitMask;		// mask for V bits
	DWORD   dwStencilBitMask;	// mask for stencil bits
        DWORD   dwBumpLuminanceBitMask; // mask for luminance in bump map
    } DUMMYUNIONNAMEN(4);
    union
    {
	DWORD	dwRGBAlphaBitMask;	// mask for alpha channel
	DWORD	dwYUVAlphaBitMask;	// mask for alpha channel
        DWORD   dwLuminanceAlphaBitMask;// mask for alpha channel
	DWORD	dwRGBZBitMask;		// mask for Z channel
	DWORD	dwYUVZBitMask;		// mask for Z channel
    } DUMMYUNIONNAMEN(5);
} DDPIXELFORMAT;

typedef DDPIXELFORMAT FAR* LPDDPIXELFORMAT;

/*
 * DDOVERLAYFX
 */
typedef struct _DDOVERLAYFX
{
    DWORD	dwSize;				// size of structure
    DWORD	dwAlphaEdgeBlendBitDepth;	// Bit depth used to specify constant for alpha edge blend
    DWORD	dwAlphaEdgeBlend;		// Constant to use as alpha for edge blend
    DWORD	dwReserved;
    DWORD	dwAlphaDestConstBitDepth;	// Bit depth used to specify alpha constant for destination
    union
    {
	DWORD	dwAlphaDestConst;		// Constant to use as alpha channel for dest
	LPDIRECTDRAWSURFACE lpDDSAlphaDest;	// Surface to use as alpha channel for dest
    } DUMMYUNIONNAMEN(1);
    DWORD	dwAlphaSrcConstBitDepth;	// Bit depth used to specify alpha constant for source
    union
    {
	DWORD	dwAlphaSrcConst;		// Constant to use as alpha channel for src
	LPDIRECTDRAWSURFACE lpDDSAlphaSrc;	// Surface to use as alpha channel for src
    } DUMMYUNIONNAMEN(2);
    DDCOLORKEY	dckDestColorkey;		// DestColorkey override
    DDCOLORKEY	dckSrcColorkey;			// DestColorkey override
    DWORD       dwDDFX;                         // Overlay FX
    DWORD	dwFlags;			// flags
} DDOVERLAYFX;

typedef DDOVERLAYFX FAR *LPDDOVERLAYFX;


/*
 * DDBLTBATCH: BltBatch entry structure
 */
typedef struct _DDBLTBATCH
{
    LPRECT		lprDest;
    LPDIRECTDRAWSURFACE	lpDDSSrc;
    LPRECT		lprSrc;
    DWORD		dwFlags;
    LPDDBLTFX		lpDDBltFx;
} DDBLTBATCH;

typedef DDBLTBATCH FAR * LPDDBLTBATCH;


/*
 * DDGAMMARAMP
 */
typedef struct _DDGAMMARAMP
{
    WORD                red[256];
    WORD                green[256];
    WORD                blue[256];
} DDGAMMARAMP;
typedef DDGAMMARAMP FAR * LPDDGAMMARAMP;

/*
 * callbacks
 */
typedef DWORD	(FAR PASCAL *LPCLIPPERCALLBACK)(LPDIRECTDRAWCLIPPER lpDDClipper, HWND hWnd, DWORD code, LPVOID lpContext );
#ifdef STREAMING
typedef DWORD	(FAR PASCAL *LPSURFACESTREAMINGCALLBACK)(DWORD);
#endif


/*
 * INTERACES FOLLOW:
 *	IDirectDraw
 *	IDirectDrawClipper
 *	IDirectDrawPalette
 *	IDirectDrawSurface
 */

/*
 * IDirectDraw
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw
DECLARE_INTERFACE_( IDirectDraw, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->lpVtbl->SetDisplayMode(p, a, b, c)
#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#else
#define IDirectDraw_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw_AddRef(p)                       (p)->AddRef()
#define IDirectDraw_Release(p)                      (p)->Release()
#define IDirectDraw_Compact(p)                      (p)->Compact()
#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->SetDisplayMode(a, b, c)
#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw2
DECLARE_INTERFACE_( IDirectDraw2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw2_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw2_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw2_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw2_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw2_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw2_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw2_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw2_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw2_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw2_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw2_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#else
#define IDirectDraw2_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw2_AddRef(p)                       (p)->AddRef()
#define IDirectDraw2_Release(p)                      (p)->Release()
#define IDirectDraw2_Compact(p)                      (p)->Compact()
#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw2_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw2_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw2_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw2_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw2_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw2_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw2_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw4
DECLARE_INTERFACE_( IDirectDraw4, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE4 FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE4, LPDIRECTDRAWSURFACE4 FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMMODESCALLBACK2 ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC2, LPVOID,LPDDENUMSURFACESCALLBACK2 ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE4 FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS2, LPDWORD, LPDWORD) PURE;
    /*** Added in the V4 Interface ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, LPDIRECTDRAWSURFACE4 *) PURE;
    STDMETHOD(RestoreAllSurfaces)(THIS) PURE;
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw4_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw4_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw4_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw4_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw4_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw4_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw4_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw4_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw4_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw4_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw4_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw4_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw4_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw4_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw4_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw4_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw4_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw4_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw4_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw4_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw4_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw4_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw4_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw4_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw4_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#define IDirectDraw4_RestoreAllSurfaces(p)           (p)->lpVtbl->RestoreAllSurfaces(p)
#define IDirectDraw4_TestCooperativeLevel(p)         (p)->lpVtbl->TestCooperativeLevel(p)
#else
#define IDirectDraw4_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw4_AddRef(p)                       (p)->AddRef()
#define IDirectDraw4_Release(p)                      (p)->Release()
#define IDirectDraw4_Compact(p)                      (p)->Compact()
#define IDirectDraw4_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw4_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw4_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw4_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw4_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw4_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw4_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw4_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw4_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw4_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw4_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw4_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw4_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw4_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw4_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw4_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw4_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw4_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw4_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw4_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#define IDirectDraw4_GetSurfaceFromDC(p, a, b)       (p)->GetSurfaceFromDC(a, b)
#define IDirectDraw4_RestoreAllSurfaces(p)           (p)->RestoreAllSurfaces()
#define IDirectDraw4_TestCooperativeLevel(p)         (p)->TestCooperativeLevel()
#endif

#endif


/*
 * IDirectDrawPalette
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawPalette
DECLARE_INTERFACE_( IDirectDrawPalette, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawPalette methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD, LPPALETTEENTRY) PURE;
    STDMETHOD(SetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawPalette_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawPalette_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawPalette_GetCaps(p, a)                (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->lpVtbl->GetEntries(p, a, b, c, d)
#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->lpVtbl->Initialize(p, a, b, c)
#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->lpVtbl->SetEntries(p, a, b, c, d)
#else
#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->QueryInterface(a, b)
#define IDirectDrawPalette_AddRef(p)                    (p)->AddRef()
#define IDirectDrawPalette_Release(p)                   (p)->Release()
#define IDirectDrawPalette_GetCaps(p, a)                (p)->GetCaps(a)
#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->GetEntries(a, b, c, d)
#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->Initialize(a, b, c)
#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->SetEntries(a, b, c, d)
#endif

#endif



/*
 * IDirectDrawClipper
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawClipper
DECLARE_INTERFACE_( IDirectDrawClipper, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawClipper methods ***/
    STDMETHOD(GetClipList)(THIS_ LPRECT, LPRGNDATA, LPDWORD) PURE;
    STDMETHOD(GetHWnd)(THIS_ HWND FAR *) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD) PURE;
    STDMETHOD(IsClipListChanged)(THIS_ BOOL FAR *) PURE;
    STDMETHOD(SetClipList)(THIS_ LPRGNDATA,DWORD) PURE;
    STDMETHOD(SetHWnd)(THIS_ DWORD, HWND ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawClipper_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawClipper_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->lpVtbl->GetClipList(p, a, b, c)
#define IDirectDrawClipper_GetHWnd(p, a)            (p)->lpVtbl->GetHWnd(p, a)
#define IDirectDrawClipper_Initialize(p, a, b)      (p)->lpVtbl->Initialize(p, a, b)
#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->lpVtbl->IsClipListChanged(p, a)
#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->lpVtbl->SetClipList(p, a, b)
#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->lpVtbl->SetHWnd(p, a, b)
#else
#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawClipper_AddRef(p)                (p)->AddRef()
#define IDirectDrawClipper_Release(p)               (p)->Release()
#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->GetClipList(a, b, c)
#define IDirectDrawClipper_GetHWnd(p, a)            (p)->GetHWnd(a)
#define IDirectDrawClipper_Initialize(p, a, b)      (p)->Initialize(a, b)
#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->IsClipListChanged(a)
#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->SetClipList(a, b)
#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->SetHWnd(a, b)
#endif

#endif

/*
 * IDirectDrawSurface and related interfaces
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawSurface
DECLARE_INTERFACE_( IDirectDrawSurface, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#else
#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface_Release(p)                   (p)->Release()
#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#endif

/*
 * IDirectDrawSurface2 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface2
DECLARE_INTERFACE_( IDirectDrawSurface2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE2, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE2, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE2, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE2 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE2,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE2) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface2_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface2_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface2_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface2_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface2_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface2_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface2_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface2_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface2_GetDDInterface(p,a)		 (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface2_PageLock(p,a)		 (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface2_PageUnlock(p,a)		 (p)->lpVtbl->PageUnlock(p,a)
#else
#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface2_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface2_Release(p)                   (p)->Release()
#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface2_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface2_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface2_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface2_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface2_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface2_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface2_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface2_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface2_GetDDInterface(p,a)		 (p)->GetDDInterface(a)
#define IDirectDrawSurface2_PageLock(p,a)		 (p)->PageLock(a)
#define IDirectDrawSurface2_PageUnlock(p,a)		 (p)->PageUnlock(a)
#endif

/*
 * IDirectDrawSurface3 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface3
DECLARE_INTERFACE_( IDirectDrawSurface3, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE3, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE3, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE3, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE3 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE3,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE3) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the V3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface3_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface3_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface3_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface3_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface3_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface3_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface3_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface3_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface3_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface3_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface3_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface3_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface3_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface3_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface3_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface3_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface3_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface3_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface3_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface3_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface3_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface3_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface3_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface3_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface3_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface3_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface3_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface3_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface3_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface3_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface3_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface3_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface3_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface3_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface3_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface3_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface3_GetDDInterface(p,a)		 (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface3_PageLock(p,a)		 (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface3_PageUnlock(p,a)		 (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface3_SetSurfaceDesc(p,a,b)	 (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#else
#define IDirectDrawSurface3_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface3_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface3_Release(p)                   (p)->Release()
#define IDirectDrawSurface3_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface3_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface3_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface3_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface3_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface3_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface3_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface3_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface3_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface3_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface3_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface3_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface3_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface3_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface3_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface3_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface3_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface3_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface3_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface3_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface3_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface3_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface3_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface3_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface3_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface3_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface3_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface3_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface3_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface3_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface3_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface3_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface3_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface3_GetDDInterface(p,a)		 (p)->GetDDInterface(a)
#define IDirectDrawSurface3_PageLock(p,a)		 (p)->PageLock(a)
#define IDirectDrawSurface3_PageUnlock(p,a)		 (p)->PageUnlock(a)
#define IDirectDrawSurface3_SetSurfaceDesc(p,a,b)	 (p)->SetSurfaceDesc(a,b)
#endif

/*
 * IDirectDrawSurface4 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface4
DECLARE_INTERFACE_( IDirectDrawSurface4, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE4, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE4, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK2) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK2) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE4, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS2, LPDIRECTDRAWSURFACE4 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS2) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC2) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC2,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPRECT) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE4,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE4) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC2, DWORD) PURE;
    /*** Added in the v4 interface ***/
    STDMETHOD(SetPrivateData)(THIS_ REFGUID, LPVOID, DWORD, DWORD) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID, LPVOID, LPDWORD) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID) PURE;
    STDMETHOD(GetUniquenessValue)(THIS_ LPDWORD) PURE;
    STDMETHOD(ChangeUniquenessValue)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface4_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface4_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface4_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface4_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface4_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface4_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface4_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface4_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface4_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface4_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface4_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface4_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface4_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface4_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface4_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface4_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface4_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface4_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface4_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface4_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface4_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface4_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface4_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface4_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface4_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface4_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface4_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface4_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface4_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface4_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface4_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface4_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface4_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface4_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface4_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface4_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface4_GetDDInterface(p,a)		 (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface4_PageLock(p,a)		 (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface4_PageUnlock(p,a)		 (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface4_SetSurfaceDesc(p,a,b)	 (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#define IDirectDrawSurface4_SetPrivateData(p,a,b,c,d)	 (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirectDrawSurface4_GetPrivateData(p,a,b,c)	 (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirectDrawSurface4_FreePrivateData(p,a)	 (p)->lpVtbl->FreePrivateData(p,a)
#define IDirectDrawSurface4_GetUniquenessValue(p, a)     (p)->lpVtbl->GetUniquenessValue(p, a)
#define IDirectDrawSurface4_ChangeUniquenessValue(p)     (p)->lpVtbl->ChangeUniquenessValue(p)
#else
#define IDirectDrawSurface4_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface4_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface4_Release(p)                   (p)->Release()
#define IDirectDrawSurface4_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface4_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface4_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface4_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface4_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface4_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface4_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface4_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface4_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface4_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface4_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface4_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface4_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface4_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface4_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface4_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface4_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface4_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface4_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface4_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface4_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface4_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface4_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface4_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface4_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface4_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface4_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface4_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface4_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface4_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface4_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface4_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface4_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface4_GetDDInterface(p,a)		 (p)->GetDDInterface(a)
#define IDirectDrawSurface4_PageLock(p,a)		 (p)->PageLock(a)
#define IDirectDrawSurface4_PageUnlock(p,a)		 (p)->PageUnlock(a)
#define IDirectDrawSurface4_SetSurfaceDesc(p,a,b)	 (p)->SetSurfaceDesc(a,b)
#define IDirectDrawSurface4_SetPrivateData(p,a,b,c,d)	 (p)->SetPrivateData(a,b,c,d)
#define IDirectDrawSurface4_GetPrivateData(p,a,b,c)	 (p)->GetPrivateData(a,b,c)
#define IDirectDrawSurface4_FreePrivateData(p,a)	 (p)->FreePrivateData(a)
#define IDirectDrawSurface4_GetUniquenessValue(p, a)     (p)->GetUniquenessValue(a)
#define IDirectDrawSurface4_ChangeUniquenessValue(p)     (p)->ChangeUniquenessValue()
#endif



/*
 * IDirectDrawColorControl
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawColorControl
DECLARE_INTERFACE_( IDirectDrawColorControl, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawColorControl methods ***/
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawColorControl_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawColorControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawColorControl_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawColorControl_GetColorControls(p, a)   (p)->lpVtbl->GetColorControls(p, a)
#define IDirectDrawColorControl_SetColorControls(p, a)   (p)->lpVtbl->SetColorControls(p, a)
#else
#define IDirectDrawColorControl_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawColorControl_AddRef(p)                (p)->AddRef()
#define IDirectDrawColorControl_Release(p)               (p)->Release()
#define IDirectDrawColorControl_GetColorControls(p, a)   (p)->GetColorControls(a)
#define IDirectDrawColorControl_SetColorControls(p, a)   (p)->SetColorControls(a)
#endif

#endif


/*
 * IDirectDrawGammaControl
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawGammaControl
DECLARE_INTERFACE_( IDirectDrawGammaControl, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawColorControl methods ***/
    STDMETHOD(GetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
    STDMETHOD(SetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawGammaControl_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawGammaControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawGammaControl_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawGammaControl_GetGammaRamp(p, a, b)    (p)->lpVtbl->GetGammaRamp(p, a, b)
#define IDirectDrawGammaControl_SetGammaRamp(p, a, b)    (p)->lpVtbl->SetGammaRamp(p, a, b)
#else
#define IDirectDrawGammaControl_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawGammaControl_AddRef(p)                (p)->AddRef()
#define IDirectDrawGammaControl_Release(p)               (p)->Release()
#define IDirectDrawGammaControl_GetGammaRamp(p, a, b)    (p)->GetGammaRamp(a, b)
#define IDirectDrawGammaControl_SetGammaRamp(p, a, b)    (p)->SetGammaRamp(a, b)
#endif

#endif



#endif


/*
 * DDSURFACEDESC
 */
typedef struct _DDSURFACEDESC
{
    DWORD		dwSize;			// size of the DDSURFACEDESC structure
    DWORD		dwFlags;		// determines what fields are valid
    DWORD		dwHeight;		// height of surface to be created
    DWORD		dwWidth;		// width of input surface
    union
    {
        LONG		lPitch;			// distance to start of next line (return value only)
        DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    } DUMMYUNIONNAMEN(1);
    DWORD		dwBackBufferCount;	// number of back buffers requested
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requested
	DWORD		dwZBufferBitDepth;	// depth of Z buffer requested
	DWORD		dwRefreshRate;		// refresh rate (used when display mode is described)
    } DUMMYUNIONNAMEN(2);
    DWORD		dwAlphaBitDepth;	// depth of alpha buffer requested
    DWORD		dwReserved;		// reserved
    LPVOID		lpSurface;		// pointer to the associated surface memory
    DDCOLORKEY		ddckCKDestOverlay;	// color key for destination overlay use
    DDCOLORKEY		ddckCKDestBlt;		// color key for destination blt use
    DDCOLORKEY		ddckCKSrcOverlay;	// color key for source overlay use
    DDCOLORKEY		ddckCKSrcBlt;		// color key for source blt use
    DDPIXELFORMAT	ddpfPixelFormat;	// pixel format description of the surface
    DDSCAPS		ddsCaps;		// direct draw surface capabilities
} DDSURFACEDESC;

/*
 * DDSURFACEDESC2
 */
typedef struct _DDSURFACEDESC2
{
    DWORD		dwSize;			// size of the DDSURFACEDESC structure
    DWORD		dwFlags;		// determines what fields are valid
    DWORD		dwHeight;		// height of surface to be created
    DWORD		dwWidth;		// width of input surface
    union
    {
        LONG		lPitch;			// distance to start of next line (return value only)
        DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    } DUMMYUNIONNAMEN(1);
    DWORD		dwBackBufferCount;	// number of back buffers requested
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requestde
                                                // dwZBufferBitDepth removed, use ddpfPixelFormat one instead
	DWORD		dwRefreshRate;		// refresh rate (used when display mode is described)
    } DUMMYUNIONNAMEN(2);
    DWORD		dwAlphaBitDepth;	// depth of alpha buffer requested
    DWORD		dwReserved;		// reserved
    LPVOID		lpSurface;		// pointer to the associated surface memory
    DDCOLORKEY		ddckCKDestOverlay;	// color key for destination overlay use
    DDCOLORKEY		ddckCKDestBlt;		// color key for destination blt use
    DDCOLORKEY		ddckCKSrcOverlay;	// color key for source overlay use
    DDCOLORKEY		ddckCKSrcBlt;		// color key for source blt use
    DDPIXELFORMAT	ddpfPixelFormat;	// pixel format description of the surface
    DDSCAPS2		ddsCaps;		// direct draw surface capabilities
    DWORD               dwTextureStage;         // stage in multitexture cascade
} DDSURFACEDESC2;

/*
 * ddsCaps field is valid.
 */
#define DDSD_CAPS		0x00000001l	// default

/*
 * dwHeight field is valid.
 */
#define DDSD_HEIGHT		0x00000002l

/*
 * dwWidth field is valid.
 */
#define DDSD_WIDTH		0x00000004l

/*
 * lPitch is valid.
 */
#define DDSD_PITCH		0x00000008l

/*
 * dwBackBufferCount is valid.
 */
#define DDSD_BACKBUFFERCOUNT	0x00000020l

/*
 * dwZBufferBitDepth is valid.  (shouldnt be used in DDSURFACEDESC2)
 */
#define DDSD_ZBUFFERBITDEPTH	0x00000040l

/*
 * dwAlphaBitDepth is valid.
 */
#define DDSD_ALPHABITDEPTH	0x00000080l


/*
 * lpSurface is valid.
 */
#define DDSD_LPSURFACE		0x00000800l

/*
 * ddpfPixelFormat is valid.
 */
#define DDSD_PIXELFORMAT	0x00001000l

/*
 * ddckCKDestOverlay is valid.
 */
#define DDSD_CKDESTOVERLAY	0x00002000l

/*
 * ddckCKDestBlt is valid.
 */
#define DDSD_CKDESTBLT		0x00004000l

/*
 * ddckCKSrcOverlay is valid.
 */
#define DDSD_CKSRCOVERLAY	0x00008000l

/*
 * ddckCKSrcBlt is valid.
 */
#define DDSD_CKSRCBLT		0x00010000l

/*
 * dwMipMapCount is valid.
 */
#define DDSD_MIPMAPCOUNT        0x00020000l

 /*
  * dwRefreshRate is valid
  */
#define DDSD_REFRESHRATE	0x00040000l

/*
 * dwLinearSize is valid
 */
#define DDSD_LINEARSIZE		0x00080000l

/*
 * dwTextureStage is valid
 */
#define DDSD_TEXTURESTAGE       0x00100000l
/*
 * All input fields are valid.
 */
#define DDSD_ALL		0x001ff9eel


/*
 * DDOPTSURFACEDESC
 */
typedef struct _DDOPTSURFACEDESC
{
    DWORD       dwSize;             // size of the DDOPTSURFACEDESC structure
    DWORD       dwFlags;            // determines what fields are valid
    DDSCAPS2    ddSCaps;            // Common caps like: Memory type
    DDOSCAPS    ddOSCaps;           // Common caps like: Memory type
    GUID        guid;               // Compression technique GUID
    DWORD       dwCompressionRatio; // Compression ratio
} DDOPTSURFACEDESC;

/*
 * guid field is valid.
 */
#define DDOSD_GUID                  0x00000001l

/*
 * dwCompressionRatio field is valid.
 */
#define DDOSD_COMPRESSION_RATIO     0x00000002l

/*
 * ddSCaps field is valid.
 */
#define DDOSD_SCAPS                 0x00000004l

/*
 * ddOSCaps field is valid.
 */
#define DDOSD_OSCAPS                0x00000008l

/*
 * All input fields are valid.
 */
#define DDOSD_ALL                   0x0000000fl

/*
 * The surface's optimized pixelformat is compressed
 */
#define DDOSDCAPS_OPTCOMPRESSED			0x00000001l

/*
 * The surface's optimized pixelformat is reordered
 */
#define DDOSDCAPS_OPTREORDERED			0x00000002l

/*
 * The opt surface is a monolithic mipmap
 */
#define DDOSDCAPS_MONOLITHICMIPMAP		0x00000004l

/*
 * The valid Surf caps:
 * #define DDSCAPS_SYSTEMMEMORY			0x00000800l
 * #define DDSCAPS_VIDEOMEMORY	        0x00004000l
 * #define DDSCAPS_LOCALVIDMEM          0x10000000l
 * #define DDSCAPS_NONLOCALVIDMEM       0x20000000l
 */
#define DDOSDCAPS_VALIDSCAPS         	0x30004800l

/*
 * The valid OptSurf caps
 */
#define DDOSDCAPS_VALIDOSCAPS         	0x00000007l


/*
 * DDCOLORCONTROL
 */
typedef struct _DDCOLORCONTROL
{
    DWORD 		dwSize;
    DWORD		dwFlags;
    LONG		lBrightness;
    LONG		lContrast;
    LONG		lHue;
    LONG 		lSaturation;
    LONG		lSharpness;
    LONG		lGamma;
    LONG		lColorEnable;
    DWORD		dwReserved1;
} DDCOLORCONTROL;


/*
 * lBrightness field is valid.
 */
#define DDCOLOR_BRIGHTNESS		0x00000001l

/*
 * lContrast field is valid.
 */
#define DDCOLOR_CONTRAST		0x00000002l

/*
 * lHue field is valid.
 */
#define DDCOLOR_HUE			0x00000004l

/*
 * lSaturation field is valid.
 */
#define DDCOLOR_SATURATION		0x00000008l

/*
 * lSharpness field is valid.
 */
#define DDCOLOR_SHARPNESS		0x00000010l

/*
 * lGamma field is valid.
 */
#define DDCOLOR_GAMMA			0x00000020l

/*
 * lColorEnable field is valid.
 */
#define DDCOLOR_COLORENABLE		0x00000040l



/*============================================================================
 *
 * Direct Draw Capability Flags
 *
 * These flags are used to describe the capabilities of a given Surface.
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAWSURFACE CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * This bit is reserved. It should not be specified.
 */
#define DDSCAPS_RESERVED1			0x00000001l

/*
 * Indicates that this surface contains alpha-only information.
 * (To determine if a surface is RGBA/YUVA, the pixel format must be
 * interrogated.)
 */
#define DDSCAPS_ALPHA				0x00000002l

/*
 * Indicates that this surface is a backbuffer.	 It is generally
 * set by CreateSurface when the DDSCAPS_FLIP capability bit is set.
 * It indicates that this surface is THE back buffer of a surface
 * flipping structure.	DirectDraw supports N surfaces in a
 * surface flipping structure.	Only the surface that immediately
 * precedeces the DDSCAPS_FRONTBUFFER has this capability bit set.
 * The other surfaces are identified as back buffers by the presence
 * of the DDSCAPS_FLIP capability, their attachment order, and the
 * absence of the DDSCAPS_FRONTBUFFER and DDSCAPS_BACKBUFFER
 * capabilities.  The bit is sent to CreateSurface when a standalone
 * back buffer is being created.  This surface could be attached to
 * a front buffer and/or back buffers to form a flipping surface
 * structure after the CreateSurface call.  See AddAttachments for
 * a detailed description of the behaviors in this case.
 */
#define DDSCAPS_BACKBUFFER			0x00000004l

/*
 * Indicates a complex surface structure is being described.  A
 * complex surface structure results in the creation of more than
 * one surface.	 The additional surfaces are attached to the root
 * surface.  The complex structure can only be destroyed by
 * destroying the root.
 */
#define DDSCAPS_COMPLEX				0x00000008l

/*
 * Indicates that this surface is a part of a surface flipping structure.
 * When it is passed to CreateSurface the DDSCAPS_FRONTBUFFER and
 * DDSCAP_BACKBUFFER bits are not set.	They are set by CreateSurface
 * on the resulting creations.	The dwBackBufferCount field in the
 * DDSURFACEDESC structure must be set to at least 1 in order for
 * the CreateSurface call to succeed.  The DDSCAPS_COMPLEX capability
 * must always be set with creating multiple surfaces through CreateSurface.
 */
#define DDSCAPS_FLIP				0x00000010l

/*
 * Indicates that this surface is THE front buffer of a surface flipping
 * structure.  It is generally set by CreateSurface when the DDSCAPS_FLIP
 * capability bit is set.
 * If this capability is sent to CreateSurface then a standalonw front buffer
 * is created.	This surface will not have the DDSCAPS_FLIP capability.
 * It can be attached to other back buffers to form a flipping structure.
 * See AddAttachments for a detailed description of the behaviors in this
 * case.
 */
#define DDSCAPS_FRONTBUFFER			0x00000020l

/*
 * Indicates that this surface is any offscreen surface that is not an overlay,
 * texture, zbuffer, front buffer, back buffer, or alpha surface.  It is used
 * to identify plain vanilla surfaces.
 */
#define DDSCAPS_OFFSCREENPLAIN			0x00000040l

/*
 * Indicates that this surface is an overlay.  It may or may not be directly visible
 * depending on whether or not it is currently being overlayed onto the primary
 * surface.  DDSCAPS_VISIBLE can be used to determine whether or not it is being
 * overlayed at the moment.
 */
#define DDSCAPS_OVERLAY				0x00000080l

/*
 * Indicates that unique DirectDrawPalette objects can be created and
 * attached to this surface.
 */
#define DDSCAPS_PALETTE				0x00000100l

/*
 * Indicates that this surface is the primary surface.	The primary
 * surface represents what the user is seeing at the moment.
 */
#define DDSCAPS_PRIMARYSURFACE			0x00000200l

/*
 * Indicates that this surface is the primary surface for the left eye.
 * The primary surface for the left eye represents what the user is seeing
 * at the moment with the users left eye.  When this surface is created the
 * DDSCAPS_PRIMARYSURFACE represents what the user is seeing with the users
 * right eye.
 */
#define DDSCAPS_PRIMARYSURFACELEFT		0x00000400l

/*
 * Indicates that this surface memory was allocated in system memory
 */
#define DDSCAPS_SYSTEMMEMORY			0x00000800l

/*
 * Indicates that this surface can be used as a 3D texture.  It does not
 * indicate whether or not the surface is being used for that purpose.
 */
#define DDSCAPS_TEXTURE			        0x00001000l

/*
 * Indicates that a surface may be a destination for 3D rendering.  This
 * bit must be set in order to query for a Direct3D Device Interface
 * from this surface.
 */
#define DDSCAPS_3DDEVICE                        0x00002000l

/*
 * Indicates that this surface exists in video memory.
 */
#define DDSCAPS_VIDEOMEMORY			0x00004000l

/*
 * Indicates that changes made to this surface are immediately visible.
 * It is always set for the primary surface and is set for overlays while
 * they are being overlayed and texture maps while they are being textured.
 */
#define DDSCAPS_VISIBLE				0x00008000l

/*
 * Indicates that only writes are permitted to the surface.  Read accesses
 * from the surface may or may not generate a protection fault, but the
 * results of a read from this surface will not be meaningful.	READ ONLY.
 */
#define DDSCAPS_WRITEONLY			0x00010000l

/*
 * Indicates that this surface is a z buffer. A z buffer does not contain
 * displayable information.  Instead it contains bit depth information that is
 * used to determine which pixels are visible and which are obscured.
 */
#define DDSCAPS_ZBUFFER				0x00020000l

/*
 * Indicates surface will have a DC associated long term
 */
#define DDSCAPS_OWNDC				0x00040000l

/*
 * Indicates surface should be able to receive live video
 */
#define DDSCAPS_LIVEVIDEO			0x00080000l

/*
 * Indicates surface should be able to have a stream decompressed
 * to it by the hardware.
 */
#define DDSCAPS_HWCODEC				0x00100000l

/*
 * Surface is a ModeX surface.
 *
 */
#define DDSCAPS_MODEX				0x00200000l

/*
 * Indicates surface is one level of a mip-map. This surface will
 * be attached to other DDSCAPS_MIPMAP surfaces to form the mip-map.
 * This can be done explicitly, by creating a number of surfaces and
 * attaching them with AddAttachedSurface or by implicitly by CreateSurface.
 * If this bit is set then DDSCAPS_TEXTURE must also be set.
 */
#define DDSCAPS_MIPMAP                          0x00400000l

/*
 * This bit is reserved. It should not be specified.
 */
#define DDSCAPS_RESERVED2                       0x00800000l


/*
 * Indicates that memory for the surface is not allocated until the surface
 * is loaded (via the Direct3D texture Load() function).
 */
#define DDSCAPS_ALLOCONLOAD                     0x04000000l

/*
 * Indicates that the surface will recieve data from a video port.
 */
#define DDSCAPS_VIDEOPORT			0x08000000l

/*
 * Indicates that a video memory surface is resident in true, local video
 * memory rather than non-local video memory. If this flag is specified then
 * so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
 * DDSCAPS_NONLOCALVIDMEM.
 */
#define DDSCAPS_LOCALVIDMEM                     0x10000000l

/*
 * Indicates that a video memory surface is resident in non-local video
 * memory rather than true, local video memory. If this flag is specified
 * then so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
 * DDSCAPS_LOCALVIDMEM.
 */
#define DDSCAPS_NONLOCALVIDMEM                  0x20000000l

/*
 * Indicates that this surface is a standard VGA mode surface, and not a
 * ModeX surface. (This flag will never be set in combination with the
 * DDSCAPS_MODEX flag).
 */
#define DDSCAPS_STANDARDVGAMODE                 0x40000000l

/*
 * Indicates that this surface will be an optimized surface. This flag is
 * currently only valid in conjunction with the DDSCAPS_TEXTURE flag. The surface
 * will be created without any underlying video memory until loaded.
 */
#define DDSCAPS_OPTIMIZED                       0x80000000l




/*
 * Indicates that this surface will receive data from a video port using
 * the de-interlacing hardware.  This allows the driver to allocate memory
 * for any extra buffers that may be required.  The DDSCAPS_VIDEOPORT and
 * DDSCAPS_OVERLAY flags must also be set.
 */
#define DDSCAPS2_HARDWAREDEINTERLACE            0x00000002L

/*
 * Indicates to the driver that this surface will be locked very frequently
 * (for procedural textures, dynamic lightmaps, etc). Surfaces with this cap
 * set must also have DDSCAPS_TEXTURE. This cap cannot be used with
 * DDSCAPS2_HINTSTATIC and DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_HINTDYNAMIC 			0x00000004L

/*
 * Indicates to the driver that this surface can be re-ordered/retiled on
 * load. This operation will not change the size of the texture. It is
 * relatively fast and symmetrical, since the application may lock these
 * bits (although it will take a performance hit when doing so). Surfaces
 * with this cap set must also have DDSCAPS_TEXTURE. This cap cannot be
 * used with DDSCAPS2_HINTDYNAMIC and DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_HINTSTATIC 			0x00000008L

/*
 * Indicates that the client would like this texture surface to be managed by the
 * DirectDraw/Direct3D runtime. Surfaces with this cap set must also have
 * DDSCAPS_TEXTURE and DDSCAPS_SYSTEMMEMORY.
 */
#define DDSCAPS2_TEXTUREMANAGE                  0x00000010L

/*
 * These bits are reserved for internal use */
#define DDSCAPS2_RESERVED1                      0x00000020L
#define DDSCAPS2_RESERVED2                      0x00000040L

/*
 * Indicates to the driver that this surface will never be locked again.
 * The driver is free to optimize this surface via retiling and actual compression.
 * All calls to Lock() or Blts from this surface will fail. Surfaces with this
 * cap set must also have DDSCAPS_TEXTURE. This cap cannot be used with
 * DDSCAPS2_HINTDYNAMIC and DDSCAPS2_HINTSTATIC.
 */
#define DDSCAPS2_OPAQUE                         0x00000080L

/*
 * Applications should set this bit at CreateSurface time to indicate that they
 * intend to use antialiasing. Only valid if DDSCAPS_3DDEVICE is also set.
 */
#define DDSCAPS2_HINTANTIALIASING               0x00000100L




 /****************************************************************************
 *
 * DIRECTDRAW DRIVER CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Display hardware has 3D acceleration.
 */
#define DDCAPS_3D			0x00000001l

/*
 * Indicates that DirectDraw will support only dest rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundaryDest boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYDEST	0x00000002l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeDest multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZEDEST		0x00000004l
/*
 * Indicates that DirectDraw will support only source rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundarySrc boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYSRC		0x00000008l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeSrc multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZESRC		0x00000010l

/*
 * Indicates that DirectDraw will create video memory surfaces that have a stride
 * alignment equal to DIRECTDRAWCAPS.dwAlignStride.  READ ONLY.
 */
#define DDCAPS_ALIGNSTRIDE		0x00000020l

/*
 * Display hardware is capable of blt operations.
 */
#define DDCAPS_BLT			0x00000040l

/*
 * Display hardware is capable of asynchronous blt operations.
 */
#define DDCAPS_BLTQUEUE			0x00000080l

/*
 * Display hardware is capable of color space conversions during the blt operation.
 */
#define DDCAPS_BLTFOURCC		0x00000100l

/*
 * Display hardware is capable of stretching during blt operations.
 */
#define DDCAPS_BLTSTRETCH		0x00000200l

/*
 * Display hardware is shared with GDI.
 */
#define DDCAPS_GDI			0x00000400l

/*
 * Display hardware can overlay.
 */
#define DDCAPS_OVERLAY			0x00000800l

/*
 * Set if display hardware supports overlays but can not clip them.
 */
#define DDCAPS_OVERLAYCANTCLIP		0x00001000l

/*
 * Indicates that overlay hardware is capable of color space conversions during
 * the overlay operation.
 */
#define DDCAPS_OVERLAYFOURCC		0x00002000l

/*
 * Indicates that stretching can be done by the overlay hardware.
 */
#define DDCAPS_OVERLAYSTRETCH		0x00004000l

/*
 * Indicates that unique DirectDrawPalettes can be created for DirectDrawSurfaces
 * other than the primary surface.
 */
#define DDCAPS_PALETTE			0x00008000l

/*
 * Indicates that palette changes can be syncd with the veritcal refresh.
 */
#define DDCAPS_PALETTEVSYNC		0x00010000l

/*
 * Display hardware can return the current scan line.
 */
#define DDCAPS_READSCANLINE		0x00020000l

/*
 * Display hardware has stereo vision capabilities.  DDSCAPS_PRIMARYSURFACELEFT
 * can be created.
 */
#define DDCAPS_STEREOVIEW		0x00040000l

/*
 * Display hardware is capable of generating a vertical blank interrupt.
 */
#define DDCAPS_VBI			0x00080000l

/*
 * Supports the use of z buffers with blt operations.
 */
#define DDCAPS_ZBLTS			0x00100000l

/*
 * Supports Z Ordering of overlays.
 */
#define DDCAPS_ZOVERLAYS		0x00200000l

/*
 * Supports color key
 */
#define DDCAPS_COLORKEY			0x00400000l

/*
 * Supports alpha surfaces
 */
#define DDCAPS_ALPHA			0x00800000l

/*
 * colorkey is hardware assisted(DDCAPS_COLORKEY will also be set)
 */
#define DDCAPS_COLORKEYHWASSIST		0x01000000l

/*
 * no hardware support at all
 */
#define DDCAPS_NOHARDWARE		0x02000000l

/*
 * Display hardware is capable of color fill with bltter
 */
#define DDCAPS_BLTCOLORFILL		0x04000000l

/*
 * Display hardware is bank switched, and potentially very slow at
 * random access to VRAM.
 */
#define DDCAPS_BANKSWITCHED		0x08000000l

/*
 * Display hardware is capable of depth filling Z-buffers with bltter
 */
#define DDCAPS_BLTDEPTHFILL		0x10000000l

/*
 * Display hardware is capable of clipping while bltting.
 */
#define DDCAPS_CANCLIP			0x20000000l

/*
 * Display hardware is capable of clipping while stretch bltting.
 */
#define DDCAPS_CANCLIPSTRETCHED		0x40000000l

/*
 * Display hardware is capable of bltting to or from system memory
 */
#define DDCAPS_CANBLTSYSMEM		0x80000000l


 /****************************************************************************
 *
 * MORE DIRECTDRAW DRIVER CAPABILITY FLAGS (dwCaps2)
 *
 ****************************************************************************/

/*
 * Display hardware is certified
 */
#define DDCAPS2_CERTIFIED              0x00000001l

/*
 * Driver cannot interleave 2D operations (lock and blt) to surfaces with
 * Direct3D rendering operations between calls to BeginScene() and EndScene()
 */
#define DDCAPS2_NO2DDURING3DSCENE       0x00000002l

/*
 * Display hardware contains a video port
 */
#define DDCAPS2_VIDEOPORT               0x00000004l

/*
 * The overlay can be automatically flipped according to the video port
 * VSYNCs, providing automatic doubled buffered display of video port
 * data using an overlay
 */
#define DDCAPS2_AUTOFLIPOVERLAY         0x00000008l

/*
 * Overlay can display each field of interlaced data individually while
 * it is interleaved in memory without causing jittery artifacts.
 */
#define DDCAPS2_CANBOBINTERLEAVED       0x00000010l

/*
 * Overlay can display each field of interlaced data individually while
 * it is not interleaved in memory without causing jittery artifacts.
 */
#define DDCAPS2_CANBOBNONINTERLEAVED    0x00000020l

/*
 * The overlay surface contains color controls (brightness, sharpness, etc.)
 */
#define DDCAPS2_COLORCONTROLOVERLAY     0x00000040l

/*
 * The primary surface contains color controls (gamma, etc.)
 */
#define DDCAPS2_COLORCONTROLPRIMARY     0x00000080l

/*
 * RGBZ -> RGB supported for 16:16 RGB:Z
 */
#define DDCAPS2_CANDROPZ16BIT           0x00000100l

/*
 * Driver supports non-local video memory.
 */
#define DDCAPS2_NONLOCALVIDMEM          0x00000200l

/*
 * Dirver supports non-local video memory but has different capabilities for
 * non-local video memory surfaces. If this bit is set then so must
 * DDCAPS2_NONLOCALVIDMEM.
 */
#define DDCAPS2_NONLOCALVIDMEMCAPS      0x00000400l

/*
 * Driver neither requires nor prefers surfaces to be pagelocked when performing
 * blts involving system memory surfaces
 */
#define DDCAPS2_NOPAGELOCKREQUIRED      0x00000800l

/*
 * Driver can create surfaces which are wider than the primary surface
 */
#define DDCAPS2_WIDESURFACES            0x00001000l

/*
 * Driver supports bob without using a video port by handling the
 * DDFLIP_ODD and DDFLIP_EVEN flags specified in Flip.
 */
#define DDCAPS2_CANFLIPODDEVEN          0x00002000l

/*
 * Driver supports bob using hardware
 */
#define DDCAPS2_CANBOBHARDWARE          0x00004000l

/*
 * Driver supports bltting any FOURCC surface to another surface of the same FOURCC
 */
#define DDCAPS2_COPYFOURCC              0x00008000l


/*
 * Driver supports loadable gamma ramps for the primary surface
 */
#define DDCAPS2_PRIMARYGAMMA            0x00020000l

/*
 * Driver can render in windowed mode.
 */
#define DDCAPS2_CANRENDERWINDOWED       0x00080000l

/*
 * A calibrator is available to adjust the gamma ramp according to the
 * physical display properties so that the result will be identical on
 * all calibrated systems.
 */
#define DDCAPS2_CANCALIBRATEGAMMA       0x00100000l


/****************************************************************************
 *
 * DIRECTDRAW FX ALPHA CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAEDGEBLEND		0x00000001l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.	The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELS		0x00000002l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.	The alpha value
 * becomes more transparent as the alpha value increases.  (0 is opaque.)
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELSNEG		0x00000004l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.	 The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACES		0x00000008l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)	 This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACESNEG	0x00000010l

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND	0x00000020l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.	The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELS	0x00000040l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.	The alpha value
 * becomes more transparent as the alpha value increases.  (0 is opaque.)
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG	0x00000080l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.	 The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACES	0x00000100l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)	 This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACESNEG	0x00000200l

#if DIRECTDRAW_VERSION < 0x0600
#endif  //DIRECTDRAW_VERSION




/****************************************************************************
 *
 * DIRECTDRAW FX CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Uses arithmetic operations to stretch and shrink surfaces during blt
 * rather than pixel doubling techniques.  Along the Y axis.
 */
#define DDFXCAPS_BLTARITHSTRETCHY	0x00000020l

/*
 * Uses arithmetic operations to stretch during blt
 * rather than pixel doubling techniques.  Along the Y axis. Only
 * works for x1, x2, etc.
 */
#define DDFXCAPS_BLTARITHSTRETCHYN	0x00000010l

/*
 * Supports mirroring left to right in blt.
 */
#define DDFXCAPS_BLTMIRRORLEFTRIGHT	0x00000040l

/*
 * Supports mirroring top to bottom in blt.
 */
#define DDFXCAPS_BLTMIRRORUPDOWN	0x00000080l

/*
 * Supports arbitrary rotation for blts.
 */
#define DDFXCAPS_BLTROTATION		0x00000100l

/*
 * Supports 90 degree rotations for blts.
 */
#define DDFXCAPS_BLTROTATION90		0x00000200l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKX		0x00000400l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKXN		0x00000800l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKY		0x00001000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKYN		0x00002000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHX		0x00004000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHXN		0x00008000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHY		0x00010000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHYN		0x00020000l

/*
 * Uses arithmetic operations to stretch and shrink surfaces during
 * overlay rather than pixel doubling techniques.  Along the Y axis
 * for overlays.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHY	0x00040000l

/*
 * Uses arithmetic operations to stretch surfaces during
 * overlay rather than pixel doubling techniques.  Along the Y axis
 * for overlays. Only works for x1, x2, etc.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHYN	0x00000008l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKX		0x00080000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKXN	0x00100000l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKY		0x00200000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKYN	0x00400000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHX	0x00800000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHXN	0x01000000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHY	0x02000000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHYN	0x04000000l

/*
 * DirectDraw supports mirroring of overlays across the vertical axis
 */
#define DDFXCAPS_OVERLAYMIRRORLEFTRIGHT	0x08000000l

/*
 * DirectDraw supports mirroring of overlays across the horizontal axis
 */
#define DDFXCAPS_OVERLAYMIRRORUPDOWN	0x10000000l

/*
 * Driver can do alpha blending for blits.
 */
#define DDFXCAPS_BLTALPHA 		0x00000001l

/*
 * Driver can do geometric transformations (or warps) for blits.
 */
#define DDFXCAPS_BLTTRANSFORM		0x00000002l

/*
 * Driver can do surface-reconstruction filtering for warped blits.
 */
#define DDFXCAPS_BLTFILTER 		DDFXCAPS_BLTARITHSTRETCHY

/*
 * Driver can do alpha blending for overlays.
 */
#define DDFXCAPS_OVERLAYALPHA 		0x00000004l

/*
 * Driver can do geometric transformations (or warps) for overlays.
 */
#define DDFXCAPS_OVERLAYTRANSFORM 	0x20000000l

/*
 * Driver can do surface-reconstruction filtering for warped overlays.
 */
#define DDFXCAPS_OVERLAYFILTER 		DDFXCAPS_OVERLAYARITHSTRETCHY


/****************************************************************************
 *
 * DIRECTDRAW STEREO VIEW CAPABILITIES
 *
 ****************************************************************************/

/*
 * The stereo view is accomplished via enigma encoding.
 */
#define DDSVCAPS_ENIGMA			0x00000001l

/*
 * The stereo view is accomplished via high frequency flickering.
 */
#define DDSVCAPS_FLICKER		0x00000002l

/*
 * The stereo view is accomplished via red and blue filters applied
 * to the left and right eyes.	All images must adapt their colorspaces
 * for this process.
 */
#define DDSVCAPS_REDBLUE		0x00000004l

/*
 * The stereo view is accomplished with split screen technology.
 */
#define DDSVCAPS_SPLIT			0x00000008l

/****************************************************************************
 *
 * DIRECTDRAWPALETTE CAPABILITIES
 *
 ****************************************************************************/

/*
 * Index is 4 bits.  There are sixteen color entries in the palette table.
 */
#define DDPCAPS_4BIT			0x00000001l

/*
 * Index is onto a 8 bit color index.  This field is only valid with the
 * DDPCAPS_1BIT, DDPCAPS_2BIT or DDPCAPS_4BIT capability and the target
 * surface is in 8bpp. Each color entry is one byte long and is an index
 * into destination surface's 8bpp palette.
 */
#define DDPCAPS_8BITENTRIES		0x00000002l

/*
 * Index is 8 bits.  There are 256 color entries in the palette table.
 */
#define DDPCAPS_8BIT			0x00000004l

/*
 * Indicates that this DIRECTDRAWPALETTE should use the palette color array
 * passed into the lpDDColorArray parameter to initialize the DIRECTDRAWPALETTE
 * object.
 */
#define DDPCAPS_INITIALIZE		0x00000008l

/*
 * This palette is the one attached to the primary surface.  Changing this
 * table has immediate effect on the display unless DDPSETPAL_VSYNC is specified
 * and supported.
 */
#define DDPCAPS_PRIMARYSURFACE		0x00000010l

/*
 * This palette is the one attached to the primary surface left.  Changing
 * this table has immediate effect on the display for the left eye unless
 * DDPSETPAL_VSYNC is specified and supported.
 */
#define DDPCAPS_PRIMARYSURFACELEFT	0x00000020l

/*
 * This palette can have all 256 entries defined
 */
#define DDPCAPS_ALLOW256		0x00000040l

/*
 * This palette can have modifications to it synced with the monitors
 * refresh rate.
 */
#define DDPCAPS_VSYNC			0x00000080l

/*
 * Index is 1 bit.  There are two color entries in the palette table.
 */
#define DDPCAPS_1BIT			0x00000100l

/*
 * Index is 2 bit.  There are four color entries in the palette table.
 */
#define DDPCAPS_2BIT			0x00000200l

/*
 * The peFlags member of PALETTEENTRY denotes an 8 bit alpha value
 */
#define DDPCAPS_ALPHA			0x00000400l


/****************************************************************************
 *
 * DIRECTDRAWPALETTE SETENTRY CONSTANTS
 *
 ****************************************************************************/


/****************************************************************************
 *
 * DIRECTDRAWPALETTE GETENTRY CONSTANTS
 *
 ****************************************************************************/

/* 0 is the only legal value */

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPRIVATEDATA CONSTANTS
 *
 ****************************************************************************/

/*
 * The passed pointer is an IUnknown ptr. The cbData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). DirectDraw will call AddRef through this
 * pointer and Release when the private data is destroyed. This includes when
 * the surface or palette is destroyed before such priovate data is destroyed.
 */
#define DDSPD_IUNKNOWNPOINTER           0x00000001L

/*
 * Private data is only valid for the current state of the object,
 * as determined by the uniqueness value.
 */
#define DDSPD_VOLATILE                  0x00000002L


/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPALETTE CONSTANTS
 *
 ****************************************************************************/


/****************************************************************************
 *
 * DIRECTDRAW BITDEPTH CONSTANTS
 *
 * NOTE:  These are only used to indicate supported bit depths.   These
 * are flags only, they are not to be used as an actual bit depth.   The
 * absolute numbers 1, 2, 4, 8, 16, 24 and 32 are used to indicate actual
 * bit depths in a surface or for changing the display mode.
 *
 ****************************************************************************/

/*
 * 1 bit per pixel.
 */
#define DDBD_1			0x00004000l

/*
 * 2 bits per pixel.
 */
#define DDBD_2			0x00002000l

/*
 * 4 bits per pixel.
 */
#define DDBD_4			0x00001000l

/*
 * 8 bits per pixel.
 */
#define DDBD_8			0x00000800l

/*
 * 16 bits per pixel.
 */
#define DDBD_16			0x00000400l

/*
 * 24 bits per pixel.
 */
#define DDBD_24			0X00000200l

/*
 * 32 bits per pixel.
 */
#define DDBD_32			0x00000100l

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SET/GET COLOR KEY FLAGS
 *
 ****************************************************************************/

/*
 * Set if the structure contains a color space.	 Not set if the structure
 * contains a single color key.
 */
#define DDCKEY_COLORSPACE	0x00000001l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for blt operations.
 */
#define DDCKEY_DESTBLT		0x00000002l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for overlay operations.
 */
#define DDCKEY_DESTOVERLAY	0x00000004l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for blt operations.
 */
#define DDCKEY_SRCBLT		0x00000008l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for overlay operations.
 */
#define DDCKEY_SRCOVERLAY	0x00000010l


/****************************************************************************
 *
 * DIRECTDRAW COLOR KEY CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports transparent blting using a color key to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLT			0x00000001l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACE		0x00000002l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACEYUV		0x00000004l

/*
 * Supports transparent blting using a color key to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTYUV			0x00000008l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the surface
 * being overlayed for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAY			0x00000010l

/*
 * Supports a color space as the color key for the destination for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACE		0x00000020l

/*
 * Supports a color space as the color key for the destination for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV	0x00000040l

/*
 * Supports only one active destination color key value for visible overlay
 * surfaces.
 */
#define DDCKEYCAPS_DESTOVERLAYONEACTIVE		0x00000080l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the
 * surface being overlayed for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYYUV		0x00000100l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLT			0x00000200l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACE		0x00000400l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACEYUV		0x00000800l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTYUV			0x00001000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAY			0x00002000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACE		0x00004000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV	0x00008000l

/*
 * Supports only one active source color key value for visible
 * overlay surfaces.
 */
#define DDCKEYCAPS_SRCOVERLAYONEACTIVE		0x00010000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYYUV		0x00020000l

/*
 * there are no bandwidth trade-offs for using colorkey with an overlay
 */
#define DDCKEYCAPS_NOCOSTOVERLAY		0x00040000l


/****************************************************************************
 *
 * DIRECTDRAW PIXELFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * The surface has alpha channel information in the pixel format.
 */
#define DDPF_ALPHAPIXELS			0x00000001l

/*
 * The pixel format contains alpha only information
 */
#define DDPF_ALPHA				0x00000002l

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC				0x00000004l

/*
 * The surface is 4-bit color indexed.
 */
#define DDPF_PALETTEINDEXED4			0x00000008l

/*
 * The surface is indexed into a palette which stores indices
 * into the destination surface's 8-bit palette.
 */
#define DDPF_PALETTEINDEXEDTO8			0x00000010l

/*
 * The surface is 8-bit color indexed.
 */
#define DDPF_PALETTEINDEXED8			0x00000020l

/*
 * The RGB data in the pixel format structure is valid.
 */
#define DDPF_RGB				0x00000040l

/*
 * The surface will accept pixel data in the format specified
 * and compress it during the write.
 */
#define DDPF_COMPRESSED				0x00000080l

/*
 * The surface will accept RGB data and translate it during
 * the write to YUV data.  The format of the data to be written
 * will be contained in the pixel format structure.  The DDPF_RGB
 * flag will be set.
 */
#define DDPF_RGBTOYUV				0x00000100l

/*
 * pixel format is YUV - YUV data in pixel format struct is valid
 */
#define DDPF_YUV				0x00000200l

/*
 * pixel format is a z buffer only surface
 */
#define DDPF_ZBUFFER				0x00000400l

/*
 * The surface is 1-bit color indexed.
 */
#define DDPF_PALETTEINDEXED1			0x00000800l

/*
 * The surface is 2-bit color indexed.
 */
#define DDPF_PALETTEINDEXED2			0x00001000l

/*
 * The surface contains Z information in the pixels
 */
#define DDPF_ZPIXELS				0x00002000l

/*
 * The surface contains stencil information along with Z
 */
#define DDPF_STENCILBUFFER			0x00004000l

/*
 * Premultiplied alpha format -- the color components have been
 * premultiplied by the alpha component.
 */
#define DDPF_ALPHAPREMULT 			0x00008000l


/*
 * Luminance data in the pixel format is valid.
 * Use this flag for luminance-only or luminance+alpha surfaces,
 * the bit depth is then ddpf.dwLuminanceBitCount.
 */
#define DDPF_LUMINANCE                          0x00020000l

/*
 * Luminance data in the pixel format is valid.
 * Use this flag when hanging luminance off bumpmap surfaces,
 * the bit mask for the luminance portion of the pixel is then
 * ddpf.dwBumpLuminanceBitMask
 */
#define DDPF_BUMPLUMINANCE                      0x00040000l

/*
 * Bump map dUdV data in the pixel format is valid.
 */
#define DDPF_BUMPDUDV                           0x00080000l

/*===========================================================================
 *
 *
 * DIRECTDRAW CALLBACK FLAGS
 *
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAW ENUMSURFACES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate all of the surfaces that meet the search criterion.
 */
#define DDENUMSURFACES_ALL			0x00000001l

/*
 * A search hit is a surface that matches the surface description.
 */
#define DDENUMSURFACES_MATCH			0x00000002l

/*
 * A search hit is a surface that does not match the surface description.
 */
#define DDENUMSURFACES_NOMATCH			0x00000004l

/*
 * Enumerate the first surface that can be created which meets the search criterion.
 */
#define DDENUMSURFACES_CANBECREATED		0x00000008l

/*
 * Enumerate the surfaces that already exist that meet the search criterion.
 */
#define DDENUMSURFACES_DOESEXIST		0x00000010l


/****************************************************************************
 *
 * DIRECTDRAW SETDISPLAYMODE FLAGS
 *
 ****************************************************************************/

/*
 * The desired mode is a standard VGA mode
 */
#define DDSDM_STANDARDVGAMODE                   0x00000001l



/****************************************************************************
 *
 * DIRECTDRAW ENUMDISPLAYMODES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate Modes with different refresh rates.  EnumDisplayModes guarantees
 * that a particular mode will be enumerated only once.  This flag specifies whether
 * the refresh rate is taken into account when determining if a mode is unique.
 */
#define DDEDM_REFRESHRATES			0x00000001l

/*
 * Enumerate VGA modes. Specify this flag if you wish to enumerate supported VGA
 * modes such as mode 0x13 in addition to the usual ModeX modes (which are always
 * enumerated if the application has previously called SetCooperativeLevel with the
 * DDSCL_ALLOWMODEX flag set).
 */
#define DDEDM_STANDARDVGAMODES                  0x00000002L


/****************************************************************************
 *
 * DIRECTDRAW SETCOOPERATIVELEVEL FLAGS
 *
 ****************************************************************************/

/*
 * Exclusive mode owner will be responsible for the entire primary surface.
 * GDI can be ignored. used with DD
 */
#define DDSCL_FULLSCREEN			0x00000001l

/*
 * allow CTRL_ALT_DEL to work while in fullscreen exclusive mode
 */
#define DDSCL_ALLOWREBOOT			0x00000002l

/*
 * prevents DDRAW from modifying the application window.
 * prevents DDRAW from minimize/restore the application window on activation.
 */
#define DDSCL_NOWINDOWCHANGES			0x00000004l

/*
 * app wants to work as a regular Windows application
 */
#define DDSCL_NORMAL				0x00000008l

/*
 * app wants exclusive access
 */
#define DDSCL_EXCLUSIVE                         0x00000010l


/*
 * app can deal with non-windows display modes
 */
#define DDSCL_ALLOWMODEX                        0x00000040l

/*
 * this window will receive the focus messages
 */
#define DDSCL_SETFOCUSWINDOW                    0x00000080l

/*
 * this window is associated with the DDRAW object and will
 * cover the screen in fullscreen mode
 */
#define DDSCL_SETDEVICEWINDOW                   0x00000100l

/*
 * app wants DDRAW to create a window to be associated with the
 * DDRAW object
 */
#define DDSCL_CREATEDEVICEWINDOW                0x00000200l

/*
 * App explicitly asks DDRAW/D3D to be multithread safe. This makes D3D
 * take the global crtisec more frequently.
 */
#define DDSCL_MULTITHREADED                     0x00000400l

/*
 * App hints that it would like to keep the FPU set up for optimal Direct3D
 * performance (single precision and exceptions disabled) so Direct3D
 * does not need to explicitly set the FPU each time
 */
#define DDSCL_FPUSETUP                          0x00000800l


/****************************************************************************
 *
 * DIRECTDRAW BLT FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHADEST				0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDBLTFX structure as the alpha channel
 * for the destination surface for this blt.
 */
#define DDBLT_ALPHADESTCONSTOVERRIDE		0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHADESTNEG			0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDBLTFX structure as the alpha
 * channel for the destination for this blt.
 */
#define DDBLT_ALPHADESTSURFACEOVERRIDE		0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDBLTFX structure as the alpha channel
 * for the edges of the image that border the color key colors.
 */
#define DDBLT_ALPHAEDGEBLEND			0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHASRC				0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCCONSTOVERRIDE		0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHASRCNEG			0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCSURFACEOVERRIDE		0x00000100l

/*
 * Do this blt asynchronously through the FIFO in the order received.  If
 * there is no room in the hardware FIFO fail the call.
 */
#define DDBLT_ASYNC				0x00000200l

/*
 * Uses the dwFillColor field in the DDBLTFX structure as the RGB color
 * to fill the destination rectangle on the destination surface with.
 */
#define DDBLT_COLORFILL				0x00000400l

/*
 * Uses the dwDDFX field in the DDBLTFX structure to specify the effects
 * to use for the blt.
 */
#define DDBLT_DDFX				0x00000800l

/*
 * Uses the dwDDROPS field in the DDBLTFX structure to specify the ROPS
 * that are not part of the Win32 API.
 */
#define DDBLT_DDROPS				0x00001000l

/*
 * Use the color key associated with the destination surface.
 */
#define DDBLT_KEYDEST				0x00002000l

/*
 * Use the dckDestColorkey field in the DDBLTFX structure as the color key
 * for the destination surface.
 */
#define DDBLT_KEYDESTOVERRIDE			0x00004000l

/*
 * Use the color key associated with the source surface.
 */
#define DDBLT_KEYSRC				0x00008000l

/*
 * Use the dckSrcColorkey field in the DDBLTFX structure as the color key
 * for the source surface.
 */
#define DDBLT_KEYSRCOVERRIDE			0x00010000l

/*
 * Use the dwROP field in the DDBLTFX structure for the raster operation
 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
 */
#define DDBLT_ROP				0x00020000l

/*
 * Use the dwRotationAngle field in the DDBLTFX structure as the angle
 * (specified in 1/100th of a degree) to rotate the surface.
 */
#define DDBLT_ROTATIONANGLE			0x00040000l

/*
 * Z-buffered blt using the z-buffers attached to the source and destination
 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
 * z-buffer opcode.
 */
#define DDBLT_ZBUFFER				0x00080000l

/*
 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the destination.
 */
#define DDBLT_ZBUFFERDESTCONSTOVERRIDE		0x00100000l

/*
 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the destination.
 */
#define DDBLT_ZBUFFERDESTOVERRIDE		0x00200000l

/*
 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the source.
 */
#define DDBLT_ZBUFFERSRCCONSTOVERRIDE		0x00400000l

/*
 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the source.
 */
#define DDBLT_ZBUFFERSRCOVERRIDE                0x00800000l

/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */
#define DDBLT_WAIT                              0x01000000l

/*
 * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
 * to fill the destination rectangle on the destination Z-buffer surface
 * with.
 */
#define DDBLT_DEPTHFILL				0x02000000l



/****************************************************************************
 *
 * BLTFAST FLAGS
 *
 ****************************************************************************/

#define DDBLTFAST_NOCOLORKEY                    0x00000000
#define DDBLTFAST_SRCCOLORKEY                   0x00000001
#define DDBLTFAST_DESTCOLORKEY                  0x00000002
#define DDBLTFAST_WAIT                          0x00000010




/****************************************************************************
 *
 * FLIP FLAGS
 *
 ****************************************************************************/

#define DDFLIP_WAIT                          0x00000001L

/*
 * Indicates that the target surface contains the even field of video data.
 * This flag is only valid with an overlay surface.
 */
#define DDFLIP_EVEN                          0x00000002L

/*
 * Indicates that the target surface contains the odd field of video data.
 * This flag is only valid with an overlay surface.
 */
#define DDFLIP_ODD                           0x00000004L



/****************************************************************************
 *
 * DIRECTDRAW SURFACE OVERLAY FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for the
 * destination overlay.
 */
#define DDOVER_ALPHADEST			0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDOVERLAYFX structure as the
 * destination alpha channel for this overlay.
 */
#define DDOVER_ALPHADESTCONSTOVERRIDE		0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases.
 */
#define DDOVER_ALPHADESTNEG			0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDOVERLAYFX structure as the alpha
 * channel destination for this overlay.
 */
#define DDOVER_ALPHADESTSURFACEOVERRIDE		0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDOVERLAYFX structure as the alpha
 * channel for the edges of the image that border the color key colors.
 */
#define DDOVER_ALPHAEDGEBLEND			0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the source alpha channel for this overlay.
 */
#define DDOVER_ALPHASRC				0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDOVERLAYFX structure as the source
 * alpha channel for this overlay.
 */
#define DDOVER_ALPHASRCCONSTOVERRIDE		0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases.
 */
#define DDOVER_ALPHASRCNEG			0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDOVERLAYFX structure as the alpha channel
 * source for this overlay.
 */
#define DDOVER_ALPHASRCSURFACEOVERRIDE		0x00000100l

/*
 * Turn this overlay off.
 */
#define DDOVER_HIDE				0x00000200l

/*
 * Use the color key associated with the destination surface.
 */
#define DDOVER_KEYDEST				0x00000400l

/*
 * Use the dckDestColorkey field in the DDOVERLAYFX structure as the color key
 * for the destination surface
 */
#define DDOVER_KEYDESTOVERRIDE			0x00000800l

/*
 * Use the color key associated with the source surface.
 */
#define DDOVER_KEYSRC				0x00001000l

/*
 * Use the dckSrcColorkey field in the DDOVERLAYFX structure as the color key
 * for the source surface.
 */
#define DDOVER_KEYSRCOVERRIDE			0x00002000l

/*
 * Turn this overlay on.
 */
#define DDOVER_SHOW				0x00004000l

/*
 * Add a dirty rect to an emulated overlayed surface.
 */
#define DDOVER_ADDDIRTYRECT                     0x00008000l

/*
 * Redraw all dirty rects on an emulated overlayed surface.
 */
#define DDOVER_REFRESHDIRTYRECTS		0x00010000l

/*
 * Redraw the entire surface on an emulated overlayed surface.
 */
#define DDOVER_REFRESHALL                      0x00020000l


/*
 * Use the overlay FX flags to define special overlay FX
 */
#define DDOVER_DDFX                       	0x00080000l

/*
 * Autoflip the overlay when ever the video port autoflips
 */
#define DDOVER_AUTOFLIP                       	0x00100000l

/*
 * Display each field of video port data individually without
 * causing any jittery artifacts
 */
#define DDOVER_BOB                       	0x00200000l

/*
 * Indicates that bob/weave decisions should not be overridden by other
 * interfaces.
 */
#define DDOVER_OVERRIDEBOBWEAVE			0x00400000l

/*
 * Indicates that the surface memory is composed of interleaved fields.
 */
#define DDOVER_INTERLEAVED			0x00800000l

/*
 * Indicates that bob will be performed using hardware rather than
 * software or emulated.
 */
#define DDOVER_BOBHARDWARE			0x01000000l








/****************************************************************************
 *
 * DIRECTDRAWSURFACE LOCK FLAGS
 *
 ****************************************************************************/

/*
 * The default.	 Set to indicate that Lock should return a valid memory pointer
 * to the top of the specified rectangle.  If no rectangle is specified then a
 * pointer to the top of the surface is returned.
 */
#define DDLOCK_SURFACEMEMORYPTR			0x00000000L	// default

/*
 * Set to indicate that Lock should wait until it can obtain a valid memory
 * pointer before returning.  If this bit is set, Lock will never return
 * DDERR_WASSTILLDRAWING.
 */
#define DDLOCK_WAIT				0x00000001L

/*
 * Set if an event handle is being passed to Lock.  Lock will trigger the event
 * when it can return the surface memory pointer requested.
 */
#define DDLOCK_EVENT				0x00000002L

/*
 * Indicates that the surface being locked will only be read from.
 */
#define DDLOCK_READONLY				0x00000010L

/*
 * Indicates that the surface being locked will only be written to
 */
#define DDLOCK_WRITEONLY			0x00000020L


/*
 * Indicates that a system wide lock should not be taken when this surface
 * is locked. This has several advantages (cursor responsiveness, ability
 * to call more Windows functions, easier debugging) when locking video
 * memory surfaces. However, an application specifying this flag must
 * comply with a number of conditions documented in the help file.
 * Furthermore, this flag cannot be specified when locking the primary.
 */
#define DDLOCK_NOSYSLOCK                        0x00000800L


/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGELOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGEUNLOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE BLT FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this blt.
 */
#define DDBLTFX_ARITHSTRETCHY			0x00000001l

/*
 * Do this blt mirroring the surface left to right.  Spin the
 * surface around its y-axis.
 */
#define DDBLTFX_MIRRORLEFTRIGHT			0x00000002l

/*
 * Do this blt mirroring the surface up and down.  Spin the surface
 * around its x-axis.
 */
#define DDBLTFX_MIRRORUPDOWN			0x00000004l

/*
 * Schedule this blt to avoid tearing.
 */
#define DDBLTFX_NOTEARING			0x00000008l

/*
 * Do this blt rotating the surface one hundred and eighty degrees.
 */
#define DDBLTFX_ROTATE180			0x00000010l

/*
 * Do this blt rotating the surface two hundred and seventy degrees.
 */
#define DDBLTFX_ROTATE270			0x00000020l

/*
 * Do this blt rotating the surface ninety degrees.
 */
#define DDBLTFX_ROTATE90			0x00000040l

/*
 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
 * specified to limit the bits copied from the source surface.
 */
#define DDBLTFX_ZBUFFERRANGE			0x00000080l

/*
 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
 * before comparing it with the desting z values.
 */
#define DDBLTFX_ZBUFFERBASEDEST			0x00000100l

/****************************************************************************
 *
 * DIRECTDRAWSURFACE OVERLAY FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this overlay.
 */
#define DDOVERFX_ARITHSTRETCHY			0x00000001l

/*
 * Mirror the overlay across the vertical axis
 */
#define DDOVERFX_MIRRORLEFTRIGHT		0x00000002l

/*
 * Mirror the overlay across the horizontal axis
 */
#define DDOVERFX_MIRRORUPDOWN			0x00000004l

/****************************************************************************
 *
 * Flags for dwDDFX member of DDSPRITEFX structure
 *
 ****************************************************************************/
/*
 * Use affine transformation matrix in fTransform member.
 */
#define DDSPRITEFX_AFFINETRANSFORM		0x00000001l

/*
 * Use RGBA scaling factors in ddrgbaScaleFactors member.
 */
#define DDSPRITEFX_RGBASCALING			0x00000002l

/*
 * Degrade RGBA scaling factors to accommodate driver's capabilities.
 */
#define DDSPRITEFX_DEGRADERGBASCALING		0x00000004l

/*
 * Do bilinear filtering of stretched or warped sprite.
 */
#define DDSPRITEFX_BILINEARFILTER     	  	0x00000008l

/*
 * Do "blur" filtering of stretched or warped sprite.
 */
#define DDSPRITEFX_BLURFILTER 	      	 	0x00000010l

/*
 * Do "flat" filtering of stretched or warped sprite.
 */
#define DDSPRITEFX_FLATFILTER 	      		0x00000020l

/*
 * Degrade filtering operation to accommodate driver's capabilities.
 */
#define DDSPRITEFX_DEGRADEFILTER 	      	0x00000040l


/****************************************************************************
 *
 * DIRECTDRAW WAITFORVERTICALBLANK FLAGS
 *
 ****************************************************************************/

/*
 * return when the vertical blank interval begins
 */
#define DDWAITVB_BLOCKBEGIN			0x00000001l

/*
 * set up an event to trigger when the vertical blank begins
 */
#define DDWAITVB_BLOCKBEGINEVENT		0x00000002l

/*
 * return when the vertical blank interval ends and display begins
 */
#define DDWAITVB_BLOCKEND			0x00000004l

/****************************************************************************
 *
 * DIRECTDRAW GETFLIPSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to flip now?
 */
#define DDGFS_CANFLIP			0x00000001l

/*
 * is the last flip finished?
 */
#define DDGFS_ISFLIPDONE		0x00000002l

/****************************************************************************
 *
 * DIRECTDRAW GETBLTSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to blt now?
 */
#define DDGBS_CANBLT			0x00000001l

/*
 * is the blt to the surface finished?
 */
#define DDGBS_ISBLTDONE			0x00000002l


/****************************************************************************
 *
 * DIRECTDRAW ENUMOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate overlays back to front.
 */
#define DDENUMOVERLAYZ_BACKTOFRONT	0x00000000l

/*
 * Enumerate overlays front to back
 */
#define DDENUMOVERLAYZ_FRONTTOBACK	0x00000001l

/****************************************************************************
 *
 * DIRECTDRAW UPDATEOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Send overlay to front
 */
#define DDOVERZ_SENDTOFRONT		0x00000000l

/*
 * Send overlay to back
 */
#define DDOVERZ_SENDTOBACK		0x00000001l

/*
 * Move Overlay forward
 */
#define DDOVERZ_MOVEFORWARD		0x00000002l

/*
 * Move Overlay backward
 */
#define DDOVERZ_MOVEBACKWARD		0x00000003l

/*
 * Move Overlay in front of relative surface
 */
#define DDOVERZ_INSERTINFRONTOF		0x00000004l

/*
 * Move Overlay in back of relative surface
 */
#define DDOVERZ_INSERTINBACKOF		0x00000005l



/****************************************************************************
 *
 * DIRECTDRAW SETGAMMARAMP FLAGS
 *
 ****************************************************************************/

/*
 * Request calibrator to adjust the gamma ramp according to the physical
 * properties of the display so that the result should appear identical
 * on all systems.
 */
#define DDSGR_CALIBRATE                        0x00000001L


/*===========================================================================
 *
 *
 * DIRECTDRAW RETURN CODES
 *
 * The return values from DirectDraw Commands and Surface that return an HRESULT
 * are codes from DirectDraw concerning the results of the action
 * requested by DirectDraw.
 *
 *==========================================================================*/

/*
 * Status is OK
 *
 * Issued by: DirectDraw Commands and all callbacks
 */
#define DD_OK					0
#define DD_FALSE                                S_FALSE

/****************************************************************************
 *
 * DIRECTDRAW ENUMCALLBACK RETURN VALUES
 *
 * EnumCallback returns are used to control the flow of the DIRECTDRAW and
 * DIRECTDRAWSURFACE object enumerations.   They can only be returned by
 * enumeration callback routines.
 *
 ****************************************************************************/

/*
 * stop the enumeration
 */
#define DDENUMRET_CANCEL			0

/*
 * continue the enumeration
 */
#define DDENUMRET_OK				1

/****************************************************************************
 *
 * DIRECTDRAW ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

/*
 * This object is already initialized
 */
#define DDERR_ALREADYINITIALIZED		MAKE_DDHRESULT( 5 )

/*
 * This surface can not be attached to the requested surface.
 */
#define DDERR_CANNOTATTACHSURFACE		MAKE_DDHRESULT( 10 )

/*
 * This surface can not be detached from the requested surface.
 */
#define DDERR_CANNOTDETACHSURFACE		MAKE_DDHRESULT( 20 )

/*
 * Support is currently not available.
 */
#define DDERR_CURRENTLYNOTAVAIL			MAKE_DDHRESULT( 40 )

/*
 * An exception was encountered while performing the requested operation
 */
#define DDERR_EXCEPTION				MAKE_DDHRESULT( 55 )

/*
 * Generic failure.
 */
#define DDERR_GENERIC				E_FAIL

/*
 * Height of rectangle provided is not a multiple of reqd alignment
 */
#define DDERR_HEIGHTALIGN			MAKE_DDHRESULT( 90 )

/*
 * Unable to match primary surface creation request with existing
 * primary surface.
 */
#define DDERR_INCOMPATIBLEPRIMARY		MAKE_DDHRESULT( 95 )

/*
 * One or more of the caps bits passed to the callback are incorrect.
 */
#define DDERR_INVALIDCAPS			MAKE_DDHRESULT( 100 )

/*
 * DirectDraw does not support provided Cliplist.
 */
#define DDERR_INVALIDCLIPLIST			MAKE_DDHRESULT( 110 )

/*
 * DirectDraw does not support the requested mode
 */
#define DDERR_INVALIDMODE			MAKE_DDHRESULT( 120 )

/*
 * DirectDraw received a pointer that was an invalid DIRECTDRAW object.
 */
#define DDERR_INVALIDOBJECT			MAKE_DDHRESULT( 130 )

/*
 * One or more of the parameters passed to the callback function are
 * incorrect.
 */
#define DDERR_INVALIDPARAMS			E_INVALIDARG

/*
 * pixel format was invalid as specified
 */
#define DDERR_INVALIDPIXELFORMAT		MAKE_DDHRESULT( 145 )

/*
 * Rectangle provided was invalid.
 */
#define DDERR_INVALIDRECT			MAKE_DDHRESULT( 150 )

/*
 * Operation could not be carried out because one or more surfaces are locked
 */
#define DDERR_LOCKEDSURFACES			MAKE_DDHRESULT( 160 )

/*
 * There is no 3D present.
 */
#define DDERR_NO3D				MAKE_DDHRESULT( 170 )

/*
 * Operation could not be carried out because there is no alpha accleration
 * hardware present or available.
 */
#define DDERR_NOALPHAHW				MAKE_DDHRESULT( 180 )


/*
 * no clip list available
 */
#define DDERR_NOCLIPLIST			MAKE_DDHRESULT( 205 )

/*
 * Operation could not be carried out because there is no color conversion
 * hardware present or available.
 */
#define DDERR_NOCOLORCONVHW			MAKE_DDHRESULT( 210 )

/*
 * Create function called without DirectDraw object method SetCooperativeLevel
 * being called.
 */
#define DDERR_NOCOOPERATIVELEVELSET		MAKE_DDHRESULT( 212 )

/*
 * Surface doesn't currently have a color key
 */
#define DDERR_NOCOLORKEY			MAKE_DDHRESULT( 215 )

/*
 * Operation could not be carried out because there is no hardware support
 * of the dest color key.
 */
#define DDERR_NOCOLORKEYHW			MAKE_DDHRESULT( 220 )

/*
 * No DirectDraw support possible with current display driver
 */
#define DDERR_NODIRECTDRAWSUPPORT		MAKE_DDHRESULT( 222 )

/*
 * Operation requires the application to have exclusive mode but the
 * application does not have exclusive mode.
 */
#define DDERR_NOEXCLUSIVEMODE			MAKE_DDHRESULT( 225 )

/*
 * Flipping visible surfaces is not supported.
 */
#define DDERR_NOFLIPHW				MAKE_DDHRESULT( 230 )

/*
 * There is no GDI present.
 */
#define DDERR_NOGDI				MAKE_DDHRESULT( 240 )

/*
 * Operation could not be carried out because there is no hardware present
 * or available.
 */
#define DDERR_NOMIRRORHW			MAKE_DDHRESULT( 250 )

/*
 * Requested item was not found
 */
#define DDERR_NOTFOUND				MAKE_DDHRESULT( 255 )

/*
 * Operation could not be carried out because there is no overlay hardware
 * present or available.
 */
#define DDERR_NOOVERLAYHW			MAKE_DDHRESULT( 260 )

/*
 * Operation could not be carried out because the source and destination
 * rectangles are on the same surface and overlap each other.
 */
#define DDERR_OVERLAPPINGRECTS			MAKE_DDHRESULT( 270 )

/*
 * Operation could not be carried out because there is no appropriate raster
 * op hardware present or available.
 */
#define DDERR_NORASTEROPHW			MAKE_DDHRESULT( 280 )

/*
 * Operation could not be carried out because there is no rotation hardware
 * present or available.
 */
#define DDERR_NOROTATIONHW			MAKE_DDHRESULT( 290 )

/*
 * Operation could not be carried out because there is no hardware support
 * for stretching
 */
#define DDERR_NOSTRETCHHW			MAKE_DDHRESULT( 310 )

/*
 * DirectDrawSurface is not in 4 bit color palette and the requested operation
 * requires 4 bit color palette.
 */
#define DDERR_NOT4BITCOLOR			MAKE_DDHRESULT( 316 )

/*
 * DirectDrawSurface is not in 4 bit color index palette and the requested
 * operation requires 4 bit color index palette.
 */
#define DDERR_NOT4BITCOLORINDEX			MAKE_DDHRESULT( 317 )

/*
 * DirectDraw Surface is not in 8 bit color mode and the requested operation
 * requires 8 bit color.
 */
#define DDERR_NOT8BITCOLOR			MAKE_DDHRESULT( 320 )

/*
 * Operation could not be carried out because there is no texture mapping
 * hardware present or available.
 */
#define DDERR_NOTEXTUREHW			MAKE_DDHRESULT( 330 )

/*
 * Operation could not be carried out because there is no hardware support
 * for vertical blank synchronized operations.
 */
#define DDERR_NOVSYNCHW				MAKE_DDHRESULT( 335 )

/*
 * Operation could not be carried out because there is no hardware support
 * for zbuffer blting.
 */
#define DDERR_NOZBUFFERHW			MAKE_DDHRESULT( 340 )

/*
 * Overlay surfaces could not be z layered based on their BltOrder because
 * the hardware does not support z layering of overlays.
 */
#define DDERR_NOZOVERLAYHW			MAKE_DDHRESULT( 350 )

/*
 * The hardware needed for the requested operation has already been
 * allocated.
 */
#define DDERR_OUTOFCAPS				MAKE_DDHRESULT( 360 )

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFMEMORY			E_OUTOFMEMORY

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFVIDEOMEMORY			MAKE_DDHRESULT( 380 )

/*
 * hardware does not support clipped overlays
 */
#define DDERR_OVERLAYCANTCLIP			MAKE_DDHRESULT( 382 )

/*
 * Can only have ony color key active at one time for overlays
 */
#define DDERR_OVERLAYCOLORKEYONLYONEACTIVE	MAKE_DDHRESULT( 384 )

/*
 * Access to this palette is being refused because the palette is already
 * locked by another thread.
 */
#define DDERR_PALETTEBUSY			MAKE_DDHRESULT( 387 )

/*
 * No src color key specified for this operation.
 */
#define DDERR_COLORKEYNOTSET			MAKE_DDHRESULT( 400 )

/*
 * This surface is already attached to the surface it is being attached to.
 */
#define DDERR_SURFACEALREADYATTACHED		MAKE_DDHRESULT( 410 )

/*
 * This surface is already a dependency of the surface it is being made a
 * dependency of.
 */
#define DDERR_SURFACEALREADYDEPENDENT		MAKE_DDHRESULT( 420 )

/*
 * Access to this surface is being refused because the surface is already
 * locked by another thread.
 */
#define DDERR_SURFACEBUSY			MAKE_DDHRESULT( 430 )

/*
 * Access to this surface is being refused because no driver exists
 * which can supply a pointer to the surface.
 * This is most likely to happen when attempting to lock the primary
 * surface when no DCI provider is present.
 * Will also happen on attempts to lock an optimized surface.
 */
#define DDERR_CANTLOCKSURFACE                   MAKE_DDHRESULT( 435 )

/*
 * Access to Surface refused because Surface is obscured.
 */
#define DDERR_SURFACEISOBSCURED			MAKE_DDHRESULT( 440 )

/*
 * Access to this surface is being refused because the surface is gone.
 * The DIRECTDRAWSURFACE object representing this surface should
 * have Restore called on it.
 */
#define DDERR_SURFACELOST			MAKE_DDHRESULT( 450 )

/*
 * The requested surface is not attached.
 */
#define DDERR_SURFACENOTATTACHED		MAKE_DDHRESULT( 460 )

/*
 * Height requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGHEIGHT			MAKE_DDHRESULT( 470 )

/*
 * Size requested by DirectDraw is too large --	 The individual height and
 * width are OK.
 */
#define DDERR_TOOBIGSIZE			MAKE_DDHRESULT( 480 )

/*
 * Width requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGWIDTH			MAKE_DDHRESULT( 490 )

/*
 * Action not supported.
 */
#define DDERR_UNSUPPORTED			E_NOTIMPL

/*
 * FOURCC format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDFORMAT			MAKE_DDHRESULT( 510 )

/*
 * Bitmask in the pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDMASK			MAKE_DDHRESULT( 520 )

/*
 * The specified stream contains invalid data
 */
#define DDERR_INVALIDSTREAM                     MAKE_DDHRESULT( 521 )

/*
 * vertical blank is in progress
 */
#define DDERR_VERTICALBLANKINPROGRESS		MAKE_DDHRESULT( 537 )

/*
 * Informs DirectDraw that the previous Blt which is transfering information
 * to or from this Surface is incomplete.
 */
#define DDERR_WASSTILLDRAWING			MAKE_DDHRESULT( 540 )


/*
 * Rectangle provided was not horizontally aligned on reqd. boundary
 */
#define DDERR_XALIGN				MAKE_DDHRESULT( 560 )

/*
 * The GUID passed to DirectDrawCreate is not a valid DirectDraw driver
 * identifier.
 */
#define DDERR_INVALIDDIRECTDRAWGUID		MAKE_DDHRESULT( 561 )

/*
 * A DirectDraw object representing this driver has already been created
 * for this process.
 */
#define DDERR_DIRECTDRAWALREADYCREATED		MAKE_DDHRESULT( 562 )

/*
 * A hardware only DirectDraw object creation was attempted but the driver
 * did not support any hardware.
 */
#define DDERR_NODIRECTDRAWHW			MAKE_DDHRESULT( 563 )

/*
 * this process already has created a primary surface
 */
#define DDERR_PRIMARYSURFACEALREADYEXISTS	MAKE_DDHRESULT( 564 )

/*
 * software emulation not available.
 */
#define DDERR_NOEMULATION			MAKE_DDHRESULT( 565 )

/*
 * region passed to Clipper::GetClipList is too small.
 */
#define DDERR_REGIONTOOSMALL			MAKE_DDHRESULT( 566 )

/*
 * an attempt was made to set a clip list for a clipper objec that
 * is already monitoring an hwnd.
 */
#define DDERR_CLIPPERISUSINGHWND		MAKE_DDHRESULT( 567 )

/*
 * No clipper object attached to surface object
 */
#define DDERR_NOCLIPPERATTACHED			MAKE_DDHRESULT( 568 )

/*
 * Clipper notification requires an HWND or
 * no HWND has previously been set as the CooperativeLevel HWND.
 */
#define DDERR_NOHWND				MAKE_DDHRESULT( 569 )

/*
 * HWND used by DirectDraw CooperativeLevel has been subclassed,
 * this prevents DirectDraw from restoring state.
 */
#define DDERR_HWNDSUBCLASSED			MAKE_DDHRESULT( 570 )

/*
 * The CooperativeLevel HWND has already been set.
 * It can not be reset while the process has surfaces or palettes created.
 */
#define DDERR_HWNDALREADYSET			MAKE_DDHRESULT( 571 )

/*
 * No palette object attached to this surface.
 */
#define DDERR_NOPALETTEATTACHED			MAKE_DDHRESULT( 572 )

/*
 * No hardware support for 16 or 256 color palettes.
 */
#define DDERR_NOPALETTEHW			MAKE_DDHRESULT( 573 )

/*
 * If a clipper object is attached to the source surface passed into a
 * BltFast call.
 */
#define DDERR_BLTFASTCANTCLIP			MAKE_DDHRESULT( 574 )

/*
 * No blter.
 */
#define DDERR_NOBLTHW				MAKE_DDHRESULT( 575 )

/*
 * No DirectDraw ROP hardware.
 */
#define DDERR_NODDROPSHW			MAKE_DDHRESULT( 576 )

/*
 * returned when GetOverlayPosition is called on a hidden overlay
 */
#define DDERR_OVERLAYNOTVISIBLE			MAKE_DDHRESULT( 577 )

/*
 * returned when GetOverlayPosition is called on a overlay that UpdateOverlay
 * has never been called on to establish a destionation.
 */
#define DDERR_NOOVERLAYDEST			MAKE_DDHRESULT( 578 )

/*
 * returned when the position of the overlay on the destionation is no longer
 * legal for that destionation.
 */
#define DDERR_INVALIDPOSITION			MAKE_DDHRESULT( 579 )

/*
 * returned when an overlay member is called for a non-overlay surface
 */
#define DDERR_NOTAOVERLAYSURFACE		MAKE_DDHRESULT( 580 )

/*
 * An attempt was made to set the cooperative level when it was already
 * set to exclusive.
 */
#define DDERR_EXCLUSIVEMODEALREADYSET		MAKE_DDHRESULT( 581 )

/*
 * An attempt has been made to flip a surface that is not flippable.
 */
#define DDERR_NOTFLIPPABLE			MAKE_DDHRESULT( 582 )

/*
 * Can't duplicate primary & 3D surfaces, or surfaces that are implicitly
 * created.
 */
#define DDERR_CANTDUPLICATE			MAKE_DDHRESULT( 583 )

/*
 * Surface was not locked.  An attempt to unlock a surface that was not
 * locked at all, or by this process, has been attempted.
 */
#define DDERR_NOTLOCKED				MAKE_DDHRESULT( 584 )

/*
 * Windows can not create any more DCs, or a DC was requested for a paltte-indexed
 * surface when the surface had no palette AND the display mode was not palette-indexed
 * (in this case DirectDraw cannot select a proper palette into the DC)
 */
#define DDERR_CANTCREATEDC			MAKE_DDHRESULT( 585 )

/*
 * No DC was ever created for this surface.
 */
#define DDERR_NODC				MAKE_DDHRESULT( 586 )

/*
 * This surface can not be restored because it was created in a different
 * mode.
 */
#define DDERR_WRONGMODE				MAKE_DDHRESULT( 587 )

/*
 * This surface can not be restored because it is an implicitly created
 * surface.
 */
#define DDERR_IMPLICITLYCREATED			MAKE_DDHRESULT( 588 )

/*
 * The surface being used is not a palette-based surface
 */
#define DDERR_NOTPALETTIZED			MAKE_DDHRESULT( 589 )


/*
 * The display is currently in an unsupported mode
 */
#define DDERR_UNSUPPORTEDMODE			MAKE_DDHRESULT( 590 )

/*
 * Operation could not be carried out because there is no mip-map
 * texture mapping hardware present or available.
 */
#define DDERR_NOMIPMAPHW			MAKE_DDHRESULT( 591 )

/*
 * The requested action could not be performed because the surface was of
 * the wrong type.
 */
#define DDERR_INVALIDSURFACETYPE                MAKE_DDHRESULT( 592 )



/*
 * Device does not support optimized surfaces, therefore no video memory optimized surfaces
 */
#define DDERR_NOOPTIMIZEHW                      MAKE_DDHRESULT( 600 )

/*
 * Surface is an optimized surface, but has not yet been allocated any memory
 */
#define DDERR_NOTLOADED                         MAKE_DDHRESULT( 601 )

/*
 * Attempt was made to create or set a device window without first setting
 * the focus window
 */
#define DDERR_NOFOCUSWINDOW                     MAKE_DDHRESULT( 602 )

/*
 * A DC has already been returned for this surface. Only one DC can be
 * retrieved per surface.
 */
#define DDERR_DCALREADYCREATED			MAKE_DDHRESULT( 620 )

/*
 * An attempt was made to allocate non-local video memory from a device
 * that does not support non-local video memory.
 */
#define DDERR_NONONLOCALVIDMEM                  MAKE_DDHRESULT( 630 )

/*
 * The attempt to page lock a surface failed.
 */
#define DDERR_CANTPAGELOCK			MAKE_DDHRESULT( 640 )


/*
 * The attempt to page unlock a surface failed.
 */
#define DDERR_CANTPAGEUNLOCK			MAKE_DDHRESULT( 660 )

/*
 * An attempt was made to page unlock a surface with no outstanding page locks.
 */
#define DDERR_NOTPAGELOCKED			MAKE_DDHRESULT( 680 )

/*
 * There is more data available than the specified buffer size could hold
 */
#define DDERR_MOREDATA         			MAKE_DDHRESULT( 690 )

/*
 * The data has expired and is therefore no longer valid.
 */
#define DDERR_EXPIRED                           MAKE_DDHRESULT( 691 )

/*
 * The video port is not active
 */
#define DDERR_VIDEONOTACTIVE   			MAKE_DDHRESULT( 695 )

/*
 * Surfaces created by one direct draw device cannot be used directly by
 * another direct draw device.
 */
#define DDERR_DEVICEDOESNTOWNSURFACE   		MAKE_DDHRESULT( 699 )


/*
 * An attempt was made to invoke an interface member of a DirectDraw object
 * created by CoCreateInstance() before it was initialized.
 */
#define DDERR_NOTINITIALIZED                    CO_E_NOTINITIALIZED


/* Alpha bit depth constants */


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\dls1.h ===
/*==========================================================================;
//
//  dls1.h
//
//
//  Description:
//
//  Interface defines and structures for the Instrument Collection Form
//  RIFF DLS.
//
//
//  Written by Sonic Foundry 1996.  Released for public use.
//
//=========================================================================*/

#ifndef _INC_DLS1
#define _INC_DLS1

/*//////////////////////////////////////////////////////////////////////////
//
//
// Layout of an instrument collection:
//
//
// RIFF [] 'DLS ' [dlid,colh,INSTLIST,WAVEPOOL,INFOLIST]
//
// INSTLIST
// LIST [] 'lins'
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//
// RGNLIST
// LIST [] 'lrgn' 
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//
// ARTLIST
// LIST [] 'lart'
//         'art1' level 1 Articulation connection graph
//         'art2' level 2 Articulation connection graph
//         '3rd1' Possible 3rd party articulation structure 1
//         '3rd2' Possible 3rd party articulation structure 2 .... and so on
//
// WAVEPOOL 
// ptbl [] [pool table]
// LIST [] 'wvpl'
//               [path],
//               [path],
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave'	[dlid,RIFFWAVE]
//               LIST [] 'wave'	[dlid,RIFFWAVE]
//               LIST [] 'wave'	[dlid,RIFFWAVE]
//               LIST [] 'wave'	[dlid,RIFFWAVE]
//
// INFOLIST
// LIST [] 'INFO' 
//               'icmt' 'One of those crazy comments.'
//               'icop' 'Copyright (C) 1996 Sonic Foundry'
//
/////////////////////////////////////////////////////////////////////////*/


/*/////////////////////////////////////////////////////////////////////////
// FOURCC's used in the DLS file
/////////////////////////////////////////////////////////////////////////*/

#define FOURCC_DLS   mmioFOURCC('D','L','S',' ')
#define FOURCC_DLID  mmioFOURCC('d','l','i','d')
#define FOURCC_COLH  mmioFOURCC('c','o','l','h')
#define FOURCC_WVPL  mmioFOURCC('w','v','p','l')
#define FOURCC_PTBL  mmioFOURCC('p','t','b','l')
#define FOURCC_PATH  mmioFOURCC('p','a','t','h')
#define FOURCC_wave  mmioFOURCC('w','a','v','e')
#define FOURCC_LINS  mmioFOURCC('l','i','n','s')
#define FOURCC_INS   mmioFOURCC('i','n','s',' ')
#define FOURCC_INSH  mmioFOURCC('i','n','s','h')
#define FOURCC_LRGN  mmioFOURCC('l','r','g','n')
#define FOURCC_RGN   mmioFOURCC('r','g','n',' ')
#define FOURCC_RGNH  mmioFOURCC('r','g','n','h')
#define FOURCC_LART  mmioFOURCC('l','a','r','t')
#define FOURCC_ART1  mmioFOURCC('a','r','t','1')
#define FOURCC_WLNK  mmioFOURCC('w','l','n','k')
#define FOURCC_WSMP  mmioFOURCC('w','s','m','p')
#define FOURCC_VERS  mmioFOURCC('v','e','r','s')

/*/////////////////////////////////////////////////////////////////////////
// Articulation connection graph definitions 
/////////////////////////////////////////////////////////////////////////*/

/* Generic Sources */
#define CONN_SRC_NONE              0x0000
#define CONN_SRC_LFO               0x0001
#define CONN_SRC_KEYONVELOCITY     0x0002
#define CONN_SRC_KEYNUMBER         0x0003
#define CONN_SRC_EG1               0x0004
#define CONN_SRC_EG2               0x0005
#define CONN_SRC_PITCHWHEEL        0x0006

/* Midi Controllers 0-127 */
#define CONN_SRC_CC1               0x0081
#define CONN_SRC_CC7               0x0087
#define CONN_SRC_CC10              0x008a
#define CONN_SRC_CC11              0x008b

/* Generic Destinations */
#define CONN_DST_NONE              0x0000
#define CONN_DST_ATTENUATION       0x0001
#define CONN_DST_PITCH             0x0003
#define CONN_DST_PAN               0x0004

/* LFO Destinations */
#define CONN_DST_LFO_FREQUENCY     0x0104
#define CONN_DST_LFO_STARTDELAY    0x0105

/* EG1 Destinations */
#define CONN_DST_EG1_ATTACKTIME    0x0206
#define CONN_DST_EG1_DECAYTIME     0x0207
#define CONN_DST_EG1_RELEASETIME   0x0209
#define CONN_DST_EG1_SUSTAINLEVEL  0x020a

/* EG2 Destinations */
#define CONN_DST_EG2_ATTACKTIME    0x030a
#define CONN_DST_EG2_DECAYTIME     0x030b
#define CONN_DST_EG2_RELEASETIME   0x030d
#define CONN_DST_EG2_SUSTAINLEVEL  0x030e

#define CONN_TRN_NONE              0x0000
#define CONN_TRN_CONCAVE           0x0001

typedef struct _DLSID {
  ULONG    ulData1;
  USHORT   usData2;
  USHORT   usData3;
  BYTE     abData4[8];
} DLSID, FAR *LPDLSID;

typedef struct _DLSVERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DLSVERSION, FAR *LPDLSVERSION;
				   

typedef struct _CONNECTION {
  USHORT   usSource;
  USHORT   usControl;
  USHORT   usDestination;
  USHORT   usTransform;
  LONG     lScale;
  }CONNECTION, FAR *LPCONNECTION;


/* Level 1 Articulation Data */

typedef struct _CONNECTIONLIST {
  ULONG    cbSize;            /* size of the connection list structure */
  ULONG    cConnections;      /* count of connections in the list */
  } CONNECTIONLIST, FAR *LPCONNECTIONLIST;



/*/////////////////////////////////////////////////////////////////////////
// Generic type defines for regions and instruments
/////////////////////////////////////////////////////////////////////////*/

typedef struct _RGNRANGE {
  USHORT usLow;
  USHORT usHigh;
}RGNRANGE, FAR * LPRGNRANGE;

#define F_INSTRUMENT_DRUMS      0x80000000

typedef struct _MIDILOCALE {
  ULONG ulBank;
  ULONG ulInstrument;
}MIDILOCALE, FAR *LPMIDILOCALE;

/*/////////////////////////////////////////////////////////////////////////
// Header structures found in an DLS file for collection, instruments, and
// regions.
/////////////////////////////////////////////////////////////////////////*/

#define F_RGN_OPTION_SELFNONEXCLUSIVE  0x0001

typedef struct _RGNHEADER {
  RGNRANGE RangeKey;            /* Key range  */
  RGNRANGE RangeVelocity;       /* Velocity Range  */
  USHORT   fusOptions;          /* Synthesis options for this range */
  USHORT   usKeyGroup;          /* Key grouping for non simultaneous play */
                                /* 0 = no group, 1 up is group */
                                /* for Level 1 only groups 1-15 are allowed */
}RGNHEADER, FAR *LPRGNHEADER;

typedef struct _INSTHEADER {
  ULONG      cRegions;          /* Count of regions in this instrument */
  MIDILOCALE Locale;            /* Intended MIDI locale of this instrument */
}INSTHEADER, FAR *LPINSTHEADER;

typedef struct _DLSHEADER {
  ULONG      cInstruments;      /* Count of instruments in the collection */
}DLSHEADER, FAR *LPDLSHEADER;

/*////////////////////////////////////////////////////////////////////////////
// definitions for the Wave link structure
////////////////////////////////////////////////////////////////////////////*/

/* ****  For level 1 only WAVELINK_CHANNEL_MONO is valid  **** */
/* ulChannel allows for up to 32 channels of audio with each bit position */
/* specifiying a channel of playback */

#define WAVELINK_CHANNEL_LEFT    0x0001l
#define WAVELINK_CHANNEL_RIGHT   0x0002l

#define F_WAVELINK_PHASE_MASTER  0x0001

typedef struct _WAVELINK { /* any paths or links are stored right after struct */
  USHORT   fusOptions;     /* options flags for this wave */
  USHORT   usPhaseGroup;   /* Phase grouping for locking channels */
  ULONG    ulChannel;      /* channel placement */
  ULONG    ulTableIndex;   /* index into the wave pool table, 0 based */
}WAVELINK, FAR *LPWAVELINK;

#define POOL_CUE_NULL  0xffffffffl

typedef struct _POOLCUE { 
/*  ULONG    ulEntryIndex;   // Index entry in the list */
  ULONG    ulOffset;       /* Offset to the entry in the list */
}POOLCUE, FAR *LPPOOLCUE;

typedef struct _POOLTABLE {
  ULONG    cbSize;            /* size of the pool table structure */
  ULONG    cCues;             /* count of cues in the list */
  } POOLTABLE, FAR *LPPOOLTABLE;

/*////////////////////////////////////////////////////////////////////////////
// Structures for the "wsmp" chunk
////////////////////////////////////////////////////////////////////////////*/

#define F_WSMP_NO_TRUNCATION     0x0001l
#define F_WSMP_NO_COMPRESSION    0x0002l


typedef struct _rwsmp {
  ULONG   cbSize;
  USHORT  usUnityNote;         /* MIDI Unity Playback Note */
  SHORT   sFineTune;           /* Fine Tune in log tuning */
  LONG    lAttenuation;        /* Overall Attenuation to be applied to data */
  ULONG   fulOptions;          /* Flag options  */
  ULONG   cSampleLoops;        /* Count of Sample loops, 0 loops is one shot */
  } WSMPL, FAR *LPWSMPL;


/* This loop type is a normal forward playing loop which is continually */
/* played until the envelope reaches an off threshold in the release */
/* portion of the volume envelope */

#define WLOOP_TYPE_FORWARD   0

typedef struct _rloop {
  ULONG cbSize;
  ULONG ulType;              /* Loop Type */
  ULONG ulStart;             /* Start of loop in samples */
  ULONG ulLength;            /* Length of loop in samples */
} WLOOP, FAR *LPWLOOP;

#endif /*_INC_DLS1 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\dinput.h ===
/****************************************************************************
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinput.h
 *  Content:    DirectInput include file
 *
 ****************************************************************************/

#ifndef __DINPUT_INCLUDED__
#define __DINPUT_INCLUDED__

#ifndef DIJ_RINGZERO

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#endif

#endif /* DIJ_RINGZERO */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DIRECTINPUT_VERSION
#define DIRECTINPUT_VERSION         0x0500
#endif

#ifndef DIJ_RINGZERO
/****************************************************************************
 *
 *      Class IDs
 *
 ****************************************************************************/

DEFINE_GUID(CLSID_DirectInput,      0x25E609E0,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(CLSID_DirectInputDevice,0x25E609E1,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Interfaces
 *
 ****************************************************************************/

DEFINE_GUID(IID_IDirectInputA,     0x89521360,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputW,     0x89521361,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput2A,    0x5944E662,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput2W,    0x5944E663,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(IID_IDirectInputDeviceA, 0x5944E680,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDeviceW, 0x5944E681,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDevice2A,0x5944E682,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDevice2W,0x5944E683,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(IID_IDirectInputEffect,  0xE7E1F7C0,0x88D2,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);

/****************************************************************************
 *
 *      Predefined object types
 *
 ****************************************************************************/

DEFINE_GUID(GUID_XAxis,   0xA36D02E0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_YAxis,   0xA36D02E1,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ZAxis,   0xA36D02E2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RxAxis,  0xA36D02F4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RyAxis,  0xA36D02F5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RzAxis,  0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Slider,  0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_Button,  0xA36D02F0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Key,     0x55728220,0xD33C,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_POV,     0xA36D02F2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_Unknown, 0xA36D02F3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Predefined product GUIDs
 *
 ****************************************************************************/

DEFINE_GUID(GUID_SysMouse,   0x6F1D2B60,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboard,0x6F1D2B61,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Joystick   ,0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Predefined force feedback effects
 *
 ****************************************************************************/

DEFINE_GUID(GUID_ConstantForce,0x13541C20,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_RampForce,    0x13541C21,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Square,       0x13541C22,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Sine,         0x13541C23,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Triangle,     0x13541C24,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothUp,   0x13541C25,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothDown, 0x13541C26,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Spring,       0x13541C27,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Damper,       0x13541C28,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Inertia,      0x13541C29,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Friction,     0x13541C2A,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_CustomForce,  0x13541C2B,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);


#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Interfaces and Structures...
 *
 ****************************************************************************/

#if(DIRECTINPUT_VERSION >= 0x0500)

/****************************************************************************
 *
 *      IDirectInputEffect
 *
 ****************************************************************************/

#define DIEFT_ALL                   0x00000000

#define DIEFT_CONSTANTFORCE         0x00000001
#define DIEFT_RAMPFORCE             0x00000002
#define DIEFT_PERIODIC              0x00000003
#define DIEFT_CONDITION             0x00000004
#define DIEFT_CUSTOMFORCE           0x00000005
#define DIEFT_HARDWARE              0x000000FF

#define DIEFT_FFATTACK              0x00000200
#define DIEFT_FFFADE                0x00000400
#define DIEFT_SATURATION            0x00000800
#define DIEFT_POSNEGCOEFFICIENTS    0x00001000
#define DIEFT_POSNEGSATURATION      0x00002000
#define DIEFT_DEADBAND              0x00004000

#define DIEFT_GETTYPE(n)            LOBYTE(n)

#define DI_DEGREES                  100
#define DI_FFNOMINALMAX             10000
#define DI_SECONDS                  1000000

typedef struct DICONSTANTFORCE {
    LONG  lMagnitude;
} DICONSTANTFORCE, *LPDICONSTANTFORCE;
typedef const DICONSTANTFORCE *LPCDICONSTANTFORCE;

typedef struct DIRAMPFORCE {
    LONG  lStart;
    LONG  lEnd;
} DIRAMPFORCE, *LPDIRAMPFORCE;
typedef const DIRAMPFORCE *LPCDIRAMPFORCE;

typedef struct DIPERIODIC {
    DWORD dwMagnitude;
    LONG  lOffset;
    DWORD dwPhase;
    DWORD dwPeriod;
} DIPERIODIC, *LPDIPERIODIC;
typedef const DIPERIODIC *LPCDIPERIODIC;

typedef struct DICONDITION {
    LONG  lOffset;
    LONG  lPositiveCoefficient;
    LONG  lNegativeCoefficient;
    DWORD dwPositiveSaturation;
    DWORD dwNegativeSaturation;
    LONG  lDeadBand;
} DICONDITION, *LPDICONDITION;
typedef const DICONDITION *LPCDICONDITION;

typedef struct DICUSTOMFORCE {
    DWORD cChannels;
    DWORD dwSamplePeriod;
    DWORD cSamples;
    LPLONG rglForceData;
} DICUSTOMFORCE, *LPDICUSTOMFORCE;
typedef const DICUSTOMFORCE *LPCDICUSTOMFORCE;

typedef struct DIENVELOPE {
    DWORD dwSize;                   /* sizeof(DIENVELOPE)   */
    DWORD dwAttackLevel;
    DWORD dwAttackTime;             /* Microseconds         */
    DWORD dwFadeLevel;
    DWORD dwFadeTime;               /* Microseconds         */
} DIENVELOPE, *LPDIENVELOPE;
typedef const DIENVELOPE *LPCDIENVELOPE;

typedef struct DIEFFECT {
    DWORD dwSize;                   /* sizeof(DIEFFECT)     */
    DWORD dwFlags;                  /* DIEFF_*              */
    DWORD dwDuration;               /* Microseconds         */
    DWORD dwSamplePeriod;           /* Microseconds         */
    DWORD dwGain;
    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
    DWORD cAxes;                    /* Number of axes       */
    LPDWORD rgdwAxes;               /* Array of axes        */
    LPLONG rglDirection;            /* Array of directions  */
    LPDIENVELOPE lpEnvelope;        /* Optional             */
    DWORD cbTypeSpecificParams;     /* Size of params       */
    LPVOID lpvTypeSpecificParams;   /* Pointer to params    */
} DIEFFECT, *LPDIEFFECT;
typedef const DIEFFECT *LPCDIEFFECT;

#define DIEFF_OBJECTIDS             0x00000001
#define DIEFF_OBJECTOFFSETS         0x00000002
#define DIEFF_CARTESIAN             0x00000010
#define DIEFF_POLAR                 0x00000020
#define DIEFF_SPHERICAL             0x00000040

#define DIEP_DURATION               0x00000001
#define DIEP_SAMPLEPERIOD           0x00000002
#define DIEP_GAIN                   0x00000004
#define DIEP_TRIGGERBUTTON          0x00000008
#define DIEP_TRIGGERREPEATINTERVAL  0x00000010
#define DIEP_AXES                   0x00000020
#define DIEP_DIRECTION              0x00000040
#define DIEP_ENVELOPE               0x00000080
#define DIEP_TYPESPECIFICPARAMS     0x00000100
#define DIEP_ALLPARAMS              0x000001FF
#define DIEP_START                  0x20000000
#define DIEP_NORESTART              0x40000000
#define DIEP_NODOWNLOAD             0x80000000
#define DIEB_NOTRIGGER              0xFFFFFFFF

#define DIES_SOLO                   0x00000001
#define DIES_NODOWNLOAD             0x80000000

#define DIEGES_PLAYING              0x00000001
#define DIEGES_EMULATED             0x00000002

typedef struct DIEFFESCAPE {
    DWORD   dwSize;
    DWORD   dwCommand;
    LPVOID  lpvInBuffer;
    DWORD   cbInBuffer;
    LPVOID  lpvOutBuffer;
    DWORD   cbOutBuffer;
} DIEFFESCAPE, *LPDIEFFESCAPE;

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputEffect

DECLARE_INTERFACE_(IDirectInputEffect, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputEffect methods ***/
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(GetEffectGuid)(THIS_ LPGUID) PURE;
    STDMETHOD(GetParameters)(THIS_ LPDIEFFECT,DWORD) PURE;
    STDMETHOD(SetParameters)(THIS_ LPCDIEFFECT,DWORD) PURE;
    STDMETHOD(Start)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Stop)(THIS) PURE;
    STDMETHOD(GetEffectStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(Download)(THIS) PURE;
    STDMETHOD(Unload)(THIS) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
};

typedef struct IDirectInputEffect *LPDIRECTINPUTEFFECT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputEffect_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputEffect_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputEffect_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputEffect_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputEffect_GetEffectGuid(p,a) (p)->lpVtbl->GetEffectGuid(p,a)
#define IDirectInputEffect_GetParameters(p,a,b) (p)->lpVtbl->GetParameters(p,a,b)
#define IDirectInputEffect_SetParameters(p,a,b) (p)->lpVtbl->SetParameters(p,a,b)
#define IDirectInputEffect_Start(p,a,b) (p)->lpVtbl->Start(p,a,b)
#define IDirectInputEffect_Stop(p) (p)->lpVtbl->Stop(p)
#define IDirectInputEffect_GetEffectStatus(p,a) (p)->lpVtbl->GetEffectStatus(p,a)
#define IDirectInputEffect_Download(p) (p)->lpVtbl->Download(p)
#define IDirectInputEffect_Unload(p) (p)->lpVtbl->Unload(p)
#define IDirectInputEffect_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#else
#define IDirectInputEffect_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputEffect_AddRef(p) (p)->AddRef()
#define IDirectInputEffect_Release(p) (p)->Release()
#define IDirectInputEffect_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputEffect_GetEffectGuid(p,a) (p)->GetEffectGuid(a)
#define IDirectInputEffect_GetParameters(p,a,b) (p)->GetParameters(a,b)
#define IDirectInputEffect_SetParameters(p,a,b) (p)->SetParameters(a,b)
#define IDirectInputEffect_Start(p,a,b) (p)->Start(a,b)
#define IDirectInputEffect_Stop(p) (p)->Stop()
#define IDirectInputEffect_GetEffectStatus(p,a) (p)->GetEffectStatus(a)
#define IDirectInputEffect_Download(p) (p)->Download()
#define IDirectInputEffect_Unload(p) (p)->Unload()
#define IDirectInputEffect_Escape(p,a) (p)->Escape(a)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0500 */

/****************************************************************************
 *
 *      IDirectInputDevice
 *
 ****************************************************************************/

#define DIDEVTYPE_DEVICE    1
#define DIDEVTYPE_MOUSE     2
#define DIDEVTYPE_KEYBOARD  3
#define DIDEVTYPE_JOYSTICK  4
#define DIDEVTYPE_HID       0x00010000

#define DIDEVTYPEMOUSE_UNKNOWN          1
#define DIDEVTYPEMOUSE_TRADITIONAL      2
#define DIDEVTYPEMOUSE_FINGERSTICK      3
#define DIDEVTYPEMOUSE_TOUCHPAD         4
#define DIDEVTYPEMOUSE_TRACKBALL        5

#define DIDEVTYPEKEYBOARD_UNKNOWN       0
#define DIDEVTYPEKEYBOARD_PCXT          1
#define DIDEVTYPEKEYBOARD_OLIVETTI      2
#define DIDEVTYPEKEYBOARD_PCAT          3
#define DIDEVTYPEKEYBOARD_PCENH         4
#define DIDEVTYPEKEYBOARD_NOKIA1050     5
#define DIDEVTYPEKEYBOARD_NOKIA9140     6
#define DIDEVTYPEKEYBOARD_NEC98         7
#define DIDEVTYPEKEYBOARD_NEC98LAPTOP   8
#define DIDEVTYPEKEYBOARD_NEC98106      9
#define DIDEVTYPEKEYBOARD_JAPAN106     10
#define DIDEVTYPEKEYBOARD_JAPANAX      11
#define DIDEVTYPEKEYBOARD_J3100        12

#define DIDEVTYPEJOYSTICK_UNKNOWN       1
#define DIDEVTYPEJOYSTICK_TRADITIONAL   2
#define DIDEVTYPEJOYSTICK_FLIGHTSTICK   3
#define DIDEVTYPEJOYSTICK_GAMEPAD       4
#define DIDEVTYPEJOYSTICK_RUDDER        5
#define DIDEVTYPEJOYSTICK_WHEEL         6
#define DIDEVTYPEJOYSTICK_HEADTRACKER   7

#define GET_DIDEVICE_TYPE(dwDevType)    LOBYTE(dwDevType)
#define GET_DIDEVICE_SUBTYPE(dwDevType) HIBYTE(dwDevType)

#if(DIRECTINPUT_VERSION >= 0x0500)
/* This structure is defined for DirectX 3.0 compatibility */

typedef struct DIDEVCAPS_DX3 {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwDevType;
    DWORD   dwAxes;
    DWORD   dwButtons;
    DWORD   dwPOVs;
} DIDEVCAPS_DX3, *LPDIDEVCAPS_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVCAPS {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwDevType;
    DWORD   dwAxes;
    DWORD   dwButtons;
    DWORD   dwPOVs;
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFSamplePeriod;
    DWORD   dwFFMinTimeResolution;
    DWORD   dwFirmwareRevision;
    DWORD   dwHardwareRevision;
    DWORD   dwFFDriverVersion;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVCAPS, *LPDIDEVCAPS;

#define DIDC_ATTACHED           0x00000001
#define DIDC_POLLEDDEVICE       0x00000002
#define DIDC_EMULATED           0x00000004
#define DIDC_POLLEDDATAFORMAT   0x00000008
#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIDC_FORCEFEEDBACK      0x00000100
#define DIDC_FFATTACK           0x00000200
#define DIDC_FFFADE             0x00000400
#define DIDC_SATURATION         0x00000800
#define DIDC_POSNEGCOEFFICIENTS 0x00001000
#define DIDC_POSNEGSATURATION   0x00002000
#define DIDC_DEADBAND           0x00004000
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

#define DIDFT_ALL           0x00000000

#define DIDFT_RELAXIS       0x00000001
#define DIDFT_ABSAXIS       0x00000002
#define DIDFT_AXIS          0x00000003

#define DIDFT_PSHBUTTON     0x00000004
#define DIDFT_TGLBUTTON     0x00000008
#define DIDFT_BUTTON        0x0000000C

#define DIDFT_POV           0x00000010

#define DIDFT_COLLECTION    0x00000040
#define DIDFT_NODATA        0x00000080

#define DIDFT_ANYINSTANCE   0x00FFFF00
#define DIDFT_INSTANCEMASK  DIDFT_ANYINSTANCE
#define DIDFT_MAKEINSTANCE(n) ((WORD)(n) << 8)
#define DIDFT_GETTYPE(n)     LOBYTE(n)
#define DIDFT_GETINSTANCE(n) LOWORD((n) >> 8)
#define DIDFT_FFACTUATOR        0x01000000
#define DIDFT_FFEFFECTTRIGGER   0x02000000

#define DIDFT_ENUMCOLLECTION(n) ((WORD)(n) << 8)
#define DIDFT_NOCOLLECTION      0x00FFFF00


#ifndef DIJ_RINGZERO

typedef struct _DIOBJECTDATAFORMAT {
    const GUID *pguid;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
} DIOBJECTDATAFORMAT, *LPDIOBJECTDATAFORMAT;
typedef const DIOBJECTDATAFORMAT *LPCDIOBJECTDATAFORMAT;

typedef struct _DIDATAFORMAT {
    DWORD   dwSize;
    DWORD   dwObjSize;
    DWORD   dwFlags;
    DWORD   dwDataSize;
    DWORD   dwNumObjs;
    LPDIOBJECTDATAFORMAT rgodf;
} DIDATAFORMAT, *LPDIDATAFORMAT;
typedef const DIDATAFORMAT *LPCDIDATAFORMAT;

#define DIDF_ABSAXIS            0x00000001
#define DIDF_RELAXIS            0x00000002

extern const DIDATAFORMAT c_dfDIMouse;
extern const DIDATAFORMAT c_dfDIKeyboard;
extern const DIDATAFORMAT c_dfDIJoystick;
extern const DIDATAFORMAT c_dfDIJoystick2;

#if(DIRECTINPUT_VERSION >= 0x0500)
/* These structures are defined for DirectX 3.0 compatibility */

typedef struct DIDEVICEOBJECTINSTANCE_DX3A {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    CHAR    tszName[MAX_PATH];
} DIDEVICEOBJECTINSTANCE_DX3A, *LPDIDEVICEOBJECTINSTANCE_DX3A;
typedef struct DIDEVICEOBJECTINSTANCE_DX3W {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    WCHAR   tszName[MAX_PATH];
} DIDEVICEOBJECTINSTANCE_DX3W, *LPDIDEVICEOBJECTINSTANCE_DX3W;
#ifdef UNICODE
typedef DIDEVICEOBJECTINSTANCE_DX3W DIDEVICEOBJECTINSTANCE_DX3;
typedef LPDIDEVICEOBJECTINSTANCE_DX3W LPDIDEVICEOBJECTINSTANCE_DX3;
#else
typedef DIDEVICEOBJECTINSTANCE_DX3A DIDEVICEOBJECTINSTANCE_DX3;
typedef LPDIDEVICEOBJECTINSTANCE_DX3A LPDIDEVICEOBJECTINSTANCE_DX3;
#endif // UNICODE
typedef const DIDEVICEOBJECTINSTANCE_DX3A *LPCDIDEVICEOBJECTINSTANCE_DX3A;
typedef const DIDEVICEOBJECTINSTANCE_DX3W *LPCDIDEVICEOBJECTINSTANCE_DX3W;
typedef const DIDEVICEOBJECTINSTANCE_DX3  *LPCDIDEVICEOBJECTINSTANCE_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVICEOBJECTINSTANCEA {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    CHAR    tszName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
    WORD    wCollectionNumber;
    WORD    wDesignatorIndex;
    WORD    wUsagePage;
    WORD    wUsage;
    DWORD   dwDimension;
    WORD    wExponent;
    WORD    wReserved;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEOBJECTINSTANCEA, *LPDIDEVICEOBJECTINSTANCEA;
typedef struct DIDEVICEOBJECTINSTANCEW {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    WCHAR   tszName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
    WORD    wCollectionNumber;
    WORD    wDesignatorIndex;
    WORD    wUsagePage;
    WORD    wUsage;
    DWORD   dwDimension;
    WORD    wExponent;
    WORD    wReserved;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEOBJECTINSTANCEW, *LPDIDEVICEOBJECTINSTANCEW;
#ifdef UNICODE
typedef DIDEVICEOBJECTINSTANCEW DIDEVICEOBJECTINSTANCE;
typedef LPDIDEVICEOBJECTINSTANCEW LPDIDEVICEOBJECTINSTANCE;
#else
typedef DIDEVICEOBJECTINSTANCEA DIDEVICEOBJECTINSTANCE;
typedef LPDIDEVICEOBJECTINSTANCEA LPDIDEVICEOBJECTINSTANCE;
#endif // UNICODE
typedef const DIDEVICEOBJECTINSTANCEA *LPCDIDEVICEOBJECTINSTANCEA;
typedef const DIDEVICEOBJECTINSTANCEW *LPCDIDEVICEOBJECTINSTANCEW;
typedef const DIDEVICEOBJECTINSTANCE  *LPCDIDEVICEOBJECTINSTANCE;

typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKA)(LPCDIDEVICEOBJECTINSTANCEA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKW)(LPCDIDEVICEOBJECTINSTANCEW, LPVOID);
#ifdef UNICODE
#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKW
#else
#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKA
#endif // !UNICODE

#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIDOI_FFACTUATOR        0x00000001
#define DIDOI_FFEFFECTTRIGGER   0x00000002
#define DIDOI_POLLED            0x00008000
#define DIDOI_ASPECTPOSITION    0x00000100
#define DIDOI_ASPECTVELOCITY    0x00000200
#define DIDOI_ASPECTACCEL       0x00000300
#define DIDOI_ASPECTFORCE       0x00000400
#define DIDOI_ASPECTMASK        0x00000F00
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIPROPHEADER {
    DWORD   dwSize;
    DWORD   dwHeaderSize;
    DWORD   dwObj;
    DWORD   dwHow;
} DIPROPHEADER, *LPDIPROPHEADER;
typedef const DIPROPHEADER *LPCDIPROPHEADER;

#define DIPH_DEVICE             0
#define DIPH_BYOFFSET           1
#define DIPH_BYID               2

typedef struct DIPROPDWORD {
    DIPROPHEADER diph;
    DWORD   dwData;
} DIPROPDWORD, *LPDIPROPDWORD;
typedef const DIPROPDWORD *LPCDIPROPDWORD;

typedef struct DIPROPRANGE {
    DIPROPHEADER diph;
    LONG    lMin;
    LONG    lMax;
} DIPROPRANGE, *LPDIPROPRANGE;
typedef const DIPROPRANGE *LPCDIPROPRANGE;

#define DIPROPRANGE_NOMIN       ((LONG)0x80000000)
#define DIPROPRANGE_NOMAX       ((LONG)0x7FFFFFFF)

#ifdef __cplusplus
#define MAKEDIPROP(prop)    (*(const GUID *)(prop))
#else
#define MAKEDIPROP(prop)    ((REFGUID)(prop))
#endif

#define DIPROP_BUFFERSIZE       MAKEDIPROP(1)

#define DIPROP_AXISMODE         MAKEDIPROP(2)

#define DIPROPAXISMODE_ABS      0
#define DIPROPAXISMODE_REL      1

#define DIPROP_GRANULARITY      MAKEDIPROP(3)

#define DIPROP_RANGE            MAKEDIPROP(4)

#define DIPROP_DEADZONE         MAKEDIPROP(5)

#define DIPROP_SATURATION       MAKEDIPROP(6)

#define DIPROP_FFGAIN           MAKEDIPROP(7)

#define DIPROP_FFLOAD           MAKEDIPROP(8)

#define DIPROP_AUTOCENTER       MAKEDIPROP(9)

#define DIPROPAUTOCENTER_OFF    0
#define DIPROPAUTOCENTER_ON     1

#define DIPROP_CALIBRATIONMODE  MAKEDIPROP(10)

#define DIPROPCALIBRATIONMODE_COOKED    0
#define DIPROPCALIBRATIONMODE_RAW       1

typedef struct DIDEVICEOBJECTDATA {
    DWORD   dwOfs;
    DWORD   dwData;
    DWORD   dwTimeStamp;
    DWORD   dwSequence;
} DIDEVICEOBJECTDATA, *LPDIDEVICEOBJECTDATA;
typedef const DIDEVICEOBJECTDATA *LPCDIDEVICEOBJECTDATA;

#define DIGDD_PEEK          0x00000001

#define DISEQUENCE_COMPARE(dwSequence1, cmp, dwSequence2) \
                        ((int)((dwSequence1) - (dwSequence2)) cmp 0)
#define DISCL_EXCLUSIVE     0x00000001
#define DISCL_NONEXCLUSIVE  0x00000002
#define DISCL_FOREGROUND    0x00000004
#define DISCL_BACKGROUND    0x00000008

#if(DIRECTINPUT_VERSION >= 0x0500)
/* These structures are defined for DirectX 3.0 compatibility */

typedef struct DIDEVICEINSTANCE_DX3A {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    CHAR    tszInstanceName[MAX_PATH];
    CHAR    tszProductName[MAX_PATH];
} DIDEVICEINSTANCE_DX3A, *LPDIDEVICEINSTANCE_DX3A;
typedef struct DIDEVICEINSTANCE_DX3W {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    WCHAR   tszInstanceName[MAX_PATH];
    WCHAR   tszProductName[MAX_PATH];
} DIDEVICEINSTANCE_DX3W, *LPDIDEVICEINSTANCE_DX3W;
#ifdef UNICODE
typedef DIDEVICEINSTANCE_DX3W DIDEVICEINSTANCE_DX3;
typedef LPDIDEVICEINSTANCE_DX3W LPDIDEVICEINSTANCE_DX3;
#else
typedef DIDEVICEINSTANCE_DX3A DIDEVICEINSTANCE_DX3;
typedef LPDIDEVICEINSTANCE_DX3A LPDIDEVICEINSTANCE_DX3;
#endif // UNICODE
typedef const DIDEVICEINSTANCE_DX3A *LPCDIDEVICEINSTANCE_DX3A;
typedef const DIDEVICEINSTANCE_DX3W *LPCDIDEVICEINSTANCE_DX3W;
typedef const DIDEVICEINSTANCE_DX3  *LPCDIDEVICEINSTANCE_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVICEINSTANCEA {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    CHAR    tszInstanceName[MAX_PATH];
    CHAR    tszProductName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    GUID    guidFFDriver;
    WORD    wUsagePage;
    WORD    wUsage;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEINSTANCEA, *LPDIDEVICEINSTANCEA;
typedef struct DIDEVICEINSTANCEW {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    WCHAR   tszInstanceName[MAX_PATH];
    WCHAR   tszProductName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    GUID    guidFFDriver;
    WORD    wUsagePage;
    WORD    wUsage;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEINSTANCEW, *LPDIDEVICEINSTANCEW;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef LPDIDEVICEINSTANCEW LPDIDEVICEINSTANCE;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef LPDIDEVICEINSTANCEA LPDIDEVICEINSTANCE;
#endif // UNICODE
typedef const DIDEVICEINSTANCEA *LPCDIDEVICEINSTANCEA;
typedef const DIDEVICEINSTANCEW *LPCDIDEVICEINSTANCEW;
typedef const DIDEVICEINSTANCE  *LPCDIDEVICEINSTANCE;

#undef INTERFACE
#define INTERFACE IDirectInputDeviceW

DECLARE_INTERFACE_(IDirectInputDeviceW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceW methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
};

typedef struct IDirectInputDeviceW *LPDIRECTINPUTDEVICEW;

#undef INTERFACE
#define INTERFACE IDirectInputDeviceA

DECLARE_INTERFACE_(IDirectInputDeviceA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceA methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
};

typedef struct IDirectInputDeviceA *LPDIRECTINPUTDEVICEA;

#ifdef UNICODE
#define IID_IDirectInputDevice IID_IDirectInputDeviceW
#define IDirectInputDevice IDirectInputDeviceW
#define IDirectInputDeviceVtbl IDirectInputDeviceWVtbl
#else
#define IID_IDirectInputDevice IID_IDirectInputDeviceA
#define IDirectInputDevice IDirectInputDeviceA
#define IDirectInputDeviceVtbl IDirectInputDeviceAVtbl
#endif
typedef struct IDirectInputDevice *LPDIRECTINPUTDEVICE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#else
#define IDirectInputDevice_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice_AddRef(p) (p)->AddRef()
#define IDirectInputDevice_Release(p) (p)->Release()
#define IDirectInputDevice_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice_Acquire(p) (p)->Acquire()
#define IDirectInputDevice_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#endif

#endif /* DIJ_RINGZERO */


#if(DIRECTINPUT_VERSION >= 0x0500)

#define DISFFC_RESET            0x00000001
#define DISFFC_STOPALL          0x00000002
#define DISFFC_PAUSE            0x00000004
#define DISFFC_CONTINUE         0x00000008
#define DISFFC_SETACTUATORSON   0x00000010
#define DISFFC_SETACTUATORSOFF  0x00000020

#define DIGFFS_EMPTY            0x00000001
#define DIGFFS_STOPPED          0x00000002
#define DIGFFS_PAUSED           0x00000004
#define DIGFFS_ACTUATORSON      0x00000010
#define DIGFFS_ACTUATORSOFF     0x00000020
#define DIGFFS_POWERON          0x00000040
#define DIGFFS_POWEROFF         0x00000080
#define DIGFFS_SAFETYSWITCHON   0x00000100
#define DIGFFS_SAFETYSWITCHOFF  0x00000200
#define DIGFFS_USERFFSWITCHON   0x00000400
#define DIGFFS_USERFFSWITCHOFF  0x00000800
#define DIGFFS_DEVICELOST       0x80000000

#ifndef DIJ_RINGZERO

typedef struct DIEFFECTINFOA {
    DWORD   dwSize;
    GUID    guid;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    CHAR    tszName[MAX_PATH];
} DIEFFECTINFOA, *LPDIEFFECTINFOA;
typedef struct DIEFFECTINFOW {
    DWORD   dwSize;
    GUID    guid;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    WCHAR   tszName[MAX_PATH];
} DIEFFECTINFOW, *LPDIEFFECTINFOW;
#ifdef UNICODE
typedef DIEFFECTINFOW DIEFFECTINFO;
typedef LPDIEFFECTINFOW LPDIEFFECTINFO;
#else
typedef DIEFFECTINFOA DIEFFECTINFO;
typedef LPDIEFFECTINFOA LPDIEFFECTINFO;
#endif // UNICODE
typedef const DIEFFECTINFOA *LPCDIEFFECTINFOA;
typedef const DIEFFECTINFOW *LPCDIEFFECTINFOW;
typedef const DIEFFECTINFO  *LPCDIEFFECTINFO;

typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKA)(LPCDIEFFECTINFOA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKW)(LPCDIEFFECTINFOW, LPVOID);
#ifdef UNICODE
#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKW
#else
#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKA
#endif // !UNICODE
typedef BOOL (FAR PASCAL * LPDIENUMCREATEDEFFECTOBJECTSCALLBACK)(LPDIRECTINPUTEFFECT, LPVOID);

#undef INTERFACE
#define INTERFACE IDirectInputDevice2W

DECLARE_INTERFACE_(IDirectInputDevice2W, IDirectInputDeviceW)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceW methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;

    /*** IDirectInputDevice2W methods ***/
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
};

typedef struct IDirectInputDevice2W *LPDIRECTINPUTDEVICE2W;

#undef INTERFACE
#define INTERFACE IDirectInputDevice2A

DECLARE_INTERFACE_(IDirectInputDevice2A, IDirectInputDeviceA)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceA methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;

    /*** IDirectInputDevice2A methods ***/
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
};

typedef struct IDirectInputDevice2A *LPDIRECTINPUTDEVICE2A;

#ifdef UNICODE
#define IID_IDirectInputDevice2 IID_IDirectInputDevice2W
#define IDirectInputDevice2 IDirectInputDevice2W
#define IDirectInputDevice2Vtbl IDirectInputDevice2WVtbl
#else
#define IID_IDirectInputDevice2 IID_IDirectInputDevice2A
#define IDirectInputDevice2 IDirectInputDevice2A
#define IDirectInputDevice2Vtbl IDirectInputDevice2AVtbl
#endif
typedef struct IDirectInputDevice2 *LPDIRECTINPUTDEVICE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice2_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice2_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice2_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice2_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice2_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice2_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice2_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice2_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
#define IDirectInputDevice2_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#define IDirectInputDevice2_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#else
#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice2_AddRef(p) (p)->AddRef()
#define IDirectInputDevice2_Release(p) (p)->Release()
#define IDirectInputDevice2_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice2_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice2_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice2_Acquire(p) (p)->Acquire()
#define IDirectInputDevice2_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice2_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice2_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
#define IDirectInputDevice2_Escape(p,a) (p)->Escape(a)
#define IDirectInputDevice2_Poll(p) (p)->Poll()
#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0500 */

/****************************************************************************
 *
 *      Mouse
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

typedef struct _DIMOUSESTATE {
    LONG    lX;
    LONG    lY;
    LONG    lZ;
    BYTE    rgbButtons[4];
} DIMOUSESTATE, *LPDIMOUSESTATE;

#define DIMOFS_X        FIELD_OFFSET(DIMOUSESTATE, lX)
#define DIMOFS_Y        FIELD_OFFSET(DIMOUSESTATE, lY)
#define DIMOFS_Z        FIELD_OFFSET(DIMOUSESTATE, lZ)
#define DIMOFS_BUTTON0 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 0)
#define DIMOFS_BUTTON1 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 1)
#define DIMOFS_BUTTON2 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 2)
#define DIMOFS_BUTTON3 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 3)

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Keyboard
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

/****************************************************************************
 *
 *      DirectInput keyboard scan codes
 *
 ****************************************************************************/

#define DIK_ESCAPE          0x01
#define DIK_1               0x02
#define DIK_2               0x03
#define DIK_3               0x04
#define DIK_4               0x05
#define DIK_5               0x06
#define DIK_6               0x07
#define DIK_7               0x08
#define DIK_8               0x09
#define DIK_9               0x0A
#define DIK_0               0x0B
#define DIK_MINUS           0x0C    /* - on main keyboard */
#define DIK_EQUALS          0x0D
#define DIK_BACK            0x0E    /* backspace */
#define DIK_TAB             0x0F
#define DIK_Q               0x10
#define DIK_W               0x11
#define DIK_E               0x12
#define DIK_R               0x13
#define DIK_T               0x14
#define DIK_Y               0x15
#define DIK_U               0x16
#define DIK_I               0x17
#define DIK_O               0x18
#define DIK_P               0x19
#define DIK_LBRACKET        0x1A
#define DIK_RBRACKET        0x1B
#define DIK_RETURN          0x1C    /* Enter on main keyboard */
#define DIK_LCONTROL        0x1D
#define DIK_A               0x1E
#define DIK_S               0x1F
#define DIK_D               0x20
#define DIK_F               0x21
#define DIK_G               0x22
#define DIK_H               0x23
#define DIK_J               0x24
#define DIK_K               0x25
#define DIK_L               0x26
#define DIK_SEMICOLON       0x27
#define DIK_APOSTROPHE      0x28
#define DIK_GRAVE           0x29    /* accent grave */
#define DIK_LSHIFT          0x2A
#define DIK_BACKSLASH       0x2B
#define DIK_Z               0x2C
#define DIK_X               0x2D
#define DIK_C               0x2E
#define DIK_V               0x2F
#define DIK_B               0x30
#define DIK_N               0x31
#define DIK_M               0x32
#define DIK_COMMA           0x33
#define DIK_PERIOD          0x34    /* . on main keyboard */
#define DIK_SLASH           0x35    /* / on main keyboard */
#define DIK_RSHIFT          0x36
#define DIK_MULTIPLY        0x37    /* * on numeric keypad */
#define DIK_LMENU           0x38    /* left Alt */
#define DIK_SPACE           0x39
#define DIK_CAPITAL         0x3A
#define DIK_F1              0x3B
#define DIK_F2              0x3C
#define DIK_F3              0x3D
#define DIK_F4              0x3E
#define DIK_F5              0x3F
#define DIK_F6              0x40
#define DIK_F7              0x41
#define DIK_F8              0x42
#define DIK_F9              0x43
#define DIK_F10             0x44
#define DIK_NUMLOCK         0x45
#define DIK_SCROLL          0x46    /* Scroll Lock */
#define DIK_NUMPAD7         0x47
#define DIK_NUMPAD8         0x48
#define DIK_NUMPAD9         0x49
#define DIK_SUBTRACT        0x4A    /* - on numeric keypad */
#define DIK_NUMPAD4         0x4B
#define DIK_NUMPAD5         0x4C
#define DIK_NUMPAD6         0x4D
#define DIK_ADD             0x4E    /* + on numeric keypad */
#define DIK_NUMPAD1         0x4F
#define DIK_NUMPAD2         0x50
#define DIK_NUMPAD3         0x51
#define DIK_NUMPAD0         0x52
#define DIK_DECIMAL         0x53    /* . on numeric keypad */
#define DIK_F11             0x57
#define DIK_F12             0x58

#define DIK_F13             0x64    /*                     (NEC PC98) */
#define DIK_F14             0x65    /*                     (NEC PC98) */
#define DIK_F15             0x66    /*                     (NEC PC98) */

#define DIK_KANA            0x70    /* (Japanese keyboard)            */
#define DIK_CONVERT         0x79    /* (Japanese keyboard)            */
#define DIK_NOCONVERT       0x7B    /* (Japanese keyboard)            */
#define DIK_YEN             0x7D    /* (Japanese keyboard)            */
#define DIK_NUMPADEQUALS    0x8D    /* = on numeric keypad (NEC PC98) */
#define DIK_CIRCUMFLEX      0x90    /* (Japanese keyboard)            */
#define DIK_AT              0x91    /*                     (NEC PC98) */
#define DIK_COLON           0x92    /*                     (NEC PC98) */
#define DIK_UNDERLINE       0x93    /*                     (NEC PC98) */
#define DIK_KANJI           0x94    /* (Japanese keyboard)            */
#define DIK_STOP            0x95    /*                     (NEC PC98) */
#define DIK_AX              0x96    /*                     (Japan AX) */
#define DIK_UNLABELED       0x97    /*                        (J3100) */
#define DIK_NUMPADENTER     0x9C    /* Enter on numeric keypad */
#define DIK_RCONTROL        0x9D
#define DIK_NUMPADCOMMA     0xB3    /* , on numeric keypad (NEC PC98) */
#define DIK_DIVIDE          0xB5    /* / on numeric keypad */
#define DIK_SYSRQ           0xB7
#define DIK_RMENU           0xB8    /* right Alt */
#define DIK_HOME            0xC7    /* Home on arrow keypad */
#define DIK_UP              0xC8    /* UpArrow on arrow keypad */
#define DIK_PRIOR           0xC9    /* PgUp on arrow keypad */
#define DIK_LEFT            0xCB    /* LeftArrow on arrow keypad */
#define DIK_RIGHT           0xCD    /* RightArrow on arrow keypad */
#define DIK_END             0xCF    /* End on arrow keypad */
#define DIK_DOWN            0xD0    /* DownArrow on arrow keypad */
#define DIK_NEXT            0xD1    /* PgDn on arrow keypad */
#define DIK_INSERT          0xD2    /* Insert on arrow keypad */
#define DIK_DELETE          0xD3    /* Delete on arrow keypad */
#define DIK_LWIN            0xDB    /* Left Windows key */
#define DIK_RWIN            0xDC    /* Right Windows key */
#define DIK_APPS            0xDD    /* AppMenu key */

/*
 *  Alternate names for keys, to facilitate transition from DOS.
 */
#define DIK_BACKSPACE       DIK_BACK            /* backspace */
#define DIK_NUMPADSTAR      DIK_MULTIPLY        /* * on numeric keypad */
#define DIK_LALT            DIK_LMENU           /* left Alt */
#define DIK_CAPSLOCK        DIK_CAPITAL         /* CapsLock */
#define DIK_NUMPADMINUS     DIK_SUBTRACT        /* - on numeric keypad */
#define DIK_NUMPADPLUS      DIK_ADD             /* + on numeric keypad */
#define DIK_NUMPADPERIOD    DIK_DECIMAL         /* . on numeric keypad */
#define DIK_NUMPADSLASH     DIK_DIVIDE          /* / on numeric keypad */
#define DIK_RALT            DIK_RMENU           /* right Alt */
#define DIK_UPARROW         DIK_UP              /* UpArrow on arrow keypad */
#define DIK_PGUP            DIK_PRIOR           /* PgUp on arrow keypad */
#define DIK_LEFTARROW       DIK_LEFT            /* LeftArrow on arrow keypad */
#define DIK_RIGHTARROW      DIK_RIGHT           /* RightArrow on arrow keypad */
#define DIK_DOWNARROW       DIK_DOWN            /* DownArrow on arrow keypad */
#define DIK_PGDN            DIK_NEXT            /* PgDn on arrow keypad */

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Joystick
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

typedef struct DIJOYSTATE {
    LONG    lX;                     /* x-axis position              */
    LONG    lY;                     /* y-axis position              */
    LONG    lZ;                     /* z-axis position              */
    LONG    lRx;                    /* x-axis rotation              */
    LONG    lRy;                    /* y-axis rotation              */
    LONG    lRz;                    /* z-axis rotation              */
    LONG    rglSlider[2];           /* extra axes positions         */
    DWORD   rgdwPOV[4];             /* POV directions               */
    BYTE    rgbButtons[32];         /* 32 buttons                   */
} DIJOYSTATE, *LPDIJOYSTATE;

typedef struct DIJOYSTATE2 {
    LONG    lX;                     /* x-axis position              */
    LONG    lY;                     /* y-axis position              */
    LONG    lZ;                     /* z-axis position              */
    LONG    lRx;                    /* x-axis rotation              */
    LONG    lRy;                    /* y-axis rotation              */
    LONG    lRz;                    /* z-axis rotation              */
    LONG    rglSlider[2];           /* extra axes positions         */
    DWORD   rgdwPOV[4];             /* POV directions               */
    BYTE    rgbButtons[128];        /* 128 buttons                  */
    LONG    lVX;                    /* x-axis velocity              */
    LONG    lVY;                    /* y-axis velocity              */
    LONG    lVZ;                    /* z-axis velocity              */
    LONG    lVRx;                   /* x-axis angular velocity      */
    LONG    lVRy;                   /* y-axis angular velocity      */
    LONG    lVRz;                   /* z-axis angular velocity      */
    LONG    rglVSlider[2];          /* extra axes velocities        */
    LONG    lAX;                    /* x-axis acceleration          */
    LONG    lAY;                    /* y-axis acceleration          */
    LONG    lAZ;                    /* z-axis acceleration          */
    LONG    lARx;                   /* x-axis angular acceleration  */
    LONG    lARy;                   /* y-axis angular acceleration  */
    LONG    lARz;                   /* z-axis angular acceleration  */
    LONG    rglASlider[2];          /* extra axes accelerations     */
    LONG    lFX;                    /* x-axis force                 */
    LONG    lFY;                    /* y-axis force                 */
    LONG    lFZ;                    /* z-axis force                 */
    LONG    lFRx;                   /* x-axis torque                */
    LONG    lFRy;                   /* y-axis torque                */
    LONG    lFRz;                   /* z-axis torque                */
    LONG    rglFSlider[2];          /* extra axes forces            */
} DIJOYSTATE2, *LPDIJOYSTATE2;

#define DIJOFS_X            FIELD_OFFSET(DIJOYSTATE, lX)
#define DIJOFS_Y            FIELD_OFFSET(DIJOYSTATE, lY)
#define DIJOFS_Z            FIELD_OFFSET(DIJOYSTATE, lZ)
#define DIJOFS_RX           FIELD_OFFSET(DIJOYSTATE, lRx)
#define DIJOFS_RY           FIELD_OFFSET(DIJOYSTATE, lRy)
#define DIJOFS_RZ           FIELD_OFFSET(DIJOYSTATE, lRz)
#define DIJOFS_SLIDER(n)   (FIELD_OFFSET(DIJOYSTATE, rglSlider) + \
                                                        (n) * sizeof(LONG))
#define DIJOFS_POV(n)      (FIELD_OFFSET(DIJOYSTATE, rgdwPOV) + \
                                                        (n) * sizeof(DWORD))
#define DIJOFS_BUTTON(n)   (FIELD_OFFSET(DIJOYSTATE, rgbButtons) + (n))
#define DIJOFS_BUTTON0      DIJOFS_BUTTON(0)
#define DIJOFS_BUTTON1      DIJOFS_BUTTON(1)
#define DIJOFS_BUTTON2      DIJOFS_BUTTON(2)
#define DIJOFS_BUTTON3      DIJOFS_BUTTON(3)
#define DIJOFS_BUTTON4      DIJOFS_BUTTON(4)
#define DIJOFS_BUTTON5      DIJOFS_BUTTON(5)
#define DIJOFS_BUTTON6      DIJOFS_BUTTON(6)
#define DIJOFS_BUTTON7      DIJOFS_BUTTON(7)
#define DIJOFS_BUTTON8      DIJOFS_BUTTON(8)
#define DIJOFS_BUTTON9      DIJOFS_BUTTON(9)
#define DIJOFS_BUTTON10     DIJOFS_BUTTON(10)
#define DIJOFS_BUTTON11     DIJOFS_BUTTON(11)
#define DIJOFS_BUTTON12     DIJOFS_BUTTON(12)
#define DIJOFS_BUTTON13     DIJOFS_BUTTON(13)
#define DIJOFS_BUTTON14     DIJOFS_BUTTON(14)
#define DIJOFS_BUTTON15     DIJOFS_BUTTON(15)
#define DIJOFS_BUTTON16     DIJOFS_BUTTON(16)
#define DIJOFS_BUTTON17     DIJOFS_BUTTON(17)
#define DIJOFS_BUTTON18     DIJOFS_BUTTON(18)
#define DIJOFS_BUTTON19     DIJOFS_BUTTON(19)
#define DIJOFS_BUTTON20     DIJOFS_BUTTON(20)
#define DIJOFS_BUTTON21     DIJOFS_BUTTON(21)
#define DIJOFS_BUTTON22     DIJOFS_BUTTON(22)
#define DIJOFS_BUTTON23     DIJOFS_BUTTON(23)
#define DIJOFS_BUTTON24     DIJOFS_BUTTON(24)
#define DIJOFS_BUTTON25     DIJOFS_BUTTON(25)
#define DIJOFS_BUTTON26     DIJOFS_BUTTON(26)
#define DIJOFS_BUTTON27     DIJOFS_BUTTON(27)
#define DIJOFS_BUTTON28     DIJOFS_BUTTON(28)
#define DIJOFS_BUTTON29     DIJOFS_BUTTON(29)
#define DIJOFS_BUTTON30     DIJOFS_BUTTON(30)
#define DIJOFS_BUTTON31     DIJOFS_BUTTON(31)


#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *  IDirectInput
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

#define DIENUM_STOP             0
#define DIENUM_CONTINUE         1

typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKA)(LPCDIDEVICEINSTANCEA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKW)(LPCDIDEVICEINSTANCEW, LPVOID);
#ifdef UNICODE
#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKW
#else
#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKA
#endif // !UNICODE

#define DIEDFL_ALLDEVICES       0x00000000
#define DIEDFL_ATTACHEDONLY     0x00000001
#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIEDFL_FORCEFEEDBACK    0x00000100
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

#undef INTERFACE
#define INTERFACE IDirectInputW

DECLARE_INTERFACE_(IDirectInputW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputW methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
};

typedef struct IDirectInputW *LPDIRECTINPUTW;

#undef INTERFACE
#define INTERFACE IDirectInputA

DECLARE_INTERFACE_(IDirectInputA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputA methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
};

typedef struct IDirectInputA *LPDIRECTINPUTA;

#ifdef UNICODE
#define IID_IDirectInput IID_IDirectInputW
#define IDirectInput IDirectInputW
#define IDirectInputVtbl IDirectInputWVtbl
#else
#define IID_IDirectInput IID_IDirectInputA
#define IDirectInput IDirectInputA
#define IDirectInputVtbl IDirectInputAVtbl
#endif
typedef struct IDirectInput *LPDIRECTINPUT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#else
#define IDirectInput_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput_AddRef(p) (p)->AddRef()
#define IDirectInput_Release(p) (p)->Release()
#define IDirectInput_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput_Initialize(p,a,b) (p)->Initialize(a,b)
#endif

#undef INTERFACE
#define INTERFACE IDirectInput2W

DECLARE_INTERFACE_(IDirectInput2W, IDirectInputW)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputW methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;

    /*** IDirectInput2W methods ***/
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;
};

typedef struct IDirectInput2W *LPDIRECTINPUT2W;

#undef INTERFACE
#define INTERFACE IDirectInput2A

DECLARE_INTERFACE_(IDirectInput2A, IDirectInputA)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputA methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;

    /*** IDirectInput2A methods ***/
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;
};

typedef struct IDirectInput2A *LPDIRECTINPUT2A;

#ifdef UNICODE
#define IID_IDirectInput2 IID_IDirectInput2W
#define IDirectInput2 IDirectInput2W
#define IDirectInput2Vtbl IDirectInput2WVtbl
#else
#define IID_IDirectInput2 IID_IDirectInput2A
#define IDirectInput2 IDirectInput2A
#define IDirectInput2Vtbl IDirectInput2AVtbl
#endif
typedef struct IDirectInput2 *LPDIRECTINPUT2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput2_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput2_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput2_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput2_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirectInput2_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
#else
#define IDirectInput2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput2_AddRef(p) (p)->AddRef()
#define IDirectInput2_Release(p) (p)->Release()
#define IDirectInput2_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput2_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput2_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirectInput2_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
#endif

extern HRESULT WINAPI DirectInputCreateA(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *ppDI, LPUNKNOWN punkOuter);
extern HRESULT WINAPI DirectInputCreateW(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTW *ppDI, LPUNKNOWN punkOuter);
#ifdef UNICODE
#define DirectInputCreate  DirectInputCreateW
#else
#define DirectInputCreate  DirectInputCreateA
#endif // !UNICODE

#endif /* DIJ_RINGZERO */


/****************************************************************************
 *
 *  Return Codes
 *
 ****************************************************************************/

/*
 *  The operation completed successfully.
 */
#define DI_OK                           S_OK

/*
 *  The device exists but is not currently attached.
 */
#define DI_NOTATTACHED                  S_FALSE

/*
 *  The device buffer overflowed.  Some input was lost.
 */
#define DI_BUFFEROVERFLOW               S_FALSE

/*
 *  The change in device properties had no effect.
 */
#define DI_PROPNOEFFECT                 S_FALSE

/*
 *  The operation had no effect.
 */
#define DI_NOEFFECT                     S_FALSE

/*
 *  The device is a polled device.  As a result, device buffering
 *  will not collect any data and event notifications will not be
 *  signalled until GetDeviceState is called.
 */
#define DI_POLLEDDEVICE                 ((HRESULT)0x00000002L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but the effect was not
 *  downloaded because the device is not exclusively acquired
 *  or because the DIEP_NODOWNLOAD flag was passed.
 */
#define DI_DOWNLOADSKIPPED              ((HRESULT)0x00000003L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but in order to change
 *  the parameters, the effect needed to be restarted.
 */
#define DI_EFFECTRESTARTED              ((HRESULT)0x00000004L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but some of them were
 *  beyond the capabilities of the device and were truncated.
 */
#define DI_TRUNCATED                    ((HRESULT)0x00000008L)

/*
 *  Equal to DI_EFFECTRESTARTED | DI_TRUNCATED.
 */
#define DI_TRUNCATEDANDRESTARTED        ((HRESULT)0x0000000CL)

/*
 *  The application requires a newer version of DirectInput.
 */
#define DIERR_OLDDIRECTINPUTVERSION     \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_OLD_WIN_VERSION)

/*
 *  The application was written for an unsupported prerelease version
 *  of DirectInput.
 */
#define DIERR_BETADIRECTINPUTVERSION    \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_RMODE_APP)

/*
 *  The object could not be created due to an incompatible driver version
 *  or mismatched or incomplete driver components.
 */
#define DIERR_BADDRIVERVER              \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BAD_DRIVER_LEVEL)

/*
 * The device or device instance or effect is not registered with DirectInput.
 */
#define DIERR_DEVICENOTREG              REGDB_E_CLASSNOTREG

/*
 * The requested object does not exist.
 */
#define DIERR_NOTFOUND                  \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)

/*
 * The requested object does not exist.
 */
#define DIERR_OBJECTNOTFOUND            \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)

/*
 * An invalid parameter was passed to the returning function,
 * or the object was not in a state that admitted the function
 * to be called.
 */
#define DIERR_INVALIDPARAM              E_INVALIDARG

/*
 * The specified interface is not supported by the object
 */
#define DIERR_NOINTERFACE               E_NOINTERFACE

/*
 * An undetermined error occured inside the DInput subsystem
 */
#define DIERR_GENERIC                   E_FAIL

/*
 * The DInput subsystem couldn't allocate sufficient memory to complete the
 * caller's request.
 */
#define DIERR_OUTOFMEMORY               E_OUTOFMEMORY

/*
 * The function called is not supported at this time
 */
#define DIERR_UNSUPPORTED               E_NOTIMPL

/*
 * This object has not been initialized
 */
#define DIERR_NOTINITIALIZED            \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_READY)

/*
 * This object is already initialized
 */
#define DIERR_ALREADYINITIALIZED        \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_ALREADY_INITIALIZED)

/*
 * This object does not support aggregation
 */
#define DIERR_NOAGGREGATION             CLASS_E_NOAGGREGATION

/*
 * Another app has a higher priority level, preventing this call from
 * succeeding.
 */
#define DIERR_OTHERAPPHASPRIO           E_ACCESSDENIED

/*
 * Access to the device has been lost.  It must be re-acquired.
 */
#define DIERR_INPUTLOST                 \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_READ_FAULT)

/*
 * The operation cannot be performed while the device is acquired.
 */
#define DIERR_ACQUIRED                  \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BUSY)

/*
 * The operation cannot be performed unless the device is acquired.
 */
#define DIERR_NOTACQUIRED               \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_ACCESS)

/*
 * The specified property cannot be changed.
 */
#define DIERR_READONLY                  E_ACCESSDENIED

/*
 * The device already has an event notification associated with it.
 */
#define DIERR_HANDLEEXISTS              E_ACCESSDENIED

/*
 * Data is not yet available.
 */
#ifndef E_PENDING
#define E_PENDING                       0x80070007L
#endif

/*
 * Unable to IDirectInputJoyConfig_Acquire because the user
 * does not have sufficient privileges to change the joystick
 * configuration.
 */
#define DIERR_INSUFFICIENTPRIVS         0x80040200L

/*
 * The device is full.
 */
#define DIERR_DEVICEFULL                0x80040201L

/*
 * Not all the requested information fit into the buffer.
 */
#define DIERR_MOREDATA                  0x80040202L

/*
 * The effect is not downloaded.
 */
#define DIERR_NOTDOWNLOADED             0x80040203L

/*
 *  The device cannot be reinitialized because there are still effects
 *  attached to it.
 */
#define DIERR_HASEFFECTS                0x80040204L

/*
 *  The operation cannot be performed unless the device is acquired
 *  in DISCL_EXCLUSIVE mode.
 */
#define DIERR_NOTEXCLUSIVEACQUIRED      0x80040205L

/*
 *  The effect could not be downloaded because essential information
 *  is missing.  For example, no axes have been associated with the
 *  effect, or no type-specific information has been created.
 */
#define DIERR_INCOMPLETEEFFECT          0x80040206L

/*
 *  Attempted to read buffered device data from a device that is
 *  not buffered.
 */
#define DIERR_NOTBUFFERED               0x80040207L

/*
 *  An attempt was made to modify parameters of an effect while it is
 *  playing.  Not all hardware devices support altering the parameters
 *  of an effect while it is playing.
 */
#define DIERR_EFFECTPLAYING             0x80040208L

#ifdef __cplusplus
};
#endif

#endif  /* __DINPUT_INCLUDED__ */

/****************************************************************************
 *
 *  Definitions for non-IDirectInput (VJoyD) features defined more recently
 *  than the current sdk files
 *
 ****************************************************************************/

#ifdef _INC_MMSYSTEM
#ifndef MMNOJOY

#ifndef __VJOYDX_INCLUDED__
#define __VJOYDX_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Flag to indicate that the dwReserved2 field of the JOYINFOEX structure
 * contains mini-driver specific data to be passed by VJoyD to the mini-
 * driver instead of doing a poll.
 */
#define JOY_PASSDRIVERDATA          0x10000000l

/*
 * Informs the joystick driver that the configuration has been changed
 * and should be reloaded from the registery.
 * dwFlags is reserved and should be set to zero
 */
WINMMAPI MMRESULT WINAPI joyConfigChanged( DWORD dwFlags );

/*
 * Hardware Setting indicating that the device is a headtracker
 */
#define JOY_HWS_ISHEADTRACKER       0x02000000l

/*
 * Hardware Setting indicating that the VxD is used to replace
 * the standard analog polling
 */
#define JOY_HWS_ISGAMEPORTDRIVER    0x04000000l

/*
 * Hardware Setting indicating that the driver needs a standard
 * gameport in order to communicate with the device.
 */
#define JOY_HWS_ISANALOGPORTDRIVER  0x08000000l 

/*
 * Hardware Setting indicating that VJoyD should not load this 
 * driver, it will be loaded externally and will register with
 * VJoyD of it's own accord.
 */
#define JOY_HWS_AUTOLOAD            0x10000000l

/*
 * Hardware Setting indicating that the driver acquires any 
 * resources needed without needing a devnode through VJoyD.
 */
#define JOY_HWS_NODEVNODE           0x20000000l

/*
 * Hardware Setting indicating that the VxD can be used as
 * a port 201h emulator.
 */
#define JOY_HWS_ISGAMEPORTEMULATOR  0x40000000l


/*
 * Usage Setting indicating that the settings are volatile and
 * should be removed if still present on a reboot.
 */
#define JOY_US_VOLATILE             0x00000008L

#ifdef __cplusplus
};
#endif

#endif  /* __VJOYDX_INCLUDED__ */

#endif  /* not MMNOJOY */
#endif  /* _INC_MMSYSTEM */

/****************************************************************************
 *
 *  Definitions for non-IDirectInput (VJoyD) features defined more recently
 *  than the current ddk files
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

#ifdef _INC_MMDDK
#ifndef MMNOJOYDEV

#ifndef __VJOYDXD_INCLUDED__
#define __VJOYDXD_INCLUDED__
/*
 * Poll type in which the do_other field of the JOYOEMPOLLDATA
 * structure contains mini-driver specific data passed from an app.
 */
#define JOY_OEMPOLL_PASSDRIVERDATA  7

#endif  /* __VJOYDXD_INCLUDED__ */

#endif  /* not MMNOJOYDEV */
#endif  /* _INC_MMDDK */

#endif /* DIJ_RINGZERO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\d3dvec.inl ===
/****************************************************************** 
 *                                                                *
 *   D3DVec.inl                                                   *
 *                                                                *
 *   Float-valued 3D vector class for Direct3D.                   *
 *                                                                *
 *   Copyright (c) 1996-1998 Microsoft Corp. All rights reserved. *
 *                                                                *
 ******************************************************************/

#include <math.h>

// =====================================
// Constructors
// =====================================

inline
_D3DVECTOR::_D3DVECTOR(D3DVALUE f)
{
    x = y = z = f;
}

inline
_D3DVECTOR::_D3DVECTOR(D3DVALUE _x, D3DVALUE _y, D3DVALUE _z)
{
    x = _x; y = _y; z = _z;
}

inline
_D3DVECTOR::_D3DVECTOR(const D3DVALUE f[3])
{
    x = f[0]; y = f[1]; z = f[2];
}

// =====================================
// Access grants
// =====================================

inline const D3DVALUE&
_D3DVECTOR::operator[](int i) const
{
    return (&x)[i];
}

inline D3DVALUE&
_D3DVECTOR::operator[](int i)
{
    return (&x)[i];
}


// =====================================
// Assignment operators
// =====================================

inline _D3DVECTOR&
_D3DVECTOR::operator += (const _D3DVECTOR& v)
{
   x += v.x;   y += v.y;   z += v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator -= (const _D3DVECTOR& v)
{
   x -= v.x;   y -= v.y;   z -= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator *= (const _D3DVECTOR& v)
{
   x *= v.x;   y *= v.y;   z *= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator /= (const _D3DVECTOR& v)
{
   x /= v.x;   y /= v.y;   z /= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator *= (D3DVALUE s)
{
   x *= s;   y *= s;   z *= s;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator /= (D3DVALUE s)
{
   x /= s;   y /= s;   z /= s;
   return *this;
}

inline _D3DVECTOR
operator + (const _D3DVECTOR& v)
{
   return v;
}

inline _D3DVECTOR
operator - (const _D3DVECTOR& v)
{
   return _D3DVECTOR(-v.x, -v.y, -v.z);
}

inline _D3DVECTOR
operator + (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);
}

inline _D3DVECTOR
operator - (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z);
}

inline _D3DVECTOR
operator * (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x*v2.x, v1.y*v2.y, v1.z*v2.z);
}

inline _D3DVECTOR
operator / (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x/v2.x, v1.y/v2.y, v1.z/v2.z);
}

inline int
operator < (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1[0] < v2[0] && v1[1] < v2[1] && v1[2] < v2[2];
}

inline int
operator <= (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1[0] <= v2[0] && v1[1] <= v2[1] && v1[2] <= v2[2];
}

inline _D3DVECTOR
operator * (const _D3DVECTOR& v, D3DVALUE s)
{
   return _D3DVECTOR(s*v.x, s*v.y, s*v.z);
}

inline _D3DVECTOR
operator * (D3DVALUE s, const _D3DVECTOR& v)
{
   return _D3DVECTOR(s*v.x, s*v.y, s*v.z);
}

inline _D3DVECTOR
operator / (const _D3DVECTOR& v, D3DVALUE s)
{
   return _D3DVECTOR(v.x/s, v.y/s, v.z/s);
}

inline int
operator == (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1.x==v2.x && v1.y==v2.y && v1.z == v2.z;
}

inline D3DVALUE
Magnitude (const _D3DVECTOR& v)
{
   return (D3DVALUE) sqrt(SquareMagnitude(v));
}

inline D3DVALUE
SquareMagnitude (const _D3DVECTOR& v)
{
   return v.x*v.x + v.y*v.y + v.z*v.z;
}

inline _D3DVECTOR
Normalize (const _D3DVECTOR& v)
{
   return v / Magnitude(v);
}

inline D3DVALUE
Min (const _D3DVECTOR& v)
{
   D3DVALUE ret = v.x;
   if (v.y < ret) ret = v.y;
   if (v.z < ret) ret = v.z;
   return ret;
}

inline D3DVALUE
Max (const _D3DVECTOR& v)
{
   D3DVALUE ret = v.x;
   if (ret < v.y) ret = v.y;
   if (ret < v.z) ret = v.z;
   return ret;
}

inline _D3DVECTOR
Minimize (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR( v1[0] < v2[0] ? v1[0] : v2[0],
                   v1[1] < v2[1] ? v1[1] : v2[1],
                   v1[2] < v2[2] ? v1[2] : v2[2]);
}

inline _D3DVECTOR
Maximize (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR( v1[0] > v2[0] ? v1[0] : v2[0],
                   v1[1] > v2[1] ? v1[1] : v2[1],
                   v1[2] > v2[2] ? v1[2] : v2[2]);
}

inline D3DVALUE
DotProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1.x*v2.x + v1.y * v2.y + v1.z*v2.z;
}

inline _D3DVECTOR
CrossProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
	_D3DVECTOR result;

	result[0] = v1[1] * v2[2] - v1[2] * v2[1];
	result[1] = v1[2] * v2[0] - v1[0] * v2[2];
	result[2] = v1[0] * v2[1] - v1[1] * v2[0];

	return result;
}

inline _D3DMATRIX
operator* (const _D3DMATRIX& a, const _D3DMATRIX& b)
{
    _D3DMATRIX ret;
    for (int i=0; i<4; i++) {
        for (int j=0; j<4; j++) {
            ret(i, j) = 0.0f;
            for (int k=0; k<4; k++) {
                ret(i, j) += a(i, k) * b(k, j);
            }
        }
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\dmusicf.h ===
/*
 *
 */

#ifndef _DMUSICF_
#define _DMUSICF_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#ifdef __cplusplus
extern "C" {
#endif

interface IDirectMusicCollection;
#ifndef __cplusplus 
typedef interface IDirectMusicCollection IDirectMusicCollection;
#endif

typedef struct _DMUS_COMMAND_PARAM
{
	BYTE bCommand;
	BYTE bGrooveLevel;
	BYTE bGrooveRange;
} DMUS_COMMAND_PARAM;
/* The following structures are used by the Tracks, and are the packed structures */
/* that are passed to the Tracks inside the IStream. */


typedef struct _DMUS_IO_SEQ_ITEM
{
	long    lTime;
	long	lDuration;
	BYTE	bEventType;
	BYTE	bStatus;
	BYTE	bByte1;
	BYTE	bByte2;
	BYTE	bType;
	BYTE	bPad[3];
} DMUS_IO_SEQ_ITEM;


typedef struct _DMUS_IO_TEMPO_ITEM
{
	long	lTime;
	double	dblTempo;
} DMUS_IO_TEMPO_ITEM;


typedef struct _DMUS_IO_SYSEX_ITEM
{
	long    lTime;
	DWORD   dwSysExLength;
	BYTE*   pbSysExData;
} DMUS_IO_SYSEX_ITEM;


typedef struct _DMUS_IO_BANKSELECT_ITEM
{
	BYTE	byLSB;
	BYTE	byMSB;
	BYTE    byPad[2];
} DMUS_IO_BANKSELECT_ITEM;


typedef struct _DMUS_IO_PATCH_ITEM
{
	long						lTime;
	BYTE						byStatus;
	BYTE						byByte1;
	BYTE						byByte2;
	BYTE						byMSB;
	BYTE						byLSB;
	BYTE						byPad[3];
	DWORD						dwFlags;
	IDirectMusicCollection*		pIDMCollection;
	struct _DMUS_IO_PATCH_ITEM*	pNext;	
} DMUS_IO_PATCH_ITEM;

typedef struct _DMUS_IO_TIMESIGNATURE_ITEM
{
	long	lTime;
	BYTE	bBeatsPerMeasure;		/* beats per measure (top of time sig) */
	BYTE	bBeat;				/* what note receives the beat (bottom of time sig.) */
									/* we can assume that 0 means 256th note */
	WORD	wGridsPerBeat;		/* grids per beat */
} DMUS_IO_TIMESIGNATURE_ITEM;

typedef struct _DMUS_SUBCHORD
{
	DWORD	dwChordPattern;		/* Notes in the subchord */
	DWORD	dwScalePattern;		/* Notes in the scale */
	DWORD	dwInversionPoints;	/* Where inversions can occur */
	DWORD	dwLevels;			/* Which levels are supported by this subchord */
	BYTE	bChordRoot;			/* Root of the subchord */
	BYTE	bScaleRoot;			/* Root of the scale */
} DMUS_SUBCHORD;

typedef struct _DMUS_CHORD_PARAM
{
	WCHAR			wszName[16];			/* Name of the chord */
	WORD			wMeasure;				/* Measure this falls on */
	BYTE			bBeat;				/* Beat this falls on */
	BYTE			bSubChordCount;		/* Number of chords in the list of subchords */
	DMUS_SUBCHORD	SubChordList[DMUS_MAXSUBCHORD];	/* List of sub chords */
} DMUS_CHORD_PARAM;

typedef struct _DMUS_RHYTHM_PARAM
{
	DMUS_TIMESIGNATURE	TimeSig;
	DWORD			dwRhythmPattern;
} DMUS_RHYTHM_PARAM;

typedef struct _DMUS_TEMPO_PARAM
{
	MUSIC_TIME	mtTime;
	double		dblTempo;
} DMUS_TEMPO_PARAM;


typedef struct _DMUS_MUTE_PARAM
{
	DWORD	dwPChannel;
	DWORD	dwPChannelMap;
} DMUS_MUTE_PARAM;

/* Style chunks */

#define DMUS_FOURCC_STYLE_FORM        mmioFOURCC('D','M','S','T')
#define DMUS_FOURCC_STYLE_UNDO_FORM   mmioFOURCC('s','t','u','n')
#define DMUS_FOURCC_STYLE_CHUNK       mmioFOURCC('s','t','y','h')
#define DMUS_FOURCC_STYLE_UI_CHUNK    mmioFOURCC('s','t','y','u')
#define DMUS_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DMUS_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DMUS_FOURCC_CATEGORY_CHUNK    mmioFOURCC('c','a','t','g')
#define DMUS_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')
#define DMUS_FOURCC_PART_LIST	        mmioFOURCC('p','a','r','t')
#define DMUS_FOURCC_PART_CHUNK        mmioFOURCC('p','r','t','h')
#define DMUS_FOURCC_NOTE_CHUNK        mmioFOURCC('n','o','t','e')
#define DMUS_FOURCC_CURVE_CHUNK       mmioFOURCC('c','r','v','e')
#define DMUS_FOURCC_PATTERN_LIST      mmioFOURCC('p','t','t','n')
#define DMUS_FOURCC_PATTERN_CHUNK     mmioFOURCC('p','t','n','h')
#define DMUS_FOURCC_PATTERN_UI_CHUNK  mmioFOURCC('p','t','n','u')
#define DMUS_FOURCC_RHYTHM_CHUNK      mmioFOURCC('r','h','t','m')
#define DMUS_FOURCC_PARTREF_LIST      mmioFOURCC('p','r','e','f')
#define DMUS_FOURCC_PARTREF_CHUNK     mmioFOURCC('p','r','f','c')
#define DMUS_FOURCC_OLDGUID_CHUNK		mmioFOURCC('j','o','g','c')
#define DMUS_FOURCC_PATTERN_DESIGN	mmioFOURCC('j','p','n','d')
#define DMUS_FOURCC_PART_DESIGN		mmioFOURCC('j','p','t','d')
#define DMUS_FOURCC_PARTREF_DESIGN	mmioFOURCC('j','p','f','d')
#define DMUS_FOURCC_PIANOROLL_LIST	mmioFOURCC('j','p','r','l')
#define DMUS_FOURCC_PIANOROLL_CHUNK	mmioFOURCC('j','p','r','c')

#define DMUS_PLAYMODE_SCALE_ROOT			1
#define DMUS_PLAYMODE_CHORD_ROOT			2
#define DMUS_PLAYMODE_SCALE_INTERVALS	4
#define DMUS_PLAYMODE_CHORD_INTERVALS	8
#define DMUS_PLAYMODE_NONE				16
#define DMUS_PLAYMODE_FIXED				0
#define DMUS_PLAYMODE_FIXEDTOSCALE		DMUS_PLAYMODE_SCALE_ROOT
#define DMUS_PLAYMODE_FIXEDTOCHORD		DMUS_PLAYMODE_CHORD_ROOT
#define DMUS_PLAYMODE_PEDALPOINT			(DMUS_PLAYMODE_SCALE_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
#define DMUS_PLAYMODE_PURPLEIZED			(DMUS_PLAYMODE_SCALE_INTERVALS | DMUS_PLAYMODE_CHORD_INTERVALS | \
											DMUS_PLAYMODE_CHORD_ROOT)
#define DMUS_PLAYMODE_NORMALCHORD		(DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)

#pragma pack(2)

typedef struct _DMUS_IO_TIMESIG
{
	/* Time signatures define how many beats per measure, which note receives */
	/* the beat, and the grid resolution. */
	BYTE	bBeatsPerMeasure;		/* beats per measure (top of time sig) */
	BYTE	bBeat;				/* what note receives the beat (bottom of time sig.) */
									/* we can assume that 0 means 256th note */
	WORD	wGridsPerBeat;		/* grids per beat */
} DMUS_IO_TIMESIG;

typedef struct _DMUS_IO_STYLE
{
	DMUS_IO_TIMESIG			timeSig;		/* Styles have a default Time Signature */
	double				dblTempo;	
} DMUS_IO_STYLE;

typedef struct _DMUS_IO_VERSION
{
	DWORD				dwVersionMS;		 /* Version # high-order 32 bits */
	DWORD				dwVersionLS;		 /* Version # low-order 32 bits  */
} DMUS_IO_VERSION;

typedef struct _DMUS_IO_PATTERN
{
	DMUS_IO_TIMESIG		timeSig;	/* Patterns can override the Style's Time sig. */
	BYTE				bGrooveBottom; /* bottom of groove range */
	BYTE				bGrooveTop; /* top of groove range */
	WORD				wEmbellishment;	/* Fill, Break, Intro, End, Normal, Motif */
	WORD				wNbrMeasures; /* length in measures */
} DMUS_IO_PATTERN;

typedef struct _DMUS_IO_STYLEPART
{
	DMUS_IO_TIMESIG		timeSig; /* can override pattern's */
	DWORD				dwVariationChoices[32]; /* // MOAW choice bitfield */
	GUID				guidPartID;	/* identifies the part */
	WORD				wNbrMeasures; /* length of the Part */
	BYTE				bPlayModeFlags; /* see PLAYMODE flags */
	BYTE				bInvertUpper;	/* inversion upper limit */
	BYTE				bInvertLower; /* inversion lower limit */
} DMUS_IO_STYLEPART;

typedef struct _DMUS_IO_PARTREF
{
	GUID	guidPartID;	/* unique ID for matching up with parts */
	WORD	wLogicalPartID; /* corresponds to port/device/midi channel */
	BYTE	bVariationLockID; /* parts with the same ID lock variations. */
											/* high bit is used to identify master Part */
	BYTE	bSubChordLevel; /* tells which sub chord level this part wants */
	BYTE	bPriority; /* 256 priority levels. Parts with lower priority */
									/* aren't played first when a device runs out of */
									/* notes */
	BYTE	bRandomVariation;		/* when set, matching variations play in random order */
									/* when clear, matching variations play sequentially */
} DMUS_IO_PARTREF;

typedef struct _DMUS_IO_STYLENOTE
{
	MUSIC_TIME	mtGridStart;		/* when this note occurs */
	DWORD		dwVariation;		/* variation bits */
	MUSIC_TIME	mtDuration;		/* how long this note lasts */
	short		nTimeOffset;		/* offset from mtGridStart */
    WORD		wMusicValue;		/* Position in scale. */
    BYTE		bVelocity;		/* Note velocity. */
    BYTE		bTimeRange;		/* Range to randomize start time. */
    BYTE		bDurRange;		/* Range to randomize duration. */
    BYTE		bVelRange;		/* Range to randomize velocity. */
	BYTE		bInversionID;		/* Identifies inversion group to which this note belongs */
	BYTE		bPlayModeFlags;	/* Can override part */
} DMUS_IO_STYLENOTE;

typedef struct _DMUS_IO_STYLECURVE
{
	MUSIC_TIME	mtGridStart;	/* when this curve occurs */
	DWORD		dwVariation;	/* variation bits */
	MUSIC_TIME	mtDuration;	/* how long this curve lasts */
	MUSIC_TIME	mtResetDuration;	/* how long after the end of the curve to reset the curve */
	short		nTimeOffset;	/* offset from mtGridStart */
	short		nStartValue;	/* curve's start value */
	short		nEndValue;	/* curve's end value */
	short		nResetValue;	/* the value to which to reset the curve */
    BYTE		bEventType;	/* type of curve */
	BYTE		bCurveShape;	/* shape of curve */
    BYTE		bCCData;		/* CC# */
	BYTE		bFlags;		/* Bit 1=TRUE means to send nResetValue. Otherwise, don't.
								   Other bits are reserved. */
} DMUS_IO_STYLECURVE;

#pragma pack()


/*
RIFF
(
	'STYL'			// Style
	<styh-ck>		// Style header chunk
	<guid-ck>		// Every Style has a GUID
	[<INFO-list>]	// Name, author, copyright info., comments
	[<vers-ck>]		// version chunk
	<part-list>		// List of parts in the Style, used by patterns
	<pttn-list>		// List of patterns in the Style
	<band-list>		// List of bands in the Style
	[<motf-list>]	// List of motifs in the Style
)

	// <styh-ck>
	styh
	(
		<DMUS_IO_STYLE>
	)

	// <guid-ck>
	guid
	(
		<GUID>
	)

	// <vers-ck>
	vers
	(
		<DMUS_IO_VERSION>
	)

	// <part-list>
	LIST
	(
		'part'
		<prth-ck>		// Part header chunk
		[<INFO-list>]
		[<note-ck>]	// List of notes in Part
		[<crve-ck>]	// List of curves in Part
	)

		// <orth-ck>
		prth
		(
			<DMUS_IO_STYLEPART>
		)

		// <note-ck>
		'note'
		(
			// sizeof DMUS_IO_STYLENOTE:DWORD
			<DMUS_IO_STYLENOTE>...
		)

		// <crve-ck>
		'crve'
		(
			// sizeof DMUS_IO_STYLECURVE:DWORD
			<DMUS_IO_STYLECURVE>...
		)

	// <pttn-list>
	LIST
	(
		'pttn'
		<ptnh-ck>		// Pattern header chunk
		<rhtm-ck>		// List of rhythms for chord matching
		[<INFO-list>]
		<pref-list>		// List of part reference id's
	)

		// <ptnh-ck>
		ptnh
		(
			<DMUS_IO_PATTERN>
		)

		// <rhtm-ck>
		'rhtm'
		(
			// DWORD's representing rhythms for chord matching based on number
			// of measures in the pattern
		)

		// pref-list
		LIST
		(
			'pref'
			<prfc-ck>	// part ref chunk
		)

		// <prfc-ck>
		prfc
		(
			<DMUS_IO_PARTREF>
		)
*/

/* Chord and command file formats */

#define DMUS_FOURCC_CHORDTRACK_LIST	mmioFOURCC('c','o','r','d')
#define DMUS_FOURCC_CHORDTRACKHEADER_CHUNK	mmioFOURCC('c','r','d','h')
#define DMUS_FOURCC_CHORDTRACKBODY_CHUNK	mmioFOURCC('c','r','d','b')

#define DMUS_FOURCC_COMMANDTRACK_CHUNK	mmioFOURCC('c','m','n','d')

typedef struct _DMUS_IO_CHORD
{
	WCHAR 		wszName[16];	/* Name of the chord */
	MUSIC_TIME	mtTime;		/* Time of this chord */
	WORD		wMeasure;		/* Measure this falls on */
	BYTE		bBeat;		/* Beat this falls on */
} DMUS_IO_CHORD;

typedef struct _DMUS_IO_SUBCHORD
{
	DWORD	dwChordPattern;		/* Notes in the subchord */
	DWORD	dwScalePattern;		/* Notes in the scale */
	DWORD	dwInversionPoints;	/* Where inversions can occur */
	DWORD	dwLevels;			/* Which levels are supported by this subchord */
	BYTE	bChordRoot;			/* Root of the subchord */
	BYTE	bScaleRoot;			/* Root of the scale */
} DMUS_IO_SUBCHORD;

typedef struct _DMUS_IO_COMMAND
{
	MUSIC_TIME	mtTime;		/* Time of this command */
	WORD		wMeasure;		/* Measure this falls on */
	BYTE		bBeat;		/* Beat this falls on */
	BYTE		bCommand;		/* Command type (see #defines below) */
	BYTE		bGrooveLevel;	/* Groove level (0 if command is not a groove) */
	BYTE		bGrooveRange;	/* Groove range  */
} DMUS_IO_COMMAND;


/*

	// <chrd-list>
	LIST
	(
		'chrd'
		<crdh-ck>
		<crdb-ck>		// Chord body chunk
	)

		// <crdh-ck>
		crdh
		(
			// Scale: dword (upper 8 bits for root, lower 24 for scale)
		)

		// <crdb-ck>
		crdb
		(
			// sizeof DMUS_IO_CHORD:dword
			<DMUS_IO_CHORD>
			// # of DMUS_IO_SUBCHORDS:dword
			// sizeof DMUS_IO_SUBCHORDS:dword
			// a number of <DMUS_IO_SUBCHORD>
		)


	// <cmnd-list>
	'cmnd'
	(
		//sizeof DMUS_IO_COMMAND: DWORD
		<DMUS_IO_COMMAND>...
	)

*/

/*
RIFF
(
	'DMPF'			// DirectMusic Performance chunk
	[<prfh-ck>]		// Performance header chunk
	[<guid-ck>]		// GUID for performance
	[<vers-ck>]		// Optional version info
	[<INFO-list>]	// Name, author, copyright info., comments
	[<ptgl-list>]	// List of Port groups, which are lists of desired port properties and
					// the PChannels to assign the Port.
	[<ntfl-list>]	// List of notifications
	[<glbl-list>]	// List of global data
	[<DMTG-form>]	// Optional ToolGraph
)

	// <prfh-ck>
	'prfh'			// Performance header
	(
		<DMUS_IO_PERFORMANCE_HEADER>
	)
	
	// <guid-ck>
	'guid'
	(
		<GUID>
	)

	// <vers-ck>
	vers
	(
		<DMUS_IO_VERSION>
	)

	// <ptgl-list>
	LIST
	(
		'ptgl'			// List of Port groups
		<pspl-list>		// List of support items for this group
	)

	// <ntfl-list>
	LIST
	(
		'ntfl'			// List of notifications
		<guid-ck>		// Notification guid
	)

	// <glbl-list>
	LIST
	(
		'glbl'			// List of global data
		<glbd-ck>		// The data.
	)

		// <glbd-ck>
		'glbd'
		(
			<DMUS_IO_GLOBAL_DATA>
		)

// <pspl-list>
LIST
(
	'pspl'				// List of port support items
	<psph-ck>			// Port support item header chunk
	<pchn-ck>			// PChannels that want this Port
)

	// <pchn-ck>
	'pchn'
	(
		<DMUS_IO_PCHANNELS>
	)

	// <psph-ck>			// Port support item header chunk
	(
		'psph'				// Port support item header
		<DMUS_IO_PORT_SUPPORT_HEADER>
	)
*/
	
/*	File io for DirectMusic Tool and ToolGraph objects
*/

/* RIFF ids: */

#define DMUS_FOURCC_TOOLGRAPH_FORM	mmioFOURCC('D','M','T','G')
#define DMUS_FOURCC_TOOL_LIST		mmioFOURCC('t','o','l','l')
#define DMUS_FOURCC_TOOL_FORM		mmioFOURCC('D','M','T','L')
#define DMUS_FOURCC_TOOL_CHUNK		mmioFOURCC('t','o','l','h')

/* io structures: */

typedef struct _DMUS_IO_TOOL_HEADER
{
	GUID		guidClassID;	/* Class id of tool. */
	long		lIndex;			/* Position in graph. */
	DWORD		cPChannels;		/* Number of items in channels array. */
	FOURCC      ckid;			/* chunk ID of tool's data chunk if 0 fccType valid. */
	FOURCC      fccType;		/* list type if NULL ckid valid. */
	DWORD		dwPChannels[1];	/* Array of PChannels, size determined by cPChannels. */
} DMUS_IO_TOOL_HEADER;

/*
RIFF
(
	'DMTG'			// DirectMusic ToolGraph chunk
	[<guid-ck>]		// GUID for ToolGraph
	[<vers-ck>]		// Optional version info
	[<INFO-list>]	// Name, author, copyright info., comments
	<toll-list>		// List of Tools
)

	// <guid-ck>
	'guid'
	(
		<GUID>
	)

	// <vers-ck>
	vers
	(
		<DMUS_IO_VERSION>
	)

	// <toll-list>
	LIST
	(
		'toll'			// List of tools
		<DMTL-form>...	// Each tool is encapsulated in a RIFF chunk
	)

// <DMTL-form>		// Tools can be embedded in a graph or stored as separate files.
RIFF
(
	'DMTL'
	<tolh-ck>
	[<guid-ck>]		// Optional GUID for tool object instance (not to be confused with Class id in track header)
	[<vers-ck>]		// Optional version info
	[<INFO-list>]	// Optional name, author, copyright info., comments
	[<data>]		// Tool data. Must be a RIFF readable chunk.
)

	// <tolh-ck>			// Tool header chunk
	(
		'tolh'
		<DMUS_IO_TOOL_HEADER>	// Tool header
	)
*/

/*	File io for DirectMusic Band Track object */


/* RIFF ids: */
#define DMUS_FOURCC_BANDTRACK_FORM	mmioFOURCC('D','M','B','T')
#define DMUS_FOURCC_BANDTRACK_CHUNK	mmioFOURCC('b','d','t','h')
#define DMUS_FOURCC_BANDS_LIST		mmioFOURCC('l','b','d','l')
#define DMUS_FOURCC_BAND_LIST		mmioFOURCC('l','b','n','d')
#define DMUS_FOURCC_BANDITEM_CHUNK	mmioFOURCC('b','n','i','h')

/*	io structures */
typedef struct _DMUS_IO_BAND_TRACK_HEADER
{
	BOOL bAutoDownload;	/* Determines if Auto-Download is enabled. */
} DMUS_IO_BAND_TRACK_HEADER;

typedef struct _DMUS_IO_BAND_ITEM_HEADER
{
	MUSIC_TIME lBandTime;	/* Position in track list. */
} DMUS_IO_BAND_ITEM_HEADER;

/*
RIFF
(
	'DMBT'			// DirectMusic Band Track form-type
	[<bdth-ck>]		// Band track header
	[<guid-ck>]		// GUID for band track
	[<vers-ck>]		// Optional version info
	[<INFO-list>]	// Name, author, copyright info., comments
	<lbdl-list>		// List of Band Lists
)

  	// <bnth-ck>
	'bdth'
	(
		<DMUS_IO_BAND_TRACK_HEADER>
	)

	// <guid-ck>
	'guid'
	(
		<GUID>
	)

	// <vers-ck>
	vers
	(
		<DMUS_IO_VERSION>
	)

	// <lbdl-list>
	LIST
	(
		'lbdl'			// List of bands
		<lbnd-list>		// Each band is encapsulated in a list
	)

		// <lbnd-list>
		LIST
		(
			'lbnd'
			<bdih-ck>
			<DMBD-form>	// Band
)		)

			// <bdih-ck>			// band item header
			(
				<DMUS_IO_BAND_ITEM_HEADER>	// Band item header
			)
*/		


/*	File io for DirectMusic Band object
*/

/* RIFF ids: */

#define DMUS_FOURCC_BAND_FORM			mmioFOURCC('D','M','B','D')
#define DMUS_FOURCC_INSTRUMENTS_LIST	mmioFOURCC('l','b','i','l')
#define DMUS_FOURCC_INSTRUMENT_LIST	mmioFOURCC('l','b','i','n')
#define DMUS_FOURCC_INSTRUMENT_CHUNK	mmioFOURCC('b','i','n','s')

// Flags for DMUS_IO_INSTRUMENT
#define DMUS_IO_INST_PATCH			(1 << 0)		// dwPatch is valid.
#define DMUS_IO_INST_BANKSELECT_MSB	(1 << 1)		// dwPatch contains a valid Bank Select MSB part
#define DMUS_IO_INST_BANKSELECT_LSB	(1 << 2)		// dwPatch contains a valid Bank Select LSB part
#define DMUS_IO_INST_ASSIGN_PATCH	(1 << 3)		// dwAssignPatch is valid
#define DMUS_IO_INST_NOTERANGES		(1 << 4)		// dwNoteRanges is valid
#define DMUS_IO_INST_PAN			(1 << 5)		// bPan is valid
#define DMUS_IO_INST_VOLUME			(1 << 6 )		// bVolume is valid
#define DMUS_IO_INST_TRANSPOSE		(1 << 7)		// nTranspose is valid
#define DMUS_IO_INST_GM				(1 << 8)		// Instrument is from GM collection
#define DMUS_IO_INST_GS				(1 << 9)		// Instrument is from GS collection
#define DMUS_IO_INST_VPATCH			(1 << 10)		// Instrument dwPatch is a virtual patch

/*	io structures */
typedef struct _DMUS_IO_INSTRUMENT
{
	DWORD	dwPatch;			/* MSB, LSB and Program change to define instrument */
	DWORD	dwAssignPatch;		/* MSB, LSB and Program change to assign to instrument when downloading */
	DWORD	dwNoteRanges[4];	/* 128 bits; one for each MIDI note instrument needs to able to play */
	DWORD	dwPChannel;			/* PChannel instrument plays on */
	DWORD	dwFlags;			/* DMUS_IO_INST_ flags */
	BYTE	bPan;				/* Pan for instrument */
	BYTE	bVolume;			/* Volume for instrument */
	short	nTranspose;			/* Number of semitones to transpose notes */
} DMUS_IO_INSTRUMENT;

/*
RIFF
(
	'DMBD'			// DirectMusic Band chunk
	[<guid-ck>]		// GUID for band
	[<vers-ck>]		// Optional version info
	[<INFO-list>]	// Name, author, copyright info., comments
	<lbil-list>		// List of Instruments
)

	// <guid-ck>
	'guid'
	(
		<GUID>
	)

	// <vers-ck>
	vers
	(
		<DMUS_IO_VERSION>
	)

	// <lbil-list>
	LIST
	(
		'lbil'			// List of instruments
		<lbin-list>		// Each instrument is encapsulated in a list
	)

		// <lbin-list>
		LIST
		(
			'lbin'
			<bins-ck>
			[<DMRF-list>]		// Optional reference to DLS Collection file.
		)

			// <bins-ck>			// Instrument chunk
			(
				'bins'
				<DMUS_IO_INSTRUMENT>	// Instrument header
			)
*/		

/*	File io for DirectMusic Segment object */

/* RIFF ids: */

#define DMUS_FOURCC_SEGMENT_FORM	mmioFOURCC('D','M','S','G')
#define DMUS_FOURCC_SEGMENT_CHUNK	mmioFOURCC('s','e','g','h')
#define DMUS_FOURCC_TRACK_LIST	mmioFOURCC('t','r','k','l')
#define DMUS_FOURCC_TRACK_FORM	mmioFOURCC('D','M','T','K')
#define DMUS_FOURCC_TRACK_CHUNK	mmioFOURCC('t','r','k','h')

/*	io structures:*/

typedef struct _DMUS_IO_SEGMENT_HEADER
{
	DWORD		dwRepeats;		/* Number of repeats. By default, 0. */
	MUSIC_TIME	mtLength;		/* Length, in music time. */
	MUSIC_TIME	mtPlayStart;	/* Start of playback. By default, 0. */
	MUSIC_TIME	mtLoopStart;	/* Start of looping portion. By default, 0. */
	MUSIC_TIME	mtLoopEnd;		/* End of loop. Must be greater than dwPlayStart. By default equal to length. */
	DWORD		dwResolution;	/* Default resolution. */
} DMUS_IO_SEGMENT_HEADER;

typedef struct _DMUS_IO_TRACK_HEADER
{
	GUID		guidClassID;	/* Class id of track. */
	DWORD		dwPosition;		/* Position in track list. */
	DWORD		dwGroup;		/* Group bits for track. */
	FOURCC      ckid;			/* chunk ID of track's data chunk if 0 fccType valid. */
	FOURCC      fccType;		/* list type if NULL ckid valid */
} DMUS_IO_TRACK_HEADER;

/*
RIFF
(
	'DMSG'			// DirectMusic Segment chunk
	<segh-ck>		// Segment header chunk
	[<guid-ck>]		// GUID for segment
	[<vers-ck>]		// Optional version info
	[<INFO-list>]	// Name, author, copyright info., comments
	<trkl-list>		// List of Tracks
	[<DMTG-form>]	// Optional ToolGraph
)

	// <segh-ck>		
	'segh'
	(
		<DMUS_IO_SEGMENT_HEADER>
	)
	
	// <guid-ck>
	'guid'
	(
		<GUID>
	)

	// <vers-ck>
	vers
	(
		<DMUS_IO_VERSION>
	)

	// <trkl-list>
	LIST
	(
		'trkl'			// List of tracks
		<DMTK-form>...	// Each track is encapsulated in a RIFF chunk
	)

// <DMTK-form>		// Tracks can be embedded in a segment or stored as separate files.
RIFF
(
	'DMTK'
	<trkh-ck>
	[<guid-ck>]		// Optional GUID for track object instance (not to be confused with Class id in track header)
	[<vers-ck>]		// Optional version info
	[<INFO-list>]	// Optional name, author, copyright info., comments
	[<data>]		// Track data. Must be a RIFF readable chunk.
)

	// <trkh-ck>			// Track header chunk
	(
		'trkh'
		<DMUS_IO_TRACK_HEADER>	// Track header
	)
*/

/*	File io for DirectMusic reference chunk. 
	This is used to embed a reference to an object.
*/

/*	RIFF ids: */

#define DMUS_FOURCC_REF_LIST			mmioFOURCC('D','M','R','F')
#define DMUS_FOURCC_REF_CHUNK			mmioFOURCC('r','e','f','h')
#define DMUS_FOURCC_DATE_CHUNK		mmioFOURCC('d','a','t','e')
#define DMUS_FOURCC_NAME_CHUNK		mmioFOURCC('n','a','m','e')
#define DMUS_FOURCC_FILE_CHUNK		mmioFOURCC('f','i','l','e')
#define DMUS_FOURCC_CATEGORY_CHUNK	mmioFOURCC('c','a','t','g')
#define DMUS_FOURCC_VERSION_CHUNK		mmioFOURCC('v','e','r','s')

typedef struct _DMUS_IO_REFERENCE
{
	GUID	guidClassID;	/* Class id is always required. */
	DWORD	dwValidData;	/* Flags. */
} DMUS_IO_REFERENCE;

/*
LIST
(
	'DMRF'			// DirectMusic Reference chunk
	<refh-ck>		// Reference header chunk
	[<guid-ck>]		// Optional object GUID.
	[<date-ck>]		// Optional file date.
	[<name-ck>]		// Optional name.
	[<file-ck>]		// Optional file name.
	[<catg-ck>]		// Optional category name.
	[<vers-ck>]		// Optional version info.
)

	// <refh-ck>
	'refh'
	(
		<DMUS_IO_REFERENCE>
	)

	// <guid-ck>
	'guid'
	(
		<GUID>
	)

	// <date-ck>
	date
	(
		<FILETIME>
	)

	// <name-ck>
	name
	(
		// Name, stored as NULL terminated string of WCHARs
	)

	// <file-ck>
	file
	(
		// File name, stored as NULL terminated string of WCHARs
	)

	// <catg-ck>
	catg
	(
		// Category name, stored as NULL terminated string of WCHARs
	)

	// <vers-ck>
	vers
	(
		<DMUS_IO_VERSION>
	)
*/

/*	File i/o for DirectMusic Performance object */

/*	RIFF ids: */

#define DMUS_FOURCC_PERFORMANCE_FORM		mmioFOURCC('D','M','P','F')
#define DMUS_FOURCC_PERFORMANCE_CHUNK		mmioFOURCC('p','r','f','h')
#define DMUS_FOURCC_PERF_PORTGROUP_LIST		mmioFOURCC('p','t','g','l')
#define DMUS_FOURCC_PERF_NOTIFICATION_LIST	mmioFOURCC('n','t','f','l')
#define DMUS_FOURCC_PERF_GLOBAL_DATA_LIST	mmioFOURCC('g','l','b','l')
#define DMUS_FOURCC_PERF_SUPPORT_LIST		mmioFOURCC('p','s','p','l')
#define DMUS_FOURCC_PERF_SUPPORT_CHUNK		mmioFOURCC('p','s','p','h')
#define DMUS_FOURCC_PERF_PCHANNELS_CHUNK	mmioFOURCC('p','c','h','n')
/*	io structures: */

typedef struct _DMUS_IO_PERFORMANCE_HEADER
{
	DWORD		dwPrepareTime;	/* time ahead, in ms, to transport */
	DWORD		dwPrePlayTime;	/* time ahead, in ms, of latency clock to pack events */
} DMUS_IO_PERFORMANCE_HEADER;

typedef enum _DMUS_SUPPORTTYPE	/* identifies the type of data in DMUS_IO_USSupportData */
{
	DMUS_ST_BOOL = 0,
	DMUS_ST_DWORD = 1,
	DMUS_ST_LONG = 2
} DMUS_SUPPORTTYPE;

typedef struct _DMUS_IO_SUPPORT_DATA		/* data used in DMUS_IO_USPortSupportHeader */
{
	DMUS_SUPPORTTYPE	type;		/* identifies which member of the union is valid */
	union
	{
		BOOL	fVal;
		DWORD	dwVal;
		LONG	lVal;
	};
} DMUS_IO_SUPPORT_DATA;

typedef struct _DMUS_IO_PORT_SUPPORT_HEADER	/* identifies desired port properties */
{
	GUID				guidID;			/* Support ID. */
	DMUS_IO_SUPPORT_DATA	lowData;		/* Low range of data, inclusive. If BOOL type, */
										/* ignore highData. Otherwise, combine lowData */
										/* and highData into a range. */
	DMUS_IO_SUPPORT_DATA	highData;		/* High range of data, inclusive */
} DMUS_IO_PORT_SUPPORT_HEADER;

typedef struct _DMUS_IO_PCHANNELS	/* Holds the PChannels to assign to a Port */
{
	DWORD		cPChannels;	/* Number of items in channels array.  */
	DWORD		adwPChannels[1];/* Array of PChannels, size determined by cPChannels. */
} DMUS_IO_PCHANNELS;

typedef struct _DMUS_IO_GLOBAL_DATA	/* Holds the global data information */
{
	GUID		guid;		/* The global data guid */
	DWORD		dwSize;		/* The size of the data */
	char		acData[1];	/* Holds the data of the global data, size determine by dwSize */
} DMUS_IO_GLOBAL_DATA;

/* personalities */

/* runtime chunks */
#define DMUS_FOURCC_PERSONALITY_FORM	mmioFOURCC('D','M','P','R')
#define DMUS_FOURCC_IOPERSONALITY_CHUNK		mmioFOURCC('p','e','r','h')
#define DMUS_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DMUS_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DMUS_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')
#define DMUS_FOURCC_SUBCHORD_CHUNK				mmioFOURCC('c','h','d','t')
#define DMUS_FOURCC_CHORDENTRY_CHUNK			mmioFOURCC('c','h','e','h')
#define DMUS_FOURCC_SUBCHORDID_CHUNK			mmioFOURCC('s','b','c','n')
#define DMUS_FOURCC_IONEXTCHORD_CHUNK			mmioFOURCC('n','c','r','d')
#define DMUS_FOURCC_NEXTCHORDSEQ_CHUNK		  mmioFOURCC('n','c','s','q')
#define DMUS_FOURCC_IOSIGNPOST_CHUNK			mmioFOURCC('s','p','s','h')
#define DMUS_FOURCC_CHORDNAME_CHUNK			mmioFOURCC('I','N','A','M')

/* runtime list chunks */
#define DMUS_FOURCC_CHORDENTRY_LIST		mmioFOURCC('c','h','o','e')
#define DMUS_FOURCC_CHORDMAP_LIST			mmioFOURCC('c','m','a','p')
#define DMUS_FOURCC_CHORD_LIST			mmioFOURCC('c','h','r','d')
#define DMUS_FOURCC_CHORDPALETTE_LIST		mmioFOURCC('c','h','p','l')
#define DMUS_FOURCC_CADENCE_LIST			mmioFOURCC('c','a','d','e')
#define DMUS_FOURCC_SIGNPOSTITEM_LIST			mmioFOURCC('s','p','s','t')

#define DMUS_FOURCC_SIGNPOST_LIST		mmioFOURCC('s','p','s','q')

/* run time data structs */
typedef struct _DMUS_IO_PERSONALITY
{
	WCHAR	wszLoadName[20];
	DWORD	dwScalePattern;
	DWORD	dwFlags;
} DMUS_IO_PERSONALITY;

typedef struct _DMUS_IO_PERS_SUBCHORD
{
	DWORD	dwChordPattern;
	DWORD	dwScalePattern;
	DWORD	dwInvertPattern;
	BYTE	bChordRoot;
	BYTE	bScaleRoot;
	WORD	wCFlags;
	DWORD	dwLevels;	/* parts or which subchord levels this chord supports */
} DMUS_IO_PERS_SUBCHORD;

typedef struct _DMUS_IO_CHORDENTRY
{
	DWORD	dwFlags;
	WORD	wConnectionID;	/* replaces runtime "pointer to this" */
} DMUS_IO_CHORDENTRY;

typedef struct _DMUS_IO_NEXTCHORD
{
	DWORD	dwFlags;
	WORD	nWeight;
	WORD	wMinBeats;
	WORD	wMaxBeats;
	WORD	wConnectionID;	/* points to an ioChordEntry */
} DMUS_IO_NEXTCHORD;

typedef struct _DMUS_IO_PERS_SIGNPOST
{
	DWORD	dwChords;	/* 1bit per group */
	DWORD	dwFlags;
} DMUS_IO_PERS_SIGNPOST;

/*
RIFF
(
	'DMPR'
	<perh-ck>			// Personality header chunk
	[<guid-ck>]			// guid chunk
	[<vers-ck>]			// version chunk (two DWORDS)
	<INFO-list>		  // standard MS Info chunk
	<chdt-ck>		   // subchord database
	<chpl-list>			// chord palette
	<cmap-list>		  // chord map
	<spst-list>			// signpost list
 )

 <chdt> ::= chdt(<cbChordSize::WORD>  <ioSubChord> ... )

<chpl-list> ::= LIST('chpl' 
								<chrd-list> ... // chord definition
							 )

<chrd-list> ::= LIST('chrd' 
								<INAM-ck> // name of chord in wide char format
								<sbcn-ck>	// list of subchords composing chord
								[<ched-ck>]   //  optional chord edit flags
								)

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
								<cheh-ck>	// chord entry data
								<chrd-list>	// chord definition
								<ncsq-ck>	// connecting(next) chords
								)

<spst-list> ::= LIST('spst'
							 <spsh-ck>
							 <chrd-list>
							 [<cade-list>]
							 )

<cade-list> ::= LIST('cade' <chrd-list> ...)
								
<sbcn-ck> ::= sbcn(<cSubChordID:WORD>)

<cheh-ck> ::= cheh(i<DMUS_IO_CHORDENTRY>)

<ncrd-ck> ::= ncrd(<DMUS_IO_NEXTCHORD>)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> <DMUS_IO_NEXTCHORD>...)

<spsh-ck> ::= spsh(<DMUS_IO_PERS_SIGNPOST>)

*/

/* Signpost tracks */

#define DMUS_FOURCC_SIGNPOST_TRACK_CHUNK	 mmioFOURCC( 's', 'g', 'n', 'p' )


typedef struct _DMUS_IO_SIGNPOST
{
	MUSIC_TIME	mtTime;
	DWORD		dwChords;
	WORD		wMeasure;
} DMUS_IO_SIGNPOST;

/*

	// <sgnp-list>
	'sgnp'
	(
		//sizeof DMUS_IO_SIGNPOST: DWORD
		<DMUS_IO_SIGNPOST>...
	)

*/

#define DMUS_FOURCC_MUTE_CHUNK        mmioFOURCC('m','u','t','e')

typedef struct _DMUS_IO_MUTE
{
	MUSIC_TIME	mtTime;
	DWORD		dwPChannel;
	DWORD		dwPChannelMap;
} DMUS_IO_MUTE;

/*

	// <mute-list>
	'mute'
	(
		//sizeof DMUS_IO_MUTE:DWORD
		<DMUS_IO_MUTE>...
	)


*/

/* Used for both style and personality tracks */

#define DMUS_FOURCC_TIME_STAMP_CHUNK mmioFOURCC('s', 't', 'm', 'p')

/* Style tracks */

#define DMUS_FOURCC_STYLE_TRACK_LIST mmioFOURCC('s', 't', 't', 'r')
#define DMUS_FOURCC_STYLE_REF_LIST mmioFOURCC('s', 't', 'r', 'f')

/*

	// <sttr-list>
	LIST('sttr'
	(
		// some number of <strf-list>
	)

	// <strf-list>
	LIST('strf'
	(
		<stmp-ck>
		<DMRF>
	)

	// <stmp-ck> defined in ..\dmcompos\dmcompp.h

*/

/* Personality tracks */

#define DMUS_FOURCC_PERS_TRACK_LIST mmioFOURCC('p', 'f', 't', 'r')
#define DMUS_FOURCC_PERS_REF_LIST mmioFOURCC('p', 'f', 'r', 'f')

/*

	// <pftr-list>
	LIST('pftr'
	(
		// some number of <pfrf-list>
	)

	// <pfrf-list>
	LIST('pfrf'
	(
		<stmp-ck>
		<DMRF>
	)

  // <stmp-ck>
  'stmp'
  (
	// time:DWORD
  )



*/

#define DMUS_FOURCC_TEMPO_TRACK mmioFOURCC('t','e','t','r')

/*
	// tempo list
	'tetr'
	(
		// sizeof DMUS_IO_TEMPO: DWORD
		<DMUS_IO_TEMPO>...
	)
  */

#define DMUS_FOURCC_SEQ_TRACK mmioFOURCC('s','q','t','r')

/*
	// sequence track
	'sqtr'
	(
		// sizeof DMUS_IO_SEQ_ITEM: DWORD
		<DMUS_IO_SEQ_ITEM>...
	)
*/

#define DMUS_FOURCC_SYSEX_TRACK mmioFOURCC('s','y','s','x')

/*
	// sysex track
	'sysx'
	(
		// list of:
		// {
		//		time of the sys-ex message: long
		//		length of the sys-ex data: DWORD
		//		sys-ex: data
		// }...
	)
*/

#define DMUS_FOURCC_TIMESIGNATURE_TRACK	mmioFOURCC('t','i','m','s')

/*
	// time signature track
	'tims'
	(
		// size of DMUS_IO_TIMESIGNATURE_ITEM : DWORD
		<DMUS_IO_TIMESIGNATURE_ITEM>...
	)
*/

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* #ifndef _DMUSICF_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\dmusici.h ===
/*
 *
 */

#ifndef _DMUSICI_
#define _DMUSICI_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>
#include <dmusicc.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef WORD            TRANSITION_TYPE;
typedef LONGLONG        REFERENCE_TIME;
typedef long            MUSIC_TIME;

#define DMUS_PPQ        768     /* parts per quarter note */

/*//////////////////////////////////////////////////////////////////////
// Custom success codes */
#define DMUS_S_REQUEUE  0x00000222      /* returned to requeue a PMSG */
#define DMUS_S_FREE             0x00000223  /* returned to cause the PMSG to be freed */
#define DMUS_S_END       0x00000224  /* returned by IDirectMusicSegment::Play indicating the end of the segment */

interface IDirectMusic;
interface IDirectMusicTrack;
interface IDirectMusicPerformance;
interface IDirectMusicTool;
interface IDirectMusicSegment;
interface IDirectMusicSegmentState;
interface IDirectMusicBuffer;
interface IDirectMusicGraph;
interface IDirectMusicPort;
interface IDirectMusicBuffer;
interface IDirectMusicPort;
interface IDirectMusicInstrument;
interface IDirectMusicDownloadedInstrument;
interface IDirectMusicBand;
interface IDirectMusicPersonality;
interface IDirectMusicLoader;
interface IDirectMusicObject;
interface IDirectMusicBand;
#ifndef __cplusplus 
typedef interface IDirectMusic IDirectMusic;
typedef interface IDirectMusicTrack IDirectMusicTrack;
typedef interface IDirectMusicPerformance IDirectMusicPerformance;
typedef interface IDirectMusicTool IDirectMusicTool;
typedef interface IDirectMusicSegment IDirectMusicSegment;
typedef interface IDirectMusicSegmentState IDirectMusicSegmentState;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicGraph IDirectMusicGraph;
typedef interface IDirectMusicPort IDirectMusicPort;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicPort IDirectMusicPort;
typedef interface IDirectMusicInstrument IDirectMusicInstrument;
typedef interface IDirectMusicDownloadedInstrument IDirectMusicDownloadedInstrument;
typedef interface IDirectMusicBand IDirectMusicBand;
typedef interface IDirectMusicPersonality IDirectMusicPersonality;
typedef interface IDirectMusicObject IDirectMusicObject;
typedef interface IDirectMusicLoader IDirectMusicLoader;
typedef interface IDirectMusicBand IDirectMusicBand;
#endif

typedef enum enumDMUS_COMMANDT_TYPES
{
	DMUS_COMMANDT_GROOVE    = 0,
	DMUS_COMMANDT_FILL              = 1,
	DMUS_COMMANDT_INTRO             = 2,
	DMUS_COMMANDT_BREAK             = 3,
	DMUS_COMMANDT_END               = 4
} DMUS_COMMANDT_TYPES;

typedef enum enumDMUS_SHAPET_TYPES
{
	DMUS_SHAPET_FALLING             = 0,
	DMUS_SHAPET_LEVEL               = 1,
	DMUS_SHAPET_LOOPABLE    = 2,
	DMUS_SHAPET_LOUD                = 3,
	DMUS_SHAPET_QUIET               = 4,
	DMUS_SHAPET_PEAKING             = 5,
	DMUS_SHAPET_RANDOM              = 6,
	DMUS_SHAPET_RISING              = 7,
	DMUS_SHAPET_SONG                = 8
}       DMUS_SHAPET_TYPES;

typedef enum enumDMUS_COMPOSEF_FLAGS
{       
	DMUS_COMPOSEF_NONE              = 0,
	DMUS_COMPOSEF_ALIGN     = 0x1,
	DMUS_COMPOSEF_OVERLAP   = 0x2,
	DMUS_COMPOSEF_IMMEDIATE = 0x4,
	DMUS_COMPOSEF_GRID              = 0x8,
	DMUS_COMPOSEF_BEAT              = 0x10,
	DMUS_COMPOSEF_MEASURE   = 0x20,
	DMUS_COMPOSEF_MODULATE  = 0x1000,
	DMUS_COMPOSEF_LONG              = 0x2000
}       DMUS_COMPOSEF_FLAGS;

#define DMUS_PMSG_PART                                                                       \
	DWORD                   dwSize;                                                                  \
    REFERENCE_TIME      rtTime;                 /* real time (in 100 nanosecond increments) */           \
    MUSIC_TIME          mtTime;                 /* music time */                                         \
	DWORD                   dwFlags;                        /* various bits (see DMUS_PMSG_FLAGS enumeration) */ \
    DWORD                       dwPChannel;             /* Performance Channel. The Performance can */           \
										/* use this to determine the port/channel. */        \
    DWORD                       dwVirtualTrackID;       /* virtual track ID */                               \
    IDirectMusicTool*           pTool;  /* tool interface pointer */                             \
	IDirectMusicGraph*              pGraph; /* tool graph interface pointer */                       \
	DWORD                   dwType;                 /* PMSG type (see DMUS_PM_TYPE defines) */               \
	IUnknown*               punkUser;                       /* user com pointer, auto released upon PMSG free */

/* every DMUS_PMSG is based off of this structure. The Performance needs 
   to access these members consistently in every PMSG that goes through it. */
typedef struct _DMUS_PMSG
{
	/* begin DMUS_PMSG_PART */
	DMUS_PMSG_PART
	/* end DMUS_PMSG_PART */

} DMUS_PMSG;

/* DMUS_PMSGF_FLAGS fill the DMUS_PMSG's dwFlags member */
typedef enum enumDMUS_PMSGF_FLAGS
{
    DMUS_PMSGF_REFTIME = 1,   /* if rtTime is valid */
    DMUS_PMSGF_MUSICTIME = 2, /* if mtTime is valid */
    DMUS_PMSGF_TOOL_IMMEDIATE = 4, /* if PMSG should be processed immediately */ 
    DMUS_PMSGF_TOOL_QUEUE = 8,          /* if PMSG should be processed a little early, at Queue time */
    DMUS_PMSGF_TOOL_ATTIME = 16,   /* if PMSG should be processed at the time stamp */
	DMUS_PMSGF_TOOL_FLUSH = 32              /* if PMSG is being flushed */
} DMUS_PMSGF_FLAGS;

/* DMUS_PMSGT_TYPES fill the DMUS_PMSG's dwType member */
typedef enum enumDMUS_PMSGT_TYPES
{
	DMUS_PMSGT_MIDI =               0,      /* MIDI short message */
	DMUS_PMSGT_NOTE =               1,      /* Interactive Music Note */
	DMUS_PMSGT_SYSEX =              2,      /* MIDI long message (system exclusive message) */
	DMUS_PMSGT_NOTIFICATION =       3,      /* Notification message */
	DMUS_PMSGT_TEMPO        =       4,      /* Tempo message */
	DMUS_PMSGT_CURVE =              5,      /* Control change / pitch bend, etc. curve */
	DMUS_PMSGT_TIMESIG =    6,      /* Time signature */
	DMUS_PMSGT_PATCH =              7,      /* Patch changes */
	DMUS_PMSGT_TRANSPOSE =  8,      /* Transposition messages */
	DMUS_PMSGT_USER =       255     /* User message */
} DMUS_PMSGT_TYPES;

/* DMUS_SEGF_FLAGS correspond to IDirectMusicPerformance::PlaySegment, and other API */
typedef enum enumDMUS_SEGF_FLAGS
{
	DMUS_SEGF_IMMEDIATE = 0,        /* play on music or reference time boundary */
	DMUS_SEGF_RESMASK = 7,  /* masks resolution bits */
	DMUS_SEGF_GRID = 2,             /* play on grid boundary */
	DMUS_SEGF_BEAT = 3,             /* play on beat boundary */
	DMUS_SEGF_MEASURE = 4,  /* play on measure boundary */
	DMUS_SEGF_DEFAULT = 5,  /* use segment's default boundary */
	DMUS_SEGF_NOW = 64,             /* play now (asap) */
	DMUS_SEGF_REFTIME = 16, /* time parameter is in reference time  */
	DMUS_SEGF_SECONDARY = 32,       /* secondary segment */
	DMUS_SEGF_QUEUE = 128,  /* queue at the end of the primary segment queue (primary only) */
	DMUS_SEGF_CONTROL = 256 /* play as a control track (secondary segments only) */
} DMUS_SEGF_FLAGS;

/* The following flags are sent in the IDirectMusicTrack::Play() method */
/* inside the dwFlags parameter */
typedef enum enumDMUS_TRACKF_FLAGS
{
	DMUS_TRACKF_SEEK = 1,           /* set on a seek */
	DMUS_TRACKF_LOOP = 2,           /* set on a loop (repeat) */
	DMUS_TRACKF_START = 4,          /* set on first call to Play */
	DMUS_TRACKF_FLUSH = 8           /* set when this call is in response to a flush on the perfomance */
} DMUS_TRACKF_FLAGS;

#define DMUS_MAXSUBCHORD 8

/* DMUS_NOTE_PMSG */
typedef struct _DMUS_NOTE_PMSG
{
	/* begin DMUS_PMSG_PART */
	DMUS_PMSG_PART
	/* end DMUS_PMSG_PART */

	MUSIC_TIME      mtDuration;     /* duration */
    WORD        wMusicValue;            /* Description of note in chord and key. */
	WORD    wMeasure;                       /* Measure in which this note occurs */
	short   nOffset;                        /* Offset from grid at which this note occurs */
	BYTE    bBeat;                  /* Beat (in measure) at which this note occurs */
	BYTE    bGrid;                  /* Grid offset from beat at which this note occurs */
	BYTE    bVelocity;              /* Note velocity */
    BYTE        bFlags;                 /* see DMUS_NOTE_FLAGS */
    BYTE    bTimeRange;       /* Range to randomize time. */
    BYTE    bDurRange;        /* Range to randomize duration. */
    BYTE    bVelRange;        /* Range to randomize velocity. */
	BYTE    bInversionID;           /* Identifies inversion group to which this note belongs */
	BYTE    bPlayModeFlags; /* Play mode */
	BYTE    bMidiValue;             /* The MIDI note value, converted from wMusicValue */
} DMUS_NOTE_PMSG;

typedef enum enumDMUS_NOTEF_FLAGS
{
	DMUS_NOTEF_NOTEON = 1,          /* Set if this is a MIDI Note On. Otherwise, it is MIDI Note Off */
} DMUS_NOTEF_FLAGS;

/* DMUS_MIDI_PMSG */
typedef struct _DMUS_MIDI_PMSG
{
	/* begin DMUS_PMSG_PART */
	DMUS_PMSG_PART
	/* end DMUS_PMSG_PART */

	BYTE    bStatus;
	BYTE    bByte1;
	BYTE    bByte2;
	BYTE    bPad[1];
} DMUS_MIDI_PMSG;

/* DMUS_PATCH_PMSG */
typedef struct _DMUS_PATCH_PMSG
{
	/* begin DMUS_PMSG_PART */
	DMUS_PMSG_PART
	/* end DMUS_PMSG_PART */

	BYTE                                     byInstrument;
	BYTE                                     byMSB;
	BYTE                                     byLSB;
	BYTE                                     byPad[1];
	DWORD                                    dwGroup;
	DWORD                                    dwMChannel;
} DMUS_PATCH_PMSG;

/* DMUS_TRANSPOSE_PMSG */
typedef struct _DMUS_TRANSPOSE_PMSG
{
	/* begin DMUS_PMSG_PART */
	DMUS_PMSG_PART
	/* end DMUS_PMSG_PART */

	short   nTranspose;
} DMUS_TRANSPOSE_PMSG;

/* DMUS_TEMPO_PMSG */
typedef struct _DMUS_TEMPO_PMSG
{
	/* begin DMUS_PMSG_PART */
	DMUS_PMSG_PART
	/* end DMUS_PMSG_PART */

	double  dblTempo;                       /* the tempo */
} DMUS_TEMPO_PMSG;

#define DMUS_TEMPO_MAX  350
#define DMUS_TEMPO_MIN  10

#define DMUS_MASTERTEMPO_MAX    2.0
#define DMUS_MASTERTEMPO_MIN    0.25

#define DMUS_MASTERVOLUME_MAX   6
#define DMUS_MASTERVOLUME_MIN   -100

/* DMUS_SYSEX_PMSG */
typedef struct _DMUS_SYSEX_PMSG
{
	/* begin DMUS_PMSG_PART */
	DMUS_PMSG_PART
	/* end DMUS_PMSG_PART */

	DWORD   dwLen;  /* length of the data */
	BYTE    abData[1];      /* array of data, length equal to dwLen */
} DMUS_SYSEX_PMSG;

/* DMUS_CURVE_PMSG */
typedef struct _DMUS_CURVE_PMSG
{
	/* begin DMUS_PMSG_PART */
	DMUS_PMSG_PART
	/* end DMUS_PMSG_PART */

	MUSIC_TIME      mtDuration;     /* how long this curve lasts */
	MUSIC_TIME      mtOriginalStart;        /* must be set to either zero when this PMSG is created or to the original mtTime of the curve */
	MUSIC_TIME      mtResetDuration; /* how long after the curve is finished to reset to the
									   reset value, nResetValue */
	short           nStartValue;    /* curve's start value */
	short           nEndValue;              /* curve's end value */
	short           nResetValue;    /* curve's reset value, sent after mtResetDuration or
								   upon a flush or invalidation */
	WORD            wMeasure;               /* Measure in which this curve occurs */
	short           nOffset;                /* Offset from grid at which this curve occurs */
	BYTE            bBeat;                  /* Beat (in measure) at which this curve occurs */
	BYTE            bGrid;                  /* Grid offset from beat at which this curve occurs */
    BYTE                bType;                  /* type of curve */
	BYTE            bCurveShape;    /* shape of curve */
    BYTE                bCCData;                /* CC# if this is a control change type */
	BYTE            bFlags;                 /* set to 1 if the nResetValue must be sent when the 
								   time is reached or an invalidate occurs because
								   of a transition. If 0, the curve stays
								   permanently stuck at the new value. All bits besides
								   1 are reserved. */

} DMUS_CURVE_PMSG;

/* Curve shapes */
enum
{ 
	DMUS_CURVES_LINEAR = 0,
	DMUS_CURVES_INSTANT = 1,
	DMUS_CURVES_EXP = 2,
	DMUS_CURVES_LOG = 3,
	DMUS_CURVES_SINE = 4
};
/* curve types */
#define DMUS_CURVET_PBCURVE                     0x03
#define DMUS_CURVET_CCCURVE                     0x04
#define DMUS_CURVET_MATCURVE            0x05
#define DMUS_CURVET_PATCURVE            0x06

/* DMUS_TIMESIG_PMSG */
typedef struct _DMUS_TIMESIG_PMSG
{
	/* begin DMUS_PMSG_PART */
	DMUS_PMSG_PART
	/* end DMUS_PMSG_PART */

	/* Time signatures define how many beats per measure, which note receives */
	/* the beat, and the grid resolution. */
	BYTE    bBeatsPerMeasure;               /* beats per measure (top of time sig) */
	BYTE    bBeat;                          /* what note receives the beat (bottom of time sig.) */
									/* we can assume that 0 means 256th note */
	WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIG_PMSG;

/* notification type values */
/* The following correspond to GUID_NOTIFICATION_SEGMENT */
#define DMUS_NOTIFICATION_SEGSTART 0
#define DMUS_NOTIFICATION_SEGEND        1
#define DMUS_NOTIFICATION_SEGALMOSTEND  2
#define DMUS_NOTIFICATION_MUSICSTOPPED  3
#define DMUS_NOTIFICATION_SEGLOOP       4
/* The following corresponds to GUID_NOTIFICATION_MEASUREANDBEAT */
#define DMUS_NOTIFICATION_MEASUREBEAT   0

/* DMUS_NOTIFICATION_PMSG */
typedef struct _DMUS_NOTIFICATION_PMSG
{
	/* begin DMUS_PMSG_PART */
	DMUS_PMSG_PART
	/* end DMUS_PMSG_PART */

	GUID    guidNotificationType;
	DWORD   dwNotificationOption;
	DWORD   dwField1;
	DWORD   dwField2;
} DMUS_NOTIFICATION_PMSG;

/* Time Signature structure, used by IDirectMusicStyle */
typedef struct _DMUS_TIMESIGNATURE
{
	long    lTime;
	BYTE    bBeatsPerMeasure;               /* beats per measure (top of time sig) */
	BYTE    bBeat;                          /* what note receives the beat (bottom of time sig.) */
									/* we can assume that 0 means 256th note */
	WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIGNATURE;


#define DMUS_MAX_NAME           64              /* Maximum object name length. */
#define DMUS_MAX_CATEGORY       64              /* Maximum object category name length. */
#define DMUS_MAX_FILENAME       MAX_PATH
	
typedef struct _DMUS_VERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DMUS_VERSION, FAR *LPDMUS_VERSION;

/*      The DMUSOBJECTDESC structure is used to communicate everything you could */
/*      possibly use to describe a DirectMusic object.  */

typedef struct _DMUS_OBJECTDESC
{
	DWORD                   dwSize;                         /* Size of this structure. */
	DWORD                   dwValidData;            /* Flags indicating which fields below are valid. */
	GUID                    guidObject;                     /* Unique ID for this object. */
	GUID                    guidClass;                      /* GUID for the class of object. */
	FILETIME                ftDate;                         /* Last edited date of object. */
	DMUS_VERSION    vVersion;                       /* Version. */
	WCHAR                   wszName[DMUS_MAX_NAME]; /* Name of object.       */
	WCHAR                   wszCategory[DMUS_MAX_CATEGORY]; /* Category for object (optional). */
	WCHAR                   wszFileName[DMUS_MAX_FILENAME]; /* File path. */
} DMUS_OBJECTDESC;

typedef DMUS_OBJECTDESC *LPDMUS_OBJECTDESC;

/*      Flags for dwValidData. When set, a flag indicates that the  */
/*      corresponding field in DMUSOBJECTDESC holds valid data. */

#define DMUS_OBJ_OBJECT         (1 << 0)                /* Object GUID is valid. */
#define DMUS_OBJ_CLASS          (1 << 1)                /* Class GUID is valid. */
#define DMUS_OBJ_NAME           (1 << 2)                /* Name is valid. */
#define DMUS_OBJ_CATEGORY       (1 << 3)                /* Category is valid. */
#define DMUS_OBJ_FILENAME       (1 << 4)                /* File path is valid. */
#define DMUS_OBJ_FULLPATH       (1 << 5)                /* Path is full path. */
#define DMUS_OBJ_URL            (1 << 6)                /* Path is URL. */
#define DMUS_OBJ_VERSION        (1 << 7)                /* Version is valid. */
#define DMUS_OBJ_DATE           (1 << 8)                /* Date is valid. */
#define DMUS_OBJ_LOADED         (1 << 9)                /* Object is currently loaded in memory. */


typedef IDirectMusicObject __RPC_FAR *LPDMUS_OBJECT;
typedef IDirectMusicLoader __RPC_FAR *LPDMUS_LOADER;
typedef IDirectMusicBand __RPC_FAR *LPDMUS_BAND;


#define DMUSB_LOADED    (1 << 0)        /* Set when band has been loaded */
#define DMUSB_DEFAULT   (1 << 1)        /* Set when band is default band for a style */

#undef  INTERFACE
#define INTERFACE  IDirectMusicBand
DECLARE_INTERFACE_(IDirectMusicBand, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicBand */
	STDMETHOD(CreateSegment)        (THIS_ IDirectMusicSegment** ppSegment) PURE;
	STDMETHOD(Download)             (THIS_ IDirectMusicPerformance* pPerformance) PURE;     
	STDMETHOD(Unload)               (THIS_ IDirectMusicPerformance* pPerformance) PURE;     
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicObject
DECLARE_INTERFACE_(IDirectMusicObject, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicObject */
	STDMETHOD(GetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
	STDMETHOD(SetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
	STDMETHOD(ParseDescriptor)      (THIS_ LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicLoader
DECLARE_INTERFACE_(IDirectMusicLoader, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicLoader */
	STDMETHOD(GetObject)            (THIS_ IDirectMusicObject **ppObject,LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetSearchDirectory)   (THIS_ REFGUID rguidClass, WCHAR *pwzPath, BOOL fClear) PURE;
	STDMETHOD(ScanDirectory)		(THIS_ REFGUID rguidClass, WCHAR *pwzFileExtension, WCHAR *pwzScanFileName) PURE;
	STDMETHOD(CacheObject)          (THIS_ IDirectMusicObject * pObject) PURE;
	STDMETHOD(ReleaseObject)        (THIS_ IDirectMusicObject * pObject) PURE;
	STDMETHOD(ClearCache)           (THIS_ REFGUID rguidClass) PURE;
	STDMETHOD(EnableCache)          (THIS_ REFGUID rguidClass, BOOL fEnable) PURE;
	STDMETHOD(EnumObject)           (THIS_ REFGUID rguidClass, DWORD dwIndex, LPDMUS_OBJECTDESC pDesc) PURE;
};									

/*	Stream object supports IDirectMusicGetLoader interface to access loader while file parsing. */

#undef  INTERFACE
#define INTERFACE  IDirectMusicGetLoader
DECLARE_INTERFACE_(IDirectMusicGetLoader, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicGetLoader */
	STDMETHOD(GetLoader)            (THIS_ IDirectMusicLoader ** ppLoader) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicSegment */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegment
DECLARE_INTERFACE_(IDirectMusicSegment, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/*  IDirectMusicSegment */
	STDMETHOD(GetLength)                    (THIS_ MUSIC_TIME* pmtLength) PURE;
	STDMETHOD(SetLength)                    (THIS_ MUSIC_TIME mtLength) PURE;
	STDMETHOD(GetRepeats)                   (THIS_ DWORD* pdwRepeats) PURE;
	STDMETHOD(SetRepeats)                   (THIS_ DWORD  dwRepeats) PURE;
	STDMETHOD(GetDefaultResolution) (THIS_ DWORD* pdwResolution) PURE;
	STDMETHOD(SetDefaultResolution) (THIS_ DWORD  dwResolution) PURE;
	STDMETHOD(GetTrack)                             (THIS_ REFGUID rguidType, DWORD dwGroupBits, DWORD dwIndex, IDirectMusicTrack** ppTrack) PURE;
	STDMETHOD(InsertTrack)                  (THIS_ IDirectMusicTrack* pTrack, DWORD dwGroupBits) PURE;
	STDMETHOD(RemoveTrack)                  (THIS_ IDirectMusicTrack* pTrack) PURE;
	STDMETHOD(InitPlay)                             (THIS_ IDirectMusicSegmentState** ppSegState, IDirectMusicPerformance* pPerformance) PURE;
	STDMETHOD(GetGraph)                             (THIS_ IDirectMusicGraph** ppGraph) PURE;
	STDMETHOD(SetGraph)                             (THIS_ IDirectMusicGraph* pGraph) PURE;
	STDMETHOD(AddNotificationType)  (THIS_ REFGUID rguidNotificationType) PURE;
	STDMETHOD(RemoveNotificationType)                       (THIS_ REFGUID rguidNotificationType) PURE;
	STDMETHOD(GetParam)                             (THIS_ REFGUID rguidType, DWORD dwGroupBits, DWORD dwIndex, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pParam) PURE; 
	STDMETHOD(SetParam)                             (THIS_ REFGUID rguidType, DWORD dwGroupBits, DWORD dwIndex, MUSIC_TIME mtTime, void* pParam) PURE;
	STDMETHOD(Clone)                                (THIS_ MUSIC_TIME mtStart, MUSIC_TIME mtEnd, IDirectMusicSegment** ppSegment) PURE;
	STDMETHOD(SetStartPoint)                (THIS_ MUSIC_TIME mtStart) PURE;
	STDMETHOD(GetStartPoint)                (THIS_ MUSIC_TIME* pmtStart) PURE;
	STDMETHOD(SetLoopPoints)                (THIS_ MUSIC_TIME mtStart, MUSIC_TIME mtEnd) PURE;
	STDMETHOD(GetLoopPoints)                (THIS_ MUSIC_TIME* pmtStart, MUSIC_TIME* pmtEnd) PURE;
	STDMETHOD(SetPChannelsUsed)             (THIS_ DWORD dwNumPChannels, DWORD* paPChannels) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegmentState
DECLARE_INTERFACE_(IDirectMusicSegmentState, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/*  IDirectMusicSegmentState */
	STDMETHOD(GetRepeats)                   (THIS_ DWORD* pdwRepeats) PURE;
	STDMETHOD(GetSegment )                  (THIS_ IDirectMusicSegment** ppSegment) PURE;
	STDMETHOD(GetStartTime)                 (THIS_ MUSIC_TIME* pmtStart) PURE;
	STDMETHOD(GetSeek)                      (THIS_ MUSIC_TIME* pmtSeek) PURE;
	STDMETHOD(GetStartPoint)                (THIS_ MUSIC_TIME* pmtStart) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTrack */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTrack
DECLARE_INTERFACE_(IDirectMusicTrack, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/*  IDirectMusicTrack */
	STDMETHOD(Init)                                 (THIS_ IDirectMusicSegment* pSegment) PURE;
	STDMETHOD(InitPlay)                             (THIS_ IDirectMusicSegmentState* pSegmentState, IDirectMusicPerformance* pPerformance, void** ppStateData, DWORD dwVirtualTrackID) PURE;
	STDMETHOD(EndPlay)                              (THIS_ void* pStateData) PURE;
	STDMETHOD(Play)                                 (THIS_ void* pStateData, MUSIC_TIME mtStart, MUSIC_TIME mtEnd, MUSIC_TIME mtOffset, DWORD dwFlags, IDirectMusicPerformance* pPerf, IDirectMusicSegmentState* pSegSt, DWORD dwVirtualID) PURE;
	STDMETHOD(GetParam)                             (THIS_ REFGUID rguidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pParam) PURE; 
	STDMETHOD(SetParam)                             (THIS_ REFGUID rguidType, MUSIC_TIME mtTime, void* pParam) PURE;
	STDMETHOD(IsParamSupported)             (THIS_ REFGUID rguidType) PURE;
	STDMETHOD(AddNotificationType)  (THIS_ REFGUID rguidNotificationType) PURE;
	STDMETHOD(RemoveNotificationType) (THIS_ REFGUID rguidNotificationType) PURE;
	STDMETHOD(Clone)                                (THIS_ MUSIC_TIME mtStart, MUSIC_TIME mtEnd, IDirectMusicTrack** ppTrack) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance */
#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformance
DECLARE_INTERFACE_(IDirectMusicPerformance, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/*  IDirectMusicPerformance */
	STDMETHOD(Init)                                 (THIS_ IDirectMusic** ppDirectMusic) PURE;
	STDMETHOD(PlaySegment)                  (THIS_ IDirectMusicSegment*     pSegment, DWORD dwFlags, REFERENCE_TIME rtStartTime, IDirectMusicSegmentState** ppSegmentState) PURE;
	STDMETHOD(Stop)                                 (THIS_ IDirectMusicSegment*     pSegment, IDirectMusicSegmentState* pSegmentState, MUSIC_TIME mtTime, DWORD dwFlags) PURE;
	STDMETHOD(GetSegmentState)              (THIS_ IDirectMusicSegmentState** ppSegmentState, MUSIC_TIME mtTime) PURE;
	STDMETHOD(SetPrepareTime)               (THIS_ DWORD dwMilliSeconds) PURE;
	STDMETHOD(GetPrepareTime)               (THIS_ DWORD* pdwMilliSeconds) PURE;
	STDMETHOD(SetBumperLength)              (THIS_ DWORD dwMilliSeconds) PURE;
	STDMETHOD(GetBumperLength)              (THIS_ DWORD* pdwMilliSeconds) PURE;
	STDMETHOD(SendPMsg)                             (THIS_ DMUS_PMSG* pPMSG) PURE;
	STDMETHOD(MusicToReferenceTime) (THIS_ MUSIC_TIME mtTime, REFERENCE_TIME* prtTime) PURE;
	STDMETHOD(ReferenceToMusicTime) (THIS_ REFERENCE_TIME rtTime, MUSIC_TIME* pmtTime) PURE;
    STDMETHOD(IsPlaying)                        (THIS_ IDirectMusicSegment* pSegment, IDirectMusicSegmentState* pSegState) PURE;
	STDMETHOD(GetTime)                              (THIS_ REFERENCE_TIME* prtNow, MUSIC_TIME* pmtNow) PURE;
	STDMETHOD(AllocPMsg)                    (THIS_ ULONG cb, DMUS_PMSG** ppPMSG) PURE;
	STDMETHOD(FreePMsg)                             (THIS_ DMUS_PMSG* pPMSG) PURE;
	STDMETHOD(GetGraph)                             (THIS_ IDirectMusicGraph** ppGraph) PURE;
	STDMETHOD(SetGraph)                             (THIS_ IDirectMusicGraph* pGraph) PURE;
	STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hNotification, REFERENCE_TIME rtMinimum) PURE;
	STDMETHOD(GetNotificationPMsg)  (THIS_ DMUS_NOTIFICATION_PMSG** ppNotificationPMsg) PURE;
	STDMETHOD(AddNotificationType)  (THIS_ REFGUID rguidNotificationType) PURE;
	STDMETHOD(RemoveNotificationType)(THIS_ REFGUID rguidNotificationType) PURE;
	STDMETHOD(AddPort)                              (THIS_ IDirectMusicPort* pPort) PURE;
	STDMETHOD(RemovePort)                   (THIS_ IDirectMusicPort* pPort ) PURE;
	STDMETHOD(AssignPChannelBlock)  (THIS_ DWORD dwBlockNum, IDirectMusicPort* pPort, DWORD dwGroup ) PURE;
	STDMETHOD(AssignPChannel)               (THIS_ DWORD dwPChannel, IDirectMusicPort* pPort, DWORD dwGroup, DWORD dwMChannel ) PURE;
	STDMETHOD(PChannelInfo)                 (THIS_ DWORD dwPChannel, IDirectMusicPort** ppPort, DWORD* pdwGroup, DWORD* pdwMChannel ) PURE;
	STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument* pInst, DWORD dwPChannel, IDirectMusicDownloadedInstrument** ppDownInst, DMUS_NOTERANGE* pNoteRanges, DWORD dwNumNoteRanges, IDirectMusicPort** ppPort, DWORD* pdwGroup, DWORD* pdwMChannel ) PURE;
	STDMETHOD(Invalidate)                   (THIS_ MUSIC_TIME mtTime, DWORD dwFlags) PURE;
	STDMETHOD(GetParam)                             (THIS_ REFGUID rguidType, DWORD dwGroupBits, DWORD dwIndex, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pParam) PURE; 
	STDMETHOD(SetParam)                             (THIS_ REFGUID rguidType, DWORD dwGroupBits, DWORD dwIndex, MUSIC_TIME mtTime, void* pParam) PURE;
	STDMETHOD(GetGlobalParam)               (THIS_ REFGUID rguidType, void* pParam, DWORD dwSize) PURE;
	STDMETHOD(SetGlobalParam)               (THIS_ REFGUID rguidType, void* pParam, DWORD dwSize) PURE;
	STDMETHOD(GetLatencyTime)               (THIS_ REFERENCE_TIME* prtTime) PURE;
	STDMETHOD(GetQueueTime)                 (THIS_ REFERENCE_TIME* prtTime) PURE;
	STDMETHOD(AdjustTime)                   (THIS_ REFERENCE_TIME rtAmount) PURE;
	STDMETHOD(CloseDown)                    (THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTool */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTool
DECLARE_INTERFACE_(IDirectMusicTool, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/*  IDirectMusicTool */
	STDMETHOD(Init)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
	STDMETHOD(GetMsgDeliveryType)   (THIS_ DWORD* pdwDeliveryType ) PURE;
	STDMETHOD(GetMediaTypeArraySize)(THIS_ DWORD* pdwNumElements ) PURE;
	STDMETHOD(GetMediaTypes)        (THIS_ DWORD** padwMediaTypes, DWORD dwNumElements) PURE;
	STDMETHOD(ProcessPMsg)          (THIS_ IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG) PURE;
	STDMETHOD(Flush)                (THIS_ IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG, REFERENCE_TIME rtTime) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicGraph */
#undef  INTERFACE
#define INTERFACE  IDirectMusicGraph
DECLARE_INTERFACE_(IDirectMusicGraph, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/*  IDirectMusicGraph */
	STDMETHOD(StampPMsg)                    (THIS_ DMUS_PMSG* pPMSG) PURE;
	STDMETHOD(Shutdown)                             (THIS) PURE;
	STDMETHOD(InsertTool)                   (THIS_ IDirectMusicTool* pTool, DWORD* pdwPChannels, DWORD cPChannels, LONG lIndex) PURE;
	STDMETHOD(GetTool)                              (THIS_ DWORD dwIndex, IDirectMusicTool** ppTool) PURE;
	STDMETHOD(RemoveTool)                   (THIS_ IDirectMusicTool* pTool) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicStyle */
#undef  INTERFACE
#define INTERFACE  IDirectMusicStyle
DECLARE_INTERFACE_(IDirectMusicStyle, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/*  IDirectMusicStyle */
	STDMETHOD(GetBand)                              (THIS_ WCHAR* pwszName, IDirectMusicBand** ppBand) PURE;
	STDMETHOD(EnumBand)                             (THIS_ DWORD dwIndex, WCHAR *pwszName) PURE;
	STDMETHOD(GetDefaultBand)               (THIS_ IDirectMusicBand** ppBand) PURE;
	STDMETHOD(EnumMotif)                    (THIS_ DWORD dwIndex, WCHAR* pwszName) PURE;
	STDMETHOD(GetMotif)                             (THIS_ WCHAR* pwszName, IDirectMusicSegment** ppSegment) PURE;
	STDMETHOD(GetDefaultPersonality)(THIS_ IDirectMusicPersonality** ppPersonality) PURE;
	STDMETHOD(EnumPersonality)              (THIS_ DWORD dwIndex, WCHAR *pwszName) PURE;
	STDMETHOD(GetPersonality)               (THIS_ WCHAR* pwszName, IDirectMusicPersonality** ppPersonality) PURE;
	STDMETHOD(GetTimeSignature)             (THIS_ DMUS_TIMESIGNATURE* pTimeSig) PURE;
	STDMETHOD(GetEmbellishmentLength)       (THIS_ DWORD dwType, DWORD dwLevel, DWORD* pdwMin, DWORD* pdwMax) PURE;
	STDMETHOD(GetTempo)                             (THIS_ double* pTempo) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicPersonality */
#undef  INTERFACE
#define INTERFACE  IDirectMusicPersonality
DECLARE_INTERFACE_(IDirectMusicPersonality, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/*  IDirectMusicPersonality */
	STDMETHOD(GetScale)                             (THIS_ DWORD* pdwScale) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicComposer */
#undef  INTERFACE
#define INTERFACE  IDirectMusicComposer
DECLARE_INTERFACE_(IDirectMusicComposer, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/*  IDirectMusicComposer */
	STDMETHOD(ComposeSegmentFromTemplate)   (THIS_ IDirectMusicStyle* pStyle, IDirectMusicSegment* pTempSeg, WORD wActivity, IDirectMusicPersonality* pPersonality, IDirectMusicSegment** ppSectionSeg) PURE;
	STDMETHOD(ComposeSegmentFromShape)              (THIS_ IDirectMusicStyle* pStyle, WORD wNumMeasures, WORD wShape, WORD wActivity, BOOL fIntro, BOOL fEnd, IDirectMusicPersonality* pPersonality, IDirectMusicSegment** ppSectionSeg ) PURE;
	STDMETHOD(ComposeTransition)                    (THIS_ IDirectMusicSegment*     pFromSeg, IDirectMusicSegment* pToSeg, MUSIC_TIME mtTime, WORD wCommand, DWORD dwFlags, IDirectMusicPersonality* pPersonality, IDirectMusicSegment** ppSectionSeg) PURE;
	STDMETHOD(AutoTransition)                               (THIS_ IDirectMusicPerformance* pPerformance, IDirectMusicSegment* pToSeg, WORD wCommand, DWORD dwFlags, IDirectMusicPersonality* pPersonality, IDirectMusicSegment** ppTransSeg, IDirectMusicSegmentState** ppToSegState, IDirectMusicSegmentState** ppTransSegState) PURE;
	STDMETHOD(ComposeTemplateFromShape)             (THIS_ WORD wNumMeasures, WORD wShape, BOOL fIntro, BOOL fEnd, WORD wEndLength, IDirectMusicSegment** ppTempSeg) PURE;
	STDMETHOD(ChangePersonality)                    (THIS_ IDirectMusicSegment* pSectionSeg, BOOL fTrackScale, IDirectMusicPersonality* pPersonality) PURE;
};

/* CLSID's */
DEFINE_GUID(CLSID_DirectMusicPerformance,0xd2ac2881, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegment,0xd2ac2882, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegmentState,0xd2ac2883, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicGraph,0xd2ac2884, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyle,0xd2ac288a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicPersonality,0xd2ac288f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicComposer,0xd2ac2890, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicLoader,0xd2ac2892, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrk,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicPersonalityTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicAuditionTrack,0xd2ac2897, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Special GUID for all object types. This is used by the loader. */
DEFINE_GUID(GUID_DirectMusicAllTypes,0xd2ac2893, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Notification guids */
DEFINE_GUID(GUID_NOTIFICATION_SEGMENT,0xd2ac2899, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_MEASUREANDBEAT,0xd2ac289a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_CHORD,0xd2ac289b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_COMMANDANDGROOVE,0xd2ac289c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Track param type guids */
DEFINE_GUID(GUID_CommandTrack,0xd2ac289d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_ChordTrackChord,0xd2ac289e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_ChordTrackRhythm,0xd2ac289f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_StyleTrackRepeats,0xd2ac28a0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_StyleTrackStyle,0xd2ac28a1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_MotifTrack,0xd2ac28a2, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_SignPostTrack,0xd2ac28a3, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_TimeSigTrack,0xd2ac28a4, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_TempoTrack,0xd2ac28a5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_BandTrack,0xd2ac28a6, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_BandTrack_Download,0xd2ac28a7, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_BandTrack_Unload,0xd2ac28a8, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_BandTrack_Enable_Auto_Download,0xd2ac28a9, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_BandTrack_Disable_Auto_Download,0xd2ac28aa, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_BandTrack_Clear_All_Bands,0xd2ac28ab, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_BandTrack_AddBand,0xd2ac28ac, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PersonalityTrack,0xd2ac28ad, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_AuditionTrack,0xd2ac28ae, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_MuteTrack,0xd2ac28af, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Global data guids */
DEFINE_GUID(GUID_PerfMasterTempo,0xd2ac28b0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterVolume,0xd2ac28b1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterGrooveLevel,0xd2ac28b2, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* GUID for default GM/GS dls collection. */
DEFINE_GUID(GUID_DefaultGMCollection, 0xf17e8673, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* IID's */
DEFINE_GUID(IID_IDirectMusicLoader,0x68a04842, 0xd13d, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicGetLoader,0x68a04844, 0xd13d, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicObject,0xd2ac28b5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicSegment, 0xde5e3a31, 0xd31b, 0x11d1, 0xbc, 0x8b, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicSegmentState, 0xa3afdcc7, 0xd3ee, 0x11d1, 0xbc, 0x8d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicTrack, 0xde5e3a32, 0xd31b, 0x11d1, 0xbc, 0x8b, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicPerformance, 0xde5e3a33, 0xd31b, 0x11d1, 0xbc, 0x8b, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicTool,0xd2ac28ba, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicGraph,0x1ee21dc8, 0xc370, 0x11d1, 0xbc, 0x84, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicStyle,0xd2ac28bd, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicPersonality,0xd2ac28be, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicComposer,0xd2ac28bf, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicBand,0xd2ac28c0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* #ifndef _DMUSICI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\dmusicc.h ===
/*
 *
 */

#ifndef _DMUSICC_
#define _DMUSICC_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#include "dls1.h"

#ifdef __cplusplus
extern "C" {
#endif

#define FACILITY_DIRECTMUSIC    0x878       /* Shared with DirectSound */
#define DMUS_ERRBASE              0x1000      /* Make error codes human readable in hex */
    
#define MAKE_DMHRESULTSUCCESS(code)  MAKE_HRESULT(0, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))
#define MAKE_DMHRESULTERROR(code)  MAKE_HRESULT(1, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))

#define DMUS_S_CORE_ALREADY_DOWNLOADED		MAKE_DMHRESULTSUCCESS(0x090)
#define DMUS_S_IME_PARTIALLOAD				MAKE_DMHRESULTSUCCESS(0x091)

#define DMUS_E_CORE_NO_DRIVER               MAKE_DMHRESULTERROR(0x0100)
#define DMUS_E_CORE_DRIVER_FAILED           MAKE_DMHRESULTERROR(0x0101)
#define DMUS_E_CORE_PORTS_OPEN              MAKE_DMHRESULTERROR(0x0102)
#define DMUS_E_CORE_DEVICE_IN_USE           MAKE_DMHRESULTERROR(0x0103)
#define DMUS_E_CORE_INSUFFICIENTBUFFER		MAKE_DMHRESULTERROR(0x0104)
#define DMUS_E_CORE_BUFFERNOTSET			MAKE_DMHRESULTERROR(0x0105)
#define DMUS_E_CORE_BUFFERNOTAVAILABLE		MAKE_DMHRESULTERROR(0x0106)
#define DMUS_E_CORE_NOTINITED				MAKE_DMHRESULTERROR(0x0107)
#define DMUS_E_CORE_NOTADLSCOL				MAKE_DMHRESULTERROR(0x0108)
#define DMUS_E_CORE_INVALIDOFFSET			MAKE_DMHRESULTERROR(0x0109)
#define DMUS_E_CORE_INVALIDID				MAKE_DMHRESULTERROR(0x0110)
#define DMUS_E_CORE_ALREADY_LOADED			MAKE_DMHRESULTERROR(0x0111)
#define DMUS_E_CORE_INVALIDPOS				MAKE_DMHRESULTERROR(0x0113)
#define DMUS_E_CORE_INVALIDPATCH			MAKE_DMHRESULTERROR(0x0114)
#define DMUS_E_CORE_CANNOTSEEK				MAKE_DMHRESULTERROR(0x0115)
#define DMUS_E_CORE_CANNOTWRITE				MAKE_DMHRESULTERROR(0x0116)
#define DMUS_E_CORE_CHUNKNOTFOUND			MAKE_DMHRESULTERROR(0x0117)
#define DMUS_E_CORE_CHUNKNOTFOUNDINPARENT	MAKE_DMHRESULTERROR(0x0118)
#define DMUS_E_CORE_INVALID_DOWNLOADID		MAKE_DMHRESULTERROR(0x0119)
#define DMUS_E_CORE_NOT_DOWNLOADED_TO_PORT	MAKE_DMHRESULTERROR(0x0120)
#define DMUS_E_CORE_ALREADY_DOWNLOADED		MAKE_DMHRESULTERROR(0x0121)
#define DMUS_E_CORE_UNKNOWN_PROPERTY		MAKE_DMHRESULTERROR(0x0122)
#define DMUS_E_CORE_SET_UNSUPPORTED			MAKE_DMHRESULTERROR(0x0123)
#define DMUS_E_CORE_GET_UNSUPPORTED			MAKE_DMHRESULTERROR(0x0124)
#define DMUS_E_CORE_NOTMONO					MAKE_DMHRESULTERROR(0x0125)
#define DMUS_E_CORE_BADARTICULATION			MAKE_DMHRESULTERROR(0x0126)
#define DMUS_E_CORE_BADINSTRUMENT			MAKE_DMHRESULTERROR(0x0127)
#define DMUS_E_CORE_BADWAVELINK				MAKE_DMHRESULTERROR(0x0128)
#define DMUS_E_CORE_NOARTICULATION			MAKE_DMHRESULTERROR(0x0129)
#define DMUS_E_CORE_NOTPCM					MAKE_DMHRESULTERROR(0x012A)
#define DMUS_E_CORE_BADWAVE					MAKE_DMHRESULTERROR(0x012B)
#define DMUS_E_CORE_BADOFFSETTABLE			MAKE_DMHRESULTERROR(0x012C)
#define DMUS_E_CORE_UNKNOWNDOWNLOAD			MAKE_DMHRESULTERROR(0x012D)
#define DMUS_E_CORE_NOSYNTHSINK				MAKE_DMHRESULTERROR(0x012E)
#define DMUS_E_CORE_ALREADYOPEN				MAKE_DMHRESULTERROR(0x012F)
#define DMUS_E_CORE_ALREADYCLOSED			MAKE_DMHRESULTERROR(0x0130)
#define DMUS_E_CORE_SYNTHNOTCONFIGURED		MAKE_DMHRESULTERROR(0x0131)

#define DMUS_E_IME_UNSUPPORTED_STREAM		MAKE_DMHRESULTERROR(0x0150)
#define	DMUS_E_IME_ALREADY_INITED			MAKE_DMHRESULTERROR(0x0151)
#define DMUS_E_IME_INVALID_BAND				MAKE_DMHRESULTERROR(0x0152)
#define DMUS_E_IME_CANNOT_ADD_AFTER_INITED	MAKE_DMHRESULTERROR(0x0153)
#define DMUS_E_IME_NOT_INITED				MAKE_DMHRESULTERROR(0x0154)
#define DMUS_E_IME_TRACK_HDR_NOT_FIRST_CK	MAKE_DMHRESULTERROR(0x0155)
#define DMUS_E_IME_TOOL_HDR_NOT_FIRST_CK	MAKE_DMHRESULTERROR(0x0156)
#define DMUS_E_IME_INVALID_TRACK_HDR		MAKE_DMHRESULTERROR(0x0157)
#define DMUS_E_IME_INVALID_TOOL_HDR			MAKE_DMHRESULTERROR(0x0158)
#define DMUS_E_IME_ALL_TOOLS_FAILED			MAKE_DMHRESULTERROR(0x0159)
#define DMUS_E_IME_ALL_TRACKS_FAILED		MAKE_DMHRESULTERROR(0x0160)

#define DMUS_E_NO_MASTER_CLOCK				MAKE_DMHRESULTERROR(0x0160)

#define DMUS_E_LOADER_NOCLASSID				MAKE_DMHRESULTERROR(0x0170)
#define DMUS_E_LOADER_BADPATH				MAKE_DMHRESULTERROR(0x0171)
#define DMUS_E_LOADER_FAILEDOPEN			MAKE_DMHRESULTERROR(0x0172)
#define DMUS_E_LOADER_FORMATNOTSUPPORTED	MAKE_DMHRESULTERROR(0x0173)

#define DMUS_MAX_DESCRIPTION 128
#define DMUS_MAX_DRIVER 128

#define DMUS_PC_INPUTCLASS       (0)
#define DMUS_PC_OUTPUTCLASS      (1)

#define DMUS_PC_DLS              (0x00000001)
#define DMUS_PC_EXTERNAL         (0x00000002)
#define DMUS_PC_SOFTWARESYNTH    (0x00000004)
#define DMUS_PC_MEMORYSIZEFIXED  (0x00000008)
#define DMUS_PC_GMINHARDWARE     (0x00000010)
#define DMUS_PC_GSINHARDWARE     (0x00000020)
#define DMUS_PC_REVERB           (0x00000040)
#define DMUS_PC_SYSTEMMEMORY     (0x7FFFFFFF)

typedef struct _DMUS_BUFFERDESC *LPDMUS_BUFFERDESC;
typedef struct _DMUS_BUFFERDESC{
    DWORD dwSize;
    DWORD dwFlags;
    GUID guidBufferFormat;
    DWORD cbBuffer;
} DMUS_BUFFERDESC;

	
typedef struct _DMUS_PORTCAPS *LPDMUS_PORTCAPS;
typedef struct _DMUS_PORTCAPS
{
	DWORD   dwSize;
    DWORD   dwFlags;
    GUID    guidPort;
    DWORD   dwClass;
    DWORD   dwMemorySize;
    DWORD   dwMaxChannelGroups;
	DWORD   dwMaxVoices;	
    WCHAR   wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_PORTCAPS;

typedef struct _DMUS_PORTPARAMS *LPDMUS_PORTPARAMS;
typedef struct _DMUS_PORTPARAMS
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    BOOL    fStereo;
    DWORD   dwSampleRate;
    BOOL    fReverb;
} DMUS_PORTPARAMS;

/* These flags (set in dwValidParams) indicate which other members of the */
/* DMOPENDESC are valid. */
/* */
#define DMUS_PORTPARAMS_VOICES           0x00000001
#define DMUS_PORTPARAMS_CHANNELGROUPS    0x00000002
#define DMUS_PORTPARAMS_STEREO           0x00000004
#define DMUS_PORTPARAMS_SAMPLERATE       0x00000008
#define DMUS_PORTPARAMS_REVERB           0x00000010

typedef struct _DMUS_SYNTHSTATS *LPDMUS_SYNTHSTATS;
typedef struct _DMUS_SYNTHSTATS
{
    DWORD   dwSize;             /* Size in bytes of the structure */
	DWORD	dwValidStats;		/* Flags indicating which fields below are valid. */
    DWORD	dwVoices;			/* Average number of voices playing. */
	DWORD	dwTotalCPU;			/* Total CPU usage as percent * 100. */
	DWORD	dwCPUPerVoice;		/* CPU per voice as percent * 100. */
    DWORD	dwLostNotes;		/* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long	lPeakVolume;		/* Decibel level * 100. */
} DMUS_SYNTHSTATS;

#define DMUS_SYNTHSTATS_VOICES			(1 << 0)
#define DMUS_SYNTHSTATS_TOTAL_CPU       (1 << 1)
#define DMUS_SYNTHSTATS_CPU_PER_VOICE   (1 << 2)
#define DMUS_SYNTHSTATS_LOST_NOTES		(1 << 3)
#define DMUS_SYNTHSTATS_PEAK_VOLUME		(1 << 4)
#define DMUS_SYNTHSTATS_FREE_MEMORY		(1 << 5)

#define DMUS_SYNTHSTATS_SYSTEMMEMORY	DMUS_PC_SYSTEMMEMORY

typedef enum
{
    DMUS_CLOCK_SYSTEM = 0,
    DMUS_CLOCK_WAVE = 1
} DMUS_CLOCKTYPE;

typedef struct _DMUS_CLOCKINFO *LPDMUS_CLOCKINFO;
typedef struct _DMUS_CLOCKINFO
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_CLOCKINFO;

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

#define DMUS_EVENTCLASS_CHANNELMSG (0x00000000)
#define DMUS_EVENTCLASS_SYSEX      (0x00000001)

typedef long PCENT;		/* Pitch cents */
typedef long GCENT;		/* Gain cents */
typedef long TCENT;		/* Time cents */
typedef long PERCENT;	/* Per.. cent! */

typedef struct _DMUS_DOWNLOADINFO
{
	DWORD dwDLType;
	DWORD dwDLId;
	DWORD dwNumOffsetTableEntries;
	DWORD cbSizeData;
} DMUS_DOWNLOADINFO;

#define DMUS_DOWNLOADINFO_INSTRUMENT	1
#define DMUS_DOWNLOADINFO_WAVE			2

#define DMUS_DEFAULT_SIZE_OFFSETTABLE	1

/* Flags for DMUS_INSTRUMENT's ulFlags member */
 
#define DMUS_INSTRUMENT_GM_INSTRUMENT	(1 << 0)

typedef struct _DMUS_OFFSETTABLE
{
	ULONG ulOffsetTable[DMUS_DEFAULT_SIZE_OFFSETTABLE];
} DMUS_OFFSETTABLE;

typedef struct _DMUS_INSTRUMENT
{
	ULONG           ulPatch;
	ULONG           ulFirstRegionIdx;             
	ULONG           ulGlobalArtIdx;               /* If zero the instrument does not have an articulation */
	ULONG           ulFirstExtCkIdx;              /* If zero no 3rd party entenstion chunks associated with the instrument */
	ULONG           ulCopyrightIdx;               /* If zero no Copyright information associated with the instrument */
	ULONG			ulFlags;					   	
} DMUS_INSTRUMENT;

typedef struct _DMUS_REGION
{
	RGNRANGE        RangeKey;
	RGNRANGE        RangeVelocity;
	USHORT          fusOptions;
	USHORT          usKeyGroup;
	ULONG           ulRegionArtIdx;               /* If zero the region does not have an articulation */
	ULONG           ulNextRegionIdx;              /* If zero no more regions */
	ULONG           ulFirstExtCkIdx;              /* If zero no 3rd party entenstion chunks associated with the region */
	WAVELINK        WaveLink;
	WSMPL           WSMP;                         /*  If WSMP.cSampleLoops > 1 then a WLOOP is included */
	WLOOP           WLOOP[1];
} DMUS_REGION;

typedef struct _DMUS_LFOPARAMS
{
    PCENT       pcFrequency;
    TCENT       tcDelay;
    GCENT       gcVolumeScale;
    PCENT       pcPitchScale;
    GCENT       gcMWToVolume;
    PCENT       pcMWToPitch;
} DMUS_LFOPARAMS;

typedef struct _DMUS_VEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
} DMUS_VEGPARAMS;

typedef struct _DMUS_PEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
    PCENT       pcRange;
} DMUS_PEGPARAMS;

typedef struct _DMUS_MSCPARAMS
{
    PERCENT     ptDefaultPan;
} DMUS_MSCPARAMS;

typedef struct _DMUS_ARTICPARAMS
{
    DMUS_LFOPARAMS   LFO;
    DMUS_VEGPARAMS   VolEG;
    DMUS_PEGPARAMS   PitchEG;
    DMUS_MSCPARAMS   Misc;
} DMUS_ARTICPARAMS;

typedef struct _DMUS_ARTICULATION
{
	ULONG           ulArt1Idx;					/* If zero no DLS Level 1 articulation chunk */
	ULONG           ulFirstExtCkIdx;              /* If zero no 3rd party entenstion chunks associated with the articulation */
} DMUS_ARTICULATION;

#define DMUS_MIN_DATA_SIZE 4       
/*  The actual number is determined by cbSize of struct _DMUS_EXTENSIONCHUNK */

typedef struct _DMUS_EXTENSIONCHUNK
{
	ULONG           cbSize;						/*  Size of extension chunk  */
	ULONG           ulNextExtCkIdx;               /*  If zero no more 3rd party entenstion chunks */
	FOURCC          ExtCkID;                                      
	BYTE            byExtCk[DMUS_MIN_DATA_SIZE]; /*  The actual number that follows is determined by cbSize */
} DMUS_EXTENSIONCHUNK;

/*  The actual number is determined by cbSize of struct _DMUS_COPYRIGHT */

typedef struct _DMUS_COPYRIGHT
{
	ULONG           cbSize;										/*  Size of copyright information */
	BYTE            byCopyright[DMUS_MIN_DATA_SIZE];       /*  The actual number that follows is determined by cbSize */
} DMUS_COPYRIGHT;

typedef struct _DMUS_WAVEDATA
{
	ULONG			cbSize;
	BYTE			byData[DMUS_MIN_DATA_SIZE];	
} DMUS_WAVEDATA;

typedef struct _DMUS_WAVE
{
	ULONG           ulFirstExtCkIdx;	/* If zero no 3rd party entenstion chunks associated with the wave */
	ULONG           ulCopyrightIdx;		/* If zero no Copyright information associated with the wave */
	WAVEFORMATEX    WaveformatEx;		
	DMUS_WAVEDATA	WaveData;			/* Wave data */
} DMUS_WAVE;

typedef struct _DMUS_NOTERANGE *LPDMUS_NOTERANGE;
typedef struct _DMUS_NOTERANGE
{
	DWORD           dwLowNote;	/* Sets the low note for the range of MIDI note events to which the instrument responds.*/
	DWORD           dwHighNote;	/* Sets the high note for the range of MIDI note events to which the instrument responds.*/
} DMUS_NOTERANGE;

/* Software synths are enumerated from under this registry key.
 */
#define REGSTR_PATH_SOFTWARESYNTHS  "Software\\Microsoft\\DirectMusic\\SoftwareSynths"

interface IDirectMusicBuffer;
interface IDirectMusicPort;
interface IReferenceClock;
interface IDirectMusicSynth;
interface IDirectMusicSynthSink;

#ifndef __cplusplus 
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicPort IDirectMusicPort;
typedef interface IReferenceClock IReferenceClock;
typedef interface IDirectMusicSynth IDirectMusicSynth;
typedef interface IDirectMusicSynthSink IDirectMusicSynthSink;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynth
DECLARE_INTERFACE_(IDirectMusicSynth, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicSynth */
    STDMETHOD(Open)					(THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)				(THIS) PURE;
	STDMETHOD(SetNumChannelGroups)	(THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)				(THIS_ LPHANDLE phDownload, LPVOID pvData, LPBOOL pbFree ) PURE;
	STDMETHOD(Unload)				(THIS_ HANDLE hDownload, HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)			(THIS_ REFERENCE_TIME rt, LPBYTE pbBuffer, DWORD cbBuffer) PURE;
	STDMETHOD(GetRunningStats)		(THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)			(THIS_ LPDMUS_PORTCAPS pCaps) PURE;
	STDMETHOD(SetMasterClock)		(THIS_ IReferenceClock *pClock) PURE;
	STDMETHOD(GetLatencyClock)		(THIS_ IReferenceClock **ppClock) PURE;
	STDMETHOD(Activate)				(THIS_ HWND hWnd, BOOL fEnable) PURE;
	STDMETHOD(SetSynthSink)			(THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
	STDMETHOD(Render)				(THIS_ short *pBuffer, DWORD dwLength, DWORD dwPosition) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicSynthSink */
    STDMETHOD(Init)					(THIS_ IDirectMusicSynth *pSynth) PURE;
    STDMETHOD(SetFormat)			(THIS_ LPCWAVEFORMATEX pWaveFormat) PURE;
	STDMETHOD(SetMasterClock)		(THIS_ IReferenceClock *pClock) PURE;
	STDMETHOD(GetLatencyClock)		(THIS_ IReferenceClock **ppClock) PURE;
	STDMETHOD(Activate)				(THIS_ HWND hWnd, BOOL fEnable) PURE;
	STDMETHOD(SampleToRefTime)		(THIS_ DWORD dwSampleTime,REFERENCE_TIME *prfTime) PURE;
	STDMETHOD(RefTimeToSample)		(THIS_ REFERENCE_TIME rfTime, DWORD *pdwSampleTime) PURE;
};

typedef IDirectMusicBuffer *LPDIRECTMUSICBUFFER;
typedef IDirectMusicPort *LPDIRECTMUSICPORT;

#undef  INTERFACE
#define INTERFACE  IDirectMusic
DECLARE_INTERFACE_(IDirectMusic, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/*  IDirectMusic */
	STDMETHOD(EnumPort)             (THIS_ DWORD dwIdx, LPDMUS_PORTCAPS pPortCaps) PURE;
	STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc, LPDIRECTMUSICBUFFER *ppBuffer, LPUNKNOWN pUnkOuter) PURE;
	STDMETHOD(CreatePort)           (THIS_ REFGUID rguidPort, REFGUID rguidSink, LPDMUS_PORTPARAMS pPortParams, LPDIRECTMUSICPORT *ppPort, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex, LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock, IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID guidClock) PURE;
    STDMETHOD(Activate)             (THIS_ HWND hWnd, BOOL fEnable) PURE;
    STDMETHOD(GetPortProperty)      (THIS_ REFGUID rguidPort, REFGUID rguidPropSet, UINT uId, LPVOID pPropertyData, ULONG ulDataLength, ULONG *pulBytesReturned) PURE;
	STDMETHOD(GetDefaultPort)		(THIS_ LPGUID pguidPort) PURE;
	STDMETHOD(SetDefaultPort)		(THIS_ REFGUID rguidPort) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicBuffer
DECLARE_INTERFACE_(IDirectMusicBuffer, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/*  IDirectMusicBuffer */
	STDMETHOD(Flush)                (THIS) PURE;
	STDMETHOD(TotalTime)            (THIS_ LPREFERENCE_TIME prtTime) PURE;
    
	STDMETHOD(PackChannelMsg)       (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD dwChannelMessage) PURE;
    
	STDMETHOD(PackSysEx)            (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD cb,
                                           LPBYTE lpb) PURE;
    
	STDMETHOD(ResetReadPtr)         (THIS) PURE;
	STDMETHOD(GetNextEvent)         (THIS_ LPREFERENCE_TIME prt,
                                           LPDWORD pdwChannelGroup,
                                           LPDWORD pdwLength,
                                           LPBYTE *ppData) PURE;

    STDMETHOD(GetRawBufferPtr)      (THIS_ LPBYTE *ppData) PURE;
    STDMETHOD(GetStartTime)         (THIS_ LPREFERENCE_TIME prt) PURE;
    STDMETHOD(GetUsedBytes)         (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetMaxBytes)          (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetBufferFormat)      (THIS_ LPGUID pGuidFormat) PURE;

    STDMETHOD(SetStartTime)         (THIS_ REFERENCE_TIME rt) PURE;
    STDMETHOD(SetUsedBytes)         (THIS_ DWORD cb) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicInstrument
DECLARE_INTERFACE_(IDirectMusicInstrument, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

	/* IDirectMusicInstrument */
	STDMETHOD(GetPatch)                 (THIS_ DWORD* pdwPatch) PURE;
	STDMETHOD(SetPatch)                 (THIS_ DWORD dwPatch) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadedInstrument
DECLARE_INTERFACE_(IDirectMusicDownloadedInstrument, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

	/* IDirectMusicDownloadedInstrument */
	/* None at this time */
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicCollection
DECLARE_INTERFACE_(IDirectMusicCollection, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

	/* IDirectMusicCollection */
	STDMETHOD(GetInstrument)            (THIS_ DWORD dwPatch, IDirectMusicInstrument** ppInstrument) PURE;
	STDMETHOD(EnumInstrument)			(THIS_ DWORD dwIndex, DWORD* pdwPatch, LPWSTR pName, DWORD cwchName) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownload 
DECLARE_INTERFACE_(IDirectMusicDownload , IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicDownload */
    STDMETHOD(GetBuffer)			(THIS_ void** ppvBuffer, DWORD* pdwSize) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicPortDownload
DECLARE_INTERFACE_(IDirectMusicPortDownload, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicPortDownload */
	STDMETHOD(GetBuffer)			(THIS_ DWORD dwId, IDirectMusicDownload** pIDMDownload) PURE;
	STDMETHOD(AllocateBuffer)		(THIS_ DWORD dwSize, IDirectMusicDownload** pIDMDownload) PURE;
	STDMETHOD(FreeBuffer)			(THIS_ IDirectMusicDownload* pIDMDownload) PURE;
	STDMETHOD(GetDLId)				(THIS_ DWORD* pdwStartDLId, DWORD dwCount) PURE;
	STDMETHOD(Download)				(THIS_ IDirectMusicDownload* pIDMDownload) PURE;
	STDMETHOD(Unload)				(THIS_ IDirectMusicDownload* pIDMDownload) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicPort
DECLARE_INTERFACE_(IDirectMusicPort, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/*  IDirectMusicPort */
	/*  */
    STDMETHOD(PlayBuffer)			(THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(SetReadNotificationHandle) 
     								(THIS_ HANDLE hEvent) PURE;
    STDMETHOD(Read)                 (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
	STDMETHOD(DownloadInstrument)	(THIS_ IDirectMusicInstrument *pInstrument, 
									 IDirectMusicDownloadedInstrument **ppDownloadedInstrument,
									 DMUS_NOTERANGE *pNoteRanges,
									 DWORD dwNumNoteRanges) PURE;

	STDMETHOD(UnloadInstrument)		(THIS_ IDirectMusicDownloadedInstrument *pInstrument) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDMUS_PORTCAPS pPortCaps) PURE;
	STDMETHOD(DeviceIoControl)		(THIS_ DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwChannelGroups) PURE;
	STDMETHOD(GetNumChannelGroups)	(THIS_ LPDWORD pdwGroups) PURE;
    STDMETHOD(GetInterfaces)        (THIS_ LPUNKNOWN *ppUnknownPort, LPUNKNOWN *ppUnknownSink) PURE;
};

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

DEFINE_GUID(IID_IReferenceClock,0x56a86897,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#undef  INTERFACE
#define INTERFACE  IReferenceClock
DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
	/*  IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /*  IReferenceClock */
    /*  */
    
    /*  get the time now */
    STDMETHOD(GetTime)                  (THIS_ REFERENCE_TIME *pTime) PURE;

    /*  ask for an async notification that a time has elapsed */
    STDMETHOD(AdviseTime)               (THIS_ REFERENCE_TIME baseTime,         /*  base time */
                                               REFERENCE_TIME streamTime,	    /*  stream offset time */
                                               HANDLE hEvent,                   /*  advise via this event */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  ask for an async periodic notification that a time has elapsed */
    STDMETHOD(AdvisePeriodic)           (THIS_ REFERENCE_TIME startTime,	    /*  starting at this time */
                                               REFERENCE_TIME periodTime,       /*  time between notifications */
                                               HANDLE hSemaphore,				/*  advise via a semaphore */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  cancel a request for notification */
    STDMETHOD(Unadvise)                 (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif /* __IReferenceClock_INTERFACE_DEFINED__ */

/* Include IKsPropertySet if ksproxy.h is not included.
 */
#ifndef _IKsPropertySet_
#define _IKsPropertySet_

DEFINE_GUID(IID_IKsPropertySet, 0x31EFAC30, 0x515C, 0x11d0, 0xA9, 0xAA, 0x00, 0xAA, 0x00, 0x61, 0xBE, 0x93);

/* Flags returned in pulTypeSupport
 */
#define KSPROPERTY_SUPPORT_GET 1
#define KSPROPERTY_SUPPORT_SET 2

#undef  INTERFACE
#define INTERFACE IKsPropertySet
DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    STDMETHOD (Set)                     (THIS_ REFGUID  rguidPropSet,
                                               ULONG    ulId,
                                               LPVOID   pInstanceData,
                                               ULONG    ulInstanceLength,
                                               LPVOID   pPropertyData,
                                               ULONG    ulDataLength) PURE;

    STDMETHOD (Get)                     (THIS_ REFGUID  rguidPropSet,
                                               ULONG    ulId,
                                               LPVOID   pInstanceData,
                                               ULONG    ulInstanceLength,
                                               LPVOID   pPropertyData,
                                               ULONG    ulDataLength,
                                               ULONG*   pulBytesReturned) PURE;

    STDMETHOD (QuerySupported)          (THIS_ REFGUID  rguidPropSet,
                                               ULONG    ulId,
                                               ULONG*   pulTypeSupport) PURE;
};
#endif


DEFINE_GUID(CLSID_DirectMusic,0x636b9f10,0x0c7d,0x11d1,0x95,0xb2,0x00,0x20,0xaf,0xdc,0x74,0x21);
DEFINE_GUID(CLSID_DirectMusicCollection,0x480ff4b0, 0x28b2, 0x11d1, 0xbe, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_DirectMusicSynthSink,0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

DEFINE_GUID(IID_IDirectMusic,0xd2ac2876, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicBuffer,0xd2ac2878, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicPort, 0x55e2edd8, 0xcd7c, 0x11d1, 0xa7, 0x6f, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortDownload,0xd2ac287a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownload,0xd2ac287b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicCollection,0xd2ac287c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicInstrument,0xd2ac287d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownloadedInstrument,0xd2ac287e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicSynth,0xf69b9165, 0xbb60, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSynthSink,0xd2ac2880, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Property Query GUID_DMUS_PROP_GM_Hardware
 * Property Query GUID_DMUS_PROP_GS_Hardware
 * Property Query GUID_DMUS_PROP_XG_Hardware
 * Property Query GUID_DMUS_PROP_DLS1_Hardware
 * Property Query GUID_DMUS_PROP_SynthSink_DSOUND
 * Property Query GUID_DMUS_PROP_SynthSink_WAVE
 *
 * Item 0: Supported
 * Returns a DWORD which is non-zero if the feature is supported
 */
DEFINE_GUID(GUID_DMUS_PROP_GM_Hardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_GS_Hardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Hardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_DLS1,        0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_DSOUND,0xaa97844, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_WAVE,0xaa97845, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Property Get GUID_DMUS_PROP_MemorySize
 *
 * Item 0: Memory size
 * Returns a DWORD containing the total number of bytes of sample RAM
 */
DEFINE_GUID(GUID_DMUS_PROP_MemorySize,  0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_SetDSound
 *
 * Item 0: IDirectSound Interface
 * Sets the IDirectMusicSynthSink to use the specified DSound object.
 */
DEFINE_GUID(GUID_DMUS_PROP_SetDSound,0xaa97842, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Property Set GUID_DMUS_PROP_WriteBufferZone
 *
 * Item 0: Distance in milliseconds from the write pointer to the synth write.
 * Sets the IDirectMusicSynthSink to write this far behind the pointer.
 */
DEFINE_GUID(GUID_DMUS_PROP_WriteBufferZone,0xaa97843, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);


#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* #ifndef _DMUSICC_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\dplay.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplay.h
 *  Content:    DirectPlay include file
 *
 ***************************************************************************/

#ifndef __DPLAY_INCLUDED__
#define __DPLAY_INCLUDED__

#include <ole2.h>       // for DECLARE_INTERFACE and HRESULT

/*
 * Some types
 */

typedef LPVOID (*LPRGLPVOID)[];
typedef LPRGLPVOID PRGPVOID, LPRGPVOID, PRGLPVOID, PAPVOID, LPAPVOID, PALPVOID, LPALPVOID;

#define _FACDP  0x877
#define MAKE_DPHRESULT( code )    MAKE_HRESULT( 1, _FACDP, code )

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectPlay objects
 */
DEFINE_GUID(IID_IDirectPlay2, 0x2b74f7c0, 0x9154, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);
DEFINE_GUID(IID_IDirectPlay2A,0x9d460580, 0xa822, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

DEFINE_GUID(IID_IDirectPlay3, 0x133efe40, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay3A,0x133efe41, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

DEFINE_GUID(IID_IDirectPlay4, 0xab1c530, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlay4A,0xab1c531, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

// {D1EB6D20-8923-11d0-9D97-00A0C90A43CB}
DEFINE_GUID(CLSID_DirectPlay,0xd1eb6d20, 0x8923, 0x11d0, 0x9d, 0x97, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

/*
 * GUIDS used by Service Providers shipped with DirectPlay
 * Use these to identify Service Provider returned by EnumConnections
 */

// GUID for IPX service provider
// {685BC400-9D2C-11cf-A9CD-00AA006886E3}
DEFINE_GUID(DPSPGUID_IPX, 
0x685bc400, 0x9d2c, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);

// GUID for TCP/IP service provider
// 36E95EE0-8577-11cf-960C-0080C7534E82
DEFINE_GUID(DPSPGUID_TCPIP,
0x36E95EE0, 0x8577, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

// GUID for Serial service provider
// {0F1D6860-88D9-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSPGUID_SERIAL,						
0xf1d6860, 0x88d9, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// GUID for Modem service provider
// {44EAA760-CB68-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSPGUID_MODEM,
0x44eaa760, 0xcb68, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/****************************************************************************
 *
 * DirectPlay Structures
 *
 * Various structures used to invoke DirectPlay.
 *
 ****************************************************************************/

#ifndef IDIRECTPLAY2_OR_GREATER
typedef struct IDirectPlay        FAR *LPDIRECTPLAY;
#else
typedef struct IUnknown           FAR *LPDIRECTPLAY;
#endif

typedef struct IDirectPlay2       FAR *LPDIRECTPLAY2;
typedef struct IDirectPlay2       FAR *LPDIRECTPLAY2A;
typedef struct IDirectPlay2       IDirectPlay2A;

typedef struct IDirectPlay3       FAR *LPDIRECTPLAY3;
typedef struct IDirectPlay3       FAR *LPDIRECTPLAY3A;
typedef struct IDirectPlay3       IDirectPlay3A;

typedef struct IDirectPlay4       FAR *LPDIRECTPLAY4;
typedef struct IDirectPlay4       FAR *LPDIRECTPLAY4A;
typedef struct IDirectPlay4       IDirectPlay4A;

/*
 * DPID
 * DirectPlay player and group ID
 */
typedef DWORD DPID, FAR *LPDPID;

/*
 * DPID that system messages come from
 */
#define DPID_SYSMSG         0

/*
 * DPID representing all players in the session
 */
#define DPID_ALLPLAYERS     0

/*
 * DPID representing the server player
 */
#define DPID_SERVERPLAYER	1


/*
 * DPID representing the maxiumum ID in the range of DPID's reserved for
 * use by DirectPlay.
 */
#define DPID_RESERVEDRANGE     100

/*
 * The player ID is unknown (used with e.g. DPSESSION_NOMESSAGEID)
 */
#define DPID_UNKNOWN		0xFFFFFFFF

/*
 * DPCAPS
 * Used to obtain the capabilities of a DirectPlay object
 */
typedef struct
{
    DWORD dwSize;               // Size of structure, in bytes
    DWORD dwFlags;              // DPCAPS_xxx flags
    DWORD dwMaxBufferSize;      // Maximum message size, in bytes,  for this service provider
    DWORD dwMaxQueueSize;       // Obsolete. 
    DWORD dwMaxPlayers;         // Maximum players/groups (local + remote)
    DWORD dwHundredBaud;        // Bandwidth in 100 bits per second units; 
                                // i.e. 24 is 2400, 96 is 9600, etc.
    DWORD dwLatency;            // Estimated latency; 0 = unknown
    DWORD dwMaxLocalPlayers;    // Maximum # of locally created players allowed
    DWORD dwHeaderLength;       // Maximum header length, in bytes, on messages
                                // added by the service provider
    DWORD dwTimeout;            // Service provider's suggested timeout value
                                // This is how long DirectPlay will wait for 
                                // responses to system messages
} DPCAPS, FAR *LPDPCAPS;

/*
 * This DirectPlay object is the session host.  If the host exits the
 * session, another application will become the host and receive a
 * DPSYS_HOST system message.
 */
#define DPCAPS_ISHOST               0x00000002

/*
 * The service provider bound to this DirectPlay object can optimize
 * group messaging.
 */
#define DPCAPS_GROUPOPTIMIZED       0x00000008

/*
 * The service provider bound to this DirectPlay object can optimize
 * keep alives (see DPSESSION_KEEPALIVE)
 */
#define DPCAPS_KEEPALIVEOPTIMIZED   0x00000010

/*
 * The service provider bound to this DirectPlay object can optimize
 * guaranteed message delivery.
 */
#define DPCAPS_GUARANTEEDOPTIMIZED  0x00000020

/*
 * This DirectPlay object supports guaranteed message delivery.
 */
#define DPCAPS_GUARANTEEDSUPPORTED  0x00000040

/*
 * This DirectPlay object supports digital signing of messages.
 */
#define DPCAPS_SIGNINGSUPPORTED     0x00000080

/*
 * This DirectPlay object supports encryption of messages.
 */
#define DPCAPS_ENCRYPTIONSUPPORTED  0x00000100

/*
 * This DirectPlay player was created on this machine
 */
#define DPPLAYERCAPS_LOCAL			0x00000800

/*
 * Current Open settings supports all forms of Cancel
 */
#define DPCAPS_ASYNCCANCELSUPPORTED    0x00001000

/*
 * Current Open settings supports CancelAll, but not Cancel
 */
#define DPCAPS_ASYNCCANCELALLSUPPORTED 0x00002000

/*
 *  Current Open settings supports Send Timeouts for sends
 */
#define DPCAPS_SENDTIMEOUTSUPPORTED   0x00004000

/*
 *  Current Open settings supports send priority
 */
#define DPCAPS_SENDPRIORITYSUPPORTED   0x00008000

/*
 *  Current Open settings supports DPSEND_ASYNC flag
 */
#define DPCAPS_ASYNCSUPPORTED 		   0x00010000


/*
 * DPSESSIONDESC2
 * Used to describe the properties of a DirectPlay
 * session instance
 */
typedef struct
{
    DWORD   dwSize;             // Size of structure
    DWORD   dwFlags;            // DPSESSION_xxx flags
    GUID    guidInstance;       // ID for the session instance
    GUID    guidApplication;    // GUID of the DirectPlay application.
                                // GUID_NULL for all applications.
    DWORD   dwMaxPlayers;       // Maximum # players allowed in session
    DWORD   dwCurrentPlayers;   // Current # players in session (read only)
    union
    {                           // Name of the session
        LPWSTR  lpszSessionName;    // Unicode
        LPSTR   lpszSessionNameA;   // ANSI
    };
    union
    {                           // Password of the session (optional)
        LPWSTR  lpszPassword;       // Unicode
        LPSTR   lpszPasswordA;      // ANSI
    };
    DWORD   dwReserved1;        // Reserved for future MS use.
    DWORD   dwReserved2;
    DWORD   dwUser1;            // For use by the application
    DWORD   dwUser2;
    DWORD   dwUser3;
    DWORD   dwUser4;
} DPSESSIONDESC2, FAR *LPDPSESSIONDESC2;

/*
 * LPCDPSESSIONDESC2
 * A constant pointer to DPSESSIONDESC2
 */
typedef const DPSESSIONDESC2 FAR *LPCDPSESSIONDESC2;
 
/*
 * Applications cannot create new players in this session.
 */
#define DPSESSION_NEWPLAYERSDISABLED    0x00000001 

/*
 * If the DirectPlay object that created the session, the host,
 * quits, then the host will attempt to migrate to another
 * DirectPlay object so that new players can continue to be created
 * and new applications can join the session.
 */
#define DPSESSION_MIGRATEHOST           0x00000004

/*
 * This flag tells DirectPlay not to set the idPlayerTo and idPlayerFrom 
 * fields in player messages.  This cuts two DWORD's off the message 
 * overhead.
 */
#define DPSESSION_NOMESSAGEID           0x00000008


/*
 * This flag tells DirectPlay to not allow any new applications to
 * join the session.  Applications already in the session can still
 * create new players.
 */
#define DPSESSION_JOINDISABLED          0x00000020

/*
 * This flag tells DirectPlay to detect when remote players 
 * exit abnormally (e.g. their computer or modem gets unplugged)
 */
#define DPSESSION_KEEPALIVE             0x00000040

/*
 * This flag tells DirectPlay not to send a message to all players
 * when a players remote data changes
 */
#define DPSESSION_NODATAMESSAGES        0x00000080

/*
 * This flag indicates that the session belongs to a secure server
 * and needs user authentication
 */
#define DPSESSION_SECURESERVER          0x00000100

/*
 * This flag indicates that the session is private and requirs a password
 * for EnumSessions as well as Open.
 */
#define DPSESSION_PRIVATE               0x00000200

/*
 * This flag indicates that the session requires a password for joining.
 */
#define DPSESSION_PASSWORDREQUIRED      0x00000400

/*
 * This flag tells DirectPlay to route all messages through the server
 */
#define DPSESSION_MULTICASTSERVER		0x00000800

/*
 * This flag tells DirectPlay to only download information about the
 * DPPLAYER_SERVERPLAYER.  
 */
#define DPSESSION_CLIENTSERVER			0x00001000

/*
 * This flag tells DirectPlay to use the protocol built into dplay
 * for reliability and statistics all the time.  When this bit is
 * set, only other sessions with this bit set can join or be joined.
 */
#define DPSESSION_DIRECTPLAYPROTOCOL	0x00002000

/*
 * This flag tells DirectPlay that preserving order of received
 * packets is not important, when using reliable delivery.  This
 * will allow messages to be indicated out of order if preceding
 * messages have not yet arrived.  Otherwise DPLAY will wait for
 * earlier messages before delivering later reliable messages.
 */
#define DPSESSION_NOPRESERVEORDER		0x00004000


/*
 * This flag tells DirectPlay to optimize communication for latency
 */
#define DPSESSION_OPTIMIZELATENCY		0x00008000

/*
 * DPNAME
 * Used to hold the name of a DirectPlay entity
 * like a player or a group
 */
typedef struct 
{
    DWORD   dwSize;             // Size of structure
    DWORD   dwFlags;            // Not used. Must be zero.
    union
    {                           // The short or friendly name
        LPWSTR  lpszShortName;  // Unicode
        LPSTR   lpszShortNameA; // ANSI
    };
    union
    {                           // The long or formal name
        LPWSTR  lpszLongName;   // Unicode
        LPSTR   lpszLongNameA;  // ANSI
    };

} DPNAME, FAR *LPDPNAME;

/*
 * LPCDPNAME
 * A constant pointer to DPNAME
 */
typedef const DPNAME FAR *LPCDPNAME;

/*
 * DPCREDENTIALS
 * Used to hold the user name and password of a DirectPlay user
 */
typedef struct 
{
    DWORD dwSize;               // Size of structure
    DWORD dwFlags;              // Not used. Must be zero.
    union
    {                           // User name of the account
        LPWSTR  lpszUsername;   // Unicode
        LPSTR   lpszUsernameA;  // ANSI
    };    
    union
    {                           // Password of the account
        LPWSTR  lpszPassword;   // Unicode
        LPSTR   lpszPasswordA;  // ANSI
    };    
    union
    {                           // Domain name of the account
        LPWSTR  lpszDomain;     // Unicode
        LPSTR   lpszDomainA;    // ANSI
    };    
} DPCREDENTIALS, FAR *LPDPCREDENTIALS;

typedef const DPCREDENTIALS FAR *LPCDPCREDENTIALS;

/*
 * DPSECURITYDESC
 * Used to describe the security properties of a DirectPlay
 * session instance
 */
typedef struct 
{
    DWORD dwSize;                   // Size of structure
    DWORD dwFlags;                  // Not used. Must be zero.
    union
    {                               // SSPI provider name
        LPWSTR  lpszSSPIProvider;   // Unicode
        LPSTR   lpszSSPIProviderA;  // ANSI
    };
    union
    {                               // CAPI provider name
        LPWSTR lpszCAPIProvider;    // Unicode
        LPSTR  lpszCAPIProviderA;   // ANSI
    };
    DWORD dwCAPIProviderType;       // Crypto Service Provider type
    DWORD dwEncryptionAlgorithm;    // Encryption Algorithm type
} DPSECURITYDESC, FAR *LPDPSECURITYDESC;

typedef const DPSECURITYDESC FAR *LPCDPSECURITYDESC;

/*
 * DPACCOUNTDESC
 * Used to describe a user membership account
 */
typedef struct 
{
    DWORD dwSize;                   // Size of structure
    DWORD dwFlags;                  // Not used. Must be zero.
    union
    {                               // Account identifier
        LPWSTR  lpszAccountID;      // Unicode
        LPSTR   lpszAccountIDA;     // ANSI
    };
} DPACCOUNTDESC, FAR *LPDPACCOUNTDESC;

typedef const DPACCOUNTDESC FAR *LPCDPACCOUNTDESC;

/*
 * LPCGUID
 * A constant pointer to a guid
 */
typedef const GUID FAR *LPCGUID;

/*
 * DPLCONNECTION
 * Used to hold all in the informaion needed to connect
 * an application to a session or create a session
 */
typedef struct
{
    DWORD               dwSize;             // Size of this structure
    DWORD               dwFlags;            // Flags specific to this structure
    LPDPSESSIONDESC2    lpSessionDesc;      // Pointer to session desc to use on connect
    LPDPNAME            lpPlayerName;       // Pointer to Player name structure
    GUID                guidSP;             // GUID of the DPlay SP to use
    LPVOID              lpAddress;          // Address for service provider
    DWORD               dwAddressSize;      // Size of address data
} DPLCONNECTION, FAR *LPDPLCONNECTION;

/*
 * LPCDPLCONNECTION
 * A constant pointer to DPLCONNECTION
 */
typedef const DPLCONNECTION FAR *LPCDPLCONNECTION;

/*
 * DPCHAT
 * Used to hold the a DirectPlay chat message
 */
typedef struct
{
    DWORD               dwSize;
    DWORD               dwFlags;
    union
    {                          // Message string
        LPWSTR  lpszMessage;   // Unicode
        LPSTR   lpszMessageA;  // ANSI
    };    
} DPCHAT, FAR * LPDPCHAT;

/*
 * SGBUFFER
 * Scatter Gather Buffer used for SendEx
 */
typedef struct 
{
	UINT         len;       // length of buffer data
	PUCHAR	     pData;		// pointer to buffer data
} SGBUFFER, *PSGBUFFER, FAR *LPSGBUFFER;


/****************************************************************************
 *
 * Prototypes for DirectPlay callback functions
 *
 ****************************************************************************/

/*
 * Callback for IDirectPlay2::EnumSessions
 */
typedef BOOL (FAR PASCAL * LPDPENUMSESSIONSCALLBACK2)(
    LPCDPSESSIONDESC2   lpThisSD,
    LPDWORD             lpdwTimeOut,
    DWORD               dwFlags,
    LPVOID              lpContext );

/*
 * This flag is set on the EnumSessions callback dwFlags parameter when
 * the time out has occurred. There will be no session data for this 
 * callback. If *lpdwTimeOut is set to a non-zero value and the 
 * EnumSessionsCallback function returns TRUE then EnumSessions will 
 * continue waiting until the next timeout occurs. Timeouts are in 
 * milliseconds.
 */
#define DPESC_TIMEDOUT          0x00000001


/*
 * Callback for IDirectPlay2::EnumPlayers
 *              IDirectPlay2::EnumGroups
 *              IDirectPlay2::EnumGroupPlayers
 */
typedef BOOL (FAR PASCAL *LPDPENUMPLAYERSCALLBACK2)(
    DPID            dpId,
    DWORD           dwPlayerType,
    LPCDPNAME       lpName,
    DWORD           dwFlags,
    LPVOID          lpContext );


/*
 * Unicode callback for DirectPlayEnumerate
 * This callback prototype will be used if compiling
 * for Unicode strings
 */
typedef BOOL (FAR PASCAL * LPDPENUMDPCALLBACK)(
    LPGUID      lpguidSP,
    LPWSTR      lpSPName,
    DWORD       dwMajorVersion,
    DWORD       dwMinorVersion,
    LPVOID      lpContext);

/*
 * ANSI callback for DirectPlayEnumerate
 * This callback prototype will be used if compiling
 * for ANSI strings
 */
typedef BOOL (FAR PASCAL * LPDPENUMDPCALLBACKA)(
    LPGUID      lpguidSP,
    LPSTR       lpSPName,
    DWORD       dwMajorVersion,     
    DWORD       dwMinorVersion,
    LPVOID      lpContext);

/*
 * Callback for IDirectPlay3(A)::EnumConnections
 */
typedef BOOL (FAR PASCAL * LPDPENUMCONNECTIONSCALLBACK)(
    LPCGUID     lpguidSP,
	LPVOID		lpConnection,
	DWORD		dwConnectionSize,
    LPCDPNAME   lpName,
	DWORD 		dwFlags,
	LPVOID 		lpContext);


/*
 * API's
 */

#ifdef UNICODE
#define DirectPlayEnumerate     DirectPlayEnumerateW
#else
#define DirectPlayEnumerate     DirectPlayEnumerateA
#endif // UNICODE

extern HRESULT WINAPI DirectPlayEnumerateA( LPDPENUMDPCALLBACKA, LPVOID );
extern HRESULT WINAPI DirectPlayEnumerateW( LPDPENUMDPCALLBACK, LPVOID );
extern HRESULT WINAPI DirectPlayCreate( LPGUID lpGUID, LPDIRECTPLAY *lplpDP, IUnknown *pUnk);

/****************************************************************************
 *
 * IDirectPlay2 (and IDirectPlay2A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay2
DECLARE_INTERFACE_( IDirectPlay2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlay2 interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay2_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay2_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlay2_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlay2_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay2_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlay2_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlay2_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlay2_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay2_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay2_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay2_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlay2_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay2_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay2_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay2_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay2_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay2_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlay2_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlay2_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlay2_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlay2_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlay2_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlay2_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlay2_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay2_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlay2_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay2_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay2_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlay2_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlay2_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlay2_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlay2_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)

#else /* C++ */

#define IDirectPlay2_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlay2_AddRef(p)                      (p)->AddRef()
#define IDirectPlay2_Release(p)                     (p)->Release()
#define IDirectPlay2_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlay2_Close(p)                       (p)->Close()
#define IDirectPlay2_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlay2_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlay2_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay2_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlay2_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlay2_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlay2_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlay2_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay2_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay2_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlay2_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlay2_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlay2_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlay2_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlay2_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlay2_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlay2_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlay2_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlay2_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlay2_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlay2_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlay2_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlay2_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlay2_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlay2_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlay2_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlay2_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)

#endif

/****************************************************************************
 *
 * IDirectPlay3 (and IDirectPlay3A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay3
DECLARE_INTERFACE_( IDirectPlay3, IDirectPlay2 )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    /*** IDirectPlay3 methods ***/
    STDMETHOD(AddGroupToGroup)      (THIS_ DPID, DPID) PURE;
    STDMETHOD(CreateGroupInGroup)   (THIS_ DPID,LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeleteGroupFromGroup)	(THIS_ DPID,DPID) PURE;	
    STDMETHOD(EnumConnections)     	(THIS_ LPCGUID,LPDPENUMCONNECTIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroupsInGroup)	(THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
	STDMETHOD(GetGroupConnectionSettings)(THIS_ DWORD, DPID, LPVOID, LPDWORD) PURE;
	STDMETHOD(InitializeConnection) (THIS_ LPVOID,DWORD) PURE;
    STDMETHOD(SecureOpen)           (THIS_ LPCDPSESSIONDESC2,DWORD,LPCDPSECURITYDESC,LPCDPCREDENTIALS) PURE;
	STDMETHOD(SendChatMessage)      (THIS_ DPID,DPID,DWORD,LPDPCHAT) PURE;
	STDMETHOD(SetGroupConnectionSettings)(THIS_ DWORD,DPID,LPDPLCONNECTION) PURE;
	STDMETHOD(StartSession)         (THIS_ DWORD,DPID) PURE;
	STDMETHOD(GetGroupFlags)        (THIS_ DPID,LPDWORD) PURE;
	STDMETHOD(GetGroupParent)       (THIS_ DPID,LPDPID) PURE;
	STDMETHOD(GetPlayerAccount)     (THIS_ DPID, DWORD, LPVOID, LPDWORD) PURE;
	STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlay3 interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay3_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay3_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlay3_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlay3_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay3_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlay3_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlay3_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlay3_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay3_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay3_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay3_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlay3_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay3_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay3_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay3_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay3_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay3_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlay3_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlay3_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlay3_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlay3_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlay3_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlay3_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlay3_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay3_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlay3_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay3_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay3_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlay3_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlay3_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlay3_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlay3_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)
#define IDirectPlay3_AddGroupToGroup(p,a,b) 		(p)->lpVtbl->AddGroupToGroup(p,a,b)
#define IDirectPlay3_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->lpVtbl->CreateGroupInGroup(p,a,b,c,d,e,f)
#define IDirectPlay3_DeleteGroupFromGroup(p,a,b)   	(p)->lpVtbl->DeleteGroupFromGroup(p,a,b)
#define IDirectPlay3_EnumConnections(p,a,b,c,d) 	(p)->lpVtbl->EnumConnections(p,a,b,c,d)
#define IDirectPlay3_EnumGroupsInGroup(p,a,b,c,d,e) (p)->lpVtbl->EnumGroupsInGroup(p,a,b,c,d,e)
#define IDirectPlay3_GetGroupConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetGroupConnectionSettings(p,a,b,c,d)
#define IDirectPlay3_InitializeConnection(p,a,b) 	(p)->lpVtbl->InitializeConnection(p,a,b)
#define IDirectPlay3_SecureOpen(p,a,b,c,d)          (p)->lpVtbl->SecureOpen(p,a,b,c,d)
#define IDirectPlay3_SendChatMessage(p,a,b,c,d)     (p)->lpVtbl->SendChatMessage(p,a,b,c,d)
#define IDirectPlay3_SetGroupConnectionSettings(p,a,b,c) (p)->lpVtbl->SetGroupConnectionSettings(p,a,b,c)
#define IDirectPlay3_StartSession(p,a,b)            (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlay3_GetGroupFlags(p,a,b)           (p)->lpVtbl->GetGroupFlags(p,a,b)
#define IDirectPlay3_GetGroupParent(p,a,b)          (p)->lpVtbl->GetGroupParent(p,a,b)
#define IDirectPlay3_GetPlayerAccount(p,a,b,c,d)    (p)->lpVtbl->GetPlayerAccount(p,a,b,c,d)
#define IDirectPlay3_GetPlayerFlags(p,a,b)          (p)->lpVtbl->GetPlayerFlags(p,a,b)

#else /* C++ */

#define IDirectPlay3_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlay3_AddRef(p)                      (p)->AddRef()
#define IDirectPlay3_Release(p)                     (p)->Release()
#define IDirectPlay3_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlay3_Close(p)                       (p)->Close()
#define IDirectPlay3_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlay3_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlay3_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay3_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlay3_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlay3_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlay3_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlay3_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay3_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay3_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlay3_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlay3_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlay3_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlay3_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlay3_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlay3_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlay3_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlay3_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlay3_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlay3_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlay3_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlay3_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlay3_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlay3_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlay3_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlay3_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlay3_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)
#define IDirectPlay3_AddGroupToGroup(p,a,b) 		(p)->AddGroupToGroup(a,b)
#define IDirectPlay3_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->CreateGroupInGroup(a,b,c,d,e,f)
#define IDirectPlay3_DeleteGroupFromGroup(p,a,b)   	(p)->DeleteGroupFromGroup(a,b)
#define IDirectPlay3_EnumConnections(p,a,b,c,d)     (p)->EnumConnections(a,b,c,d)
#define IDirectPlay3_EnumGroupsInGroup(p,a,b,c,d,e) (p)->EnumGroupsInGroup(a,b,c,d,e)
#define IDirectPlay3_GetGroupConnectionSettings(p,a,b,c,d) (p)->GetGroupConnectionSettings(a,b,c,d)
#define IDirectPlay3_InitializeConnection(p,a,b)    (p)->InitializeConnection(a,b)
#define IDirectPlay3_SecureOpen(p,a,b,c,d)          (p)->SecureOpen(a,b,c,d)
#define IDirectPlay3_SendChatMessage(p,a,b,c,d)     (p)->SendChatMessage(a,b,c,d)
#define IDirectPlay3_SetGroupConnectionSettings(p,a,b,c) (p)->SetGroupConnectionSettings(a,b,c)
#define IDirectPlay3_StartSession(p,a,b)            (p)->StartSession(a,b)
#define IDirectPlay3_GetGroupFlags(p,a,b)           (p)->GetGroupFlags(a,b)
#define IDirectPlay3_GetGroupParent(p,a,b)          (p)->GetGroupParent(a,b)
#define IDirectPlay3_GetPlayerAccount(p,a,b,c,d)    (p)->GetPlayerAccount(a,b,c,d)
#define IDirectPlay3_GetPlayerFlags(p,a,b)          (p)->GetPlayerFlags(a,b)

#endif

/****************************************************************************
 *
 * IDirectPlay4 (and IDirectPlay4A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay4
DECLARE_INTERFACE_( IDirectPlay4, IDirectPlay3 )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    /*** IDirectPlay3 methods ***/
    STDMETHOD(AddGroupToGroup)      (THIS_ DPID, DPID) PURE;
    STDMETHOD(CreateGroupInGroup)   (THIS_ DPID,LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeleteGroupFromGroup)	(THIS_ DPID,DPID) PURE;	
    STDMETHOD(EnumConnections)     	(THIS_ LPCGUID,LPDPENUMCONNECTIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroupsInGroup)	(THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
	STDMETHOD(GetGroupConnectionSettings)(THIS_ DWORD, DPID, LPVOID, LPDWORD) PURE;
	STDMETHOD(InitializeConnection) (THIS_ LPVOID,DWORD) PURE;
    STDMETHOD(SecureOpen)           (THIS_ LPCDPSESSIONDESC2,DWORD,LPCDPSECURITYDESC,LPCDPCREDENTIALS) PURE;
    STDMETHOD(SendChatMessage)      (THIS_ DPID,DPID,DWORD,LPDPCHAT) PURE;
    STDMETHOD(SetGroupConnectionSettings)(THIS_ DWORD,DPID,LPDPLCONNECTION) PURE;
    STDMETHOD(StartSession)         (THIS_ DWORD,DPID) PURE;
    STDMETHOD(GetGroupFlags)        (THIS_ DPID,LPDWORD) PURE;
    STDMETHOD(GetGroupParent)       (THIS_ DPID,LPDPID) PURE;
    STDMETHOD(GetPlayerAccount)     (THIS_ DPID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
    /*** IDirectPlay4 methods ***/
    STDMETHOD(GetGroupOwner)        (THIS_ DPID, LPDPID) PURE;
    STDMETHOD(SetGroupOwner)        (THIS_ DPID, DPID) PURE;
    STDMETHOD(SendEx)               (THIS_ DPID, DPID, DWORD, LPVOID, DWORD, DWORD, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(GetMessageQueue)      (THIS_ DPID, DPID, DWORD, LPDWORD, LPDWORD) PURE;
    STDMETHOD(CancelMessage)        (THIS_ DWORD, DWORD) PURE;
    STDMETHOD(CancelPriority)       (THIS_ DWORD, DWORD, DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayX interface macros (for IDirectPlay4 and beyond)
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayX_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayX_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlayX_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlayX_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlayX_CancelMessage(p,a,b)           (p)->lpVtbl->CancelMessage(p,a,b)
#define IDirectPlayX_CancelPriority(p,a,b,c)        (p)->lpVtbl->CancelPriority(p,a,b,c)
#define IDirectPlayX_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlayX_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlayX_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlayX_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlayX_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlayX_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlayX_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlayX_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlayX_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlayX_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlayX_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlayX_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlayX_GetMessageQueue(p,a,b,c,d,e)   (p)->lpVtbl->GetMessageQueue(p,a,b,c,d,e)
#define IDirectPlayX_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlayX_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlayX_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlayX_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlayX_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlayX_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlayX_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlayX_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlayX_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlayX_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlayX_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlayX_SendEx(p,a,b,c,d,e,f,g,h,i)    (p)->lpVtbl->SendEx(p,a,b,c,d,e,f,g,h,i)
#define IDirectPlayX_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlayX_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlayX_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlayX_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlayX_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)
#define IDirectPlayX_AddGroupToGroup(p,a,b) 		(p)->lpVtbl->AddGroupToGroup(p,a,b)
#define IDirectPlayX_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->lpVtbl->CreateGroupInGroup(p,a,b,c,d,e,f)
#define IDirectPlayX_DeleteGroupFromGroup(p,a,b)   	(p)->lpVtbl->DeleteGroupFromGroup(p,a,b)
#define IDirectPlayX_EnumConnections(p,a,b,c,d) 	(p)->lpVtbl->EnumConnections(p,a,b,c,d)
#define IDirectPlayX_EnumGroupsInGroup(p,a,b,c,d,e) (p)->lpVtbl->EnumGroupsInGroup(p,a,b,c,d,e)
#define IDirectPlayX_GetGroupConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetGroupConnectionSettings(p,a,b,c,d)
#define IDirectPlayX_InitializeConnection(p,a,b) 	(p)->lpVtbl->InitializeConnection(p,a,b)
#define IDirectPlayX_SecureOpen(p,a,b,c,d)          (p)->lpVtbl->SecureOpen(p,a,b,c,d)
#define IDirectPlayX_SendChatMessage(p,a,b,c,d)     (p)->lpVtbl->SendChatMessage(p,a,b,c,d)
#define IDirectPlayX_SetGroupConnectionSettings(p,a,b,c) (p)->lpVtbl->SetGroupConnectionSettings(p,a,b,c)
#define IDirectPlayX_StartSession(p,a,b)            (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlayX_GetGroupFlags(p,a,b)           (p)->lpVtbl->GetGroupFlags(p,a,b)
#define IDirectPlayX_GetGroupParent(p,a,b)          (p)->lpVtbl->GetGroupParent(p,a,b)
#define IDirectPlayX_GetPlayerAccount(p,a,b,c,d)    (p)->lpVtbl->GetPlayerAccount(p,a,b,c,d)
#define IDirectPlayX_GetPlayerFlags(p,a,b)          (p)->lpVtbl->GetPlayerFlags(p,a,b)
#define IDirectPlayX_GetGroupOwner(p,a,b)           (p)->lpVtbl->GetGroupOwner(p,a,b)
#define IDirectPlayX_SetGroupOwner(p,a,b)           (p)->lpVtbl->SetGroupOwner(p,a,b)

#else /* C++ */

#define IDirectPlayX_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlayX_AddRef(p)                      (p)->AddRef()
#define IDirectPlayX_Release(p)                     (p)->Release()
#define IDirectPlayX_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlayX_CancelMessage(p,a,b)           (p)->CancelMessage(a,b)
#define IDirectPlayX_CancelPriority(p,a,b,c)        (p)->CancelPriority(a,b,c)
#define IDirectPlayX_Close(p)                       (p)->Close()
#define IDirectPlayX_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlayX_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlayX_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlayX_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlayX_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlayX_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlayX_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlayX_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlayX_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlayX_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlayX_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlayX_GetMessageQueue(p,a,b,c,d,e)   (p)->GetMessageQueue(a,b,c,d,e)
#define IDirectPlayX_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlayX_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlayX_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlayX_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlayX_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlayX_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlayX_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlayX_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlayX_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlayX_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlayX_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlayX_SendEx(p,a,b,c,d,e,f,g,h,i)    (p)->SendEx(a,b,c,d,e,f,g,h,i)
#define IDirectPlayX_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlayX_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlayX_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlayX_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlayX_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)
#define IDirectPlayX_AddGroupToGroup(p,a,b) 		(p)->AddGroupToGroup(a,b)
#define IDirectPlayX_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->CreateGroupInGroup(a,b,c,d,e,f)
#define IDirectPlayX_DeleteGroupFromGroup(p,a,b)   	(p)->DeleteGroupFromGroup(a,b)
#define IDirectPlayX_EnumConnections(p,a,b,c,d)     (p)->EnumConnections(a,b,c,d)
#define IDirectPlayX_EnumGroupsInGroup(p,a,b,c,d,e) (p)->EnumGroupsInGroup(a,b,c,d,e)
#define IDirectPlayX_GetGroupConnectionSettings(p,a,b,c,d) (p)->GetGroupConnectionSettings(a,b,c,d)
#define IDirectPlayX_InitializeConnection(p,a,b)    (p)->InitializeConnection(a,b)
#define IDirectPlayX_SecureOpen(p,a,b,c,d)          (p)->SecureOpen(a,b,c,d)
#define IDirectPlayX_SendChatMessage(p,a,b,c,d)     (p)->SendChatMessage(a,b,c,d)
#define IDirectPlayX_SetGroupConnectionSettings(p,a,b,c) (p)->SetGroupConnectionSettings(a,b,c)
#define IDirectPlayX_StartSession(p,a,b)            (p)->StartSession(a,b)
#define IDirectPlayX_GetGroupFlags(p,a,b)           (p)->GetGroupFlags(a,b)
#define IDirectPlayX_GetGroupParent(p,a,b)          (p)->GetGroupParent(a,b)
#define IDirectPlayX_GetPlayerAccount(p,a,b,c,d)    (p)->GetPlayerAccount(a,b,c,d)
#define IDirectPlayX_GetPlayerFlags(p,a,b)          (p)->GetPlayerFlags(a,b)
#define IDirectPlayX_GetGroupOwner(p,a,b)           (p)->GetGroupOwner(a,b)
#define IDirectPlayX_SetGroupOwner(p,a,b)           (p)->SetGroupOwner(a,b)

#endif

/****************************************************************************
 *
 * EnumConnections API flags
 *
 ****************************************************************************/

/*
 * Enumerate Service Providers
 */
#define DPCONNECTION_DIRECTPLAY      0x00000001

/*
 * Enumerate Lobby Providers
 */
#define DPCONNECTION_DIRECTPLAYLOBBY 0x00000002


/****************************************************************************
 *
 * EnumPlayers API flags
 *
 ****************************************************************************/

/*
 * Enumerate all players in the current session
 */
#define DPENUMPLAYERS_ALL           0x00000000
#define DPENUMGROUPS_ALL            DPENUMPLAYERS_ALL


/*
 * Enumerate only local (created by this application) players
 * or groups
 */
#define DPENUMPLAYERS_LOCAL         0x00000008
#define DPENUMGROUPS_LOCAL			DPENUMPLAYERS_LOCAL

/*
 * Enumerate only remote (non-local) players
 * or groups
 */
#define DPENUMPLAYERS_REMOTE        0x00000010
#define DPENUMGROUPS_REMOTE			DPENUMPLAYERS_REMOTE

/*
 * Enumerate groups along with the players
 */
#define DPENUMPLAYERS_GROUP         0x00000020

/*
 * Enumerate players or groups in another session 
 * (must supply lpguidInstance)
 */
#define DPENUMPLAYERS_SESSION       0x00000080
#define DPENUMGROUPS_SESSION		DPENUMPLAYERS_SESSION

/*
 * Enumerate server players
 */
#define DPENUMPLAYERS_SERVERPLAYER  0x00000100

/*
 * Enumerate spectator players
 */
#define DPENUMPLAYERS_SPECTATOR     0x00000200

/*
 * Enumerate shortcut groups
 */
#define DPENUMGROUPS_SHORTCUT       0x00000400

/*
 * Enumerate staging area groups
 */
#define DPENUMGROUPS_STAGINGAREA    0x00000800

/*
 * Enumerate hidden groups
 */
#define DPENUMGROUPS_HIDDEN         0x00001000

/*
 * Enumerate the group's owner
 */
#define DPENUMPLAYERS_OWNER			0x00002000


/****************************************************************************
 *
 * CreatePlayer API flags
 *
 ****************************************************************************/

/*
 * This flag indicates that this player should be designated
 * the server player. The app should specify this at CreatePlayer.
 */
#define DPPLAYER_SERVERPLAYER           DPENUMPLAYERS_SERVERPLAYER

/*
 * This flag indicates that this player should be designated
 * a spectator. The app should specify this at CreatePlayer.
 */
#define DPPLAYER_SPECTATOR              DPENUMPLAYERS_SPECTATOR

/*
 * This flag indicates that this player was created locally.
 * (returned from GetPlayerFlags)
 */
#define DPPLAYER_LOCAL                  DPENUMPLAYERS_LOCAL

/*
 * This flag indicates that this player is the group's owner
 * (Only returned in EnumGroupPlayers)
 */
#define DPPLAYER_OWNER                   DPENUMPLAYERS_OWNER

/****************************************************************************
 *
 * CreateGroup API flags
 *
 ****************************************************************************/


/*
 * This flag indicates that the StartSession can be called on the group.
 * The app should specify this at CreateGroup, or CreateGroupInGroup.
 */
#define DPGROUP_STAGINGAREA             DPENUMGROUPS_STAGINGAREA

/*
 * This flag indicates that this group was created locally.
 * (returned from GetGroupFlags)
 */
#define DPGROUP_LOCAL                   DPENUMGROUPS_LOCAL

/*
 * This flag indicates that this group was created hidden.
 */
#define DPGROUP_HIDDEN                   DPENUMGROUPS_HIDDEN


/****************************************************************************
 *
 * EnumSessions API flags
 *
 ****************************************************************************/

/*
 * Enumerate sessions which can be joined
 */
#define DPENUMSESSIONS_AVAILABLE    0x00000001 

/*
 * Enumerate all sessions even if they can't be joined.
 */
#define DPENUMSESSIONS_ALL          0x00000002




/*
 * Start an asynchronous enum sessions
 */
 #define DPENUMSESSIONS_ASYNC		0x00000010

/*
 * Stop an asynchronous enum sessions
 */
 #define DPENUMSESSIONS_STOPASYNC	0x00000020
 
/*
 * Enumerate sessions even if they require a password
 */
 #define DPENUMSESSIONS_PASSWORDREQUIRED	0x00000040

/*
 * Return status about progress of enumeration instead of
 * showing any status dialogs.
 */
 #define DPENUMSESSIONS_RETURNSTATUS 0x00000080

/****************************************************************************
 *
 * GetCaps and GetPlayerCaps API flags
 *
 ****************************************************************************/

/*
 * The latency returned should be for guaranteed message sending.
 * Default is non-guaranteed messaging.
 */
#define DPGETCAPS_GUARANTEED        0x00000001 

 
/****************************************************************************
 *
 * GetGroupData, GetPlayerData API flags
 * Remote and local Group/Player data is maintained separately. 
 * Default is DPGET_REMOTE.
 *
 ****************************************************************************/

/*
 * Get the remote data (set by any DirectPlay object in
 * the session using DPSET_REMOTE)
 */
#define DPGET_REMOTE                0x00000000
	
/*
 * Get the local data (set by this DirectPlay object 
 * using DPSET_LOCAL)
 */
#define DPGET_LOCAL                 0x00000001


/****************************************************************************
 *
 * Open API flags
 *
 ****************************************************************************/

/*
 * Join the session that is described by the DPSESSIONDESC2 structure
 */
#define DPOPEN_JOIN                 0x00000001

/*
 * Create a new session as described by the DPSESSIONDESC2 structure
 */
#define DPOPEN_CREATE               0x00000002

/*
 * Return status about progress of open instead of showing
 * any status dialogs.
 */
 #define DPOPEN_RETURNSTATUS		DPENUMSESSIONS_RETURNSTATUS



/****************************************************************************
 *
 * DPLCONNECTION flags
 *
 ****************************************************************************/

/*
 * This application should create a new session as
 * described by the DPSESIONDESC structure
 */
#define DPLCONNECTION_CREATESESSION					DPOPEN_CREATE

/*
 * This application should join the session described by 
 * the DPSESIONDESC structure with the lpAddress data
 */
#define DPLCONNECTION_JOINSESSION					DPOPEN_JOIN

/****************************************************************************
 *
 * Receive API flags
 * Default is DPRECEIVE_ALL
 *
 ****************************************************************************/

/*
 * Get the first message in the queue
 */
#define DPRECEIVE_ALL               0x00000001

/*
 * Get the first message in the queue directed to a specific player 
 */
#define DPRECEIVE_TOPLAYER          0x00000002

/*
 * Get the first message in the queue from a specific player
 */
#define DPRECEIVE_FROMPLAYER        0x00000004

/*
 * Get the message but don't remove it from the queue
 */
#define DPRECEIVE_PEEK              0x00000008


/****************************************************************************
 *
 * Send API flags
 *
 ****************************************************************************/

/*
 * Send the message using a guaranteed send method.
 * Default is non-guaranteed.
 */
#define DPSEND_GUARANTEED           0x00000001


/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_HIGHPRIORITY         0x00000002

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_OPENSTREAM           0x00000008

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_CLOSESTREAM          0x00000010

/*
 * Send the message digitally signed to ensure authenticity.
 */
#define DPSEND_SIGNED               0x00000020

/*
 * Send the message with encryption to ensure privacy.
 */
#define DPSEND_ENCRYPTED            0x00000040

/*
 * The message is a lobby system message
 */
#define DPSEND_LOBBYSYSTEMMESSAGE	0x00000080


// andyco - added this so we can make addforward async.
// needs to be sanitized when we add / expose full async
// support.  8/3/97.
#define DPSEND_ASYNC				0x00000200

/*
 * When an message is completed, don't tell me. 
 * by default the application is notified with a system message.
 */
#define DPSEND_NOSENDCOMPLETEMSG    0x00000400


/*
 * Maximum priority for sends available to applications
 */
#define DPSEND_MAX_PRI              0x0000FFFF
#define DPSEND_MAX_PRIORITY         DPSEND_MAX_PRI


/****************************************************************************
 *
 * SetGroupData, SetGroupName, SetPlayerData, SetPlayerName,
 * SetSessionDesc API flags.
 * Default is DPSET_REMOTE.
 *
 ****************************************************************************/

/* 
 * Propagate the data to all players in the session
 */
#define DPSET_REMOTE                0x00000000

/*
 * Do not propagate the data to other players
 */
#define DPSET_LOCAL                 0x00000001

/*
 * Used with DPSET_REMOTE, use guaranteed message send to
 * propagate the data
 */
#define DPSET_GUARANTEED            0x00000002

/****************************************************************************
 *
 * GetMessageQueue API flags.
 * Default is DPMESSAGEQUEUE_SEND
 *
 ****************************************************************************/

/* 
 * Get Send Queue - requires Service Provider Support
 */
#define DPMESSAGEQUEUE_SEND        	0x00000001

/*
 * Get Receive Queue
 */
#define DPMESSAGEQUEUE_RECEIVE      0x00000002


/****************************************************************************
 *
 * Connect API flags
 *
 ****************************************************************************/

 
/*
 * Start an asynchronous connect which returns status codes
 */
#define DPCONNECT_RETURNSTATUS      (DPENUMSESSIONS_RETURNSTATUS)


/****************************************************************************
 *
 * DirectPlay system messages and message data structures
 *
 * All system message come 'From' player DPID_SYSMSG.  To determine what type 
 * of message it is, cast the lpData from Receive to DPMSG_GENERIC and check
 * the dwType member against one of the following DPSYS_xxx constants. Once
 * a match is found, cast the lpData to the corresponding of the DPMSG_xxx
 * structures to access the data of the message.
 *
 ****************************************************************************/

/*
 * A new player or group has been created in the session
 * Use DPMSG_CREATEPLAYERORGROUP.  Check dwPlayerType to see if it
 * is a player or a group.
 */
#define DPSYS_CREATEPLAYERORGROUP   0x0003  

/*
 * A player has been deleted from the session
 * Use DPMSG_DESTROYPLAYERORGROUP
 */
#define DPSYS_DESTROYPLAYERORGROUP  0x0005  

/*
 * A player has been added to a group
 * Use DPMSG_ADDPLAYERTOGROUP
 */
#define DPSYS_ADDPLAYERTOGROUP      0x0007  

/*
 * A player has been removed from a group
 * Use DPMSG_DELETEPLAYERFROMGROUP
 */
#define DPSYS_DELETEPLAYERFROMGROUP 0x0021  

/*
 * This DirectPlay object lost its connection with all the
 * other players in the session.
 * Use DPMSG_SESSIONLOST.
 */
#define DPSYS_SESSIONLOST           0x0031

/*
 * The current host has left the session.
 * This DirectPlay object is now the host.
 * Use DPMSG_HOST.
 */
#define DPSYS_HOST                  0x0101

/*
 * The remote data associated with a player or
 * group has changed. Check dwPlayerType to see
 * if it is a player or a group
 * Use DPMSG_SETPLAYERORGROUPDATA
 */
#define DPSYS_SETPLAYERORGROUPDATA  0x0102

/*
 * The name of a player or group has changed.
 * Check dwPlayerType to see if it is a player
 * or a group.
 * Use DPMSG_SETPLAYERORGROUPNAME
 */
#define DPSYS_SETPLAYERORGROUPNAME  0x0103

/*
 * The session description has changed.
 * Use DPMSG_SETSESSIONDESC
 */
#define DPSYS_SETSESSIONDESC        0x0104

/*
 * A group has been added to a group
 * Use DPMSG_ADDGROUPTOGROUP
 */
#define DPSYS_ADDGROUPTOGROUP      	0x0105  

/*
 * A group has been removed from a group
 * Use DPMSG_DELETEGROUPFROMGROUP
 */
#define DPSYS_DELETEGROUPFROMGROUP 	0x0106

/*
 * A secure player-player message has arrived.
 * Use DPMSG_SECUREMESSAGE
 */
#define DPSYS_SECUREMESSAGE         0x0107

/*
 * Start a new session.
 * Use DPMSG_STARTSESSION
 */
#define DPSYS_STARTSESSION          0x0108

/*
 * A chat message has arrived
 * Use DPMSG_CHAT
 */
#define DPSYS_CHAT                  0x0109

/*
 * The owner of a group has changed
 * Use DPMSG_SETGROUPOWNER
 */
#define DPSYS_SETGROUPOWNER         0x010A

/*
 * An async send has finished, failed or been cancelled
 * Use DPMSG_SENDCOMPLETE
 */
#define DPSYS_SENDCOMPLETE          0x010d


/*
 * Used in the dwPlayerType field to indicate if it applies to a group
 * or a player
 */
#define DPPLAYERTYPE_GROUP          0x00000000
#define DPPLAYERTYPE_PLAYER         0x00000001


/*
 * DPMSG_GENERIC
 * Generic message structure used to identify the message type.
 */
typedef struct
{
    DWORD       dwType;         // Message type
} DPMSG_GENERIC, FAR *LPDPMSG_GENERIC;

/*
 * DPMSG_CREATEPLAYERORGROUP
 * System message generated when a new player or group
 * created in the session with information about it.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of the player or group
    DWORD       dwCurrentPlayers;   // current # players & groups in session
    LPVOID      lpData;         // pointer to remote data
    DWORD       dwDataSize;     // size of remote data
    DPNAME      dpnName;        // structure with name info
	// the following fields are only available when using
	// the IDirectPlay3 interface or greater
    DPID	    dpIdParent;     // id of parent group
	DWORD		dwFlags;		// player or group flags
} DPMSG_CREATEPLAYERORGROUP, FAR *LPDPMSG_CREATEPLAYERORGROUP;

/*
 * DPMSG_DESTROYPLAYERORGROUP
 * System message generated when a player or group is being
 * destroyed in the session with information about it.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // player ID being deleted
    LPVOID      lpLocalData;    // copy of players local data
    DWORD       dwLocalDataSize; // sizeof local data
    LPVOID      lpRemoteData;   // copy of players remote data
    DWORD       dwRemoteDataSize; // sizeof remote data
	// the following fields are only available when using
	// the IDirectPlay3 interface or greater
    DPNAME      dpnName;        // structure with name info
    DPID	    dpIdParent;     // id of parent group	
	DWORD		dwFlags;		// player or group flags
} DPMSG_DESTROYPLAYERORGROUP, FAR *LPDPMSG_DESTROYPLAYERORGROUP;

/*
 * DPMSG_ADDPLAYERTOGROUP
 * System message generated when a player is being added
 * to a group.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        dpIdGroup;      // group ID being added to
    DPID        dpIdPlayer;     // player ID being added
} DPMSG_ADDPLAYERTOGROUP, FAR *LPDPMSG_ADDPLAYERTOGROUP;

/*
 * DPMSG_DELETEPLAYERFROMGROUP
 * System message generated when a player is being
 * removed from a group
 */
typedef DPMSG_ADDPLAYERTOGROUP          DPMSG_DELETEPLAYERFROMGROUP;
typedef DPMSG_DELETEPLAYERFROMGROUP     FAR *LPDPMSG_DELETEPLAYERFROMGROUP;

/*
 * DPMSG_ADDGROUPTOGROUP
 * System message generated when a group is being added
 * to a group.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        dpIdParentGroup; // group ID being added to
    DPID        dpIdGroup;     // group ID being added
} DPMSG_ADDGROUPTOGROUP, FAR *LPDPMSG_ADDGROUPTOGROUP;

/*
 * DPMSG_DELETEGROUPFROMGROUP
 * System message generated when a GROUP is being
 * removed from a group
 */
typedef DPMSG_ADDGROUPTOGROUP          DPMSG_DELETEGROUPFROMGROUP;
typedef DPMSG_DELETEGROUPFROMGROUP     FAR *LPDPMSG_DELETEGROUPFROMGROUP;

/*
 * DPMSG_SETPLAYERORGROUPDATA
 * System message generated when remote data for a player or
 * group has changed.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of player or group
    LPVOID      lpData;         // pointer to remote data
    DWORD       dwDataSize;     // size of remote data
} DPMSG_SETPLAYERORGROUPDATA, FAR *LPDPMSG_SETPLAYERORGROUPDATA;

/*
 * DPMSG_SETPLAYERORGROUPNAME
 * System message generated when the name of a player or
 * group has changed.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of player or group
    DPNAME      dpnName;        // structure with new name info
} DPMSG_SETPLAYERORGROUPNAME, FAR *LPDPMSG_SETPLAYERORGROUPNAME;

/*
 * DPMSG_SETSESSIONDESC
 * System message generated when session desc has changed
 */
typedef struct
{
    DWORD           dwType;     // Message type
    DPSESSIONDESC2  dpDesc;     // Session desc
} DPMSG_SETSESSIONDESC, FAR *LPDPMSG_SETSESSIONDESC;

/*
 * DPMSG_HOST
 * System message generated when the host has migrated to this
 * DirectPlay object.
 *
 */
typedef DPMSG_GENERIC       DPMSG_HOST;
typedef DPMSG_HOST          FAR *LPDPMSG_HOST;

/*
 * DPMSG_SESSIONLOST
 * System message generated when the connection to the session is lost.
 *
 */
typedef DPMSG_GENERIC       DPMSG_SESSIONLOST;
typedef DPMSG_SESSIONLOST   FAR *LPDPMSG_SESSIONLOST;

/*
 * DPMSG_SECUREMESSAGE
 * System message generated when a player requests a secure send
 */
typedef struct 
{
    DWORD		dwType;         // Message Type
    DWORD		dwFlags;        // Signed/Encrypted
    DPID        dpIdFrom;       // ID of Sending Player
    LPVOID		lpData;         // Player message
    DWORD		dwDataSize;     // Size of player message
} DPMSG_SECUREMESSAGE, FAR *LPDPMSG_SECUREMESSAGE;

/*
 * DPMSG_STARTSESSION
 * System message containing all information required to 
 * start a new session
 */
typedef struct
{
    DWORD              dwType;     // Message type
    LPDPLCONNECTION    lpConn;     // DPLCONNECTION structure
} DPMSG_STARTSESSION, FAR *LPDPMSG_STARTSESSION;

/*
 * DPMSG_CHAT
 * System message containing a chat message
 */
typedef struct
{
    DWORD              	dwType;       	// Message type
    DWORD              	dwFlags;      	// Message flags
    DPID               	idFromPlayer; 	// ID of the Sending Player
    DPID               	idToPlayer;   	// ID of the To Player
    DPID               	idToGroup;    	// ID of the To Group
	LPDPCHAT 			lpChat;			// Pointer to a structure containing the chat message
} DPMSG_CHAT, FAR *LPDPMSG_CHAT;

/*
 * DPMSG_SETGROUPOWNER
 * System message generated when the owner of a group has changed
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        idGroup;        // ID of the group
    DPID        idNewOwner;     // ID of the player that is the new owner
    DPID        idOldOwner;     // ID of the player that used to be the owner
} DPMSG_SETGROUPOWNER, FAR *LPDPMSG_SETGROUPOWNER;

/*
 * DPMSG_SENDCOMPLETE
 * System message generated when finished with an Async Send message
 *
 * NOTE SENDPARMS has an overlay for DPMSG_SENDCOMPLETE, don't
 *                change this message w/o changing SENDPARMS.
 */
typedef struct
{
	DWORD 		dwType;
	DPID		idFrom;
	DPID		idTo;
	DWORD		dwFlags;
	DWORD		dwPriority;
	DWORD		dwTimeout;
	LPVOID		lpvContext;
	DWORD		dwMsgID;
	HRESULT     hr;
	DWORD       dwSendTime;
} DPMSG_SENDCOMPLETE, *LPDPMSG_SENDCOMPLETE;

/****************************************************************************
 *
 * DIRECTPLAY ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/
#define DP_OK                           S_OK
#define DPERR_ALREADYINITIALIZED        MAKE_DPHRESULT(   5 )
#define DPERR_ACCESSDENIED              MAKE_DPHRESULT(  10 )
#define DPERR_ACTIVEPLAYERS             MAKE_DPHRESULT(  20 )
#define DPERR_BUFFERTOOSMALL            MAKE_DPHRESULT(  30 )
#define DPERR_CANTADDPLAYER             MAKE_DPHRESULT(  40 )
#define DPERR_CANTCREATEGROUP           MAKE_DPHRESULT(  50 )
#define DPERR_CANTCREATEPLAYER          MAKE_DPHRESULT(  60 )
#define DPERR_CANTCREATESESSION         MAKE_DPHRESULT(  70 )
#define DPERR_CAPSNOTAVAILABLEYET       MAKE_DPHRESULT(  80 )
#define DPERR_EXCEPTION                 MAKE_DPHRESULT(  90 )
#define DPERR_GENERIC                   E_FAIL
#define DPERR_INVALIDFLAGS              MAKE_DPHRESULT( 120 )
#define DPERR_INVALIDOBJECT             MAKE_DPHRESULT( 130 )
#define DPERR_INVALIDPARAM              E_INVALIDARG
#define DPERR_INVALIDPARAMS             DPERR_INVALIDPARAM
#define DPERR_INVALIDPLAYER             MAKE_DPHRESULT( 150 )
#define DPERR_INVALIDGROUP             	MAKE_DPHRESULT( 155 )
#define DPERR_NOCAPS                    MAKE_DPHRESULT( 160 )
#define DPERR_NOCONNECTION              MAKE_DPHRESULT( 170 )
#define DPERR_NOMEMORY                  E_OUTOFMEMORY
#define DPERR_OUTOFMEMORY               DPERR_NOMEMORY
#define DPERR_NOMESSAGES                MAKE_DPHRESULT( 190 )
#define DPERR_NONAMESERVERFOUND         MAKE_DPHRESULT( 200 )
#define DPERR_NOPLAYERS                 MAKE_DPHRESULT( 210 )
#define DPERR_NOSESSIONS                MAKE_DPHRESULT( 220 )
#define DPERR_PENDING					E_PENDING
#define DPERR_SENDTOOBIG				MAKE_DPHRESULT( 230 )
#define DPERR_TIMEOUT                   MAKE_DPHRESULT( 240 )
#define DPERR_UNAVAILABLE               MAKE_DPHRESULT( 250 )
#define DPERR_UNSUPPORTED               E_NOTIMPL
#define DPERR_BUSY                      MAKE_DPHRESULT( 270 )
#define DPERR_USERCANCEL                MAKE_DPHRESULT( 280 ) 
#define DPERR_NOINTERFACE               E_NOINTERFACE
#define DPERR_CANNOTCREATESERVER        MAKE_DPHRESULT( 290 )
#define DPERR_PLAYERLOST                MAKE_DPHRESULT( 300 )
#define DPERR_SESSIONLOST               MAKE_DPHRESULT( 310 )
#define DPERR_UNINITIALIZED             MAKE_DPHRESULT( 320 )
#define DPERR_NONEWPLAYERS              MAKE_DPHRESULT( 330 )
#define DPERR_INVALIDPASSWORD           MAKE_DPHRESULT( 340 )
#define DPERR_CONNECTING                MAKE_DPHRESULT( 350 )
#define DPERR_CONNECTIONLOST            MAKE_DPHRESULT( 360 )
#define DPERR_UNKNOWNMESSAGE            MAKE_DPHRESULT( 370 )
#define DPERR_CANCELFAILED              MAKE_DPHRESULT( 380 )
#define DPERR_INVALIDPRIORITY           MAKE_DPHRESULT( 390 )
#define DPERR_NOTHANDLED                MAKE_DPHRESULT( 400 )
#define DPERR_CANCELLED                 MAKE_DPHRESULT( 410 )
#define DPERR_ABORTED                   MAKE_DPHRESULT( 420 )


#define DPERR_BUFFERTOOLARGE            MAKE_DPHRESULT( 1000 )
#define DPERR_CANTCREATEPROCESS         MAKE_DPHRESULT( 1010 )
#define DPERR_APPNOTSTARTED             MAKE_DPHRESULT( 1020 )
#define DPERR_INVALIDINTERFACE          MAKE_DPHRESULT( 1030 )
#define DPERR_NOSERVICEPROVIDER         MAKE_DPHRESULT( 1040 )
#define DPERR_UNKNOWNAPPLICATION        MAKE_DPHRESULT( 1050 )
#define DPERR_NOTLOBBIED                MAKE_DPHRESULT( 1070 )
#define DPERR_SERVICEPROVIDERLOADED		MAKE_DPHRESULT( 1080 )
#define DPERR_ALREADYREGISTERED			MAKE_DPHRESULT( 1090 )
#define DPERR_NOTREGISTERED				MAKE_DPHRESULT( 1100 )

//
// Security related errors
//
#define DPERR_AUTHENTICATIONFAILED      MAKE_DPHRESULT(  2000 )
#define DPERR_CANTLOADSSPI              MAKE_DPHRESULT(  2010 )
#define DPERR_ENCRYPTIONFAILED          MAKE_DPHRESULT(  2020 )
#define DPERR_SIGNFAILED                MAKE_DPHRESULT(  2030 )
#define DPERR_CANTLOADSECURITYPACKAGE   MAKE_DPHRESULT(  2040 )
#define DPERR_ENCRYPTIONNOTSUPPORTED    MAKE_DPHRESULT(  2050 )
#define DPERR_CANTLOADCAPI              MAKE_DPHRESULT(  2060 )
#define DPERR_NOTLOGGEDIN               MAKE_DPHRESULT(  2070 )
#define DPERR_LOGONDENIED               MAKE_DPHRESULT(  2080 )


/****************************************************************************
 *
 * 	dplay 1.0 obsolete structures + interfaces
 *	Included for compatibility only. New apps should
 *	use IDirectPlay2
 *
 ****************************************************************************/

// define this to ignore obsolete interfaces and constants
#ifndef IDIRECTPLAY2_OR_GREATER

#define DPOPEN_OPENSESSION          DPOPEN_JOIN
#define DPOPEN_CREATESESSION        DPOPEN_CREATE

#define DPENUMSESSIONS_PREVIOUS     0x00000004

#define DPENUMPLAYERS_PREVIOUS      0x00000004

#define DPSEND_GUARANTEE            DPSEND_GUARANTEED
#define DPSEND_TRYONCE              0x00000004

#define DPCAPS_NAMESERVICE          0x00000001
#define DPCAPS_NAMESERVER           DPCAPS_ISHOST
#define DPCAPS_GUARANTEED           0x00000004

#define DPLONGNAMELEN               52
#define DPSHORTNAMELEN              20
#define DPSESSIONNAMELEN            32
#define DPPASSWORDLEN               16
#define DPUSERRESERVED              16

#define DPSYS_ADDPLAYER             0x0003
#define DPSYS_DELETEPLAYER          0x0005

#define DPSYS_DELETEGROUP           0x0020
#define DPSYS_DELETEPLAYERFROMGRP   0x0021
#define DPSYS_CONNECT               0x484b

typedef struct
{
    DWORD       dwType;
    DWORD       dwPlayerType;
    DPID        dpId;
    char        szLongName[DPLONGNAMELEN];
    char        szShortName[DPSHORTNAMELEN];
    DWORD       dwCurrentPlayers;
}   DPMSG_ADDPLAYER;

typedef DPMSG_ADDPLAYER DPMSG_ADDGROUP;

typedef struct
{
    DWORD       dwType;
    DPID        dpIdGroup;
    DPID        dpIdPlayer;
} DPMSG_GROUPADD;

typedef DPMSG_GROUPADD DPMSG_GROUPDELETE;
typedef struct
{
    DWORD       dwType;
    DPID        dpId;
} DPMSG_DELETEPLAYER;

typedef BOOL (PASCAL *LPDPENUMPLAYERSCALLBACK)(
    DPID    dpId,
    LPSTR   lpFriendlyName,
    LPSTR   lpFormalName,
    DWORD   dwFlags,
    LPVOID  lpContext );

typedef struct
{
    DWORD   dwSize;
    GUID    guidSession;                  
    DWORD   dwSession;                    
    DWORD   dwMaxPlayers;                 
    DWORD   dwCurrentPlayers;             
    DWORD   dwFlags;                      
    char    szSessionName[DPSESSIONNAMELEN];
    char    szUserField[DPUSERRESERVED];
    DWORD   dwReserved1;                  
    char    szPassword[DPPASSWORDLEN];    
    DWORD   dwReserved2;                  
    DWORD   dwUser1;
    DWORD   dwUser2;
    DWORD   dwUser3;
    DWORD   dwUser4;
} DPSESSIONDESC,*LPDPSESSIONDESC;

typedef BOOL (PASCAL * LPDPENUMSESSIONSCALLBACK)(
    LPDPSESSIONDESC lpDPSessionDesc,
    LPVOID      lpContext,
    LPDWORD     lpdwTimeOut,
    DWORD       dwFlags);

/*
 * IDirectPlay
 */
#undef INTERFACE
#define INTERFACE IDirectPlay
DECLARE_INTERFACE_( IDirectPlay, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPSTR,LPSTR,LPHANDLE) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPSTR,LPSTR) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(EnableNewPlayers)     (THIS_ BOOL) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ DWORD, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ DWORD, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC,DWORD,LPDPENUMSESSIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID, LPDPCAPS) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPSTR,LPDWORD,LPSTR,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(SaveSession)          (THIS_ LPSTR) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPSTR,LPSTR) PURE;
};

/****************************************************************************
 *
 * IDirectPlay interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay_AddPlayerToGroup(p,a,b)         (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay_Close(p)                        (p)->lpVtbl->Close(p)
#define IDirectPlay_CreateGroup(p,a,b,c)            (p)->lpVtbl->CreateGroup(p,a,b,c)
#define IDirectPlay_CreatePlayer(p,a,b,c,d)         (p)->lpVtbl->CreatePlayer(p,a,b,c,d)
#define IDirectPlay_DeletePlayerFromGroup(p,a,b)    (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay_DestroyGroup(p,a)               (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay_DestroyPlayer(p,a)              (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay_EnableNewPlayers(p,a)           (p)->lpVtbl->EnableNewPlayers(p,a)
#define IDirectPlay_EnumGroupPlayers(p,a,b,c,d)     (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d)
#define IDirectPlay_EnumGroups(p,a,b,c,d)           (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay_EnumPlayers(p,a,b,c,d)          (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay_EnumSessions(p,a,b,c,d,e)       (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectPlay_GetMessageCount(p,a,b)          (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay_GetPlayerCaps(p,a,b)            (p)->lpVtbl->GetPlayerCaps(p,a,b)
#define IDirectPlay_GetPlayerName(p,a,b,c,d,e)      (p)->lpVtbl->GetPlayerName(p,a,b,c,d,e)
#define IDirectPlay_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay_Open(p,a)                       (p)->lpVtbl->Open(p,a)
#define IDirectPlay_Receive(p,a,b,c,d,e)            (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay_SaveSession(p,a)                (p)->lpVtbl->SaveSession(p,a)
#define IDirectPlay_Send(p,a,b,c,d,e)               (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay_SetPlayerName(p,a,b,c)          (p)->lpVtbl->SetPlayerName(p,a,b,c)

#else /* C++ */

#define IDirectPlay_AddPlayerToGroup(p,a,b)         (p)->AddPlayerToGroup(a,b)
#define IDirectPlay_Close(p)                        (p)->Close()
#define IDirectPlay_CreateGroup(p,a,b,c)            (p)->CreateGroup(a,b,c)
#define IDirectPlay_CreatePlayer(p,a,b,c,d)         (p)->CreatePlayer(a,b,c,d)
#define IDirectPlay_DeletePlayerFromGroup(p,a,b)    (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay_DestroyGroup(p,a)               (p)->DestroyGroup(a)
#define IDirectPlay_DestroyPlayer(p,a)              (p)->DestroyPlayer(a)
#define IDirectPlay_EnableNewPlayers(p,a)           (p)->EnableNewPlayers(a)
#define IDirectPlay_EnumGroupPlayers(p,a,b,c,d)     (p)->EnumGroupPlayers(a,b,c,d)
#define IDirectPlay_EnumGroups(p,a,b,c,d)           (p)->EnumGroups(a,b,c,d)
#define IDirectPlay_EnumPlayers(p,a,b,c,d)          (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay_EnumSessions(p,a,b,c,d,e)       (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectPlay_GetMessageCount(p,a,b)          (p)->GetMessageCount(a,b)
#define IDirectPlay_GetPlayerCaps(p,a,b)            (p)->GetPlayerCaps(a,b)
#define IDirectPlay_GetPlayerName(p,a,b,c,d,e)      (p)->GetPlayerName(a,b,c,d,e)
#define IDirectPlay_Initialize(p,a)                 (p)->Initialize(a)
#define IDirectPlay_Open(p,a)                       (p)->Open(a)
#define IDirectPlay_Receive(p,a,b,c,d,e)            (p)->Receive(a,b,c,d,e)
#define IDirectPlay_SaveSession(p,a)                (p)->SaveSession(a)
#define IDirectPlay_Send(p,a,b,c,d,e)               (p)->Send(a,b,c,d,e)
#define IDirectPlay_SetPlayerName(p,a,b,c)          (p)->SetPlayerName(a,b,c)

#endif

DEFINE_GUID(IID_IDirectPlay, 0x5454e9a0, 0xdb65, 0x11ce, 0x92, 0x1c, 0x00, 0xaa, 0x00, 0x6c, 0x49, 0x72);

#endif // IDIRECTPLAY2_OR_GREATER

/****************************************************************************
 *
 * IDirectPlay macros (included regardless of IDIRECTPLAY2_OR_GREATER flag)
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay_QueryInterface(p,a,b)           (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectPlay_Release(p)                      (p)->lpVtbl->Release(p)

#else

#define IDirectPlay_QueryInterface(p,a,b)           (p)->QueryInterface(a,b)
#define IDirectPlay_AddRef(p)                       (p)->AddRef()
#define IDirectPlay_Release(p)                      (p)->Release()

#endif // IDirectPlay interface macros 




#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\dplobby.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobby.h
 *  Content:    DirectPlayLobby include file
 ***************************************************************************/
#ifndef __DPLOBBY_INCLUDED__
#define __DPLOBBY_INCLUDED__

#include "dplay.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*
 * GUIDS used by DirectPlay objects
 */

/* {AF465C71-9588-11cf-A020-00AA006157AC} */
DEFINE_GUID(IID_IDirectPlayLobby, 0xaf465c71, 0x9588, 0x11cf, 0xa0, 0x20, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
/* {26C66A70-B367-11cf-A024-00AA006157AC} */
DEFINE_GUID(IID_IDirectPlayLobbyA, 0x26c66a70, 0xb367, 0x11cf, 0xa0, 0x24, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
/* {0194C220-A303-11d0-9C4F-00A0C905425E} */
DEFINE_GUID(IID_IDirectPlayLobby2, 0x194c220, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
/* {1BB4AF80-A303-11d0-9C4F-00A0C905425E} */
DEFINE_GUID(IID_IDirectPlayLobby2A, 0x1bb4af80, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
/* {2DB72490-652C-11d1-A7A8-0000F803ABFC} */
DEFINE_GUID(IID_IDirectPlayLobby3, 0x2db72490, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
/* {2DB72491-652C-11d1-A7A8-0000F803ABFC} */
DEFINE_GUID(IID_IDirectPlayLobby3A, 0x2db72491, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
/* {2FE8F810-B2A5-11d0-A787-0000F803ABFC} */
DEFINE_GUID(CLSID_DirectPlayLobby, 0x2fe8f810, 0xb2a5, 0x11d0, 0xa7, 0x87, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);


/****************************************************************************
 *
 * IDirectPlayLobby Structures
 *
 * Various structures used to invoke DirectPlayLobby.
 *
 ****************************************************************************/

typedef struct IDirectPlayLobby     FAR *LPDIRECTPLAYLOBBY;
typedef struct IDirectPlayLobby     FAR *LPDIRECTPLAYLOBBYA;
typedef struct IDirectPlayLobby     IDirectPlayLobbyA;

typedef struct IDirectPlayLobby2    FAR *LPDIRECTPLAYLOBBY2;
typedef struct IDirectPlayLobby2    FAR *LPDIRECTPLAYLOBBY2A;
typedef struct IDirectPlayLobby2    IDirectPlayLobby2A;

typedef struct IDirectPlayLobby3    FAR *LPDIRECTPLAYLOBBY3;
typedef struct IDirectPlayLobby3    FAR *LPDIRECTPLAYLOBBY3A;
typedef struct IDirectPlayLobby3    IDirectPlayLobby3A;


/*
 * DPLAPPINFO
 * Used to hold information about a registered DirectPlay
 * application
 */
typedef struct DPLAPPINFO
{
    DWORD       dwSize;             // Size of this structure
    GUID        guidApplication;    // GUID of the Application
    union
    {
        LPSTR   lpszAppNameA;       // Pointer to the Application Name
        LPWSTR  lpszAppName;
    };

} DPLAPPINFO, FAR *LPDPLAPPINFO;

/*
 * LPCDPLAPPINFO
 * A constant pointer to DPLAPPINFO
 */
typedef const DPLAPPINFO FAR *LPCDPLAPPINFO;

/*
 * DPCOMPOUNDADDRESSELEMENT
 *
 * An array of these is passed to CreateCompoundAddresses()
 */
typedef struct DPCOMPOUNDADDRESSELEMENT
{
    GUID                guidDataType;
    DWORD               dwDataSize;
	LPVOID				lpData;
} DPCOMPOUNDADDRESSELEMENT, FAR *LPDPCOMPOUNDADDRESSELEMENT;

/*
 * LPCDPCOMPOUNDADDRESSELEMENT
 * A constant pointer to DPCOMPOUNDADDRESSELEMENT
 */
typedef const DPCOMPOUNDADDRESSELEMENT FAR *LPCDPCOMPOUNDADDRESSELEMENT;

/*
 * LPDPAPPLICATIONDESC
 * Used to register a DirectPlay application
 */
typedef struct DPAPPLICATIONDESC
{
    DWORD       dwSize;
    DWORD       dwFlags;
    union
    {
        LPSTR       lpszApplicationNameA;
        LPWSTR      lpszApplicationName;
    };
    GUID        guidApplication;
    union
    {
        LPSTR       lpszFilenameA;
        LPWSTR      lpszFilename;
    };
    union
    {
        LPSTR       lpszCommandLineA;
        LPWSTR      lpszCommandLine;
    };
    union
    {
        LPSTR       lpszPathA;
        LPWSTR      lpszPath;
    };
    union
    {
        LPSTR       lpszCurrentDirectoryA;
        LPWSTR      lpszCurrentDirectory;
    };
    LPSTR       lpszDescriptionA;
    LPWSTR      lpszDescriptionW;
} DPAPPLICATIONDESC, *LPDPAPPLICATIONDESC;


/****************************************************************************
 *
 * Enumeration Method Callback Prototypes
 *
 ****************************************************************************/

/*
 * Callback for EnumAddress()
 */
typedef BOOL (FAR PASCAL *LPDPENUMADDRESSCALLBACK)(
    REFGUID         guidDataType,
    DWORD           dwDataSize,
    LPCVOID         lpData,
    LPVOID          lpContext);

/*
 * Callback for EnumAddressTypes()
 */
typedef BOOL (FAR PASCAL *LPDPLENUMADDRESSTYPESCALLBACK)(
    REFGUID         guidDataType,
    LPVOID          lpContext,
    DWORD           dwFlags);

/*
 * Callback for EnumLocalApplications()
 */
typedef BOOL (FAR PASCAL * LPDPLENUMLOCALAPPLICATIONSCALLBACK)(
    LPCDPLAPPINFO   lpAppInfo,
    LPVOID          lpContext,
    DWORD           dwFlags);


/****************************************************************************
 *
 * DirectPlayLobby API Prototypes
 *
 ****************************************************************************/
#ifdef UNICODE
#define DirectPlayLobbyCreate   DirectPlayLobbyCreateW
#else
#define DirectPlayLobbyCreate   DirectPlayLobbyCreateA
#endif /* UNICODE */

extern HRESULT WINAPI DirectPlayLobbyCreateW(LPGUID, LPDIRECTPLAYLOBBY *, IUnknown *, LPVOID, DWORD );
extern HRESULT WINAPI DirectPlayLobbyCreateA(LPGUID, LPDIRECTPLAYLOBBYA *, IUnknown *, LPVOID, DWORD );


/****************************************************************************
 *
 * IDirectPlayLobby (and IDirectPlayLobbyA) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby
DECLARE_INTERFACE_( IDirectPlayLobby, IUnknown )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

};

/****************************************************************************
 *
 * IDirectPlayLobby2 (and IDirectPlayLobby2A) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby2
DECLARE_INTERFACE_( IDirectPlayLobby2, IDirectPlayLobby )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

    /*  IDirectPlayLobby2 Methods	*/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayLobby3 (and IDirectPlayLobby3A) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby3
DECLARE_INTERFACE_( IDirectPlayLobby3, IDirectPlayLobby )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

    /*  IDirectPlayLobby2 Methods	*/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;

    /*  IDirectPlayLobby3 Methods	*/
    STDMETHOD(ConnectEx)            (THIS_ DWORD, REFIID, LPVOID *, IUnknown FAR *) PURE;
    STDMETHOD(RegisterApplication)  (THIS_ DWORD, LPDPAPPLICATIONDESC) PURE;
    STDMETHOD(UnregisterApplication)(THIS_ DWORD, REFGUID) PURE;
    STDMETHOD(WaitForConnectionSettings)(THIS_ DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayLobby interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayLobby_QueryInterface(p,a,b)              (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayLobby_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IDirectPlayLobby_Release(p)                         (p)->lpVtbl->Release(p)
#define IDirectPlayLobby_Connect(p,a,b,c)                   (p)->lpVtbl->Connect(p,a,b,c)
#define IDirectPlayLobby_ConnectEx(p,a,b,c,d)               (p)->lpVtbl->ConnectEx(p,a,b,c,d)
#define IDirectPlayLobby_CreateAddress(p,a,b,c,d,e,f)       (p)->lpVtbl->CreateAddress(p,a,b,c,d,e,f)
#define IDirectPlayLobby_CreateCompoundAddress(p,a,b,c,d)   (p)->lpVtbl->CreateCompoundAddress(p,a,b,c,d)
#define IDirectPlayLobby_EnumAddress(p,a,b,c,d)             (p)->lpVtbl->EnumAddress(p,a,b,c,d)
#define IDirectPlayLobby_EnumAddressTypes(p,a,b,c,d)        (p)->lpVtbl->EnumAddressTypes(p,a,b,c,d)
#define IDirectPlayLobby_EnumLocalApplications(p,a,b,c)     (p)->lpVtbl->EnumLocalApplications(p,a,b,c)
#define IDirectPlayLobby_GetConnectionSettings(p,a,b,c)     (p)->lpVtbl->GetConnectionSettings(p,a,b,c)
#define IDirectPlayLobby_ReceiveLobbyMessage(p,a,b,c,d,e)   (p)->lpVtbl->ReceiveLobbyMessage(p,a,b,c,d,e)
#define IDirectPlayLobby_RegisterApplication(p,a,b)         (p)->lpVtbl->RegisterApplication(p,a,b)
#define IDirectPlayLobby_RunApplication(p,a,b,c,d)          (p)->lpVtbl->RunApplication(p,a,b,c,d)
#define IDirectPlayLobby_SendLobbyMessage(p,a,b,c,d)        (p)->lpVtbl->SendLobbyMessage(p,a,b,c,d)
#define IDirectPlayLobby_SetConnectionSettings(p,a,b,c)		(p)->lpVtbl->SetConnectionSettings(p,a,b,c)
#define IDirectPlayLobby_SetLobbyMessageEvent(p,a,b,c)	    (p)->lpVtbl->SetLobbyMessageEvent(p,a,b,c)
#define IDirectPlayLobby_UnregisterApplication(p,a,b)       (p)->lpVtbl->UnregisterApplication(p,a,b)
#define IDirectPlayLobby_WaitForConnectionSettings(p,a)     (p)->lpVtbl->WaitForConnectionSettings(p,a)

#else /* C++ */

#define IDirectPlayLobby_QueryInterface(p,a,b)              (p)->QueryInterface(a,b)
#define IDirectPlayLobby_AddRef(p)                          (p)->AddRef()
#define IDirectPlayLobby_Release(p)                         (p)->Release()
#define IDirectPlayLobby_Connect(p,a,b,c)                   (p)->Connect(a,b,c)
#define IDirectPlayLobby_ConnectEx(p,a,b,c,d)               (p)->ConnectEx(a,b,c,d)
#define IDirectPlayLobby_CreateAddress(p,a,b,c,d,e,f)       (p)->CreateAddress(a,b,c,d,e,f)
#define IDirectPlayLobby_CreateCompoundAddress(p,a,b,c,d)   (p)->CreateCompoundAddress(a,b,c,d)
#define IDirectPlayLobby_EnumAddress(p,a,b,c,d)             (p)->EnumAddress(a,b,c,d)
#define IDirectPlayLobby_EnumAddressTypes(p,a,b,c,d)        (p)->EnumAddressTypes(a,b,c,d)
#define IDirectPlayLobby_EnumLocalApplications(p,a,b,c)     (p)->EnumLocalApplications(a,b,c)
#define IDirectPlayLobby_GetConnectionSettings(p,a,b,c)     (p)->GetConnectionSettings(a,b,c)
#define IDirectPlayLobby_ReceiveLobbyMessage(p,a,b,c,d,e)   (p)->ReceiveLobbyMessage(a,b,c,d,e)
#define IDirectPlayLobby_RegisterApplication(p,a,b)         (p)->RegisterApplication(a,b)
#define IDirectPlayLobby_RunApplication(p,a,b,c,d)          (p)->RunApplication(a,b,c,d)
#define IDirectPlayLobby_SendLobbyMessage(p,a,b,c,d)        (p)->SendLobbyMessage(a,b,c,d)
#define IDirectPlayLobby_SetConnectionSettings(p,a,b,c)		(p)->SetConnectionSettings(a,b,c)
#define IDirectPlayLobby_SetLobbyMessageEvent(p,a,b,c)	    (p)->SetLobbyMessageEvent(a,b,c)
#define IDirectPlayLobby_UnregisterApplication(p,a,b)       (p)->UnregisterApplication(a,b)
#define IDirectPlayLobby_WaitForConnectionSettings(p,a)     (p)->WaitForConnectionSettings(a)

#endif

/****************************************************************************
 *
 * DirectPlayLobby Flags
 *
 ****************************************************************************/

/*
 *	This flag is used by IDirectPlayLobby->WaitForConnectionSettings to
 *	cancel a current wait that is in progress.
 */
#define DPLWAIT_CANCEL                  0x00000001


/*
 *	This is a message flag used by ReceiveLobbyMessage.  It can be
 *	returned in the dwMessageFlags parameter to indicate a message from
 *	the system.
 */
#define DPLMSG_SYSTEM					0x00000001

/*
 *	This is a message flag used by ReceiveLobbyMessage and SendLobbyMessage.
 *  It is used to indicate that the message is a standard lobby message.
 *  DPLMSG_SETPROPERTY, DPLMSG_SETPROPERTYRESPONSE, DPLMSG_GETPROPERTY,
 *	DPLMSG_GETPROPERTYRESPONSE
 */
#define DPLMSG_STANDARD					0x00000002


/****************************************************************************
 *
 * DirectPlayLobby messages and message data structures
 *
 * All system messages have a dwMessageFlags value of DPLMSG_SYSTEM returned
 * from a call to ReceiveLobbyMessage.
 *
 * All standard messages have a dwMessageFlags value of DPLMSG_STANDARD returned
 * from a call to ReceiveLobbyMessage.
 *
 ****************************************************************************/

/*
 * DPLMSG_GENERIC
 * Generic message structure used to identify the message type.
 */
typedef struct _DPLMSG_GENERIC
{
    DWORD       dwType;         // Message type
} DPLMSG_GENERIC, FAR *LPDPLMSG_GENERIC;

/*
 * DPLMSG_SYSTEMMESSAGE
 * Generic message format for all system messages --
 * DPLSYS_CONNECTIONSETTINGSREAD, DPLSYS_DPLYCONNECTSUCCEEDED,
 * DPLSYS_DPLAYCONNECTFAILED, DPLSYS_APPTERMINATED, DPLSYS_NEWCONNECTIONSETTINGS
 */
typedef struct _DPLMSG_SYSTEMMESSAGE
{
    DWORD       dwType;         // Message type
    GUID        guidInstance;   // Instance GUID of the dplay session the message corresponds to
} DPLMSG_SYSTEMMESSAGE, FAR *LPDPLMSG_SYSTEMMESSAGE;

/*
 *  DPLMSG_SETPROPERTY
 *  Standard message sent by an application to a lobby to set a
 *  property
 */
typedef struct _DPLMSG_SETPROPERTY
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID (DPL_NOCONFIRMATION if no confirmation desired)
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	DWORD	dwDataSize;			// Size of data
	DWORD	dwPropertyData[1];	// Buffer containing data
} DPLMSG_SETPROPERTY, FAR *LPDPLMSG_SETPROPERTY;

#define	DPL_NOCONFIRMATION			0

/*
 *  DPLMSG_SETPROPERTYRESPONSE
 *  Standard message returned by a lobby to confirm a 
 *  DPLMSG_SETPROPERTY message.
 */
typedef struct _DPLMSG_SETPROPERTYRESPONSE
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	HRESULT	hr;					// Return Code
} DPLMSG_SETPROPERTYRESPONSE, FAR *LPDPLMSG_SETPROPERTYRESPONSE;

/*
 *  DPLMSG_GETPROPERTY
 *  Standard message sent by an application to a lobby to request
 *	the current value of a property
 */
typedef struct _DPLMSG_GETPROPERTY
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
} DPLMSG_GETPROPERTY, FAR *LPDPLMSG_GETPROPERTY;

/*
 *  DPLMSG_GETPROPERTYRESPONSE
 *  Standard message returned by a lobby in response to a
 *	DPLMSG_GETPROPERTY message.
 */
typedef struct _DPLMSG_GETPROPERTYRESPONSE
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	HRESULT	hr;					// Return Code
	DWORD	dwDataSize;			// Size of data
	DWORD	dwPropertyData[1];	// Buffer containing data
} DPLMSG_GETPROPERTYRESPONSE, FAR *LPDPLMSG_GETPROPERTYRESPONSE;

/*
 *  DPLMSG_NEWSESSIONHOST
 *  Standard message returned by a lobby in response to a
 *	the session host migrating to a new client
 */
typedef struct _DPLMSG_NEWSESSIONHOST
{
    DWORD   dwType;             // Message type
    GUID    guidInstance;       // GUID Instance of the session
} DPLMSG_NEWSESSIONHOST, FAR *LPDPLMSG_NEWSESSIONHOST;


/******************************************
 *
 *	DirectPlay Lobby message dwType values
 *
 *****************************************/

/*
 *  The application has read the connection settings.
 *  It is now O.K. for the lobby client to release
 *  its IDirectPlayLobby interface.
 */
#define DPLSYS_CONNECTIONSETTINGSREAD   0x00000001

/*
 *  The application's call to DirectPlayConnect failed
 */
#define DPLSYS_DPLAYCONNECTFAILED       0x00000002

/*
 *  The application has created a DirectPlay session.
 */
#define DPLSYS_DPLAYCONNECTSUCCEEDED    0x00000003

/*
 *  The application has terminated.
 */
#define DPLSYS_APPTERMINATED            0x00000004

/*
 *  The message is a DPLMSG_SETPROPERTY message.
 */
#define DPLSYS_SETPROPERTY				0x00000005

/*
 *  The message is a DPLMSG_SETPROPERTYRESPONSE message.
 */
#define DPLSYS_SETPROPERTYRESPONSE		0x00000006

/*
 *  The message is a DPLMSG_GETPROPERTY message.
 */
#define DPLSYS_GETPROPERTY				0x00000007

/*
 *  The message is a DPLMSG_GETPROPERTYRESPONSE message.
 */
#define DPLSYS_GETPROPERTYRESPONSE		0x00000008

/*
 *  The message is a DPLMSG_NEWSESSIONHOST message.
 */
#define DPLSYS_NEWSESSIONHOST           0x00000009

/*
 *  New connection settings are available.
 */
#define DPLSYS_NEWCONNECTIONSETTINGS    0x0000000A


/****************************************************************************
 *
 * DirectPlay defined property GUIDs and associated data structures
 *
 ****************************************************************************/

/*
 * DPLPROPERTY_MessagesSupported
 *
 * Request whether the lobby supports standard.  Lobby with respond with either
 * TRUE or FALSE or may not respond at all.
 * 
 * Property data is a single BOOL with TRUE or FALSE
 */
// {762CCDA1-D916-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_MessagesSupported, 
0x762ccda1, 0xd916, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLPROPERTY_LobbyGuid
 *
 * Request the GUID that identifies the lobby software that the application
 * is communicating with.
 *
 * Property data is a single GUID.
 */
// {F56920A0-D218-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_LobbyGuid, 
0xf56920a0, 0xd218, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLPROPERTY_PlayerGuid
 *
 * Request the GUID that identifies the player on this machine for sending
 * property data back to the lobby.
 *
 * Property data is the DPLDATA_PLAYERDATA structure
 */
// {B4319322-D20D-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerGuid, 
0xb4319322, 0xd20d, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLDATA_PLAYERGUID
 *
 * Data structure to hold the GUID of the player and player creation flags
 * from the lobby.
 */
typedef struct _DPLDATA_PLAYERGUID
{
	GUID	guidPlayer;
	DWORD	dwPlayerFlags;
} DPLDATA_PLAYERGUID, FAR *LPDPLDATA_PLAYERGUID;

/*
 * DPLPROPERTY_PlayerScore
 *
 * Used to send an array of long integers to the lobby indicating the 
 * score of a player.
 *
 * Property data is the DPLDATA_PLAYERSCORE structure.
 */
// {48784000-D219-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerScore, 
0x48784000, 0xd219, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLDATA_PLAYERSCORE
 *
 * Data structure to hold an array of long integers representing a player score.
 * Application must allocate enough memory to hold all the scores.
 */
typedef struct _DPLDATA_PLAYERSCORE
{
	DWORD	dwScoreCount;
	LONG	Score[1];
} DPLDATA_PLAYERSCORE, FAR *LPDPLDATA_PLAYERSCORE;

/****************************************************************************
 *
 * DirectPlay Address ID's
 *
 ****************************************************************************/

/* DirectPlay Address
 *
 * A DirectPlay address consists of multiple chunks of data, each tagged
 * with a GUID signifying the type of data in the chunk. The chunk also
 * has a length so that unknown chunk types can be skipped.
 *
 * The EnumAddress() function is used to parse these address data chunks.
 */

/*
 * DPADDRESS
 *
 * Header for block of address data elements
 */
typedef struct _DPADDRESS
{
    GUID                guidDataType;
    DWORD               dwDataSize;
} DPADDRESS;

typedef DPADDRESS FAR *LPDPADDRESS;

/*
 * DPAID_TotalSize
 *
 * Chunk is a DWORD containing size of entire DPADDRESS structure
 */

// {1318F560-912C-11d0-9DAA-00A0C90A43CB}
DEFINE_GUID(DPAID_TotalSize, 
0x1318f560, 0x912c, 0x11d0, 0x9d, 0xaa, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

/*
 * DPAID_ServiceProvider
 *
 * Chunk is a GUID describing the service provider that created the chunk.
 * All addresses must contain this chunk.
 */

// {07D916C0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ServiceProvider, 
0x7d916c0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_LobbyProvider
 *
 * Chunk is a GUID describing the lobby provider that created the chunk.
 * All addresses must contain this chunk.
 */

// {59B95640-9667-11d0-A77D-0000F803ABFC}
DEFINE_GUID(DPAID_LobbyProvider, 
0x59b95640, 0x9667, 0x11d0, 0xa7, 0x7d, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

/*
 * DPAID_Phone and DPAID_PhoneW
 *
 * Chunk is a string containing a phone number (i.e. "1-800-555-1212")
 * in ANSI or UNICODE format
 */

// {78EC89A0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_Phone, 
0x78ec89a0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {BA5A7A70-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_PhoneW, 
0xba5a7a70, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_Modem and DPAID_ModemW
 *
 * Chunk is a string containing a modem name registered with TAPI
 * in ANSI or UNICODE format
 */

// {F6DCC200-A2FE-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_Modem, 
0xf6dcc200, 0xa2fe, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {01FD92E0-A2FF-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_ModemW, 
0x1fd92e0, 0xa2ff, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_Inet and DPAID_InetW
 *
 * Chunk is a string containing a TCP/IP host name or an IP address
 * (i.e. "dplay.microsoft.com" or "137.55.100.173") in ANSI or UNICODE format
 */

// {C4A54DA0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_INet, 
0xc4a54da0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {E63232A0-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_INetW, 
0xe63232a0, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_InetPort
 *
 * Chunk is the port number used for creating the apps TCP and UDP sockets.
 * WORD value (i.e. 47624)
 */
 
// {E4524541-8EA5-11d1-8A96-006097B01411}
DEFINE_GUID(DPAID_INetPort, 
0xe4524541, 0x8ea5, 0x11d1, 0x8a, 0x96, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

/*
 * DPCOMPORTADDRESS
 *
 * Used to specify com port settings. The constants that define baud rate,
 * stop bits and parity are defined in WINBASE.H. The constants for flow
 * control are given below.
 */

#define DPCPA_NOFLOW        0           // no flow control
#define DPCPA_XONXOFFFLOW   1           // software flow control
#define DPCPA_RTSFLOW       2           // hardware flow control with RTS
#define DPCPA_DTRFLOW       3           // hardware flow control with DTR
#define DPCPA_RTSDTRFLOW    4           // hardware flow control with RTS and DTR

typedef struct _DPCOMPORTADDRESS
{
    DWORD   dwComPort;                  // COM port to use (1-4)
    DWORD   dwBaudRate;                 // baud rate (100-256k)
    DWORD   dwStopBits;                 // no. stop bits (1-2)
    DWORD   dwParity;                   // parity (none, odd, even, mark)
    DWORD   dwFlowControl;              // flow control (none, xon/xoff, rts, dtr)
} DPCOMPORTADDRESS;

typedef DPCOMPORTADDRESS FAR *LPDPCOMPORTADDRESS;

/*
 * DPAID_ComPort
 *
 * Chunk contains a DPCOMPORTADDRESS structure defining the serial port.
 */

// {F2F0CE00-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ComPort, 
0xf2f0ce00, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/****************************************************************************
 *
 * 	dplobby 1.0 obsolete definitions
 *	Included for compatibility only.
 *
 ****************************************************************************/
#define DPLAD_SYSTEM          DPLMSG_SYSTEM


#ifdef __cplusplus
};
#endif /* __cplusplus */

#endif /* __DPLOBBY_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\rmxfguid.h ===
/***************************************************************************
 *
 *  Copyright (C) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rmxfguid.h
 *
 *  Content:    Defines GUIDs of D3DRM's templates.
 *
 ***************************************************************************/

#ifndef __RMXFGUID_H_
#define __RMXFGUID_H_

/* {2B957100-9E9A-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMInfo,
0x2b957100, 0x9e9a, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB44-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMesh,
0x3d82ab44, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB5E-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMVector,
0x3d82ab5e, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB5F-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMeshFace,
0x3d82ab5f, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB4D-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMaterial,
0x3d82ab4d, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {35FF44E1-6C7C-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialArray,
0x35ff44e1, 0x6c7c, 0x11cf, 0x8F, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB46-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMFrame,
0x3d82ab46, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {F6F23F41-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameTransformMatrix,
0xf6f23f41, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F42-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshMaterialList,
0xf6f23f42, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F40-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshTextureCoords,
0xf6f23f40, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F43-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshNormals,
0xf6f23f43, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F44-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMCoords2d,
0xf6f23f44, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F45-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMatrix4x4,
0xf6f23f45, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB4F-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMAnimation,
0x3d82ab4f, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB50-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMAnimationSet,
0x3d82ab50, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {10DD46A8-775B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMAnimationKey,
0x10dd46a8, 0x775b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {10DD46A9-775B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFloatKeys,
0x10dd46a9, 0x775b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411840-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialAmbientColor,
0x01411840, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411841-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialDiffuseColor,
0x01411841, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411842-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialSpecularColor,
0x01411842, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {D3E16E80-7835-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialEmissiveColor,
0xd3e16e80, 0x7835, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {01411843-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialPower,
0x01411843, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {35FF44E0-6C7C-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMColorRGBA,
0x35ff44e0, 0x6c7c, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {D3E16E81-7835-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMColorRGB,
0xd3e16e81, 0x7835, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E0-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMGuid,
0xa42790e0, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E1-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTextureFilename,
0xa42790e1, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E2-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTextureReference,
0xa42790e2, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {1630B820-7842-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMIndexedColor,
0x1630b820, 0x7842, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {1630B821-7842-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshVertexColors,
0x1630b821, 0x7842, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {4885AE60-78E8-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialWrap,
0x4885ae60, 0x78e8, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {537DA6A0-CA37-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMBoolean,
0x537da6a0, 0xca37, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {ED1EC5C0-C0A8-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMMeshFaceWraps,
0xed1ec5c0, 0xc0a8, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {4885AE63-78E8-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMBoolean2d,
0x4885ae63, 0x78e8, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F406B180-7B3B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTimedFloatKeys,
0xf406b180, 0x7b3b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C0-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMAnimationOptions,
0xe2bf56c0, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C1-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFramePosition,
0xe2bf56c1, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C2-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameVelocity,
0xe2bf56c2, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C3-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameRotation,
0xe2bf56c3, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB4A-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMLight,
0x3d82ab4a, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB51-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMCamera,
0x3d82ab51, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {E5745280-B24F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMAppData,
0xe5745280, 0xb24f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22740-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightUmbra,
0xaed22740, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22742-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightRange,
0xaed22742, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22741-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightPenumbra,
0xaed22741, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {A8A98BA0-C5E5-11cf-B941-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMLightAttenuation,
0xa8a98ba0, 0xc5e5, 0x11cf, 0xb9, 0x41, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {3A23EEA0-94B1-11d0-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMInlineData,
0x3a23eea0, 0x94b1, 0x11d0, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3A23EEA1-94B1-11d0-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMUrl,
0x3a23eea1, 0x94b1, 0x11d0, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {8A63C360-997D-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMProgressiveMesh,
0x8A63C360, 0x997D, 0x11d0, 0x94, 0x1C, 0x0, 0x80, 0xC8, 0x0C, 0xFA, 0x7B);

/* {98116AA0-BDBA-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMExternalVisual,
0x98116AA0, 0xBDBA, 0x11d1, 0x82, 0xC0, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x71);

/* {7F0F21E0-BFE1-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMStringProperty, 
0x7f0f21e0, 0xbfe1, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

/* {7F0F21E1-BFE1-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMPropertyBag, 
0x7f0f21e1, 0xbfe1, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

#endif /* __RMXFGUID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\dsound.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsound.h
 *  Content:    DirectSound include file
 *
 **************************************************************************/

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

#include <d3dtypes.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#define _FACDS  0x878
#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Direct Sound Component GUID {47D4D946-62E8-11cf-93BC-444553540000}
DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

// DirectSound Capture Component GUID {B0210780-89CD-11d0-AF08-00A0C925CD16}
DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

//
// Structures
// 

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IDirectSound;
struct IDirectSoundBuffer;
struct IDirectSound3DListener;
struct IDirectSound3DBuffer;
struct IDirectSoundCapture;
struct IDirectSoundCaptureBuffer;
struct IDirectSoundNotify;
#endif // __cplusplus

typedef struct IDirectSound *LPDIRECTSOUND;
typedef struct IDirectSoundBuffer *LPDIRECTSOUNDBUFFER;
typedef struct IDirectSound3DListener *LPDIRECTSOUND3DLISTENER;
typedef struct IDirectSound3DBuffer *LPDIRECTSOUND3DBUFFER;
typedef struct IDirectSoundCapture *LPDIRECTSOUNDCAPTURE;
typedef struct IDirectSoundCaptureBuffer *LPDIRECTSOUNDCAPTUREBUFFER;
typedef struct IDirectSoundNotify *LPDIRECTSOUNDNOTIFY;

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef const DSBCAPS *LPCDSBCAPS;

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef const DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS 
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef const DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// Compatibility typedefs
//

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;
typedef LPVOID *LPLPVOID;
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;

//
// DirectSound API
//

typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);
typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);

extern HRESULT WINAPI DirectSoundCreate(LPGUID, LPDIRECTSOUND *, LPUNKNOWN);
extern HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW, LPVOID);
extern HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA, LPVOID);

extern HRESULT WINAPI DirectSoundCaptureCreate(LPGUID, LPDIRECTSOUNDCAPTURE *, LPUNKNOWN);
extern HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW, LPVOID);
extern HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA, LPVOID);

#ifdef UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
#define DirectSoundEnumerate        DirectSoundEnumerateW
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
#else // UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
#define DirectSoundEnumerate        DirectSoundEnumerateA
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
#endif // UNICODE

//
// IDirectSound
//

DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound

DECLARE_INTERFACE_(IDirectSound, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    
    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC, LPDIRECTSOUNDBUFFER *, LPUNKNOWN) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER, LPDIRECTSOUNDBUFFER *) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND, DWORD) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_QueryInterface(p,a,b)       (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSound_AddRef(p)                   (p)->lpVtbl->AddRef(p)
#define IDirectSound_Release(p)                  (p)->lpVtbl->Release(p)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_QueryInterface(p,a,b)       (p)->QueryInterface(a,b)
#define IDirectSound_AddRef(p)                   (p)->AddRef()
#define IDirectSound_Release(p)                  (p)->Release()
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
#define IDirectSound_Compact(p)                  (p)->Compact()
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundBuffer
//

DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer

DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    
    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD, LPDWORD) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX, DWORD, LPDWORD) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND, LPCDSBUFFERDESC) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD, DWORD, DWORD) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSoundBuffer_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectSoundBuffer_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectSoundBuffer_AddRef(p)                    (p)->AddRef()
#define IDirectSoundBuffer_Release(p)                   (p)->Release()
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DListener
//

DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DListener

DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSound3D methods
    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetOrientation)           (THIS_ LPD3DVECTOR, LPD3DVECTOR) PURE;
    STDMETHOD(GetPosition)              (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetVelocity)              (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER, DWORD) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_QueryInterface(p,a,b)            (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSound3DListener_AddRef(p)                        (p)->lpVtbl->AddRef(p)
#define IDirectSound3DListener_Release(p)                       (p)->lpVtbl->Release(p)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_QueryInterface(p,a,b)            (p)->QueryInterface(a,b)
#define IDirectSound3DListener_AddRef(p)                        (p)->AddRef()
#define IDirectSound3DListener_Release(p)                       (p)->Release()
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBuffer
//

DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DBuffer

DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer3D methods
    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD, LPDWORD) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetMode)              (THIS_ LPDWORD) PURE;
    STDMETHOD(GetPosition)          (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(GetVelocity)          (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER, DWORD) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD, DWORD, DWORD) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG, DWORD) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD, DWORD) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSound3DBuffer_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IDirectSound3DBuffer_Release(p)                 (p)->lpVtbl->Release(p)
#define IDirectSound3DBuffer_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)       (p)->lpVtbl->GetConeAngles(p,a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)    (p)->lpVtbl->GetConeOrientation(p,a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)  (p)->lpVtbl->GetConeOutsideVolume(p,a)
#define IDirectSound3DBuffer_GetPosition(p,a)           (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)        (p)->lpVtbl->GetMinDistance(p,a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)        (p)->lpVtbl->GetMaxDistance(p,a)
#define IDirectSound3DBuffer_GetMode(p,a)               (p)->lpVtbl->GetMode(p,a)
#define IDirectSound3DBuffer_GetVelocity(p,a)           (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)    (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)     (p)->lpVtbl->SetConeAngles(p,a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d) (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)(p)->lpVtbl->SetConeOutsideVolume(p,a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)     (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)      (p)->lpVtbl->SetMinDistance(p,a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)      (p)->lpVtbl->SetMaxDistance(p,a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)             (p)->lpVtbl->SetMode(p,a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)     (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IDirectSound3DBuffer_AddRef(p)                  (p)->AddRef()
#define IDirectSound3DBuffer_Release(p)                 (p)->Release()
#define IDirectSound3DBuffer_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)       (p)->GetConeAngles(a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)    (p)->GetConeOrientation(a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)  (p)->GetConeOutsideVolume(a)
#define IDirectSound3DBuffer_GetPosition(p,a)           (p)->GetPosition(a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)        (p)->GetMinDistance(a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)        (p)->GetMaxDistance(a)
#define IDirectSound3DBuffer_GetMode(p,a)               (p)->GetMode(a)
#define IDirectSound3DBuffer_GetVelocity(p,a)           (p)->GetVelocity(a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)    (p)->SetAllParameters(a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)     (p)->SetConeAngles(a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d) (p)->SetConeOrientation(a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)(p)->SetConeOutsideVolume(a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)     (p)->SetPosition(a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)      (p)->SetMinDistance(a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)      (p)->SetMaxDistance(a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)             (p)->SetMode(a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)     (p)->SetVelocity(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCapture
//

DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCapture

DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCapture methods
    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC, LPDIRECTSOUNDCAPTUREBUFFER *, LPUNKNOWN) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS ) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_QueryInterface(p,a,b)           (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSoundCapture_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectSoundCapture_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_QueryInterface(p,a,b)           (p)->QueryInterface(a,b)
#define IDirectSoundCapture_AddRef(p)                       (p)->AddRef()
#define IDirectSoundCapture_Release(p)                      (p)->Release()
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureBuffer
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS ) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX, DWORD, LPDWORD ) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD ) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE, LPCDSCBUFFERDESC) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD) PURE;
    STDMETHOD(Start)                (THIS_ DWORD) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID, DWORD, LPVOID, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectSoundCaptureBuffer_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                   (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                    (p)->AddRef()
#define IDirectSoundCaptureBuffer_Release(p)                   (p)->Release()
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                   (p)->Start(a)
#define IDirectSoundCaptureBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundNotify
//

DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundNotify

DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD, LPCDSBPOSITIONNOTIFY) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_QueryInterface(p,a,b)            (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSoundNotify_AddRef(p)                        (p)->lpVtbl->AddRef(p)
#define IDirectSoundNotify_Release(p)                       (p)->lpVtbl->Release(p)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_QueryInterface(p,a,b)            (p)->QueryInterface(a,b)
#define IDirectSoundNotify_AddRef(p)                        (p)->AddRef()
#define IDirectSoundNotify_Release(p)                       (p)->Release()
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IKsPropertySet
//

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IKsPropertySet;
#endif // __cplusplus

typedef struct IKsPropertySet *LPKSPROPERTYSET;

#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002

DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);

#undef INTERFACE
#define INTERFACE IKsPropertySet

DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG, PULONG) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID, ULONG, PULONG) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_QueryInterface(p,a,b)       (p)->lpVtbl->QueryInterface(p,a,b)
#define IKsPropertySet_AddRef(p)                   (p)->lpVtbl->AddRef(p)
#define IKsPropertySet_Release(p)                  (p)->lpVtbl->Release(p)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_QueryInterface(p,a,b)       (p)->QueryInterface(a,b)
#define IKsPropertySet_AddRef(p)                   (p)->AddRef()
#define IKsPropertySet_Release(p)                  (p)->Release()
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IKsPropertySet_

//
// Return Codes
//

#define DS_OK                           0

// The call failed because resources (such as a priority level)
// were already being used by another caller.
#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)

// The control (vol,pan,etc.) requested by the caller is not available.
#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              E_INVALIDARG

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)

// An undetermined error occured inside the DirectSound subsystem
#define DSERR_GENERIC                   E_FAIL

// The caller does not have the priority level required for the function to
// succeed.
#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               E_NOTIMPL

// No sound driver is available for use
#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)

// This object does not support aggregation
#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION

// The buffer memory has been lost, and must be restored.
#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)

// Another app has a higher priority level, preventing this call from
// succeeding.
#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)

// This object has not been initialized
#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)

// The requested COM interface is not available
#define DSERR_NOINTERFACE               E_NOINTERFACE

//
// Flags
//

#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800

#define DSBPLAY_LOOPING             0x00000001
      
#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004

#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004

#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002

#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001

#define DS3D_MINDISTANCEFACTOR      0.0f
#define DS3D_MAXDISTANCEFACTOR      10.0f
#define DS3D_DEFAULTDISTANCEFACTOR  1.0f

#define DS3D_MINROLLOFFFACTOR       0.0f
#define DS3D_MAXROLLOFFFACTOR       10.0f
#define DS3D_DEFAULTROLLOFFFACTOR   1.0f

#define DS3D_MINDOPPLERFACTOR       0.0f
#define DS3D_MAXDOPPLERFACTOR       10.0f
#define DS3D_DEFAULTDOPPLERFACTOR   1.0f

#define DS3D_DEFAULTMINDISTANCE     1.0f
#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f

#define DS3D_MINCONEANGLE           0
#define DS3D_MAXCONEANGLE           360
#define DS3D_DEFAULTCONEANGLE       360

#define DS3D_DEFAULTCONEOUTSIDEVOLUME   0

#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSBCAPS_CTRLDEFAULT         0x000000E0
#define DSBCAPS_CTRLALL             0x000001F0
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000 
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000

#define DSCBCAPS_WAVEMAPPED         0x80000000

#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))

#define DSCCAPS_EMULDRIVER          0x00000020

#define DSCBLOCK_ENTIREBUFFER       0x00000001

#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002

#define DSCBSTART_LOOPING           0x00000001

#define DSBFREQUENCY_MIN            100
#define DSBFREQUENCY_MAX            100000
#define DSBFREQUENCY_ORIGINAL       0

#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000

#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0

#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF

#define DSBPN_OFFSETSTOP            0xFFFFFFFF

#ifdef __cplusplus
};
#endif // __cplusplus

#endif  // __DSOUND_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\dvp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dvp.h
 *  Content:	DirectDrawVideoPort include file
 *
 ***************************************************************************/

#ifndef __DVP_INCLUDED__
#define __DVP_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#endif

/*
 * These definitions are required to allow polymorphic structure members (i.e. those
 * that are referred to both as DWORDs and as pointers) to resolve into a type
 * of correct size to hold the largest of those two types (i.e. pointer) on 64 bit
 * systems. For 32 bit environments, UINT_PTR resolves to a DWORD.
 */
#ifndef MAXUINT_PTR
#define UINT_PTR    DWORD
#endif //MAXUINT_PTR

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoPort objects
 */
#if defined( _WIN32 ) && (!defined( _NO_COM ) || defined( DEFINE_GUID ))
DEFINE_GUID( IID_IDDVideoPortContainer,		0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawVideoPort,		0xB36D93E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );

DEFINE_GUID( DDVPTYPE_E_HREFH_VREFH, 0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFH_VREFL, 0x92783220L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFH, 0xA07A02E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFL, 0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_CCIR656,	     0xFCA326A0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_BROOKTREE,     0x1352A560L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_PHILIPS,	     0x332CF160L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);

/*
 * GUIDS used to describe connections
 */

#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoPortContainer		FAR *LPDDVIDEOPORTCONTAINER;
typedef struct IDirectDrawVideoPort		FAR *LPDIRECTDRAWVIDEOPORT;

typedef struct _DDVIDEOPORTCONNECT	FAR *LPDDVIDEOPORTCONNECT;
typedef struct _DDVIDEOPORTCAPS		FAR *LPDDVIDEOPORTCAPS;
typedef struct _DDVIDEOPORTDESC		FAR *LPDDVIDEOPORTDESC;
typedef struct _DDVIDEOPORTINFO		FAR *LPDDVIDEOPORTINFO;
typedef struct _DDVIDEOPORTBANDWIDTH	FAR *LPDDVIDEOPORTBANDWIDTH;
typedef struct _DDVIDEOPORTSTATUS	FAR *LPDDVIDEOPORTSTATUS;

typedef struct IDDVideoPortContainerVtbl DDVIDEOPORTCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoPortVtbl  DIRECTDRAWVIDEOPORTCALLBACKS;


/*
 * API's
 */
typedef HRESULT (FAR PASCAL * LPDDENUMVIDEOCALLBACK)(LPDDVIDEOPORTCAPS, LPVOID);


/*
 * INTERACES FOLLOW:
 *	IDirectDrawVideoPort
 *	IVideoPort
 */

/*
 * IDirectDrawVideoPortContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoPortContainer
DECLARE_INTERFACE_( IDDVideoPortContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawVideoPort methods ***/
    STDMETHOD(CreateVideoPort)(THIS_ DWORD, LPDDVIDEOPORTDESC, LPDIRECTDRAWVIDEOPORT FAR *, IUnknown FAR *) PURE;
    STDMETHOD(EnumVideoPorts)(THIS_ DWORD, LPDDVIDEOPORTCAPS, LPVOID,LPDDENUMVIDEOCALLBACK ) PURE;
    STDMETHOD(GetVideoPortConnectInfo)(THIS_ DWORD, LPDWORD, LPDDVIDEOPORTCONNECT ) PURE;
    STDMETHOD(QueryVideoPortStatus)(THIS_ DWORD, LPDDVIDEOPORTSTATUS ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IVideoPortContainer_Release(p)                      (p)->lpVtbl->Release(p)
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->lpVtbl->CreateVideoPort(p, a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->lpVtbl->EnumVideoPorts(p, a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->lpVtbl->GetVideoPortConnectInfo(p, a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->lpVtbl->QueryVideoPortStatus(p, a, b)
#else
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->AddRef()
#define IVideoPortContainer_Release(p)                      (p)->Release()
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->CreateVideoPort(a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->EnumVideoPorts(a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->GetVideoPortConnectInfo(a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->QueryVideoPortStatus(a, b)
#endif

#endif


/*
 * IDirectDrawVideoPort
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoPort
DECLARE_INTERFACE_( IDirectDrawVideoPort, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IVideoPort methods ***/
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetBandwidthInfo)(THIS_ LPDDPIXELFORMAT, DWORD, DWORD, DWORD, LPDDVIDEOPORTBANDWIDTH) PURE;
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(GetInputFormats)(THIS_ LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetOutputFormats)(THIS_ LPDDPIXELFORMAT, LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetFieldPolarity)(THIS_ LPBOOL) PURE;
    STDMETHOD(GetVideoLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVideoSignalStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetTargetSurface)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(StartVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(StopVideo)(THIS) PURE;
    STDMETHOD(UpdateVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(WaitForSync)(THIS_ DWORD, DWORD, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPort_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoPort_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IVideoPort_Release(p)                   (p)->lpVtbl->Release(p)
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->lpVtbl->SetTargetSurface(p,a,b)
#define IVideoPort_Flip(p,a,b)			(p)->lpVtbl->Flip(p,a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->lpVtbl->GetBandwidthInfo(p,a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->lpVtbl->GetColorControls(p,a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->lpVtbl->GetInputFormats(p,a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->lpVtbl->GetOutputFormats(p,a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->lpVtbl->GetFieldPolarity(p,a)
#define IVideoPort_GetVideoLine(p,a)		(p)->lpVtbl->GetVideoLine(p,a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->lpVtbl->GetVideoSignalStatus(p,a)
#define IVideoPort_SetColorControls(p,a)	(p)->lpVtbl->SetColorControls(p,a)
#define IVideoPort_StartVideo(p,a)		(p)->lpVtbl->StartVideo(p,a)
#define IVideoPort_StopVideo(p)			(p)->lpVtbl->StopVideo(p)
#define IVideoPort_UpdateVideo(p,a)		(p)->lpVtbl->UpdateVideo(p,a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->lpVtbl->WaitForSync(p,a,b,c)
#else
#define IVideoPort_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IVideoPort_AddRef(p)                    (p)->AddRef()
#define IVideoPort_Release(p)                   (p)->Release()
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->SetTargetSurface(a,b)
#define IVideoPort_Flip(p,a,b)			(p)->Flip(a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->GetBandwidthInfo(a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->GetColorControls(a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->GetInputFormats(a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->GetOutputFormats(a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->GetFieldPolarity(a)
#define IVideoPort_GetVideoLine(p,a)		(p)->GetVideoLine(a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->GetVideoSignalStatus(a)
#define IVideoPort_SetColorControls(p,a)	(p)->SetColorControls(a)
#define IVideoPort_StartVideo(p,a)		(p)->StartVideo(a)
#define IVideoPort_StopVideo(p)			(p)->StopVideo()
#define IVideoPort_UpdateVideo(p,a)		(p)->UpdateVideo(a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->WaitForSync(a,b,c)
#endif

#endif


/*
 * DDVIDEOPORTCONNECT
 */
typedef struct _DDVIDEOPORTCONNECT
{
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    UINT_PTR dwReserved1;      // Reserved, set to zero.
} DDVIDEOPORTCONNECT;


/*
 * DDVIDEOPORTCAPS
 */
typedef struct _DDVIDEOPORTCAPS
{
    DWORD dwSize;			// size of the DDVIDEOPORTCAPS structure
    DWORD dwFlags;			// indicates which fields contain data
    DWORD dwMaxWidth;			// max width of the video port field
    DWORD dwMaxVBIWidth;		// max width of the VBI data
    DWORD dwMaxHeight; 			// max height of the video port field
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwCaps;			// Video port capabilities
    DWORD dwFX;				// More video port capabilities
    DWORD dwNumAutoFlipSurfaces;	// Max number of autoflippable surfaces allowed
    DWORD dwAlignVideoPortBoundary;	// Byte restriction of placement within the surface
    DWORD dwAlignVideoPortPrescaleWidth;// Byte restriction of width after prescaling
    DWORD dwAlignVideoPortCropBoundary;	// Byte restriction of left cropping
    DWORD dwAlignVideoPortCropWidth;	// Byte restriction of cropping width
    DWORD dwPreshrinkXStep;		// Width can be shrunk in steps of 1/x
    DWORD dwPreshrinkYStep;		// Height can be shrunk in steps of 1/x
    DWORD dwNumVBIAutoFlipSurfaces;	// Max number of VBI autoflippable surfaces allowed
    DWORD dwNumPreferredAutoflip;	// Optimal number of autoflippable surfaces for hardware
    WORD  wNumFilterTapsX;              // Number of taps the prescaler uses in the X direction (0 - no prescale, 1 - replication, etc.)
    WORD  wNumFilterTapsY;              // Number of taps the prescaler uses in the Y direction (0 - no prescale, 1 - replication, etc.)
} DDVIDEOPORTCAPS;

/*
 * The dwMaxWidth and dwMaxVBIWidth members are valid
 */
#define DDVPD_WIDTH		0x00000001l

/*
 * The dwMaxHeight member is valid
 */
#define DDVPD_HEIGHT		0x00000002l

/*
 * The dwVideoPortID member is valid
 */
#define DDVPD_ID		0x00000004l

/*
 * The dwCaps member is valid
 */
#define DDVPD_CAPS		0x00000008l

/*
 * The dwFX member is valid
 */
#define DDVPD_FX		0x00000010l

/*
 * The dwNumAutoFlipSurfaces member is valid
 */
#define DDVPD_AUTOFLIP		0x00000020l

/*
 * All of the alignment members are valid
 */
#define DDVPD_ALIGN		0x00000040l

/*
 * The dwNumPreferredAutoflip member is valid
 */
#define DDVPD_PREFERREDAUTOFLIP 0x00000080l

/*
 * The wNumFilterTapsX and wNumFilterTapsY fields are valid
 */
#define DDVPD_FILTERQUALITY     0x00000100l

/*
 * DDVIDEOPORTDESC
 */
typedef struct _DDVIDEOPORTDESC
{
    DWORD dwSize;			// size of the DDVIDEOPORTDESC structure
    DWORD dwFieldWidth;			// width of the video port field
    DWORD dwVBIWidth;			// width of the VBI data
    DWORD dwFieldHeight;		// height of the video port field
    DWORD dwMicrosecondsPerField;	// Microseconds per video field
    DWORD dwMaxPixelsPerSecond;		// Maximum pixel rate per second
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwReserved1;			// Reserved for future use - set to zero (struct padding)
    DDVIDEOPORTCONNECT VideoPortType; 	// Description of video port connection
    UINT_PTR dwReserved2;		// Reserved for future use - set to zero
    UINT_PTR dwReserved3;		// Reserved for future use - set to zero
} DDVIDEOPORTDESC;


/*
 * DDVIDEOPORTINFO
 */
typedef struct _DDVIDEOPORTINFO
{
    DWORD dwSize;			// Size of the structure
    DWORD dwOriginX;			// Placement of the video data within the surface.
    DWORD dwOriginY;			// Placement of the video data within the surface.
    DWORD dwVPFlags;			// Video port options
    RECT rCrop;				// Cropping rectangle (optional).
    DWORD dwPrescaleWidth;		// Determines pre-scaling/zooming in the X direction (optional).
    DWORD dwPrescaleHeight;		// Determines pre-scaling/zooming in the Y direction (optional).
    LPDDPIXELFORMAT lpddpfInputFormat;	// Video format written to the video port
    LPDDPIXELFORMAT lpddpfVBIInputFormat; // Input format of the VBI data
    LPDDPIXELFORMAT lpddpfVBIOutputFormat;// Output format of the data
    DWORD dwVBIHeight;			// Specifies the number of lines of data within the vertical blanking interval.
    UINT_PTR dwReserved1;		// Reserved for future use - set to zero
    UINT_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTINFO;


/*
 * DDVIDEOPORTBANDWIDTH
 */
typedef struct _DDVIDEOPORTBANDWIDTH
{
    DWORD dwSize;			// Size of the structure
    DWORD dwCaps;
    DWORD dwOverlay;           		// Zoom factor at which overlay is supported
    DWORD dwColorkey;			// Zoom factor at which overlay w/ colorkey is supported
    DWORD dwYInterpolate;		// Zoom factor at which overlay w/ Y interpolation is supported
    DWORD dwYInterpAndColorkey;		// Zoom factor at which ovelray w/ Y interpolation and colorkeying is supported
    UINT_PTR dwReserved1;		// Reserved for future use - set to zero
    UINT_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTBANDWIDTH;


/*
 * DDVIDEOPORTSTATUS
 */
typedef struct _DDVIDEOPORTSTATUS
{
    DWORD dwSize;			// Size of the structure
    BOOL  bInUse;			// TRUE if video port is currently being used
    DWORD dwFlags;           		// Currently not used
    DWORD dwReserved1;			// Reserved for future use
    DDVIDEOPORTCONNECT VideoPortType;	// Information about the connection
    UINT_PTR dwReserved2;		// Reserved for future use
    UINT_PTR dwReserved3;		// Reserved for future use
} DDVIDEOPORTSTATUS;

/*============================================================================
 *
 * Video Port Flags
 *
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTCONNECT FLAGS
 *
 ****************************************************************************/

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of double clocking the data.
 * When this is set by the client, this indicates that the video port
 * should enable double clocking.  This flag is only valid with external
 * syncs.
 */
#define DDVPCONNECT_DOUBLECLOCK			0x00000001l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of using an external VACT
 * signal. When this is set by the client, this indicates that the
 * video port should use the external VACT signal.
 */
#define DDVPCONNECT_VACT			0x00000002l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of treating even fields
 * like odd fields and visa versa.  When this is set by the client,
 * this indicates that the video port should treat even fields like odd
 * fields.
 */
#define DDVPCONNECT_INVERTPOLARITY		0x00000004l

/*
 * Indicates that any data written to the video port during the VREF
 * period will not be written into the frame buffer. This flag is read only.
 */
#define DDVPCONNECT_DISCARDSVREFDATA		0x00000008l

/*
 * When this is set be the driver and passed to the client, this
 * indicates that the device will write half lines into the frame buffer
 * if half lines are provided by the decoder.  If this is set by the client,
 * this indicates that the decoder will be supplying half lines.
 */
#define DDVPCONNECT_HALFLINE			0x00000010l

/*
 * Indicates that the signal is interlaced. This flag is only
 * set by the client.
 */
#define DDVPCONNECT_INTERLACED			0x00000020l

/*
 * Indicates that video port is shareable and that this video port
 * will use the even fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREEVEN			0x00000040l

/*
 * Indicates that video port is shareable and that this video port
 * will use the odd fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREODD			0x00000080l

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC CAPS
 *
 ****************************************************************************/

/*
 * Flip can be performed automatically to avoid tearing.
 */
#define DDVPCAPS_AUTOFLIP			0x00000001l

/*
 * Supports interlaced video
 */
#define DDVPCAPS_INTERLACED			0x00000002l

/*
 * Supports non-interlaced video
 */
#define DDVPCAPS_NONINTERLACED			0x00000004l

/*
 * Indicates that the device can return whether the current field
 * of an interlaced signal is even or odd.
 */
#define DDVPCAPS_READBACKFIELD			0x00000008l

/*
 * Indicates that the device can return the current line of video
 * being written into the frame buffer.
 */
#define DDVPCAPS_READBACKLINE			0x00000010l

/*
 * Allows two gen-locked video streams to share a single video port,
 * where one stream uses the even fields and the other uses the odd
 * fields. Separate parameters (including address, scaling,
 * cropping, etc.) are maintained for both fields.)
 */
#define DDVPCAPS_SHAREABLE			0x00000020l

/*
 * Even fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPEVENFIELDS			0x00000040l

/*
 * Odd fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPODDFIELDS			0x00000080l

/*
 * Indicates that the device is capable of driving the graphics
 * VSYNC with the video port VSYNC.
 */
#define DDVPCAPS_SYNCMASTER			0x00000100l

/*
 * Indicates that data within the vertical blanking interval can
 * be written to a different surface.
 */
#define DDVPCAPS_VBISURFACE			0x00000200l

/*
 * Indicates that the video port can perform color operations
 * on the incoming data before it is written to the frame buffer.
 */
#define DDVPCAPS_COLORCONTROL			0x00000400l

/*
 * Indicates that the video port can accept VBI data in a different
 * width or format than the regular video data.
 */
#define DDVPCAPS_OVERSAMPLEDVBI			0x00000800l

/*
 * Indicates that the video port can write data directly to system memory
 */
#define DDVPCAPS_SYSTEMMEMORY			0x00001000l

/*
 * Indicates that the VBI and video portions of the video stream can
 * be controlled by an independent processes.
 */
#define DDVPCAPS_VBIANDVIDEOINDEPENDENT		0x00002000l

/*
 * Indicates that the video port contains high quality hardware
 * de-interlacing hardware that should be used instead of the
 * bob/weave algorithms.
 */
#define DDVPCAPS_HARDWAREDEINTERLACE		0x00004000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC FX
 *
 ****************************************************************************/

/*
 * Limited cropping is available to crop out the vertical interval data.
 */
#define DDVPFX_CROPTOPDATA			0x00000001l

/*
 * Incoming data can be cropped in the X direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPX				0x00000002l

/*
 * Incoming data can be cropped in the Y direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPY				0x00000004l

/*
 * Supports interleaving interlaced fields in memory.
 */
#define DDVPFX_INTERLEAVE			0x00000008l

/*
 * Supports mirroring left to right as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORLEFTRIGHT			0x00000010l

/*
 * Supports mirroring top to bottom as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORUPDOWN			0x00000020l

/*
 * Data can be arbitrarily shrunk in the X direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKX			0x00000040l

/*
 * Data can be arbitrarily shrunk in the Y direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKY			0x00000080l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the X
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXB			0x00000100l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the Y
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYB			0x00000200l

/*
 * Data can be shrunk in increments of 1/x in the X direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkXStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXS			0x00000400l

/*
 * Data can be shrunk in increments of 1/x in the Y direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkYStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYS			0x00000800l

/*
 * Data can be arbitrarily stretched in the X direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHX			0x00001000l

/*
 * Data can be arbitrarily stretched in the Y direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHY			0x00002000l

/*
 * Data can be integer stretched in the X direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHXN			0x00004000l

/*
 * Data can be integer stretched in the Y direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHYN			0x00008000l

/*
 * Indicates that data within the vertical blanking interval can
 * be converted independently of the remaining video data.
 */
#define DDVPFX_VBICONVERT			0x00010000l

/*
 * Indicates that scaling can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOSCALE			0x00020000l

/*
 * Indicates that the video data can ignore the left and right
 * cropping coordinates when cropping oversampled VBI data.
 */
#define DDVPFX_IGNOREVBIXCROP			0x00040000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOINTERLEAVE			0x00080000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTINFO FLAGS
 *
 ****************************************************************************/

/*
 * Perform automatic flipping.   Auto-flipping is performed between
 * the overlay surface that was attached to the video port using
 * IDirectDrawVideoPort::AttachSurface and the overlay surfaces that
 * are attached to the surface via the IDirectDrawSurface::AttachSurface
 * method.  The flip order is the order in which the overlay surfaces
 * were. attached.
 */
#define DDVP_AUTOFLIP				0x00000001l

/*
 * Perform conversion using the ddpfOutputFormat information.
 */
#define DDVP_CONVERT				0x00000002l

/*
 * Perform cropping using the specified rectangle.
 */
#define DDVP_CROP				0x00000004l

/*
 * Indicates that interlaced fields should be interleaved in memory.
 */
#define DDVP_INTERLEAVE				0x00000008l

/*
 * Indicates that the data should be mirrored left to right as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORLEFTRIGHT			0x00000010l

/*
 * Indicates that the data should be mirrored top to bottom as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORUPDOWN			0x00000020l

/*
 * Perform pre-scaling/zooming based on the pre-scale parameters.
 */
#define DDVP_PRESCALE				0x00000040l

/*
 * Ignore input of even fields.
 */
#define DDVP_SKIPEVENFIELDS			0x00000080l

/*
 * Ignore input of odd fields.
 */
#define DDVP_SKIPODDFIELDS			0x00000100l

/*
 * Drive the graphics VSYNCs using the video port VYSNCs.
 */
#define DDVP_SYNCMASTER				0x00000200l

/*
 * The ddpfVBIOutputFormatFormat member contains data that should be used
 * to convert the data within the vertical blanking interval.
 */
#define DDVP_VBICONVERT				0x00000400l

/*
 * Indicates that data within the vertical blanking interval
 * should not be scaled.
 */
#define DDVP_VBINOSCALE				0x00000800l

/*
 * Indicates that these bob/weave decisions should not be
 * overriden by other interfaces.
 */
#define DDVP_OVERRIDEBOBWEAVE			0x00001000l

/*
 * Indicates that the video data should ignore the left and right
 * cropping coordinates when cropping the VBI data.
 */
#define DDVP_IGNOREVBIXCROP			0x00002000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVP_VBINOINTERLEAVE			0x00004000l

/*
 * Indicates that the video port should use the hardware
 * de-interlacing hardware.
 */
#define DDVP_HARDWAREDEINTERLACE		0x00008000l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETINPUTFORMAT/GETOUTPUTFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * Return formats for the video data
 */
#define DDVPFORMAT_VIDEO			0x00000001l

/*
 * Return formats for the VBI data
 */
#define DDVPFORMAT_VBI				0x00000002l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT SETTARGETSURFACE FLAGS
 *
 ****************************************************************************/

/*
 * Surface should receive video data (and VBI data if a surface
 * is not explicitly attached for that purpose)
 */
#define DDVPTARGET_VIDEO			0x00000001l

/*
 * Surface should receive VBI data
 */
#define DDVPTARGET_VBI				0x00000002l


/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT WAITFORSYNC FLAGS
 *
 ****************************************************************************/

/*
 * Waits until the beginning of the next VSYNC
 */
#define DDVPWAIT_BEGIN				0x00000001l

/*
 * Waits until the end of the next/current VSYNC
 */
#define DDVPWAIT_END				0x00000002l

/*
 * Waits until the beginning of the specified line
 */
#define DDVPWAIT_LINE				0x00000003l

/****************************************************************************
 *
 * DIRECTDRAWVIDEOPORT FLIP FLAGS
 *
 ****************************************************************************/

/*
 * Flips the normal video surface
 */
#define DDVPFLIP_VIDEO				0x00000001l

/*
 * Flips the VBI surface
 */
#define DDVPFLIP_VBI				0x00000002l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETVIDEOSIGNALSTATUS VALUES
 *
 ****************************************************************************/

/*
 * No video signal is present at the video port
 */
#define DDVPSQ_NOSIGNAL				0x00000001l

/*
 * A valid video signal is present at the video port
 */
#define DDVPSQ_SIGNALOK				0x00000002l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Flags
 *
 ****************************************************************************/

/*
 * The specified height/width refer to the size of the video port data
 * written into memory, after prescaling has occured.
 */
#define DDVPB_VIDEOPORT				0x00000001l

/*
 * The specified height/width refer to the source size of the overlay.
 */
#define DDVPB_OVERLAY				0x00000002l

/*
 * This is a query for the device to return which caps this device requires.
 */
#define DDVPB_TYPE				0x00000004l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Caps
 *
 ****************************************************************************/

/*
 * The bandwidth for this device is dependant on the overlay source size.
 */
#define DDVPBCAPS_SOURCE			0x00000001l

/*
 * The bandwidth for this device is dependant on the overlay destination
 * size.
 */
#define DDVPBCAPS_DESTINATION			0x00000002l

/****************************************************************************
 *
 * DDVIDEOPORTCONTAINER CreateVideoPort flags
 *
 ****************************************************************************/

/*
 * The process only wants to control the VBI portion of the video stream.
 */
#define DDVPCREATE_VBIONLY			0x00000001l

/*
 * The process only wants to control the non-VBI (video) portion of
 * the video stream.
 */
#define DDVPCREATE_VIDEOONLY			0x00000002l

/****************************************************************************
 *
 * DDVIDEOPORTSTATUS flags
 *
 ****************************************************************************/

/*
 * The video port interface is only controlling the VBI portion of the
 * video stream
 */
#define DDVPSTATUS_VBIONLY			0x00000001l

/*
 * The video port interface is only controlling the video portion of the
 * video stream
 */
#define DDVPSTATUS_VIDEOONLY			0x00000002l


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\dsetup.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsetup.h
 *  Content:    DirectXSetup, error codes and flags
 ***************************************************************************/

#ifndef __DSETUP_H__
#define __DSETUP_H__

#include <windows.h>      // windows stuff

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#endif


#ifdef __cplusplus
extern "C" {
#endif

// DSETUP Error Codes, must remain compatible with previous setup.
#define DSETUPERR_SUCCESS_RESTART        1
#define DSETUPERR_SUCCESS                0
#define DSETUPERR_BADWINDOWSVERSION     -1
#define DSETUPERR_SOURCEFILENOTFOUND    -2
#define DSETUPERR_BADSOURCESIZE         -3
#define DSETUPERR_BADSOURCETIME         -4
#define DSETUPERR_NOCOPY                -5
#define DSETUPERR_OUTOFDISKSPACE        -6
#define DSETUPERR_CANTFINDINF           -7
#define DSETUPERR_CANTFINDDIR           -8
#define DSETUPERR_INTERNAL              -9
#define DSETUPERR_NTWITHNO3D            -10  /* REM: obsolete, you'll never see this */
#define DSETUPERR_UNKNOWNOS             -11
#define DSETUPERR_USERHITCANCEL         -12
#define DSETUPERR_NOTPREINSTALLEDONNT   -13

// DSETUP flags. DirectX 5.0 apps should use these flags only.
#define DSETUP_DDRAWDRV         0x00000008      /* install DirectDraw Drivers           */
#define DSETUP_DSOUNDDRV        0x00000010      /* install DirectSound Drivers          */
#define DSETUP_DXCORE           0x00010000	/* install DirectX runtime              */
#define DSETUP_DIRECTX  (DSETUP_DXCORE|DSETUP_DDRAWDRV|DSETUP_DSOUNDDRV)
#define DSETUP_TESTINSTALL      0x00020000      /* just test install, don't do anything */

// These OBSOLETE flags are here for compatibility with pre-DX5 apps only.
// They are present to allow DX3 apps to be recompiled with DX5 and still work.
// DO NOT USE THEM for DX5. They will go away in future DX releases.
#define DSETUP_DDRAW            0x00000001      /* OBSOLETE. install DirectDraw           */
#define DSETUP_DSOUND           0x00000002      /* OBSOLETE. install DirectSound          */
#define DSETUP_DPLAY            0x00000004      /* OBSOLETE. install DirectPlay           */
#define DSETUP_DPLAYSP          0x00000020      /* OBSOLETE. install DirectPlay Providers */
#define DSETUP_DVIDEO           0x00000040      /* OBSOLETE. install DirectVideo          */
#define DSETUP_D3D              0x00000200      /* OBSOLETE. install Direct3D             */
#define DSETUP_DINPUT           0x00000800      /* OBSOLETE. install DirectInput          */
#define DSETUP_DIRECTXSETUP     0x00001000      /* OBSOLETE. install DirectXSetup DLL's   */
#define DSETUP_NOUI             0x00002000      /* OBSOLETE. install DirectX with NO UI   */
#define DSETUP_PROMPTFORDRIVERS 0x10000000      /* OBSOLETE. prompt when replacing display/audio drivers */
#define DSETUP_RESTOREDRIVERS   0x20000000      /* OBSOLETE. restore display/audio drivers */



//******************************************************************
// DirectX Setup Callback mechanism
//******************************************************************

// DSETUP Message Info Codes, passed to callback as Reason parameter.
#define DSETUP_CB_MSG_NOMESSAGE                     0
#define DSETUP_CB_MSG_CANTINSTALL_UNKNOWNOS         1
#define DSETUP_CB_MSG_CANTINSTALL_NT                2
#define DSETUP_CB_MSG_CANTINSTALL_BETA              3
#define DSETUP_CB_MSG_CANTINSTALL_NOTWIN32          4
#define DSETUP_CB_MSG_CANTINSTALL_WRONGLANGUAGE     5
#define DSETUP_CB_MSG_CANTINSTALL_WRONGPLATFORM     6
#define DSETUP_CB_MSG_PREINSTALL_NT                 7
#define DSETUP_CB_MSG_NOTPREINSTALLEDONNT           8
#define DSETUP_CB_MSG_SETUP_INIT_FAILED             9
#define DSETUP_CB_MSG_INTERNAL_ERROR                10
#define DSETUP_CB_MSG_CHECK_DRIVER_UPGRADE          11
#define DSETUP_CB_MSG_OUTOFDISKSPACE                12
#define DSETUP_CB_MSG_BEGIN_INSTALL                 13
#define DSETUP_CB_MSG_BEGIN_INSTALL_RUNTIME         14
#define DSETUP_CB_MSG_BEGIN_INSTALL_DRIVERS         15
#define DSETUP_CB_MSG_BEGIN_RESTORE_DRIVERS         16
#define DSETUP_CB_MSG_FILECOPYERROR                 17


#define DSETUP_CB_UPGRADE_TYPE_MASK             0x000F
#define DSETUP_CB_UPGRADE_KEEP                  0x0001
#define DSETUP_CB_UPGRADE_SAFE                  0x0002
#define DSETUP_CB_UPGRADE_FORCE                 0x0004
#define DSETUP_CB_UPGRADE_UNKNOWN               0x0008

#define DSETUP_CB_UPGRADE_HASWARNINGS           0x0100
#define DSETUP_CB_UPGRADE_CANTBACKUP            0x0200

#define DSETUP_CB_UPGRADE_DEVICE_ACTIVE         0x0800

#define DSETUP_CB_UPGRADE_DEVICE_DISPLAY        0x1000
#define DSETUP_CB_UPGRADE_DEVICE_MEDIA          0x2000


typedef struct _DSETUP_CB_UPGRADEINFO
{
    DWORD UpgradeFlags;
} DSETUP_CB_UPGRADEINFO;

typedef struct _DSETUP_CB_FILECOPYERROR
{
    DWORD dwError;
} DSETUP_CB_FILECOPYERROR;


#ifdef _WIN32
//
// Data Structures
//
#ifndef UNICODE_ONLY
typedef struct _DIRECTXREGISTERAPPA {
    DWORD    dwSize;
    DWORD    dwFlags;
    LPSTR    lpszApplicationName;
    LPGUID   lpGUID;
    LPSTR    lpszFilename;
    LPSTR    lpszCommandLine;
    LPSTR    lpszPath;
    LPSTR    lpszCurrentDirectory;
} DIRECTXREGISTERAPPA, *PDIRECTXREGISTERAPPA, *LPDIRECTXREGISTERAPPA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _DIRECTXREGISTERAPPW {
    DWORD    dwSize;
    DWORD    dwFlags;
    LPWSTR   lpszApplicationName;
    LPGUID   lpGUID;
    LPWSTR   lpszFilename;
    LPWSTR   lpszCommandLine;
    LPWSTR   lpszPath;
    LPWSTR   lpszCurrentDirectory;
} DIRECTXREGISTERAPPW, *PDIRECTXREGISTERAPPW, *LPDIRECTXREGISTERAPPW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef DIRECTXREGISTERAPPW DIRECTXREGISTERAPP;
typedef PDIRECTXREGISTERAPPW PDIRECTXREGISTERAPP;
typedef LPDIRECTXREGISTERAPPW LPDIRECTXREGISTERAPP;
#else
typedef DIRECTXREGISTERAPPA DIRECTXREGISTERAPP;
typedef PDIRECTXREGISTERAPPA PDIRECTXREGISTERAPP;
typedef LPDIRECTXREGISTERAPPA LPDIRECTXREGISTERAPP;
#endif // UNICODE


//
// API
//
#ifndef UNICODE_ONLY
INT
WINAPI
DirectXSetupA(
    HWND  hWnd,
    LPSTR lpszRootPath,
    DWORD dwFlags
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
INT
WINAPI
DirectXSetupW(
    HWND   hWnd,
    LPWSTR lpszRootPath,
    DWORD  dwFlags
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DirectXSetup  DirectXSetupW
#else
#define DirectXSetup  DirectXSetupA
#endif // !UNICODE

#ifndef UNICODE_ONLY
INT
WINAPI
DirectXDeviceDriverSetupA(
    HWND  hWnd,
    LPSTR lpszDriverClass,
    LPSTR lpszDriverPath,
    DWORD dwFlags
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
INT
WINAPI
DirectXDeviceDriverSetupW(
    HWND   hWnd,
    LPWSTR lpszDriverClass,
    LPWSTR lpszDriverPath,
    DWORD  dwFlags
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DirectXDeviceDriverSetup  DirectXDeviceDriverSetupW
#else
#define DirectXDeviceDriverSetup  DirectXDeviceDriverSetupA
#endif // !UNICODE

#ifndef UNICODE_ONLY
INT
WINAPI
DirectXRegisterApplicationA(
    HWND                  hWnd,
    LPDIRECTXREGISTERAPPA lpDXRegApp
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
INT
WINAPI
DirectXRegisterApplicationW(
    HWND                  hWnd,
    LPDIRECTXREGISTERAPPW lpDXRegApp
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DirectXRegisterApplication  DirectXRegisterApplicationW
#else
#define DirectXRegisterApplication  DirectXRegisterApplicationA
#endif // !UNICODE

INT
WINAPI
DirectXUnRegisterApplication(
    HWND     hWnd,
    LPGUID   lpGUID
    );

//
// Function Pointers
//
#ifdef UNICODE
typedef INT (WINAPI * LPDIRECTXSETUP)(HWND, LPWSTR, DWORD);
typedef INT (WINAPI * LPDIRECTXDEVICEDRIVERSETUP)(HWND, LPWSTR, LPSTR, DWORD);
typedef INT (WINAPI * LPDIRECTXREGISTERAPPLICATION)(HWND, LPDIRECTXREGISTERAPPW);
#else
typedef INT (WINAPI * LPDIRECTXSETUP)(HWND, LPSTR, DWORD);
typedef INT (WINAPI * LPDIRECTXDEVICEDRIVERSETUP)(HWND, LPSTR, LPSTR, DWORD);
typedef INT (WINAPI * LPDIRECTXREGISTERAPPLICATION)(HWND, LPDIRECTXREGISTERAPPA);
#endif // UNICODE

typedef DWORD (FAR PASCAL * DSETUP_CALLBACK)(DWORD Reason,
                                  DWORD MsgType,       /* Same as flags to MessageBox */
                                  LPSTR szMessage,
                                  LPSTR szName,
                                  void *pInfo);

INT WINAPI DirectXSetupSetCallback(DSETUP_CALLBACK Callback);
INT WINAPI DirectXSetupGetVersion(DWORD *lpdwVersion, DWORD *lpdwMinorVersion);

#endif // WIN32


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\rmxftmpl.h ===
/* D3DRM XFile templates in binary form */

#ifndef _RMXFTMPL_H_
#define _RMXFTMPL_H_

unsigned char D3DRM_XTEMPLATES[] = {
        0x78, 0x6f, 0x66, 0x20, 0x30, 0x33, 0x30, 0x32, 0x62, 
        0x69, 0x6e, 0x20, 0x30, 0x30, 0x36, 0x34, 0x1f, 0, 0x1, 
        0, 0x6, 0, 0, 0, 0x48, 0x65, 0x61, 0x64, 0x65, 
        0x72, 0xa, 0, 0x5, 0, 0x43, 0xab, 0x82, 0x3d, 0xda, 
        0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
        0x33, 0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x6d, 
        0x61, 0x6a, 0x6f, 0x72, 0x14, 0, 0x28, 0, 0x1, 0, 
        0x5, 0, 0, 0, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x14, 
        0, 0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x66, 
        0x6c, 0x61, 0x67, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
        0x6f, 0x72, 0xa, 0, 0x5, 0, 0x5e, 0xab, 0x82, 0x3d, 
        0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 
        0xe4, 0x33, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 0, 
        0x78, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
        0, 0x79, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
        0, 0, 0x7a, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
        0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
        0x73, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x44, 0x3f, 0xf2, 
        0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
        0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
        0, 0x75, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
        0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
        0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
        0x78, 0x34, 0x78, 0x34, 0xa, 0, 0x5, 0, 0x45, 0x3f, 
        0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
        0x33, 0x35, 0x94, 0xa3, 0x34, 0, 0x2a, 0, 0x1, 0, 
        0x6, 0, 0, 0, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 
        0xe, 0, 0x3, 0, 0x10, 0, 0, 0, 0xf, 0, 
        0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 
        0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
        0x41, 0xa, 0, 0x5, 0, 0xe0, 0x44, 0xff, 0x35, 0x7c, 
        0x6c, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 
        0xa3, 0x2a, 0, 0x1, 0, 0x3, 0, 0, 0, 0x72, 
        0x65, 0x64, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 
        0, 0, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x14, 0, 0x2a, 
        0, 0x1, 0, 0x4, 0, 0, 0, 0x62, 0x6c, 0x75, 
        0x65, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 0, 
        0, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x14, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 
        0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0xa, 0, 0x5, 0, 
        0x81, 0x6e, 0xe1, 0xd3, 0x35, 0x78, 0xcf, 0x11, 0x8f, 0x52, 
        0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 
        0x3, 0, 0, 0, 0x72, 0x65, 0x64, 0x14, 0, 0x2a, 
        0, 0x1, 0, 0x5, 0, 0, 0, 0x67, 0x72, 0x65, 
        0x65, 0x6e, 0x14, 0, 0x2a, 0, 0x1, 0, 0x4, 0, 
        0, 0, 0x62, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x49, 0x6e, 
        0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
        0xa, 0, 0x5, 0, 0x20, 0xb8, 0x30, 0x16, 0x42, 0x78, 
        0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
        0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x69, 0x6e, 
        0x64, 0x65, 0x78, 0x14, 0, 0x1, 0, 0x9, 0, 0, 
        0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 
        0x1, 0, 0xa, 0, 0, 0, 0x69, 0x6e, 0x64, 0x65, 
        0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 
        0x6f, 0x6c, 0x65, 0x61, 0x6e, 0xa, 0, 0x5, 0, 0xa0, 
        0xa6, 0x7d, 0x53, 0x37, 0xca, 0xd0, 0x11, 0x94, 0x1c, 0, 
        0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 0, 0x9, 
        0, 0, 0, 0x74, 0x72, 0x75, 0x65, 0x66, 0x61, 0x6c, 
        0x73, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0x9, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 
        0x6e, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x63, 0xae, 0x85, 
        0x48, 0xe8, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
        0x35, 0x94, 0xa3, 0x1, 0, 0x7, 0, 0, 0, 0x42, 
        0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 
        0, 0, 0x75, 0x14, 0, 0x1, 0, 0x7, 0, 0, 
        0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 
        0x1, 0, 0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 
        0, 0x1, 0, 0xc, 0, 0, 0, 0x4d, 0x61, 0x74, 
        0x65, 0x72, 0x69, 0x61, 0x6c, 0x57, 0x72, 0x61, 0x70, 0xa, 
        0, 0x5, 0, 0x60, 0xae, 0x85, 0x48, 0xe8, 0x78, 0xcf, 
        0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
        0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 
        0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 0x75, 0x14, 
        0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 
        0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 
        0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0xf, 
        0, 0, 0, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 
        0x46, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0xa, 0, 
        0x5, 0, 0xe1, 0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 
        0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x31, 0, 
        0x1, 0, 0x8, 0, 0, 0, 0x66, 0x69, 0x6c, 0x65, 
        0x6e, 0x61, 0x6d, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x8, 0, 0, 0, 0x4d, 0x61, 0x74, 0x65, 
        0x72, 0x69, 0x61, 0x6c, 0xa, 0, 0x5, 0, 0x4d, 0xab, 
        0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 
        0xaf, 0x71, 0xe4, 0x33, 0x1, 0, 0x9, 0, 0, 0, 
        0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 0x1, 
        0, 0x9, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x43, 
        0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x2a, 0, 0x1, 0, 
        0x5, 0, 0, 0, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x14, 
        0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6c, 
        0x6f, 0x72, 0x52, 0x47, 0x42, 0x1, 0, 0xd, 0, 0, 
        0, 0x73, 0x70, 0x65, 0x63, 0x75, 0x6c, 0x61, 0x72, 0x43, 
        0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x1, 0, 0x8, 0, 
        0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
        0x1, 0, 0xd, 0, 0, 0, 0x65, 0x6d, 0x69, 0x73, 
        0x73, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 
        0, 0xe, 0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 
        0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x8, 0, 0, 
        0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 0xa, 
        0, 0x5, 0, 0x5f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
        0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
        0, 0x1, 0, 0x12, 0, 0, 0, 0x6e, 0x46, 0x61, 
        0x63, 0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 
        0x64, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 
        0, 0x1, 0, 0x11, 0, 0, 0, 0x66, 0x61, 0x63, 
        0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 
        0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 0, 0x12, 0, 
        0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x56, 0x65, 0x72, 
        0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 
        0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0xd, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 
        0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x73, 0xa, 0, 0x5, 
        0, 0xc0, 0xc5, 0x1e, 0xed, 0xa8, 0xc0, 0xd0, 0x11, 0x94, 
        0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 
        0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
        0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 
        0x14, 0, 0x34, 0, 0x1, 0, 0x9, 0, 0, 0, 
        0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x32, 0x64, 0x1, 
        0, 0xe, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x57, 
        0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0xe, 
        0, 0x1, 0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 
        0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 
        0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x11, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
        0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 
        0x72, 0x64, 0x73, 0xa, 0, 0x5, 0, 0x40, 0x3f, 0xf2, 
        0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
        0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xe, 0, 0, 
        0, 0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 
        0x6f, 0x6f, 0x72, 0x64, 0x73, 0x14, 0, 0x34, 0, 0x1, 
        0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
        0x73, 0x32, 0x64, 0x1, 0, 0xd, 0, 0, 0, 0x74, 
        0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 0x72, 
        0x64, 0x73, 0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 
        0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 
        0x6f, 0x72, 0x64, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x4d, 0x65, 
        0x73, 0x68, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 
        0x4c, 0x69, 0x73, 0x74, 0xa, 0, 0x5, 0, 0x42, 0x3f, 
        0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
        0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 0, 
        0, 0, 0x6e, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 
        0x6c, 0x73, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 0, 
        0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x49, 0x6e, 0x64, 
        0x65, 0x78, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 0, 
        0x1, 0, 0xb, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
        0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xe, 0, 0x1, 
        0, 0xc, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
        0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xf, 0, 0x14, 
        0, 0xe, 0, 0x1, 0, 0x8, 0, 0, 0, 0x4d, 
        0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 0xf, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x4d, 
        0x65, 0x73, 0x68, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
        0xa, 0, 0x5, 0, 0x43, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 
        0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
        0x29, 0, 0x1, 0, 0x8, 0, 0, 0, 0x6e, 0x4e, 
        0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 
        0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
        0x6f, 0x72, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x6f, 
        0x72, 0x6d, 0x61, 0x6c, 0x73, 0xe, 0, 0x1, 0, 0x8, 
        0, 0, 0, 0x6e, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 
        0x73, 0xf, 0, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 
        0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x4e, 0x6f, 
        0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 0x1, 
        0, 0x8, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 
        0x61, 0x63, 0x65, 0x1, 0, 0xb, 0, 0, 0, 0x66, 
        0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
        0xe, 0, 0x1, 0, 0xc, 0, 0, 0, 0x6e, 0x46, 
        0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
        0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0x10, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x56, 0x65, 
        0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 
        0xa, 0, 0x5, 0, 0x21, 0xb8, 0x30, 0x16, 0x42, 0x78, 
        0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
        0x29, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 0x56, 
        0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
        0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0xc, 0, 0, 
        0, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 
        0x6c, 0x6f, 0x72, 0x1, 0, 0xc, 0, 0, 0, 0x76, 
        0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
        0x73, 0xe, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 
        0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 
        0x72, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x4, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
        0xa, 0, 0x5, 0, 0x44, 0xab, 0x82, 0x3d, 0xda, 0x62, 
        0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
        0x29, 0, 0x1, 0, 0x9, 0, 0, 0, 0x6e, 0x56, 
        0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 
        0, 0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 
        0x74, 0x6f, 0x72, 0x1, 0, 0x8, 0, 0, 0, 0x76, 
        0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 
        0, 0x9, 0, 0, 0, 0x6e, 0x56, 0x65, 0x72, 0x74, 
        0x69, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0x29, 0, 
        0x1, 0, 0x6, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 
        0x65, 0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0x8, 0, 
        0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 
        0x1, 0, 0x5, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
        0x73, 0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x6e, 
        0x46, 0x61, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xe, 
        0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0x14, 0, 0, 0, 0x46, 
        0x72, 0x61, 0x6d, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 
        0x6f, 0x72, 0x6d, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78, 0xa, 
        0, 0x5, 0, 0x41, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 0xcf, 
        0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
        0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
        0x78, 0x34, 0x78, 0x34, 0x1, 0, 0xb, 0, 0, 0, 
        0x66, 0x72, 0x61, 0x6d, 0x65, 0x4d, 0x61, 0x74, 0x72, 0x69, 
        0x78, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x5, 
        0, 0, 0, 0x46, 0x72, 0x61, 0x6d, 0x65, 0xa, 0, 
        0x5, 0, 0x46, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 
        0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 0, 
        0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 0x46, 0x6c, 
        0x6f, 0x61, 0x74, 0x4b, 0x65, 0x79, 0x73, 0xa, 0, 0x5, 
        0, 0xa9, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 0x8f, 
        0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 
        0, 0x7, 0, 0, 0, 0x6e, 0x56, 0x61, 0x6c, 0x75, 
        0x65, 0x73, 0x14, 0, 0x34, 0, 0x2a, 0, 0x1, 0, 
        0x6, 0, 0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 
        0xe, 0, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x56, 
        0x61, 0x6c, 0x75, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 
        0x69, 0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 
        0x65, 0x79, 0x73, 0xa, 0, 0x5, 0, 0x80, 0xb1, 0x6, 
        0xf4, 0x3b, 0x7b, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
        0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x4, 0, 0, 
        0, 0x74, 0x69, 0x6d, 0x65, 0x14, 0, 0x1, 0, 0x9, 
        0, 0, 0, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
        0x79, 0x73, 0x1, 0, 0x6, 0, 0, 0, 0x74, 0x66, 
        0x6b, 0x65, 0x79, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0xc, 0, 0, 0, 0x41, 0x6e, 0x69, 0x6d, 
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0xa, 0, 
        0x5, 0, 0xa8, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 
        0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 
        0x1, 0, 0x7, 0, 0, 0, 0x6b, 0x65, 0x79, 0x54, 
        0x79, 0x70, 0x65, 0x14, 0, 0x29, 0, 0x1, 0, 0x5, 
        0, 0, 0, 0x6e, 0x4b, 0x65, 0x79, 0x73, 0x14, 0, 
        0x34, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 0x69, 
        0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
        0x79, 0x73, 0x1, 0, 0x4, 0, 0, 0, 0x6b, 0x65, 
        0x79, 0x73, 0xe, 0, 0x1, 0, 0x5, 0, 0, 0, 
        0x6e, 0x4b, 0x65, 0x79, 0x73, 0xf, 0, 0x14, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x41, 
        0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x70, 
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0xa, 0, 0x5, 0, 0xc0, 
        0x56, 0xbf, 0xe2, 0xf, 0x84, 0xcf, 0x11, 0x8f, 0x52, 0, 
        0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 
        0, 0, 0, 0x6f, 0x70, 0x65, 0x6e, 0x63, 0x6c, 0x6f, 
        0x73, 0x65, 0x64, 0x14, 0, 0x29, 0, 0x1, 0, 0xf, 
        0, 0, 0, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 
        0x6e, 0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x14, 0, 
        0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 
        0x41, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xa, 
        0, 0x5, 0, 0x4f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
        0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 
        0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x41, 
        0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 
        0x74, 0xa, 0, 0x5, 0, 0x50, 0xab, 0x82, 0x3d, 0xda, 
        0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
        0x33, 0xe, 0, 0x1, 0, 0x9, 0, 0, 0, 0x41, 
        0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xf, 0, 
        0xb, 0, 0x1f, 0, 0x1, 0, 0xa, 0, 0, 0, 
        0x49, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 
        0xa, 0, 0x5, 0, 0xa0, 0xee, 0x23, 0x3a, 0xb1, 0x94, 
        0xd0, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
        0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x42, 0x49, 
        0x4e, 0x41, 0x52, 0x59, 0xf, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 0x6c, 0xa, 
        0, 0x5, 0, 0xa1, 0xee, 0x23, 0x3a, 0xb1, 0x94, 0xd0, 
        0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
        0, 0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 
        0x6c, 0x73, 0x14, 0, 0x34, 0, 0x31, 0, 0x1, 0, 
        0x4, 0, 0, 0, 0x75, 0x72, 0x6c, 0x73, 0xe, 0, 
        0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 0x6c, 
        0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
        0, 0xf, 0, 0, 0, 0x50, 0x72, 0x6f, 0x67, 0x72, 
        0x65, 0x73, 0x73, 0x69, 0x76, 0x65, 0x4d, 0x65, 0x73, 0x68, 
        0xa, 0, 0x5, 0, 0x60, 0xc3, 0x63, 0x8a, 0x7d, 0x99, 
        0xd0, 0x11, 0x94, 0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 
        0xe, 0, 0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 
        0x6c, 0x13, 0, 0x1, 0, 0xa, 0, 0, 0, 0x49, 
        0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 0xf, 
        0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x4, 0, 0, 
        0, 0x47, 0x75, 0x69, 0x64, 0xa, 0, 0x5, 0, 0xe0, 
        0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 
        0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x5, 
        0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x31, 0x14, 0, 
        0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x64, 0x61, 
        0x74, 0x61, 0x32, 0x14, 0, 0x28, 0, 0x1, 0, 0x5, 
        0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x33, 0x14, 0, 
        0x34, 0, 0x2d, 0, 0x1, 0, 0x5, 0, 0, 0, 
        0x64, 0x61, 0x74, 0x61, 0x34, 0xe, 0, 0x3, 0, 0x8, 
        0, 0, 0, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 
        0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 0x72, 
        0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 
        0x79, 0xa, 0, 0x5, 0, 0xe0, 0x21, 0xf, 0x7f, 0xe1, 
        0xbf, 0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 
        0x71, 0x31, 0, 0x1, 0, 0x3, 0, 0, 0, 0x6b, 
        0x65, 0x79, 0x14, 0, 0x31, 0, 0x1, 0, 0x5, 0, 
        0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x50, 
        0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x42, 0x61, 0x67, 
        0xa, 0, 0x5, 0, 0xe1, 0x21, 0xf, 0x7f, 0xe1, 0xbf, 
        0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 
        0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 
        0x72, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 
        0x74, 0x79, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0xe, 0, 0, 0, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 
        0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0xa, 0, 
        0x5, 0, 0xa0, 0x6a, 0x11, 0x98, 0xba, 0xbd, 0xd1, 0x11, 
        0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 0x1, 0, 
        0x4, 0, 0, 0, 0x47, 0x75, 0x69, 0x64, 0x1, 0, 
        0x12, 0, 0, 0, 0x67, 0x75, 0x69, 0x64, 0x45, 0x78, 
        0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 
        0x61, 0x6c, 0x14, 0, 0xe, 0, 0x12, 0, 0x12, 0, 
        0x12, 0, 0xf, 0, 0xb, 0
};

#define D3DRM_XTEMPLATE_BYTES 3215

#endif /* _RMXFTMPL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx6\dxfile.h ===
/***************************************************************************
 *
 *  Copyright (C) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxfile.h
 *
 *  Content:    DirectX File public header file
 *
 ***************************************************************************/

#ifndef __DXFILE_H__
#define __DXFILE_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef DWORD DXFILEFORMAT;

#define DXFILEFORMAT_BINARY     0
#define DXFILEFORMAT_TEXT       1
#define DXFILEFORMAT_COMPRESSED 2

typedef DWORD DXFILELOADOPTIONS;

#define DXFILELOAD_FROMFILE  0x00L
#define DXFILELOAD_FROMRESOURCE 0x01L
#define DXFILELOAD_FROMMEMORY 0x02L
#define DXFILELOAD_FROMSTREAM 0x04L
#define DXFILELOAD_FROMURL 0x08L

typedef struct _DXFILELOADRESOURCE {
    HMODULE hModule;
    LPCTSTR lpName;
    LPCTSTR lpType;
}DXFILELOADRESOURCE, *LPDXFILELOADRESOURCE;

typedef struct _DXFILELOADMEMORY {
    LPVOID lpMemory;
    DWORD dSize;
}DXFILELOADMEMORY, *LPDXFILELOADMEMORY;

/*
 * DirectX File object types.
 */

#ifndef WIN_TYPES
#define WIN_TYPES(itype, ptype) typedef interface itype *LP##ptype, **LPLP##ptype
#endif

WIN_TYPES(IDirectXFile,                 DIRECTXFILE);
WIN_TYPES(IDirectXFileEnumObject,       DIRECTXFILEENUMOBJECT);
WIN_TYPES(IDirectXFileSaveObject,       DIRECTXFILESAVEOBJECT);
WIN_TYPES(IDirectXFileObject,           DIRECTXFILEOBJECT);
WIN_TYPES(IDirectXFileData,             DIRECTXFILEDATA);
WIN_TYPES(IDirectXFileDataReference,    DIRECTXFILEDATAREFERENCE);
WIN_TYPES(IDirectXFileBinary,           DIRECTXFILEBINARY);

/*
 * API for creating IDirectXFile interface.
 */

STDAPI DirectXFileCreate(LPDIRECTXFILE *lplpDirectXFile);

/*
 * The methods for IUnknown
 */

#define IUNKNOWN_METHODS(kind) \
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD_(ULONG, AddRef)       (THIS) kind; \
    STDMETHOD_(ULONG, Release)      (THIS) kind

/*
 * The methods for IDirectXFileObject
 */

#define IDIRECTXFILEOBJECT_METHODS(kind) \
    STDMETHOD(GetName) (THIS_ LPSTR, LPDWORD) kind; \
    STDMETHOD(GetId) (THIS_ LPGUID) kind

/*
 * DirectX File interfaces.
 */

#undef INTERFACE
#define INTERFACE IDirectXFile

DECLARE_INTERFACE_(IDirectXFile, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    STDMETHOD(CreateEnumObject) (THIS_ LPVOID, DXFILELOADOPTIONS,
                                 LPDIRECTXFILEENUMOBJECT *) PURE;
    STDMETHOD(CreateSaveObject) (THIS_ LPCSTR, DXFILEFORMAT,
                                 LPDIRECTXFILESAVEOBJECT *) PURE;
    STDMETHOD(RegisterTemplates) (THIS_ LPVOID, DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectXFileEnumObject

DECLARE_INTERFACE_(IDirectXFileEnumObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    STDMETHOD(GetNextDataObject)    (THIS_ LPDIRECTXFILEDATA *) PURE;
    STDMETHOD(GetDataObjectById)    (THIS_ REFGUID, LPDIRECTXFILEDATA *) PURE;
    STDMETHOD(GetDataObjectByName)  (THIS_ LPCSTR, LPDIRECTXFILEDATA *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectXFileSaveObject

DECLARE_INTERFACE_(IDirectXFileSaveObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    STDMETHOD(SaveTemplates) (THIS_ DWORD, const GUID **) PURE;
    STDMETHOD(CreateDataObject) (THIS_ REFGUID, LPCSTR, const GUID *,
                                 DWORD, LPVOID, LPDIRECTXFILEDATA *) PURE;
    STDMETHOD(SaveData) (THIS_ LPDIRECTXFILEDATA) PURE;
};


#undef INTERFACE
#define INTERFACE IDirectXFileObject

DECLARE_INTERFACE_(IDirectXFileObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECTXFILEOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirectXFileData

DECLARE_INTERFACE_(IDirectXFileData, IDirectXFileObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECTXFILEOBJECT_METHODS(PURE);

    STDMETHOD(GetData)          (THIS_ LPCSTR, DWORD *, void **) PURE;
    STDMETHOD(GetType)          (THIS_ const GUID **) PURE;
    STDMETHOD(GetNextObject)    (THIS_ LPDIRECTXFILEOBJECT *) PURE;
    STDMETHOD(AddDataObject)    (THIS_ LPDIRECTXFILEDATA) PURE;
    STDMETHOD(AddDataReference) (THIS_ LPCSTR, const GUID *) PURE;
    STDMETHOD(AddBinaryObject)  (THIS_ LPCSTR, const GUID *, LPCSTR, LPVOID, DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectXFileDataReference

DECLARE_INTERFACE_(IDirectXFileDataReference, IDirectXFileObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECTXFILEOBJECT_METHODS(PURE);

    STDMETHOD(Resolve) (THIS_ LPDIRECTXFILEDATA *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectXFileBinary

DECLARE_INTERFACE_(IDirectXFileBinary, IDirectXFileObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECTXFILEOBJECT_METHODS(PURE);

    STDMETHOD(GetSize)      (THIS_ DWORD *) PURE;
    STDMETHOD(GetMimeType)  (THIS_ LPCSTR *) PURE;
    STDMETHOD(Read)         (THIS_ LPVOID, DWORD, LPDWORD) PURE;
};

/*
 * DirectX File Interface GUIDs.
 */

DEFINE_GUID(IID_IDirectXFile,               0x3d82ab40, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileEnumObject,     0x3d82ab41, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileSaveObject,     0x3d82ab42, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileObject,         0x3d82ab43, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileData,           0x3d82ab44, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileDataReference,  0x3d82ab45, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileBinary,         0x3d82ab46, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/*
 * DirectX File Header template's GUID.
 */

DEFINE_GUID(TID_DXFILEHeader,   0x3d82ab43, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);


/*
 * DirectX File errors.
 */

#define _FACDD  0x876
#define MAKE_DDHRESULT( code )  MAKE_HRESULT( 1, _FACDD, code )

#define DXFILE_OK   0

#define DXFILEERR_BADOBJECT                 MAKE_DDHRESULT(850)
#define DXFILEERR_BADVALUE                  MAKE_DDHRESULT(851)
#define DXFILEERR_BADTYPE                   MAKE_DDHRESULT(852)
#define DXFILEERR_BADSTREAMHANDLE           MAKE_DDHRESULT(853)
#define DXFILEERR_BADALLOC                  MAKE_DDHRESULT(854)
#define DXFILEERR_NOTFOUND                  MAKE_DDHRESULT(855)
#define DXFILEERR_NOTDONEYET                MAKE_DDHRESULT(856)
#define DXFILEERR_FILENOTFOUND              MAKE_DDHRESULT(857)
#define DXFILEERR_RESOURCENOTFOUND          MAKE_DDHRESULT(858)
#define DXFILEERR_URLNOTFOUND               MAKE_DDHRESULT(859)
#define DXFILEERR_BADRESOURCE               MAKE_DDHRESULT(860)
#define DXFILEERR_BADFILETYPE               MAKE_DDHRESULT(861)
#define DXFILEERR_BADFILEVERSION            MAKE_DDHRESULT(862)
#define DXFILEERR_BADFILEFLOATSIZE          MAKE_DDHRESULT(863)
#define DXFILEERR_BADFILECOMPRESSIONTYPE    MAKE_DDHRESULT(864)
#define DXFILEERR_BADFILE                   MAKE_DDHRESULT(865)
#define DXFILEERR_PARSEERROR                MAKE_DDHRESULT(866)
#define DXFILEERR_NOTEMPLATE                MAKE_DDHRESULT(867)
#define DXFILEERR_BADARRAYSIZE              MAKE_DDHRESULT(868)
#define DXFILEERR_BADDATAREFERENCE          MAKE_DDHRESULT(869)
#define DXFILEERR_INTERNALERROR             MAKE_DDHRESULT(870)
#define DXFILEERR_NOMOREOBJECTS             MAKE_DDHRESULT(871)
#define DXFILEERR_BADINTRINSICS             MAKE_DDHRESULT(872)
#define DXFILEERR_NOMORESTREAMHANDLES       MAKE_DDHRESULT(873)
#define DXFILEERR_NOMOREDATA                MAKE_DDHRESULT(874)
#define DXFILEERR_BADCACHEFILE              MAKE_DDHRESULT(875)
#define DXFILEERR_NOINTERNET                MAKE_DDHRESULT(876)


#ifdef __cplusplus
};
#endif

#endif /* _DXFILE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\cbitmap_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\cbitmap.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\cd3dsurf_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\cd3dsurf.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\test\main.cpp ===
#define INITGUID
#include <windows.h>
#include <ddraw.h>
#include "..\ddrawex.h"


int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
			LPSTR lpCmdLine, int nCmdShow)
{
    CoInitialize(NULL);
    IDirectDrawFactory *pFactory;

    
    HRESULT hr = CoCreateInstance(CLSID_DirectDrawFactory, NULL, CLSCTX_INPROC_SERVER, IID_IDirectDrawFactory, (void **)&pFactory);
    if (SUCCEEDED(hr))
    {
	IDirectDraw *pDD;
	if (SUCCEEDED(pFactory->CreateDirectDraw(NULL, GetDesktopWindow(), DDSCL_NORMAL, 0, NULL, &pDD))) {
            DDSURFACEDESC ddsd;
    	    IDirectDrawSurface *pPrimarySurface;
    	    ddsd.dwSize = sizeof(ddsd);
    	    ddsd.dwFlags = DDSD_CAPS;
    	    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
	    if (SUCCEEDED(pDD->CreateSurface(&ddsd, &pPrimarySurface, NULL))) {
		IDirectDrawSurface *pSurface;
		ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
		ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY | DDSCAPS_OWNDC;
		ddsd.dwHeight = 100;
		ddsd.dwWidth = 100;
		pDD->CreateSurface(&ddsd, &pSurface, NULL);
		HDC hdc;
		pSurface->GetDC(&hdc);
		TextOut(hdc, 0, 0, "Testing 1..2..3", 15);

		IDirectDrawSurface *pFoundSurf;
		IDirectDrawDC *pGetDCThingie;
		pDD->QueryInterface(IID_IDirectDrawDC, (void **)&pGetDCThingie);
		pGetDCThingie->GetSurfaceFromDC(hdc, &pFoundSurf);

		RECT r = {0,0,100,100};
                pPrimarySurface->Blt(&r, pFoundSurf, &r, DDBLT_WAIT, NULL);     

		pFoundSurf->ReleaseDC(hdc);
		
		Sleep(3000);

		pSurface->Release();
		pFoundSurf->Release();
		pPrimarySurface->Release();
		pGetDCThingie->Release();
	    }
    	}
    	pDD->Release();
    }
    else
    {
	MessageBox( NULL, "CCI FAILED!!!!!!!!!", "FUUUUUUUCCCCCCCK", MB_OK );
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\cdeviceui_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\cdeviceui.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\cdevicecontrol_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\cdevicecontrol.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\cdeviceviewtext_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\cdeviceviewtext.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\cdeviceview_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\cdeviceview.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\cdftest_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\cdftest.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\cfrmwrk_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\cfrmwrk.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\cfguitrace_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\cfguitrace.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\common_stub.hpp ===
#include "..\\..\\diconfig\\common.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\configwnd_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\configwnd.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\cdiacpage_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\cdiacpage.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\cyclestr_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\cyclestr.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\constants_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\constants.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\flexcheckbox_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\flexcheckbox.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\flexcombobox_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\flexcombobox.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\flexlistbox_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\flexlistbox.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\flexscrollbar_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\flexscrollbar.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\flexmsgbox_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\flexmsgbox.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\flextooltip_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\flextooltip.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\flexinfobox_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\flexinfobox.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\flextree_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\flextree.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\flexwnd_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\flexwnd.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\iclassfact_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\iclassfact.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\guids_stub.c ===
#include "..\\..\\diconfig\\guids.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\ipageclassfact_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\ipageclassfact.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\itestclassfact_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\itestclassfact.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\main_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\main.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\makefile.inc ===
!if $(AXP64)
GUID_CPL_OPTIONS=/cpl_opt:" /qap64"
!else
GUID_CPL_OPTIONS=
!endif

$O\diguid.lib: ..\dinputpr.h ..\dinput.w ..\dinputd.w
    guidlib /OUT:$@ $(GUID_CPL_OPTIONS) /CPP_OPT:"-DINITGUID -DGUIDLIB -I$(SDK_INC_PATH) -I$(UMINCL)" ..\dinputpr.h

$(O)\guids.obj: ..\guids.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\populate_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\populate.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\privcom_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\privcom.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\registry_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\registry.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\rundftest_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\rundftest.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\win9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\uiglobals_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\uiglobals.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\sources.inc ===
!ifndef DXROOT
DXROOT=$(BASEDIR)\MultiMedia\DirectX
!endif

!INCLUDE $(DXROOT)\Project.mk


MAJORCOMP=windows
MINORCOMP=media
UMTYPE=windows

TARGETNAME=diactfrd
TARGETTYPE=DYNLINK
TARGETPATH=obj
USE_LIBCMT=1
USE_RTTI=1
DLLENTRY=_DllMainCRTStartup

INCLUDES=$(INCLUDES); \
	..\; \
	$(DXROOT)\inc;\
	$(SDK_INC_PATH)\MFC42;

USE_RTTI=1

!IFDEF TARGET_WIN95
CHICAGO_PRODUCT = 1
ALT_PROJECT_TARGET = WIN9x
C_DEFINES=$(C_DEFINES) -DDDKBUILD -DWIN95 -D_X86_ 
!ELSE
C_DEFINES=$(C_DEFINES) -DDDKBUILD -DWINNT -DUNICODE 
!ENDIF


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
	$(SDK_LIB_PATH)\kernel32.lib    \
	$(SDK_LIB_PATH)\advapi32.lib    \
	$(SDK_LIB_PATH)\ole32.lib    \
	$(SDK_LIB_PATH)\user32.lib      \
	$(SDK_LIB_PATH)\uuid.lib        \
	$(SDK_LIB_PATH)\gdi32.lib       \
	$(SDK_LIB_PATH)\comdlg32.lib    \
	$(SDK_LIB_PATH)\dinput8.lib     \
	$(SDK_LIB_PATH)\ddraw.lib       \
        $(SDK_LIB_PATH)\d3d8.lib     \
#	$(SDK_LIB_PATH)\mydebug.lib     \

!if $(FREEBUILD)
TARGETLIBS=$(TARGETLIBS) \
        $(SDK_LIB_PATH)\d3dx8.lib
!else
TARGETLIBS=$(TARGETLIBS) \
        $(SDK_LIB_PATH)\d3dx8dt.lib
!endif      


LINKER_FLAGS=-SECTION:share,RWS


!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif

SOURCES= \
	guids_stub.c	\
	dconfig_stub.rc	\
	privcom_stub.cpp \
	itestclassfact_stub.cpp \
	cdftest_stub.cpp \
	rundftest_stub.cpp \
	flexcombobox_stub.cpp \
	flexlistbox_stub.cpp \
	uiglobals_stub.cpp \
	cfguitrace_stub.cpp \
	flextree_stub.cpp \
	flexscrollbar_stub.cpp \
	selcontroldlg_stub.cpp \
	viewselwnd_stub.cpp \
	constants_stub.cpp        \
	cdiacpage_stub.cpp        \
	cdeviceui_stub.cpp        \
	cdeviceview_stub.cpp      \
	cdevicecontrol_stub.cpp   \
	iclassfact_stub.cpp \
	ipageclassfact_stub.cpp \
	configwnd_stub.cpp \
	cbitmap_stub.cpp  \
	usefuldi_stub.cpp \
	flexwnd_stub.cpp 	\
	cyclestr_stub.cpp   \
	cfrmwrk_stub.cpp	\
	registry_stub.cpp	\
	main_stub.cpp 	\
	flextooltip_stub.cpp \
	cd3dsurf_stub.cpp \
	cdeviceviewtext_stub.cpp \
	populate_stub.cpp \
	flexinfobox_stub.cpp \
	flexcheckbox_stub.cpp \
	flexmsgbox_stub.cpp \

PRECOMPILED_INCLUDE=..\common_stub.hpp

DLLDEF=..\..\diconfig\diactfrm.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\selcontroldlg_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\selcontroldlg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\usefuldi_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\usefuldi.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dicfgddk\viewselwnd_stub.cpp ===
#include "common_stub.hpp"
#include "..\\..\\diconfig\\viewselwnd.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cbitmap.h ===
//-----------------------------------------------------------------------------
// File: Cbitmap.h
//
// Desc: CBitmap class is an object that wraps around a Windows bitmap.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __CBITMAP_H__
#define __CBITMAP_H__

//@@BEGIN_MSINTERNAL
//typedef WINGDIAPI BOOL (WINAPI* ALPHABLEND)( HDC, int, int, int, int, HDC, int, int, int, int, BLENDFUNCTION);
//extern ALPHABLEND g_AlphaBlend;
//extern HMODULE g_MSImg32;
//@@END_MSINTERNAL

class CBitmap
{
private:
	CBitmap() :
		m_hbm(NULL),
		m_bSizeKnown(FALSE),
		m_hDCInto(NULL), m_hOldBitmap(NULL)
	{}
public:
	~CBitmap();

	static CBitmap *CreateViaD3DX(LPCTSTR tszFileName, LPDIRECT3DSURFACE8 pUISurf = NULL);
	static CBitmap *CreateViaLoadImage(HINSTANCE hInst, LPCTSTR tszName, UINT uType, int cx, int cy, UINT fuLoad);
	static CBitmap *CreateFromResource(HINSTANCE hInst, UINT uID) {return CreateFromResource(hInst, MAKEINTRESOURCE(uID));}
	static CBitmap *CreateFromResource(HINSTANCE hInst, LPCTSTR tszName);
	static CBitmap *CreateFromFile(LPCTSTR tszFileName);
	static CBitmap *StealToCreate(HBITMAP &refbm);
	static CBitmap *Create(int cx, int cy, HDC hDC = NULL) {SIZE size = {cx, cy}; return Create(size, hDC);}
	static CBitmap *Create(SIZE, HDC = NULL);
	static CBitmap *Create(SIZE, COLORREF, HDC = NULL);
	static CBitmap *CreateHorzGradient(const RECT &, COLORREF, COLORREF);

	BOOL GetSize(SIZE *psize);
	void AssumeSize(SIZE size);
	BOOL FigureSize();

	CBitmap *CreateResizedTo(SIZE size, HDC hDC = NULL, int iStretchMode = HALFTONE, BOOL bStretch = TRUE);
	CBitmap *Dup();
	
	BOOL Get(HDC hDC, POINT point, SIZE size);
	BOOL Get(HDC hDC, POINT point);

	BOOL Draw(HDC hDC) {return Draw(hDC, 0, 0);}
	BOOL Draw(HDC hDC, SIZE size) {return Draw(hDC, 0, 0, size);}
	BOOL Draw(HDC hDC, int x, int y, SIZE size) {POINT t = {x, y}; return Draw(hDC, t, size);}
	BOOL Draw(HDC hDC, int x, int y) {POINT t = {x, y}; return Draw(hDC, t);}
	BOOL Draw(HDC hDC, POINT origin) {SIZE t = {0, 0}; return Draw(hDC, origin, t, TRUE);}
	BOOL Draw(HDC hDC, POINT origin, SIZE size, BOOL bAll = FALSE);

	BOOL Blend(HDC hDC) {return Blend(hDC, 0, 0);}
	BOOL Blend(HDC hDC, SIZE size) {return Blend(hDC, 0, 0, size);}
	BOOL Blend(HDC hDC, int x, int y, SIZE size) {POINT t = {x, y}; return Blend(hDC, t, size);}
	BOOL Blend(HDC hDC, int x, int y) {POINT t = {x, y}; return Blend(hDC, t);}
	BOOL Blend(HDC hDC, POINT origin) {SIZE t = {0, 0}; return Blend(hDC, origin, t, TRUE);}
	BOOL Blend(HDC hDC, POINT origin, SIZE size, BOOL bAll = FALSE);

	HDC BeginPaintInto(HDC hCDC = NULL);
	void EndPaintInto(HDC &hDC);

	BOOL MapToDC(HDC hDCTo, HDC hDCMapFrom = NULL);

private:
	HBITMAP m_hbm;
	SIZE m_size;
	BOOL m_bSizeKnown;
	HDC m_hDCInto;
	HGDIOBJ m_hOldBitmap;
	void PopOut();
	void PopIn();
};


#endif //__CBITMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cbitmap.cpp ===
//-----------------------------------------------------------------------------
// File: Cbitmap.cpp
//
// Desc: CBitmap class is an object that wraps around a Windows bitmap.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"
#include "id3dsurf.h"

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
//HMODULE g_MSImg32 = NULL;
//ALPHABLEND g_AlphaBlend = NULL;
#endif
//@@END_MSINTERNAL

BOOL DI_AlphaBlend(
  HDC hdcDest,                 // handle to destination DC
  int nXOriginDest,            // x-coord of upper-left corner
  int nYOriginDest,            // y-coord of upper-left corner
  int nWidthDest,              // destination width
  int nHeightDest,             // destination height
  HDC hdcSrc,                  // handle to source DC
  int nXOriginSrc,             // x-coord of upper-left corner
  int nYOriginSrc,             // y-coord of upper-left corner
  int nWidthSrc,               // source width
  int nHeightSrc              // source height
)
{
	LPBYTE pbDestBits = NULL;
	HBITMAP hTempDestDib = NULL;
	int nXOriginDestLogical = nXOriginDest, nYOriginDestLogical = nYOriginDest;

	// Convert nXOriginDest and nYOriginDest from logical coord to device coord
	POINT pt = {nXOriginDest, nYOriginDest};
	LPtoDP(hdcDest, &pt, 1);
	nXOriginDest = pt.x;
	nYOriginDest = pt.y;
	// Convert nXOriginSrc and nYOriginSrc from logical coord to device coord
	pt.x = nXOriginSrc;
	pt.y = nYOriginSrc;
	LPtoDP(hdcSrc, &pt, 1);
	nXOriginSrc = pt.x;
	nYOriginSrc = pt.y;

	// Get the bits for both source and destination first
	// Every BITMAP used in the UI is created with CreateDIBSection, so we know we can get the bits.
	HBITMAP hSrcBmp, hDestBmp;
	DIBSECTION SrcDibSec, DestDibSec;
	hSrcBmp = (HBITMAP)GetCurrentObject(hdcSrc, OBJ_BITMAP);
	GetObject(hSrcBmp, sizeof(DIBSECTION), &SrcDibSec);
	hDestBmp = (HBITMAP)GetCurrentObject(hdcDest, OBJ_BITMAP);
	GetObject(hDestBmp, sizeof(DIBSECTION), &DestDibSec);
	if (!SrcDibSec.dsBm.bmBits) return FALSE;  // Not necessary, but to be absolutely safe.

	// Calculate the rectangle to perform the operation.
	if (nXOriginSrc + nWidthSrc > SrcDibSec.dsBm.bmWidth) nWidthSrc = SrcDibSec.dsBm.bmWidth - nXOriginSrc;
	if (nYOriginSrc + nHeightSrc > SrcDibSec.dsBm.bmHeight) nHeightSrc = SrcDibSec.dsBm.bmHeight - nYOriginSrc;
	if (nXOriginDest + nWidthDest > DestDibSec.dsBm.bmWidth) nWidthDest = DestDibSec.dsBm.bmWidth - nXOriginDest;
	if (nYOriginDest + nHeightDest > DestDibSec.dsBm.bmHeight) nHeightDest = DestDibSec.dsBm.bmHeight - nYOriginDest;

	if (nWidthDest > nWidthSrc) nWidthDest = nWidthSrc;
	if (nHeightDest > nHeightSrc) nHeightDest = nHeightSrc;
	if (nWidthSrc > nWidthDest) nWidthSrc = nWidthDest;
	if (nHeightSrc > nHeightDest) nHeightSrc = nHeightDest;

	BITMAPINFO bmi;
	ZeroMemory(&bmi.bmiHeader, sizeof(BITMAPINFOHEADER));
	bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	bmi.bmiHeader.biWidth = nWidthDest;
	bmi.bmiHeader.biHeight = nHeightDest;
	bmi.bmiHeader.biPlanes = 1;
	bmi.bmiHeader.biBitCount = 32;
	bmi.bmiHeader.biCompression = BI_RGB;

	// Bitmap will have the same width as the dest, but only lines covered in the subrect.
	hTempDestDib = CreateDIBSection(hdcDest, &bmi, DIB_RGB_COLORS, (LPVOID*)&pbDestBits, NULL, NULL);
	if (!hTempDestDib)
		return FALSE;

	HDC hTempDC = CreateCompatibleDC(hdcDest);
	if (!hTempDC)
	{
		DeleteObject(hTempDestDib);
		return FALSE;
	}
	HBITMAP hOldTempBmp = (HBITMAP)SelectObject(hTempDC, hTempDestDib);
	BOOL res = BitBlt(hTempDC, 0, 0, nWidthDest, nHeightDest, hdcDest, nXOriginDestLogical, nYOriginDestLogical, SRCCOPY);
	SelectObject(hTempDC, hOldTempBmp);
	DeleteDC(hTempDC);
	if (!res)
	{
		DeleteObject(hTempDestDib);
		return FALSE;
	}

	// We have the bits. Now do the blend.
	for (int j = 0; j < nHeightSrc; ++j)
	{
		assert(j >= 0 &&
		       j < nHeightDest);
		LPBYTE pbDestRGB = (LPBYTE)&((DWORD*)pbDestBits)[j * nWidthDest];

		assert(nYOriginSrc+SrcDibSec.dsBm.bmHeight-nHeightSrc >= 0 &&
		       nYOriginSrc+SrcDibSec.dsBm.bmHeight-nHeightSrc < SrcDibSec.dsBm.bmHeight);
		LPBYTE pbSrcRGBA = (LPBYTE)&((DWORD*)SrcDibSec.dsBm.bmBits)[(j+nYOriginSrc+SrcDibSec.dsBm.bmHeight-nHeightSrc)
		                                                            * SrcDibSec.dsBm.bmWidth + nXOriginSrc];

		for (int i = 0; i < nWidthSrc; ++i)
		{
			// Blend
			if (pbSrcRGBA[3] == 255)
			{
				// Alpha is 255. straight copy.
				*(LPDWORD)pbDestRGB = *(LPDWORD)pbSrcRGBA;
			} else
			if (pbSrcRGBA[3])
			{
				// Alpha is non-zero
				pbDestRGB[0] = pbSrcRGBA[0] + (((255-pbSrcRGBA[3]) * pbDestRGB[0]) >> 8);
				pbDestRGB[1] = pbSrcRGBA[1] + (((255-pbSrcRGBA[3]) * pbDestRGB[1]) >> 8);
				pbDestRGB[2] = pbSrcRGBA[2] + (((255-pbSrcRGBA[3]) * pbDestRGB[2]) >> 8);
			}
			pbDestRGB += sizeof(DWORD);
			pbSrcRGBA += sizeof(DWORD);
		}  // for
	} // for

	HDC hdcTempDest = CreateCompatibleDC(hdcDest);
	if (hdcTempDest)
	{
		HBITMAP hOldTempBmp = (HBITMAP)SelectObject(hdcTempDest, hTempDestDib);  // Select the temp dib for blitting
		// Get logical coord for device coord of dest origin
		POINT pt = {nXOriginDest, nYOriginDest};
		DPtoLP(hdcDest, &pt, 1);
		BitBlt(hdcDest, pt.x, pt.y, nWidthDest, nHeightDest,
		       hdcTempDest, 0, 0, SRCCOPY);
		SelectObject(hdcTempDest, hOldTempBmp);
		DeleteDC(hdcTempDest);
	}

	DeleteObject(hTempDestDib);
	return TRUE;
}

CBitmap::~CBitmap()
{
	if (m_hbm != NULL)
		DeleteObject(m_hbm);
	m_hbm = NULL;
	m_bSizeKnown = FALSE;
}

HDC CreateAppropDC(HDC hDC)
{
	return CreateCompatibleDC(hDC);
}

HBITMAP CreateAppropBitmap(HDC hDC, int cx, int cy)
{
	if (hDC != NULL)
		return CreateCompatibleBitmap(hDC, cx, cy);
	
	HWND hWnd = GetDesktopWindow();
	HDC hWDC = GetWindowDC(hWnd);
	HBITMAP hbm = NULL;
	if (hWDC != NULL)
	{
		hbm = CreateCompatibleBitmap(hWDC, cx, cy);
		ReleaseDC(hWnd, hWDC);
	}

	return hbm;
}

CBitmap *CBitmap::CreateFromResource(HINSTANCE hInst, LPCTSTR tszName)
{
	return CreateViaLoadImage(hInst, tszName, IMAGE_BITMAP, 0, 0,
		LR_CREATEDIBSECTION | LR_DEFAULTSIZE);
}

CBitmap *CBitmap::CreateFromFile(LPCTSTR tszFileName)
{
	return CreateViaD3DX(tszFileName);
}

// Use D3DX API to load our surface with image content.
CBitmap *CBitmap::CreateViaD3DX(LPCTSTR tszFileName, LPDIRECT3DSURFACE8 pUISurf)
{
	HRESULT hr;
	LPDIRECT3D8 pD3D = NULL;
	LPDIRECT3DDEVICE8 pD3DDev = NULL;
	LPDIRECT3DTEXTURE8 pTex = NULL;
	LPDIRECT3DSURFACE8 pSurf = NULL;
	HBITMAP hDIB = NULL;

	__try
	{
//@@BEGIN_MSINTERNAL
		pSurf = GetCloneSurface(512, 512); /*
//@@END_MSINTERNAL

		// If the UI surface is NULL, create a new device.  Otherwise, use existing device.
		if (!pUISurf)
		{
			pD3D = Direct3DCreate8(D3D_SDK_VERSION);
			if (!pD3D)
				return NULL;
			OutputDebugString(_T("D3D created\n"));
			D3DDISPLAYMODE Mode;
			pD3D->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &Mode);
			D3DPRESENT_PARAMETERS d3dpp;
			d3dpp.BackBufferWidth = 1;
			d3dpp.BackBufferHeight = 1;
			d3dpp.BackBufferFormat = Mode.Format;
			d3dpp.BackBufferCount = 1;
			d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;
			d3dpp.SwapEffect = D3DSWAPEFFECT_COPY;
			d3dpp.hDeviceWindow = NULL;
			d3dpp.Windowed = TRUE;
			d3dpp.EnableAutoDepthStencil = FALSE;
			d3dpp.FullScreen_RefreshRateInHz = 0;
			d3dpp.FullScreen_PresentationInterval = 0;
			d3dpp.Flags = 0;
			hr = pD3D->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_REF, GetActiveWindow(), D3DCREATE_SOFTWARE_VERTEXPROCESSING, &d3dpp, &pD3DDev);
			if (FAILED(hr))
			{
            	TCHAR tszMsg[MAX_PATH];

				_stprintf(tszMsg, _T("CreateDevice returned 0x%X\n"), hr);
				OutputDebugString(tszMsg);
				return NULL;
			}
		} else
		{
			hr = pUISurf->GetDevice(&pD3DDev);
			if (FAILED(hr))
				return NULL;
		}

		OutputDebugString(_T("D3D device createed\n"));
		hr = pD3DDev->CreateTexture(512, 512, 0, 0, D3DFMT_A8R8G8B8, D3DPOOL_SYSTEMMEM, &pTex);
		if (FAILED(hr))
			return NULL;
		OutputDebugString(_T("D3D texture createed\n"));
		hr = pTex->GetSurfaceLevel(0, &pSurf);
		if (FAILED(hr))
			return NULL;
		OutputDebugString(_T("Surface interface obtained\n"));

//@@BEGIN_MSINTERNAL
	*/
//@@END_MSINTERNAL
		D3DXIMAGE_INFO d3dii;
		if (FAILED(D3DXLoadSurfaceFromFile(pSurf, NULL, NULL, tszFileName, NULL, D3DX_FILTER_NONE, 0, &d3dii)))
			return NULL;

		// Create a bitmap and copy the texture content onto it.
		int iDibWidth = d3dii.Width, iDibHeight = d3dii.Height;
		if (iDibWidth > 430) iDibWidth = 430;
		if (iDibHeight > 310) iDibHeight = 310;
		LPBYTE pDIBBits;
		BITMAPINFO bmi;
		bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
		bmi.bmiHeader.biWidth = iDibWidth;
		bmi.bmiHeader.biHeight = iDibHeight;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biCompression = BI_RGB;
		bmi.bmiHeader.biSizeImage = 0;
		bmi.bmiHeader.biXPelsPerMeter = 0;
		bmi.bmiHeader.biYPelsPerMeter = 0;
		bmi.bmiHeader.biClrUsed = 0;
		bmi.bmiHeader.biClrImportant = 0;
		hDIB = CreateDIBSection(NULL, &bmi, DIB_RGB_COLORS, (LPVOID*)&pDIBBits, NULL, 0);
		if (!hDIB)
			return NULL;

		// Pre-process the pixel data based on alpha for AlphaBlend()
		D3DLOCKED_RECT lrc;
		pSurf->LockRect(&lrc, NULL, NULL);
		BYTE *pbData = (LPBYTE)lrc.pBits;
		{
			for (DWORD i = 0; i < 512 * 512; ++i)
			{
				BYTE bAlpha = pbData[i * 4 + 3];
				pbData[i * 4] = pbData[i * 4] * bAlpha / 255;
				pbData[i * 4 + 1] = pbData[i * 4 + 1] * bAlpha / 255;
				pbData[i * 4 + 2] = pbData[i * 4 + 2] * bAlpha / 255;
			}
		}
		pSurf->UnlockRect();

		// Lock the surface
		D3DLOCKED_RECT D3DRect;
		hr = pSurf->LockRect(&D3DRect, NULL, 0);
		if (FAILED(hr))
			return NULL;

		// Copy the bits
		// Note that the image is reversed in Y direction, so we need to re-reverse it.
		for (int y = 0; y < iDibHeight; ++y)
			CopyMemory(pDIBBits + ((iDibHeight-1-y) * iDibWidth * 4), (LPBYTE)D3DRect.pBits + (y * D3DRect.Pitch), iDibWidth * 4);

		// Unlock
		pSurf->UnlockRect();

		CBitmap *pbm = new CBitmap;
		if (!pbm) return NULL;
		pbm->m_hbm = hDIB;
		hDIB = NULL;
		pbm->FigureSize();

		return pbm;
	}
	__finally
	{
		if (hDIB) DeleteObject(hDIB);
		if (pSurf) pSurf->Release();
		if (pTex) pTex->Release();
		if (pD3DDev) pD3DDev->Release();
		if (pD3D) pD3D->Release();
	}
//@@BEGIN_MSINTERNAL
	/*
//@@END_MSINTERNAL
	return NULL;
//@@BEGIN_MSINTERNAL
	*/
//@@END_MSINTERNAL
}

CBitmap *CBitmap::CreateViaLoadImage(HINSTANCE hInst, LPCTSTR tszName, UINT uType, int cx, int cy, UINT fuLoad)
{
	if (fuLoad & LR_SHARED)
	{
		assert(0);
		return NULL;
	}

	CBitmap *pbm = new CBitmap;
	if (pbm == NULL)
		return NULL;
	
	HANDLE handle = ::LoadImage(hInst, tszName, uType, cx, cy, fuLoad);
	
	if (handle == NULL)
	{
		delete pbm;
		return NULL;
	}

	pbm->m_hbm = (HBITMAP)handle;

	pbm->FigureSize();

	return pbm;
}

BOOL CBitmap::FigureSize()
{
	BITMAP bm;

	if (0 == GetObject((HGDIOBJ)m_hbm, sizeof(BITMAP), (LPVOID)&bm))
		return FALSE;

	m_size.cx = abs(bm.bmWidth);
	m_size.cy = abs(bm.bmHeight);

	return m_bSizeKnown = TRUE;
}

CBitmap *CBitmap::StealToCreate(HBITMAP &refbm)
{
	if (refbm == NULL)
		return NULL;

	CBitmap *pbm = new CBitmap;
	if (pbm == NULL)
		return NULL;
	
	pbm->m_hbm = refbm;
	refbm = NULL;

	pbm->FigureSize();

	return pbm;
}

BOOL CBitmap::GetSize(SIZE *psize)
{
	if (m_hbm == NULL || !m_bSizeKnown || psize == NULL)
		return FALSE;

	*psize = m_size;
	return TRUE;
}

void CBitmap::AssumeSize(SIZE size)
{
	m_size = size;
	m_bSizeKnown = TRUE;  //m_hbm != NULL;
}

CBitmap *CBitmap::CreateResizedTo(SIZE size, HDC hDC, int iStretchMode, BOOL bStretch)
{
	CBitmap *pbm = new CBitmap;
	HDC hSrcDC = NULL;
	HDC hDestDC = NULL;
	HBITMAP hBitmap = NULL;
	HGDIOBJ hOldSrcBitmap = NULL, hOldDestBitmap = NULL;
	BOOL bRet = FALSE;
	int oldsm = 0;
	POINT brushorg;

	if (pbm == NULL || size.cx < 1 || size.cy < 1 || m_hbm == NULL || !m_bSizeKnown)
		goto error;

	hSrcDC = CreateAppropDC(hDC);
	hDestDC = CreateAppropDC(hDC);
	if (hSrcDC == NULL || hDestDC == NULL)
		goto error;

	hBitmap = CreateAppropBitmap(hDC, size.cx, size.cy);
	if (hBitmap == NULL)
		goto error;

	if (bStretch)
	{
		if (GetStretchBltMode(hDestDC) != iStretchMode)
		{
			if (iStretchMode == HALFTONE)
				GetBrushOrgEx(hDestDC, &brushorg);
			oldsm = SetStretchBltMode(hDestDC, iStretchMode);
			if (iStretchMode == HALFTONE)
				SetBrushOrgEx(hDestDC, brushorg.x, brushorg.y, NULL);
		}
	}

	hOldSrcBitmap = SelectObject(hSrcDC, m_hbm);
	hOldDestBitmap = SelectObject(hDestDC, hBitmap);
	if (bStretch)
		bRet = StretchBlt(hDestDC, 0, 0, size.cx, size.cy, hSrcDC, 0, 0, m_size.cx, m_size.cy, SRCCOPY);
	else
		bRet = BitBlt(hDestDC, 0, 0, size.cx, size.cy, hSrcDC, 0, 0, SRCCOPY);
	SelectObject(hDestDC, hOldDestBitmap);
	SelectObject(hSrcDC, hOldSrcBitmap);

	if (bStretch)
	{
		if (oldsm != 0)
		{
			if (oldsm == HALFTONE)
				GetBrushOrgEx(hDestDC, &brushorg);
			SetStretchBltMode(hDestDC, oldsm);
			if (oldsm == HALFTONE)
				SetBrushOrgEx(hDestDC, brushorg.x, brushorg.y, NULL);
		}
	}

	if (!bRet)
		goto error;

	pbm->m_hbm = hBitmap;
	hBitmap = NULL;
	pbm->AssumeSize(size);

	goto cleanup;
error:
	if (pbm != NULL)
		delete pbm;
	pbm = NULL;
cleanup:
	if (hBitmap != NULL)
		DeleteObject(hBitmap);
	if (hSrcDC != NULL)
		DeleteDC(hSrcDC);
	if (hDestDC != NULL)
		DeleteDC(hDestDC);

	return pbm;
}

HDC CBitmap::BeginPaintInto(HDC hCDC)
{
	if (m_hDCInto != NULL)
	{
		assert(0);
		return NULL;
	}

	m_hDCInto = CreateAppropDC(hCDC);
	if (m_hDCInto == NULL)
		return NULL;

	m_hOldBitmap = SelectObject(m_hDCInto, m_hbm);

	return m_hDCInto;
}

void CBitmap::EndPaintInto(HDC &hDC)
{
	if (hDC == NULL || hDC != m_hDCInto)
	{
		assert(0);
		return;
	}

	SelectObject(m_hDCInto, m_hOldBitmap);
	DeleteDC(m_hDCInto);
	m_hDCInto = NULL;
	hDC = NULL;
}

void CBitmap::PopOut()
{
	if (m_hDCInto == NULL)
	{
		assert(0);
		return;
	}

	SelectObject(m_hDCInto, m_hOldBitmap);
}

void CBitmap::PopIn()
{
	if (m_hDCInto == NULL)
	{
		assert(0);
		return;
	}

	m_hOldBitmap = SelectObject(m_hDCInto, m_hbm);
}

BOOL CBitmap::Draw(HDC hDC, POINT origin, SIZE crop, BOOL bAll)
{
	if (hDC == NULL || m_hbm == NULL)
		return FALSE;

	if (bAll && !m_bSizeKnown)
		return FALSE;

	if (bAll)
		crop = m_size;

	HDC hDCbm = CreateAppropDC(hDC);
	if (hDCbm == NULL)
		return FALSE;

	BOOL bPop = m_hDCInto != NULL;

	if (bPop)
		PopOut();

	HGDIOBJ hOldBitmap = SelectObject(hDCbm, m_hbm);
	BOOL bRet = BitBlt(hDC, origin.x, origin.y, crop.cx, crop.cy, hDCbm, 0, 0, SRCCOPY);
	SelectObject(hDCbm, hOldBitmap);
	DeleteDC(hDCbm);

	if (bPop)
		PopIn();

	return bRet;
}

BOOL CBitmap::Blend(HDC hDC, POINT origin, SIZE crop, BOOL bAll)
{
	if (hDC == NULL || m_hbm == NULL)
		return FALSE;

	if (bAll && !m_bSizeKnown)
		return FALSE;

	if (bAll)
		crop = m_size;

	HDC hDCbm = CreateAppropDC(hDC);
	if (hDCbm == NULL)
		return FALSE;

	BOOL bPop = m_hDCInto != NULL;

	if (bPop)
		PopOut();

#ifndef AC_SRC_ALPHA
#define AC_SRC_ALPHA AC_SRC_NO_PREMULT_ALPHA
#endif

	HGDIOBJ hOldBitmap = SelectObject(hDCbm, m_hbm);
	BOOL bRet;

//@@BEGIN_MSINTERNAL
/*	if (!g_AlphaBlend) // If AlphaBlend is not available, use BitBlt instead.
	{
		bRet = BitBlt(hDC, origin.x, origin.y, crop.cx, crop.cy, hDCbm, 0, 0, SRCPAINT);
	}
	else
	{
		BLENDFUNCTION blendfn = {AC_SRC_OVER, 0, 255, AC_SRC_ALPHA};
		bRet = g_AlphaBlend(hDC, origin.x, origin.y, crop.cx, crop.cy, hDCbm, 0, 0, m_size.cx, m_size.cy, blendfn);
	}*/
//@@END_MSINTERNAL
	bRet = DI_AlphaBlend(hDC, origin.x, origin.y, crop.cx, crop.cy, hDCbm, 0, 0, m_size.cx, m_size.cy);
	SelectObject(hDCbm, hOldBitmap);
	DeleteDC(hDCbm);

	if (bPop)
		PopIn();

	return bRet;
}

CBitmap *CBitmap::Dup()
{	
	SIZE t;
	if (!GetSize(&t))
		return NULL;
	return CreateResizedTo(t, NULL, COLORONCOLOR, FALSE);
}

CBitmap *CBitmap::Create(SIZE size, HDC hCDC)
{
	CBitmap *pbm = new CBitmap;
	if (pbm == NULL)
		return NULL;

	pbm->m_hbm = CreateAppropBitmap(hCDC, size.cx, size.cy);
	if (pbm->m_hbm == NULL)
	{
		delete pbm;
		return NULL;
	}

	pbm->AssumeSize(size);

	return pbm;
}

CBitmap *CBitmap::Create(SIZE size, COLORREF color, HDC hCDC)
{
	CBitmap *pbm = Create(size, hCDC);
	if (pbm == NULL)
		return NULL;

	HDC hDC = pbm->BeginPaintInto();
	if (hDC == NULL)
	{
		delete pbm;
		return NULL;
	}
	
	HGDIOBJ hBrush = (HGDIOBJ)CreateSolidBrush(color), hOldBrush;

	if (hBrush)
	{
		hOldBrush = SelectObject(hDC, hBrush);
		Rectangle(hDC, -1, -1, size.cx + 1, size.cy + 1);
		SelectObject(hDC, hOldBrush);
		DeleteObject(hBrush);
	}

	pbm->EndPaintInto(hDC);

	return pbm;
}

BOOL CBitmap::Get(HDC hDC, POINT point)
{
	if (!m_bSizeKnown)
		return FALSE;
	return Get(hDC, point, m_size);
}

BOOL CBitmap::Get(HDC hDC, POINT point, SIZE size)
{
	if (m_hDCInto != NULL || hDC == NULL)
		return FALSE;

	HDC hDCInto = BeginPaintInto(hDC);
	if (hDCInto == NULL)
		return FALSE;

	BOOL bRet = BitBlt(hDCInto, 0, 0, size.cx, size.cy, hDC, point.x, point.y, SRCCOPY);
	
	EndPaintInto(hDCInto);

	return bRet;
}

CBitmap *CBitmap::CreateHorzGradient(const RECT &rect, COLORREF rgbLeft, COLORREF rgbRight)
{
	SIZE size = GetRectSize(rect);
	COLORREF rgbMid = RGB(
		(int(GetRValue(rgbLeft)) + int(GetRValue(rgbRight))) / 2,
		(int(GetGValue(rgbLeft)) + int(GetGValue(rgbRight))) / 2,
		(int(GetBValue(rgbLeft)) + int(GetBValue(rgbRight))) / 2);
	return Create(size, rgbMid);
}

BOOL CBitmap::MapToDC(HDC hDCTo, HDC hDCMapFrom)
{
	if (hDCTo == NULL || !m_bSizeKnown || m_hDCInto != NULL)
		return FALSE;

	HBITMAP hbm = CreateAppropBitmap(hDCTo, m_size.cx, m_size.cy);
	if (hbm == NULL)
		return FALSE;

	HDC hDCFrom = NULL;
	HDC hDCInto = NULL;
	HGDIOBJ hOld = NULL;
	BOOL bRet = FALSE;

	hDCFrom = BeginPaintInto(hDCMapFrom);
	if (!hDCFrom)
		goto cleanup;

	hDCInto = CreateCompatibleDC(hDCTo);
	if (!hDCInto)
		goto cleanup;

	hOld = SelectObject(hDCInto, (HGDIOBJ)hbm);
	bRet = BitBlt(hDCInto, 0, 0, m_size.cx, m_size.cy, hDCFrom, 0, 0, SRCCOPY);
	SelectObject(hDCInto, hOld);

cleanup:
	if (hDCFrom)
		EndPaintInto(hDCFrom);
	if (hDCInto)
		DeleteDC(hDCInto);
	if (bRet)
	{
		if (m_hbm)
			DeleteObject((HGDIOBJ)m_hbm);
		m_hbm = hbm;
		hbm = NULL;
	}
	if (hbm)
		DeleteObject((HGDIOBJ)hbm);

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\bidirlookup.h ===
//-----------------------------------------------------------------------------
// File: bidirlookup.h
//
// Desc: This file implements a bi-directional map class template.  It does
//       this by using two CMap classes that each handles the look up in one
//       direction.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __BIDIRLOOKUP_H__
#define __BIDIRLOOKUP_H__


#ifndef NULL
#define NULL 0
#endif


template <class L, class R>
class bidirlookup
{
private:
	
	CMap<L, const L &, R, const R &> l2r;
	CMap<R, const R &, L, const L &> r2l;

	bool addnode(const L &l, const R &r)
	{
		l2r.SetAt(l, r);
		r2l.SetAt(r, l);
		return true;
	}

public:
	void clear()
	{
		l2r.RemoveAll();
		r2l.RemoveAll();
	}

	bidirlookup() {}
	~bidirlookup() {clear();}

	bool add(const L &l, const R &r)
	{
		L tl;
		R tr;

		if (l2r.Lookup(l, tr) || r2l.Lookup(r, tl))
			return false;
		
		return addnode(l, r);
	}

	bool getleft(L &l, const R &r)
	{
		return r2l.Lookup(r, l) ? true : false;
	}

	bool getright(const L &l, R &r)
	{
		return l2r.Lookup(l, r) ? true : false;
	}
};


#if 0

template <class L, class R>
class bidirlookup
{
private:
	struct node {
		node(const L &a, const R &b) : l(a), r(b), next(NULL) {}
		node *next;
		L l;
		R r;
	} *head;

	bool addnode(const L &l, const R &r)
	{
		node *old = head;
		head = new node(l, r);
		if (!head)
			return false;
		head->next = old;
		return true;
	}

	node *getleftnode(const L &l)
	{
		for (node *on = head; on; on = on->next)
			if (on->l == l)
				return on;
		return NULL;
	}

	node *getrightnode(const R &r)
	{
		for (node *on = head; on; on = on->next)
			if (on->r == r)
				return on;
		return NULL;
	}

public:
	void clear()
	{
		while (head)
		{
			node *next = head->next;
			delete head;
			head = next;
		}
	}

	bidirlookup() : head(NULL) {}
	~bidirlookup() {clear();}

	bool add(const L &l, const R &r)
	{
		if (getleftnode(l) || getrightnode(r))
			return false;
		
		return addnode(l, r);
	}

	bool getleft(L &l, const R &r)
	{
		node *n = getrightnode(r);
		if (!n)
			return false;

		l = n->l;

		return true;
	}

	bool getright(const L &l, R &r)
	{
		node *n = getleftnode(l);
		if (!n)
			return false;

		r = n->r;

		return true;
	}
};

#endif


#endif //__BIDIRLOOKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cdevicecontrol.h ===
//-----------------------------------------------------------------------------
// File: cdevicecontrol.h
//
// Desc: CDeviceControl is a class that encapsulate the functionality of a
//       device control (or a callout).  CDeviceView accesses it to retrieve/
//       save information about the control.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifdef FORWARD_DECLS


	struct DEVICECONTROLSTRUCT;
	enum DEVCTRLHITRESULT;

	class CDeviceControl;


#else // FORWARD_DECLS

#ifndef __CDEVICECONTROL_H__
#define __CDEVICECONTROL_H__


const int MAX_DEVICECONTROL_LINEPOINTS = 5;

#define CAF_LEFT 1
#define CAF_RIGHT 2
#define CAF_TOP 4
#define CAF_BOTTOM 8

#define CAF_TOPLEFT (CAF_TOP | CAF_LEFT)
#define CAF_TOPRIGHT (CAF_TOP | CAF_RIGHT)
#define CAF_BOTTOMLEFT (CAF_BOTTOM | CAF_LEFT)
#define CAF_BOTTOMRIGHT (CAF_BOTTOM | CAF_RIGHT)

struct DEVICECONTROLSTRUCT {
	DEVICECONTROLSTRUCT() : nLinePoints(0) {CopyStr(wszOverlayPath, "", MAX_PATH); SRECT r; rectOverlay = r.r;}
	DWORD dwDeviceControlOffset;
	int nLinePoints;
	POINT rgptLinePoint[MAX_DEVICECONTROL_LINEPOINTS];
	DWORD dwCalloutAlign;
	RECT rectCalloutMax;
	WCHAR wszOverlayPath[MAX_PATH];
	RECT rectOverlay;
};

enum DEVCTRLHITRESULT {
	DCHT_LINE,
	DCHT_CAPTION,
	DCHT_MAXRECT,
	DCHT_CONTROL,
	DCHT_NOHIT
};


class CDeviceControl
{
private:
	friend class CDeviceView; 	// CDeviceView has exclusive right to create/destroy views
	CDeviceControl(CDeviceUI &ui, CDeviceView &view);
	~CDeviceControl();
	CDeviceView &m_view;
	CDeviceUI &m_ui;

public:
	// Info
	int GetViewIndex() { return m_view.GetViewIndex(); }
	int GetControlIndex();

	// state information
	void SetCaption(LPCTSTR tszCaption, BOOL bFixed = FALSE);
	LPCTSTR GetCaption();
	BOOL IsFixed() { return m_bFixed; }
	void Unhighlight() {Highlight(FALSE);}
	void Highlight(BOOL bHighlight = TRUE);
	BOOL IsHighlighted() {return m_bHighlight;}
	void GetInfo(GUID &rGuid, DWORD &rdwOffset);
	DWORD GetOffset();
	BOOL IsOffsetAssigned();
	BOOL HasAction() { return lstrcmp(m_ptszCaption, g_tszUnassignedControlCaption); }
	void FillImageInfo(DIDEVICEIMAGEINFOW *pImgInfo);  // This fills the structure info about this control
	BOOL IsMapped();
	int GetMinX() {return m_rectCallout.left;}
	int GetMaxX() {return m_rectCallout.right;}
	int GetMinY() {return m_rectCallout.top;}
	int GetMaxY() {return m_rectCallout.bottom;}
	const RECT &GetCalloutMaxRect() const { return m_rectCalloutMax; }

	// hit testing (in coord's relative to view's origin)
	DEVCTRLHITRESULT HitTest(POINT test);

	// simple notification
	void OnMouseOver(POINT point);
	void OnClick(POINT point, BOOL bLeft, BOOL bDoubleClick = FALSE);
	void OnPaint(HDC hDC);

	// redrawing
	void Invalidate();

	// editing
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	void ReselectControl();
	void SelectControl(BOOL bReselect = FALSE);
#endif
//@@END_MSINTERNAL
	void PlaceCalloutMaxCorner(int nCorner, POINT point);
	void ConsiderAlignment(POINT point);
	void FinalizeAlignment() { }
	void SetLastLinePoint(int nPoint, POINT point, BOOL bShiftDown);
	void Position(POINT point);
	BOOL ReachedMaxLinePoints() { return m_nLinePoints >= MAX_DEVICECONTROL_LINEPOINTS; }
	int GetNextLinePointIndex() { return m_nLinePoints; }
	BOOL HasOverlay() { return m_pbmOverlay != NULL; }
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	void SelectOverlay();
	void PositionOverlay(POINT point);
#endif
//@@END_MSINTERNAL

	// population
	void SetObjID(DWORD dwObjID) { m_dwDeviceControlOffset = dwObjID; m_bOffsetAssigned = TRUE; }
	void SetLinePoints(int n, POINT *rgpt);
	void SetCalloutMaxRect(const RECT &r) { m_rectCalloutMax = r; CalcCallout(); }
	void SetAlignment(DWORD a) { m_dwCalloutAlign = a; }
	void SetOverlayPath(LPCTSTR tszPath);
	void SetOverlayRect(const RECT &r);
	void Init();

private:
	// editing vars/helpers
	POINT m_ptFirstCorner;
	BOOL m_bPlacedOnlyFirstCorner;

	// helpers
	void Unpopulate();
	BOOL m_bInit;
	BOOL m_bFixed;  // Whether this control is assigned an action with DIA_APPFIXED flag.
	DEVICEUINOTIFY m_uin;
	BOOL HitControl(POINT point);
	BOOL DrawOverlay(HDC hDC);
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	void ManualLoadImage(LPCTSTR);
#endif
//@@END_MSINTERNAL

	// device information
	DWORD m_dwDeviceControlOffset;
	BOOL m_bOffsetAssigned;

	// location/indication/visualization...
	// (all relative to view's origin)

	// overlay
	LPTSTR m_ptszOverlayPath;
	CBitmap *m_pbmOverlay;
	CBitmap *m_pbmHitMask;
	POINT m_ptOverlay;
	POINT m_ptHitMask;

	// caption (allocated and stored here)
	LPTSTR m_ptszCaption;
	BOOL m_bCaptionClipped;  // Whether the caption is clipped when drawn by DrawTextEx.

	// coloring
	BOOL m_bHighlight;

	// line points...  first connects to callout, last points to control
	int m_nLinePoints;
	POINT m_rgptLinePoint[MAX_DEVICECONTROL_LINEPOINTS];

	// callout specs
	DWORD m_dwCalloutAlign;	// where the line emerges from the callout
	RECT m_rectCallout, m_rectCalloutMax;	// current callout rect, and max rect

	// gdi
	DWORD m_dwDrawTextFlags;
	int m_FontHeight;
	void PrepFont();
	BOOL PrepCaption();
	void PrepLinePoints();
	void CalcCallout();
	void PrepCallout();
	BOOL m_bCalledCalcCallout;

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	HRESULT ExportCodeTo(FILE *);
#endif
//@@END_MSINTERNAL
};


#endif //__CDEVICECONTROL_H__

#endif // FORWARD_DECLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cd3dsurf.cpp ===
#include "common.hpp"
#include "id3dsurf.h"

class CDirect3DSurface8: public IDirect3DSurface8Clone
{
public:
	CDirect3DSurface8();
	~CDirect3DSurface8();
/*	ULONG AddRef();
	HRESULT QueryInterface(REFIID iid, void **ppvObject);
	ULONG Release();*/

	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID  riid, 
														 VOID  **ppvObj);
	STDMETHOD_(ULONG,AddRef) ();
	STDMETHOD_(ULONG,Release) ();

	// IBuffer methods
	STDMETHOD(SetPrivateData)(REFGUID riid, 
														CONST VOID   *pvData, 
														DWORD   cbData, 
														DWORD   dwFlags);

	STDMETHOD(GetPrivateData)(REFGUID riid, 
														VOID   *pvData, 
														DWORD  *pcbData);

	STDMETHOD(FreePrivateData)(REFGUID riid);

	STDMETHOD(GetContainer)(REFIID riid, 
													void **ppContainer);

	STDMETHOD(GetDevice)(IDirect3DDevice8 **ppDevice);

	// IDirect3DSurface8 methods
	STDMETHOD_(D3DSURFACE_DESC, GetDesc)();

	STDMETHOD(LockRect)(D3DLOCKED_RECT  *pLockedRectData, 
											CONST RECT      *pRect, 
											DWORD            dwFlags);

	STDMETHOD(UnlockRect)();

	BOOL Create(int iWidth, int iHeight);

/*	HRESULT GetDevice(IDirect3DDevice8** ppDevice);
	HRESULT SetPrivateData(REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags);
	HRESULT GetPrivateData(REFGUID refguid, void* pData, DWORD* pSizeOfData);
	HRESULT FreePrivateData(REFGUID refguid);
	HRESULT GetContainer(REFIID riid, void** ppContainer);

	D3DSURFACE_DESC GetDesc();
	HRESULT LockRect(D3DLOCKED_RECT* pLockedRect, CONST RECT* pRect, DWORD Flags);
	HRESULT UnlockRect();*/

private:
	int m_iRefCount;
	BYTE *m_pData;
	D3DSURFACE_DESC m_Desc;
};

CDirect3DSurface8::CDirect3DSurface8() : m_pData(NULL), m_iRefCount(1)
{
}

CDirect3DSurface8::~CDirect3DSurface8()
{
	delete[] m_pData;
}

BOOL CDirect3DSurface8::Create(int iWidth, int iHeight)
{
	m_pData = new BYTE[iWidth * iHeight * 4];
	if (!m_pData) return FALSE;

	m_Desc.Format = D3DFMT_A8R8G8B8;
	m_Desc.Type = D3DRTYPE_SURFACE;
	m_Desc.Usage = 0;
	m_Desc.Pool = D3DPOOL_SYSTEMMEM;
	m_Desc.Size = iWidth * iHeight * 4;
	m_Desc.MultiSampleType = D3DMULTISAMPLE_NONE;
	m_Desc.Width = iWidth;
	m_Desc.Height = iHeight;
	return TRUE;
}

STDMETHODIMP_(ULONG) CDirect3DSurface8::AddRef()
{
	return ++m_iRefCount;
}

STDMETHODIMP CDirect3DSurface8::QueryInterface(REFIID iid, void **ppvObject)
{
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDirect3DSurface8::Release()
{
	if (!--m_iRefCount)
	{
		delete this;
		return 0;
	}
	return m_iRefCount;
}

/////////// Dummy implementations ///////////////

STDMETHODIMP CDirect3DSurface8::SetPrivateData(REFGUID riid, CONST VOID *pvData, DWORD cbData, DWORD dwFlags)
{
	return S_OK;
}

STDMETHODIMP CDirect3DSurface8::GetPrivateData(REFGUID riid, VOID *pvData, DWORD *pcbData)
{
	return S_OK;
}

STDMETHODIMP CDirect3DSurface8::FreePrivateData(REFGUID riid)
{
	return S_OK;
}

STDMETHODIMP CDirect3DSurface8::GetContainer(REFIID riid, void **ppContainer)
{
	return S_OK;
}

STDMETHODIMP CDirect3DSurface8::GetDevice(IDirect3DDevice8 **ppDevice)
{
	return S_OK;
}

// Required implementation

STDMETHODIMP_(D3DSURFACE_DESC) CDirect3DSurface8::GetDesc()
{
	return m_Desc;
}

// Assume the entire surface is being locked.
STDMETHODIMP CDirect3DSurface8::LockRect(D3DLOCKED_RECT* pLockedRect, CONST RECT* pRect, DWORD Flags)
{
	pLockedRect->Pitch = m_Desc.Width * 4;
	pLockedRect->pBits = m_pData;
	return S_OK;
}

STDMETHODIMP CDirect3DSurface8::UnlockRect()
{
	return S_OK;
}



IDirect3DSurface8 *GetCloneSurface(int iWidth, int iHeight)
{
	CDirect3DSurface8 *pSurf = new CDirect3DSurface8;

	if (!pSurf) return NULL;
	if (!pSurf->Create(iWidth, iHeight))
	{
		delete pSurf;
		return NULL;
	}

	return (IDirect3DSurface8*)pSurf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cdevicecontrol.cpp ===
//-----------------------------------------------------------------------------
// File: cdevicecontrol.cpp
//
// Desc: CDeviceControl is a class that encapsulate the functionality of a
//       device control (or a callout).  CDeviceView accesses it to retrieve/
//       save information about the control.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


CDeviceControl::CDeviceControl(CDeviceUI &ui, CDeviceView &view) :
	m_ui(ui),
	m_view(view),
	m_bHighlight(FALSE),
	m_ptszCaption(NULL),
	m_dwDrawTextFlags(0),
	m_FontHeight(-1),
	m_bCalledCalcCallout(FALSE),
	m_bPlacedOnlyFirstCorner(FALSE),
	m_bInit(FALSE),
	m_dwCalloutAlign(CAF_TOPLEFT),
	m_nLinePoints(0),
	m_dwDeviceControlOffset((DWORD)-1),
	m_bOffsetAssigned(FALSE),
	m_pbmOverlay(NULL),
	m_pbmHitMask(NULL),
	m_ptszOverlayPath(NULL),
	m_bCaptionClipped(FALSE)
{
}

CDeviceControl::~CDeviceControl()
{
	DEVICEUINOTIFY uin;
	uin.from = DEVUINFROM_CONTROL;
	uin.control.pControl = (CDeviceControl *)this;
	uin.msg = DEVUINM_ONCONTROLDESTROY;
	m_ui.Notify(uin);
	if (m_ptszCaption)
		free(m_ptszCaption);
	delete m_pbmOverlay;
	delete m_ptszOverlayPath;
}

void CDeviceControl::SetCaption(LPCTSTR tszCaption, BOOL bFixed)
{
	LPTSTR tszNewCaption = NULL;

	m_bFixed = bFixed;

	if (tszCaption != NULL)
	{
		tszNewCaption = _tcsdup(tszCaption);

		if (tszNewCaption == NULL)
			return;
	}

	free(m_ptszCaption);
	m_ptszCaption = tszNewCaption;
	tszNewCaption = NULL;

	CalcCallout();
	Invalidate();
}

LPCTSTR CDeviceControl::GetCaption()
{
	return (LPCTSTR)m_ptszCaption;
}

BOOL CDeviceControl::HitControl(POINT point)
{
	return FALSE;
}

DEVCTRLHITRESULT CDeviceControl::HitTest(POINT test)
{
	if (!m_bInit)
		return DCHT_NOHIT;

	if (m_ui.InEditMode() &&
			PtInRect(&m_rectCalloutMax, test))
		return DCHT_MAXRECT;

	PrepCallout();

	if (PtInRect(&m_rectCallout, test))
		return DCHT_CAPTION;

	if (HitControl(test))
		return DCHT_CONTROL;

	return DCHT_NOHIT;
}

void CDeviceControl::Init()
{
	m_uin.from = DEVUINFROM_CONTROL;
	m_uin.control.pControl = this;

	CalcCallout();

	m_bInit = TRUE;
}

// We will have to know the view's scrolling offset to adjust the tooltip's position.
void CDeviceControl::OnMouseOver(POINT point)
{
	// Tooltip only if the callout text is clipped.
	if (m_bCaptionClipped)
	{
		TOOLTIPINITPARAM ttip;
		ttip.hWndParent = GetParent(m_view.m_hWnd);  // Parent is the page window.
		ttip.iSBWidth = 0;
		ttip.dwID = m_dwDeviceControlOffset;
		ttip.hWndNotify = m_view.m_hWnd;
		ttip.tszCaption = GetCaption();
		CFlexToolTip::UpdateToolTipParam(ttip);
	} else
		CFlexWnd::s_ToolTip.SetToolTipParent(NULL);

	m_uin.msg = DEVUINM_MOUSEOVER;
	m_ui.Notify(m_uin);
}

void CDeviceControl::OnClick(POINT point, BOOL bLeft, BOOL bDoubleClick)
{
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	if (!bLeft && m_ui.InEditMode())
	{
		// If right click in edit mode, pop up the edit menu.
		m_view.EditMenu(point, this);
		return;
	}
#endif
//@@END_MSINTERNAL

	// If this control is not assigned, and we are in view mode, we should not do anything (highlight).
	if (!lstrcmp(m_ptszCaption, g_tszUnassignedControlCaption) && !m_ui.m_uig.InEditMode())
		return;

	m_uin.msg = bDoubleClick ? DEVUINM_DOUBLECLICK : DEVUINM_CLICK;
	m_uin.click.bLeftButton = bLeft;
	m_ui.Notify(m_uin);
}

void CDeviceControl::Unpopulate()
{
}

void CDeviceControl::Highlight(BOOL bHighlight)
{
	if (m_bHighlight == bHighlight)
		return;

	// If the callout text is the default text, no action is assigned, and we don't highlight it.
//@@BEGIN_MSINTERNAL
//  ISSUE-2000/12/21-MarcAnd This breaks highlighting of unassigned controls
//  When you're trying to assign 
//@@END_MSINTERNAL
	if (!lstrcmp(m_ptszCaption, g_tszUnassignedControlCaption) && bHighlight && !m_ui.m_uig.InEditMode())
		return;

	m_bHighlight = bHighlight;

	// If the view has scrolling enabled, we need to adjust the scroll
	// bar position to make this callout visible.
	if (bHighlight)
		m_view.ScrollToMakeControlVisible(m_rectCalloutMax);

	CalcCallout();

	// We do not invalidate rectangle if we are unhighlighting.  Let CDeviceView handle that.
	if (bHighlight) Invalidate();
}

void CDeviceControl::GetInfo(GUID &rGuid, DWORD &rdwOffset)
{
	m_ui.GetDeviceInstanceGuid(rGuid);
	rdwOffset = m_dwDeviceControlOffset;
}

BOOL CDeviceControl::PrepCaption()
{
	if (m_ptszCaption != NULL)
		return TRUE;
	m_ptszCaption = _tcsdup(g_tszUnassignedControlCaption);
	return m_ptszCaption != NULL;
}

void CDeviceControl::PrepLinePoints()
{
	if (m_nLinePoints > 0)
		return;
	m_nLinePoints = 1;
	POINT pt = {0, 0};
	if (m_dwCalloutAlign & CAF_LEFT)
		pt.x = m_rectCalloutMax.left;
	if (m_dwCalloutAlign & CAF_RIGHT)
		pt.x = m_rectCalloutMax.right - 1;
	if (m_dwCalloutAlign & CAF_TOP)
		pt.y = m_rectCalloutMax.top;
	if (m_dwCalloutAlign & CAF_BOTTOM)
		pt.y = m_rectCalloutMax.bottom - 1;
	if (!(m_dwCalloutAlign & (CAF_LEFT | CAF_RIGHT)))
		pt.x = (m_rectCalloutMax.left + m_rectCalloutMax.right - 1) / 2;
	if (!(m_dwCalloutAlign & (CAF_BOTTOM | CAF_TOP)))
		pt.y = (m_rectCalloutMax.top + m_rectCalloutMax.bottom - 1) / 2;
	m_rgptLinePoint[0] = pt;
}

void CDeviceControl::PrepCallout()
{
	if (m_bCalledCalcCallout)
		return;
	CalcCallout();
}

void CDeviceControl::PrepFont()
{
	if (m_FontHeight != -1)
		return;

	HDC hDC = CreateCompatibleDC(NULL);
	if (hDC != NULL)
	{
		RECT rect = {0, 0, 500, 1};
		{
			CPaintHelper ph(m_ui.m_uig, hDC);
			ph.SetFont(UIF_CALLOUT);
			m_FontHeight = DrawText(hDC, _T("Testify"), -1, &rect, m_dwDrawTextFlags);
		}
		DeleteDC(hDC);
	}
}

void CDeviceControl::CalcCallout()
{
	m_bCalledCalcCallout = TRUE;

	RECT max = m_rectCalloutMax;
	InflateRect(&max, -1, -1);
	RECT rect = max;
	rect.bottom = rect.top + 1;

	PrepFont();

	HDC hDC = CreateCompatibleDC(NULL);

	{
		CPaintHelper ph(m_ui.m_uig, hDC);
		ph.SetFont(UIF_CALLOUT);

		// We make sure the max rect height is at least same as the font requires.
		m_dwDrawTextFlags = DT_SINGLELINE | DT_CALCRECT | DT_NOPREFIX | DT_END_ELLIPSIS | DT_EDITCONTROL;
		RECT hrect = rect;
		DrawText(hDC, m_ptszCaption, -1, &hrect, m_dwDrawTextFlags);
		if (hrect.bottom > max.bottom) max.bottom = hrect.bottom;

		m_dwDrawTextFlags = DT_WORDBREAK | DT_CALCRECT | DT_NOPREFIX | DT_END_ELLIPSIS | DT_EDITCONTROL;

		// first, drawtext/calcrect into the temporary rect
		if (!PrepCaption())
		{
			return;
		}

		int th = DrawText(hDC, m_ptszCaption, -1, &rect, m_dwDrawTextFlags);

		m_bCaptionClipped = rect.bottom > max.bottom || rect.right > max.right;  // Set clipped flag.
		
		BOOL bSingleTextLine = th <= m_FontHeight;

		if (rect.right > max.right)
		{
			bSingleTextLine = TRUE;
			rect.right = max.right;
		}

		if (bSingleTextLine)
			m_dwDrawTextFlags &= ~DT_WORDBREAK;

		m_dwDrawTextFlags &= ~DT_CALCRECT;

		RECT rect2 = rect;
		if (rect2.bottom > max.bottom)
			rect2.bottom = max.bottom;
		th = DrawText(hDC, m_ptszCaption, -1, &rect2, m_dwDrawTextFlags);
		int ith = (th / m_FontHeight) * m_FontHeight;
//@@BEGIN_MSINTERNAL
		//LTRACE(QSAFESTR(m_ptszCaption));
		//LTRACE("  max = %s", RECTDIMSTR(max));
		//LTRACE("!rect = %s", RECTDIMSTR(rect));
//@@END_MSINTERNAL
		rect.bottom = rect.top + ith + 1;
//@@BEGIN_MSINTERNAL
		//LTRACE(" rect = %s", RECTDIMSTR(rect));
		//LTRACE("rect2 = %s", RECTDIMSTR(rect2));
		//LTRACE("th = %d, ith = %d, m_FontHeight = %d", th, ith, m_FontHeight);
//@@END_MSINTERNAL
	}

	DeleteDC(hDC);
	hDC = NULL;

	if (rect.bottom > max.bottom)
		rect.bottom = max.bottom;

	assert(rect.right <= max.right);
	assert(rect.bottom <= max.bottom);

	PrepLinePoints();
	POINT adj = {0, 0};

	assert(rect.left == max.left);
	assert(rect.top == max.top);

	int w = rect.right - rect.left;
	int h = rect.bottom - rect.top;
	int mw = max.right - max.left;
	int mh = max.bottom - max.top;
	int dw = mw - w, dh = mh - h;
	int cx = mw / 2 + max.left, cy = mh / 2 + max.top;
	int cl = cx - w / 2, ct = cy - h / 2;

	assert(dw >= 0);
	assert(dh >= 0);

	if (m_dwCalloutAlign & CAF_RIGHT && rect.right < max.right)
		adj.x = max.right - rect.right;
	if (m_dwCalloutAlign & CAF_BOTTOM && rect.bottom < max.bottom)
		adj.y = max.bottom - rect.bottom;
	if (!(m_dwCalloutAlign & (CAF_RIGHT | CAF_LEFT)) && w < mw && rect.left != cl)
		adj.x = cl - rect.left;
	if (!(m_dwCalloutAlign & (CAF_BOTTOM | CAF_TOP)) && h < mh && rect.top != ct)
		adj.y = ct - rect.top;

	OffsetRect(&rect, adj.x, adj.y);

	InflateRect(&rect, 1, 1);

	m_rectCallout = rect;
}

BOOL CDeviceControl::DrawOverlay(HDC hDC)
{
	if (m_pbmOverlay == NULL)
		return FALSE;

	return m_pbmOverlay->Blend(hDC, m_ptOverlay);
}

void CDeviceControl::OnPaint(HDC hDC)
{
	if (!m_bInit)
		return;

	// If we are in view mode and the callout is not assigned, don't draw anything.
	if (!m_ui.m_uig.InEditMode() && !lstrcmp(m_ptszCaption, g_tszUnassignedControlCaption))
		return;

	PrepCallout();

	CPaintHelper ph(m_ui.m_uig, hDC);
	UIELEMENT eCallout = m_bHighlight ? UIE_CALLOUTHIGH : UIE_CALLOUT;

	// draw lines...
	if (m_nLinePoints > 1)
	{
		ph.SetElement(UIE_CALLOUTSHADOW);
		PolyLineArrowShadow(hDC, m_rgptLinePoint, m_nLinePoints);
		ph.SetElement(eCallout);
		PolyLineArrow(hDC, m_rgptLinePoint, m_nLinePoints);
	}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	// if we're in edit mode, show the callout max rect
	if (m_ui.InEditMode())
	{
		ph.SetElement(UIE_CALLOUTMAX);
		ph.Rectangle(m_rectCalloutMax);
		ph.SetElement(eCallout);
		ph.Rectangle(m_rectCallout);
	}

	// if we're in edit mode, indicate alignment
	if (m_ui.InEditMode())
	{
		ph.SetElement(UIE_CALLOUTALIGN);

		const int &align = m_dwCalloutAlign;
		const RECT &rect = m_rectCalloutMax;

		int vert = align & (CAF_TOP | CAF_BOTTOM);
		int horz = align & (CAF_LEFT | CAF_RIGHT);

		BOOL bHorz = TRUE;
		BOOL bVert = TRUE;
		
		int hsq, hy, heq, vsq, vx, veq, s, e;

		switch (vert)
		{
			case CAF_TOP:
				hy = rect.top;
				vsq = 0;
				veq = 1;
				break;

			case 0:
				bHorz = FALSE;
				vsq = 1;
				veq = 3;
				break;

			case CAF_BOTTOM:
				hy = rect.bottom - 1;
				vsq = 3;
				veq = 4;
				break;
		}
		
		switch (horz)
		{
			case CAF_LEFT:
				vx = rect.left;
				hsq = 0;
				heq = 1;
				break;

			case 0:
				bVert = FALSE;
				hsq = 1;
				heq = 3;
				break;

			case CAF_RIGHT:
				vx = rect.right - 1;
				hsq = 3;
				heq = 4;
				break;
		}
		
		if (bHorz)
		{
			s = ConvertVal(hsq, 0, 4, rect.left, rect.right - 1);
			e = ConvertVal(heq, 0, 4, rect.left, rect.right - 1);
			MoveToEx(hDC, s, hy, NULL);
			LineTo(hDC, e + 1, hy);
		}

		if (bVert)
		{
			s = ConvertVal(vsq, 0, 4, rect.top, rect.bottom - 1);
			e = ConvertVal(veq, 0, 4, rect.top, rect.bottom - 1);
			MoveToEx(hDC, vx, s, NULL);
			LineTo(hDC, vx, e + 1);
		}
	}

#endif
//@@END_MSINTERNAL
	// draw text
	ph.SetElement(eCallout);
	RECT rect = m_rectCallout;
	InflateRect(&rect, -1, -1);

	// If this control is assigned an action with DIA_FIXED (m_bFixed), use gray color for text.
	COLORREF OldColor;
	if (m_bFixed)
	{
		OldColor = ::SetTextColor(hDC, 0);  // Set an arbitrary color to find out what we are currently using.
		::SetTextColor(hDC, RGB(GetRValue(OldColor) >> 1, GetGValue(OldColor) >> 1, GetBValue(OldColor) >> 1));
	}

	if (m_ptszCaption)
		DrawText(hDC, m_ptszCaption, -1, &rect, m_dwDrawTextFlags);

	if (m_bFixed)
		::SetTextColor(hDC, OldColor);
}

void CDeviceControl::Invalidate()
{
	m_view.Invalidate();
}

void MakeRect(RECT &rect, POINT a, POINT b)
{
	rect.left = min(a.x, b.x);
	rect.right = max(a.x, b.x);
	rect.top = min(a.y, b.y);
	rect.bottom = max(a.y, b.y);
}

void CDeviceControl::PlaceCalloutMaxCorner(int nCorner, POINT point)
{
	switch (nCorner)
	{
		case 0:
			m_ptFirstCorner = point;
			m_bPlacedOnlyFirstCorner = TRUE;
			Invalidate();
			break;

		case 1:
			MakeRect(m_rectCalloutMax, m_ptFirstCorner, point);
			m_bPlacedOnlyFirstCorner = FALSE;
			if (!m_bInit)
				Init();
			else
				CalcCallout();
			Invalidate();
			break;

		default:
			assert(0);
			break;
	}
}

void CDeviceControl::SetLastLinePoint(int nPoint, POINT point, BOOL bShiftDown)
{
	if (!(nPoint >= 0 && nPoint < MAX_DEVICECONTROL_LINEPOINTS))
		return;

	// Check for SHIFT key state
	if (nPoint && bShiftDown)  // SHIFT key only makes a difference if we are setting 2nd and subsequent points.
	{
		// SHIFT key down.  Need to draw controlled line.
		if (labs(m_rgptLinePoint[nPoint-1].x - point.x) > labs(m_rgptLinePoint[nPoint-1].y - point.y))
		{
			// Wider. Draw horizontal.
			m_rgptLinePoint[nPoint].x = point.x;
			m_rgptLinePoint[nPoint].y = m_rgptLinePoint[nPoint-1].y;
		} else
		{
			// Taller. Draw vertical
			m_rgptLinePoint[nPoint].x = m_rgptLinePoint[nPoint-1].x;
			m_rgptLinePoint[nPoint].y = point.y;
		}
	} else
		m_rgptLinePoint[nPoint] = point; // SHIFT key not down.  Draw line as usual.
	m_nLinePoints = nPoint + 1;
	Invalidate();

	if (m_nLinePoints < 2)
		return;

	POINT prev = m_rgptLinePoint[m_nLinePoints - 2];

	// remove identical points
	if (point.x == prev.x && point.y == prev.y)
	{
		m_nLinePoints--;
		return;
	}
//@@BEGIN_MSINTERNAL

	// TODO: remove the midpoint of colinear triples
//@@END_MSINTERNAL
}

void PlaceRectCenter(RECT &rect, POINT point)
{
	POINT center = {
		(rect.left + rect.right) / 2,
		(rect.top + rect.bottom) / 2};

	OffsetRect(&rect, point.x - center.x, point.y - center.y);
}

void OffsetRectToWithin(RECT &rect, const RECT &bounds)
{
	POINT adj = {0, 0};

	if (rect.left < bounds.left)
		adj.x = bounds.left - rect.left;
	if (rect.right > bounds.right)
		adj.x = bounds.right - rect.right;
	if (rect.top < bounds.top)
		adj.y = bounds.top - rect.top;
	if (rect.bottom > bounds.bottom)
		adj.y = bounds.bottom - rect.bottom;

	OffsetRect(&rect, adj.x, adj.y);
}

void CDeviceControl::Position(POINT point)
{
	PlaceRectCenter(m_rectCalloutMax, point);
	RECT client;
	m_view.GetClientRect(&client);
	OffsetRectToWithin(m_rectCalloutMax, client);
	CalcCallout();
	Invalidate();
}

void CDeviceControl::ConsiderAlignment(POINT point)
{
	POINT center = {
		(m_rectCalloutMax.right + m_rectCalloutMax.left) / 2,
		(m_rectCalloutMax.bottom + m_rectCalloutMax.top) / 2};
	SIZE dim = {
		m_rectCalloutMax.right - m_rectCalloutMax.left,
		m_rectCalloutMax.bottom - m_rectCalloutMax.top};
	SIZE delta = {point.x - center.x, point.y - center.y};
	int MININ = m_FontHeight;
	SIZE in = {max(dim.cx / 4, MININ), max(dim.cy / 4, MININ)};
	DWORD align = 0;
	if (delta.cx < -in.cx)
		align |= CAF_LEFT;
	if (delta.cx > in.cx)
		align |= CAF_RIGHT;
	if (delta.cy < -in.cy)
		align |= CAF_TOP;
	if (delta.cy > in.cy)
		align |= CAF_BOTTOM;
	m_dwCalloutAlign = align;
	CalcCallout();
	Invalidate();
}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
void CDeviceControl::ReselectControl()
{
	SelectControl(TRUE);
}

void CDeviceControl::SelectControl(BOOL bReselect)
{
	CSelControlDlg dlg(m_view, *this, bReselect, m_dwDeviceControlOffset, m_ui.m_didi);

	switch (dlg.DoModal(m_view.m_hWnd))
	{
		case SCDR_OK:
			m_dwDeviceControlOffset = dlg.GetOffset();
			m_bOffsetAssigned = TRUE;
			Invalidate();
			break;

		case SCDR_CANCEL:
			break;

		case SCDR_NOFREE:
			MessageBox(m_view.m_hWnd, _T("All device controls have been assigned for this view."),
			           _T("Can't reselect control."), MB_OK);
			break;

		case -1:
			MessageBox(m_view.m_hWnd, _T("CSelControlDlg.DoModal() failed."), _T("oops"), MB_OK);
			break;

		default:
			assert(0);
			break;
	}
}

#endif
//@@END_MSINTERNAL
DWORD CDeviceControl::GetOffset()
{
	if (m_bOffsetAssigned)
		return m_dwDeviceControlOffset;

	return (DWORD)-1;
}

BOOL CDeviceControl::IsOffsetAssigned()
{
	return m_bOffsetAssigned;
}

void CDeviceControl::FillImageInfo(DIDEVICEIMAGEINFOW *pImgInfo)
{
	if (!pImgInfo) return;

	if (m_ptszOverlayPath != NULL)
		CopyStr(pImgInfo->tszImagePath, m_ptszOverlayPath, MAX_PATH);
	else
		wcscpy(pImgInfo->tszImagePath, L"");  // Overlay Image not yet supported

	SIZE size = {0, 0};
	if (m_pbmOverlay != NULL)
		m_pbmOverlay->GetSize(&size);
	RECT rect = {m_ptOverlay.x, m_ptOverlay.y,
		m_ptOverlay.x + size.cx, m_ptOverlay.y + size.cy};

	pImgInfo->dwFlags = DIDIFT_OVERLAY;  // This is an overlay
	pImgInfo->rcOverlay = rect;
	pImgInfo->dwObjID = GetOffset();
	pImgInfo->dwcValidPts = m_nLinePoints;
	DWORD dwPtsToCopy = m_nLinePoints > 5 ? 5 : m_nLinePoints;
	for (DWORD i = 0; i < dwPtsToCopy; ++i)
		pImgInfo->rgptCalloutLine[i] = m_rgptLinePoint[i];
	pImgInfo->rcCalloutRect = m_rectCalloutMax;
	pImgInfo->dwTextAlign = m_dwCalloutAlign;
}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
void CDeviceControl::SelectOverlay()
{
	LPCTSTR file = GetOpenFileName(
		g_hModule,
		m_view.m_hWnd,
		_T("Select An Overlay Image for This Control"),
		_T("PNG Files (*.png)\0*.png\0All Files (*.*)\0*.*\0"),
		_T("png"));

	if (file == NULL)
		return;

	ManualLoadImage(file);
}

void CDeviceControl::ManualLoadImage(LPCTSTR tszPath)
{
	if (!tszPath)
		FormattedErrorBox(g_hModule, m_view.m_hWnd, IDS_TITLE_NOLOADVIEWIMAGE, IDS_NULLPATH);

	LPDIRECT3DSURFACE8 pSurf = m_ui.m_uig.GetSurface3D();  // GetSurface3D() calls AddRef() on the surface.
	CBitmap *pbmNewImage = CBitmap::CreateViaD3DX(tszPath, pSurf);
	if (pSurf)
	{
		// Release surface instance after we are done with it so we don't leak memory.
		pSurf->Release();
		pSurf = NULL;
	}
	if (pbmNewImage == NULL)
	{
		FormattedErrorBox(g_hModule, m_view.m_hWnd, IDS_TITLE_NOLOADVIEWIMAGE, IDS_COULDNOTCREATEIMAGEFROMFILE, tszPath);
		return;
	}

	// replace
	delete m_pbmOverlay;
	m_pbmOverlay = pbmNewImage;
	pbmNewImage = NULL;
	if (m_ptszOverlayPath != NULL)
		free(m_ptszOverlayPath);
	m_ptszOverlayPath = _tcsdup(tszPath);

	// redraw
	Invalidate();
}

void CDeviceControl::PositionOverlay(POINT point)
{
	SIZE size = {1, 1};
	RECT rect = {0, 0, size.cx, size.cy};
	PlaceRectCenter(rect, point);
	RECT client;
	m_view.GetClientRect(&client);
	OffsetRectToWithin(rect, client);
	SRECT sr = rect;
	m_ptOverlay = sr.ul;
	Invalidate();
}
#endif
//@@END_MSINTERNAL

BOOL CDeviceControl::IsMapped()
{
	return m_ui.IsControlMapped(this);
}

int CDeviceControl::GetControlIndex()
{
	for (int i = 0; i < m_view.GetNumControls(); i++)
		if (m_view.GetControl(i) == this)
			return i;

	return -1;
}

void CDeviceControl::SetLinePoints(int n, POINT *rgpt)
{
	assert(n >= 0 && n <= MAX_DEVICECONTROL_LINEPOINTS && rgpt);

	if (n < 0)
		n = 0;
	if (n > MAX_DEVICECONTROL_LINEPOINTS)
		n = MAX_DEVICECONTROL_LINEPOINTS;

	if (!rgpt)
		n = 0;

	m_nLinePoints = n;

	for (int i = 0; i < n; i++)
		m_rgptLinePoint[i] = rgpt[i];
}

void CDeviceControl::SetOverlayPath(LPCTSTR tszPath)
{
	if (m_ptszOverlayPath)
		free(m_ptszOverlayPath);
	m_ptszOverlayPath = NULL;

	if (tszPath)
		m_ptszOverlayPath = _tcsdup(tszPath);

	delete m_pbmOverlay;
	m_pbmOverlay = NULL;

	if (m_ptszOverlayPath)
	{
		LPDIRECT3DSURFACE8 pSurf = m_ui.m_uig.GetSurface3D();  // GetSurface3D() calls AddRef() on the surface.
		m_pbmOverlay = CBitmap::CreateViaD3DX(m_ptszOverlayPath, pSurf);
		if (pSurf)
		{
			// Release surface instance after we are done with it so we don't leak memory.
			pSurf->Release();
			pSurf = NULL;
		}
	}
}

void CDeviceControl::SetOverlayRect(const RECT &r)
{
	m_ptOverlay.x = r.left;
	m_ptOverlay.y = r.top;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cdeviceview.cpp ===
//-----------------------------------------------------------------------------
// File: cdeviceview.cpp
//
// Desc: CDeviceView is a window class derived from CFlexWnd.  It represents
//       the device view window in which the device and callouts are drawn.
//       Each CDeviceView only represents one view.  A device that has more
//       than one view should have a corresponding number of CDeviceView for it.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


CDeviceView::CDeviceView(CDeviceUI &ui) :
	m_ui(ui),
	m_pbmImage(NULL),
	m_pbmThumb(NULL),
	m_pbmSelThumb(NULL),
	m_SuperState(0),
	m_State(0),
	m_SubState(0),
	m_OldSuperState(0),
	m_OldState(0),
	m_OldSubState(0),
	m_pControlContext(NULL),
	m_ptszImagePath(NULL),
	m_bScrollEnable(FALSE),
	m_nScrollOffset(0),
	m_nViewHeight(g_sizeImage.cy),
	m_bForcePaint(FALSE),
	m_bControlHeaderClipped(FALSE),
	m_bActionHeaderClipped(FALSE)
{
	ZeroMemory(m_HeaderRectControl, sizeof(m_HeaderRectControl));
	ZeroMemory(m_HeaderRectAction, sizeof(m_HeaderRectAction));
	m_ptNextWLOText.x = m_ptNextWLOText.y = 0;
}

CDeviceView::~CDeviceView()
{
	Unpopulate();
}

CDeviceControl *CDeviceView::NewControl()
{
	CDeviceControl *pControl = new CDeviceControl(m_ui, *this);
	if (!pControl)
		return NULL;
	m_arpControl.SetAtGrow(m_arpControl.GetSize(), pControl);
	return pControl;
}

void CDeviceView::Remove(CDeviceControl *pControl)
{
	if (pControl == NULL)
		return;

	int i = pControl->GetControlIndex();
	if (i < 0 || i >= GetNumControls())
	{
		assert(0);
		return;
	}

	if (pControl == m_pControlContext)
		m_pControlContext = NULL;

	if (m_arpControl[i] != NULL)
		delete m_arpControl[i];
	m_arpControl[i] = NULL;

	m_arpControl.RemoveAt(i);

	Invalidate();
}

void CDeviceView::RemoveAll(BOOL bUser)
{
	m_pControlContext = NULL;

	for (int i = 0; i < GetNumControls(); i++)
	{
		if (m_arpControl[i] != NULL)
			delete m_arpControl[i];
		m_arpControl[i] = NULL;
	}
	m_arpControl.RemoveAll();

	Invalidate();
}

void CDeviceView::Unpopulate(BOOL bInternalOnly)
{
	DisableScrollBar();

	m_bScrollEnable = FALSE;

	if (m_pbmImage != NULL)
		delete m_pbmImage;
	if (m_pbmThumb != NULL)
		delete m_pbmThumb;
	if (m_pbmSelThumb != NULL)
		delete m_pbmSelThumb;
	m_pbmImage = NULL;
	m_pbmThumb = NULL;
	m_pbmSelThumb = NULL;
	free(m_ptszImagePath);
	m_ptszImagePath = NULL;

	if (!bInternalOnly)
		RemoveAll(FALSE);

	for (int i = 0; i < m_arpText.GetSize(); i++)
	{
		if (m_arpText[i])
			delete m_arpText[i];
		m_arpText[i] = NULL;
	}
	m_arpText.RemoveAll();
}

void AssureSize(CBitmap *&pbm, SIZE to)
{
	if (!pbm)
		return;

	SIZE from;
	if (!pbm->GetSize(&from))
		return;

	if (from.cx >= to.cx && from.cy >= to.cy)
		return;

	CBitmap *nbm = CBitmap::Create(to, RGB(0,0,0));
	if (!nbm)
		return;

	HDC hDC = nbm->BeginPaintInto();
	pbm->Draw(hDC);
	nbm->EndPaintInto(hDC);

	delete pbm;
	pbm = nbm;
	nbm = NULL;
}

CBitmap *CDeviceView::GrabViewImage()
{
	CBitmap *pbm = CBitmap::Create(GetClientSize(), RGB(0, 0, 0), NULL);
	if (!pbm)
		return NULL;
	HDC hDC = pbm->BeginPaintInto();
	if (!hDC)
	{
		delete pbm;
		return NULL;
	}

	OnPaint(hDC);

	pbm->EndPaintInto(hDC);

	return pbm;
}

void CDeviceView::MakeMissingImages()
{
//	if (m_pbmImage)
//		AssureSize(m_pbmImage, g_sizeImage);

	if (m_pbmThumb == NULL)
	{
		if (m_pbmImage)
			m_pbmThumb = m_pbmImage->CreateResizedTo(g_sizeThumb);
		else
		{
			CBitmap *pbmImage = GrabViewImage();
			if (pbmImage)
			{
				AssureSize(pbmImage, g_sizeImage);
				m_pbmThumb = pbmImage->CreateResizedTo(g_sizeThumb);
			}
			delete pbmImage;
		}
	}

	if (m_pbmThumb == NULL)
		return;

	if (m_pbmSelThumb == NULL)
	{
		m_pbmSelThumb = m_pbmThumb->Dup();
		if (m_pbmSelThumb != NULL)
		{
			HDC hDC = m_pbmSelThumb->BeginPaintInto();
			{
				CPaintHelper ph(m_ui.m_uig, hDC);
				ph.SetPen(UIP_SELTHUMB);
				ph.Rectangle(0, 0, g_sizeThumb.cx, g_sizeThumb.cy, UIR_OUTLINE);
			}
			m_pbmSelThumb->EndPaintInto(hDC);
		}
	}
}

void CDeviceView::OnPaint(HDC hDC)
{
	HDC hBDC = NULL, hODC = NULL;
	CBitmap *pbm = NULL;

	if (!InRenderMode())
	{
		hODC = hDC;
		pbm = CBitmap::Create(GetClientSize(), RGB(0, 0, 0), hDC);
		if (pbm != NULL)
		{
			hBDC = pbm->BeginPaintInto();
			if (hBDC != NULL)
				hDC = hBDC;
		}
	}

	// Black-fill first
	SIZE fillsz = GetClientSize();
	RECT fillrc = {0, 0, fillsz.cx, fillsz.cy};
	FillRect(hDC, &fillrc, (HBRUSH)GetStockObject(BLACK_BRUSH));

	if (m_pbmImage != NULL)
		m_pbmImage->Blend(hDC);

	BOOL bScroll = m_bScrollEnable && m_sb.m_hWnd;
	int sdc = 0;
	if (bScroll)
	{
		sdc = SaveDC(hDC);
		OffsetViewportOrgEx(hDC, 0, -m_nScrollOffset + g_iListHeaderHeight, NULL);
	}
	else
	if (m_bScrollEnable)
	{
		sdc = SaveDC(hDC);
		OffsetViewportOrgEx(hDC, 0, g_iListHeaderHeight, NULL);
	}

	int miny = 0 + m_nScrollOffset;
	int maxy = g_sizeImage.cy + m_nScrollOffset;

	int t, nt = GetNumTexts();
	for (t = 0; t < nt; t++)
	{
		CDeviceViewText *pText = m_arpText[t];
		if (pText != NULL &&
			!(pText->GetMinY() > maxy || pText->GetMaxY() < miny))
				pText->OnPaint(hDC);
	}

	BOOL bCFGUIEdit = m_ui.m_uig.InEditMode();
	BOOL bEitherEditMode = bCFGUIEdit;
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	BOOL bEditLayout = m_ui.InEditMode();
	bEitherEditMode = bEitherEditMode || bEditLayout;
#endif
//@@END_MSINTERNAL

	int c, nc = GetNumControls();
	for (c = 0; c < nc; c++)
		if (m_arpControl[c] != NULL && m_arpControl[c]->HasOverlay() &&
		    (m_arpControl[c]->IsHighlighted()
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
				|| InMoveOverlayStateForControl(m_arpControl[c])
#endif
//@@END_MSINTERNAL
				)
				&& (bEitherEditMode || m_arpControl[c]->IsMapped()))
			m_arpControl[c]->DrawOverlay(hDC);
	for (c = 0; c < nc; c++)
	{
		CDeviceControl *pControl = m_arpControl[c];
		if (pControl != NULL && (bEitherEditMode || pControl->IsMapped()) &&
		    !(pControl->GetMinY() > maxy || pControl->GetMaxY() < miny))
			pControl->OnPaint(hDC);
	}

	if (bScroll || m_bScrollEnable)
	{
		RestoreDC(hDC, sdc);
		sdc = 0;
	}

	// Black fill the top portion if this is a list view
	if (bScroll)
	{
		GetClientRect(&fillrc);
		fillrc.bottom = g_iListHeaderHeight;
		FillRect(hDC, &fillrc, (HBRUSH)GetStockObject(BLACK_BRUSH));
	}

	// Print out the headers
	TCHAR tszHeader[MAX_PATH];
	// Control column
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	if (m_arpText.GetSize() > 2)
	/*
//@@END_MSINTERNAL
	if (m_arpText.GetSize())
//@@BEGIN_MSINTERNAL
	*/
#endif
//@@END_MSINTERNAL
	{
		CPaintHelper ph(m_ui.m_uig, hDC);
		ph.SetElement(UIE_CALLOUT);

		for (int i = 0; i < 2; i++)
		{
			// Check if there are two columns, break out the 2nd iteration if not 2 columns.
			if (i == 1 && !(GetNumControls() > 1 &&
			    m_arpControl[0]->GetCalloutMaxRect().top == m_arpControl[1]->GetCalloutMaxRect().top))
				break;

			RECT rcheader;
			if (m_arpText.GetSize())
			{
				// Control column
				LoadString(g_hModule, IDS_LISTHEADER_CTRL, tszHeader, MAX_PATH);
				DrawText(hDC, tszHeader, -1, &m_HeaderRectControl[i], DT_LEFT|DT_NOPREFIX|DT_END_ELLIPSIS);

				// Action column
				LoadString(g_hModule, IDS_LISTHEADER_ACTION, tszHeader, MAX_PATH);
				DrawText(hDC, tszHeader, -1, &m_HeaderRectAction[i], DT_CENTER|DT_NOPREFIX|DT_END_ELLIPSIS);
			}
		}
	}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	if (bEditLayout)
	{
		CPaintHelper ph(m_ui.m_uig, hDC);
		ph.SetElement(UIE_VIEWBORDER);
		RECT rect;
		GetClientRect(&rect);

		if (bScroll)
			rect.right -= DEFAULTVIEWSBWIDTH;
		ph.Rectangle(rect);
	}
#endif
//@@END_MSINTERNAL

	if (!InRenderMode())
	{
		if (pbm != NULL)
		{
			if (hBDC != NULL)
			{
				pbm->EndPaintInto(hBDC);
				pbm->Draw(hODC);
			}
			delete pbm;
		}
	}
}

int CDeviceView::GetNumControls()
{
	return m_arpControl.GetSize();
}

CDeviceControl *CDeviceView::GetControl(int nControl)
{
	if (nControl >= 0 && nControl < GetNumControls())
		return m_arpControl[nControl];
	else
		return NULL;
}

CBitmap *CDeviceView::GetImage(DVIMAGE dvi)
{
	switch (dvi)
	{
		case DVI_IMAGE: return m_pbmImage;
		case DVI_THUMB: return m_pbmThumb;
		case DVI_SELTHUMB: return m_pbmSelThumb;

		default:
			return NULL;
	}
}

void CDeviceView::OnMouseOver(POINT point, WPARAM wParam)
{
	if (m_bScrollEnable && m_sb.m_hWnd)
		point.y += m_nScrollOffset;

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	if (InEditState())
	{
		StateEvent(point, FALSE, TRUE, wParam);
		return;
	}
#endif
//@@END_MSINTERNAL

	// Check if we are over a control
	POINT adjPt = point;
	if (m_bScrollEnable) adjPt.y -= g_iListHeaderHeight;
	int c, nc = GetNumControls();
	for (c = 0; c < nc; c++)
		if (m_arpControl[c] != NULL && m_arpControl[c]->HitTest(adjPt) != DCHT_NOHIT)
		{
			m_arpControl[c]->OnMouseOver(adjPt);
			return;
		}

	// Check if we are over a viewtext
	nc = GetNumTexts();
	for (c = 0; c < nc; c++)
		if (m_arpText[c] != NULL && m_arpText[c]->HitTest(adjPt) != DCHT_NOHIT)
		{
			m_arpText[c]->OnMouseOver(adjPt);
			return;
		}

	CFlexWnd::s_ToolTip.SetEnable(FALSE);

	DEVICEUINOTIFY uin;
	uin.msg = DEVUINM_MOUSEOVER;
	uin.from = DEVUINFROM_VIEWWND;
	uin.mouseover.point = point;
	m_ui.Notify(uin);
}

void CDeviceView::OnClick(POINT point, WPARAM wParam, BOOL bLeft)
{
	if (m_bScrollEnable && m_sb.m_hWnd)
		point.y += m_nScrollOffset;

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	if (InEditState())
	{
		StateEvent(point, TRUE, bLeft, wParam);
		return;
	}
#endif
//@@END_MSINTERNAL

	POINT adjPt = point;
	if (m_bScrollEnable) adjPt.y -= g_iListHeaderHeight;
	int c, nc = GetNumControls();
	for (c = 0; c < nc; c++)
		// adjPt is the adjust click point for scrolling list view
		if (m_arpControl[c] != NULL && m_arpControl[c]->HitTest(adjPt) != DCHT_NOHIT)
		{
			m_arpControl[c]->OnClick(adjPt, bLeft);
			return;
		}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	if (GetNumTexts() > 2)
#endif
//@@END_MSINTERNAL
	{
		for (c = 0; c < GetNumTexts(); ++c)
			if (m_arpControl[c] != NULL && m_arpText[c] != NULL)
			{
				RECT rc = m_arpText[c]->GetRect();
				if (PtInRect(&rc, adjPt))
				{
					m_arpControl[c]->OnClick(adjPt, bLeft);
					return;
				}
			}
	}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	if (!bLeft && m_ui.InEditMode())
	{
		EditMenu(point);
		return;
	}
#endif
//@@END_MSINTERNAL

	// Send notification
	DEVICEUINOTIFY uin;
	uin.msg = DEVUINM_CLICK;
	uin.from = DEVUINFROM_VIEWWND;
	uin.click.bLeftButton = bLeft;
	m_ui.Notify(uin);
}

void CDeviceView::OnDoubleClick(POINT point, WPARAM wParam, BOOL bLeft)
{
	if (m_bScrollEnable && m_sb.m_hWnd)
		point.y += m_nScrollOffset;

	POINT adjPt = point;
	if (m_bScrollEnable) adjPt.y -= g_iListHeaderHeight;
	int c, nc = GetNumControls();
	for (c = 0; c < nc; c++)
		if (m_arpControl[c] != NULL && m_arpControl[c]->HitTest(adjPt) != DCHT_NOHIT)
		{
			m_arpControl[c]->OnClick(adjPt, bLeft, TRUE);
			return;
		}

	for (c = 0; c < GetNumTexts(); ++c)
		if (m_arpControl[c] != NULL && m_arpText[c] != NULL)
		{
			RECT rc = m_arpText[c]->GetRect();
			if (PtInRect(&rc, adjPt))
			{
				m_arpControl[c]->OnClick(adjPt, bLeft, TRUE);
				return;
			}
		}

	DEVICEUINOTIFY uin;
	uin.msg = DEVUINM_DOUBLECLICK;
	uin.from = DEVUINFROM_VIEWWND;
	uin.click.bLeftButton = bLeft;
	m_ui.Notify(uin);
}

void CDeviceView::OnWheel(POINT point, WPARAM wParam)
{
	if (!m_bScrollEnable) return;

	if (m_sb.GetMin() == m_sb.GetMax()) return;

	int nPage = MulDiv(m_sb.GetPage(), 9, 10) >> 1;  // Half a page at a time

	if ((int)wParam >= 0)
		m_sb.AdjustPos(-nPage);
	else
		m_sb.AdjustPos(nPage);

	m_nScrollOffset = m_sb.GetPos();
	Invalidate();
}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
enum {
	IDEC_MOVECALLOUT = 1,
	IDEC_REDEFINECALLOUTMAX,
	IDEC_REALIGNCALLOUT,
	IDEC_REDEFINELINE,
	IDEC_RESELECTCONTROL,
	IDEC_REMOVECALLOUT,
	IDEC_SELECTIMAGES,
	IDEC_NEWVIEW,
	IDEC_NEWCALLOUT,
	IDEC_REMOVEALLCALLOUTS,
	IDEC_REMOVEVIEW,
	IDEC_REMOVEALLVIEWS,
	IDEC_SAVEOREXPORT,
	IDEC_SELECTOVERLAY,
	IDEC_MOVEOVERLAY,
};

BOOL CDeviceView::InMoveOverlayStateForControl(CDeviceControl *pControl)
{
	return m_State == IDEC_MOVEOVERLAY && m_pControlContext == pControl && pControl != NULL;
}

void CDeviceView::EditMenu(POINT point, CDeviceControl *pControl)
{
	static const struct ITEM {
		UINT uID; LPCTSTR tszName;
	} itemC[] = {
		{0, _T("Callout Edit Menu")},
		{0, NULL},
		{IDEC_MOVECALLOUT, _T("Move Callout")},
		{0, NULL},
		{IDEC_REDEFINECALLOUTMAX, _T("Redefine Callout Max")},
		{IDEC_REALIGNCALLOUT, _T("Realign Callout")},
		{IDEC_REDEFINELINE, _T("Redefine Line")},
		{IDEC_SELECTOVERLAY, _T("Select Overlay")},
		{IDEC_MOVEOVERLAY, _T("Move Overlay")},
		{0, NULL},
		{IDEC_RESELECTCONTROL, _T("Reselect Control")},
		{0, NULL},
		{IDEC_REMOVECALLOUT, _T("Remove Callout")},
		{0,NULL}
	}, itemV[] = {
		{0, _T("View Edit Menu")},
		{0, NULL},
		{IDEC_SELECTIMAGES, _T("Select Image(s)")},
		{0, NULL},
		{IDEC_NEWVIEW, _T("New View")},
		{IDEC_NEWCALLOUT, _T("New Callout")},
		{0, NULL},
		{IDEC_REMOVEALLCALLOUTS, _T("Remove All Callouts")},
		{0, NULL},
		{IDEC_REMOVEVIEW, _T("Remove View")},
		{IDEC_REMOVEALLVIEWS, _T("Remove All Views")},
		{0, NULL},
		{IDEC_SAVEOREXPORT, _T("Save/Export")},
		{0,NULL}
	};
	static const int numitemsC = sizeof(itemC) / sizeof(ITEM) - 1;
	static const int numitemsV = sizeof(itemV) / sizeof(ITEM) - 1;
	const ITEM *item = pControl ? itemC : itemV;
	int numitems = pControl ? numitemsC : numitemsV;

	HMENU hMenu = CreatePopupMenu();

	for (int i = 0; i < numitems; i++)
		if (item[i].tszName == NULL)
			AppendMenu(hMenu, MF_SEPARATOR, 0, NULL);
		else
			if (item[i].uID != 0)
				AppendMenu(hMenu, MF_STRING, item[i].uID, item[i].tszName);
			else
				AppendMenu(hMenu, MF_STRING | MF_GRAYED, 0, item[i].tszName);

	m_pControlContext = pControl;
	CFlexWnd::s_ToolTip.SetEnable(FALSE);
	POINT cursor;
	GetCursorPos(&cursor);
	TrackPopupMenuEx(hMenu, TPM_TOPALIGN | TPM_LEFTALIGN | TPM_LEFTBUTTON,
		cursor.x, cursor.y, m_hWnd, NULL);

	DestroyMenu(hMenu);
}

void CDeviceView::SaveOrExport()
{
	OPENFILENAME ofn;

	TCHAR tszFile[256] = _T("");

	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = m_hWnd;
	ofn.hInstance = g_hModule;
	ofn.lpstrFilter = NULL;
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 0;
	ofn.lpstrFile = tszFile;
	ofn.nMaxFile = 256;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = 0;
	ofn.lpstrTitle = NULL;
	ofn.Flags = OFN_EXPLORER | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
	ofn.lpstrDefExt = _T("cpp");
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	if (!GetSaveFileName(&ofn))
		return;

	if (FAILED(ExportCodeTo(tszFile)))
		MessageBox(m_hWnd, _T("Failed."), _T("Failed."), MB_OK);
}

HRESULT CDeviceView::ExportCodeTo(LPCTSTR tszFile)
{
#ifdef UNICODE
	FILE *f = _wfopen(tszFile, _T("wt"));
#define fpf fwprintf
#else
	FILE *f = fopen(tszFile, _T("wt"));
#define fpf fprintf
#endif
	if (f == NULL)
		return E_FAIL;

	fpf(f, _T("CViewKey g_View[%d] =\n{\n"), GetNumControls());
	for (int i = 0; i < GetNumControls(); i++)
		m_arpControl[i]->ExportCodeTo(f);
	fpf(f, _T("};\n"));

	fclose(f);

#undef fpf
	return S_OK;
}

HRESULT CDeviceControl::ExportCodeTo(FILE *f)
{
	if (f == NULL)
		return E_FAIL;

#ifdef UNICODE
#define fpf fwprintf
#else
#define fpf fprintf
#endif

	fpf(f, _T("\t{0, 0, 0, {DIK_,\t"));
	switch (m_dwCalloutAlign)
	{
		case CAF_LEFT: fpf(f, _T("CAF_LEFT, ")); break;
		case CAF_RIGHT: fpf(f, _T("CAF_RIGHT, ")); break;
		case CAF_TOP: fpf(f, _T("CAF_TOP, ")); break;
		case CAF_BOTTOM: fpf(f, _T("CAF_BOTTOM, ")); break;
		case CAF_TOPLEFT: fpf(f, _T("CAF_TOPLEFT, ")); break;
		case CAF_TOPRIGHT: fpf(f, _T("CAF_TOPRIGHT, ")); break;
		case CAF_BOTTOMLEFT: fpf(f, _T("CAF_BOTTOMLEFT, ")); break;
		case CAF_BOTTOMRIGHT: fpf(f, _T("CAF_BOTTOMRIGHT, ")); break;
		case 0: default: fpf(f, _T("0,")); break;
	}
	fpf(f, _T("%s, %d, {"), RECTSTR(m_rectCalloutMax), m_nLinePoints);
	for (int i = 0; i < m_nLinePoints; i++)
		fpf(f, _T("%s,"), POINTSTR(m_rgptLinePoint[i]));
	fpf(f, _T("}}},\n"));

#undef fpf

	return S_OK;
}

LRESULT CDeviceView::OnCommand(WORD wNotifyCode, WORD wID, HWND hWnd)
{
	// only handle menu messages
	if (wNotifyCode != 0)
		return FALSE;

	UINT cmd = (UINT)wID;

	switch (cmd)
	{
		case IDEC_SAVEOREXPORT:
		{
			BOOL b;
			b = WriteToINI();
			break;
		}
		case IDEC_MOVEOVERLAY:
		case IDEC_MOVECALLOUT:
		case IDEC_REDEFINECALLOUTMAX:
		case IDEC_REALIGNCALLOUT:
		case IDEC_REDEFINELINE:
		case IDEC_NEWCALLOUT:
			SetEditState(cmd);
			return TRUE;

		case IDEC_RESELECTCONTROL:
			if (m_pControlContext)
				m_pControlContext->ReselectControl();
			break;

		case IDEC_REMOVECALLOUT:
			if (m_pControlContext)
				m_ui.NoteDeleteControl(m_pControlContext);
			Remove(m_pControlContext);
			break;

		case IDEC_SELECTOVERLAY:
			if (m_pControlContext)
				m_pControlContext->SelectOverlay();
			break;

		case IDEC_SELECTIMAGES:
			SelectImages();
			break;

		case IDEC_NEWVIEW:
			m_ui.SetView(m_ui.UserNewView());
			break;

		case IDEC_REMOVEALLCALLOUTS:
			if (UserConfirm(g_hModule, m_hWnd, IDS_REMOVEALLCALLOUTS, IDS_CONFIRMREMOVEALLCALLOUTS))
			{
				m_ui.NoteDeleteAllControlsForView(this);
				RemoveAll();
			}
			break;

		case IDEC_REMOVEVIEW:
			if (UserConfirm(g_hModule, m_hWnd, IDS_REMOVEVIEW, IDS_CONFIRMREMOVEVIEW))
			{
				// you MUST return immediately after this call,
				// as this object will have been deleted!
				m_ui.NoteDeleteView(this);
				m_ui.Remove(this);
				return TRUE;
			}
			break;

		case IDEC_REMOVEALLVIEWS:
			if (UserConfirm(g_hModule, m_hWnd, IDS_REMOVEALLVIEWS, IDS_CONFIRMREMOVEALLVIEWS))
			{
				// you MUST return immediately after this call,
				// as this object (and all other views for this device)
				// will have been deleted!
				m_ui.NoteDeleteAllViews();
				m_ui.RemoveAll();
				return TRUE;
			}
			break;

		default:
			return FALSE;
	}

	m_pControlContext = NULL;
	return TRUE;
}

BOOL CDeviceView::InEditState()
{
	return m_State != 0;
}

void CDeviceView::EndEditState()
{
	m_SuperState = 0;
	m_State = 0;
	m_SubState = 0;
	m_pControlContext = NULL;
	IndicateState();
	ReleaseCapture();
}

void CDeviceView::SetEditState(UINT cmd)
{
	m_State = cmd;
	m_SubState = 0;

	if (m_State == 0)
	{
		EndEditState();
		return;
	}

	switch (cmd)
	{
		case IDEC_NEWCALLOUT:
			if (!IsUnassignedOffsetAvailable())
			{
				FormattedMsgBox(g_hModule, m_hWnd, MB_OK | MB_ICONINFORMATION, IDS_TITLE_NONEWCONTROL, IDS_ERROR_OFFSETUNAVAIL);
				EndEditState();
				return;
			}
			m_pControlContext = NewControl();
			m_SuperState = cmd;
			m_State = cmd = IDEC_REDEFINECALLOUTMAX;
			// fallthrough

		case IDEC_REDEFINECALLOUTMAX:
		case IDEC_REALIGNCALLOUT:
		case IDEC_REDEFINELINE:
		case IDEC_MOVECALLOUT:
		case IDEC_MOVEOVERLAY:
			break;

		default:
			assert(0);
			break;
	}

	SetCapture();

	IndicateState(TRUE);
}

void CDeviceView::IndicateState(BOOL bFirst)
{
	// see what's changed since last call
	BOOL bSuperStateChanged = m_SuperState != m_OldSuperState;
	BOOL bStateChanged = m_State != m_OldState;
	BOOL bSubStateChanged = m_SubState != m_OldSubState;

	// save to check for next call
	m_OldSuperState = m_SuperState;
	m_OldState = m_State;
	m_OldSubState = m_SubState;

	// if there is no state, just end indication
	if (m_State == 0)
	{
		m_ui.EndStateIndication();
		return;
	}

	// unless this is the first indication for an editing state or super state...
	if (!bFirst)
	{
		// do nothing if nothing's changed
		if (!(bSuperStateChanged || bStateChanged || bSubStateChanged))
			return;
	}

	// string to send to the ui for indication
	TCHAR str[1024] = _T("");

	// fill string as appropriate
	switch (m_State)
	{
		case IDEC_REDEFINECALLOUTMAX:
			wsprintf(str, _T("Left click where you want to place %s corner of the callout max rect."),
			         m_SubState == 0 ? _T("a") : _T("the opposite"));
			break;

		case IDEC_REALIGNCALLOUT:
			_tcscpy(str, _T("Move the mouse to consider callout alignments within the max rect, and left click to choose the one you want."));
			break;

		case IDEC_REDEFINELINE:
			_tcscpy(str, _T("Draw a line from the callout to the corresponding device control by left clicking to add points.  Right click to place the last point."));
			break;

		case IDEC_MOVECALLOUT:
			_tcscpy(str, _T("Move the entire callout around with the mouse and left click to place it."));
			break;

		case IDEC_MOVEOVERLAY:
			_tcscpy(str, _T("Move the overlay image around with the mouse and left click to place it."));
			break;
	}

	// set state indication if the string was actually filled
	if (_tcslen(str) > 0)
		m_ui.SetStateIndication(str);
}

void CDeviceView::StateEvent(POINT point, BOOL bClick, BOOL bLeft, WPARAM nKeyState)
{
	// constrain point to view
	SIZE size = GetClientSize();
	const int WRAPAROUND = 10000;
	if (point.x < 0 || point.x > WRAPAROUND)
	point.x = 0;
	if (point.y < 0 || point.y > WRAPAROUND)
	point.y = 0;
	if (point.x >= size.cx)
	point.x = size.cx - 1;
	if (point.y >= size.cy)
	point.y = size.cy - 1;

	switch (m_State)
	{
		case IDEC_REDEFINECALLOUTMAX:
			if (m_pControlContext)
				m_pControlContext->PlaceCalloutMaxCorner(m_SubState, point);
			if (bClick && bLeft)
			{
				m_SubState++;
				if (m_SubState == 2)
					EndState();
			}
			break;

		case IDEC_REALIGNCALLOUT:
			if (m_pControlContext)
				m_pControlContext->ConsiderAlignment(point);
			if (bClick && bLeft)
			{
				if (m_pControlContext)
					m_pControlContext->FinalizeAlignment();
				EndState();
			}
			break;

		case IDEC_REDEFINELINE:
			if (m_pControlContext)
				m_pControlContext->SetLastLinePoint(m_SubState, point, (BOOL)(nKeyState & MK_SHIFT));
			if (bClick)
			{
				if (bLeft && m_pControlContext)
					m_SubState = m_pControlContext->GetNextLinePointIndex();
				if (!bLeft || m_pControlContext->ReachedMaxLinePoints())
					EndState();
			}
			break;

		case IDEC_MOVECALLOUT:
			if (m_pControlContext)
				m_pControlContext->Position(point);
			if (bClick && bLeft)
				EndState();
			break;

		case IDEC_MOVEOVERLAY:
			if (m_pControlContext)
			{
				if (!m_pControlContext->HasOverlay())
					EndState();
				else
					m_pControlContext->PositionOverlay(point);
			}
			if (bClick && bLeft)
				EndState();
			break;

		default:
			assert(0);
	}

	IndicateState();
}

void CDeviceView::EndState()
{
	switch (m_SuperState)
	{
		case IDEC_NEWCALLOUT:
			switch (m_State)
			{
				case IDEC_REDEFINECALLOUTMAX:
					SetEditState(IDEC_REALIGNCALLOUT);
					break;

				case IDEC_REALIGNCALLOUT:
					SetEditState(IDEC_REDEFINELINE);
					break;

				case IDEC_REDEFINELINE:
					if (m_pControlContext)
					{
						m_pControlContext->SelectControl();
						m_pControlContext->SelectOverlay();

						if (m_pControlContext->HasOverlay())
							SetEditState(IDEC_MOVEOVERLAY);
						else
							EndEditState();
					}
					break;

				case IDEC_MOVEOVERLAY:
					EndEditState();
					break;

				default:
					assert(0);
					break;
			}
			break;

		case 0:
			EndEditState();
			break;

		default:
			assert(0);
			break;
	}
}
#endif
//@@END_MSINTERNAL

BOOL CDeviceView::DoesCalloutExistForOffset(DWORD dwOfs)
{
	return DoesCalloutOtherThanSpecifiedExistForOffset(NULL, dwOfs);
}

BOOL CDeviceView::DoesCalloutOtherThanSpecifiedExistForOffset(CDeviceControl *pOther, DWORD dwOfs)
{
	int nc = GetNumControls();
	for (int i = 0; i < nc; i++)
	{
		CDeviceControl *pControl = GetControl(i);
		if (pControl == NULL || pControl == pOther)
			continue;
		if (!pControl->IsOffsetAssigned())
			continue;
		if (pControl->GetOffset() == dwOfs)
			return TRUE;
	}
	return FALSE;
}

// This function returns the index of a control with the specified offset
int CDeviceView::GetIndexFromOfs(DWORD dwOfs)
{
	for (int i = 0; i < GetNumControls(); ++i)
		if (m_arpControl[i]->GetOffset() == dwOfs)
			return i;

	return -1;
}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
BOOL CDeviceView::WriteToINI()
{
	// This function simply routes the call to the parent UI because the entire device info must
	// be saved, not just current view.
	return m_ui.WriteToINI();
}
#endif
//@@END_MSINTERNAL

int CDeviceView::GetViewIndex()
{
	return m_ui.GetViewIndex(this);
}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
void CDeviceView::SelectImages()
{
	LPCTSTR file = GetOpenFileName(
		g_hModule,
		m_hWnd,
		_T("Select An Image for This View"),
		_T("PNG Files (*.png)\0*.png\0All Files (*.*)\0*.*\0"),
		_T("png"));

	if (file == NULL)
		return;

	ManualLoadImage(file);
}

void CDeviceView::ManualLoadImage(LPCTSTR tszPath)
{
	if (!tszPath)
		FormattedErrorBox(g_hModule, m_hWnd, IDS_TITLE_NOLOADVIEWIMAGE, IDS_NULLPATH);

	LPDIRECT3DSURFACE8 pSurf = m_ui.m_uig.GetSurface3D();  // GetSurface3D() calls AddRef() on the surface.
	CBitmap *pbmNewImage = CBitmap::CreateViaD3DX(tszPath, pSurf);
	if (pSurf)
	{
		// Release surface instance after we are done with it so we don't leak memory.
		pSurf->Release();
		pSurf = NULL;
	}
	if (pbmNewImage == NULL)
	{
		FormattedErrorBox(g_hModule, m_hWnd, IDS_TITLE_NOLOADVIEWIMAGE, IDS_COULDNOTCREATEIMAGEFROMFILE, tszPath);
		return;
	}

	// unpopulate only this view's stuff, not the callouts
	Unpopulate(TRUE);

	// replace
	m_pbmImage = pbmNewImage;
	pbmNewImage = NULL;
	MakeMissingImages();
	m_ptszImagePath = _tcsdup(tszPath);

	// redraw
	Invalidate();
}
#endif
//@@END_MSINTERNAL

BOOL CDeviceView::IsUnassignedOffsetAvailable()
{
	DIDEVOBJSTRUCT os;

	HRESULT hr = FillDIDeviceObjectStruct(os, m_ui.m_lpDID);
	if (FAILED(hr))
		return FALSE;

	if (os.nObjects < 1)
		return FALSE;

	assert(os.pdoi);
	if (!os.pdoi)
		return FALSE;

	for (int i = 0; i < os.nObjects; i++)
	{
		const DIDEVICEOBJECTINSTANCEW &o = os.pdoi[i];

		if (!DoesCalloutExistForOffset(o.dwOfs))
			return TRUE;
	}

	return FALSE;
}

CDeviceViewText *CDeviceView::AddText(
	HFONT f, COLORREF t, COLORREF b, const RECT &r, LPCTSTR text)
{
	CDeviceViewText *pText = NewText();
	if (!pText)
		return NULL;

	pText->SetLook(f, t, b);
	pText->SetRect(r);
	pText->SetText(text);

	return pText;
}

CDeviceViewText *CDeviceView::AddText(
	HFONT f, COLORREF t, COLORREF b, const POINT &p, LPCTSTR text)
{
	CDeviceViewText *pText = NewText();
	if (!pText)
		return NULL;

	pText->SetLook(f, t, b);
	pText->SetPosition(p);
	pText->SetTextAndResizeTo(text);

	return pText;
}

CDeviceViewText *CDeviceView::AddWrappedLineOfText(
	HFONT f, COLORREF t, COLORREF b, LPCTSTR text)
{
	CDeviceViewText *pText = NewText();
	if (!pText)
		return NULL;

	pText->SetLook(f, t, b);
	pText->SetPosition(m_ptNextWLOText);
	pText->SetTextAndResizeToWrapped(text);
	
	m_ptNextWLOText.y += pText->GetHeight();

	return pText;
}

CDeviceViewText *CDeviceView::NewText()
{
	CDeviceViewText *pText = new CDeviceViewText(m_ui, *this);
	if (!pText)
		return NULL;
	m_arpText.SetAtGrow(m_arpText.GetSize(), pText);
	return pText;
}

// Called by PopulateListView(), after the CDeviceViewText and CDeviceControl lists are constructed.
// Returns TRUE if any label is printed with ellipses (not enough space).
BOOL CDeviceView::CalculateHeaderRect()
{
	TCHAR tszHeader[MAX_PATH];
	// Control column
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	if (m_arpText.GetSize() > 2)
	/*
//@@END_MSINTERNAL
	if (m_arpText.GetSize())
//@@BEGIN_MSINTERNAL
	*/
#endif
//@@END_MSINTERNAL
	{
		HDC hDC = CreateCompatibleDC(NULL);

		if (hDC)
		{
			CPaintHelper ph(m_ui.m_uig, hDC);
			ph.SetElement(UIE_CALLOUT);

			for (int i = 0; i < 2; i++)
			{
				// Check if there are two columns, break out the 2nd iteration if not 2 columns.
				if (i == 1 && !(GetNumControls() > 1 &&
					m_arpControl[0]->GetCalloutMaxRect().top == m_arpControl[1]->GetCalloutMaxRect().top))
					break;

				RECT rcheader;
				if (m_arpText.GetSize())
				{
					// Action column
					rcheader = m_arpText[i]->GetRect();
					rcheader.bottom -= rcheader.top;
					rcheader.top = 0;
					if (i == 0)
						rcheader.left = 0;
					else
						rcheader.left = (g_ViewRect.right - g_ViewRect.left) >> 1;
					m_HeaderRectControl[i] = rcheader;

					// Find out if the control header label will be clipped.
					LoadString(g_hModule, IDS_LISTHEADER_CTRL, tszHeader, MAX_PATH);
					DrawText(hDC, tszHeader, -1, &rcheader, DT_LEFT|DT_NOPREFIX|DT_CALCRECT);
					if (rcheader.right > m_HeaderRectControl[i].right || rcheader.bottom > m_HeaderRectControl[i].bottom)
						m_bControlHeaderClipped = TRUE;

					// Control column
					rcheader = m_arpControl[i]->GetCalloutMaxRect();
					rcheader.bottom -= rcheader.top;
					rcheader.top = 0;
					m_HeaderRectAction[i] = rcheader;

					// Find out if the action header label will be clipped.
					LoadString(g_hModule, IDS_LISTHEADER_ACTION, tszHeader, MAX_PATH);
					DrawText(hDC, tszHeader, -1, &rcheader, DT_LEFT|DT_NOPREFIX|DT_CALCRECT);
					if (rcheader.right > m_HeaderRectAction[i].right || rcheader.bottom > m_HeaderRectAction[i].bottom)
						m_bActionHeaderClipped = TRUE;
				}
			}
		}
		DeleteDC(hDC);
	}
	return m_bActionHeaderClipped || m_bControlHeaderClipped;
}

int CDeviceView::GetNumTexts()
{
	return m_arpText.GetSize();
}

CDeviceViewText *CDeviceView::GetText(int nText)
{
	if (nText < 0 || nText >= GetNumTexts())
		return NULL;
	return m_arpText[nText];
}

void CDeviceView::SetImage(CBitmap *&refpbm)
{
	delete m_pbmImage;
	m_pbmImage = refpbm;
	refpbm = NULL;
	MakeMissingImages();
	Invalidate();
}

void CDeviceView::SetImagePath(LPCTSTR tszPath)
{
	if (m_ptszImagePath)
		free(m_ptszImagePath);
	m_ptszImagePath = NULL;

	if (tszPath)
		m_ptszImagePath = _tcsdup(tszPath);
}

void CDeviceView::CalcDimensions()
{
	// go through all texts and controls to find the max y coord
	int max = g_sizeImage.cy - g_iListHeaderHeight;
	int i = 0;
	for (; i < GetNumTexts(); i++)
	{
		CDeviceViewText *pText = GetText(i);
		if (!pText)
			continue;
		int ty = pText->GetMaxY();
		if (ty > max)
			max = ty;
	}
	for (i = 0; i < GetNumControls(); i++)
	{
		CDeviceControl *pControl = GetControl(i);
		if (!pControl)
			continue;
		int cy = pControl->GetMaxY();
		if (cy > max)
			max = cy;
	}

	// set
	m_nViewHeight = max;
	m_nScrollOffset = 0;

	// enable scrollbar if view height more than window size
	if (m_nViewHeight > g_sizeImage.cy - g_iListHeaderHeight)
		EnableScrollBar();
}

void CDeviceView::DisableScrollBar()
{
	if (!m_sb.m_hWnd)
		return;

	m_sb.Destroy();
}

void CDeviceView::EnableScrollBar()
{
	if (m_sb.m_hWnd)
		return;

	FLEXSCROLLBARCREATESTRUCT cs;
	cs.dwSize = sizeof(cs);
	cs.dwFlags = FSBF_VERT;
	cs.min = 0;
	cs.max = m_nViewHeight;
	cs.page = g_sizeImage.cy - g_iListHeaderHeight;
	cs.pos = m_nScrollOffset;
	cs.hWndParent = m_hWnd;
	cs.hWndNotify = m_hWnd;
	RECT rect = {g_sizeImage.cx - DEFAULTVIEWSBWIDTH, g_iListHeaderHeight, g_sizeImage.cx, g_sizeImage.cy};
	cs.rect = rect;
	cs.bVisible = TRUE;
	m_sb.SetColors(
		m_ui.m_uig.GetBrushColor(UIE_SBTRACK),
		m_ui.m_uig.GetBrushColor(UIE_SBTHUMB),
		m_ui.m_uig.GetPenColor(UIE_SBBUTTON));
	m_sb.Create(&cs);
}

LRESULT CDeviceView::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
		case WM_PAINT:
			m_bForcePaint = TRUE;
			return CFlexWnd::WndProc(hWnd, msg, wParam, lParam);

		case WM_FLEXVSCROLL:
		{
			int code = (int)wParam;
			CFlexScrollBar *pSB = (CFlexScrollBar *)lParam;
			if (!pSB)
				return 0;

			int nLine = 5;
			int nPage = MulDiv(pSB->GetPage(), 9, 10);

			switch (code)
			{
				case SB_LINEUP: pSB->AdjustPos(-nLine); break;
				case SB_LINEDOWN: pSB->AdjustPos(nLine); break;
				case SB_PAGEUP: pSB->AdjustPos(-nPage); break;
				case SB_PAGEDOWN: pSB->AdjustPos(nPage); break;
				case SB_THUMBTRACK: pSB->SetPos(pSB->GetThumbPos()); break;
			}

			m_nScrollOffset = pSB->GetPos();

			Invalidate();
			return 0;
		}

		case WM_FLEXHSCROLL:
			assert(0);
		default:
			return CFlexWnd::WndProc(hWnd, msg, wParam, lParam);
	}
}

void CDeviceView::ScrollToMakeControlVisible(const RECT &rc)
{
	RECT viewrc;

	if (!m_bScrollEnable)
		return;

	GetClientRect(&viewrc);
	viewrc.bottom -= g_iListHeaderHeight;
	viewrc.top += m_nScrollOffset;
	viewrc.bottom += m_nScrollOffset;

	// If scroll enabled, we scroll the view to make the control visible if not already so.
	if (m_bScrollEnable && m_sb.m_hWnd &&
	    !(viewrc.left <= rc.left &&
	      viewrc.right >= rc.right &&
	      viewrc.top <= rc.top &&
	      viewrc.bottom >= rc.bottom))
	{
		// If the callout is below the view window, scroll so it shows up at the bottom of the window.
		if (viewrc.bottom < rc.bottom)
			m_sb.SetPos(m_sb.GetPos() + rc.bottom - viewrc.bottom);
		else
			m_sb.SetPos(rc.top);
		m_nScrollOffset = m_sb.GetPos();
		Invalidate();
	}
}

void CDeviceView::SwapControls(int i, int j)
{
	RECT rect;
	CDeviceControl *pTmpControl;
	CDeviceViewText *pTmpViewText;

	pTmpControl = m_arpControl[i];
	m_arpControl[i] = m_arpControl[j];
	m_arpControl[j] = pTmpControl;
	pTmpViewText = m_arpText[i];
	m_arpText[i] = m_arpText[j];
	m_arpText[j] = pTmpViewText;
	// Swap the rect back so everything will display properly.
	rect = m_arpControl[i]->GetCalloutMaxRect();
	m_arpControl[i]->SetCalloutMaxRect(m_arpControl[j]->GetCalloutMaxRect());
	m_arpControl[j]->SetCalloutMaxRect(rect);
	rect = m_arpText[i]->GetRect();
	m_arpText[i]->SetRect(m_arpText[j]->GetRect());
	m_arpText[j]->SetRect(rect);
	// Exchange the text rect width, so the correct width stays with the correct text.
	RECT rc1 = m_arpText[i]->GetRect();
	RECT rc2 = m_arpText[j]->GetRect();
	// Store rc1's new width first
	int iTempWidth = rc1.right - (rc2.right - rc2.left);
	rc2.left = rc2.right - (rc1.right - rc1.left);  // Adjust rc2's width
	rc1.left = iTempWidth;  // Adjust rc1's width
	m_arpText[i]->SetRect(rc1);
	m_arpText[j]->SetRect(rc2);
}

// Implements a simple selection sort algorithm to sort the control array and viewtext array.
// - iStart is the starting index, inclusive.
// - iEnd is the last index, exclusive.
void CDeviceView::SortCallouts(int iStart, int iEnd)
{
	for (int i = iStart; i < iEnd - 1; ++i)
	{
		DWORD dwSmallestOfs = m_arpControl[i]->GetOffset();
		int iSmallestIndex = i;
		for (int j = i + 1; j < iEnd; ++j)
			if (m_arpControl[j]->GetOffset() < dwSmallestOfs)
			{
				dwSmallestOfs = m_arpControl[j]->GetOffset();
				iSmallestIndex = j;
			}
		// Swap the smallest element with i-th element.
		if (iSmallestIndex != i)
			SwapControls(i, iSmallestIndex);
	}
}

void CDeviceView::SortAssigned(BOOL bSort)
{
	// If less than 2 controls, no need for sorting.
	if (m_arpControl.GetSize() < 2)
		return;

	int iCalloutX[2] = {m_arpControl[0]->GetMinX(), m_arpControl[1]->GetMinX()};  // Callout X for the two columns

	// Sort the text array and control array.
	if (bSort)
	{
		// First move all the assigned controls to the first n elements.
		int iNextAssignedWriteIndex = 0;
		for (int i = 0; i < m_arpControl.GetSize(); ++i)
			if (m_arpControl[i]->HasAction())
			{
				// Swap the controls
				SwapControls(i, iNextAssignedWriteIndex);
				++iNextAssignedWriteIndex;  // Increment the write index
			}

		// Sort the two parts now
		SortCallouts(0, iNextAssignedWriteIndex);
		SortCallouts(iNextAssignedWriteIndex, m_arpControl.GetSize());
	} else
		SortCallouts(0, m_arpControl.GetSize());
}

void CDeviceView::DoOnPaint(HDC hDC)
{
	// Paint only if we have an update region.
	if (GetUpdateRect(m_hWnd, NULL, FALSE) || m_bForcePaint)
		OnPaint(hDC);
	m_bForcePaint = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cdeviceui.h ===
/******************************************************************************
 * File: CDeviceUI.h
 *
 * Desc:
 *
 * CDeviceUI is a helper that holds all the views and a bunch of
 * information for a specific device.  It has a CFlexWnd whose
 * handler it sets to the CDeviceView for the current view,
 * thus reusing one window to implement multiple pages.
 *
 * All CDeviceViews and CDeviceControls have a reference to the CDeviceUI
 * that created them (m_ui).  Thus, they also have access to the
 * CUIGlobals, since CDeviceUI has a reference to them (m_ui.m_uig).
 * CDeviceUI also provides the following read-only public variables
 * for convenience, all referring to the device this CDeviceUI
 * represents:
 * 
 * const DIDEVICEINSTANCEW &m_didi;
 * const LPDIRECTINPUTDEVICE8W &m_lpDID;
 * const DIDEVOBJSTRUCT &m_os;
 *
 * See usefuldi.h for a description of DIDEVOBJSTRUCT.
 *
 * CDeviceUI communicates to the rest of the UI via the CDeviceUINotify
 * abstract base class.  Another class (in our case CDIDeviceActionConfigPage)
 * must derive from CDeviceUINotify, and define the DeviceUINotify() and
 * IsControlMapped() virtual functions.  This derived class must be passed as
 * the last parameter to CDeviceUI's Init() function.  All the views and 
 * controls within the views notify the UI of user actions via m_ui.Notify(),
 * so that all actionformat manipulation can be done in the page class.  The
 * views and controls themselves never touch the actionformat.  See the
 * DEVICEUINOTIFY structure below for information on the parameter passed
 * through Notify()/DeviceUINotify().
 *
 * Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
 *
 ***************************************************************************/


#ifdef FORWARD_DECLS


	struct DEVICEUINOTIFY;

	struct UIDELETENOTE;

	class CDeviceUINotify;
	class CDeviceUI;


#else // FORWARD_DECLS

#ifndef __CDEVICEUI_H__
#define __CDEVICEUI_H__


enum {
	DEVUINM_NUMVIEWSCHANGED,
	DEVUINM_ONCONTROLDESTROY,
	DEVUINM_MOUSEOVER,
	DEVUINM_CLICK,
	DEVUINM_DOUBLECLICK,
	DEVUINM_SELVIEW,
	DEVUINM_INVALID,
	DEVUINM_UNASSIGNCALLOUT,
	DEVUINM_RENEWDEVICE
};

enum {
	DEVUINFROM_CONTROL,
	DEVUINFROM_THUMBNAIL,
	DEVUINFROM_SELWND,
	DEVUINFROM_VIEWWND,
	DEVUINFROM_INVALID
};

struct DEVICEUINOTIFY {
	DEVICEUINOTIFY() : msg(DEVUINM_INVALID), from(DEVUINFROM_INVALID) {}
	int msg;
	int from;
	union {
		struct {
			CDeviceControl *pControl;
		} control;
		struct {
			CDeviceView *pView;
			BOOL bSelected;
		} thumbnail;
		struct {
			int dummy;
		} selwnd;
		struct {
			int dummy;
		} viewwnd;
	};
	union {
		struct {
			int nView;
		} selview;
		struct {
			POINT point;
		} mouseover;
		struct {
			BOOL bLeftButton;
		} click;
	};
};


enum UIDELETENOTETYPE {
	UIDNT_VIEW,
	UIDNT_CONTROL,
};

struct UIDELETENOTE {
	UIDELETENOTETYPE eType;
	int nViewIndex;
	int nControlIndex;
	DWORD dwObjID;
};

typedef void (*DEVCTRLCALLBACK)(CDeviceControl *, LPVOID, BOOL);


class CDeviceUINotify
{
public:
	virtual void DeviceUINotify(const DEVICEUINOTIFY &) = 0;
	virtual BOOL IsControlMapped(CDeviceControl *) = 0;
};


class CDeviceUI
{
public:
	CDeviceUI(CUIGlobals &uig, IDIConfigUIFrameWindow &uif);
	~CDeviceUI();

	// intialization
	HRESULT Init(const DIDEVICEINSTANCEW &didi, LPDIRECTINPUTDEVICE8W lpDID, HWND hWnd, CDeviceUINotify *pNotify);

	// view state
	void SetView(int nView);
	void SetView(CDeviceView *pView);
	CDeviceView *GetView(int nView);
	CDeviceView *GetCurView();
	int GetViewIndex(CDeviceView *pView);
	int GetCurViewIndex();
	int GetNumViews() {return m_arpView.GetSize();}
	void NextView() {SetView((GetCurViewIndex() + 1) % GetNumViews());}
	void PrevView() {SetView((GetCurViewIndex() - 1 + GetNumViews()) % GetNumViews());}

	// gets the thumbnail for the specified view,
	// using the selected version if the view is selected
	CBitmap *GetViewThumbnail(int nView);
	
	// gets the thumbnail for the specified view,
	// specifiying whether or not we want the selected version
	CBitmap *GetViewThumbnail(int nView, BOOL bSelected);

	// for view/control to notify
	void Notify(const DEVICEUINOTIFY &uin)
		{if (m_pNotify != NULL) m_pNotify->DeviceUINotify(uin);}

	// device control access
	void SetAllControlCaptionsTo(LPCTSTR tszCaption);
	void SetCaptionForControlsAtOffset(DWORD dwOffset, LPCTSTR tszCaption, BOOL bFixed = FALSE);
	void DoForAllControls(DEVCTRLCALLBACK callback, LPVOID pVoid, BOOL bFixed = FALSE);
	void DoForAllControlsAtOffset(DWORD dwOffset, DEVCTRLCALLBACK callback, LPVOID pVoid, BOOL bFixed = FALSE);
	
	// page querying
	BOOL IsControlMapped(CDeviceControl *);

	// other
	void GetDeviceInstanceGuid(GUID &rGuid) {rGuid = m_didi.guidInstance;}
	
	// editing
	void SetEditMode(BOOL bEdit = TRUE);
	BOOL InEditMode() {return m_bInEditMode;}
	void Remove(CDeviceView *pView);
	void RemoveAll();
#define NVT_USER 1
#define NVT_POPULATE 2
#define NVT_REQUIREATLEASTONE 3
	CDeviceView *NewView();
	CDeviceView *UserNewView();
	void RequireAtLeastOneView();
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	void SetStateIndication(LPCTSTR) {}
	void EndStateIndication() {}
	BOOL WriteToINI();
#endif
//@@END_MSINTERNAL
	void SetDevice(LPDIRECTINPUTDEVICE8W lpDID);  // Sets the device object that we are using

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	// deletion noting
	void NoteDeleteView(CDeviceView *pView);
	void NoteDeleteView(int nView);
	void NoteDeleteControl(CDeviceControl *pControl);
	void NoteDeleteControl(int nView, int nControl, DWORD dwObjID);
	void NoteDeleteAllControlsForView(CDeviceView *pView);
	void NoteDeleteAllViews();

	// deletion querying
	int GetNumDeleteNotes();
	BOOL GetDeleteNote(UIDELETENOTE &uidn, int i);
	void ClearDeleteNotes();

	// deletion debugging
	void DumpDeleteNotes();
#endif
//@@END_MSINTERNAL

	// drawing
	void Invalidate();

	// clearing
	void Unpopulate();

private:
	// delete notes
	CArray<UIDELETENOTE, UIDELETENOTE &> m_DeleteNotes;

	// who we're going to notify
	CDeviceUINotify *m_pNotify;
	HWND m_hWnd;

	// view state
	CArray<CDeviceView *, CDeviceView *&> m_arpView;
	CDeviceView *m_pCurView;
	BOOL m_bInEditMode;
	RECT m_ViewRect;
	void NumViewsChanged();

	// device globals...
public:
	// full access to ui globals and frame
	CUIGlobals &m_uig;
	IDIConfigUIFrameWindow &m_UIFrame;

	// read only public access versions
	const DIDEVICEINSTANCEW &m_didi;
	const LPDIRECTINPUTDEVICE8W &m_lpDID;
	const DIDEVOBJSTRUCT &m_os;
private:
	// private versions
	DIDEVICEINSTANCEW m_priv_didi;
	LPDIRECTINPUTDEVICE8W m_priv_lpDID;
	DIDEVOBJSTRUCT m_priv_os;
};


#endif //__CDEVICEUI_H__

#endif // FORWARD_DECLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cdeviceviewtext.cpp ===
//-----------------------------------------------------------------------------
// File: cdeviceviewtext.cpp
//
// Desc: CDeviceViewText is a class representing a text string in the view
//       window. It is used when the view type is a list view.  CDeviceViewText
//       will print the text of the control name, while CDeviceControl will
//       print the text of the action assigned to that control.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"
#include <string.h>


CDeviceViewText::CDeviceViewText(CDeviceUI &ui, CDeviceView &view) :
	m_ui(ui), m_view(view),
	m_hFont(NULL),
	m_rgbText(RGB(255,255,255)),
	m_rgbBk(RGB(0,0,0)),
	m_bWrap(FALSE),
	m_bClipped(FALSE),
	m_ptszText(NULL)
{
	m_rect.left = m_rect.top = m_rect.right = m_rect.bottom = 0;
}

CDeviceViewText::~CDeviceViewText()
{
	if (m_ptszText)
		free(m_ptszText);
	m_ptszText = NULL;
}

void CDeviceViewText::SetLook(HFONT a, COLORREF b, COLORREF c)
{
	m_hFont = a;
	m_rgbText = b;
	m_rgbBk = c;

	Invalidate();
}

void CDeviceViewText::SetPosition(int x, int y)
{
	int w = m_rect.right - m_rect.left;
	int h = m_rect.bottom - m_rect.top;

	m_rect.left = x;
	m_rect.right = x + w;

	m_rect.top = y;
	m_rect.bottom = y + h;

	Invalidate();
}

void CDeviceViewText::SetRect(const RECT &r)
{
	m_rect = r;
	CheckClipped();
	Invalidate();
}

void CDeviceViewText::_SetText(LPCTSTR t)
{
	if (m_ptszText)
		free(m_ptszText);
	if (t)
		m_ptszText = AllocLPTSTR(t);
}

// Check if the text is clipped when printed and set flag appropriately.
void CDeviceViewText::CheckClipped()
{
	RECT rect = m_rect;
	HDC hDC = CreateCompatibleDC(NULL);
	if (hDC != NULL)
	{
		HGDIOBJ hOld = NULL;
		if (m_hFont)
			hOld = SelectObject(hDC, m_hFont);
		DrawText(hDC, m_ptszText, -1, &rect, DT_CALCRECT | DT_NOPREFIX | DT_LEFT);
		if (m_hFont)
			SelectObject(hDC, hOld);
		DeleteDC(hDC);
	}
	if (rect.right > m_rect.right || rect.bottom > m_rect.bottom)
		m_bClipped = TRUE;
	else
		m_bClipped = FALSE;
}

void CDeviceViewText::SetText(LPCTSTR t)
{
	_SetText(t);
	CheckClipped();
	Invalidate(TRUE);
}

void CDeviceViewText::SetTextAndResizeTo(LPCTSTR t)
{
	_SetText(t);
	SIZE s = GetTextSize(m_ptszText, m_hFont);
	m_rect.right = m_rect.left + s.cx;
	m_rect.bottom = m_rect.top + s.cy;
	CheckClipped();
	Invalidate(TRUE);
}

void CDeviceViewText::SetTextAndResizeToWrapped(LPCTSTR t)
{
	_SetText(t);
	if (!m_ptszText)
	{
		m_rect.right = m_rect.left;
		m_rect.bottom = m_rect.top;
		Invalidate(TRUE);
		return;
	}
	RECT rect = {m_rect.left, m_rect.top, g_sizeImage.cx, m_rect.top + 1};
	HDC hDC = CreateCompatibleDC(NULL);
	if (hDC != NULL)
	{
		HGDIOBJ hOld = NULL;
		if (m_hFont)
			hOld = SelectObject(hDC, m_hFont);
		DrawText(hDC, m_ptszText, -1, &rect, DT_CALCRECT | DT_NOPREFIX | DT_WORDBREAK);
		if (m_hFont)
			SelectObject(hDC, hOld);
		DeleteDC(hDC);
	}
	m_rect = rect;
	m_bWrap = TRUE;
	CheckClipped();
	Invalidate(TRUE);
}

void CDeviceViewText::SetWrap(BOOL bWrap)
{
	m_bWrap = bWrap;
	Invalidate();
}

void CDeviceViewText::Invalidate(BOOL bForce)
{
	if (m_ptszText || bForce)
		m_view.Invalidate();
}

void CDeviceViewText::OnPaint(HDC hDC)
{
	if (!m_ptszText)
		return;

	SetTextColor(hDC, m_rgbText);
	SetBkColor(hDC, m_rgbBk);
	SetBkMode(hDC, OPAQUE);
	RECT rect = m_rect;
	HGDIOBJ hOld = NULL;
	if (m_hFont)
		hOld = SelectObject(hDC, m_hFont);
	DrawText(hDC, m_ptszText, -1, &rect, DT_NOPREFIX | (m_bWrap ? DT_WORDBREAK : 0) | DT_RIGHT | DT_END_ELLIPSIS);
	if (m_hFont)
		SelectObject(hDC, hOld);
}

// We will have to know the view's scrolling offset to adjust the tooltip's position.
void CDeviceViewText::OnMouseOver(POINT point)
{
	// Tooltip only if the callout text is clipped.
	if (m_bClipped)
	{
		TOOLTIPINITPARAM ttip;
		ttip.hWndParent = GetParent(m_view.m_hWnd);  // Parent is the page window.
		ttip.iSBWidth = 0;
		ttip.dwID = 0;
		ttip.hWndNotify = m_view.m_hWnd;
		ttip.tszCaption = GetText();
		CFlexToolTip::UpdateToolTipParam(ttip);
	} else
		CFlexWnd::s_ToolTip.SetToolTipParent(NULL);
}

DEVCTRLHITRESULT CDeviceViewText::HitTest(POINT test)
{
	if (PtInRect(&m_rect, test))
		return DCHT_CAPTION;

	return DCHT_NOHIT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cdeviceview.h ===
//-----------------------------------------------------------------------------
// File: cdeviceview.h
//
// Desc: CDeviceView is a window class derived from CFlexWnd.  It represents
//       the device view window in which the device and callouts are drawn.
//       Each CDeviceView only represents one view.  A device that has more
//       than one view should have a corresponding number of CDeviceView for it.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifdef FORWARD_DECLS


	enum DVIMAGE;

	class CDeviceView;

#define DEFAULTVIEWSBWIDTH 11


#else // FORWARD_DECLS

#ifndef __CDEVICEVIEW_H__
#define __CDEVICEVIEW_H__


enum DVIMAGE {
	DVI_IMAGE,
	DVI_THUMB,
	DVI_SELTHUMB
};


class CDeviceView : public CFlexWnd
{
private:
friend class CDeviceUI;	// CDeviceUI has exclusive right to create/destroy views
friend class CDIDeviceActionConfigPage;
	CDeviceView(CDeviceUI &ui);
	~CDeviceView();
	CDeviceUI &m_ui;

public:
	// Header information (for list view)
	BOOL CalculateHeaderRect();  // Compute rect used for headers.

	// control information
	int GetNumControls();
	CDeviceControl *GetControl(int nControl);
	CDeviceControl *GetControlFromOfs(DWORD dwOfs)
		{ return GetControl(GetIndexFromOfs(dwOfs)); }

	// text information
	int GetNumTexts();
	CDeviceViewText *GetText(int nText);

	// text addition
	CDeviceViewText *NewText();
	CDeviceViewText *AddText(
		HFONT, COLORREF, COLORREF, const RECT &, LPCTSTR text);
	CDeviceViewText *AddText(
		HFONT, COLORREF, COLORREF, const POINT &, LPCTSTR text);
	CDeviceViewText *AddWrappedLineOfText(
		HFONT, COLORREF, COLORREF, LPCTSTR text);

	void SetImage(CBitmap *&refpbm);
	void SetImagePath(LPCTSTR tszPath);

	// imaging
	CBitmap *GetImage(DVIMAGE dvi);
	
	// editing
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	void SelectImages();
	void EditMenu(POINT point, CDeviceControl *pControl = NULL);
#endif
//@@END_MSINTERNAL
	void Remove(CDeviceControl *pControl);
	void RemoveAll(BOOL bUser = TRUE);
	BOOL DoesCalloutOtherThanSpecifiedExistForOffset(CDeviceControl *, DWORD);
	BOOL DoesCalloutExistForOffset(DWORD);
	BOOL IsUnassignedOffsetAvailable();

	int GetViewIndex();

	int GetIndexFromOfs(DWORD dwOfs);  // For writing to INI

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	BOOL InMoveOverlayStateForControl(CDeviceControl *pControl);
#endif
//@@END_MSINTERNAL

	void MakeMissingImages();

	CDeviceControl *NewControl();

protected:
	virtual void OnPaint(HDC hDC);
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	virtual LRESULT OnCommand(WORD wNotifyCode, WORD wID, HWND hWnd);
#endif
//@@END_MSINTERNAL
	virtual void OnMouseOver(POINT point, WPARAM fwKeys);
	virtual void OnClick(POINT point, WPARAM fwKeys, BOOL bLeft);
	virtual void OnDoubleClick(POINT point, WPARAM fwKeys, BOOL bLeft);
	virtual void OnWheel(POINT point, WPARAM wParam);
	virtual LRESULT WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
	// helpers
	void Unpopulate(BOOL bInternalOnly = FALSE);
	
	// images/visualization
	CBitmap *m_pbmImage, *m_pbmThumb, *m_pbmSelThumb;
	LPTSTR m_ptszImagePath;
	CBitmap *GrabViewImage();

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	void ManualLoadImage(LPCTSTR tszPath);
#endif
//@@END_MSINTERNAL
	LPCTSTR GetImagePath() { return m_ptszImagePath; }

	// headers
	BOOL m_bControlHeaderClipped, m_bActionHeaderClipped;  // Whether the header labels are clipped (flag for tooltip).
	RECT m_HeaderRectControl[2];  // 2 possible columns. Coord relative to parent's client space.
	RECT m_HeaderRectAction[2];  // 2 possible columns. Coord relative to parent's client space.

	// controls
	CArray<CDeviceControl *, CDeviceControl *&> m_arpControl;

	// text
	CArray<CDeviceViewText *, CDeviceViewText *&> m_arpText;
	POINT m_ptNextWLOText;

	// Special painting
	virtual void DoOnPaint(HDC hDC);
	BOOL m_bForcePaint;  // This indicates that we need painting even if GetUpdateRect returns FALSE.

	// Sort assigned for keyboard devices
	void SwapControls(int i, int j);
	void SortAssigned(BOOL bSort);
	void SortCallouts(int iStart, int iEnd);

	// editting state machine
	int m_SuperState, m_State, m_SubState;
	int m_OldSuperState, m_OldState, m_OldSubState;
	CDeviceControl *m_pControlContext;
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	BOOL InEditState();
	void SetEditState(UINT cmd);
	void StateEvent(POINT point, BOOL bClick, BOOL bLeft, WPARAM nKeyState);
	void EndState();
	void IndicateState(BOOL bFirst = FALSE);
	void EndEditState();

	void SaveOrExport();
	BOOL WriteToINI();
	HRESULT ExportCodeTo(LPCTSTR tszFile);
#endif
//@@END_MSINTERNAL

	// scrolling (vertical only)
	BOOL m_bScrollEnable;
	int m_nScrollOffset;
	int m_nViewHeight;
public:
	void EnableScrolling() {m_bScrollEnable = TRUE;}	
	void ScrollToMakeControlVisible(const RECT &rc);
	void CalcDimensions();
private:
	void DisableScrollBar();
	void EnableScrollBar();
	CFlexScrollBar m_sb;
};


#endif //__CDEVICEVIEW_H__

#endif // FORWARD_DECLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cdeviceui.cpp ===
/******************************************************************************
 * File: CDeviceUI.cpp
 *
 * Desc:
 *
 * CDeviceUI is a helper that holds all the views and a bunch of
 * information for a specific device.  It has a CFlexWnd whose
 * handler it sets to the CDeviceView for the current view,
 * thus reusing one window to implement multiple pages.
 *
 * All CDeviceViews and CDeviceControls have a reference to the CDeviceUI
 * that created them (m_ui).  Thus, they also have access to the
 * CUIGlobals, since CDeviceUI has a reference to them (m_ui.m_uig).
 * CDeviceUI also provides the following read-only public variables
 * for convenience, all referring to the device this CDeviceUI
 * represents:
 * 
 * const DIDEVICEINSTANCEW &m_didi;
 * const LPDIRECTINPUTDEVICE8W &m_lpDID;
 * const DIDEVOBJSTRUCT &m_os;
 *
 * See usefuldi.h for a description of DIDEVOBJSTRUCT.
 *
 * CDeviceUI communicates to the rest of the UI via the CDeviceUINotify
 * abstract base class.  Another class (in our case CDIDeviceActionConfigPage)
 * must derive from CDeviceUINotify, and define the DeviceUINotify() and
 * IsControlMapped() virtual functions.  This derived class must be passed as
 * the last parameter to CDeviceUI's Init() function.  All the views and 
 * controls within the views notify the UI of user actions via m_ui.Notify(),
 * so that all actionformat manipulation can be done in the page class.  The
 * views and controls themselves never touch the actionformat.  See the
 * DEVICEUINOTIFY structure below for information on the parameter passed
 * through Notify()/DeviceUINotify().
 *
 * Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
 *
 ***************************************************************************/

#include "common.hpp"
#include <dinputd.h>
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
#include <initguid.h>
#include "..\dx8\dimap\dimap.h"
#endif
//@@END_MSINTERNAL
#include "configwnd.h"

#define DIPROP_MAPFILE MAKEDIPROP(0xFFFD)

CDeviceUI::CDeviceUI(CUIGlobals &uig, IDIConfigUIFrameWindow &uif) :
	m_uig(uig), m_UIFrame(uif),
	m_didi(m_priv_didi), m_lpDID(m_priv_lpDID), m_os(m_priv_os),
	m_pCurView(NULL),
	m_pNotify(NULL), m_hWnd(NULL), m_bInEditMode(FALSE)
{
	m_priv_lpDID = NULL;
}

CDeviceUI::~CDeviceUI()
{
	Unpopulate();
}

HRESULT CDeviceUI::Init(const DIDEVICEINSTANCEW &didi, LPDIRECTINPUTDEVICE8W lpDID, HWND hWnd, CDeviceUINotify *pNotify)
{tracescope(__ts, _T("CDeviceUI::Init()...\n"));
	// save the params
	m_priv_didi = didi;
	m_priv_lpDID = lpDID;
	m_pNotify = pNotify;
	m_hWnd = hWnd;

	// fail if we don't have lpDID
	if (m_lpDID == NULL)
	{
		etrace(_T("CDeviceUI::Init() was passed a NULL lpDID!\n"));
		return E_FAIL;
	}

	// fill the devobjstruct
	HRESULT hr = FillDIDeviceObjectStruct(m_priv_os, lpDID);
	if (FAILED(hr))
	{
		etrace1(_T("FillDIDeviceObjectStruct() failed, returning 0x%08x\n"), hr);
		return hr;
	}

	// view rect needs to be set before populating so the views are
	// created with the correct dimensions
	m_ViewRect = g_ViewRect;

	// populate
	hr = PopulateAppropriately(*this);
	if (FAILED(hr))
		return hr;

	// if there are no views, return
	if (GetNumViews() < 1)
	{
//@@BEGIN_MSINTERNAL
		// should be unnecessary, but wtheck...
//@@END_MSINTERNAL
		Unpopulate();
		return E_FAIL;
	}

	// show the first view
	SetView(0);

	return hr;
}

void CDeviceUI::Unpopulate()
{
	m_pCurView = NULL;

	for (int i = 0; i < GetNumViews(); i++)
	{
		if (m_arpView[i] != NULL)
			delete m_arpView[i];
		m_arpView[i] = NULL;
	}
	m_arpView.RemoveAll();

	Invalidate();
}

void CDeviceUI::SetView(int nView)
{
	if (nView >= 0 && nView < GetNumViews())
		SetView(m_arpView[nView]);
}

void CDeviceUI::SetView(CDeviceView *pView)
{
	if (m_pCurView != NULL)
		ShowWindow(m_pCurView->m_hWnd, SW_HIDE);

	m_pCurView = pView;

	if (m_pCurView != NULL)
		ShowWindow(m_pCurView->m_hWnd, SW_SHOW);
}

CDeviceView *CDeviceUI::GetView(int nView)
{
	if (nView >= 0 && nView < GetNumViews())
		return m_arpView[nView];
	else
		return NULL;
}

CDeviceView *CDeviceUI::GetCurView()
{
	return m_pCurView;
}

int CDeviceUI::GetViewIndex(CDeviceView *pView)
{
	if (GetNumViews() == 0)
		return -1;

	for (int i = 0; i < GetNumViews(); i++)
		if (m_arpView[i] == pView)
			return i;

	return -1;
}

int CDeviceUI::GetCurViewIndex()
{
	return GetViewIndex(m_pCurView);
}

// gets the thumbnail for the specified view,
// using the selected version if the view is selected
CBitmap *CDeviceUI::GetViewThumbnail(int nView)
{
	return GetViewThumbnail(nView, GetView(nView) == GetCurView());
}

// gets the thumbnail for the specified view,
// specifiying whether or not we want the selected version
CBitmap *CDeviceUI::GetViewThumbnail(int nView, BOOL bSelected)
{
	CDeviceView *pView = GetView(nView);
	if (pView == NULL)
		return NULL;

	return pView->GetImage(bSelected ? DVI_SELTHUMB : DVI_THUMB);
}

void CDeviceUI::DoForAllControls(DEVCTRLCALLBACK callback, LPVOID pVoid, BOOL bFixed)
{
	int nv = GetNumViews();
	for (int v = 0; v < nv; v++)
	{
		CDeviceView *pView = GetView(v);
		if (pView == NULL)
			continue;

		int nc = pView->GetNumControls();
		for (int c = 0; c < nc; c++)
		{
			CDeviceControl *pControl = pView->GetControl(c);
			if (pControl == NULL)
				continue;

			callback(pControl, pVoid, bFixed);
		}
	}
}

typedef struct _DFCIAO {
	DWORD dwOffset;
	DEVCTRLCALLBACK callback;
	LPVOID pVoid;
} DFCIAO;

void DoForControlIfAtOffset(CDeviceControl *pControl, LPVOID pVoid, BOOL bFixed)
{
	DFCIAO &dfciao = *((DFCIAO *)pVoid);

	if (pControl->GetOffset() == dfciao.dwOffset)
		dfciao.callback(pControl, dfciao.pVoid, bFixed);
}

void CDeviceUI::DoForAllControlsAtOffset(DWORD dwOffset, DEVCTRLCALLBACK callback, LPVOID pVoid, BOOL bFixed)
{
	DFCIAO dfciao;
	dfciao.dwOffset = dwOffset;
	dfciao.callback = callback;
	dfciao.pVoid = pVoid;
	DoForAllControls(DoForControlIfAtOffset, &dfciao, bFixed);
}

void SetControlCaptionTo(CDeviceControl *pControl, LPVOID pVoid, BOOL bFixed)
{
	pControl->SetCaption((LPCTSTR)pVoid, bFixed);
}

void CDeviceUI::SetAllControlCaptionsTo(LPCTSTR tszCaption)
{
	DoForAllControls(SetControlCaptionTo, (LPVOID)tszCaption);
}

void CDeviceUI::SetCaptionForControlsAtOffset(DWORD dwOffset, LPCTSTR tszCaption, BOOL bFixed)
{
	DoForAllControlsAtOffset(dwOffset, SetControlCaptionTo, (LPVOID)tszCaption, bFixed);
}

void CDeviceUI::Invalidate()
{
	if (m_pCurView != NULL)
		m_pCurView->Invalidate();
}

void CDeviceUI::SetEditMode(BOOL bEdit)
{
	if (bEdit == m_bInEditMode)
		return;

	m_bInEditMode = bEdit;
	Invalidate();
}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
BOOL CDeviceUI::WriteToINI()
{
	// JACK:  do not remove this
	class dumpandcleardeletenotes {
	public:
		dumpandcleardeletenotes(CDeviceUI &ui) : bFailed(FALSE), m_ui(ui) {m_ui.DumpDeleteNotes();}
		~dumpandcleardeletenotes() {if (!bFailed) m_ui.ClearDeleteNotes();}
		void SetFailed() {bFailed = TRUE;}
	private:
		BOOL bFailed;
		CDeviceUI &m_ui;
	} ___dacdn(*this);

	int failure__ids;
	BOOL bFailed = FALSE;
#define FAILURE(ids) {___dacdn.SetFailed(); failure__ids = ids; bFailed = TRUE; goto cleanup;}
	HINSTANCE hInst = NULL;
	LPFNGETCLASSOBJECT fpClassFactory = NULL;
	LPDIRECTINPUTMAPPERVENDORW lpDiMap = NULL;
	IClassFactory *pDiMapCF = NULL;

	// Writes the callout information to INI file
	// Get INI path first
	HRESULT hr;
	TCHAR szIniPath[MAX_PATH];
	DIPROPSTRING dips;
	LPDIRECTINPUT8 lpDI = NULL;
	LPDIRECTINPUTDEVICE8 lpDID = NULL;
	GUID guid;
	BOOL bUsedDefault;
	int r;
	DWORD dwError;
	DWORD diver = DIRECTINPUT_VERSION;
	DIDEVICEIMAGEINFOW *pDelImgInfo = NULL;

	hr = DirectInput8Create(g_hModule, diver, IID_IDirectInput8, (LPVOID*)&lpDI, NULL);
	if (FAILED(hr))
		FAILURE(IDS_DICREATEFAILED);

	GetDeviceInstanceGuid(guid);
	hr = lpDI->CreateDevice(guid, &lpDID, NULL);
	if (FAILED(hr))
		FAILURE(IDS_CREATEDEVICEFAILED);

	// Check device type.  If this is keyboard or mouse, don't need to saving anything.
	if ((m_priv_didi.dwDevType & 0xFF) == DI8DEVTYPE_KEYBOARD ||
	    (m_priv_didi.dwDevType & 0xFF) == DI8DEVTYPE_MOUSE)
		FAILURE(0);  // Fail silently. Do not display any error dialog

	ZeroMemory(&dips, sizeof(dips));
	dips.diph.dwSize = sizeof(dips);
	dips.diph.dwHeaderSize = sizeof(DIPROPHEADER);
	dips.diph.dwObj = 0;
	dips.diph.dwHow = DIPH_DEVICE;
	hr = lpDID->GetProperty(DIPROP_MAPFILE, &dips.diph);
	if (FAILED(hr))
		FAILURE(IDS_GETPROPMAPFILEFAILED);

#ifdef UNICODE
	lstrcpy(szIniPath, dips.wsz);
#else
	r = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK|WC_DEFAULTCHAR, dips.wsz, -1, szIniPath, MAX_PATH, _T("0"), &bUsedDefault);
	dwError = GetLastError();
	if (0 == r)
		FAILURE(IDS_WCTOMBFAILED);
#endif

	if (lstrlen(szIniPath) < 1)
		FAILURE(IDS_NOMAPFILEPATH);

	{
		int i;

		//////// Got map file name.  Now write information to the file in 2 steps:   ////////
		////////   write deleted views, write remaining views.                       ////////

		// Prepare deleted views array
		if (GetNumDeleteNotes())
		{
			pDelImgInfo = new DIDEVICEIMAGEINFOW[GetNumDeleteNotes()];
			if (!pDelImgInfo) FAILURE(IDS_ERROR_OUTOFMEMORY);
			for (int iDelIndex = 0; iDelIndex < GetNumDeleteNotes(); ++iDelIndex)
			{
				UIDELETENOTE Del;
				GetDeleteNote(Del, iDelIndex);
				pDelImgInfo[iDelIndex].dwFlags = DIDIFT_DELETE | (Del.eType == UIDNT_VIEW ? DIDIFT_CONFIGURATION : DIDIFT_OVERLAY);
				pDelImgInfo[iDelIndex].dwViewID = Del.nViewIndex;
				pDelImgInfo[iDelIndex].dwObjID = Del.dwObjID;
			}
		}

		// Initialize DIMAP class
		hInst = LoadLibrary(_T("DIMAP.DLL"));
		if (hInst)
			fpClassFactory = (LPFNGETCLASSOBJECT)GetProcAddress(hInst,"DllGetClassObject");
		if (!fpClassFactory)
			FAILURE(IDS_ERROR_CANTLOADDIMAP);

		hr = fpClassFactory(IID_IDirectInputMapClsFact, IID_IClassFactory, (void**)&pDiMapCF);
		if (FAILED(hr)) FAILURE(IDS_ERROR_CANTLOADDIMAP);
		hr = pDiMapCF->CreateInstance(NULL, IID_IDirectInputMapVendorIW, (void**)&lpDiMap);  // Create mapper object
		if (FAILED(hr)) FAILURE(IDS_ERROR_CANTLOADDIMAP);
		hr = lpDiMap->Initialize(&guid, dips.wsz, 0);  // Initialize with the INI file name
		if (FAILED(hr)) FAILURE(IDS_ERROR_CANTLOADDIMAP);

		// Prepare DIACTIONFORMAT for writing.
		DIDEVICEIMAGEINFOHEADERW ImgInfoHdr;
		LPDIACTIONFORMATW lpNewActFormat = NULL;

		// We can get the DIACTIONFORMAT for this device from the main CConfigWnd object.
		hr = m_UIFrame.GetActionFormatFromInstanceGuid(&lpNewActFormat, guid);
		if (FAILED(hr) || !lpNewActFormat)
			FAILURE(0);
		for (DWORD dwAct = 0; dwAct < lpNewActFormat->dwNumActions; ++dwAct)
			lpNewActFormat->rgoAction[dwAct].dwHow |= DIAH_HWDEFAULT;

		// Prepare DIDEVICEIMAGEINFOHEADER for writing.
		// Compute the number of DIDEVICEIMAGEINFO that we will need to fill out.
		DWORD dwNumImgInfo = 0;
		for (int i = 0; i < GetNumViews(); ++i)
			dwNumImgInfo += GetView(i)->GetNumControls() + 1;  // The view itself is one element.

		ImgInfoHdr.dwSize = sizeof(ImgInfoHdr);
		ImgInfoHdr.dwSizeImageInfo = sizeof(DIDEVICEIMAGEINFOW);
		ImgInfoHdr.dwcViews = GetNumViews();
		ImgInfoHdr.dwcAxes = 0;  // Not needed for writing.
		ImgInfoHdr.dwcButtons =  0;  // Not needed for writing.
		ImgInfoHdr.dwcPOVs =  0;  // Not needed for writing.

		// Send delete array first, but only if there is something to delete
		if (GetNumDeleteNotes())
		{
			ImgInfoHdr.dwBufferSize =
			ImgInfoHdr.dwBufferUsed	= GetNumDeleteNotes() * sizeof(DIDEVICEIMAGEINFOW);
			ImgInfoHdr.lprgImageInfoArray = pDelImgInfo;
			hr = lpDiMap->WriteVendorFile(lpNewActFormat, &ImgInfoHdr, 0);  // Write it
			if (FAILED(hr))
			{
				if (hr == E_ACCESSDENIED)
				{
					FAILURE(IDS_WRITEVENDORFILE_ACCESSDENIED);
				}
				else
				{
					FAILURE(IDS_ERROR_WRITEVENDORFILE_FAILED);
				}
			}
		}

		// Update a few fields for writing remaining views.
		ImgInfoHdr.dwBufferSize =
		ImgInfoHdr.dwBufferUsed = dwNumImgInfo * sizeof(DIDEVICEIMAGEINFOW);
		ImgInfoHdr.lprgImageInfoArray = new DIDEVICEIMAGEINFOW[dwNumImgInfo];
		if (!ImgInfoHdr.lprgImageInfoArray)
			FAILURE(IDS_ERROR_OUTOFMEMORY);

		// Get a default image filename so that if a view doesn't have one, we'll use the default.
		// For now, default image is the image used by the first view for which an image exists.
		TCHAR tszDefImgPath[MAX_PATH] = _T("");
		for (int iCurrView = 0; iCurrView < GetNumViews(); ++iCurrView)
		{
			CDeviceView *pView = GetView(iCurrView);
			if (pView->GetImagePath())
			{
				lstrcpy(tszDefImgPath, pView->GetImagePath());
				break;
			}
		}

		DWORD dwNextWriteOffset = 0;  // This is the index that the next write operation will write to.
		int dwViewImgOffset = 0;  // This is the index to be used for the next configuration image.
		// Now we fill in the DIDEVICEIMAGEINFO array by going through each view
		for (int iCurrView = 0; iCurrView < GetNumViews(); ++iCurrView)
		{
			CDeviceView *pView = GetView(iCurrView);

			// Convert image path from T to unicode
#ifndef UNICODE
			WCHAR wszImagePath[MAX_PATH];
			if (pView->GetImagePath())
				MultiByteToWideChar(CP_ACP, 0, pView->GetImagePath(), -1, wszImagePath, MAX_PATH);
			else
				MultiByteToWideChar(CP_ACP, 0, tszDefImgPath, -1, wszImagePath, MAX_PATH);
			wcscpy(ImgInfoHdr.lprgImageInfoArray[dwNextWriteOffset].tszImagePath, wszImagePath);
#else
			if (pView->GetImagePath())
				wcscpy(ImgInfoHdr.lprgImageInfoArray[dwNextWriteOffset].tszImagePath, pView->GetImagePath());
			else
				wcscpy(ImgInfoHdr.lprgImageInfoArray[dwNextWriteOffset].tszImagePath, tszDefImgPath);  // String with a space
#endif

			ImgInfoHdr.lprgImageInfoArray[dwNextWriteOffset].dwViewID = dwViewImgOffset;  // Points to the view offset
			ImgInfoHdr.lprgImageInfoArray[dwNextWriteOffset].dwFlags = DIDIFT_CONFIGURATION;
			++dwNextWriteOffset; // Increment the write index

			// Now iterate through the controls within this view
			for (int iCurrCtrl = 0; iCurrCtrl < pView->GetNumControls(); ++iCurrCtrl)
			{
				CDeviceControl *pCtrl = pView->GetControl(iCurrCtrl);
				pCtrl->FillImageInfo(&ImgInfoHdr.lprgImageInfoArray[dwNextWriteOffset]);  // Fill in control info
				ImgInfoHdr.lprgImageInfoArray[dwNextWriteOffset].dwViewID = dwViewImgOffset;  // Points to the view offset
				++dwNextWriteOffset; // Increment the write index
			}

			++dwViewImgOffset;  // Increment dwViewImgOffset once per view
		}

		// Write to vendor file
		hr = lpDiMap->WriteVendorFile(lpNewActFormat, &ImgInfoHdr, 0);
		delete[] ImgInfoHdr.lprgImageInfoArray;
		if (FAILED(hr))
		{
			if (hr == E_ACCESSDENIED)
			{
				FAILURE(IDS_WRITEVENDORFILE_ACCESSDENIED);
			}
			else
			{
				FAILURE(IDS_ERROR_WRITEVENDORFILE_FAILED);
			}
		}

		// Recreate the device instances to get the change
		DEVICEUINOTIFY uin;
		uin.msg = DEVUINM_RENEWDEVICE;
		Notify(uin);
	}

cleanup:
	delete[] pDelImgInfo;
	if (lpDiMap)
		lpDiMap->Release();
	if (pDiMapCF)
		pDiMapCF->Release();
	if (lpDID != NULL)
		lpDID->Release();
	if (lpDI != NULL)
		lpDI->Release();
	if (hInst)
		FreeLibrary(hInst);
	lpDiMap = NULL;
	pDiMapCF = NULL;
	lpDID = NULL;
	lpDI = NULL;
	hInst = NULL;

	if (!bFailed)
		FormattedMsgBox(g_hModule, m_hWnd, MB_OK | MB_ICONINFORMATION, IDS_MSGBOXTITLE_WRITEINISUCCEEDED, IDS_WROTEINITO, m_didi.tszInstanceName, szIniPath);
	else
	{
		switch (failure__ids)
		{
			case 0:
				break;  // Case for keyboards and mice where we don't want any msg box to pop up.

			case IDS_GETPROPVIDPIDFAILED:
			case IDS_GETPROPMAPFILEFAILED:
			case IDS_WRITEVENDORFILE_ACCESSDENIED:
				FormattedErrorBox(g_hModule, m_hWnd, IDS_MSGBOXTITLE_WRITEINIFAILED, IDS_WRITEVENDORFILE_ACCESSDENIED);
				break;

			case IDS_ERROR_WRITEVENDORFILE_FAILED:
				FormattedErrorBox(g_hModule, m_hWnd, IDS_MSGBOXTITLE_WRITEINIFAILED, failure__ids, hr);
				break;

			case IDS_ERROR_INIREAD:
				FormattedErrorBox(g_hModule, m_hWnd, IDS_MSGBOXTITLE_WRITEINIFAILED, IDS_ERROR_INIREAD);
				break;

			case IDS_DICREATEFAILED:
				FormattedErrorBox(g_hModule, m_hWnd, IDS_MSGBOXTITLE_WRITEINIFAILED, IDS_DICREATEFAILED, diver, hr);
				break;

			case IDS_CREATEDEVICEFAILED:
				FormattedErrorBox(g_hModule, m_hWnd, IDS_MSGBOXTITLE_WRITEINIFAILED, IDS_CREATEDEVICEFAILED, GUIDSTR(guid), hr);
				break;

			case IDS_WCTOMBFAILED:
				FormattedLastErrorBox(g_hModule, m_hWnd, IDS_MSGBOXTITLE_WRITEINIFAILED, IDS_WCTOMBFAILED, IDS_WCTOMBFAILED);
				break;

			case IDS_NOMAPFILEPATH:
				FormattedErrorBox(g_hModule, m_hWnd, IDS_MSGBOXTITLE_WRITEINIFAILED, IDS_NOMAPFILEPATH);
				break;

			case IDS_ERROR_OUTOFMEMORY:
				FormattedErrorBox(g_hModule, m_hWnd, IDS_MSGBOXTITLE_WRITEINIFAILED, IDS_ERROR_OUTOFMEMORY);
				break;

			default:
				FormattedErrorBox(g_hModule, m_hWnd, IDS_MSGBOXTITLE_WRITEINIFAILED, IDS_ERRORUNKNOWN);
				break;
		}
	}
	return FALSE;
#undef FAILURE
}
#endif
//@@END_MSINTERNAL

void CDeviceUI::SetDevice(LPDIRECTINPUTDEVICE8W lpDID)
{
	m_priv_lpDID = lpDID;
}

BOOL CDeviceUI::IsControlMapped(CDeviceControl *pControl)
{
	if (pControl == NULL || m_pNotify == NULL)
		return FALSE;

	return m_pNotify->IsControlMapped(pControl);
}

void CDeviceUI::Remove(CDeviceView *pView)
{
	if (pView == NULL)
		return;

	int i = GetViewIndex(pView);
	if (i < 0 || i >= GetNumViews())
	{
		assert(0);
		return;
	}

	if (pView == m_pCurView)
		m_pCurView = NULL;

	if (m_arpView[i] != NULL)
	{
		m_arpView[i]->RemoveAll();
		delete m_arpView[i];
	}
	m_arpView[i] = NULL;

	m_arpView.RemoveAt(i);

	if (m_arpView.GetSize() < 1)
		RequireAtLeastOneView();
	else if (m_pCurView == NULL)
	{
		SetView(0);
		NumViewsChanged();
	}
}

void CDeviceUI::RemoveAll()
{
	m_pCurView = NULL;

	for (int i = 0; i < GetNumViews(); i++)
	{
		if (m_arpView[i] != NULL)
			delete m_arpView[i];
		m_arpView[i] = NULL;
	}
	m_arpView.RemoveAll();

	RequireAtLeastOneView();
}

CDeviceView *CDeviceUI::NewView()
{
	// allocate new view, continuing on if it fails
	CDeviceView *pView = new CDeviceView(*this);
	if (pView == NULL)
		return NULL;

	// add view to array
	m_arpView.SetAtGrow(m_arpView.GetSize(), pView);

	// create view
	pView->Create(m_hWnd, m_ViewRect, FALSE);

	// let the page update to indicate viewness
	NumViewsChanged();

	return pView;
}

CDeviceView *CDeviceUI::UserNewView()
{
	CDeviceView *pView = NewView();
	if (!pView)
		return NULL;

	pView->AddWrappedLineOfText(
		(HFONT)m_uig.GetFont(UIE_PICCUSTOMTEXT),
		m_uig.GetTextColor(UIE_PICCUSTOMTEXT),
		m_uig.GetBkColor(UIE_PICCUSTOMTEXT),
		_T("Customize This View"));

	pView->MakeMissingImages();

	Invalidate();

	return pView;
}

void CDeviceUI::RequireAtLeastOneView()
{
	if (GetNumViews() > 0)
		return;

	CDeviceView *pView = NewView();
	if (!pView)
		return;

	pView->AddWrappedLineOfText(
		(HFONT)m_uig.GetFont(UIE_PICCUSTOMTEXT),
		m_uig.GetTextColor(UIE_PICCUSTOMTEXT),
		m_uig.GetBkColor(UIE_PICCUSTOMTEXT),
		_T("Customize This View"));
	pView->AddWrappedLineOfText(
		(HFONT)m_uig.GetFont(UIE_PICCUSTOM2TEXT),
		m_uig.GetTextColor(UIE_PICCUSTOM2TEXT),
		m_uig.GetBkColor(UIE_PICCUSTOM2TEXT),
		_T("The UI requires at least one view per device"));

	pView->MakeMissingImages();

	SetView(pView);
}

void CDeviceUI::NumViewsChanged()
{
	DEVICEUINOTIFY uin;
	uin.msg = DEVUINM_NUMVIEWSCHANGED;
	Notify(uin);
}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
void CDeviceUI::NoteDeleteView(CDeviceView *pView)
{
	assert(pView != NULL);

	if (pView)
		NoteDeleteView(pView->GetViewIndex());
}

void CDeviceUI::NoteDeleteControl(CDeviceControl *pControl)
{
	assert(pControl != NULL);

	if (pControl)
		NoteDeleteControl(pControl->GetViewIndex(),
		                  pControl->GetControlIndex(),
		                  pControl->GetOffset());
}

void CDeviceUI::NoteDeleteView(int nView)
{
	NoteDeleteAllControlsForView(GetView(nView));

	int last = m_DeleteNotes.GetSize();
	m_DeleteNotes.SetSize(last + 1);
	
	UIDELETENOTE &uidn = m_DeleteNotes[last];
	uidn.eType = UIDNT_VIEW;
	uidn.nViewIndex = nView;
}

void CDeviceUI::NoteDeleteControl(int nView, int nControl, DWORD dwObjID)
{
	int last = m_DeleteNotes.GetSize();
	m_DeleteNotes.SetSize(last + 1);
	
	UIDELETENOTE &uidn = m_DeleteNotes[last];
	uidn.eType = UIDNT_CONTROL;
	uidn.nViewIndex = nView;
	uidn.nControlIndex = nControl;
	uidn.dwObjID = dwObjID;
}

int CDeviceUI::GetNumDeleteNotes()
{
	return m_DeleteNotes.GetSize();
}

BOOL CDeviceUI::GetDeleteNote(UIDELETENOTE &uidn, int i)
{
	if (i >= 0 && i < GetNumDeleteNotes())
	{
		uidn = m_DeleteNotes[i];
		return TRUE;
	}

	return FALSE;
}

void CDeviceUI::ClearDeleteNotes()
{
	m_DeleteNotes.RemoveAll();
}

void CDeviceUI::DumpDeleteNotes()
{
	utilstr s, suffix;

	suffix.Format(_T("for device %s"), QSAFESTR(m_didi.tszInstanceName));

	int n = GetNumDeleteNotes();

	if (!n)
	{
		s.Format(_T("No DeleteNotes %s\n\n"), suffix.Get());
		trace(s.Get());
		return;
	}

	s.Format(_T("%d DeleteNotes %s...\n"), n, suffix.Get());

	tracescope(__ts, s.Get());

	for (int i = 0; i < n; i++)
	{
		UIDELETENOTE uidn;
		GetDeleteNote(uidn, i);

		switch (uidn.eType)
		{
			case UIDNT_VIEW:
				s.Format(_T("%02d: View %d\n"), i, uidn.nViewIndex);
				break;

			case UIDNT_CONTROL:
				s.Format(_T("%02d: Control %d on View %d, dwObjID = 0x%08x (%d)\n"),
					i, uidn.nControlIndex, uidn.nViewIndex, uidn.dwObjID, uidn.dwObjID);
				break;
		}

		trace(s.Get());
	}

	trace(_T("\n"));
}

void CDeviceUI::NoteDeleteAllControlsForView(CDeviceView *pView)
{
	if (!pView)
		return;

	for (int i = 0; i < pView->GetNumControls(); i++)
		NoteDeleteControl(pView->GetControl(i));
}

void CDeviceUI::NoteDeleteAllViews()
{
	for (int i = 0; i < GetNumViews(); i++)
		NoteDeleteView(GetView(i));
}
#endif
//@@END_MSINTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cdeviceviewtext.h ===
//-----------------------------------------------------------------------------
// File: cdeviceviewtext.h
//
// Desc: CDeviceViewText is a class representing a text string in the view
//       window. It is used when the view type is a list view.  CDeviceViewText
//       will print the text of the control name, while CDeviceControl will
//       print the text of the action assigned to that control.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifdef FORWARD_DECLS


	class CDeviceViewText;


#else // FORWARD_DECLS

#ifndef __CDEVICEVIEWTEXT_H__
#define __CDEVICEVIEWTEXT_H__


class CDeviceViewText
{
private:
	friend class CDeviceView;	// CDeviceView has exclusive right to create/destroy views
	CDeviceViewText(CDeviceUI &ui, CDeviceView &view);
	~CDeviceViewText();
	CDeviceView &m_view;
	CDeviceUI &m_ui;

public:
	// set look/position/text
	void SetLook(HFONT, COLORREF, COLORREF);
	void SetRect(const RECT &r);
	void SetPosition(int, int);
	void SetPosition(POINT p) {SetPosition(p.x, p.y);}
	void SetText(LPCTSTR);
	void SetTextAndResizeTo(LPCTSTR);
	void SetTextAndResizeToWrapped(LPCTSTR);
	void SetWrap(BOOL bWrap = FALSE);

	LPCTSTR GetText() { return m_ptszText; }

	// get dimensions
	RECT GetRect() {return m_rect;}
	int GetHeight() {return m_rect.bottom - m_rect.top;}
	int GetMinY() {return m_rect.top;}
	int GetMaxY() {return m_rect.bottom;}

	// hit testing (in coord's relative to view's origin)
	DEVCTRLHITRESULT HitTest(POINT test);

	void OnPaint(HDC);
	void OnMouseOver(POINT point);

private:
	void _SetText(LPCTSTR t);
	void CheckClipped();
	void Invalidate(BOOL bForce = FALSE);

	HFONT m_hFont;
	COLORREF m_rgbText, m_rgbBk;
	RECT m_rect;
	BOOL m_bWrap;
	BOOL m_bClipped;
	LPTSTR m_ptszText;
};


#endif //__CDEVICEVIEWTEXT_H__

#endif // FORWARD_DECLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cdftest.cpp ===
#include "common.hpp"


//QueryInterface
STDMETHODIMP CDirectInputConfigUITest::QueryInterface(REFIID iid, LPVOID* ppv)
{
   //null the out param
	*ppv = NULL;

	if ((iid == IID_IUnknown) 
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
#ifdef DBG
	   || (iid == IID_IDirectInputConfigUITest) 
#endif
#endif
//@@END_MSINTERNAL
     )
	{
	   *ppv = this;
	   AddRef();	   
	   return S_OK;
	}

	return E_NOINTERFACE;
}


//AddRef
STDMETHODIMP_(ULONG) CDirectInputConfigUITest::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}							


//Release
STDMETHODIMP_(ULONG) CDirectInputConfigUITest::Release()
{

   if (InterlockedDecrement(&m_cRef) == 0)
   {
	   delete this;
	   return 0;
   }

   return m_cRef;
}


//TestConfigUI
STDMETHODIMP CDirectInputConfigUITest::TestConfigUI(LPTESTCONFIGUIPARAMS params)
{
	return RunDFTest(params);
}


//constructor
CDirectInputConfigUITest::CDirectInputConfigUITest()
{
	//set ref count
	m_cRef = 1;
}


//destructor
CDirectInputConfigUITest::~CDirectInputConfigUITest()
{
	// not necessary to cleanup action format here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cdftest.h ===
#ifndef __CDFTEST_H__
#define __CDFTEST_H__


//framework implementation class
class CDirectInputConfigUITest : public IDirectInputConfigUITest
{

public:

   	//IUnknown fns
	STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
	STDMETHOD_(ULONG, AddRef) ();
	STDMETHOD_(ULONG, Release) ();

	//own fns
	STDMETHOD (TestConfigUI) (LPTESTCONFIGUIPARAMS params);

	//construction / destruction
	CDirectInputConfigUITest();
	~CDirectInputConfigUITest();

protected:

	//reference count
	LONG m_cRef;
};


#endif //__CDFTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cfguitrace.h ===
//-----------------------------------------------------------------------------
// File: cfguitrace.h
//
// Desc: Contains all trace functionalities used by the UI.
//       Define __CFGUI_TRACE__TO_FILE to have output written to a file.
//       Define __CFGUI_TRACE__TO_DEBUG_OUT to direct output to a debugger.
//       These two symbols can coexist, and are defined in defines.h.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __CFGUI_TRACE_H__
#define __CFGUI_TRACE_H__


#ifdef UNICODE
#define _tfWSTR _T("%s")
#define _tfSTR _T("%S")
#else
#define _tfWSTR _T("%S")
#define _tfSTR _T("%s")
#endif


enum __cfgui_tracetype {
	__cfgui_tracetype_ERROR,
	__cfgui_tracetype_INFO,
};


#ifdef NTRACE

#define tracescope(t,s) (void(0))

#define etrace(a) (void(0))
#define etrace1(a,b) (void(0))
#define etrace2(a,b,c) (void(0))
#define etrace3(a,b,c,d) (void(0))
#define etrace4(a,b,c,d,e) (void(0))
#define etrace5(a,b,c,d,e,f) (void(0))
#define etrace6(a,b,c,d,e,f,g) (void(0))
#define etrace7(a,b,c,d,e,f,g,h) (void(0))
#define trace(a) (void(0))
#define trace1(a,b) (void(0))
#define trace2(a,b,c) (void(0))
#define trace3(a,b,c,d) (void(0))
#define trace4(a,b,c,d,e) (void(0))
#define trace5(a,b,c,d,e,f) (void(0))
#define trace6(a,b,c,d,e,f,g) (void(0))
#define trace7(a,b,c,d,e,f,g,h) (void(0))

#define traceDWORD(v) (void(0))
#define traceUINT(v) (void(0))
#define traceLONG(v) (void(0))
#define traceHEX(v) (void(0))
#define traceHEXPTR(v) (void(0))
#define traceWSTR(v) (void(0))
#define traceSTR(v) (void(0))
#define traceTSTR(v) (void(0))
#define traceGUID(v) (void(0))
#define traceBOOL(v) (void(0))
#define tracePOINT(v) (void(0))
#define traceSIZE(v) (void(0))
#define traceRECT(v) (void(0))
#define traceRECTDIM(v) (void(0))
#define traceSUPERSTR(v) (void(0))

#else

void __cfgui_trace(__cfgui_tracetype, LPCTSTR, ...);

class __cfgui_out_filescope
{
friend class __cfgui_tracescope;
	__cfgui_out_filescope(bool bInternal = false);
	~__cfgui_out_filescope();
friend void __cfgui_trace(__cfgui_tracetype, LPCTSTR, ...);
	bool m_bInternal;
};

class __cfgui_tracescope
{
	__cfgui_out_filescope fs;
public:
	__cfgui_tracescope(LPCTSTR);
	~__cfgui_tracescope();
};

#define tracescope(t,s) __cfgui_tracescope t(s)

#define etrace(a) __cfgui_trace(__cfgui_tracetype_ERROR, a)
#define etrace1(a,b) __cfgui_trace(__cfgui_tracetype_ERROR, a,b)
#define etrace2(a,b,c) __cfgui_trace(__cfgui_tracetype_ERROR, a,b,c)
#define etrace3(a,b,c,d) __cfgui_trace(__cfgui_tracetype_ERROR, a,b,c,d)
#define etrace4(a,b,c,d,e) __cfgui_trace(__cfgui_tracetype_ERROR, a,b,c,d,e)
#define etrace5(a,b,c,d,e,f) __cfgui_trace(__cfgui_tracetype_ERROR, a,b,c,d,e,f)
#define etrace6(a,b,c,d,e,f,g) __cfgui_trace(__cfgui_tracetype_ERROR, a,b,c,d,e,f,g)
#define etrace7(a,b,c,d,e,f,g,h) __cfgui_trace(__cfgui_tracetype_ERROR, a,b,c,d,e,f,g,h)
#define trace(a) __cfgui_trace(__cfgui_tracetype_INFO, a)
#define trace1(a,b) __cfgui_trace(__cfgui_tracetype_INFO, a,b)
#define trace2(a,b,c) __cfgui_trace(__cfgui_tracetype_INFO, a,b,c)
#define trace3(a,b,c,d) __cfgui_trace(__cfgui_tracetype_INFO, a,b,c,d)
#define trace4(a,b,c,d,e) __cfgui_trace(__cfgui_tracetype_INFO, a,b,c,d,e)
#define trace5(a,b,c,d,e,f) __cfgui_trace(__cfgui_tracetype_INFO, a,b,c,d,e,f)
#define trace6(a,b,c,d,e,f,g) __cfgui_trace(__cfgui_tracetype_INFO, a,b,c,d,e,f,g)
#define trace7(a,b,c,d,e,f,g,h) __cfgui_trace(__cfgui_tracetype_INFO, a,b,c,d,e,f,g,h)

#define traceDWORD(v) trace1(_T(#v) _T(" = %u\n"), v)
#define traceUINT(v) trace1(_T(#v) _T(" = %u\n"), v)
#define traceLONG(v) trace1(_T(#v) _T(" = %d\n"), v)
#define traceHEX(v) trace1(_T(#v) _T(" = 0x%08x\n"), v)
#define traceHEXPTR(v) trace1(_T(#v) _T(" = 0x%p\n"), v)
#define traceWSTR(v) traceTSTR(v)
#define traceSTR(v) traceTSTR(v)
#define traceTSTR(v) trace1(_T(#v) _T(" = %s\n"), QSAFESTR(v))
#define traceGUID(v) trace1(_T(#v) _T(" = %s\n"), GUIDSTR(v))
#define traceBOOL(v) trace1(_T(#v) _T(" = %s\n"), BOOLSTR(v))
#define tracePOINT(v) trace1(_T(#v) _T(" = %s\n"), POINTSTR(v))
#define traceSIZE(v) trace1(_T(#v) _T(" = %s\n"), SIZESTR(v))
#define traceRECT(v) trace1(_T(#v) _T(" = %s\n"), RECTSTR(v))
#define traceRECTDIM(v) trace1(_T(#v) _T(" = %s\n"), RECTDIMSTR(v))
#define traceSUPERSTR(v) trace1(_T(#v) _T(" = %s\n"), SUPERSTR(v))


#endif

#endif //__CFGUI_TRACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cfguitrace.cpp ===
//-----------------------------------------------------------------------------
// File: cfguitrace.cpp
//
// Desc: Contains all trace functionalities used by the UI.
//       Define __CFGUI_TRACE__TO_FILE to have output written to a file.
//       Define __CFGUI_TRACE__TO_DEBUG_OUT to direct output to a debugger.
//       These two symbols can coexist, and are defined in defines.h.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


#ifndef NTRACE


const int mindepth = 0;
static int depth = mindepth;

static int filedepth = 0;
static FILE *file = NULL;

__cfgui_out_filescope::__cfgui_out_filescope(bool bInternal)
	: m_bInternal(bInternal)
{
#ifdef __CFGUI_TRACE__TO_FILE

	static bool bFirst = true;

	filedepth++;
	
	if (filedepth == 1)
	{

		assert(file == NULL);
		if (file == NULL)
			file = fopen("c:\\cfguilog.txt", bFirst ? "w+t" : "a+t");

		assert(file != NULL);
		if (file != NULL)
		{
			if (bFirst)
			{
				time_t curtime;
				time(&curtime);
				LPSTR str = _strdup(ctime(&curtime));
				if (str != NULL)
				{
					LPSTR last = str + strlen(str) - 1;
					if (last >= str && *last == '\n')
						*last = 0;
				}
				fprintf(file,
"\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"DInput Mapper Device Configuration UI\n"
"New logfile session started at %s.\n"
"--------------------------------------------------------------------------------\n"
"\n"
						, str);
				free(str);

			}
			bFirst = false;
		}
	}

#endif
}

__cfgui_out_filescope::~__cfgui_out_filescope()
{
#ifdef __CFGUI_TRACE__TO_FILE

	assert(filedepth > 0);

	if (filedepth < 0)
		filedepth = 0;

	if (filedepth > 0)
	{
		filedepth--;

		assert(file != NULL);
		if (file != NULL)
		{
			if (filedepth == 0)
			{
				fclose(file);
				file = NULL;
			}
			else if (!m_bInternal)
				fflush(file);
		}			
	}

#endif
}

static void __cfgui_out(LPCTSTR str)
{
#ifdef __CFGUI_TRACE__TO_FILE

	assert(file != NULL);
	if (file != NULL)
		_ftprintf(file, str);

#endif

#ifdef __CFGUI_TRACE__TO_DEBUG_OUT

	OutputDebugString(str);

#endif
}

__cfgui_tracescope::__cfgui_tracescope(LPCTSTR str)
{
	if (str != NULL)
		trace(str);
	depth++;
}

__cfgui_tracescope::~__cfgui_tracescope()
{
	depth--;
}

LPTSTR splitlines(LPTSTR);

/*void test(LPTSTR str)
{
	LPTSTR orig = _tcsdup(str), str2 = _tcsdup(str);
	static TCHAR buf[1024];
	int i = 1;
	for (LPTSTR token = splitlines(str2);
		 token != NULL;
		 token = splitlines(NULL), i++)
	{
		LPTSTR t = _tcsdup(token);
		int len = _tcslen(t);
		BOOL b = t[len - 1] == _T("\n")[0];
		if (b)
			t[len - 1] = _T("\0")[0];
		_stprintf(buf, _T("%02d: \"%s\" (%s)\n"), i, t, BOOLSTR(b));
		__cfgui_out(buf);
		free(t);
	}
	free(str2);
	free(orig);
}
*/

void __cfgui_trace(__cfgui_tracetype t, LPCTSTR format, ...)
{
	__cfgui_out_filescope fs(true);
	int i;

	bool bError = t == __cfgui_tracetype_ERROR;

	LPCTSTR errorprefix = _T("ERROR! ");
	const int prefixlen = 8, depthbuflen = 1024, buflen = 4096;
	static TCHAR prefixbuf[prefixlen + depthbuflen + 1] = _T("cfgUI:  "), buf[buflen];
	static LPTSTR depthbuf = prefixbuf + prefixlen;
	static TCHAR space = _T(" ")[0];
	static TCHAR zero = _T("\0")[0];
	static TCHAR endl = _T("\n")[0];
	static int last = -2;
	static bool bendl = true;

	if (last == -2)
	{
		for (i = 0; i < depthbuflen; i++)
			depthbuf[i] = space;
		depthbuf[i] = zero;
		last = -1;
/*
		test(_T("aopiwfoiefef\n\nwpoeifef\naefoie\n\n\nwpoeifwef asefeiof"));
		test(_T("\npw\noiefpow ij e f owpiejf\n\n"));
		test(_T("\n\npw\noiefpo wije\n\n   \n\n\nfowpie jf   \n"));
*/	}

	if (last != -1)
	{
		depthbuf[last] = space;
	}

	int d = depth;
	if (d < mindepth)
		d = mindepth;
	
	last = d * 4;
	if (last >= depthbuflen)
		last = depthbuflen - 1;

	depthbuf[last] = zero;

	va_list args;
	va_start(args, format);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,format);					// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))		// find each %p
			*(psz+1) = 'x';						// replace each %p with %x
		_vstprintf(buf, szDfs, args);	   		// use the local format string
	}
#else
	{
		_vstprintf(buf, format, args);
	}
#endif
	va_end(args);

	LPTSTR tempbuf = _tcsdup(buf);

	bool doprefix = bendl;
	for (LPTSTR token = splitlines(tempbuf);
		 token != NULL;
		 token = splitlines(NULL))
	{
		if (doprefix)
			__cfgui_out(depthbuf/*prefixbuf*/);
		if (bError && doprefix)
			__cfgui_out(errorprefix);
		__cfgui_out(token);
		bendl = token[_tcslen(token) - 1] == endl;
		doprefix = bendl;
	}

	free(tempbuf);
}

LPTSTR splitlines(LPTSTR split)
{
	static LPTSTR str = NULL;
	static int last = 0;
	static TCHAR save = _T("!")[0];
	static TCHAR newline = _T("\n")[0], zero = _T("\0")[0];

	if (split != NULL)
		str = split;
	else
	{
		if (str == NULL)
			return NULL;

		str[last] = save;
		str += last;
	}

	if (str[0] == zero)
	{
		str = NULL;
		return NULL;
	}

	LPCTSTR at = str, f = _tcschr(at, newline);
	last = f ? f - at + 1: _tcslen(at);

	save = str[last];
	str[last] = zero;

	return str;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cfrmwrk.cpp ===
//-----------------------------------------------------------------------------
// File: cfrmwrk.cpp
//
// Desc: CDirectInputActionFramework is the outer-most layer of the UI. It
//       contains everything else. Its functionality is provided by one
//       method: ConfigureDevices.
//
//       InternalConfigureDevices is called by the CDirectInputActionFramework
//       class. This function actually contains the initialization code and
//       the message pump for the UI.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


//QueryInterface
STDMETHODIMP CDirectInputActionFramework::QueryInterface(REFIID iid, LPVOID* ppv)
{
	//null the out param
	*ppv = NULL;

	if ((iid == IID_IUnknown) || (iid == IID_IDIActionFramework))
	{
		*ppv = this;
		AddRef();
		return S_OK;
	}

	return E_NOINTERFACE;
}


//AddRef
STDMETHODIMP_(ULONG) CDirectInputActionFramework::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}


//Release
STDMETHODIMP_(ULONG) CDirectInputActionFramework::Release()
{

	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

// Manages auto loading/unloading WINMM.DLL
// There will only be one instance of this class: inside InternalConfigureDevicees.
class CWinMmLoader
{
public:
	CWinMmLoader()
	{
		if (!g_hWinMmDLL)
		{
			g_hWinMmDLL = LoadLibrary(_T("WINMM.DLL"));
			if (g_hWinMmDLL)
			{
				*(FARPROC*)(&g_fptimeSetEvent) = GetProcAddress(g_hWinMmDLL, "timeSetEvent");
			}
		}
	}
	~CWinMmLoader()
	{
		if (g_hWinMmDLL)
		{
			/*
             *  Make sure no new callbacks can get scheduled then sleep to 
             *  allow any pending ones to complete.
//@@BEGIN_MSINTERNAL
             *  Use 40ms as 20ms is the UI refresh interval
             *
             *  ISSUE-2000/11/21-MarcAnd 
             *      Should either have a more robust way to make sure no 
             *      timers are left running or at least use constants to 
             *      to make sure that if any timer interval is increased, 
             *      that this value is still long enough.
//@@END_MSINTERNAL
             */
            g_fptimeSetEvent = NULL;
            Sleep( 40 );
			FreeLibrary(g_hWinMmDLL);
			g_hWinMmDLL = NULL;
		}
	}
};


//@@BEGIN_MSINTERNAL
// Manages auto loading/unloading MSIMG32.DLL
// There will only be one instance of this class: inside InternalConfigureDevicees.
/*
class CMSImgLoader
{
public:
	CMSImgLoader()
	{
		if (!g_MSImg32)
		{
			g_MSImg32 = LoadLibrary(_T("MSIMG32.DLL"));
			if (g_MSImg32)
			{
				g_AlphaBlend = (ALPHABLEND)GetProcAddress(g_MSImg32, "AlphaBlend");
				if (!g_AlphaBlend)
				{ 
					FreeLibrary(g_MSImg32);
                    g_MSImg32 = NULL;
				}
			}
		}
	}
	~CMSImgLoader()
	{
		if (g_MSImg32)
		{
			FreeLibrary(g_MSImg32);
            g_MSImg32 = NULL;
            g_AlphaBlend = NULL;
		}
	}
};
*/
//@@END_MSINTERNAL


// internal, which api wraps around
static HRESULT InternalConfigureDevices(LPDICONFIGUREDEVICESCALLBACK lpdiCallback,
                                        LPDICONFIGUREDEVICESPARAMSW  lpdiCDParams,
                                        DWORD                        dwFlags,
                                        LPVOID                       pvRefData)
{
	tracescope(__ts, _T("InternalConfigureDevices()\n"));

//@@BEGIN_MSINTERNAL
//	CMSImgLoader g_MSImgLoadingHelper;  // Automatically call LoadLibrary and FreeLibrary on MSIMG32.DLL
//@@END_MSINTERNAL
	CWinMmLoader g_WinMmLoadingHelper;  // Automatically call LoadLibrary and FreeLibrary on WINMM.DLL

	// check that we're at least 256 colors
	HDC hMemDC = CreateCompatibleDC(NULL);
	if (hMemDC == NULL)
	{
		etrace(_T("Can't get a DC! Exiting.\n"));
		return E_FAIL;
	}

	int bpp = GetDeviceCaps(hMemDC, BITSPIXEL);
	DeleteDC(hMemDC);
	if (bpp < 8)
	{
		etrace1(_T("Screen is not at least 8bpp (bpp = %d)\n"), bpp);
		return E_FAIL;
	}

	// do it...
	{
		// create the globals
		CUIGlobals uig(
			dwFlags,
			lpdiCDParams->lptszUserNames,
			lpdiCDParams->dwcFormats,
			lpdiCDParams->lprgFormats,
			&(lpdiCDParams->dics),
			lpdiCDParams->lpUnkDDSTarget,
			lpdiCallback,
			pvRefData
		);
		HRESULT hr = uig.GetInitResult();
		if (FAILED(hr))
		{
			etrace(_T("CUIGlobals.Init() failed\n"));
			return hr;
		}

		// make sure the flexwnd window class is registered only during possible use
//@@BEGIN_MSINTERNAL
		// TODO: consider doing this wnd class stuff at dll scope, or doing it refcount-ish within flexwnd.cpp
//@@END_MSINTERNAL
		{
			struct flexwndscope {
				flexwndscope(CUIGlobals &uig) : m_uig(uig) {CFlexWnd::RegisterWndClass(m_uig.GetInstance());}
				~flexwndscope() {CFlexWnd::UnregisterWndClass(m_uig.GetInstance());}
				CUIGlobals &m_uig;
			} scope(uig);

			// create the main window
			CConfigWnd cfgWnd(uig);
			if (!cfgWnd.Create(lpdiCDParams->hwnd))
			{
				etrace(_T("Failed to create main window\n"));
				return E_FAIL;
			}

			// Initialize the shared tooltip object.
			RECT rc = {0, 0, 0, 0};
			CFlexWnd::s_ToolTip.Create(cfgWnd.m_hWnd, rc, TRUE);
			if (!CFlexWnd::s_ToolTip.m_hWnd)
			{
				etrace(_T("Failed to create tooltip window\n"));
				return E_FAIL;
			}
			::ShowWindow(CFlexWnd::s_ToolTip.m_hWnd, SW_HIDE);  // Hide window by default

			// enter message loop
			MSG msg;
			while (GetMessage(&msg, NULL, 0, 0))
			{
				// If this is a message for the parent window (game window), only dispatch if it's WM_PAINT.
				if (!cfgWnd.InRenderMode() && msg.hwnd == lpdiCDParams->hwnd && msg.message != WM_PAINT)
					continue;
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
		}

		CFlexWnd::s_ToolTip.Destroy();

		return uig.GetFinalResult();
	}
}


BOOL AreAcForsGood(LPDIACTIONFORMATW lpAcFors, DWORD dwNumAcFors)
{
	if (lpAcFors == NULL)
		return FALSE;

	if (dwNumAcFors < 1)
		return FALSE;

	if (lpAcFors->dwNumActions == 0)
		return FALSE;

	return TRUE;
}


//ConfigureDevices
STDMETHODIMP CDirectInputActionFramework::ConfigureDevices(
			LPDICONFIGUREDEVICESCALLBACK lpdiCallback,
			LPDICONFIGUREDEVICESPARAMSW  lpdiCDParams,
			DWORD                        dwFlags,
			LPVOID                       pvRefData)
{
	tracescope(__ts,_T("CDirectInputActionFramework::ConfigureDevices()\n"));

	trace(_T("\nConfigureDevices() called...\n\n"));

	// check parameters
	if (lpdiCDParams == NULL)
	{
		etrace(_T("NULL params structure passed to ConfigureDevices()\n"));
		return E_INVALIDARG;
	}

	// save passed params in case we change 'em
	LPDIACTIONFORMATW lpAcFors = lpdiCDParams->lprgFormats;
	DWORD dwNumAcFors = lpdiCDParams->dwcFormats;

#ifdef CFGUI__FORCE_GOOD_ACFORS

	if (!AreAcForsGood(lpdiCDParams->lprgFormats, lpdiCDParams->dwcFormats))
	{
		etrace(_T("Passed ActionFormats aren't good...  Using GetTestActionFormats() (just 2 of them).\n"));
		lpdiCDParams->dwcFormats = 2;
		lpdiCDParams->lprgFormats = GetTestActionFormats();
	}

#endif

	HRESULT hr = InternalConfigureDevices(lpdiCallback, lpdiCDParams, dwFlags, pvRefData);

	// restore passed params in case changed
	lpdiCDParams->lprgFormats = lpAcFors;
	lpdiCDParams->dwcFormats = dwNumAcFors;

	trace(_T("\n"));

	if (FAILED(hr))
		etrace1(_T("ConfigureDevices() failed, returning 0x%08x\n"), hr);
	else
		trace1(_T("ConfigureDevices() suceeded, returning 0x%08x\n"), hr);

	trace(_T("\n"));

	return hr;
}


//constructor
CDirectInputActionFramework::CDirectInputActionFramework()
{
	//set ref count
	m_cRef = 1;
}


//destructor
CDirectInputActionFramework::~CDirectInputActionFramework()
{
	// not necessary to cleanup action format here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cdiacpage.h ===
//-----------------------------------------------------------------------------
// File: cdiacpage.h
//
// Desc: CDIDeviceActionConfigPage implements the page object used by the UI.
//       A page covers the entire UI minus the device tabs and the bottons at
//       the bottom.  The information window, player combo-box, genre combo-
//       box, action list tree, and device view window are all managed by
//       the page.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifdef FORWARD_DECLS


	class CDIDeviceActionConfigPage;


#else // FORWARD_DECLS

#ifndef __CDIACPAGE_H__
#define __CDIACPAGE_H__

// For WINMM.DLL
typedef MMRESULT (WINAPI *FUNCTYPE_timeSetEvent)(UINT, UINT, LPTIMECALLBACK, DWORD_PTR, UINT);
extern HINSTANCE g_hWinMmDLL;
extern FUNCTYPE_timeSetEvent g_fptimeSetEvent;

//implementation class
class CDIDeviceActionConfigPage : public IDIDeviceActionConfigPage, public CDeviceUINotify, public CFlexWnd
{
public:

	//IUnknown fns
	STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
	STDMETHOD_(ULONG, AddRef) ();
	STDMETHOD_(ULONG, Release) ();

	//IDirectInputActionConfigPage
	STDMETHOD (Create) (DICFGPAGECREATESTRUCT *pcs);
	STDMETHOD (Show) (LPDIACTIONFORMATW lpDiActFor);
	STDMETHOD (Hide) ();

	// layout edit mode
	STDMETHOD (SetEditLayout) (BOOL bEditLayout);

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	// Write layout to IHV setting file
	STDMETHOD (WriteIHVSetting) ();
#endif
//@@END_MSINTERNAL

	// Set the info box text
	STDMETHOD (SetInfoText) (int iCode);

	// Unacquire and Reacquire the device for page's purposes
	// (the configwnd needs to do this around SetActionMap() calls)
	STDMETHOD (Unacquire) ();
	STDMETHOD (Reacquire) ();

	//construction/destruction
	CDIDeviceActionConfigPage();
	~CDIDeviceActionConfigPage();


	// dialog window message handlers
/*	BOOL OnInitDialog(HWND hWnd, HWND hwndFocus);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
	void OnPaint(HDC hDC);
	void OnClick(POINT point, WPARAM, BOOL bLeft);*/

protected:
	virtual void OnInit();
	virtual void OnPaint(HDC hDC);
	virtual void OnClick(POINT point, WPARAM fwKeys, BOOL bLeft);
	virtual void OnMouseOver(POINT point, WPARAM fwKeys);
	virtual LRESULT WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
	enum CONFIGSTATE {CFGSTATE_NORMAL, CFGSTATE_ASSIGN};

//	HWND m_hWnd; // handle to the page dialog window
	LONG m_cRef; //reference count
	LPDIACTIONFORMATW m_lpDiac;
	DIDEVICEINSTANCEW m_didi;
	LPDIRECTINPUTDEVICE8W m_lpDID;
	CUIGlobals *m_puig;
	IDIConfigUIFrameWindow *m_pUIFrame;
	CONFIGSTATE m_State;

	// device ui
	CDeviceUI *m_pDeviceUI;
	CDeviceControl *m_pCurControl;
	virtual void DeviceUINotify(const DEVICEUINOTIFY &);
	virtual BOOL IsControlMapped(CDeviceControl *);

	// ui logic
	void SetCurrentControl(CDeviceControl *pControl);
	void NullAction(LPDIACTIONW lpac);
	void UnassignControl(CDeviceControl *pControl);
	friend void CallUnassignControl(CDeviceControl *pControl, LPVOID pVoid, BOOL bFixed);
	void UnassignAction(LPDIACTIONW lpac);
	void UnassignSpecificAction(LPDIACTIONW lpac);
	void UnassignActionsAssignedTo(const GUID &guidInstance, DWORD dwOffset);
	void AssignCurrentControlToAction(LPDIACTIONW lpac);
	void ActionClick(LPDIACTIONW lpac);
	void EnterAssignState();
	void ExitAssignState();
	void UnassignCallout();
	void SetAppropriateDefaultText();

	void GlobalUnassignControlAt(const GUID &, DWORD);
	void SetControlAssignments();

	void ShowCurrentControlAssignment();

	CBitmap *m_pbmRelAxesGlyph;
	CBitmap *m_pbmAbsAxesGlyph;
	CBitmap *m_pbmButtonGlyph;
	CBitmap *m_pbmHatGlyph;
	CBitmap *m_pbmCheckGlyph;
	CBitmap *m_pbmCheckGlyphDark;
	CBitmap *m_pbmIB;
	CBitmap *m_pbmIB2;
	void InitResources();
	void FreeResources();

	RECT m_rectIB;
	RECT m_rectIBLeft;
	RECT m_rectIBRight;
	LPTSTR m_tszIBText;
	POINT m_ptIBOffset;
	POINT m_ptIBOffset2;
	RECT m_rectIBText;
	void InitIB();

	CViewSelWnd m_ViewSelWnd;
	void DoViewSel();

	CFlexTree m_Tree;
	CFTItem *m_pRelAxesParent, *m_pAbsAxesParent, *m_pButtonParent, *m_pHatParent, *m_pUnknownParent;
	void ClearTree();
	void InitTree(BOOL bForceInit = FALSE);
	DWORD m_dwLastControlType;

	CFTItem *GetItemForActionAssignedToControl(CDeviceControl *pControl);
	int GetNumItemLpacs(CFTItem *pItem);
	LPDIACTIONW GetItemLpac(CFTItem *pItem, int i = 0);
	typedef CArray<LPDIACTIONW, LPDIACTIONW &> RGLPDIACW;
	// GetItemWithActionNameAndSemType returns an item with the specified action name and semantic type.  NULL if none.
	CFTItem *GetItemWithActionNameAndSemType(LPCWSTR acname, DWORD dwSemantic);
	BOOL IsActionAssignedHere(int index);

	// quick fix for offset->objid change:
	void SetInvalid(LPDIACTIONW);
	DWORD GetOffset(LPDIACTIONW);
	void SetOffset(LPDIACTIONW, DWORD);
	bidirlookup<DWORD, DWORD> offset_objid;
	HRESULT InitLookup();

	// dropdowns
	CFlexComboBox m_UserNames, m_Genres;

	// Information window
	CFlexInfoBox m_InfoBox;

	// Sort Assigned check box for keyboard devices
	CFlexCheckBox m_CheckBox;

	// device control
	DWORD m_cbDeviceDataSize;
	DWORD *m_pDeviceData[2];
	int m_nOnDeviceData;
	BOOL m_bFirstDeviceData;
	void InitDevice();
	void DeviceTimer();
	static void CALLBACK DeviceTimerProc(UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);
	void DeviceDelta(DWORD *pData, DWORD *pOldData);
	void AxisDelta(const DIDEVICEOBJECTINSTANCEW &doi, BOOL data, BOOL old);
	void ButtonDelta(const DIDEVICEOBJECTINSTANCEW &doi, DWORD data, DWORD old);
	void PovDelta(const DIDEVICEOBJECTINSTANCEW &doi, DWORD data, DWORD old);
	void ActivateObject(const DIDEVICEOBJECTINSTANCEW &doi);
	void DeactivateObject(const DIDEVICEOBJECTINSTANCEW &doi);
	bidirlookup<DWORD, int> objid_avai;
	typedef CArray<int, int &> AxisValueArray;
	CArray<AxisValueArray, AxisValueArray &> m_AxisValueArray;
	void StoreAxisDeltaAndCalcSignificance(const DIDEVICEOBJECTINSTANCEW &doi, DWORD data, DWORD olddata, BOOL &bSig, BOOL &bOldSig);

	// page index
	int m_nPageIndex;
};


#endif //__CDIACPAGE_H__

#endif // FORWARD_DECLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cdiacpage.cpp ===
//-----------------------------------------------------------------------------
// File: cdiacpage.cpp
//
// Desc: CDIDeviceActionConfigPage implements the page object used by the UI.
//       A page covers the entire UI minus the device tabs and the bottons at
//       the bottom.  The information window, player combo-box, genre combo-
//       box, action list tree, and device view window are all managed by
//       the page.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"
#include <initguid.h>

DEFINE_GUID(GUID_NULL,0,0,0,0,0,0,0,0,0,0,0);


// {D0B5C9AE-966F-4510-B955-4D2482C5EB1B}
DEFINE_GUID(GUID_ActionItem, 
0xd0b5c9ae, 0x966f, 0x4510, 0xb9, 0x55, 0x4d, 0x24, 0x82, 0xc5, 0xeb, 0x1b);


#define DISEM_TYPE_MASK                    ( 0x00000600 )
#define DISEM_REL_MASK                     ( 0x00000100 )
#define DISEM_REL_SHIFT                    ( 8 ) 
#define DISEM_TYPE_AXIS                    0x00000200
#define DISEM_TYPE_BUTTON                  0x00000400
#define DISEM_TYPE_POV                     0x00000600

#define DEVICE_POLLING_INTERVAL 10
#define DEVICE_POLLING_AXIS_MIN 0
#define DEVICE_POLLING_AXIS_MAX 100
#define DEVICE_POLLING_AXIS_MINDELTA 3
#define DEVICE_POLLING_AXIS_SIGNIFICANT 40
#define DEVICE_POLLING_AXIS_ACCUMULATION 20
#define DEVICE_POLLING_ACBUF_START_INDEX 3
#define DEVICE_POLLING_WHEEL_SCALE_FACTOR 3

// For WINMM.DLL
HINSTANCE g_hWinMmDLL = NULL;
FUNCTYPE_timeSetEvent g_fptimeSetEvent = NULL;

//QueryInterface
STDMETHODIMP CDIDeviceActionConfigPage::QueryInterface(REFIID iid, LPVOID* ppv)
{
   //null the out param
	*ppv = NULL;

	if ((iid == IID_IUnknown) || (iid == IID_IDIDeviceActionConfigPage))
	{
		*ppv = this;
		AddRef();
		return S_OK;
	}

	return E_NOINTERFACE;
}


//AddRef
STDMETHODIMP_(ULONG) CDIDeviceActionConfigPage::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}


//Release
STDMETHODIMP_(ULONG) CDIDeviceActionConfigPage::Release()
{

	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this;
		return 0;
	}

	return m_cRef;
}


//constructor
CDIDeviceActionConfigPage::CDIDeviceActionConfigPage() :
	m_pDeviceUI(NULL), m_puig(NULL), m_pUIFrame(NULL),
	m_cRef(1), m_lpDiac(NULL), m_lpDID(NULL), m_State(CFGSTATE_NORMAL),
	m_pCurControl(NULL),
	m_tszIBText(NULL), m_pbmIB(NULL), m_pbmIB2(NULL),
	m_pbmRelAxesGlyph(NULL), m_pbmAbsAxesGlyph(NULL), m_pbmButtonGlyph(NULL),
	m_pbmHatGlyph(NULL), m_pbmCheckGlyph(NULL), m_pbmCheckGlyphDark(NULL),
	m_pRelAxesParent(NULL), m_pAbsAxesParent(NULL), m_pButtonParent(NULL),
	m_pHatParent(NULL),	m_pUnknownParent(NULL),
	m_bFirstDeviceData(TRUE), m_cbDeviceDataSize(0), m_nOnDeviceData(0),
	m_dwLastControlType(0),
	m_nPageIndex(-1)
{
	tracescope(__ts, _T("CDIDeviceActionConfigPage::CDIDeviceActionConfigPage()\n"));
	m_pDeviceData[0] = NULL;
	m_pDeviceData[1] = NULL;
}


//destructor
CDIDeviceActionConfigPage::~CDIDeviceActionConfigPage()
{
	tracescope(__ts, _T("CDIDeviceActionConfigPage::~CDIDeviceActionConfigPage()\n"));

	// Unattach the parent from the tooltip window so it won't get destroyed.
	SetParent(CFlexWnd::s_ToolTip.m_hWnd, NULL);

	if (m_hWnd != NULL)
		Destroy();

	FreeResources();

	delete m_pDeviceUI;

	for (int c = 0; c < 2; c++)
		if (m_pDeviceData[c] != NULL)
			free(m_pDeviceData[c]);

	if (m_lpDID != NULL)
	{
		m_lpDID->Unacquire();
		m_lpDID->Release();
	}
	m_lpDID = NULL;
}


STDMETHODIMP CDIDeviceActionConfigPage::Create(DICFGPAGECREATESTRUCT *pcs)
{
	tracescope(__ts, _T("CDIDeviceActionConfigPage::Create()\n"));
	if (pcs == NULL)
		return E_INVALIDARG;
	DICFGPAGECREATESTRUCT &cs = *pcs;
	
	// validate/save uig and uif
	m_puig = pcs->pUIGlobals;
	m_pUIFrame = pcs->pUIFrame;
	if (m_puig == NULL || m_pUIFrame == NULL)
		return E_INVALIDARG;

	// save page index
	m_nPageIndex = pcs->nPage;
	assert(m_nPageIndex >= 0);

	// create deviceui with uig, or fail
	m_pDeviceUI = new CDeviceUI(*m_puig, *m_pUIFrame);
	if (m_pDeviceUI == NULL)
		return E_FAIL;

	// save the device instance
	m_didi = cs.didi;
	m_lpDID = cs.lpDID;
	if (m_lpDID != NULL)
		m_lpDID->AddRef();

	// create the window
	HWND hWnd = NULL;
	assert(m_puig != NULL);
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	BOOL bAllowEditLayout = m_puig->QueryAllowEditLayout();
#endif
//@@END_MSINTERNAL
	RECT rect = {0, 0, 1, 1};
	hWnd = CFlexWnd::Create(cs.hParentWnd, rect, FALSE);

	// return the handle
	cs.hPageWnd = hWnd;

	assert(m_puig != NULL);

	// Create the information box
	m_InfoBox.Create(m_hWnd, g_InfoWndRect, TRUE);
	m_InfoBox.SetFont((HFONT)m_puig->GetFont(UIE_USERNAMES));
	m_InfoBox.SetColors(m_puig->GetTextColor(UIE_USERNAMES),
	                    m_puig->GetBkColor(UIE_USERNAMES),
	                    m_puig->GetTextColor(UIE_USERNAMESEL),
	                    m_puig->GetBkColor(UIE_USERNAMESEL),
	                    m_puig->GetBrushColor(UIE_USERNAMES),
	                    m_puig->GetPenColor(UIE_USERNAMES));
	SetAppropriateDefaultText();

	// Create the check box only if this is a keyboard device.
	if (LOBYTE(LOWORD(m_didi.dwDevType)) == DI8DEVTYPE_KEYBOARD)
	{
		m_CheckBox.Create(m_hWnd, g_CheckBoxRect, FALSE);
		m_CheckBox.SetNotify(m_hWnd);
		m_CheckBox.SetFont((HFONT)m_puig->GetFont(UIE_USERNAMES));
		m_CheckBox.SetColors(m_puig->GetTextColor(UIE_USERNAMES),
		                     m_puig->GetBkColor(UIE_USERNAMES),
		                     m_puig->GetTextColor(UIE_USERNAMESEL),
		                     m_puig->GetBkColor(UIE_USERNAMESEL),
		                     m_puig->GetBrushColor(UIE_USERNAMES),
		                     m_puig->GetPenColor(UIE_USERNAMES));

		TCHAR tszResourceString[MAX_PATH];
		LoadString(g_hModule, IDS_SORTASSIGNED, tszResourceString, MAX_PATH);
		m_CheckBox.SetText(tszResourceString);
		m_CheckBox.SetCheck(TRUE);
		::ShowWindow(m_CheckBox.m_hWnd, SW_SHOW);
	}

	// create the username dropdown if necessary
	FLEXCOMBOBOXCREATESTRUCT cbcs;
	cbcs.dwSize = sizeof(FLEXCOMBOBOXCREATESTRUCT);
	cbcs.dwFlags = FCBF_DEFAULT;
	cbcs.dwListBoxFlags = FCBF_DEFAULT|FLBF_INTEGRALHEIGHT;
	cbcs.hWndParent = m_hWnd;
	cbcs.hWndNotify = m_hWnd;
	cbcs.bVisible = TRUE;
	cbcs.rect = g_UserNamesRect;
	cbcs.hFont = (HFONT)m_puig->GetFont(UIE_USERNAMES);
	cbcs.rgbText = m_puig->GetTextColor(UIE_USERNAMES);
	cbcs.rgbBk = m_puig->GetBkColor(UIE_USERNAMES);
	cbcs.rgbSelText = m_puig->GetTextColor(UIE_USERNAMESEL);
	cbcs.rgbSelBk = m_puig->GetBkColor(UIE_USERNAMESEL);
	cbcs.rgbFill = m_puig->GetBrushColor(UIE_USERNAMES);
	cbcs.rgbLine = m_puig->GetPenColor(UIE_USERNAMES);
	cbcs.nSBWidth = 11;

	if (m_puig->GetNumUserNames() > 0 && m_hWnd != NULL
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	    && !m_puig->QueryAllowEditLayout()
#endif
//@@END_MSINTERNAL
	   )
	{
		for (int i = 0, n = m_puig->GetNumUserNames(); i < n; i++)
			m_UserNames.AddString(SAFESTR(m_puig->GetUserName(i)));
		m_UserNames.AddString(SAFESTR(_T("(unassigned)")));

		m_UserNames.Create(&cbcs);

		int nUser = m_pUIFrame->GetCurUser(m_nPageIndex);
		if (nUser == -1)
			nUser = m_puig->GetNumUserNames();
		m_UserNames.SetSel(nUser);
	} else
	if (m_hWnd != NULL)
		m_UserNames.SetSel(0);  // If only 1 user, still must set selection to 0 or we get error later.

	// If we are in view mode, set username combobox to read only so user can't change its value.
	if (!m_puig->InEditMode())
		m_UserNames.SetReadOnly(TRUE);

	if (m_puig->GetNumMasterAcFors() > 1 && m_hWnd != NULL)
	{
		for (int i = 0, n = m_puig->GetNumMasterAcFors(); i < n; i++)
			m_Genres.AddString(SAFESTR(m_puig->RefMasterAcFor(i).tszActionMap));

		cbcs.rect = g_GenresRect;
		m_Genres.Create(&cbcs);
		m_Genres.SetSel(m_pUIFrame->GetCurGenre());
	}

	// return success/fail
	return hWnd != NULL ? S_OK : E_FAIL;
}

STDMETHODIMP CDIDeviceActionConfigPage::Show(LPDIACTIONFORMATW lpDiActFor)
{
	// save the format pointer
	m_lpDiac = lpDiActFor;

	// force tree init
	InitTree(TRUE);

	// show the assignments for the controls
	SetControlAssignments();

	// show the assignment for the current control
	ShowCurrentControlAssignment();

	// Sort the list if check box is checked.
	if (m_CheckBox.GetCheck())
		m_pDeviceUI->GetCurView()->SortAssigned(TRUE);

	// show the window
	if (m_hWnd != NULL)
		ShowWindow(m_hWnd, SW_SHOW);

	SetFocus(m_hWnd);
	CFlexWnd::s_CurrPageHwnd = m_hWnd;

	return S_OK;
}

STDMETHODIMP CDIDeviceActionConfigPage::Hide()
{
	// clear the tree
	ClearTree();

	// null the format pointer
	m_lpDiac = NULL;

	// hide the window
	if (m_hWnd != NULL)
		ShowWindow(m_hWnd, SW_HIDE);

	// If we are in the assign state, exit it.
	if (m_State == CFGSTATE_ASSIGN)
		ExitAssignState();

	return S_OK;
}

void CDIDeviceActionConfigPage::InitIB()
{
	RECT z = {0,0,0,0};
	SIZE bsize = {0,0};
	m_rectIB = z;
	if (m_pbmIB != NULL)
	{
		if (m_pbmIB->GetSize(&bsize))
		{
			m_rectIB.right = bsize.cx * 2;
			m_rectIB.bottom = bsize.cy;
		}
	}

	const int IBORIGINX = 200, IBORIGINY = 394,
		IBTEXTMARGINLEFT = 5;
	POINT ptIBOrigin = {IBORIGINX, IBORIGINY};

	m_tszIBText = _T("Click here to see different views of your controller.");
	SIZE tsize = GetTextSize(m_tszIBText, (HFONT)m_puig->GetFont(UIE_VIEWSEL));
	m_ptIBOffset.x = 0;
	m_ptIBOffset.y = 0;
	int tofs = 0;
	if (m_rectIB.bottom < tsize.cy)
	{
		m_rectIB.bottom = tsize.cy;
		m_ptIBOffset.y = (tsize.cy - bsize.cy) / 2;
	}
	else if (tsize.cy < m_rectIB.bottom)
		tofs = (bsize.cy - tsize.cy) / 2;
	m_rectIB.right += tsize.cx;
	if (m_pbmIB != NULL)
		m_rectIB.right += IBTEXTMARGINLEFT * 2;

	OffsetRect(&m_rectIB, ptIBOrigin.x, ptIBOrigin.y);
	m_ptIBOffset.x += ptIBOrigin.x;
	m_ptIBOffset.y += ptIBOrigin.y;

	m_ptIBOffset2.x = m_rectIB.right - bsize.cx;
	m_ptIBOffset2.y = m_ptIBOffset.y;

	m_rectIBText = m_rectIB;
	if (m_pbmIB != NULL)
		m_rectIBText.left += IBTEXTMARGINLEFT + bsize.cx;
	if (m_pbmIB2 != NULL)
		m_rectIBText.right -= IBTEXTMARGINLEFT + bsize.cx;
	m_rectIBText.top += tofs;

	// Inialize the two RECTs representing the two arrow bitmaps
	m_rectIBLeft = m_rectIBRight = m_rectIB;
	m_rectIBLeft.right = m_rectIBText.left;
	m_rectIBRight.left = m_rectIBText.right;
}

void CDIDeviceActionConfigPage::OnInit()
{
	tracescope(__ts, _T("CDIDeviceActionConfigPage::OnInit()\n"));
	// init resources
	InitResources();

	// init IB
	InitIB();

	// initialize the device UI
	m_pDeviceUI->Init(m_didi, m_lpDID, m_hWnd, this);

	// initialize the device
	InitDevice();

	// Start a one-shot timer for click to pick
	if (g_fptimeSetEvent)
		g_fptimeSetEvent(DEVICE_POLLING_INTERVAL, DEVICE_POLLING_INTERVAL,
		                 CDIDeviceActionConfigPage::DeviceTimerProc, (DWORD_PTR)m_hWnd, TIME_ONESHOT);

	// create the tree
	CAPTIONLOOK cl;
	cl.dwMask = CLMF_TEXTCOLOR | CLMF_FONT | CLMF_LINECOLOR;
	cl.rgbTextColor = m_puig->GetTextColor(UIE_CALLOUT);
	cl.rgbLineColor = m_puig->GetPenColor(UIE_BORDER);
	cl.hFont = (HFONT)m_puig->GetFont(UIE_ACTION);
	m_Tree.SetDefCaptionLook(cl);
	cl.rgbTextColor = m_puig->GetTextColor(UIE_CALLOUTHIGH);
	m_Tree.SetDefCaptionLook(cl, TRUE);
	m_Tree.SetBkColor(RGB(0,0,0));
	if (m_puig->InEditMode())
	{
		m_Tree.Create(m_hWnd, g_TreeRect, TRUE, TRUE);
		m_Tree.SetScrollBarColors(
			m_puig->GetBrushColor(UIE_SBTRACK),
			m_puig->GetBrushColor(UIE_SBTHUMB),
			m_puig->GetPenColor(UIE_SBBUTTON));
	}
}

void CDIDeviceActionConfigPage::InitResources()
{
	// create glyphs
	if (!m_pbmRelAxesGlyph)
		m_pbmRelAxesGlyph = CBitmap::CreateFromResource(g_hModule, IDB_AXESGLYPH);
	if (!m_pbmAbsAxesGlyph)
		m_pbmAbsAxesGlyph = CBitmap::CreateFromResource(g_hModule, IDB_AXESGLYPH);
	if (!m_pbmButtonGlyph)
		m_pbmButtonGlyph = CBitmap::CreateFromResource(g_hModule, IDB_BUTTONGLYPH);
	if (!m_pbmHatGlyph)
		m_pbmHatGlyph = CBitmap::CreateFromResource(g_hModule, IDB_HATGLYPH);
	if (!m_pbmCheckGlyph)
		m_pbmCheckGlyph = CBitmap::CreateFromResource(g_hModule, IDB_CHECKGLYPH);
	if (!m_pbmCheckGlyphDark)
		m_pbmCheckGlyphDark = CBitmap::CreateFromResource(g_hModule, IDB_CHECKGLYPHDARK);

	// create IB bitmaps
	if (!m_pbmIB)
		m_pbmIB = CBitmap::CreateFromResource(g_hModule, IDB_IB);
	if (!m_pbmIB2)
		m_pbmIB2 = CBitmap::CreateFromResource(g_hModule, IDB_IB2);
}

void CDIDeviceActionConfigPage::FreeResources()
{
	if (m_pbmRelAxesGlyph)
		delete m_pbmRelAxesGlyph;
	if (m_pbmAbsAxesGlyph)
		delete m_pbmAbsAxesGlyph;
	if (m_pbmButtonGlyph)
		delete m_pbmButtonGlyph;
	if (m_pbmHatGlyph)
		delete m_pbmHatGlyph;
	if (m_pbmCheckGlyph)
		delete m_pbmCheckGlyph;
	if (m_pbmCheckGlyphDark)
		delete m_pbmCheckGlyphDark;
	if (m_pbmIB)
		delete m_pbmIB;
	if (m_pbmIB2)
		delete m_pbmIB2;
	m_pbmRelAxesGlyph = NULL;
	m_pbmAbsAxesGlyph = NULL;
	m_pbmButtonGlyph = NULL;
	m_pbmHatGlyph = NULL;
	m_pbmCheckGlyph = NULL;
	m_pbmCheckGlyphDark = NULL;
	m_pbmIB = NULL;
	m_pbmIB2 = NULL;
}

void CDIDeviceActionConfigPage::ClearTree()
{
	m_Tree.FreeAll();
	m_pRelAxesParent = NULL;
	m_pAbsAxesParent = NULL;
	m_pButtonParent = NULL;
	m_pHatParent = NULL;
	m_pUnknownParent = NULL;
	m_dwLastControlType = 0;
}

void CDIDeviceActionConfigPage::InitTree(BOOL bForceInit)
{
	// get type of control
	DWORD dwControlType = 0;
	if (m_pCurControl && m_pCurControl->IsOffsetAssigned())
	{
		DWORD dwObjId = m_pCurControl->GetOffset();

		if (dwObjId & DIDFT_RELAXIS)
			dwControlType = DIDFT_RELAXIS;
		else if (dwObjId & DIDFT_ABSAXIS)
			dwControlType = DIDFT_ABSAXIS;
		else if (dwObjId & DIDFT_BUTTON)
			dwControlType = DIDFT_BUTTON;
		else if (dwObjId & DIDFT_POV)
			dwControlType = DIDFT_POV;
	}

	// Turn off the tree's readonly flag if we are in the assign state.
	// We will turn it on later if current control's action has DIA_APPFIXED.
	if (m_State == CFGSTATE_NORMAL)
		m_Tree.SetReadOnly(TRUE);
	else
		m_Tree.SetReadOnly(FALSE);

	// if this control type is the same as the last, do nothing,
	// unless we're force init
	if (m_dwLastControlType == dwControlType && !bForceInit && m_State)
		return;

	// delete the whole tree
	ClearTree();

	// can't use tree if there is no diac or action array
	if (m_lpDiac == NULL || m_lpDiac->rgoAction == NULL)
		return;

	// also can't use if we don't have a control type
	if (dwControlType == 0)
		return;

	// prepare margin rects
	RECT labelmargin = {14, 6, 3, 3};
	RECT itemmargin = {14, 1, 3, 2};

	// set default indents
	m_Tree.SetRootChildIndent(5);
	m_Tree.SetDefChildIndent(12);

	// add the control type sections
	m_Tree.SetDefMargin(labelmargin);
	TCHAR tszResourceString[MAX_PATH];
	switch (dwControlType)
	{
		case DIDFT_RELAXIS:
			LoadString(g_hModule, IDS_AXISACTIONS, tszResourceString, MAX_PATH);
			m_pRelAxesParent = m_Tree.DefAddItem(tszResourceString);
			break;

		case DIDFT_ABSAXIS:
			LoadString(g_hModule, IDS_AXISACTIONS, tszResourceString, MAX_PATH);
			m_pAbsAxesParent = m_Tree.DefAddItem(tszResourceString);
			break;

		case DIDFT_BUTTON:
			LoadString(g_hModule, IDS_BUTTONACTIONS, tszResourceString, MAX_PATH);
			m_pButtonParent = m_Tree.DefAddItem(tszResourceString);
			break;

		case DIDFT_POV:
			LoadString(g_hModule, IDS_POVACTIONS, tszResourceString, MAX_PATH);
			m_pHatParent = m_Tree.DefAddItem(tszResourceString);
			break;

		default:
			return;
	}

	// populate the tree
	m_Tree.SetDefMargin(itemmargin);
	for (unsigned int i = 0; i < m_lpDiac->dwNumActions; i++)
	{
		DIACTIONW *pAction = m_lpDiac->rgoAction + i;
		CFTItem *pItem = NULL;

		if (pAction == NULL) 
			continue;

		switch (pAction->dwSemantic & DISEM_TYPE_MASK)
		{
			case DISEM_TYPE_AXIS:
				// Must distinguish between relative and absolute
				switch((pAction->dwSemantic & DISEM_REL_MASK) >> DISEM_REL_SHIFT)
				{
					case 0: pItem = m_pAbsAxesParent; break;
					case 1: pItem = m_pRelAxesParent; break;
				}
				break;
			case DISEM_TYPE_BUTTON: pItem = m_pButtonParent; break;
			case DISEM_TYPE_POV: pItem = m_pHatParent; break;
		}

		if (pItem == NULL)
			continue;

		// Add action with this name
		CFTItem *pAlready = GetItemWithActionNameAndSemType(pAction->lptszActionName, pAction->dwSemantic);
		if (!pAlready)
		{
			LPTSTR acname = AllocLPTSTR(pAction->lptszActionName);
			pItem = m_Tree.DefAddItem(acname, pItem, ATTACH_LASTCHILD);  // This might return NULL.
			free(acname);
			if (pItem)
				pItem->SetUserData((LPVOID)(new RGLPDIACW));
		}
		else
		{
			pItem = pAlready;
		}

		if (pItem == NULL)
			continue;

		pItem->SetUserGUID(GUID_ActionItem);
		RGLPDIACW *pacs = (RGLPDIACW *)pItem->GetUserData();
		if (pacs)
			pacs->SetAtGrow(pacs->GetSize(), pAction);

		if (pAlready)
		{
			// The tree already has an action with this name.  Check the DIA_APPFIXED flag for each DIACTION
			// that this item holds.
			DWORD dwNumActions = GetNumItemLpacs(pItem);
			for (DWORD i = 0; i < dwNumActions; ++i)
			{
				LPDIACTIONW lpExistingAc = GetItemLpac(pItem, i);
				// If the DIACTION that is assigned to this device has DIA_APPFIXED flag, then
				//   the other must have it too.
				if (lpExistingAc && IsEqualGUID(lpExistingAc->guidInstance, m_didi.guidInstance))
				{
					if (lpExistingAc->dwFlags & DIA_APPFIXED)
					{
						// If this DIACTION has DIA_APPFIXED, then all DIACTIONs must have it too.
						for (DWORD j = 0; j < dwNumActions; ++j)
						{
							LPDIACTIONW lpChangeAc = GetItemLpac(pItem, j);
							if (lpChangeAc)
								lpChangeAc->dwFlags |= DIA_APPFIXED;
						}
					}

					break;  // Break the loop since we already found the DIACTION that is assigned.
				}
			}
		}  // if (pAlready)
	}

	// show all
	m_Tree.GetRoot()->ExpandAll();
	m_dwLastControlType = dwControlType;
}

int CompareActionNames(LPCWSTR acname1, LPCWSTR acname2)
{
#ifdef CFGUI__COMPAREACTIONNAMES_CASE_INSENSITIVE
	return _wcsicmp(acname1, acname2);
#else
	return wcscmp(acname1, acname2);
#endif
}

CFTItem *CDIDeviceActionConfigPage::GetItemWithActionNameAndSemType(LPCWSTR acname, DWORD dwSemantic)
{
	CFTItem *pItem = m_Tree.GetFirstItem();
	for (; pItem != NULL; pItem = pItem->GetNext())
	{
		if (!pItem->IsUserGUID(GUID_ActionItem))
			continue;
		
		LPDIACTIONW lpac = GetItemLpac(pItem);
		if (!lpac)
			continue;

		// Check semantic type
		if ((lpac->dwSemantic & DISEM_TYPE_MASK) != (dwSemantic & DISEM_TYPE_MASK))
			continue;

		// If both are axis, check for relative/absolute
		if ((lpac->dwSemantic & DISEM_TYPE_MASK) == DISEM_TYPE_AXIS)
			if ((lpac->dwSemantic & DISEM_REL_MASK) != (dwSemantic & DISEM_REL_MASK))
				continue;

		// Check name
		if (CompareActionNames(lpac->lptszActionName, acname) == 0)
			return pItem;
	}

	return NULL;
}

void CDIDeviceActionConfigPage::OnPaint(HDC hDC)
{
	TCHAR tszResourceString[MAX_PATH];
	CPaintHelper ph(*m_puig, hDC);

	ph.SetBrush(UIB_BLACK);
	RECT rect;
	GetClientRect(&rect);
	ph.Rectangle(rect, UIR_SOLID);

	ph.SetText(UIC_BORDER, UIC_BLACK);
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	if (!m_puig->QueryAllowEditLayout())
#endif
//@@END_MSINTERNAL
	{
		rect = g_UserNamesTitleRect;
		LoadString(g_hModule, IDS_PLAYER_TITLE, tszResourceString, MAX_PATH);
		DrawText(hDC, tszResourceString, -1, &rect, DT_CENTER|DT_NOCLIP|DT_NOPREFIX);
	}
	if (m_puig->GetNumMasterAcFors() > 1)
	{
		rect = g_GenresTitleRect;
		LoadString(g_hModule, IDS_GENRE_TITLE, tszResourceString, MAX_PATH);
		DrawText(hDC, tszResourceString, -1, &rect, DT_CENTER|DT_NOCLIP|DT_NOPREFIX);
	}

	// Draw tree window title and outline if we are in edit mode.
	if (m_puig->InEditMode())
	{
		COLORREF BorderColor = m_puig->GetColor(UIC_BORDER);
		if (m_Tree.GetReadOnly())
			BorderColor = RGB(GetRValue(BorderColor)>>1, GetGValue(BorderColor)>>1, GetBValue(BorderColor)>>1);

		::SetTextColor(hDC, BorderColor);  // Use the muted color if tree is read only.
		// Draw tree window title (Available Actions)
		rect = g_TreeTitleRect;
		LoadString(g_hModule, IDS_AVAILABLEACTIONS_TITLE, tszResourceString, MAX_PATH);
		DrawText(hDC, tszResourceString, -1, &rect, DT_CENTER|DT_NOCLIP|DT_NOPREFIX);
		// Draw tree window outline
		HGDIOBJ hPen, hOldPen;
		if (m_Tree.GetReadOnly())
		{
			hPen = CreatePen(PS_SOLID, 0, BorderColor);
			hOldPen = ::SelectObject(hDC, hPen);
		}
		else
			ph.SetPen(UIP_BORDER);

		RECT rc = g_TreeRect;
		InflateRect(&rc, 1, 1);
		Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
		if (m_Tree.GetReadOnly())
		{
			::SelectObject(hDC, hOldPen);
			DeleteObject(hPen);
		}
	}

	if (m_pDeviceUI->GetNumViews() < 2)
		return;

	if (m_pbmIB != NULL)
		m_pbmIB->Draw(hDC, m_ptIBOffset);
	if (m_pbmIB2 != NULL)
		m_pbmIB2->Draw(hDC, m_ptIBOffset2);
	if (m_tszIBText != NULL)
	{
		ph.SetElement(UIE_VIEWSEL);
		RECT rect = m_rectIBText;
		DrawText(hDC, m_tszIBText, -1, &rect, DT_NOCLIP | DT_NOPREFIX);
	}
}

void CDIDeviceActionConfigPage::SetCurrentControl(CDeviceControl *pControl)
{
	// If the new control is the same as the old, no need to do anything.
	if (m_pCurControl == pControl)
		return;
	if (m_pCurControl != NULL)
	{
		m_pCurControl->Unhighlight();
		// If we don't have a current control, then invalidate the view so that the old callout can be repainted.
		// If there is a current control, the view will be invalidated by Highlight().
		if (!pControl)
			m_pCurControl->Invalidate();
	}
	m_pCurControl = pControl;
	if (m_pCurControl != NULL)
		m_pCurControl->Highlight();
	ShowCurrentControlAssignment();
}

CFTItem *CDIDeviceActionConfigPage::GetItemForActionAssignedToControl(CDeviceControl *pControl)
{
	if (!pControl)
		return NULL;

	// find the item for the action assigned to this control, if any
	CFTItem *pItem = m_Tree.GetFirstItem();
	for (; pItem != NULL; pItem = pItem->GetNext())
	{
		if (!pItem->IsUserGUID(GUID_ActionItem))
			continue;

		for (int i = 0, n = GetNumItemLpacs(pItem); i < n; i++)
		{
			LPDIACTIONW lpac = GetItemLpac(pItem, i);
			if (!lpac)
				continue;

			if (IsEqualGUID(lpac->guidInstance, m_didi.guidInstance) &&
					GetOffset(lpac) == pControl->GetOffset())
				return pItem;
		}
	}

	return NULL;
}

int CDIDeviceActionConfigPage::GetNumItemLpacs(CFTItem *pItem)
{
	if (pItem == NULL)
		return 0;

	RGLPDIACW *pacs = (RGLPDIACW *)pItem->GetUserData();
	if (!pacs)
		return 0;
	else
		return pacs->GetSize();
}

LPDIACTIONW CDIDeviceActionConfigPage::GetItemLpac(CFTItem *pItem, int i)
{
	if (pItem == NULL)
		return NULL;

	RGLPDIACW *pacs = (RGLPDIACW *)pItem->GetUserData();
	if (!pacs || i < 0 || i >= pacs->GetSize())
		return NULL;
	else	
		return pacs->GetAt(i);
}

void CDIDeviceActionConfigPage::ShowCurrentControlAssignment()
{
	// init the tree
	InitTree();

	// if we don't have a control...
	if (m_pCurControl == NULL)
	{
		// select nothing
		m_Tree.SetCurSel(NULL);
		return;
	}

	// find the item for the action assigned to this control, if any
	CFTItem *pItem = GetItemForActionAssignedToControl(m_pCurControl);

	// if we didn't find a match...
	if (!pItem)
	{
		// select nothing
		m_Tree.SetCurSel(NULL);
		return;
	}

	// We need to check if the action this control is assigned to has DIA_APPFIXED flag.
	// If it does, this control cannot be remapped to another action.
	// We prevent this by setting the tree control to read-only, so it can't receive any clicks.
	LPDIACTIONW lpAc = GetItemLpac(pItem);  // Get the action
	if (lpAc && (lpAc->dwFlags & DIA_APPFIXED))
		m_Tree.SetReadOnly(TRUE);

	// otherwise, show item and select it
	pItem->EnsureVisible();
	m_Tree.SetCurSel(pItem);
}

void CDIDeviceActionConfigPage::DeviceUINotify(const DEVICEUINOTIFY &uin)
{
	switch (uin.msg)
	{
		case DEVUINM_NUMVIEWSCHANGED:
			Invalidate();
			break;

		case DEVUINM_SELVIEW:
			// set the view
			m_pDeviceUI->SetView(uin.selview.nView);

			// show the assignments for the controls
			SetControlAssignments();

			// select nothing
			SetCurrentControl(NULL);
			break;

		case DEVUINM_ONCONTROLDESTROY:
			if (uin.control.pControl == m_pCurControl)
				m_pCurControl = NULL;
			break;

		case DEVUINM_CLICK:
			ExitAssignState();
			switch (uin.from)
			{
				case DEVUINFROM_CONTROL:
					SetCurrentControl(uin.control.pControl);
					SetAppropriateDefaultText();
					break;
				case DEVUINFROM_VIEWWND:
					break;
			}
			break;

		case DEVUINM_DOUBLECLICK:
			switch (uin.from)
			{
				case DEVUINFROM_CONTROL:
					EnterAssignState();
					break;
			}
			break;

		case DEVUINM_MOUSEOVER:
			SetAppropriateDefaultText();
			break;

		case DEVUINM_RENEWDEVICE:
			HWND hParent = GetParent(m_hWnd);
			CConfigWnd *pCfgWnd = (CConfigWnd *)GetFlexWnd(hParent);
			if (pCfgWnd)
			{
				LPDIRECTINPUTDEVICE8W lpDID = pCfgWnd->RenewDevice(m_didi.guidInstance);
				if (lpDID)
				{
					// Destroy the device instance we have
					if (m_lpDID) m_lpDID->Release();
					lpDID->AddRef();
					m_lpDID = lpDID;
				}
				m_pDeviceUI->SetDevice(lpDID);  // Sets the device pointer in CDeviceUI (no need to AddRef)
			}
	}
}

void CDIDeviceActionConfigPage::UnassignCallout()
{
	// find the item for the action assigned to this control, if any
	CFTItem *pItem = GetItemForActionAssignedToControl(m_pCurControl);
	if (pItem)
	{
		LPDIACTIONW lpac = GetItemLpac(pItem);
		// Only unassign if the action doesn't have DIA_APPFIXED flag.
		if (lpac && !(lpac->dwFlags & DIA_APPFIXED))
		{
			ActionClick(NULL);
			m_Tree.Invalidate();
		}
	}
	// Sort the list if the check box is checked.
	if (m_CheckBox.GetCheck())
		m_pDeviceUI->GetCurView()->SortAssigned(TRUE);
}

void CDIDeviceActionConfigPage::NullAction(LPDIACTIONW lpac)
{
	if (lpac == NULL)
		return;

	SetInvalid(lpac);

//@@BEGIN_MSINTERNAL
	// TODO: find tree view item with this action and indicate unassignment
//@@END_MSINTERNAL
}

void CDIDeviceActionConfigPage::UnassignActionsAssignedTo(const GUID &guidInstance, DWORD dwOffset)
{
	if (m_lpDiac == NULL || m_lpDiac->rgoAction == NULL)
		return;

	if (IsEqualGUID(guidInstance, GUID_NULL))
		return;

	// assign any actions assigned to this control to nothing
	DWORD i;
	LPDIACTIONW lpac;
	for (i = 0, lpac = m_lpDiac->rgoAction; i < m_lpDiac->dwNumActions; i++, lpac++)
		if (IsEqualGUID(guidInstance, lpac->guidInstance) && dwOffset == GetOffset(lpac)/*->dwInternalOffset*/)
		{
			GlobalUnassignControlAt(guidInstance, dwOffset);
			NullAction(lpac);
		}
}

void CDIDeviceActionConfigPage::UnassignControl(CDeviceControl *pControl)
{
	if (pControl == NULL)
		return;

	// make sure the control itself indicates unassignment
	pControl->SetCaption(g_tszUnassignedControlCaption);
}

void CallUnassignControl(CDeviceControl *pControl, LPVOID pVoid, BOOL bFixed)
{
	CDIDeviceActionConfigPage *pThis = (CDIDeviceActionConfigPage *)pVoid;
	pThis->UnassignControl(pControl);
}

void CDIDeviceActionConfigPage::GlobalUnassignControlAt(const GUID &guidInstance, DWORD dwOffset)
{
	if (IsEqualGUID(guidInstance, GUID_NULL))
		return;

	if (IsEqualGUID(guidInstance, m_didi.guidInstance))
		m_pDeviceUI->DoForAllControlsAtOffset(dwOffset, CallUnassignControl, this);
}

// this function must find whatever control is assigned to this action and unassign it
void CDIDeviceActionConfigPage::UnassignAction(LPDIACTIONW slpac)
{
	// call UnassignSpecificAction for each action with the same name
	// as this one, including this one
	
	if (slpac == NULL)
		return;

	CFTItem *pItem = GetItemWithActionNameAndSemType(slpac->lptszActionName, slpac->dwSemantic);
	if (!pItem)
		return;

	RGLPDIACW *pacs = (RGLPDIACW *)pItem->GetUserData();
	if (!pacs)
		return;

	for (int i = 0; i < pacs->GetSize(); i++)
		UnassignSpecificAction(pacs->GetAt(i));
}

void CDIDeviceActionConfigPage::UnassignSpecificAction(LPDIACTIONW lpac)
{
	if (lpac == NULL)
		return;

	if (IsEqualGUID(lpac->guidInstance, GUID_NULL))
		return;

	// if there's a control with this instance/offset, unassign it
	UnassignActionsAssignedTo(lpac->guidInstance, GetOffset(lpac)/*->dwInternalOffset*/);
	GlobalUnassignControlAt(lpac->guidInstance, GetOffset(lpac)/*->dwInternalOffset*/);

	// now actually null the action
	NullAction(lpac);
}

void CDIDeviceActionConfigPage::AssignCurrentControlToAction(LPDIACTIONW lpac)
{
	// if there is a control, unassign it
	if (m_pCurControl != NULL)
	{
		UnassignControl(m_pCurControl);
		GUID guidInstance;
		DWORD dwOffset;
		m_pCurControl->GetInfo(guidInstance, dwOffset);
		UnassignActionsAssignedTo(guidInstance, dwOffset);
	}

	// if there is an action, unassign it
	if (lpac != NULL)
		UnassignAction(lpac);

	// can only continue if we have both
	if (lpac == NULL || m_pCurControl == NULL)
		return;

	// here we should have a control and an action
	assert(lpac != NULL);
	assert(m_pCurControl != NULL);

	// because an action can only be assigned to one control,
	// make sure this action is unassigned first
	UnassignAction(lpac);

	// now actually assign
	DWORD ofs;
	m_pCurControl->GetInfo(lpac->guidInstance, ofs/*lpac->dwInternalOffset*/);
	SetOffset(lpac, ofs);
	LPTSTR acname = AllocLPTSTR(lpac->lptszActionName);
	m_pCurControl->SetCaption(acname, lpac->dwFlags & DIA_APPFIXED);
	free(acname);

	// Sort the action list if check box is checked
	if (m_CheckBox.GetCheck())
	{
		m_pDeviceUI->GetCurView()->SortAssigned(TRUE);
		// Scroll so that we scroll to make this visible since it might be displaced by sorting.
		m_pDeviceUI->GetCurView()->ScrollToMakeControlVisible(m_pCurControl->GetCalloutMaxRect());
	}
}

void CDIDeviceActionConfigPage::ActionClick(LPDIACTIONW lpac)
{
	if (m_pCurControl != NULL)
	{
		AssignCurrentControlToAction(lpac);

		// Set assignment since other views may have the same callout and
		// they need to be updated too.
		SetControlAssignments();
	}
	// Change the state back to normal
	ExitAssignState();
}

void CDIDeviceActionConfigPage::SetControlAssignments()
{
	assert(!IsEqualGUID(m_didi.guidInstance, GUID_NULL));

	m_pDeviceUI->SetAllControlCaptionsTo(g_tszUnassignedControlCaption);

	if (m_lpDiac == NULL || m_lpDiac->rgoAction == NULL)
		return;

	DWORD i;
	LPDIACTIONW lpac;
	for (i = 0, lpac = m_lpDiac->rgoAction; i < m_lpDiac->dwNumActions; i++)
	{
		lpac = m_lpDiac->rgoAction + i;

		if (IsEqualGUID(lpac->guidInstance, GUID_NULL))
			continue;

		if (!IsEqualGUID(lpac->guidInstance, m_didi.guidInstance))
			continue;

		LPTSTR acname = AllocLPTSTR(lpac->lptszActionName);
		m_pDeviceUI->SetCaptionForControlsAtOffset(GetOffset(lpac)/*->dwInternalOffset*/, acname, lpac->dwFlags & DIA_APPFIXED);
		free(acname);
	}
}

void CDIDeviceActionConfigPage::DoViewSel()
{
	m_ViewSelWnd.Go(m_hWnd, m_rectIB.left, m_rectIB.top, m_pDeviceUI);
}

void CDIDeviceActionConfigPage::OnClick(POINT point, WPARAM, BOOL bLeft)
{
	if (!bLeft)
		return;

	// Unhighlight current callout
	ExitAssignState();

	if (m_pDeviceUI->GetNumViews() > 1)
	{
		int iCurView = m_pDeviceUI->GetCurViewIndex();

		if (PtInRect(&m_rectIBLeft, point))
			m_pDeviceUI->SetView(iCurView == 0 ? m_pDeviceUI->GetNumViews() - 1 : iCurView - 1);
		if (PtInRect(&m_rectIBRight, point))
			m_pDeviceUI->SetView(iCurView == m_pDeviceUI->GetNumViews() - 1 ? 0 : iCurView + 1);
		if (PtInRect(&m_rectIBText, point))
			DoViewSel();
	}
}

void CDIDeviceActionConfigPage::OnMouseOver(POINT point, WPARAM fwKeys)
{
	CFlexWnd::s_ToolTip.SetEnable(FALSE);

	// Check view selection area so we can display text in info box.
	if (m_pDeviceUI->GetNumViews() > 1)
	{
		if (PtInRect(&m_rectIB, point))
		{
			SetInfoText(IDS_INFOMSG_VIEW_VIEWSEL);
			return;
		}
	}

	SetAppropriateDefaultText();
}

int GetActionIndexFromPointer(LPDIACTIONW p, LPDIACTIONFORMATW paf)
{
	if (!p || !paf || !paf->rgoAction)
		return -1;

	int index = int((((LPBYTE)p) - ((LPBYTE)paf->rgoAction)) / (DWORD)sizeof(DIACTIONW));

	assert(&(paf->rgoAction[index]) == p);

	return index;
}

BOOL CDIDeviceActionConfigPage::IsActionAssignedHere(int index)
{
	if (!m_lpDiac)
		return FALSE;

	if (index < 0 || index >= (int)m_lpDiac->dwNumActions)
		return FALSE;

	return IsEqualGUID(m_didi.guidInstance, m_lpDiac->rgoAction[index].guidInstance);
}

LRESULT CDIDeviceActionConfigPage::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
		case WM_UNHIGHLIGHT:
			// Unhighlight current callout
			ExitAssignState();
			break;

		case WM_KEYDOWN:
#ifdef DBG
			// In debug version, shift-escape exits the UI.
			if (wParam == VK_ESCAPE && GetAsyncKeyState(VK_SHIFT) < 0)
			{
				PostMessage(GetParent(m_hWnd), WM_KEYDOWN, wParam, lParam);
				break;
			}
#endif
			// If this is a keyboard device, then click-to-pick will take care of the functionalities below.
			// Process WM_KEYDOWN only for non-keyboard devices.
			if (LOBYTE(m_didi.dwDevType) == DI8DEVTYPE_KEYBOARD) return 0;
			switch(wParam)
			{
				case VK_RETURN:
					// If we are not in assign state, enter it.
					if (m_State == CFGSTATE_NORMAL && m_pCurControl)
						EnterAssignState();
					break;

				case VK_DELETE:
					// If we are in assign state and there is a control, unassign it.
					if (m_State == CFGSTATE_ASSIGN && m_pCurControl)
						UnassignCallout();
					break;

				case VK_ESCAPE:
					if (m_State == CFGSTATE_ASSIGN)
						ExitAssignState();

					break;
			}
			return 0;

		case WM_FLEXCHECKBOX:
			switch(wParam)
			{
				case CHKNOTIFY_UNCHECK:
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
					if (!m_pDeviceUI->InEditMode())  // Ignore sort assigned checkbox if in DDK tool
					{
#endif
//@@END_MSINTERNAL
						m_pDeviceUI->GetCurView()->SortAssigned(FALSE);
						if (m_pCurControl)
						{
							// Scroll so that we scroll to make this visible since it might be displaced by sorting.
							m_pDeviceUI->GetCurView()->ScrollToMakeControlVisible(m_pCurControl->GetCalloutMaxRect());
						}
						Invalidate();
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
					}
#endif
//@@END_MSINTERNAL
					break;
				case CHKNOTIFY_CHECK:
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
					if (!m_pDeviceUI->InEditMode())  // Ignore sort assigned checkbox if in DDK tool
					{
#endif
//@@END_MSINTERNAL
						m_pDeviceUI->GetCurView()->SortAssigned(TRUE);
						if (m_pCurControl)
						{
							// Scroll so that we scroll to make this visible since it might be displaced by sorting.
							m_pDeviceUI->GetCurView()->ScrollToMakeControlVisible(m_pCurControl->GetCalloutMaxRect());
						}
						Invalidate();
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
					}
#endif
//@@END_MSINTERNAL
					break;
				case CHKNOTIFY_MOUSEOVER:
					SetInfoText(m_CheckBox.GetCheck() ? IDS_INFOMSG_VIEW_SORTENABLED : IDS_INFOMSG_VIEW_SORTDISABLED);
					break;
			}
			break;

		case WM_FLEXCOMBOBOX:
			switch (wParam)
			{
				case FCBN_MOUSEOVER:
					if (lParam)
					{
						CFlexComboBox *pCombo = (CFlexComboBox*)lParam;
						if (pCombo->m_hWnd == m_UserNames.m_hWnd)
							SetInfoText(m_puig->InEditMode() ? IDS_INFOMSG_EDIT_USERNAME : IDS_INFOMSG_VIEW_USERNAME);
						else if (pCombo->m_hWnd == m_Genres.m_hWnd)
							SetInfoText(m_puig->InEditMode() ? IDS_INFOMSG_EDIT_GAMEMODE : IDS_INFOMSG_VIEW_GAMEMODE);
					}
					break;

				case FCBN_SELCHANGE:
					// Clear the tool tip as the combo-box has closed
					CFlexWnd::s_ToolTip.SetEnable(FALSE);
					CFlexWnd::s_ToolTip.SetToolTipParent(NULL);
					if (m_pUIFrame && m_puig)
					{
						ExitAssignState();
						m_pUIFrame->SetCurGenre(m_Genres.GetSel());
						int nUser = m_UserNames.GetSel();
						if (m_puig->GetNumUserNames() > 0 && nUser >= m_puig->GetNumUserNames())
							nUser = -1;
						m_pUIFrame->SetCurUser(m_nPageIndex, nUser);
					}
					break;
			}
			return 0;

		case WM_FLEXTREENOTIFY:
		{
			// Check if this is a mouse over message (just for info box update)
			if (wParam == FTN_MOUSEOVER)
			{
				SetAppropriateDefaultText();
				return FALSE;
			}

			if (!lParam)
				return FALSE;
			FLEXTREENOTIFY &n = *((FLEXTREENOTIFY *)(LPVOID)lParam);
			if (!n.pItem)
				return FALSE;
			switch (wParam)
			{
				case FTN_OWNERDRAW:
				{
					POINT ofs = {0, 0};
					CBitmap *pbmGlyph = NULL;
					BOOL bAssigned = FALSE, bAssignedHere = FALSE;
					if (n.pItem->IsUserGUID(GUID_ActionItem))
					{
						LPDIACTIONW lpac = GetItemLpac(n.pItem, 0);
						if (lpac)
							// We now walk through each DIACTION and find those with action name match, then see if 
							// they are assigned anywhere.
							for (DWORD i = 0; i < m_lpDiac->dwNumActions; ++i)
							{
								if (wcscmp(lpac->lptszActionName, m_lpDiac->rgoAction[i].lptszActionName))
									continue;

								if (bAssignedHere = IsActionAssignedHere(i))
								{
									bAssigned = TRUE;
									break;
								}
								if (m_pUIFrame && m_pUIFrame->QueryActionAssignedAnywhere(m_didi.guidInstance, i) == S_OK)
									bAssigned = TRUE;
							}
						if (bAssigned || bAssignedHere)
						{
							pbmGlyph = bAssignedHere ? m_pbmCheckGlyph :
								m_pbmCheckGlyphDark;
							pbmGlyph->FigureSize();
							ofs.x = 2;
							ofs.y = 4;
						}
					}
					else
					{
						if (n.pItem == m_pRelAxesParent)
							pbmGlyph = m_pbmRelAxesGlyph;
						if (n.pItem == m_pAbsAxesParent)
							pbmGlyph = m_pbmAbsAxesGlyph;
						if (n.pItem == m_pButtonParent)
							pbmGlyph = m_pbmButtonGlyph;
						if (n.pItem == m_pHatParent)
							pbmGlyph = m_pbmHatGlyph;
						ofs.y = 2;
					}
					if (!pbmGlyph)
						return FALSE;
					n.pItem->PaintInto(n.hDC);
					RECT rect;
					CPaintHelper ph(*m_puig, n.hDC);
					ph.SetElement(UIE_GLYPH);
					n.pItem->GetMargin(rect);
					pbmGlyph->Draw(n.hDC, ofs.x, rect.top + ofs.y);
					return TRUE;
				}

				case FTN_CLICK:
					// We cannot assign a different control to this action if it has the DIA_APPFIXED flag.
					if (n.pItem->IsUserGUID(GUID_ActionItem) && GetItemLpac(n.pItem) && !(GetItemLpac(n.pItem)->dwFlags & DIA_APPFIXED))
					{
						m_Tree.SetCurSel(n.pItem);
						ActionClick(GetItemLpac(n.pItem));
					}
					else
					{
#ifdef CFGUI__ALLOW_USER_ACTION_TREE_BRANCH_MANIPULATION
						if (!n.pItem->IsExpanded())
							n.pItem->Expand();
						else
							n.pItem->Collapse();
#endif
					}
					break;
			}
			break;
		}
	}

	return CFlexWnd::WndProc(hWnd, msg, wParam, lParam);
}

void CDIDeviceActionConfigPage::SetInvalid(LPDIACTIONW lpac)
{
	lpac->guidInstance = GUID_NULL;
	lpac->dwObjID = (DWORD)-1;
}

DWORD CDIDeviceActionConfigPage::GetOffset(LPDIACTIONW lpac)
{
	return lpac ? lpac->dwObjID : (DWORD)-1;
}

void CDIDeviceActionConfigPage::SetOffset(LPDIACTIONW lpac, DWORD ofs)
{
	assert(lpac != NULL);
	if (!lpac)
		return;
	lpac->dwObjID = ofs;
}

HRESULT CDIDeviceActionConfigPage::InitLookup()
{
	DIDEVOBJSTRUCT os;

	HRESULT hresult = FillDIDeviceObjectStruct(os, m_lpDID);

	if (FAILED(hresult))
		return hresult;

	for (int i = 0; i < os.nObjects; i++)
	{
		DIDEVICEOBJECTINSTANCEW &doi = os.pdoi[i];
		offset_objid.add(doi.dwOfs, doi.dwType);
	}

	return S_OK;
}

HRESULT CDIDeviceActionConfigPage::SetEditLayout(BOOL bEditLayout)
{
	m_pDeviceUI->SetEditMode(bEditLayout);
	return S_OK;
}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
HRESULT CDIDeviceActionConfigPage::WriteIHVSetting()
{
	m_pDeviceUI->WriteToINI();
	return S_OK;
}
#endif
//@@END_MSINTERNAL

BOOL CDIDeviceActionConfigPage::IsControlMapped(CDeviceControl *pControl)
{
	if (pControl == NULL)
		return FALSE;

	if (!pControl->IsOffsetAssigned())
		return FALSE;

	if (m_lpDiac == NULL)
		return FALSE;
	
	for (DWORD i = 0; i < m_lpDiac->dwNumActions; i++)
		if (GetOffset(&(m_lpDiac->rgoAction[i])) == pControl->GetOffset())
			return TRUE;

	return FALSE;
}

void CDIDeviceActionConfigPage::InitDevice()
{
	if (m_lpDID == NULL || m_pDeviceUI == NULL || m_pUIFrame == NULL)
		return;

	HWND hWndMain = m_pUIFrame->GetMainHWND();
	if (!hWndMain)
		return;

	// don't do anything if this is a mouse
	switch ((DWORD)(LOBYTE(LOWORD(m_pDeviceUI->m_didi.dwDevType))))
	{
		case DI8DEVTYPE_MOUSE:
			return;
	}

	// init/prepare...
	int i;
	const DIDEVOBJSTRUCT &os = m_pDeviceUI->m_os;
	int nObjects = os.nObjects;

	DIDATAFORMAT df;
	df.dwSize = sizeof(DIDATAFORMAT);
	df.dwObjSize = sizeof(DIOBJECTDATAFORMAT);
	df.dwFlags = DIDF_ABSAXIS;
	df.dwDataSize = sizeof(DWORD) * (DWORD)nObjects;
	df.dwNumObjs = (DWORD)nObjects;
	df.rgodf = (DIOBJECTDATAFORMAT *)malloc(sizeof(DIOBJECTDATAFORMAT) * nObjects);
	if (df.rgodf == NULL)
	{
		etrace1(_T("Could not allocate DIOBJECTDATAFORMAT array of %d elements\n"), nObjects);
		return;
	}

	m_cbDeviceDataSize = df.dwDataSize;
	for (int c = 0; c < 2; c++)
	{
		if (m_pDeviceData[c] != NULL)
			free(m_pDeviceData[c]);
		m_pDeviceData[c] = (DWORD *)malloc(m_cbDeviceDataSize);
		if (m_pDeviceData[c] == NULL)
			etrace2(_T("Could not allocate device data buffer %d of %d bytes\n"), c, m_cbDeviceDataSize);
	}
	m_nOnDeviceData = 0;
	m_bFirstDeviceData = TRUE;

	for (i = 0; i < nObjects; i++)
	{
		DIOBJECTDATAFORMAT *podf = &(df.rgodf[i]);
		podf->pguid = NULL;
		podf->dwOfs = i * sizeof(DWORD);
		podf->dwType = os.pdoi[i].dwType;
		podf->dwFlags = 0;
	}

	if (df.rgodf != NULL)
	{
		HRESULT hr = m_lpDID->SetDataFormat(&df);
		free(df.rgodf);
		df.rgodf = NULL;

		if (FAILED(hr))
		{
			etrace1(_T("SetDataFormat() failed, returning 0x%08x\n"), hr);
		}
		else
		{
			hr = m_lpDID->SetCooperativeLevel(hWndMain, DISCL_BACKGROUND | DISCL_NONEXCLUSIVE);
			if (FAILED(hr))
				etrace1(_T("SetCooperativeLevel() failed, returning 0x%08x\n"), hr);

			DIPROPRANGE range;
			range.diph.dwSize = sizeof(DIPROPRANGE);
			range.diph.dwHeaderSize = sizeof(DIPROPHEADER);
			range.diph.dwObj = 0;
			range.diph.dwHow = DIPH_DEVICE;
			range.lMin = DEVICE_POLLING_AXIS_MIN;
			range.lMax = DEVICE_POLLING_AXIS_MAX;

			hr = m_lpDID->SetProperty(DIPROP_RANGE, (LPCDIPROPHEADER)&range);
			if (FAILED(hr))
				etrace1(_T("SetProperty(DIPROP_RANGE, ...) failed, returning 0x%08x\n"), hr);

			hr = m_lpDID->Acquire();
			if (FAILED(hr))
				etrace1(_T("Acquire() failed, returning 0x%08x\n"), hr);
		}
	}
}

void CALLBACK CDIDeviceActionConfigPage::DeviceTimerProc(UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)
{
	if (!IsWindow((HWND)dwUser)) return;  // Verify that dwUser is a valid window handle
	CDIDeviceActionConfigPage *pPage = (CDIDeviceActionConfigPage *)GetFlexWnd((HWND)dwUser);  // Get flex object
	if (pPage)
		pPage->DeviceTimer();
}

void CDIDeviceActionConfigPage::DeviceTimer()
{
	DWORD *pOldData = m_pDeviceData[m_nOnDeviceData];
	m_nOnDeviceData = (m_nOnDeviceData + 1) & 1;
	DWORD *pData = m_pDeviceData[m_nOnDeviceData];

	if (m_lpDID == NULL || pData == NULL || pOldData == NULL)
	{
		// Required data not available.  Return and there'll be no more timer callbacks.
		etrace(_T("DeviceTimer() failed\n"));
		return;
	}

	// Get device data only if this page is visible.
	if (m_lpDiac)
	{
		HRESULT hr = m_lpDID->Poll();
		if (SUCCEEDED(hr))
		{
			hr = m_lpDID->GetDeviceState(m_cbDeviceDataSize, pData);
			if (SUCCEEDED(hr))
			{
				if (!m_bFirstDeviceData)
				{
					DeviceDelta(pData, pOldData);
				} else
				{
					m_bFirstDeviceData = FALSE;
				}
			} else
			{
				etrace1(_T("GetDeviceState() failed, returning 0x%08x\n"), hr);
			}
		} else
		{
			etrace1(_T("Poll() failed, returning 0x%08x\n"), hr);
		}
	}

	// Set the next timer event.
	if (g_fptimeSetEvent)
		g_fptimeSetEvent(DEVICE_POLLING_INTERVAL, DEVICE_POLLING_INTERVAL,
		                 CDIDeviceActionConfigPage::DeviceTimerProc, (DWORD_PTR)m_hWnd, TIME_ONESHOT);
}

void CDIDeviceActionConfigPage::DeviceDelta(DWORD *pData, DWORD *pOldData)
{
	if (pData == NULL || pOldData == NULL || m_pDeviceUI == NULL)
		return;

	const DIDEVOBJSTRUCT &os = m_pDeviceUI->m_os;

	// see which objects changed
	for (int i = 0; i < os.nObjects; i++)
	{
		// for axes, we need to do special processing
		if (os.pdoi[i].dwType & DIDFT_AXIS)
		{
			BOOL bSig = FALSE, bOldSig = FALSE;

			StoreAxisDeltaAndCalcSignificance(os.pdoi[i],
				pData[i], pOldData[i], bSig, bOldSig);

			AxisDelta(os.pdoi[i], bSig, bOldSig);

			continue;
		}

		// for all others, skip that which didn't change
		if (pData[i] == pOldData[i])
			continue;

		// pass to appropriate delta function
		DWORD dwObjId = os.pdoi[i].dwType;
		if (dwObjId & DIDFT_BUTTON)
			ButtonDelta(os.pdoi[i], pData[i], pOldData[i]);
		else if (dwObjId & DIDFT_POV)
			PovDelta(os.pdoi[i], pData[i], pOldData[i]);
	}
}

void CDIDeviceActionConfigPage::StoreAxisDeltaAndCalcSignificance(const DIDEVICEOBJECTINSTANCEW &doi, DWORD data, DWORD olddata, BOOL &bSig, BOOL &bOldSig)
{
	// see if this object has an axis value array
	int i;
	if (objid_avai.getright(doi.dwType, i))
	{
		AxisValueArray &ar = m_AxisValueArray[i];
		int on = ar[0] + 1;
		if (on >= ar.GetSize())
			on = DEVICE_POLLING_ACBUF_START_INDEX;
		ar[0] = on;
		int delta = abs(int(data) - int(olddata));
		// Scale up the delta if this is a wheel axis as wheels are harder to move generally.
		if (LOBYTE(m_didi.dwDevType) == DI8DEVTYPE_DRIVING && doi.guidType == GUID_XAxis)
			delta = delta * DEVICE_POLLING_WHEEL_SCALE_FACTOR;
		if (delta < DEVICE_POLLING_AXIS_MINDELTA)
			delta = 0;
		int cumul = ar[1];  // Retrieve cumulative value for easier processing
		cumul -= ar[on];  // Subtract value in current slot from cumul since it's being thrown away.
		cumul += delta;  // Add current delta to cumul
		ar[on] = delta;  // Store the delta at current slot
		ar[1] = cumul;  // Save cumulative value

		bOldSig = (BOOL)ar[2];
		ar[2] = int(bSig = cumul > DEVICE_POLLING_AXIS_SIGNIFICANT);
		if (bSig)
		{
			// This axis is about to be activated.  We now reset the history and cumulative movement since we don't need them any more.
			ar[0] = DEVICE_POLLING_ACBUF_START_INDEX;
			ar[1] = 0;
			ar[2] = FALSE;
			for (int c = DEVICE_POLLING_ACBUF_START_INDEX;
					c < DEVICE_POLLING_ACBUF_START_INDEX + DEVICE_POLLING_AXIS_ACCUMULATION; c++)
				ar[c] = 0;
		}
	}
	else
	{
		i = m_AxisValueArray.GetSize();
		m_AxisValueArray.SetSize(i + 1);
		objid_avai.add(doi.dwType, i);
		AxisValueArray &ar = m_AxisValueArray[i];
		ar.SetSize(DEVICE_POLLING_ACBUF_START_INDEX + DEVICE_POLLING_AXIS_ACCUMULATION);
		ar[0] = DEVICE_POLLING_ACBUF_START_INDEX;
		ar[1] = 0;
		ar[2] = FALSE;
		for (int c = DEVICE_POLLING_ACBUF_START_INDEX;
				c < DEVICE_POLLING_ACBUF_START_INDEX + DEVICE_POLLING_AXIS_ACCUMULATION; c++)
			ar[c] = 0;
		
		bOldSig = bSig = FALSE;
	}
}

void CDIDeviceActionConfigPage::AxisDelta(const DIDEVICEOBJECTINSTANCEW &doi, BOOL data, BOOL old)
{
	if (data && !old)
	{
		if (m_State == CFGSTATE_NORMAL)
			ActivateObject(doi);
	}
	if (old && !data)
		DeactivateObject(doi);
}

void CDIDeviceActionConfigPage::ButtonDelta(const DIDEVICEOBJECTINSTANCEW &doi, DWORD data, DWORD old)
{
	static DWORD dwLastOfs;
	static DWORD dwLastTimeStamp;

	if (data && !old)
	{
		// Do special processing for keyboard
		if (LOBYTE(m_didi.dwDevType) == DI8DEVTYPE_KEYBOARD)
		{
			// If this is an ENTER key, we enter the assign state if not already in it.
			if (doi.dwOfs == DIK_RETURN || doi.dwOfs == DIK_NUMPADENTER)
			{
				if (m_State == CFGSTATE_NORMAL && m_pCurControl)
					EnterAssignState();
				return;  // Do nothing other than entering the assign state.  No highlighting
			}

			// DELETE key case
			// If we are in assign state and there is a control, unassign it.
			if (doi.dwOfs == DIK_DELETE && m_State == CFGSTATE_ASSIGN && m_pCurControl)
				{
					UnassignCallout();
					return;  // Don't highlight or do pick to click for delete if this press happens during assign state.
				}

			// ESCAPE key case
			if (doi.dwOfs == DIK_ESCAPE && m_State == CFGSTATE_ASSIGN)
			{
				ExitAssignState();
				return;
			}

			// For all other keys, still process click-to-pick or highlighting.
		}

		// Enter assign state if this is a double activation
		if (m_State == CFGSTATE_NORMAL)
		{
			ActivateObject(doi);

			if (doi.dwOfs == dwLastOfs && dwLastTimeStamp + GetDoubleClickTime() > GetTickCount())
			{
				// We check if a callout for this control exists.  If not, do not enter assign state.
				CDeviceView *pCurView = m_pDeviceUI->GetCurView();
				CDeviceControl *pControl = pCurView->GetControlFromOfs(doi.dwType);
				if (pControl)
					EnterAssignState();
			}
			dwLastOfs = doi.dwOfs;
			dwLastTimeStamp = GetTickCount();
		}
	}
	if (old && !data)
		DeactivateObject(doi);
}

void CDIDeviceActionConfigPage::PovDelta(const DIDEVICEOBJECTINSTANCEW &doi, DWORD data, DWORD old)
{
	BOOL d = data != -1, o = old != -1;

	if (d && !o)
	{
		if (m_State == CFGSTATE_NORMAL)
			ActivateObject(doi);
	}
	if (o && !d)
		DeactivateObject(doi);	
}

void CDIDeviceActionConfigPage::ActivateObject(const DIDEVICEOBJECTINSTANCEW &doi)
{
	if (m_pDeviceUI == NULL)
		return;

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	if (m_pDeviceUI->GetCurView()->InEditState())
		return;
#endif
//@@END_MSINTERNAL

	CDeviceView *pCurView = m_pDeviceUI->GetCurView(), *pView = pCurView;
	if (pView == NULL)
		return;

	CDeviceControl *pControl = pView->GetControlFromOfs(doi.dwType);
	if (pControl == NULL)
	{
		for (int i = 0; i < m_pDeviceUI->GetNumViews(); i++)
		{
			pView = m_pDeviceUI->GetView(i);
			if (pView == NULL)
				continue;

			pControl = pView->GetControlFromOfs(doi.dwType);
			if (pControl != NULL)
				break;
		}

		if (pControl != NULL && pView != NULL && pView != pCurView)
		{
			// switch to view
			m_pDeviceUI->SetView(pView);
			SetControlAssignments();
			SetCurrentControl(NULL);
		}
	}

	if (pControl != NULL)
		SetCurrentControl(pControl);

	SetAppropriateDefaultText();
}

void CDIDeviceActionConfigPage::DeactivateObject(const DIDEVICEOBJECTINSTANCEW &doi)
{
	// Add code that needs to be run when deactivating here.
}

HRESULT CDIDeviceActionConfigPage::Unacquire()
{
	if (m_lpDID != NULL)
		m_lpDID->Unacquire();

	return S_OK;
}

HRESULT CDIDeviceActionConfigPage::Reacquire()
{
	InitDevice();

	return S_OK;
}

void CDIDeviceActionConfigPage::EnterAssignState()
{
	if (!m_puig->InEditMode())
		return;
	if (!m_pCurControl || m_pCurControl->IsFixed())
		return;
	SetInfoText(IDS_INFOMSG_EDIT_EDITMODEENABLED);
	m_State = CFGSTATE_ASSIGN;  // Into the assign state.
	ShowCurrentControlAssignment();  // Show the tree
	m_Tree.Invalidate();
	Invalidate();
}

void CDIDeviceActionConfigPage::ExitAssignState()
{
	m_State = CFGSTATE_NORMAL;  // Out of the assign state.
	SetCurrentControl(NULL);  // Unselect the control
	ShowCurrentControlAssignment();  // Show the tree
	m_Tree.Invalidate();
	Invalidate();
	SetAppropriateDefaultText();
}

HRESULT CDIDeviceActionConfigPage::SetInfoText(int iCode)
{
	// We check for special code -1 here.  This is only called by CConfigWnd, and means that we should
	// call SetAppropriateDefaultText to display proper text.
	if (iCode == -1)
		SetAppropriateDefaultText();
	else
		m_InfoBox.SetText(iCode);
	return S_OK;
}

void CDIDeviceActionConfigPage::SetAppropriateDefaultText()
{
	if (m_puig->InEditMode())
	{
		if (m_State == CFGSTATE_ASSIGN)
			SetInfoText(IDS_INFOMSG_EDIT_EDITMODEENABLED);
		else if (m_pCurControl)
		{
			if (m_pCurControl->IsFixed())
				SetInfoText(IDS_INFOMSG_APPFIXEDSELECT);
			else
				SetInfoText(IDS_INFOMSG_EDIT_CTRLSELECTED);
		}
		else
		{
			if (LOBYTE(m_didi.dwDevType) == DI8DEVTYPE_KEYBOARD)
				SetInfoText(IDS_INFOMSG_EDIT_KEYBOARD);
			else
			if (LOBYTE(m_didi.dwDevType) == DI8DEVTYPE_MOUSE)
				SetInfoText(IDS_INFOMSG_EDIT_MOUSE);
			else
				SetInfoText(IDS_INFOMSG_EDIT_DEVICE);
		}
	} else
		SetInfoText(IDS_INFOMSG_VIEW_DEVICE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\common.hpp ===
//-----------------------------------------------------------------------------
// File: common.hpp
//
// Desc: Master header file used by the UI.  Good candidate for pre-compiled
//       header.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __CFGUI_COMMON_H__
#define __CFGUI_COMMON_H__


// custom/local defines
#include "defines.h"


// windows/system includes
#include <windows.h>
#include <objbase.h>
#include <winnls.h>
#include <commdlg.h>
#include <mmsystem.h>
#include <tchar.h>

// standard includes
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <math.h>
#include <string.h>
#include <process.h>
#include <time.h>
#include <assert.h>

// directx includes
#include <dinput.h>
#include <ddraw.h>
#include <d3d8.h>
#include <d3dx8tex.h>

// guids include
#include "ourguids.h"

// resource include
#include "dicfgres.h"

// constants include
#include "constants.h"

// main module include
#include "main.h"

// collections includes
#include "collections.h"
#include "bidirlookup.h"

// util includes
#include "cbitmap.h"
#include "cyclestr.h"
#include "useful.h"
#include "usefuldi.h"
#include "ltrace.h"
#include "cfguitrace.h"
#include "privcom.h"

// registry util include
#include "registry.h"

// flexwnd includes
#include "flexmsg.h"
#include "flexwnd.h"
#include "flexscrollbar.h"
#include "flextree.h"
#include "flexlistbox.h"
#include "flexcombobox.h"
#include "flextooltip.h"
#include "flexinfobox.h"
#include "flexcheckbox.h"
#include "flexmsgbox.h"

// uiglobals include
#include "uiglobals.h"

// interface includes
//@@BEGIN_MSINTERNAL
#include "idftest.h"
//@@END_MSINTERNAL
#include "iuiframe.h"
#include "idiacpage.h"
#include "ifrmwrk.h"

// class factory includes
#include "iclassfact.h"
#include "ipageclassfact.h"
//@@BEGIN_MSINTERNAL
#include "itestclassfact.h"
//@@END_MSINTERNAL

// framework class/module includes
#include "configwnd.h"
#include "cfrmwrk.h"
//@@BEGIN_MSINTERNAL

// test subsystem includes
#include "cdftest.h"
#include "rundftest.h"
//@@END_MSINTERNAL

// page class/module includes
#include "pagecommon.h"


#endif //__CFGUI_COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\collections.h ===
//-----------------------------------------------------------------------------
// File: collections.h
//
// Desc: Contains all container templates used by the UI.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __COLLECTIONS_H__
#define __COLLECTIONS_H__


// fake out afx

#define BEFORE_START_POSITION ((POSITION)-1L)

BOOL AfxIsValidAddress( const void* lp, UINT nBytes, BOOL bReadWrite = TRUE ); 

#define ASSERT assert
#define AFX_INLINE inline
#define AFXAPI
#define ASSERT_VALID(p) assert(p != NULL)

typedef void *POSITION;

#pragma warning( disable : 4291 )
inline void *__cdecl operator new(size_t, void *_P)
	{ return (_P); }

// afx template stuff without mfc dependencies!  :D

template<class ARG_KEY>
AFX_INLINE UINT AFXAPI HashKey(ARG_KEY key)
{
	// default identity hash - works for most primitive values
	return ((UINT)(DWORD)key) >> 4;
}

template<class TYPE>
AFX_INLINE void AFXAPI ConstructElements(TYPE* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

	// first do bit-wise zero initialization
	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	// then call the constructor(s)
	for (; nCount--; pElements++)
		::new((void*)pElements) TYPE;
}

template<class TYPE>
AFX_INLINE void AFXAPI DestructElements(TYPE* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

	// call the destructor(s)
	for (; nCount--; pElements++)
		pElements->~TYPE();
}

template<class TYPE>
AFX_INLINE void AFXAPI CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pDest, nCount * sizeof(TYPE)));
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pSrc, nCount * sizeof(TYPE)));

	// default is element-copy using assignment
	while (nCount--)
		*pDest++ = *pSrc++;
}

template<class TYPE, class ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
	ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE), FALSE));
	ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));

	return *pElement1 == *pElement2;
}


/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray
{
public:
// Construction
	CArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

	// Operations

	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	TYPE GetAt(int nIndex) const;
	void SetAt(int nIndex, ARG_TYPE newElement);
	TYPE& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const TYPE* GetData() const;
	TYPE* GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, ARG_TYPE newElement);
	int Add(ARG_TYPE newElement);
	int Append(const CArray& src);
	void Copy(const CArray& src);

	// overloaded operator helpers
	TYPE operator[](int nIndex) const;
	TYPE& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
	TYPE* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CArray();
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
AFX_INLINE int CArray<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
	{ return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE void CArray<TYPE, ARG_TYPE>::RemoveAll()
	{ SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
	{ return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE* CArray<TYPE, ARG_TYPE>::GetData()
	{ return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
	{ return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
	{ return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
	ASSERT_VALID(this);

	if (m_pData != NULL)
	{
		DestructElements<TYPE>(m_pData, m_nSize);
		delete[] (BYTE*)m_pData;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		if (m_pData != NULL)
		{
			DestructElements<TYPE>(m_pData, m_nSize);
			delete[] (BYTE*)m_pData;
			m_pData = NULL;
		}
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
#endif
		m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
		ConstructElements<TYPE>(m_pData, nNewSize);
		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);
		}
		else if (m_nSize > nNewSize)
		{
			// destroy the old elements
			DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);
		}
		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = m_nSize / 8;
			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);
		ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);
	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
	return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	SetSize(src.m_nSize);
	CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
			// copy new data from old
			memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1, -1);
	m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount, -1);  // grow it to new size
		// destroy intial data before copying over it
		DestructElements<TYPE>(&m_pData[nOldSize], nCount);
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(TYPE));

		// re-init slots we copied from
		ConstructElements<TYPE>(&m_pData[nIndex], nCount);
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);
	while (nCount--)
		m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	ASSERT(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);
	DestructElements<TYPE>(&m_pData[nIndex], nCount);
	if (nMoveCount)
		memmove(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(TYPE));
	m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPlex

struct CPlex     // warning variable length structure
{
	CPlex* pNext;
	DWORD dwReserved[1];    // align on 8 byte boundary

	// BYTE data[maxNum*elementSize];

	void* data() { return this+1; }

	static CPlex* PASCAL Create(CPlex*& head, UINT nMax, UINT cbElement);
	// like 'calloc' but no zero fill
	// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		TYPE data;
	};
public:
// Construction
	CList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	TYPE RemoveHead();
	TYPE RemoveTail();

	// add before head or after tail
	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	// add another list of elements before head or after tail
	void AddHead(CList* pNewList);
	void AddTail(CList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); // return *Position++
	TYPE GetNext(POSITION& rPosition) const; // return *Position++
	TYPE& GetPrev(POSITION& rPosition); // return *Position--
	TYPE GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
		// defaults to starting at the HEAD, return NULL if not found
	POSITION FindIndex(int nIndex) const;
		// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CList();
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
AFX_INLINE int CList<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE CList<TYPE, ARG_TYPE>::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE CList<TYPE, ARG_TYPE>::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements
	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		DestructElements<TYPE>(&pNode->data, 1);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	CList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow

	ConstructElements<TYPE>(&pNode->data, 1);
	return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
	DestructElements<TYPE>(&pNode->data, 1);
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
	ASSERT_VALID(this);

	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	TYPE returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	TYPE returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
	ASSERT_VALID(this);

	if (nIndex >= m_nCount || nIndex < 0)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (CompareElements<TYPE>(&pNode->data, &searchValue))
			return (POSITION)pNode;
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		KEY key;
		VALUE value;
	};
public:
// Construction
	CMap(int nBlockSize = 10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key);

	// add a new (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
	~CMap();
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
	{ return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
	{ (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
	ASSERT_VALID(this);

	if (m_pHashTable != NULL)
	{
		// destroy elements (values and keys)
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				DestructElements<VALUE>(&pAssoc->value, 1);
				DestructElements<KEY>(&pAssoc->key, 1);
			}
		}
	}

	// free hash table
	delete[] m_pHashTable;
	m_pHashTable = NULL;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
		// chain them into free list
		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMap::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
	ConstructElements<KEY>(&pAssoc->key, 1);
	ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
	DestructElements<VALUE>(&pAssoc->value, 1);
	DestructElements<KEY>(&pAssoc->key, 1);
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
			return pAssoc;
	}
	return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
	KEY& rKey, VALUE& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		ASSERT(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		     nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}


#undef ASSERT
#undef AFX_INLINE
#undef AFXAPI
#undef ASSERT_VALID


#endif //__COLLECTIONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cfrmwrk.h ===
//-----------------------------------------------------------------------------
// File: cfrmwrk.h
//
// Desc: CDirectInputActionFramework is the outer-most layer of the UI. It
//       contains everything else. Its functionality is provided by one
//       method: ConfigureDevices.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef _CFRMWRK_H
#define _CFRMWRK_H


//framework implementation class
class CDirectInputActionFramework : public IDirectInputActionFramework
{

public:

		//IUnknown fns
	STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
	STDMETHOD_(ULONG, AddRef) ();
	STDMETHOD_(ULONG, Release) ();

	//own fns
	STDMETHOD (ConfigureDevices) (LPDICONFIGUREDEVICESCALLBACK lpdiCallback,
	                              LPDICONFIGUREDEVICESPARAMSW  lpdiCDParams,
	                              DWORD                        dwFlags,
	                              LPVOID                       pvRefData);

	//construction / destruction
	CDirectInputActionFramework();
	~CDirectInputActionFramework();

protected:

	//reference count
	LONG m_cRef;
};

#endif // _CFRMWRK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\configwnd.h ===
//-----------------------------------------------------------------------------
// File: configwnd.h
//
// Desc: CConfigWnd is derived from CFlexWnd. It implements the top-level
//       UI window which all other windows are descendents of.
//
//       Functionalities handled by CConfigWnd are device tabs, Reset, Ok,
//       and Cancel buttons.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __CONFIGWND_H__
#define __CONFIGWND_H__


#define PAGETYPE IDIDeviceActionConfigPage
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
#define NUMBUTTONS 4
#else
#define NUMBUTTONS 3
#endif
/*
//@@END_MSINTERNAL
#define NUMBUTTONS 3
//@@BEGIN_MSINTERNAL
*/
//@@END_MSINTERNAL


class CMouseTrap : public CFlexWnd
{
	HWND m_hParent;

public:
	CMouseTrap() : m_hParent(NULL) { }
	HWND Create(HWND hParent = NULL, BOOL bInRenderMode = TRUE);

protected:
	virtual BOOL OnEraseBkgnd(HDC hDC) {return TRUE;}
	virtual void OnPaint(HDC hDC)	{}
	virtual void OnRender(BOOL bInternalCall = FALSE) {}
};

// Each device is represented by an ELEMENT object that is managed by
// CConfigWnd.
struct ELEMENT {
	ELEMENT() : nCurUser(-1), pPage(NULL), lpDID(NULL) {tszCaption[0] = 0;}
	// everything's cleaned up in CConfigWnd::ClearElement();
	DIDEVICEINSTANCEW didi;
	PAGETYPE *pPage;
	HWND hWnd;
	BOOL bCalc;
	RECT rect, textrect;
	TCHAR tszCaption[MAX_PATH];
	LPDIRECTINPUTDEVICE8W lpDID;

	// the map of acfors contains an acfor for each genre/username
	// that has been used so far on this device.  the dword represents
	// the genre username as follows:  the hiword is the index of the
	// genre per uiglobals.  the loword is the index of the username
	// per uiglobals.
	CMap<DWORD, DWORD &, LPDIACTIONFORMATW, LPDIACTIONFORMATW &> AcForMap;

#define MAP2GENRE(m) (int(((m) & 0xffff0000) >> 16))
#define MAP2USER(m) (int((m) & 0x0000ffff))
#define GENREUSER2MAP(g,u) \
	( \
		((((DWORD)(nGenre)) & 0xffff) << 16) | \
		(((DWORD)(nUser)) & 0xffff) \
	)

	// this function simply returns the corresponding entry in the
	// map if it already exists.  otherwise, it creates a copy for
	// this entry from the masteracfor and calls buildactionmap on
	// it with the appropriate username.

	// bHwDefault flag is added to properly support Reset button.  BuildActionMap must be
	// called with the flag to get hardware default mapping, so we need this parameter.
	LPDIACTIONFORMATW GetAcFor(int nGenre, int nUser, BOOL bHwDefault = FALSE);

	// we need to keep track of the current user per-element
	int nCurUser;

	// we need a pointer to the uiglobals in order to correspond
	// user indexes to the actual string
	CUIGlobals *pUIGlobals;

	// this function will be called in CConfigWnd::ClearElement to
	// free all the actionformats from the map
	void FreeMap();

	// Applies all the acfor's in the map
	void Apply();
};

typedef CArray<ELEMENT, ELEMENT &> ELEMENTARRAY;

// CConfigWnd needs to expose methods for child windows to notify it.
class CConfigWnd : public CFlexWnd, public IDIConfigUIFrameWindow
{
public:
	CConfigWnd(CUIGlobals &uig);
	~CConfigWnd();

	BOOL Create(HWND hParent);
	static void SetForegroundWindow();
	LPDIRECTINPUTDEVICE8W RenewDevice(GUID &GuidInstance);

	BOOL EnumDeviceCallback(const DIDEVICEINSTANCEW *lpdidi);
	void EnumDeviceCallbackAssignUser(const DIDEVICEINSTANCEW *lpdidi, DWORD *pdwOwner);

	CUIGlobals &m_uig;

	// IDIConfigUIFrameWindow implementation...

	// Reset Entire Configuration
	STDMETHOD (Reset) ();

	// Assignment Querying. GuidInstance is the guid of the device initiating the query.
	STDMETHOD (QueryActionAssignedAnywhere) (GUID GuidInstance, int i);

	// Genre Control
	STDMETHOD_(int, GetNumGenres) ();
	STDMETHOD (SetCurGenre) (int i);
	STDMETHOD_(int, GetCurGenre) ();

	// User Control
	STDMETHOD_(int, GetNumUsers) ();
	STDMETHOD (SetCurUser) (int nPage, int nUser);
	STDMETHOD_(int, GetCurUser) (int nPage);

	// ActionFormat Access
	STDMETHOD (GetActionFormatFromInstanceGuid) (LPDIACTIONFORMATW *lplpAcFor, REFGUID);

	// Main HWND Access
	STDMETHOD_(HWND, GetMainHWND) ();


protected:
	// overrides
	virtual void OnRender(BOOL bInternalCall = FALSE);
	virtual LRESULT OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual void OnPaint(HDC hDC);
	virtual void OnMouseOver(POINT point, WPARAM fwKeys);
	virtual void OnClick(POINT point, WPARAM fwKeys, BOOL bLeft);
	virtual void OnDestroy();
	virtual LRESULT WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:

#define CFGWND_INIT_REINIT 1
#define CFGWND_INIT_RESET 2

	BOOL Init(DWORD dwInitFlags = 0);
	DWORD m_dwInitFlags;
	BOOL m_bCreated;
	int AddToList(const DIDEVICEINSTANCEW *lpdidi, BOOL bReset = FALSE);
	void ClearList();
	void PlacePages();
	void GetPageRect(RECT &rect, BOOL bTemp = FALSE);
	void Render(BOOL bInternalCall = FALSE);

	ELEMENTARRAY m_Element;
	ELEMENT m_InvalidElement;
	int m_CurSel;
	int GetNumElements();
	ELEMENT &GetElement(int i);
	void ClearElement(int i, BOOL bReset = FALSE);
	void ClearElement(ELEMENT &e, BOOL bReset = FALSE);
	BOOL m_bScrollTabs, m_bScrollTabsLeft, m_bScrollTabsRight;
	int m_nLeftTab;
	RECT m_rectSTLeft, m_rectSTRight;
	void ScrollTabs(int);
	LPDIRECTINPUTDEVICE8W CreateDevice(GUID &guid);
	BOOL m_bNeedRedraw;
	CFlexMsgBox m_MsgBox;

	LPDIACTIONFORMATW GetCurAcFor(ELEMENT &e);

	int m_nCurGenre;

	IClassFactory *m_pPageFactory;
	HINSTANCE m_hPageFactoryInst;
	PAGETYPE *CreatePageObject(int nPage, const ELEMENT &e, HWND &refhChildWnd);
	void DestroyPageObject(PAGETYPE *&pPage);

	LPDIRECTINPUT8W m_lpDI;

	RECT m_rectTopGradient, m_rectBottomGradient;
	CBitmap *m_pbmTopGradient, *m_pbmBottomGradient;
	BOOL m_bHourGlass;  // Set when the cursor should be an hourglass

	typedef struct BUTTON {
		BUTTON() {CopyStr(tszCaption, _T(""), MAX_PATH);}
		RECT rect;
		TCHAR tszCaption[MAX_PATH];
		SIZE textsize;
		RECT textrect;
	} BUTTON;
	BUTTON m_Button[NUMBUTTONS];
	enum {
		BUTTON_RESET = 0,
		BUTTON_CANCEL,
		BUTTON_OK,
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
		BUTTON_LAYOUT
#endif
//@@END_MSINTERNAL
	};

	SIZE GetTextSize(LPCTSTR tszText);

	void CalcTabs();
	void CalcButtons();
	void InitGradients();

	void SelTab(int);
	void FireButton(int);
	void ShowPage(int);
	void HidePage(int);

	HDC GetRenderDC();
	void ReleaseRenderDC(HDC &phDC);
	void Create3DBitmap();
	void Copy3DBitmapToSurface3D();
	void CallRenderCallback();

	IDirectDrawSurface *m_pSurface;
	IDirect3DSurface8 *m_pSurface3D;
	D3DFORMAT m_SurfFormat;
	UINT m_uiPixelSize;  // Size of a pixel in byte for the format we are using
	CBitmap *m_pbmPointerEraser;
	CBitmap *m_pbm3D;
	LPVOID m_p3DBits;
	BOOL m_bRender3D;

	POINT m_ptTest;

	void MapBitmaps(HDC);
	BOOL m_bBitmapsMapped;

	BOOL m_bAllowEditLayout;
	BOOL m_bEditLayout;
	void ToggleLayoutEditting();

	CMouseTrap m_MouseTrap;

	// Timer
	static void CALLBACK TimerProc(UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);

	HRESULT Apply();

	// GuidInstance is the guid of the device initiating the query.
	BOOL IsActionAssignedAnywhere(GUID GuidInstance, int nActionIndex);

	void Unacquire();
	void Reacquire();
};


#endif //__CONFIGWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cyclestr.h ===
//-----------------------------------------------------------------------------
// File: cyclestr.h
//
// Desc: Implements a circular queue that provides space to hold a string
//       without repeatedly allocating and deallocating memory.  This is
//       only for short-term use such as outputting debug message to
//       ensure that the same buffer is not used at more than one place
//       simultaneously.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __CYCLESTR_H__
#define __CYCLESTR_H__


LPTSTR getcyclestr();
LPCTSTR SAFESTR(LPCWSTR);
LPCTSTR SAFESTR(LPCSTR);
LPCTSTR QSAFESTR(LPCWSTR);
LPCTSTR QSAFESTR(LPCSTR);
LPCTSTR BOOLSTR(BOOL);
LPCTSTR RECTSTR(RECT &);
LPCTSTR RECTDIMSTR(RECT &);
LPCTSTR POINTSTR(POINT &);
LPCTSTR GUIDSTR(const GUID &);
LPCTSTR SUPERSTR(LPCWSTR);
LPCTSTR SUPERSTR(LPCSTR);


#endif //__CYCLESTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\configwnd.cpp ===
//-----------------------------------------------------------------------------
// File: configwnd.cpp
//
// Desc: CConfigWnd is derived from CFlexWnd. It implements the top-level
//       UI window which all other windows are descendents of.
//
//       Functionalities handled by CConfigWnd are device tabs, Reset, Ok,
//       and Cancel buttons.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


LPCTSTR g_tszAppWindowName = _T("DINPUT Default Mapper UI");

const int WINDOW_WIDTH = 640;
const int WINDOW_HEIGHT = 480;
const int TABTEXTMARGINLEFT = 7;
const int TABTEXTMARGINTOP = 3;
const int TABTEXTMARGINRIGHT = 7;
const int TABTEXTMARGINBOTTOM = 4;
const int BUTTONTEXTMARGINLEFT = 7;
const int BUTTONTEXTMARGINTOP = 3;
const int BUTTONTEXTMARGINRIGHT = 7;
const int BUTTONTEXTMARGINBOTTOM = 4;
const int BARBUTTONMARGINLEFT = 9;
const int BARBUTTONMARGINTOP = 4;
const int BARBUTTONMARGINRIGHT = 9;
const int BARBUTTONMARGINBOTTOM = 5;
const int BARBUTTONSPACING = 4;

//#define WM_QUERYACTIONASSIGNEDANYWHERE (WM_USER + 4)


CConfigWnd::CConfigWnd(CUIGlobals &uig) :
	m_uig(uig),
	m_bCreated(FALSE),
	m_pPageFactory(NULL),
	m_hPageFactoryInst(NULL),
	m_pSurface(NULL),
	m_pSurface3D(NULL),
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	m_bEditLayout(uig.QueryAllowEditLayout()),
#endif
//@@END_MSINTERNAL
	m_CurSel(-1),
	m_nCurGenre(0),
	m_pbmTopGradient(NULL),
	m_pbmBottomGradient(NULL),
	m_pbmPointerEraser(NULL),
	m_pbm3D(NULL),
	m_p3DBits(NULL),
	m_SurfFormat(D3DFMT_UNKNOWN),
	m_uiPixelSize(4),
	m_bBitmapsMapped(FALSE),
	m_lpDI(NULL),
	m_bScrollTabs(FALSE),
	m_bScrollTabsLeft(FALSE),
	m_bScrollTabsRight(FALSE),
	m_nLeftTab(0),
	m_dwInitFlags(0),
	m_bHourGlass(FALSE),
	m_bNeedRedraw(FALSE)
{
	tracescope(__ts, _T("CConfigWnd::CConfigWnd()\n"));
	m_lpDI = m_uig.GetDI();

	m_pSurface = m_uig.GetSurface();
	m_pSurface3D = m_uig.GetSurface3D();

	if (m_pSurface != NULL || m_pSurface3D != NULL)
	{
		if (m_pSurface != NULL && m_pSurface3D != NULL)
		{
			etrace(_T("Both Surface and Surface3D are non-NULL, will use only Surface3D\n"));
		
			m_pSurface->Release();
			m_pSurface = NULL;

			assert(m_pSurface3D != NULL);
			assert(m_pSurface == NULL);
		}

		assert(m_pSurface != NULL || m_pSurface3D != NULL);
		assert(!(m_pSurface != NULL && m_pSurface3D != NULL));

		m_bRender3D = (m_pSurface3D != NULL);

		SetRenderMode();
		trace(_T("RenderMode set\n"));
		traceBOOL(m_bRender3D);

		if (m_bRender3D)
			Create3DBitmap();

		HDC hDC = GetRenderDC();
		if (hDC != NULL)
		{
			m_pbmPointerEraser = CBitmap::Create(
				GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON),
				hDC);

			ReleaseRenderDC(hDC);
		}
		else
			etrace(_T("Failed to get Render DC"));
	}
}

CConfigWnd::~CConfigWnd()
{
	tracescope(__ts, _T("CConfigWnd::~CConfigWnd()\n"));
	ClearList();

	if (m_lpDI != NULL)
		m_lpDI->Release();
	m_lpDI = NULL;

	if (m_pSurface != NULL)
		m_pSurface->Release();
	m_pSurface = NULL;

	if (m_pSurface3D != NULL)
		m_pSurface3D->Release();
	m_pSurface3D = NULL;

	if (m_pPageFactory != NULL)
		m_pPageFactory->Release();
	m_pPageFactory = NULL;

	if (m_hPageFactoryInst != NULL)
		FreeLibrary(m_hPageFactoryInst);
	m_hPageFactoryInst = NULL;

	if (m_pbmPointerEraser != NULL)
		delete m_pbmPointerEraser;
	m_pbmPointerEraser = NULL;

	if (m_pbm3D != NULL)
		delete m_pbm3D;
	m_pbm3D = NULL;

	if (m_pbmTopGradient != NULL)
		delete m_pbmTopGradient;
	m_pbmTopGradient = NULL;

	if (m_pbmBottomGradient != NULL)
		delete m_pbmBottomGradient;
	m_pbmBottomGradient = NULL;
}

HWND CMouseTrap::Create(HWND hParent, BOOL bInRenderMode)
{
	if (m_hWnd)
		return m_hWnd;

	m_hParent = hParent;
	int sx = GetSystemMetrics(SM_CXSCREEN);
	int sy = GetSystemMetrics(SM_CYSCREEN);
	RECT rect = {0, 0, sx, sy};

	// If we are not in render mode, the trap window is exactly the same as the parent window
	if (!bInRenderMode)
		GetWindowRect(hParent, &rect);

	return CFlexWnd::Create(
		hParent,
		NULL,
		WS_EX_TOPMOST,
		WS_POPUP | WS_VISIBLE,
		rect);
}

BOOL CConfigWnd::Create(HWND hParent)
{
	tracescope(__ts, _T("CConfigWnd::Create()\n"));
	traceHEX(hParent);

	HRESULT hresult = PrivGetClassObject(CLSID_CDIDeviceActionConfigPage, CLSCTX_INPROC_SERVER, NULL,  IID_IClassFactory, (LPVOID*) &m_pPageFactory, &m_hPageFactoryInst);
	if (FAILED(hresult))
	{
		// TODO: indicate failure to create page factory
		m_pPageFactory = NULL;
		m_hPageFactoryInst = NULL;
		etrace1(_T("Failed to create page classfactory, PrivGetClassObject() returned 0x%08x\n"), hresult);
		return FALSE;
	}

	int sx = GetSystemMetrics(SM_CXSCREEN);
	int sy = GetSystemMetrics(SM_CYSCREEN);
	int w = WINDOW_WIDTH;
	int h = WINDOW_HEIGHT;
	int rx = sx - w;
	int ry = sy - h;
	RECT rect = {rx / 2, ry / 2, 0, 0};
	rect.right = rect.left + w;
	rect.bottom = rect.top + h;

	HWND hConfigParent = hParent;

	if (InRenderMode())
	{
		hConfigParent = m_MouseTrap.Create(hParent, InRenderMode());
		if (hConfigParent == NULL)
			hConfigParent = hParent;
	}

	HWND hRet = CFlexWnd::Create(
		hConfigParent,
		g_tszAppWindowName,
		0,
		WS_POPUP | WS_VISIBLE | WS_CLIPCHILDREN,
		rect);

	if (hRet == NULL)
		etrace(_T("CFlexWnd::Create() failed!\n"));

	// Set the cursor extent to this window if we are in render mode (full-screen)
	if (InRenderMode())
	{
		RECT rc;
		GetWindowRect(m_hWnd, &rc);
		ClipCursor(&rc);
	}

	return NULL != hRet;
}

void CConfigWnd::SetForegroundWindow()
{
	// find the window
	HWND hWnd = FindWindow(GetDefaultClassName(), g_tszAppWindowName);

	// activate it if found
	if (NULL != hWnd)
		::SetForegroundWindow(hWnd);
}

void CConfigWnd::OnPaint(HDC hDC)
{
	if (hDC == NULL)
		return;

	SIZE topsize = GetRectSize(m_rectTopGradient);
	SIZE bottomsize = GetRectSize(m_rectBottomGradient);
	SIZE bsize = {max(topsize.cx, bottomsize.cx),
		max(topsize.cy, bottomsize.cy)};
	CBitmap *pbm = CBitmap::Create(bsize, hDC);
	if (pbm == NULL)
		return;
	HDC hBDC = NULL, hODC = hDC;
	if (m_bHourGlass)
	{
		if (!InRenderMode())
		{
			// If not in fullscreen mode, change cursor to hourglass
			HCURSOR hCursor;
			hCursor = LoadCursor(NULL, IDC_WAIT);
			SetCursor(hCursor);
		} else
		{
			// If in fullscreen mode, hide the cursor during reset process.
			SetCursor(NULL);
		}
	}

	hBDC = pbm->BeginPaintInto(hDC);
	if (hBDC == NULL)
	{
		delete pbm;
		return;
	}
	hDC = hBDC;

	if (m_pbmTopGradient != NULL)
		m_pbmTopGradient->Draw(hDC);

	{
		CPaintHelper ph(m_uig, hDC);

		ph.SetElement(UIE_BORDER);

		ph.MoveTo(0, m_rectTopGradient.bottom - 1);
		ph.LineTo(WINDOW_WIDTH, m_rectTopGradient.bottom - 1);

		int i;
		for (i = 0; i < GetNumElements(); i++)
		{
			const ELEMENT &e = GetElement(i);
			BOOL bSel = i == m_CurSel;

			ph.SetElement(bSel ? UIE_SELTAB : UIE_TAB);

			ph.Rectangle(e.rect);
			RECT trect = e.textrect;
			DrawText(hDC, e.tszCaption, -1, &trect, DT_NOCLIP | DT_NOPREFIX);

			if (bSel)
			{
				ph.SetPen(UIP_BLACK);

				ph.MoveTo(e.rect.left + 1, e.rect.bottom - 1);
				ph.LineTo(e.rect.right - 1, e.rect.bottom - 1);
			}
		}

		if (m_bScrollTabs && GetNumElements() > 0)
		{
			ph.SetElement(UIE_TABARROW);

			const ELEMENT &e = GetElement(0);
			int h = e.rect.bottom - e.rect.top;

			for (i = 0; i < 2; i++)
			{
				RECT &rect = i == 0 ? m_rectSTRight : m_rectSTLeft;
				BOOL bDraw = i ? m_bScrollTabsLeft : m_bScrollTabsRight;
				ph.Rectangle(rect);
				
				if (!bDraw)
					continue;

				int d,l,r,m,t,b, f = !i, w;
				w = rect.right - rect.left;

				l = f ? w / 4 : 3 * w / 8;
				r = f ? 5 * w / 8 : 3 * w / 4;
				d = r - l;
				m = w / 2;
				t = m - d;
				b = m + d;

				l += rect.left;
				r += rect.left;

				POINT p[4];
				p[3].x = p[0].x = f ? l : r;
				p[2].x = p[1].x = f ? r : l; 
				p[3].y = p[0].y = m;
				p[1].y = t;
				p[2].y = b;

				Polyline(hDC, p, 4);
			}
		}
	}

	pbm->Draw(hODC, topsize);
	m_pbmBottomGradient->Draw(hDC);

	{
		CPaintHelper ph(m_uig, hDC);

		ph.SetElement(UIE_BORDER);

		Rectangle(hDC, 0, -1, WINDOW_WIDTH,
			GetRectSize(m_rectBottomGradient).cy);

		for (int i = 0; i < NUMBUTTONS; i++)
		{
			BOOL bOkOnly = !m_uig.InEditMode();
			const BUTTON &b = m_Button[i];

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
			BOOL bLayoutButton = i == BUTTON_LAYOUT;

			if (!m_uig.QueryAllowEditLayout() && bLayoutButton)
				continue;
#endif
//@@END_MSINTERNAL

			if ( bOkOnly && i != BUTTON_CANCEL
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
			     && !bLayoutButton
#endif
//@@END_MSINTERNAL
			   )
				continue;

			if (i == BUTTON_OK || bOkOnly)
				ph.SetElement(UIE_DEFBUTTON);
			else
				ph.SetElement(UIE_BUTTON);

			int ay = m_rectBottomGradient.top;
			ph.Rectangle(b.rect.left, b.rect.top - ay, b.rect.right, b.rect.bottom - ay);
			RECT trect = b.textrect;
			OffsetRect(&trect, 0, -ay);
			DrawText(hDC, b.tszCaption, -1, &trect, DT_NOCLIP | DT_NOPREFIX);
		}
	}

	pbm->Draw(hODC, m_rectBottomGradient.left, m_rectBottomGradient.top, bottomsize);

	pbm->EndPaintInto(hBDC);
	delete pbm;

	hDC = hODC;

	{
		CPaintHelper ph(m_uig, hDC);

		ph.SetElement(UIE_BORDER);

		ph.MoveTo(0, m_rectTopGradient.bottom);
		ph.LineTo(0, m_rectBottomGradient.top);

		ph.MoveTo(WINDOW_WIDTH - 1, m_rectTopGradient.bottom);
		ph.LineTo(WINDOW_WIDTH - 1, m_rectBottomGradient.top);
	}
}

void CConfigWnd::OnClick(POINT point, WPARAM fwKeys, BOOL bLeft)
{
	int i;

	// Un-highlight the current callout
	SendMessage(CFlexWnd::s_CurrPageHwnd, WM_UNHIGHLIGHT, 0, 0);

	// check scroll tab buttons
	if (m_bScrollTabs)
		for (i = 0; i < 2; i++)
		{
			RECT &r = !i ? m_rectSTRight : m_rectSTLeft;
			BOOL b = !i ? m_bScrollTabsRight : m_bScrollTabsLeft;
			if (PtInRect(&r, point))
			{
				if (b)
					ScrollTabs(!i ? -1 : 1);
				return;
			}
		}

	// check tabs
	for (i = 0; i < GetNumElements(); i++)
		if (PtInRect(&(GetElement(i).rect), point))
		{
			// Check if the tab is partially obscured.  If so we scroll the tab so it becomes completely visible.
			POINT pt = {m_rectSTLeft.left, m_rectSTLeft.top};
			if (m_bScrollTabsRight || m_bScrollTabsLeft)
			{
				while (PtInRect(&(GetElement(i).rect), pt))
					ScrollTabs(1);
			}
			SelTab(i);
			return;
		}

	// check buttons
	for (i = 0; i < NUMBUTTONS; i++)
		if (PtInRect(&(m_Button[i].rect), point))
		{
			FireButton(i);
			return;
		}
}

void CConfigWnd::ScrollTabs(int by)
{
	m_nLeftTab += by;
	if (m_nLeftTab < 0)
		m_nLeftTab = 0;
	if (m_nLeftTab >= GetNumElements())
		m_nLeftTab = GetNumElements() - 1;
	CalcTabs();
	Invalidate();
}

void CConfigWnd::OnDestroy()
{
	tracescope(__ts, _T("CConfigWnd::OnDestroy()\n"));
	ClipCursor(NULL);  // Set cursor extent to entire desktop.
	if (m_bCreated)
		PostQuitMessage(EXIT_SUCCESS);
}

LRESULT CConfigWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	tracescope(__ts, _T("CConfigWnd::OnCreate()\n"));

	if (!Init())
	{
		etrace(_T("CConfigWnd::Init() failed\n"));
		return -1;
	}
	else
		m_bCreated = TRUE;

	return 0;
}

BOOL CALLBACK EnumDeviceCallback(const DIDEVICEINSTANCEW *lpdidi, LPDIRECTINPUTDEVICE8W pdiDev8W, DWORD dwFlags, DWORD dwDeviceRemaining, LPVOID pvRef)
{
	if (pvRef != NULL)
		return ((CConfigWnd *)pvRef)->EnumDeviceCallback(lpdidi);
	else
		return DIENUM_STOP;
}

BOOL CConfigWnd::EnumDeviceCallback(const DIDEVICEINSTANCEW *lpdidi)
{
	DIDEVICEINSTANCEW didi;
	didi.dwSize = sizeof(DIDEVICEINSTANCEW);
	didi.guidInstance = lpdidi->guidInstance;
	didi.guidProduct = lpdidi->guidProduct;
	didi.dwDevType = lpdidi->dwDevType;
	CopyStr(didi.tszInstanceName, lpdidi->tszInstanceName, MAX_PATH);
	CopyStr(didi.tszProductName, lpdidi->tszProductName, MAX_PATH);
	didi.guidFFDriver = lpdidi->guidFFDriver;
	didi.wUsagePage = lpdidi->wUsagePage;
	didi.wUsage = lpdidi->wUsage;

	AddToList(&didi);

	return DIENUM_CONTINUE;
}

// show any error message here if returning false
BOOL CConfigWnd::Init(DWORD dwInitFlags)
{
	tracescope(__ts, _T("CConfigWnd::Init()\n"));

	HRESULT hr = S_OK;
	BOOL bReInit = !!(dwInitFlags & CFGWND_INIT_REINIT);

	m_dwInitFlags = dwInitFlags;
	SetOnFunctionExit<DWORD> _set_m_dwInitFlags(m_dwInitFlags, 0);

	// make sure we have DI
	assert(m_lpDI != NULL);
	if (m_lpDI == NULL)
	{
		etrace(_T("NULL m_lpDI\n"));
		return FALSE;
	}

	if (!(dwInitFlags & CFGWND_INIT_RESET))
	{
		// If we are not doing reset, clear device list then re-enumerate and rebuild.

		// clear list
		ClearList();

		// enum devices
		{
			tracescope(ts, _T("Enumerating Devices...\n\n"));

			DWORD dwFlags = DIEDBSFL_ATTACHEDONLY;
			hr = m_lpDI->EnumDevicesBySemantics(NULL, (LPDIACTIONFORMATW)&m_uig.RefMasterAcFor(m_nCurGenre), ::EnumDeviceCallback, (LPVOID)this, dwFlags);

			trace(_T("\n"));
		}
	} else
	{
		DIDEVICEINSTANCEW didiCopy;
		// Saves a copy of device instance as the current ELEMENT will be freed by AddToList().
		CopyMemory(&didiCopy, &GetElement(m_CurSel).didi, sizeof(didiCopy));
		// If resetting, call AddToList with bReset as TRUE to just get default mappings.
		AddToList(&didiCopy, TRUE);
	}

	// handle potential enum failure
	if (FAILED(hr))
	{
		etrace1(_T("EnumDevicesBySemantics() failed, returning 0x%08x\n"), hr);
		return FALSE;
	}

	// if there are no elements, fail
	if (GetNumElements() < 1)
	{
		etrace(_T("No devices\n"));
		return FALSE;
	}

	// calculate tabs, buttons, init gradients
	CalcTabs();
	if (!bReInit)
	{
		CalcButtons();
		InitGradients();

		// set the timer
		if (InRenderMode())
		{
			if (g_fptimeSetEvent)
				g_fptimeSetEvent(20, 20, CConfigWnd::TimerProc,
				                 (DWORD_PTR)m_hWnd, TIME_ONESHOT);
			Render();
		}
	}

	// make sure all the pages are in the right place
	PlacePages();

	// show the first page if we are not resetting. Show current page if we are.
	int CurSel = (dwInitFlags & CFGWND_INIT_RESET) ? m_CurSel : 0;
	m_CurSel = -1;
	SelTab(CurSel);

	// if we're already editting the layout, set it.
	// KLUDGE, set false and toggle to set
	if (m_bEditLayout)
	{
		m_bEditLayout = FALSE;
		ToggleLayoutEditting();
	}

	trace(_T("\n"));

	return TRUE;
}

// This is called once for each device that will get configured.
int CConfigWnd::AddToList(const DIDEVICEINSTANCEW *lpdidi, BOOL bReset)
{
	if (lpdidi == NULL)
	{
		etrace(_T("NULL lpdidi"));
		assert(0);
		return GetNumElements();
	}

	int i;

	tracescope(ts, _T("Adding Device "));
	trace(QSAFESTR(lpdidi->tszInstanceName));
	trace(_T("\n\n"));

	// add an element and get it if we are not doing reset (adding new device)
	if (!bReset)
	{
		i = GetNumElements();
		m_Element.SetSize(i + 1);
	}
	else
	{
		i = m_CurSel;
		ClearElement(m_CurSel, bReset);  // If resetting, clear the current ELEMENT as we will populate it below.
	}

	// If we are doing reset, then we use the existing ELEMENT that this device is already using.
	ELEMENT &e = bReset ? GetElement(m_CurSel) : GetElement(i);

	// set various needed variables
	e.didi = *lpdidi;
	e.bCalc = FALSE;
	e.pUIGlobals = &m_uig;

	// create and set the device
	if (m_lpDI == NULL)
	{
		e.lpDID = NULL;
		etrace(_T("m_lpDI NULL!  Can't create this device.\n"));
	}
	else
	{
		e.lpDID = CreateDevice(e.didi.guidInstance);
		if (!e.lpDID)
			etrace(_T("Failed to create device!\n"));
	}

	if (!bReset)
	{
		// Find owner of device only if we are not doing reset.
		// set starting current user index
		DIPROPSTRING dips;
		dips.diph.dwSize = sizeof(DIPROPSTRING);
		dips.diph.dwHeaderSize = sizeof(DIPROPHEADER);
		dips.diph.dwObj = DIPH_DEVICE;
		dips.diph.dwHow = 0;
		CopyStr(dips.wsz, "", MAX_PATH);
		if (!e.lpDID)
		{
			etrace(_T("no lpDID, assuming device unassigned\n"));
			e.nCurUser = -1;
		}
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
		else if (m_uig.QueryAllowEditLayout())
		{
			trace(_T("In DDK mode.  Set user to 0 automatically.\n"));
			e.nCurUser = 0;
		}
#endif
//@@END_MSINTERNAL
		else
		{
			HRESULT hr = e.lpDID->GetProperty(DIPROP_USERNAME, (LPDIPROPHEADER)&dips);
			e.nCurUser = -1; // unassigned unless getusernameindex below works
			if (FAILED(hr))
				etrace(_T("GetProperty(DIPROP_USERNAME,...) failed\n"));
			else if (hr == S_FALSE)
				trace(_T("GetProperty(DIPROP_USERNAME,...) returned S_FALSE\n"));
			else if (StrLen(dips.wsz) < 1)
				trace(_T("GetProperty(DIPROP_USERNAME,...) returned empty string\n"));
			else
			{
				trace(_T("Getting user name index for "));
				traceWSTR(dips.wsz);
				e.nCurUser = m_uig.GetUserNameIndex(dips.wsz);
				trace(_T("Result: "));
				traceLONG(e.nCurUser);
				if (e.nCurUser == -1)
					etrace(_T("Device assigned to user not passed to ConfigureDevices()\nConsidering unassigned now\n"));
			}
		}
	}

	// create and set the page object
	HWND hwndChild = NULL;
	e.pPage = CreatePageObject(i, e, hwndChild);
	if (e.pPage == NULL)
		etrace(_T("Failed to create page object!\n"));
	e.hWnd = hwndChild;
	if (e.hWnd == NULL)
		etrace(_T("CreatePageObject() returned NULL hwnd!\n"));

	// create/test the first acfor for this device with cur genre/user
	traceLONG(m_nCurGenre);
	traceLONG(e.nCurUser);
	LPDIACTIONFORMATW lpAcFor = NULL;
	if (e.nCurUser != -1)
	{
		lpAcFor = e.GetAcFor(m_nCurGenre, e.nCurUser, bReset);
		if (lpAcFor != NULL)
			TraceActionFormat(_T("Starting Device ActionFormat:"), *lpAcFor);
		else
			etrace(_T("Failed to create starting ActionFormat\n"));
	}
	else
		trace(_T("Device unassigned\n"));

	// check if anything was unsuccessful
	if ((lpAcFor == NULL && e.nCurUser != -1) || e.lpDID == NULL || e.pPage == NULL || e.hWnd == NULL)
	{
		// clear what was successful, set the size back (remove element),
		// and indicate error
		ClearElement(e);
		m_Element.SetSize(i);
		etrace(_T("Can't add this device - Element removed\n"));
	}

	trace(_T("\n"));

	return GetNumElements();
}

LPDIRECTINPUTDEVICE8W CConfigWnd::CreateDevice(GUID &guid)
{
	LPDIRECTINPUTDEVICE8W lpDID;

	HRESULT hr = m_lpDI->CreateDevice(guid, &lpDID, NULL);
	if (FAILED(hr) || lpDID == NULL)
	{
		etrace2(_T("Could not create device (guid %s), CreateDevice() returned 0x%08x\n"), GUIDSTR(guid), hr);
		return NULL;
	}
	
	return lpDID;
}

void CConfigWnd::ClearElement(int i, BOOL bReset)
{
	ELEMENT &e = GetElement(i);
	ClearElement(e, bReset);
}

void CConfigWnd::ClearElement(ELEMENT &e, BOOL bReset)
{
	if (e.pPage != NULL)
		DestroyPageObject(e.pPage);
	if (e.lpDID != NULL)
	{
		e.lpDID->Release();
		e.lpDID = NULL;
	}
	e.pPage = NULL;
	e.lpDID = NULL;
	e.hWnd = NULL;
	e.pUIGlobals = NULL; // not freed
	if (!bReset)  // Free map only if we are not resetting (delete permanently).
		e.FreeMap();
}

void CConfigWnd::ClearList()
{
	int i;
	for (i = 0; i < GetNumElements(); i++)
		ClearElement(i);
	m_Element.RemoveAll();
	assert(!GetNumElements());
}

void CConfigWnd::PlacePages()
{
	RECT rect;
	GetPageRect(rect);

	for (int i = 0; i < GetNumElements(); i++)
	{
		DWORD flags = SWP_NOZORDER | SWP_NOACTIVATE;
		SetWindowPos(GetElement(i).hWnd, NULL,
			rect.left, rect.top,
			rect.right - rect.left,
			rect.bottom - rect.top, flags);
	}
}

SIZE CConfigWnd::GetTextSize(LPCTSTR tszText)
{
	RECT trect = {0, 0, 1, 1};
	HDC hDC = CreateCompatibleDC(NULL);
	if (hDC != NULL)
	{
		{
			CPaintHelper ph(m_uig, hDC);
			ph.SetFont(UIF_FRAME);
			DrawText(hDC, tszText, -1, &trect, DT_CALCRECT | DT_NOPREFIX);
		}
		DeleteDC(hDC);
	}
	SIZE size = {trect.right - trect.left, trect.bottom - trect.top};
	return size;
}

void CConfigWnd::InitGradients()
{
	if (m_pbmTopGradient == NULL)
		m_pbmTopGradient = CBitmap::CreateHorzGradient(m_rectTopGradient, m_uig.GetColor(UIC_CONTROLFILL), m_uig.GetColor(UIC_CONTROLFILL));
	if (m_pbmBottomGradient == NULL)
		m_pbmBottomGradient = CBitmap::CreateHorzGradient(m_rectBottomGradient, m_uig.GetColor(UIC_CONTROLFILL), m_uig.GetColor(UIC_CONTROLFILL));
}

void CConfigWnd::CalcTabs()
{
	int i, maxh = 0, lastx = 0;
	for (i = 0; i < GetNumElements(); i++)
	{
		ELEMENT &e = GetElement(i);
		CopyStr(e.tszCaption, e.didi.tszInstanceName, MAX_PATH);
		e.rect.left = i > 0 ? GetElement(i - 1).rect.right - 1 : 0;
		e.rect.top = 0;
		SIZE tsize = GetTextSize(e.tszCaption);
		e.textrect.left = e.textrect.top = 0;
		e.textrect.right = tsize.cx;
		e.textrect.bottom = tsize.cy;
		OffsetRect(&e.textrect, e.rect.left + TABTEXTMARGINLEFT, e.rect.top + TABTEXTMARGINTOP);
		int w = tsize.cx;
		int h = tsize.cy;
		e.rect.right = e.rect.left + TABTEXTMARGINLEFT + w + TABTEXTMARGINRIGHT + 1;
		e.rect.bottom = e.rect.top + TABTEXTMARGINTOP + h + TABTEXTMARGINBOTTOM;
		h = e.rect.bottom - e.rect.top;
		if (h > maxh) maxh = h;
		e.bCalc = TRUE;
	}

	for (i = 0; i < GetNumElements(); i++)
	{
		ELEMENT &e = GetElement(i);
		e.rect.bottom = e.rect.top + maxh;
		lastx = e.rect.right;
	}

	if (lastx > WINDOW_WIDTH)
	{
		if (!m_bScrollTabs)
			m_nLeftTab = 0;
		m_bScrollTabs = TRUE;
	}
	else
	{
		m_bScrollTabs = FALSE;
		m_nLeftTab = 0;
	}

	int cutoff = WINDOW_WIDTH;
	if (m_bScrollTabs)
	{
		cutoff = WINDOW_WIDTH - maxh * 2;
		RECT r = {WINDOW_WIDTH - maxh, 0, WINDOW_WIDTH, maxh};
		m_rectSTLeft = r;
		OffsetRect(&r, -(maxh - 1), 0);
		m_rectSTRight = r;
	}

	if (m_bScrollTabs && m_nLeftTab > 0)
	{
		int left = GetElement(m_nLeftTab).rect.left, right = 0;
		for (i = 0; i < GetNumElements(); i++)
		{
			ELEMENT &e = GetElement(i);
			OffsetRect(&e.rect, -left, 0);
			OffsetRect(&e.textrect, -left, 0);
			if (e.rect.right > right)
				right = e.rect.right;
		}
		lastx = right;
	}

	if (m_bScrollTabs)
	{
		m_bScrollTabsLeft = lastx > cutoff && m_nLeftTab < GetNumElements() - 1;
		m_bScrollTabsRight = m_nLeftTab > 0;
	}

	RECT t = {0/*lastx*/, 0, WINDOW_WIDTH, maxh};
	m_rectTopGradient = t;
}

void CConfigWnd::CalcButtons()
{
	SIZE max = {0, 0};
	int i;
	for (i = 0; i < NUMBUTTONS; i++)
	{
		BUTTON &b = m_Button[i];

		if (!StrLen(b.tszCaption))
		{
			switch (i)
			{
				case BUTTON_RESET:
				LoadString(g_hModule, IDS_BUTTON_RESET, b.tszCaption, MAX_PATH);
				break;

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
			case BUTTON_LAYOUT:
				LoadString(g_hModule, IDS_BUTTON_LAYOUT, b.tszCaption, MAX_PATH);
				break;
#endif
//@@END_MSINTERNAL

			case BUTTON_CANCEL:
				if (m_uig.InEditMode())
				{
					LoadString(g_hModule, IDS_BUTTON_CANCEL, b.tszCaption, MAX_PATH);
					break;
				}
				// else, intentional fallthrough

			case BUTTON_OK:
				LoadString(g_hModule, IDS_BUTTON_OK, b.tszCaption, MAX_PATH);
				break;
			}
		}

		b.textsize = GetTextSize(b.tszCaption);

		if (b.textsize.cx > max.cx)
			max.cx = b.textsize.cx;
		if (b.textsize.cy > max.cy)
			max.cy = b.textsize.cy;
	}

	max.cx += BUTTONTEXTMARGINLEFT + BUTTONTEXTMARGINRIGHT;
	max.cy += BUTTONTEXTMARGINTOP + BUTTONTEXTMARGINBOTTOM;

	m_rectBottomGradient.bottom = WINDOW_HEIGHT;
	m_rectBottomGradient.top = m_rectBottomGradient.bottom - max.cy - BARBUTTONMARGINTOP - BARBUTTONMARGINBOTTOM;
	m_rectBottomGradient.left = 0;
	m_rectBottomGradient.right = WINDOW_WIDTH;

	for (i = 0; i < NUMBUTTONS; i++)
	{
		BUTTON &b = m_Button[i];

		RECT z = {0,0,0,0};

		b.rect = z;
		b.rect.right = max.cx;
		b.rect.bottom = max.cy;

		int by = m_rectBottomGradient.top + BARBUTTONMARGINTOP;

		switch (i)
		{
			case BUTTON_RESET:
				OffsetRect(&b.rect, BARBUTTONMARGINLEFT, by);
				break;

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
			case BUTTON_LAYOUT:
				OffsetRect(&b.rect, WINDOW_WIDTH / 2 - max.cx / 2, by);
				break;
#endif
//@@END_MSINTERNAL

			case BUTTON_CANCEL:
				OffsetRect(&b.rect,
				m_rectBottomGradient.right - BARBUTTONMARGINRIGHT - max.cx, by);
				break;

			case BUTTON_OK:
				OffsetRect(&b.rect,
				m_rectBottomGradient.right - BARBUTTONMARGINRIGHT - max.cx - max.cx - BARBUTTONSPACING, by);
				break;
		}

		POINT m = {(b.rect.right + b.rect.left) / 2, (b.rect.bottom + b.rect.top) / 2};
		b.textrect.left = m.x - b.textsize.cx / 2;
		b.textrect.top = m.y - b.textsize.cy / 2;
		b.textrect.right = b.textrect.left + b.textsize.cx;
		b.textrect.bottom = b.textrect.top + b.textsize.cy;
	}
}

void CConfigWnd::GetPageRect(RECT &rect, BOOL bTemp)
{
	if (bTemp)
	{
		rect.left = 1;
		rect.right = WINDOW_WIDTH - 1;
		rect.top = 40;
		rect.bottom = WINDOW_HEIGHT - 40;
	}
	else
	{
		rect.left = 1;
		rect.right = WINDOW_WIDTH - 1;
		rect.top = m_rectTopGradient.bottom;
		rect.bottom = m_rectBottomGradient.top;
	}
}

void CConfigWnd::ToggleLayoutEditting()
{
	m_bEditLayout = !m_bEditLayout;

	for (int i = 0; i < GetNumElements(); i++)
	{
		ELEMENT &e = GetElement(i);
		if (e.pPage)
			e.pPage->SetEditLayout(m_bEditLayout);
	}
}

void CConfigWnd::FireButton(int b)
{
	switch(b)
	{
		case BUTTON_OK:
			if (!m_uig.InEditMode())
				break;  // If not in edit mode, Ok button doesn't not exist so we shouldn't do anything.
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
			if (m_uig.QueryAllowEditLayout())
			{
				int MsgBoxRet = MessageBox(m_hWnd, _T("Do you wish to save layout information?"), _T("Save"), MB_YESNOCANCEL);
				if (MsgBoxRet == IDYES)
				{
					// Write IHV settings for all devices.
					for (int i = 0; i < GetNumElements(); i++)
						GetElement(i).pPage->WriteIHVSetting();
				}
				else
				if (MsgBoxRet == IDCANCEL)
					break;
			} else
#endif
//@@END_MSINTERNAL
				Apply();  // If we are in Edit Layout mode, do not call Apply() to save to user setting.
			// intentional fallthrough

		case BUTTON_CANCEL:
			Destroy();
			break;

		case BUTTON_RESET:
			if (m_uig.InEditMode())  // Only reset if in edit mode.  Do nothing in view mode.
				Reset();
			break;

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
		case BUTTON_LAYOUT:
			if (m_uig.QueryAllowEditLayout())
				ToggleLayoutEditting();
			break;
#endif
//@@END_MSINTERNAL

		default:
			assert(0);
			break;
	}
}

void CConfigWnd::SelTab(int i)
{
	if (i >= 0 && i < GetNumElements())
	{
		if (i == m_CurSel)
			return;
		ShowPage(i);
		HidePage(m_CurSel);
		m_CurSel = i;
		Invalidate();
	}
}

PAGETYPE *CConfigWnd::CreatePageObject(int nPage, const ELEMENT &e, HWND &refhChildWnd)
{
	if (m_pPageFactory == NULL)
		return NULL;

	PAGETYPE *pPage = NULL;
	HRESULT hresult = m_pPageFactory->CreateInstance(NULL, IID_IDIDeviceActionConfigPage, (LPVOID*) &pPage);
	if (FAILED(hresult) || pPage == NULL)
		return NULL;

	DICFGPAGECREATESTRUCT cs;
	cs.dwSize = sizeof(DICFGPAGECREATESTRUCT);
	cs.nPage = nPage;
	cs.hParentWnd = m_hWnd;
	GetPageRect(cs.rect, TRUE);
	cs.hPageWnd = NULL;
	cs.didi = e.didi;
	cs.lpDID = e.lpDID;
	cs.pUIGlobals = &m_uig;
	cs.pUIFrame = dynamic_cast<IDIConfigUIFrameWindow *>(this);

	hresult = pPage->Create(&cs);
	if (FAILED(hresult))
	{
		etrace1(_T("pPage->Create() failed, returning 0x%08x\n"), hresult);
		pPage->Release();
		return NULL;
	}

	refhChildWnd = cs.hPageWnd;

	return pPage;
}

void CConfigWnd::DestroyPageObject(PAGETYPE *&pPage)
{
	if (pPage != NULL)
		pPage->Release();
	pPage = NULL;
}

void CConfigWnd::ShowPage(int i)
{
	if (i == -1)
		return;

	if (i < 0 || i >= GetNumElements())
	{
		assert(0);
		return;
	}

	ELEMENT &e = GetElement(i);

	PAGETYPE *pPage = e.pPage;
	if (pPage == NULL)
	{
		assert(0);
		return;
	}

	pPage->Show(e.GetAcFor(m_nCurGenre, e.nCurUser));
}

void CConfigWnd::HidePage(int i)
{
	if (i == -1)
		return;

	if (i < 0 || i >= GetNumElements())
	{
		assert(0);
		return;
	}

	PAGETYPE *pPage = GetElement(i).pPage;
	if (pPage == NULL)
	{
		assert(0);
		return;
	}

	pPage->Hide();
}

void CConfigWnd::OnMouseOver(POINT point, WPARAM fwKeys)
{
	int i;

	CFlexWnd::s_ToolTip.SetEnable(FALSE);

	// check scroll tab buttons
	if (m_bScrollTabs)
		for (i = 0; i < 2; i++)
		{
			RECT &r = !i ? m_rectSTRight : m_rectSTLeft;
			BOOL b = !i ? m_bScrollTabsRight : m_bScrollTabsLeft;
			if (PtInRect(&r, point))
			{
				if (b)
					GetElement(m_CurSel).pPage->SetInfoText(m_uig.InEditMode() ? IDS_INFOMSG_EDIT_TABSCROLL : IDS_INFOMSG_VIEW_TABSCROLL);
				return;
			}
		}

	// check tabs
	for (i = 0; i < GetNumElements(); i++)
		if (PtInRect(&(GetElement(i).rect), point))
		{
			GetElement(m_CurSel).pPage->SetInfoText(m_uig.InEditMode() ? IDS_INFOMSG_EDIT_TAB : IDS_INFOMSG_VIEW_TAB);
			return;
		}

	// check buttons
	for (i = 0; i < NUMBUTTONS; i++)
		if (PtInRect(&(m_Button[i].rect), point))
		{
			switch(i)
			{
				case BUTTON_OK:
					if (m_uig.InEditMode())
						GetElement(m_CurSel).pPage->SetInfoText(IDS_INFOMSG_EDIT_OK);
					break;

				case BUTTON_CANCEL:
					if (m_uig.InEditMode())
						GetElement(m_CurSel).pPage->SetInfoText(IDS_INFOMSG_EDIT_CANCEL);
					else
						GetElement(m_CurSel).pPage->SetInfoText(IDS_INFOMSG_VIEW_OK);
					break;

				case BUTTON_RESET:
					if (m_uig.InEditMode())  // Only reset if in edit mode.  Do nothing in view mode.
						GetElement(m_CurSel).pPage->SetInfoText(IDS_INFOMSG_EDIT_RESET);
					break;
			}
			return;
		}

	GetElement(m_CurSel).pPage->SetInfoText(-1);
}

void CALLBACK CConfigWnd::TimerProc(UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)
{
	if (!IsWindow((HWND)dwUser)) return;  // Verify that dwUser is a valid window handle
	CConfigWnd *pCfgWnd = (CConfigWnd *)GetFlexWnd((HWND)dwUser);  // Get flex object

	// We use PostMessage instead of calling Render() so we stay synchronized.
	PostMessage((HWND)dwUser, WM_DIRENDER, 0, 0);
}

void CConfigWnd::MapBitmaps(HDC hDC)
{
	if (m_bBitmapsMapped)
		return;

	if (m_pbmTopGradient)
		m_pbmTopGradient->MapToDC(hDC);
	if (m_pbmBottomGradient)
		m_pbmBottomGradient->MapToDC(hDC);

	m_bBitmapsMapped = TRUE;
}

LPDIACTIONFORMATW CConfigWnd::GetCurAcFor(ELEMENT &e)
{
	return e.GetAcFor(m_nCurGenre, e.nCurUser);
}

BOOL CConfigWnd::IsActionAssignedAnywhere(GUID GuidInstance, int nActionIndex)
{
	// Find out which user owns the device in question first.
	int nUser = 0;
	for (int ii = 0; ii < GetNumElements(); ii++)
	{
		ELEMENT &e = GetElement(ii);
		if (IsEqualGUID(e.didi.guidInstance, GuidInstance))
		{
			nUser = e.nCurUser;
			break;
		}
	}

	// Now we check the actions against this user.
	for (int i = 0; i < GetNumElements(); i++)
	{
		ELEMENT &e = GetElement(i);
		const LPDIACTIONFORMATW &lpAcFor = e.GetAcFor(m_nCurGenre, nUser);

		if (lpAcFor == NULL)
			continue;

		if (nActionIndex < 0 || nActionIndex > int(lpAcFor->dwNumActions))
			continue;

		// If this device is not owned by this user, don't need to check.
		if (e.nCurUser != nUser)
			continue;

		const DIACTIONW &a = lpAcFor->rgoAction[nActionIndex];

		if (!IsEqualGUID(a.guidInstance, GUID_NULL))
			return TRUE;
	}

	return FALSE;
}

LRESULT CConfigWnd::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
		case WM_ACTIVATE:
			switch(wParam)
			{
				case WA_ACTIVE:
				case WA_CLICKACTIVE:
					// Set the cursor extent to this window if we are in render mode because the
					// cursor can't be drawn by us when it's not above us.
					if (InRenderMode())
					{
						RECT rc;
						GetWindowRect(m_hWnd, &rc);
						ClipCursor(&rc);
					}
					// Reacquire current device
					if (GetNumElements() && m_CurSel >= 0)
						GetElement(m_CurSel).pPage->Reacquire();
					break;
				case WA_INACTIVE:
					// Unacquire current device
					if (GetNumElements() && m_CurSel >= 0)
						GetElement(m_CurSel).pPage->Unacquire();
					break;
			}
			break;

		case WM_DIRENDER:
			// Render message, sent by TimerProc() earlier.
			// The timer proc has request a render operation.
			Render(m_bNeedRedraw);

			// Set the next timer event.
			if (g_fptimeSetEvent)
				g_fptimeSetEvent(20, 20, CConfigWnd::TimerProc,
				                 (DWORD_PTR)m_hWnd, TIME_ONESHOT);
			return 0;

		case WM_SETFOCUS:
			// Set the keyboard focus to the current page window.
			ShowPage(m_CurSel);  // Call Show() on current page so it can get keyboard focus.
			return 0;

		// WM_NCHITTEST handler is added to support moving window when in GDI mode.
		case WM_NCHITTEST:
		{
			if (InRenderMode()) break;

			BOOL bHitCaption = TRUE;
			POINT point = {(short)LOWORD(lParam), (short)HIWORD(lParam)};
			int i;

			ScreenToClient(m_hWnd, &point);
			// check scroll tab buttons
			if (m_bScrollTabs)
				for (i = 0; i < 2; i++)
				{
					RECT &r = !i ? m_rectSTRight : m_rectSTLeft;
					BOOL b = !i ? m_bScrollTabsRight : m_bScrollTabsLeft;
					if (PtInRect(&r, point))
					{
						if (b)
							bHitCaption = FALSE;
						break;
					}
				}

			// check tabs
			for (i = 0; i < GetNumElements(); i++)
				if (PtInRect(&(GetElement(i).rect), point))
				{
					bHitCaption = FALSE;
					break;
				}

			// check buttons
			for (i = 0; i < NUMBUTTONS; i++)
				if (PtInRect(&(m_Button[i].rect), point))
				{
					if ((i == BUTTON_RESET || i == BUTTON_OK) && !m_uig.InEditMode()) continue;
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
					if (i == BUTTON_LAYOUT && !m_uig.QueryAllowEditLayout()) continue;
#endif
//@@END_MSINTERNAL
					bHitCaption = FALSE;
					break;
				}

			// Check Y coordinate to see if it is within the caption bar.
			if ((point.y < GetElement(0).rect.top || point.y > GetElement(0).rect.bottom) &&
					(point.y < m_rectBottomGradient.top || point.y > m_rectBottomGradient.bottom))
				bHitCaption = FALSE;

			if (bHitCaption)
			{
				// If we are returning HTCAPTION, clear the page's info box.
				GetElement(m_CurSel).pPage->SetInfoText(-1);
				return HTCAPTION;
			}
			break;
		}

		case WM_CFGUIRESET:
		{
			CFlexWnd::s_ToolTip.SetEnable(FALSE);
			m_bHourGlass = TRUE;  // Set the flag so Render() will draw hourglass instead of arrow
			Invalidate();
			SendMessage(this->m_hWnd, WM_PAINT, 0, 0);
			if (InRenderMode())  // If in render mode, need to specifically call OnRender as sending WM_PAINT merely changes flag.
				Render(TRUE);
			if (!Init(CFGWND_INIT_REINIT | CFGWND_INIT_RESET))
			{
				m_uig.SetFinalResult(E_FAIL);
				Destroy();
			}
			m_bHourGlass = FALSE;  // Change cursor back to arrow
			m_MsgBox.Destroy();
			Invalidate();
			return TRUE;
		}

		case WM_SETCURSOR:
			{
				static HCURSOR hCursor = LoadCursor(NULL, IDC_ARROW);
				::SetCursor(InRenderMode() ? NULL : hCursor);
			}
			return TRUE;

//		case WM_QUERYACTIONASSIGNEDANYWHERE:
//			return IsActionAssignedAnywhere(int(wParam), int(lParam));
	}

	return CFlexWnd::WndProc(hWnd, msg, wParam, lParam);
}

HRESULT CConfigWnd::Apply()
{
	tracescope(ts, _T("\n\nApplying Changes to All Devices...\n"));

	// Devices need to be in the unaquired state when SetActionMap is called.
	Unacquire();

	for (int i = 0; i < GetNumElements(); i++)
		GetElement(i).Apply();

	Reacquire();

	trace(_T("\n\n"));

	return S_OK;
}

int CConfigWnd::GetNumElements()
{
	return m_Element.GetSize();
}

ELEMENT &CConfigWnd::GetElement(int i)
{
	if (i < 0 || i >= GetNumElements())
	{
		assert(0);
		etrace1(_T("Tried to get invalid element %d\n"), i);
		return m_InvalidElement;
	}

	return m_Element[i];
}

// This function returns a pointer to the action format of the device that has the given GUID
HRESULT CConfigWnd::GetActionFormatFromInstanceGuid(LPDIACTIONFORMATW *lplpAcFor, REFGUID Guid)
{
	if (!lplpAcFor)
		return E_INVALIDARG;

	for (int i = 0; i < GetNumElements(); i++)
	{
		ELEMENT &e = m_Element[i];

		if (e.didi.guidInstance == Guid)
		{
			*lplpAcFor = GetCurAcFor(e);
			return S_OK;
		}
	}

	return E_INVALIDARG;
}

HDC CConfigWnd::GetRenderDC()
{
	assert(InRenderMode());

	if (m_bRender3D)
		return m_pbm3D == NULL ? NULL : m_pbm3D->BeginPaintInto();
	else
	{
		if (m_pSurface == NULL)
			return NULL;

		HDC hDC = NULL;
		HRESULT hr = m_pSurface->GetDC(&hDC);
		if (FAILED(hr))
			if (hr == DDERR_SURFACELOST)
			{
				m_pSurface->Restore();    // Restore the surface
				hr = m_pSurface->GetDC(&hDC);  // Retry
				if (FAILED(hr))
					return NULL;
			}
			else
				return NULL;

		return hDC;
	}
}

void CConfigWnd::ReleaseRenderDC(HDC &phDC)
{
	assert(InRenderMode());

	HDC hDC = phDC;
	phDC = NULL;

	if (m_bRender3D)
	{
		if (m_pbm3D == NULL)
			return;

		m_pbm3D->EndPaintInto(hDC);
	}
	else
	{
		if (m_pSurface == NULL)
			return;

		m_pSurface->ReleaseDC(hDC);
	}
}

struct BITMAPINFO_3MASKS
{
	BITMAPINFOHEADER bmiHeader;
	RGBQUAD          bmiColors[3];
};

void CConfigWnd::Create3DBitmap()
{
	HDC hDC = CreateCompatibleDC(NULL);

	BITMAPINFO_3MASKS bmi3mask;  // BITMAPINFO with 3 DWORDs for bmiColors
	BITMAPINFO *pbmi = (BITMAPINFO*)&bmi3mask;

	BITMAPINFOHEADER &h = pbmi->bmiHeader;
	h.biSize = sizeof(BITMAPINFOHEADER);
	h.biWidth = WINDOW_WIDTH;
	h.biHeight = -WINDOW_HEIGHT;
	h.biPlanes = 1;
	h.biSizeImage = 0;
	h.biXPelsPerMeter = 100;
	h.biYPelsPerMeter = 100;
	h.biClrImportant = 0;

	// Get the surface's pixel format
	D3DSURFACE_DESC d3dsd;
	ZeroMemory(&d3dsd, sizeof(d3dsd));
	m_pSurface3D->GetDesc(&d3dsd);
	m_SurfFormat = d3dsd.Format;
	switch(d3dsd.Format)
	{
		case D3DFMT_R5G6B5:
			h.biClrUsed = 3;
			h.biBitCount = 16;
			m_uiPixelSize = 2;
			h.biCompression = BI_BITFIELDS;
			*((LPDWORD)pbmi->bmiColors) = 0xF800;
			*((LPDWORD)pbmi->bmiColors+1) = 0x07E0;
			*((LPDWORD)pbmi->bmiColors+2) = 0x001F;
			break;

		case D3DFMT_X1R5G5B5:
		case D3DFMT_A1R5G5B5:
			h.biClrUsed = 3;
			h.biBitCount = 16;
			m_uiPixelSize = 2;
			h.biCompression = BI_BITFIELDS;
			*((LPDWORD)pbmi->bmiColors) = 0x7C00;
			*((LPDWORD)pbmi->bmiColors+1) = 0x03E0;
			*((LPDWORD)pbmi->bmiColors+2) = 0x001F;
			break;

		case D3DFMT_R8G8B8:
			h.biClrUsed = 0;
			h.biBitCount = 24;
			m_uiPixelSize = 3;
			h.biCompression = BI_RGB;
			break;

		case D3DFMT_A8R8G8B8:
		case D3DFMT_X8R8G8B8:
		default:
			// Use 32 bits for all other formats
			h.biClrUsed = 0;
			h.biBitCount = 32;
			m_uiPixelSize = 4;
			h.biCompression = BI_RGB;
			break;
	}

	HBITMAP hbm = CreateDIBSection(
		hDC,
		pbmi,
		DIB_RGB_COLORS,
		&m_p3DBits,
		NULL,
		0);

	DeleteDC(hDC);
	hDC = NULL;

	if (hbm != NULL)
		m_pbm3D = CBitmap::StealToCreate(hbm);

	if (hbm != NULL)
		DeleteObject((HGDIOBJ)hbm);
	hbm = NULL;
}

void CConfigWnd::Copy3DBitmapToSurface3D()
{
	assert(m_bRender3D);

	if (m_p3DBits == NULL || m_pbm3D == NULL || m_pSurface3D == NULL)
	{
		etrace(_T("One or more of the vars required for Copy3DBitmapToSurface() was NULL!\n"));
		return;
	}

	RECT rect = {0, 0, WINDOW_WIDTH, WINDOW_HEIGHT};

	HRESULT hr = D3DXLoadSurfaceFromMemory(
		m_pSurface3D,
		NULL,
		NULL,//&rect,
		m_p3DBits,
		m_SurfFormat,
		WINDOW_WIDTH * m_uiPixelSize,
		NULL,
		&rect,
		D3DX_FILTER_POINT,
		0);  // Disable Color Key
}

void CConfigWnd::CallRenderCallback()
{
	LPDICONFIGUREDEVICESCALLBACK pCallback = m_uig.GetCallback();
	LPVOID pvRefData = m_uig.GetRefData();

	if (pCallback == NULL)
		return;

	if (m_bRender3D)
	{
		Copy3DBitmapToSurface3D();
		pCallback(m_pSurface3D, pvRefData);
	}
	else
	{
		pCallback(m_pSurface, pvRefData);
	}
}

void CConfigWnd::OnRender(BOOL bInternalCall)
{
	m_bNeedRedraw = TRUE;
}

void CConfigWnd::Render(BOOL bInternalCall)
{
	tracescope(__ts, _T("CConfigWnd::Render() "));
	traceBOOL(bInternalCall);

	m_bNeedRedraw = FALSE;

	ValidateRect(m_hWnd, NULL);

	if (m_hWnd == NULL)
		return;

	HDC hDC = GetRenderDC();
	if (hDC == NULL)
		return;

	if (bInternalCall)
		RenderInto(hDC);

	static ICONINFO IconInfo;
	static HCURSOR hOldCursor = NULL;
	static HCURSOR hCursor;
	if (m_bHourGlass)
		hCursor = LoadCursor(NULL, IDC_WAIT);
	else
		hCursor = LoadCursor(NULL, IDC_ARROW);
	if (hCursor == NULL)
		return;

	if (hOldCursor != hCursor)
	{
		hOldCursor = hCursor;
		GetIconInfo(hCursor, &IconInfo);

		if (IconInfo.hbmMask)
			DeleteObject(IconInfo.hbmMask);

		if (IconInfo.hbmColor)
			DeleteObject(IconInfo.hbmColor);
	}

	POINT pt;
	GetCursorPos(&pt);

	ScreenToClient(m_hWnd, &pt);

	pt.x -= IconInfo.xHotspot;
	pt.y -= IconInfo.yHotspot;

	if (m_pbmPointerEraser)
		m_pbmPointerEraser->Get(hDC, pt);

	// If m_bHourGlass is true, we are resetting, so we don't draw mouse cursor.
	if (hCursor && !m_bHourGlass)
		DrawIcon(hDC, pt.x, pt.y, hCursor);

	ReleaseRenderDC(hDC);

	CallRenderCallback();

	hDC = GetRenderDC();
	if (hDC == NULL)
		return;

	if (m_pbmPointerEraser)
		m_pbmPointerEraser->Draw(hDC, pt);

	ReleaseRenderDC(hDC);
}

void CConfigWnd::Unacquire()
{
	for (int i = 0; i < GetNumElements(); i++)
	{
		ELEMENT &e = m_Element[i];
		if (e.pPage != NULL)
			e.pPage->Unacquire();
	}
}

void CConfigWnd::Reacquire()
{
	for (int i = 0; i < GetNumElements(); i++)
	{
		ELEMENT &e = m_Element[i];
		if (e.pPage != NULL)
			e.pPage->Reacquire();
	}
}

HRESULT CConfigWnd::Reset()
{
	RECT rect;
	int iCenterX, iCenterY;

	GetClientRect(&rect);
	iCenterX = (rect.left + rect.right) >> 1;
	iCenterY = (rect.top + rect.bottom) >> 1;
	rect.left = rect.right = iCenterX;
	rect.top = rect.bottom = iCenterY;
	InflateRect(&rect, g_iResetMsgBoxWidth >> 1, g_iResetMsgBoxHeight >> 1);

	m_MsgBox.Create(m_hWnd, rect, FALSE);
	m_MsgBox.SetNotify(m_hWnd);
	m_MsgBox.SetFont((HFONT)m_uig.GetFont(UIE_USERNAMES));
	m_MsgBox.SetColors(m_uig.GetTextColor(UIE_USERNAMES),
		                   m_uig.GetBkColor(UIE_USERNAMES),
		                   m_uig.GetTextColor(UIE_USERNAMESEL),
		                   m_uig.GetBkColor(UIE_USERNAMESEL),
		                   m_uig.GetBrushColor(UIE_USERNAMES),
		                   m_uig.GetPenColor(UIE_USERNAMES));

	TCHAR tszResourceString[MAX_PATH];
	LoadString(g_hModule, IDS_RESETMSG, tszResourceString, MAX_PATH);
	m_MsgBox.SetText(tszResourceString);
	::ShowWindow(m_MsgBox.m_hWnd, SW_SHOW);
	::SetWindowPos(m_MsgBox.m_hWnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);
	m_MsgBox.Invalidate();
	return S_OK;
}

HRESULT CConfigWnd::QueryActionAssignedAnywhere(GUID GuidInstance, int i)
{
	return IsActionAssignedAnywhere(GuidInstance, i) ? S_OK : S_FALSE;
}

int CConfigWnd::GetNumGenres()
{
	return m_uig.GetNumMasterAcFors();
}

HRESULT CConfigWnd::SetCurUser(int nPage, int nUser)
{
	// make sure we're using a valid element index
	if (nPage < 0 || nPage >= GetNumElements())
	{
		assert(0);
		return E_FAIL;
	}

	// get the element
	ELEMENT &e = GetElement(nPage);
	
	// don't do anything if we're already set to this user
	if (e.nCurUser == nUser)
		return S_OK;

	// store new curuser
	e.nCurUser = nUser;

	// if this page isn't the one currently shown, do nothing
	// (it'll get the new acfor when it's shown)
	if (m_CurSel != nPage)
		return S_OK;

	// otherwised, cycle the page to reflect change
	if (e.pPage)
		e.pPage->Unacquire();
	HidePage(nPage);
	ShowPage(nPage);
	if (e.pPage)
		e.pPage->Reacquire();

	return S_OK;
}

HRESULT CConfigWnd::SetCurGenre(int NewGenre)
{
	// if no change, do nothing
	if (NewGenre == m_nCurGenre)
		return S_OK;

	// make sure genre index is in range
	if (NewGenre < 0 || NewGenre >= GetNumGenres())
		return E_INVALIDARG;

	// set genre
	m_nCurGenre = NewGenre;

	// store which page is currently up
	int iOldPage = m_CurSel;

	// for each page...
	BOOL bShown = FALSE;
	for (int i = 0; i < GetNumElements(); i++)
	{
		ELEMENT &e = GetElement(i);

		// hide the page and unacquire its device
		if (e.pPage)
		{
			e.pPage->Unacquire();
			HidePage(i);
		}

		// show page if it was the old cur page
		if (i == iOldPage && e.pPage && GetCurAcFor(e))
		{
			ShowPage(i);
			bShown = TRUE;
		}

		// reacquire device
		if (e.pPage)
			e.pPage->Reacquire();
	}

	// if nothing was shown, show something
	if (!bShown && GetNumElements() > 0)
	{
		m_CurSel = -1;
		SelTab(0);
	}

	// if we showed the one we expected to show, we succeeded
	return bShown ? S_OK : E_FAIL;
}

int CConfigWnd::GetCurGenre()
{
	return m_nCurGenre;
}

HWND CConfigWnd::GetMainHWND()
{
	return m_hWnd;
}

// This is called by CDIDeviceActionConfigPage::DeviceUINotify.
// We scan the ELEMENT array and when we find a match, destroy and recreate the device
// object, then return it back to CDIDeviceActionConfigPage so it can update its pointer.
LPDIRECTINPUTDEVICE8W CConfigWnd::RenewDevice(GUID &GuidInstance)
{
	for (int i = 0; i < GetNumElements(); i++)
	{
		ELEMENT &e = GetElement(i);

		if (e.didi.guidInstance == GuidInstance)
		{
			// Releaes the instance we have
			if (e.lpDID)
			{
				e.lpDID->Release();
				e.lpDID = NULL;
			}
			// Recreate the device
			e.lpDID = CreateDevice(e.didi.guidInstance);
			return e.lpDID;
		}
	}
	return NULL;
}

LPDIACTIONFORMATW ELEMENT::GetAcFor(int nGenre, int nUser, BOOL bHwDefault)
{
	// return null if requesting for unassigned user
	if (nUser == -1)
		return NULL;

	// validate params
	if (!lpDID || !pUIGlobals || nGenre < 0 ||
	    nGenre >= pUIGlobals->GetNumMasterAcFors() ||
	    nUser < 0 || nUser >= pUIGlobals->GetNumUserNames())
	{
		etrace(_T("ELEMENT::GetAcFor(): Invalid params\n"));
		return NULL;
	}

	// generate dword id for map entry
	DWORD dwMap = GENREUSER2MAP(nGenre, nUser);

	// try to get that acfor
	LPDIACTIONFORMATW lpAcFor = NULL;
	BOOL bFound = AcForMap.Lookup(dwMap, lpAcFor);

	// if we found it and its not null and we are asked for hardware default setting, return it
	if (bFound && lpAcFor && !bHwDefault)
		return lpAcFor;

	// otherwise...  we gotta make it
	tracescope(__ts, _T("ELEMENT::GetAcFor"));
	trace2(_T("(%d, %d)\n"), nGenre, nUser);
	trace1(_T("Building map entry 0x%08x...\n"), dwMap);

	// copy it from the masteracfor for the genre
	lpAcFor = DupActionFormat(&(pUIGlobals->RefMasterAcFor(nGenre)));
	if (!lpAcFor)
	{
		etrace(_T("DupActionFormat() failed\n"));
		return NULL;
	}

	// build it for the user
	DWORD dwFlags = 0;
	if (bHwDefault
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	    || pUIGlobals->QueryAllowEditLayout()
#endif
//@@END_MSINTERNAL
	   )
		dwFlags |= DIDBAM_HWDEFAULTS;
	LPCWSTR wszUserName = pUIGlobals->GetUserName(nUser);
	HRESULT hr = lpDID->BuildActionMap(lpAcFor, wszUserName, dwFlags);
	if (FAILED(hr))
	{
		etrace4(_T("BuildActionMap(0x%p, %s, 0x%08x) failed, returning 0x%08x\n"), lpAcFor, QSAFESTR(wszUserName), dwFlags, hr);
		FreeActionFormatDup(lpAcFor);
		lpAcFor = NULL;
		return NULL;
	}
	else
	{
		trace3(_T("BuildActionMap(0x%p, %s, 0x%08x) succeeded\n"), lpAcFor, QSAFESTR(wszUserName), dwFlags);
		// Now we check if the return code is DI_WRITEPROTECT.  If so, device can't be remapped.
		if (hr == DI_WRITEPROTECT)
		{
			// The way we disable mapping is to add DIA_APPFIXED flag to all actions.
			for (DWORD i = 0; i < lpAcFor->dwNumActions; ++i)
				lpAcFor->rgoAction[i].dwFlags |= DIA_APPFIXED;
		}
	}

	// Here we copy the DIA_APPFIXED flag back to our action format for all DIACTION that had this.
	const DIACTIONFORMATW &MasterAcFor = pUIGlobals->RefMasterAcFor(nGenre);
	for (DWORD i = 0; i < MasterAcFor.dwNumActions; ++i)
		if (MasterAcFor.rgoAction[i].dwFlags & DIA_APPFIXED)
			lpAcFor->rgoAction[i].dwFlags |= DIA_APPFIXED;
	// set it in the map
	assert(lpAcFor != NULL);
	AcForMap.SetAt(dwMap, lpAcFor);

	// return it
	return lpAcFor;
}

void ELEMENT::FreeMap()
{
	POSITION pos = AcForMap.GetStartPosition();
	while (pos != NULL)
	{
		DWORD dwMap = (DWORD)-1;
		LPDIACTIONFORMATW lpAcFor = NULL;
		AcForMap.GetNextAssoc(pos, dwMap, lpAcFor);

		if (lpAcFor)
			FreeActionFormatDup(lpAcFor);
	}
	AcForMap.RemoveAll();
}

void ELEMENT::Apply()
{
	tracescope(tsa, _T("\nELEMENT::Apply()\n"));
	trace1(_T("Applying Changes to Device %s\n"), QSAFESTR(didi.tszInstanceName));

	if (lpDID == NULL)
	{
		etrace(_T("NULL lpDID, can't apply\n"));
		return;
	}

	if (pUIGlobals == NULL)
	{
		etrace(_T("NULL pUIGlobals, can't apply\n"));
		return;
	}

	LPDIACTIONFORMATW lpAcFor = NULL;

	// go through the map and add the map keys to last if the user
	// is the current user assignment, or to first if not
	CList<DWORD, DWORD &> first, last;
	POSITION pos = AcForMap.GetStartPosition();
	while (pos != NULL)
	{
		DWORD dwMap = (DWORD)-1;
		lpAcFor = NULL;
		AcForMap.GetNextAssoc(pos, dwMap, lpAcFor);
		
		if (MAP2USER(dwMap) == nCurUser)
			last.AddTail(dwMap);
		else
			first.AddTail(dwMap);
	}

	// concatenate lists
	first.AddTail(&last);

	// now go through the resulting list (so that the current
	// assignments are set last) if this device is assigned.
	if (nCurUser != -1)
	{
		pos = first.GetHeadPosition();
		while (pos != NULL)
		{
			DWORD dwMap = first.GetNext(pos);
			lpAcFor = AcForMap[dwMap];

			tracescope(tsa2, _T("Applying lpAcFor at AcForMap["));
			trace1(_T("0x%08x]...\n"), dwMap);

			if (lpAcFor == NULL)
			{
				etrace(_T("NULL lpAcFor, can't apply\n"));
				continue;
			}

			int nGenre = MAP2GENRE(dwMap);
			int nUser = MAP2USER(dwMap);
			LPCWSTR wszUserName = pUIGlobals->GetUserName(nUser);

			traceLONG(nGenre);
			traceLONG(nUser);
			traceWSTR(wszUserName);

			TraceActionFormat(_T("Final Device ActionFormat:"), *lpAcFor);

			for (DWORD j = 0; j < lpAcFor->dwNumActions; ++j)
			{
				if( lpAcFor->rgoAction[j].dwObjID == (DWORD)-1 || IsEqualGUID(lpAcFor->rgoAction[j].guidInstance, GUID_NULL))
				{ 
					lpAcFor->rgoAction[j].dwHow = DIAH_UNMAPPED;
				}
				else if( lpAcFor->rgoAction[j].dwHow & 
						( DIAH_USERCONFIG | DIAH_APPREQUESTED | DIAH_HWAPP | DIAH_HWDEFAULT | DIAH_DEFAULT ) )
				{
//@@BEGIN_MSINTERNAL
					// ISSUE-2001/03/27-MarcAnd should look at doing this less destructively
					// that is if everything is defaults then leave them alon
//@@END_MSINTERNAL
					lpAcFor->rgoAction[j].dwHow = DIAH_USERCONFIG;
				}
				else if(IsEqualGUID(didi.guidInstance,lpAcFor->rgoAction[j].guidInstance))
				{
					lpAcFor->rgoAction[j].dwHow = DIAH_USERCONFIG;
				}
			}

			HRESULT hr;
			hr = lpDID->SetActionMap(lpAcFor, wszUserName, DIDSAM_FORCESAVE|DIDSAM_DEFAULT);

			if (FAILED(hr))
				etrace1(_T("SetActionMap() failed, returning 0x%08x\n"), hr);
			else
				trace(_T("SetActionMap() succeeded\n"));
		}
	}  // if (nCurUser != -1)
	else
	{
		// we're unassigned, set null
		trace(_T("Unassigning...\n"));

		// we need an acfor to unassign, so get one if don't have
		// one left over from what we just did
		if (!lpAcFor)
			lpAcFor = GetAcFor(0, 0);

		if (!lpAcFor)
			etrace(_T("Couldn't get an acfor for unassignment\n"));

		HRESULT hr;
		hr = lpDID->SetActionMap(lpAcFor, NULL, DIDSAM_NOUSER);

		if (FAILED(hr))
			etrace1(_T("SetActionMap() failed, returning 0x%08x\n"), hr);
		else
			trace(_T("SetActionMap() succeeded\n"));
	}
}

int CConfigWnd::GetNumUsers()
{
	return m_uig.GetNumUserNames();
}

int	CConfigWnd::GetCurUser(int nPage)
{
	return GetElement(nPage).nCurUser;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\constants.cpp ===
//-----------------------------------------------------------------------------
// File: constants.cpp
//
// Desc: Contains all constants used by the UI.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


const SIZE g_sizeThumb = {64, 64};
const SIZE g_sizeImage = {430, 310};
const POINT g_ptViewOrigin = {13, 13};
const RECT g_UserNamesTitleRect = {9,120,190,132};
const RECT g_UserNamesRect = {9,137,190,364};
const RECT g_GenresTitleRect = {9,156,190,167};
const RECT g_GenresRect = {9,172,190,379};
const	RECT g_InfoWndRect = {9, 10, 190, 120};
const RECT g_ViewRect = {200,10,630,320};
const RECT g_CheckBoxRect = {350, 335, 475, 355};
const int g_iListHeaderHeight = 30;
const int g_iResetMsgBoxWidth = 200;
const int g_iResetMsgBoxHeight = 60;

LPCTSTR g_tszUnassignedControlCaption = _T("_ _ _  ");

const RECT g_TreeTitleRect = {9,192,190,203};
const RECT g_TreeRect = {10,208,189,417};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\cyclestr.cpp ===
//-----------------------------------------------------------------------------
// File: cyclestr.cpp
//
// Desc: Implements a circular queue that provides space to hold a string
//       without repeatedly allocating and deallocating memory.  This is
//       only for short-term use such as outputting debug message to
//       ensure that the same buffer is not used at more than one place
//       simultaneously.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


static const int g_cycles = 16;
static const int g_cyclelen = 256;


LPTSTR getcyclestr()
{
	static int on = g_cycles;
	static TCHAR cycle[g_cycles][g_cyclelen];

	on++;
	if (on >= g_cycles)
		on = 0;

	return cycle[on];
}

inline static void cap(LPTSTR c)
{
	c[g_cyclelen - 1] = 0;
}

#define SAFESTR_noconv \
	if (str) \
		return str; \
	else \
		return _T("NULL");

#define SAFESTR_conv \
	LPTSTR c = getcyclestr(); \
	CopyStr(c, str, g_cyclelen); \
	cap(c); \
	return SAFESTR(c);

LPCTSTR SAFESTR(LPCWSTR str)
{
#ifdef UNICODE
	SAFESTR_noconv
#else
	SAFESTR_conv	
#endif
}

LPCTSTR SAFESTR(LPCSTR str)
{
#ifdef UNICODE
	SAFESTR_conv
#else
	SAFESTR_noconv
#endif
}

#define QSAFESTR_doit(tf) \
	if (!str) \
		return _T("NULL"); \
\
	LPTSTR c = getcyclestr(); \
	_sntprintf(c, g_cyclelen, _T("\"") tf _T("\""), str); \
	cap(c); \
	return c;

LPCTSTR QSAFESTR(LPCWSTR str)
{
	QSAFESTR_doit(_tfWSTR)
}

LPCTSTR QSAFESTR(LPCSTR str)
{
	QSAFESTR_doit(_tfSTR)
}

LPCTSTR BOOLSTR(BOOL b)
{
	return b ? _T("TRUE"): _T("FALSE");
}

LPCTSTR RECTSTR(RECT &rect)
{
	LPTSTR c = getcyclestr();
	_sntprintf(c, g_cyclelen, _T("{%d,%d,%d,%d}"),
		rect.left,
		rect.top,
		rect.right,
		rect.bottom);
	cap(c);
	return c;
}

LPCTSTR RECTDIMSTR(RECT &rect)
{
	LPTSTR c = getcyclestr();
	_sntprintf(c, g_cyclelen, _T("{%dx%d}"),
		rect.right - rect.left,
		rect.bottom - rect.top);
	cap(c);
	return c;
}

LPCTSTR POINTSTR(POINT &point)
{
	LPTSTR c = getcyclestr();
	_sntprintf(c, g_cyclelen, _T("{%d,%d}"),
		point.x,
		point.y);
	cap(c);
	return c;
}

LPCTSTR GUIDSTR(const GUID &guid)
{
	LPTSTR c = getcyclestr();

	wsprintf(c, _T("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
	         guid.Data1, guid.Data2, guid.Data3,
	         guid.Data4[0], guid.Data4[1],
	         guid.Data4[2], guid.Data4[3],
	         guid.Data4[4], guid.Data4[5],
	         guid.Data4[6], guid.Data4[7]);

	cap(c);

	return c;
}

template<class T>
static LPCTSTR _superstr(const T *str)
{
	static LPCTSTR
		prefix = _T("(\""),
		midfix = _T("\",\""),
		suffix = _T("\")");

	LPTSTR c = getcyclestr(), c2 = getcyclestr();
	c[0] = 	0;
	
	for (int i = 0, n = CountSubStrings(str); i < n; i++)
	{
		if (!i)
			_tcsncat(c, prefix, g_cyclelen);
		else
			_tcsncat(c, midfix, g_cyclelen);

		CopyStr(c2, GetSubString(str, i), g_cyclelen);
		cap(c2);

		_tcsncat(c, c2, g_cyclelen);
		cap(c);

		if (i == n - 1)
			_tcsncat(c, suffix, g_cyclelen);
	}

	cap(c);

	return c;
}

LPCTSTR SUPERSTR(LPCWSTR str) {return _superstr(str);}
LPCTSTR SUPERSTR(LPCSTR str) {return _superstr(str);}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\defines.h ===
//-----------------------------------------------------------------------------
// File: defines.h
//
// Desc: Contains all defined symbols needed for the UI.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __CFGUI_DEFINES_H__
#define __CFGUI_DEFINES_H__


// if either UNICODE define exists, make sure both do
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif



// make sure we have the correct debug flags defined,
// thus making sure assert actually works with build
#if defined(DBG) || defined(DEBUG)
	#ifdef NDEBUG
		#undef NDEBUG
	#endif
#else
	#ifndef NDEBUG
		#define NDEBUG
	#endif
#endif

// disable tracing if we don't want debug info
#ifdef NDEBUG
	#ifndef NTRACE
		#define NTRACE
	#endif
	#ifndef NO_LTRACE
		#define NO_LTRACE
	#endif
#endif


// settings...
//#define CFGUI__FORCE_GOOD_ACFORS
//#define CFGUI__FORCE_NON_NULL_WSZUSERNAMES
//#define CFGUI__TRACE_ACTION_FORMATS
//#define CFGUI__ALLOW_USER_ACTION_TREE_BRANCH_MANIPULATION
#define CFGUI__UIGLOBALS_HAS_CURUSER
#define CFGUI__COMPAREACTIONNAMES_CASE_INSENSITIVE

//#define __CFGUI_TRACE__TO_DEBUG_OUT
#define __CFGUI_TRACE__TO_FILE



#endif //__CFGUI_DEFINES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\constants.h ===
//-----------------------------------------------------------------------------
// File: constants.h
//
// Desc: Contains all constants used by the UI.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __CFGUI_CONSTANTS_H__
#define __CFGUI_CONSTANTS_H__

#define MINLISTVIEWCALLOUTWIDTH 70

extern const SIZE g_sizeThumb;
extern const SIZE g_sizeImage;
extern const POINT g_ptViewOrigin;
extern const RECT g_ViewRect;
extern const RECT g_CheckBoxRect;
extern const RECT g_InfoWndRect;
extern const RECT g_UserNamesRect;
extern const RECT g_UserNamesTitleRect;
extern const RECT g_GenresRect;
extern const RECT g_GenresTitleRect;
extern LPCTSTR g_tszUnassignedControlCaption;
extern const RECT g_TreeTitleRect;
extern const RECT g_TreeRect;
extern const int g_iListHeaderHeight;
extern const int g_iResetMsgBoxWidth;
extern const int g_iResetMsgBoxHeight;


#endif //__CFGUI_CONSTANTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\dicfgres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dconfig.rc
//

#define IDS_MSGBOXTITLE_WRITEINISUCCEEDED 1
#define IDS_MSGBOXTITLE_WRITEINIFAILED  2
#define IDS_WROTEINITO                  3
#define IDS_DICREATEFAILED              4
#define IDS_CREATEDEVICEFAILED          5
#define IDS_GETPROPMAPFILEFAILED        6
#define IDS_WCTOMBFAILED                7
#define IDS_NOMAPFILEPATH								8
#define IDS_ERRORUNKNOWN                9
#define IDS_REMOVEALLCALLOUTS           10
#define IDS_CONFIRMREMOVEALLCALLOUTS    11
#define IDS_REMOVEVIEW                  12
#define IDS_CONFIRMREMOVEVIEW           13
#define IDS_REMOVEALLVIEWS              14
#define IDS_CONFIRMREMOVEALLVIEWS       15
#define IDS_TITLE_NONEWCONTROL          16
#define IDS_ERROR_OFFSETUNAVAIL         17
#define IDS_GETPROPVIDPIDFAILED         18
#define IDS_ERROR_INIREAD               19
#define IDS_ERROR_CANTLOADDIMAP         20
#define IDS_ERROR_OUTOFMEMORY           21
#define IDS_BUTTON_LAYOUT               22
#define IDS_ERROR_WRITEVENDORFILE_FAILED 23
#define IDS_WRITEVENDORFILE_ACCESSDENIED 24

#define IDS_DCONFIG_PRODUCTNAME         25
#define IDS_BUTTON_OK                   26
#define IDS_TITLE_NOLOADVIEWIMAGE       27
#define IDS_NULLPATH                    28
#define IDS_COULDNOTCREATEIMAGEFROMFILE 29
#define IDS_BUTTON_CANCEL               30
#define IDS_BUTTON_RESET                31
#define IDS_INFOMSG_VIEW_TAB            32
#define IDS_INFOMSG_VIEW_TABSCROLL      33
#define IDS_INFOMSG_VIEW_DEVICE         34
#define IDS_INFOMSG_VIEW_SORTDISABLED   35
#define IDS_INFOMSG_VIEW_SORTENABLED    36
#define IDS_INFOMSG_VIEW_VIEWSEL        37
#define IDS_INFOMSG_VIEW_OK             38
#define IDS_INFOMSG_VIEW_USERNAME       39
#define IDS_INFOMSG_VIEW_GAMEMODE       40
#define IDS_INFOMSG_EDIT_TAB            41
#define IDS_INFOMSG_EDIT_TABSCROLL      42
#define IDS_INFOMSG_EDIT_DEVICE         43
#define IDS_INFOMSG_EDIT_SORTDISABLED   44
#define IDS_INFOMSG_EDIT_SORTENABLED    45
#define IDS_INFOMSG_EDIT_VIEWSEL        46
#define IDS_INFOMSG_EDIT_RESET          47
#define IDS_INFOMSG_EDIT_OK             48
#define IDS_INFOMSG_EDIT_CANCEL         49
#define IDS_INFOMSG_EDIT_ACTLISTDISABLED 50
#define IDS_INFOMSG_EDIT_ACTLISTENABLED 51
#define IDS_INFOMSG_EDIT_USERNAME       52
#define IDS_INFOMSG_EDIT_GAMEMODE       53
#define IDS_INFOMSG_DEF_EDIT            54
#define IDS_INFOMSG_DEF_VIEW            55
#define IDS_INFOMSG_EDIT_CTRLSELECTED   56
#define IDS_INFOMSG_EDIT_EDITMODEENABLED 57
#define IDS_INFOMSG_EDIT_KEYBOARD       58
#define IDS_INFOMSG_EDIT_MOUSE          59
#define IDS_INFOMSG_APPFIXEDSELECT      60
#define IDS_INFO_TITLE                  61
#define IDS_PLAYER_TITLE                62
#define IDS_GENRE_TITLE                 63
#define IDS_AVAILABLEACTIONS_TITLE      64
#define IDS_SORTASSIGNED                65
#define IDS_AXISACTIONS                 66
#define IDS_BUTTONACTIONS               67
#define IDS_POVACTIONS                  68
#define IDS_LISTHEADER_CTRL             69
#define IDS_LISTHEADER_ACTION           70
#define IDS_RESETMSG                    71
#define IDD_DIACPAGE                    102
#define IDD_SELCONTROLDLG               103
#define IDD_DCONFIG_DIALOG              104
#define IDB_IB                          105
#define IDB_IB2                         106
#define IDB_HATGLYPH                    107
#define IDB_BUTTONGLYPH                 108
#define IDB_CHECKGLYPH                  109
#define IDB_AXESGLYPH                   110
#define IDB_CHECKGLYPHDARK              111
#define IDC_TAB                         1001
#define IDC_DEFAULT                     1002
#define IDC_LIST                        1003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexcheckbox.cpp ===
//-----------------------------------------------------------------------------
// File: flexcheckbox.cpp
//
// Desc: Implements a check box control similar to Windows check box.
//       CFlexCheckBox is derived from CFlexWnd.  The only place that
//       uses CFlxCheckBox is in the keyboard for sorting by assigned
//       keys.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"

CFlexCheckBox::CFlexCheckBox() :
	m_hWndNotify(NULL),
	m_bChecked(FALSE),
	m_rgbText(RGB(255,255,255)),
	m_rgbBk(RGB(0,0,0)),
	m_rgbSelText(RGB(0,0,255)),
	m_rgbSelBk(RGB(0,0,0)),
	m_rgbFill(RGB(0,0,255)),
	m_rgbLine(RGB(0,255,255)),
	m_hFont(NULL),
	m_tszText(NULL)
{
}

CFlexCheckBox::~CFlexCheckBox()
{
	delete[] m_tszText;
}

void CFlexCheckBox::SetText(LPCTSTR tszText)
{
	LPTSTR tszTempText = NULL;

	if (tszText)
	{
		tszTempText = new TCHAR[_tcslen(tszText) + 1];
		if (!tszTempText) return;
		_tcscpy(tszTempText, tszText);
	}

	delete[] m_tszText;
	m_tszText = tszTempText;
}

void CFlexCheckBox::SetFont(HFONT hFont)
{
	m_hFont = hFont;

	if (m_hWnd == NULL)
		return;

	Invalidate();
}

void CFlexCheckBox::SetColors(COLORREF text, COLORREF bk, COLORREF seltext, COLORREF selbk, COLORREF fill, COLORREF line)
{
	m_rgbText = text;
	m_rgbBk = bk;
	m_rgbSelText = seltext;
	m_rgbSelBk = selbk;
	m_rgbFill = fill;
	m_rgbLine = line;
	Invalidate();
}

void CFlexCheckBox::SetRect()
{
	if (m_hWnd == NULL)
		return;

	RECT rect = GetRect();
	SetWindowPos(m_hWnd, NULL, rect.left, rect.top, rect.right, rect.bottom, SWP_NOZORDER | SWP_NOMOVE);
}

RECT CFlexCheckBox::GetRect(const RECT &rect)
{
	int h = GetTextHeight(m_hFont);
	RECT ret = {rect.left, rect.top, rect.right, rect.top + h + 2};
	return ret;
}

RECT CFlexCheckBox::GetRect()
{
	RECT rect;
	GetClientRect(&rect);
	return GetRect(rect);
}

void CFlexCheckBox::OnPaint(HDC hDC)
{
	HDC hBDC = NULL, hODC = NULL;
	CBitmap *pbm = NULL;

	if (!InRenderMode())
	{
		hODC = hDC;
		pbm = CBitmap::Create(GetClientSize(), RGB(0,0,0), hDC);
		if (pbm != NULL)
		{
			hBDC = pbm->BeginPaintInto();
			if (hBDC != NULL)
			{
				hDC = hBDC;
			}
		}
	}

	InternalPaint(hDC);

	if (!InRenderMode())
	{
		if (pbm != NULL)
		{
			if (hBDC != NULL)
			{
				pbm->EndPaintInto(hBDC);
				pbm->Draw(hODC);
			}
			delete pbm;
		}
	}
}

void CFlexCheckBox::InternalPaint(HDC hDC)
{
	HGDIOBJ hBrush = (HGDIOBJ)CreateSolidBrush(m_rgbBk);
	if (hBrush != NULL)
	{
		HGDIOBJ hOldBrush = SelectObject(hDC, hBrush);

		// Erase the background first
		RECT client;
		GetClientRect(&client);
		Rectangle(hDC, client.left, client.top, client.right, client.bottom);

		// Create pen for check box
		HGDIOBJ hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, m_rgbLine);
		if (hPen != NULL)
		{
			HGDIOBJ hOldPen = SelectObject(hDC, hPen);

			RECT rect = {0, 0, 0, 0}, textrc;
			GetClientRect(&rect);
			textrc = rect;
			int iBoxDim = rect.bottom - rect.top;

			// Draw the square box
			rect.right = rect.left + iBoxDim;
			InflateRect(&rect, -2, -2);
			OffsetRect(&rect, 0, -2);  // Move up to align with the text
			Rectangle(hDC, rect.left, rect.top, rect.right, rect.bottom);

			// Draw the check mark if the state is checked.
			if (m_bChecked)
			{
				HGDIOBJ hCrossPen = CreatePen(PS_SOLID, 3, m_rgbLine);
				if (hCrossPen != NULL)
				{
					SelectObject(hDC, hCrossPen);
					MoveToEx(hDC, rect.left + 2, rect.top + 2, NULL);  // Upper left
					LineTo(hDC, rect.right - 2, rect.bottom - 2);  // Lower right
					MoveToEx(hDC, rect.right - 2, rect.top + 2, NULL);  // Upper right
					LineTo(hDC, rect.left + 2, rect.bottom - 2);  // Lower left
					SelectObject(hDC, hPen);
					DeleteObject(hCrossPen);
				}
			}

			SetBkMode(hDC, TRANSPARENT);

			// Draw the message text
			SetTextColor(hDC, m_rgbText);
			textrc.left = rect.right + 8;
			DrawText(hDC, m_tszText, -1, &textrc, DT_LEFT|DT_NOPREFIX|DT_WORDBREAK);

			SelectObject(hDC, hOldPen);
			DeleteObject(hPen);
		}

		SelectObject(hDC, hOldBrush);
		DeleteObject(hBrush);
	}
}

void CFlexCheckBox::Notify(int code)
{
	if (!m_hWndNotify)
		return;

	PostMessage(m_hWndNotify, WM_FLEXCHECKBOX,
		(WPARAM)code, (LPARAM)(LPVOID)this);
}

void CFlexCheckBox::OnClick(POINT point, WPARAM fwKeys, BOOL bLeft)
{
	if (!m_hWnd)
		return;

	RECT rect;
	GetClientRect(&rect);
	rect.right = rect.left + (rect.bottom - rect.top);  // Adjust the width to same as height.
	InflateRect(&rect, -2, -2);
	OffsetRect(&rect, 0, -2);  // Move up to align with the text
	if (PtInRect(&rect, point))
	{
		m_bChecked = !m_bChecked;
		Invalidate();
		Notify(m_bChecked ? CHKNOTIFY_CHECK : CHKNOTIFY_UNCHECK);  // Notify the page object about the state change.
	} else
	{
		// Unhighlight current callout
		HWND hWndParent;
		hWndParent = GetParent(m_hWnd);
		SendMessage(hWndParent, WM_UNHIGHLIGHT, 0, 0);  // Send click message to page to unhighlight callout
	}
}

void CFlexCheckBox::OnMouseOver(POINT point, WPARAM fwKeys)
{
	Notify(CHKNOTIFY_MOUSEOVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexcheckbox.h ===
//-----------------------------------------------------------------------------
// File: flexcheckbox.h
//
// Desc: Implements a check box control similar to Windows check box.
//       CFlexCheckBox is derived from CFlexWnd.  The only place that
//       uses CFlxCheckBox is in the keyboard for sorting by assigned
//       keys.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __FLEXCHECKBOX_H__
#define __FLEXCHECKBOX_H__

enum CHECKNOTIFY {
	CHKNOTIFY_UNCHECK,
	CHKNOTIFY_CHECK,
	CHKNOTIFY_MOUSEOVER};

class CFlexCheckBox : public CFlexWnd
{
	LPTSTR m_tszText;  // Text string of the message
	BOOL m_bChecked;
	COLORREF m_rgbText, m_rgbBk, m_rgbSelText, m_rgbSelBk, m_rgbFill, m_rgbLine;
	HFONT m_hFont;

	HWND m_hWndNotify;

	void SetRect();
	void InternalPaint(HDC hDC);

	RECT GetRect(const RECT &);
	RECT GetRect();

	void Notify(int code);

public:
	CFlexCheckBox();
	virtual ~CFlexCheckBox();

	void SetNotify(HWND hWnd) { m_hWndNotify = hWnd; }
	void SetCheck(BOOL bChecked) { m_bChecked = bChecked; }
	BOOL GetCheck() { return m_bChecked; }
	void SetText(LPCTSTR tszText);

	// cosmetics
	void SetFont(HFONT hFont);
	void SetColors(COLORREF text, COLORREF bk, COLORREF seltext, COLORREF selbk, COLORREF fill, COLORREF line);

	virtual void OnPaint(HDC hDC);
	virtual void OnClick(POINT point, WPARAM fwKeys, BOOL bLeft);
	virtual void OnMouseOver(POINT point, WPARAM fwKeys);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexcombobox.h ===
//-----------------------------------------------------------------------------
// File: flexcombobox.h
//
// Desc: Implements a combo box control similar to Windows combo box.
//       CFlexComboBox is derived from CFlexWnd.  It is used by the page
//       for player list and genre list.  When the combo box is open,
//       CFlexComboBox uses a CFlexListBox for the list window.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __FLEXCOMBOBOX_H__
#define __FLEXCOMBOBOX_H__


#include "flexlistbox.h"


#define FCBF_DEFAULT 0

enum {
	FCBN_SELCHANGE,
	FCBN_MOUSEOVER
};

struct FLEXCOMBOBOXCREATESTRUCT {
	DWORD dwSize;
	DWORD dwFlags;
	DWORD dwListBoxFlags;
	HWND hWndParent;
	HWND hWndNotify;
	BOOL bVisible;
	RECT rect;
	HFONT hFont;
	COLORREF rgbText, rgbBk, rgbSelText, rgbSelBk, rgbFill, rgbLine;
	int nSBWidth;
};

class CFlexComboBox : public CFlexWnd
{
public:
	CFlexComboBox();
	~CFlexComboBox();

	// creation
	BOOL Create(FLEXCOMBOBOXCREATESTRUCT *);

	// cosmetics
	void SetFont(HFONT hFont);
	void SetColors(COLORREF text, COLORREF bk, COLORREF seltext, COLORREF selbk, COLORREF fill, COLORREF line);

	// setup
	int AddString(LPCTSTR);	// returns index

	// interaction
	void SetSel(int i);
	int GetSel();
	LPCTSTR GetText();

protected:
	virtual void OnPaint(HDC hDC);
	virtual LRESULT WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
	HWND m_hWndNotify;

	COLORREF m_rgbText, m_rgbBk, m_rgbSelText, m_rgbSelBk, m_rgbFill, m_rgbLine;
	HFONT m_hFont;
	int m_nSBWidth;
	int m_nTextHeight;
	DWORD m_dwFlags;
	DWORD m_dwListBoxFlags;

	enum FCBSTATEEVENT {
		FCBSE_DOWN,
		FCBSE_UPBOX,
		FCBSE_UPLIST,
		FCBSE_UPOFF,
		FCBSE_DOWNOFF
	};

	enum FCBSTATE {
		FCBS_CLOSED,
		FCBS_OPENDOWN,
		FCBS_OPENUP,
		FCBS_CANCEL,
		FCBS_SELECT
	};

	FCBSTATE m_eCurState;
	void StateEvent(FCBSTATEEVENT e);
	void SetState(FCBSTATE s);
	int m_OldSel;

	RECT GetRect(const RECT &);
	RECT GetRect();
	RECT GetListBoxRect();
	void SetRect();
	RECT m_rect;

	void InternalPaint(HDC hDC);
	
	void Notify(int code);

	CFlexListBox m_ListBox;
	BOOL m_bInSelMode;

	void DoSel();
};


CFlexComboBox *CreateFlexComboBox(FLEXCOMBOBOXCREATESTRUCT *pcs);


#endif //__FLEXCOMBOBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexcombobox.cpp ===
//-----------------------------------------------------------------------------
// File: flexcombobox.cpp
//
// Desc: Implements a combo box control similar to Windows combo box.
//       CFlexComboBox is derived from CFlexWnd.  It is used by the page
//       for player list and genre list.  When the combo box is open,
//       CFlexComboBox uses a CFlexListBox for the list window.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


CFlexComboBox::CFlexComboBox() :
	m_nTextHeight(-1),
	m_hWndNotify(NULL),
	m_rgbText(RGB(255,255,255)),
	m_rgbBk(RGB(0,0,0)),
	m_rgbSelText(RGB(0,0,255)),
	m_rgbSelBk(RGB(0,0,0)),
	m_rgbFill(RGB(0,0,255)),
	m_rgbLine(RGB(0,255,255)),
	m_dwFlags(0),
	m_dwListBoxFlags(0),
	m_bInSelMode(FALSE),
	m_nSBWidth(11),
	m_hFont(NULL),
	m_eCurState(FCBS_CLOSED),
	m_OldSel(-1)
{
}

CFlexComboBox::~CFlexComboBox()
{
}

CFlexComboBox *CreateFlexComboBox(FLEXCOMBOBOXCREATESTRUCT *pcs)
{
	CFlexComboBox *psb = new CFlexComboBox;
	
	if (psb && psb->Create(pcs))
		return psb;
	
	delete psb;
	return NULL;
}

BOOL CFlexComboBox::Create(FLEXCOMBOBOXCREATESTRUCT *pcs)
{
	if (this == NULL)
		return FALSE;

	if (pcs == NULL)
		return FALSE;

	if (pcs->dwSize != sizeof(FLEXCOMBOBOXCREATESTRUCT))
		return FALSE;

	m_hWndNotify = pcs->hWndNotify ? pcs->hWndNotify : pcs->hWndParent;

	m_dwFlags = pcs->dwFlags;
	m_dwListBoxFlags = pcs->dwListBoxFlags;

	SetFont(pcs->hFont);
	SetColors(pcs->rgbText, pcs->rgbBk, pcs->rgbSelText, pcs->rgbSelBk, pcs->rgbFill, pcs->rgbLine);
	m_nSBWidth = pcs->nSBWidth;
	m_rect = pcs->rect;

	if (!CFlexWnd::Create(pcs->hWndParent, GetRect(pcs->rect), pcs->bVisible))
		return FALSE;

//@@BEGIN_MSINTERNAL
	// TODO:  make sure that creation sends no notifications.
	// all initial notifications should be sent here.
//@@END_MSINTERNAL

	return TRUE;
}

void CFlexComboBox::OnPaint(HDC hDC)
{
	HDC hBDC = NULL, hODC = NULL;
	CBitmap *pbm = NULL;

	if (!InRenderMode())
	{
		hODC = hDC;
		pbm = CBitmap::Create(GetClientSize(), RGB(0,0,0), hDC);
		if (pbm != NULL)
		{
			hBDC = pbm->BeginPaintInto();
			if (hBDC != NULL)
			{
				hDC = hBDC;
			}
		}
	}

	InternalPaint(hDC);

	if (!InRenderMode())
	{
		if (pbm != NULL)
		{
			if (hBDC != NULL)
			{
				pbm->EndPaintInto(hBDC);
				pbm->Draw(hODC);
			}
			delete pbm;
		}
	}
}

void CFlexComboBox::SetSel(int i)
{
	m_ListBox.SelectAndShowSingleItem(i, TRUE);
}

int CFlexComboBox::GetSel()
{
	return m_ListBox.GetSel();
}

LPCTSTR CFlexComboBox::GetText()
{
	return m_ListBox.GetSelText();
}

void CFlexComboBox::InternalPaint(HDC hDC)
{
	HGDIOBJ hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, m_rgbLine);
	if (hPen != NULL)
	{
		HGDIOBJ	hOldPen = SelectObject(hDC, hPen);

		HGDIOBJ hBrush = (HGDIOBJ)CreateSolidBrush(m_rgbBk);
		if (hBrush != NULL)
		{
			HGDIOBJ hOldBrush = SelectObject(hDC, hBrush);

			RECT rect = {0,0,0,0};
			GetClientRect(&rect);
			Rectangle(hDC, rect.left, rect.top, rect.right, rect.bottom);

			RECT arect = rect;

			arect.left = arect.right - (arect.bottom - arect.top);

			// If we are read-only, only draw the text in gray. No border, no arrow.
			if (!GetReadOnly())
			{
				MoveToEx(hDC, arect.left, arect.top, NULL);
				LineTo(hDC, arect.left, arect.bottom);
			}

			rect.left++;
			rect.top++;
			rect.right = arect.left;
			rect.bottom--;

			SetTextColor(hDC, m_rgbText);
			SetBkMode(hDC, TRANSPARENT);

			LPTSTR lpText = (LPTSTR)GetText();
			if (lpText)
			{
				DrawText(hDC, lpText, -1, &rect, DT_NOPREFIX);
			}

			SelectObject(hDC, hOldBrush);
			DeleteObject(hBrush);

			if (!GetReadOnly())
			{
				hBrush = (HGDIOBJ)CreateSolidBrush(m_rgbFill);
				if (hBrush != NULL)
				{
					SelectObject(hDC, hBrush);

					InflateRect(&arect, -3, -3);
					DrawArrow(hDC, arect, TRUE, FALSE);

					SelectObject(hDC, hOldBrush);
					DeleteObject(hBrush);
				}
			}
		}

		SelectObject(hDC, hOldPen);
		DeleteObject(hPen);
	}
}

int CFlexComboBox::AddString(LPCTSTR str)
{
	return m_ListBox.AddString(str);
}

LRESULT CFlexComboBox::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	RECT wrect = {-1, -1, -1, -1};
	POINT point = {-1, -1};
	BOOL bWithin = FALSE;

	switch (msg)
	{
		case WM_SIZE:
			Invalidate();
			SetRect();
			return 0;

		case WM_FLEXLISTBOX:
			assert(lParam == (LPARAM)(LPVOID)&m_ListBox);
			switch (wParam)
			{
				case FLBN_FINALSEL:
					StateEvent(FCBSE_UPLIST);
					break;
				case FLBN_CANCEL:
					StateEvent(FCBSE_DOWNOFF);
					break;
			}
			return 0;

		// make sure flexwnd doesn't do ANYTHING with our mouse messages
		case WM_MOUSEMOVE:
			// We initialize the tooltip to current selection text if the selected text is too long to fit.
			RECT rect;
			GetClientRect(&rect);
			rect.right = rect.right - (rect.bottom - rect.top);
			rect.left++;
			rect.top++;
			rect.bottom--;
			RECT ResultRect;
			ResultRect = rect;
			HDC hDC;
			hDC = CreateCompatibleDC(NULL);
			if (hDC)
			{
				LPTSTR lpText = (LPTSTR)GetText();
				if (lpText)
				{
					DrawText(hDC, lpText, -1, &ResultRect, DT_NOPREFIX|DT_CALCRECT);
				}
				DeleteDC(hDC);
			}
			if (rect.right < ResultRect.right || rect.bottom < ResultRect.bottom)
			{
				CFlexWnd::s_ToolTip.SetToolTipParent(GetParent(m_hWnd));
				TOOLTIPINITPARAM ttip;
				ttip.hWndParent = GetParent(m_hWnd);
				ttip.iSBWidth = 0;
				ttip.dwID = 0;
				ttip.hWndNotify = m_hWnd;
				ttip.tszCaption = m_ListBox.GetSelText();
				CFlexToolTip::UpdateToolTipParam(ttip);
			}
			Notify(FCBN_MOUSEOVER);

		case WM_LBUTTONUP:
		case WM_LBUTTONDOWN:
		case WM_RBUTTONUP:
		case WM_RBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
		case WM_RBUTTONDBLCLK:
			if (msg == WM_LBUTTONDOWN)
			{
				HWND hWndParent;
				hWndParent = GetParent(hWnd);
				SendMessage(hWndParent, WM_UNHIGHLIGHT, 0, 0);  // Send click message to page to unhighlight callout
			}
			GetClientRect(&wrect);
			point.x = int(LOWORD(lParam));
			point.y = int(HIWORD(lParam));
			bWithin = PtInRect(&wrect, point);
			break;
		case WM_TIMER:
		case WM_CAPTURECHANGED:
			break;
		default:
			return CFlexWnd::WndProc(hWnd, msg, wParam, lParam);
	}

	switch (msg)
	{
		case WM_LBUTTONDOWN:
			if (!GetReadOnly())
				StateEvent(bWithin ? FCBSE_DOWN : FCBSE_DOWNOFF);
			break;

		case WM_LBUTTONUP:
			if (!GetReadOnly())
				StateEvent(bWithin ? FCBSE_UPBOX : FCBSE_UPOFF);
			break;
	}

	return 0;
}

RECT CFlexComboBox::GetListBoxRect()
{
	HWND hParent = GetParent(m_hWnd);
	RECT rect;
	GetClientRect(&rect);
	BOOL bRet = ClientToScreen(m_hWnd, &rect);
	BOOL bRet2 = ScreenToClient(hParent, &rect);

	RECT lrect = m_rect;
	lrect.top = rect.bottom;
	lrect.right -= 12;  // UNDONE: remove this line when the clipping is working properly (scroll bars don't appear above other windows)

	return lrect;
}

void CFlexComboBox::DoSel()
{
	if (m_bInSelMode)
		return;
	
	if (m_hWnd == NULL)
		return;

	FLEXLISTBOXCREATESTRUCT cs;
	cs.dwSize = sizeof(FLEXLISTBOXCREATESTRUCT);
	cs.dwFlags = m_dwListBoxFlags;
	cs.hWndParent = GetParent(m_hWnd);
	cs.hWndNotify = m_hWnd;
	cs.bVisible = FALSE;
	cs.rect = GetListBoxRect();
	cs.hFont = m_hFont;
	cs.rgbText = m_rgbText;
	cs.rgbBk = m_rgbBk;
	cs.rgbSelText = m_rgbSelText;
	cs.rgbSelBk = m_rgbSelBk;
	cs.rgbFill = m_rgbFill;
	cs.rgbLine = m_rgbLine;
	cs.nSBWidth = m_nSBWidth;

	m_OldSel = m_ListBox.GetSel();

	m_bInSelMode = m_ListBox.Create(&cs);
	if (m_bInSelMode)
		SetWindowPos(m_ListBox.m_hWnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
}

void CFlexComboBox::Notify(int code)
{
	if (!m_hWndNotify)
		return;

	SendMessage(m_hWndNotify, WM_FLEXCOMBOBOX,
		(WPARAM)code, (LPARAM)(LPVOID)this);
}

RECT CFlexComboBox::GetRect(const RECT &rect)
{
	int h = GetTextHeight(m_hFont);
	RECT ret = {rect.left, rect.top, rect.right, rect.top + h + 2};
	return ret;
}

RECT CFlexComboBox::GetRect()
{
	RECT rect;
	GetClientRect(&rect);
	return GetRect(rect);
}

void CFlexComboBox::SetFont(HFONT hFont)
{
	m_hFont = hFont;

	if (m_hWnd == NULL)
		return;

	Invalidate();
	SetRect();
}

void CFlexComboBox::SetRect()
{
	if (m_hWnd == NULL)
		return;

	RECT rect = GetRect();
	SetWindowPos(m_hWnd, NULL, rect.left, rect.top, rect.right, rect.bottom, SWP_NOZORDER | SWP_NOMOVE);
}

void CFlexComboBox::SetColors(COLORREF text, COLORREF bk, COLORREF seltext, COLORREF selbk, COLORREF fill, COLORREF line)
{
	m_rgbText = text;
	m_rgbBk = bk;
	m_rgbSelText = seltext;
	m_rgbSelBk = selbk;
	m_rgbFill = fill;
	m_rgbLine = line;
	Invalidate();
}

void CFlexComboBox::StateEvent(FCBSTATEEVENT e)
{
	if (e == FCBSE_DOWNOFF)
	{
		SetState(FCBS_CANCEL);
		return;
	}

	switch (m_eCurState)
	{
		case FCBS_CLOSED:
			if (e == FCBSE_DOWN)
				SetState(FCBS_OPENDOWN);
			break;

		case FCBS_OPENDOWN:
			switch (e)
			{
				case FCBSE_UPLIST:
					SetState(FCBS_SELECT);
					break;
				case FCBSE_UPBOX:
					SetState(FCBS_OPENUP);
					break;
				case FCBSE_UPOFF:
					SetState(FCBS_CANCEL);
					break;
			}

		case FCBS_OPENUP:
			if (e == FCBSE_DOWN)
				SetState(FCBS_OPENDOWN);
			break;

		default:
			assert(0);
			return;
	}
}

void CFlexComboBox::SetState(FCBSTATE s)
{
	FCBSTATE eOldState = m_eCurState;
	m_eCurState = s;

	switch (s)
	{
		case FCBS_OPENUP:
			if (eOldState == FCBS_CLOSED)
				DoSel();
			return;

		case FCBS_OPENDOWN:
			if (eOldState == FCBS_CLOSED)
				DoSel();
			m_ListBox.StartSel();
			return;

		case FCBS_CANCEL:
			m_ListBox.SetSel(m_OldSel);
			CFlexWnd::s_ToolTip.SetEnable(FALSE);
			SetState(FCBS_CLOSED);
			return;

		case FCBS_SELECT:
			CFlexWnd::s_ToolTip.SetEnable(FALSE);
			Invalidate();
			Notify(FCBN_SELCHANGE);
			SetState(FCBS_CLOSED);
			return;

		case FCBS_CLOSED:
			if (eOldState != FCBS_CLOSED)
				m_ListBox.Destroy();
			m_bInSelMode = FALSE;
			Invalidate();
			return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexinfobox.cpp ===
//-----------------------------------------------------------------------------
// File: flexinfobox.cpp
//
// Desc: Implements a simple text box that displays a text string.
//       CFlexInfoBox is derived from CFlexWnd.  It is used by the page
//       for displaying direction throughout the UI.  The strings are
//       stored as resources.  The class has a static buffer which will
//       be filled with the string by the resource API when needed.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"

CFlexInfoBox::CFlexInfoBox() :
	m_iCurIndex(-1),
	m_rgbText(RGB(255,255,255)),
	m_rgbBk(RGB(0,0,0)),
	m_rgbSelText(RGB(0,0,255)),
	m_rgbSelBk(RGB(0,0,0)),
	m_rgbFill(RGB(0,0,255)),
	m_rgbLine(RGB(0,255,255)),
	m_hFont(NULL),
	m_bVertSB(FALSE),
	m_nSBWidth(11)
{
	m_TextRect.top = 0;
	m_TextRect.left = 0;
	m_TextRect.bottom = 0;
	m_TextRect.right = 0;
}

CFlexInfoBox::~CFlexInfoBox()
{
}

BOOL CFlexInfoBox::Create(HWND hParent, const RECT &rect, BOOL bVisible)
{
	if (!CFlexWnd::Create(hParent, rect, bVisible))
		return FALSE;

	FLEXSCROLLBARCREATESTRUCT sbcs;
	sbcs.dwSize = sizeof(FLEXSCROLLBARCREATESTRUCT);
	sbcs.dwFlags = FSBF_VERT;
	sbcs.min = 0;
	sbcs.max = 3;
	sbcs.page = 1;
	sbcs.pos = 1;
	sbcs.hWndParent = m_hWnd;
	sbcs.hWndNotify = m_hWnd;
	RECT rc = {0, 0, 1, 1};
	sbcs.rect = rc;
	sbcs.bVisible = FALSE;
	return m_VertSB.Create(&sbcs);
}

void CFlexInfoBox::SetText(int iIndex)
{
	if (iIndex == m_iCurIndex)
		return;

	// Load the string from resource
	LoadString(g_hModule, iIndex, m_tszText, MAX_PATH);

	// Calculate the rectangle for text
	RECT titlerc;
	m_TextRect = g_InfoWndRect;
	OffsetRect(&m_TextRect, -m_TextRect.left, -m_TextRect.top);

	InflateRect(&m_TextRect, -1, -1);
	titlerc = m_TextRect;
	HDC hDC = CreateCompatibleDC(NULL);
	if (hDC)
	{
		TCHAR tszResourceString[MAX_PATH];
		LoadString(g_hModule, IDS_INFO_TITLE, tszResourceString, MAX_PATH);
		DrawText(hDC, tszResourceString, -1, &titlerc, DT_CENTER|DT_NOPREFIX|DT_CALCRECT);
		m_TextRect.top = titlerc.bottom + 1;
		m_TextWinRect = m_TextRect;
		DrawText(hDC, m_tszText, -1, &m_TextRect, DT_CENTER|DT_NOPREFIX|DT_CALCRECT|DT_WORDBREAK);
		if (m_TextRect.bottom + 1 > g_InfoWndRect.bottom - g_InfoWndRect.top)
		{
			// Text too long. We need a scroll bar.
			m_TextRect.right -= m_nSBWidth;
			DrawText(hDC, m_tszText, -1, &m_TextRect, DT_CENTER|DT_NOPREFIX|DT_CALCRECT|DT_WORDBREAK);
			SetVertSB(TRUE);
		} else
			SetVertSB(FALSE);
		DeleteDC(hDC);
	}

	m_iCurIndex = iIndex;
	Invalidate();
}

void CFlexInfoBox::SetFont(HFONT hFont)
{
	m_hFont = hFont;

	if (m_hWnd == NULL)
		return;

	Invalidate();
}

void CFlexInfoBox::SetColors(COLORREF text, COLORREF bk, COLORREF seltext, COLORREF selbk, COLORREF fill, COLORREF line)
{
	m_rgbText = text;
	m_rgbBk = bk;
	m_rgbSelText = seltext;
	m_rgbSelBk = selbk;
	m_rgbFill = fill;
	m_rgbLine = line;
	m_VertSB.SetColors(m_rgbBk, m_rgbFill, m_rgbLine);

	Invalidate();
}

void CFlexInfoBox::SetRect()
{
	if (m_hWnd == NULL)
		return;

	RECT rect = GetRect();
	SetWindowPos(m_hWnd, NULL, rect.left, rect.top, rect.right, rect.bottom, SWP_NOZORDER | SWP_NOMOVE);
}

RECT CFlexInfoBox::GetRect(const RECT &rect)
{
	int h = GetTextHeight(m_hFont);
	RECT ret = {rect.left, rect.top, rect.right, rect.top + h + 2};
	return ret;
}

RECT CFlexInfoBox::GetRect()
{
	RECT rect;
	GetClientRect(&rect);
	return GetRect(rect);
}

void CFlexInfoBox::OnPaint(HDC hDC)
{
	HDC hBDC = NULL, hODC = NULL;
	CBitmap *pbm = NULL;

	if (!InRenderMode())
	{
		hODC = hDC;
		pbm = CBitmap::Create(GetClientSize(), RGB(0,0,0), hDC);
		if (pbm != NULL)
		{
			hBDC = pbm->BeginPaintInto();
			if (hBDC != NULL)
			{
				hDC = hBDC;
			}
		}
	}

	InternalPaint(hDC);

	if (!InRenderMode())
	{
		if (pbm != NULL)
		{
			if (hBDC != NULL)
			{
				pbm->EndPaintInto(hBDC);
				pbm->Draw(hODC);
			}
			delete pbm;
		}
	}
}

void CFlexInfoBox::InternalPaint(HDC hDC)
{
	TCHAR tszResourceString[MAX_PATH];
	HGDIOBJ hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, m_rgbLine);
	if (hPen != NULL)
	{
		HGDIOBJ hOldPen = SelectObject(hDC, hPen);

		HGDIOBJ hBrush = (HGDIOBJ)CreateSolidBrush(m_rgbBk);
		if (hBrush != NULL)
		{
			HGDIOBJ hOldBrush = SelectObject(hDC, hBrush);

			RECT rect = {0,0,0,0}, titlerc;
			GetClientRect(&rect);
			titlerc = rect;
			Rectangle(hDC, rect.left, rect.top, rect.right, rect.bottom);

			InflateRect(&rect, -1, -1);
			SetBkMode(hDC, TRANSPARENT);

			LoadString(g_hModule, IDS_INFO_TITLE, tszResourceString, MAX_PATH);
			// Draw the message text
			SetTextColor(hDC, m_rgbText);
			rect = m_TextRect;
			// Offset the rectangle to account for scroll bar
			if (m_bVertSB)
			{
				OffsetRect(&rect, 0, -m_VertSB.GetPos());
			}
			DrawText(hDC, m_tszText, -1, &rect, DT_LEFT|DT_NOPREFIX|DT_WORDBREAK);

			GetClientRect(&rect);
			InflateRect(&rect, -1, -1);
			SetTextColor(hDC, m_rgbLine);  // User line color for Information title
			// Get the title area rantangle
			DrawText(hDC, tszResourceString, -1, &titlerc, DT_CENTER|DT_NOPREFIX|DT_CALCRECT);
			// Adjust right edge position to old value
			titlerc.right = rect.right + 1;
			// Draw a rectangle around the title area.
			Rectangle(hDC, titlerc.left, titlerc.top, titlerc.right, titlerc.bottom);
			// Draw title text (Information)
			DrawText(hDC, tszResourceString, -1, &titlerc, DT_CENTER|DT_NOPREFIX);

			SelectObject(hDC, hOldBrush);
			DeleteObject(hBrush);
		}

		SelectObject(hDC, hOldPen);
		DeleteObject(hPen);
	}
}

void CFlexInfoBox::SetVertSB(BOOL bSet)
{
	if (!bSet && !m_bVertSB)
		return;

	m_bVertSB = bSet;

	if (m_hWnd == NULL)
		return;

	SetVertSB();
}

void CFlexInfoBox::SetVertSB()
{
	if (m_bVertSB)
	{
		SetSBValues();
		SIZE client = GetClientSize();
		client.cy = m_TextWinRect.bottom - m_TextWinRect.top;
		SetWindowPos(m_VertSB.m_hWnd, NULL, client.cx - m_nSBWidth - 1, m_TextRect.top, m_nSBWidth, client.cy - 1, SWP_NOZORDER);
	}

	ShowWindow(m_VertSB.m_hWnd, m_bVertSB ? SW_SHOW : SW_HIDE);
}

void CFlexInfoBox::SetSBValues()
{
	if (m_hWnd == NULL)
		return;

	m_VertSB.SetValues(0, m_TextRect.bottom - m_TextRect.top, m_TextWinRect.bottom - m_TextWinRect.top, 0);
}

void CFlexInfoBox::OnWheel(POINT point, WPARAM wParam)
{
	if (!m_bVertSB) return;

	if (m_VertSB.GetMin() == m_VertSB.GetMax()) return;

	int nPage = MulDiv(m_VertSB.GetPage(), 9, 10) >> 1;  // Half a page at a time

	if ((int)wParam >= 0)
		m_VertSB.AdjustPos(-nPage);
	else
		m_VertSB.AdjustPos(nPage);

	Invalidate();
}

LRESULT CFlexInfoBox::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
		case WM_FLEXVSCROLL:
		{
			int code = (int)wParam;
			CFlexScrollBar *pSB = (CFlexScrollBar *)lParam;
			if (!pSB)
				return 0;

			int nLine = 1;
			int nPage = MulDiv(pSB->GetPage(), 9, 10);

			switch (code)
			{
				case SB_LINEUP: pSB->AdjustPos(-nLine); break;
				case SB_LINEDOWN: pSB->AdjustPos(nLine); break;
				case SB_PAGEUP: pSB->AdjustPos(-nPage); break;
				case SB_PAGEDOWN: pSB->AdjustPos(nPage); break;
				case SB_THUMBTRACK: pSB->SetPos(pSB->GetThumbPos()); break;
				case SB_ENDSCROLL:
					::ReleaseCapture();
					break;
			}

			Invalidate();
			return 0;
		}
		default:
			if (msg == WM_LBUTTONDOWN)
			{
				HWND hWndParent;
				hWndParent = GetParent(hWnd);
				SendMessage(hWndParent, WM_UNHIGHLIGHT, 0, 0);  // Send click message to page to unhighlight callout
			}
			return CFlexWnd::WndProc(hWnd, msg, wParam, lParam);
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexinfobox.h ===
//-----------------------------------------------------------------------------
// File: flexinfobox.h
//
// Desc: Implements a simple text box that displays a text string.
//       CFlexInfoBox is derived from CFlexWnd.  It is used by the page
//       for displaying direction throughout the UI.  The strings are
//       stored as resources.  The class has a static buffer which will
//       be filled with the string by the resource API when needed.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __FLEXINFOBOX_H__
#define __FLEXINFOBOX_H__

class CFlexInfoBox : public CFlexWnd
{
	TCHAR m_tszText[MAX_PATH];  // Text string of the message
	int m_iCurIndex;  // Current text index
	COLORREF m_rgbText, m_rgbBk, m_rgbSelText, m_rgbSelBk, m_rgbFill, m_rgbLine;
	HFONT m_hFont;
	RECT m_TextRect;
	RECT m_TextWinRect;
	int m_nSBWidth;

	CFlexScrollBar m_VertSB;
	BOOL m_bVertSB;

	void SetVertSB(BOOL bSet);
	void SetVertSB();
	void SetSBValues();

	void SetRect();
	void InternalPaint(HDC hDC);

	RECT GetRect(const RECT &);
	RECT GetRect();

protected:
	virtual LRESULT WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	virtual void OnPaint(HDC hDC);
	virtual void OnWheel(POINT point, WPARAM wParam);

public:
	CFlexInfoBox();
	virtual ~CFlexInfoBox();

	BOOL Create(HWND hParent, const RECT &rect, BOOL bVisible);
	void SetText(int iIndex);

	// cosmetics
	void SetFont(HFONT hFont);
	void SetColors(COLORREF text, COLORREF bk, COLORREF seltext, COLORREF selbk, COLORREF fill, COLORREF line);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexlistbox.cpp ===
//-----------------------------------------------------------------------------
// File: flexlistbox.cpp
//
// Desc: Implements a list box control that can display a list of text strings,
//       each can be selected by mouse.  The class CFlexListBox is derived from
//       CFlexWnd.  It is used by the class CFlexComboBox when it needs to
//       expand to show the list of choices.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


CFlexListBox::CFlexListBox() :
	m_nTextHeight(-1),
	m_hWndNotify(NULL),
	m_rgbText(RGB(255,255,255)),
	m_rgbBk(RGB(0,0,0)),
	m_rgbSelText(RGB(0,0,255)),
	m_rgbSelBk(RGB(0,0,0)),
	m_rgbFill(RGB(0,0,255)),
	m_rgbLine(RGB(0,255,255)),
	m_dwFlags(0),
	m_nTopIndex(0),
	m_nSBWidth(11),
	m_hFont(NULL),
	m_bOpenClick(FALSE),
	m_bDragging(FALSE),
	m_bCapture(FALSE),
	m_nSelItem(-1),
	m_bVertSB(FALSE)
{
}

CFlexListBox::~CFlexListBox()
{
}

CFlexListBox *CreateFlexListBox(FLEXLISTBOXCREATESTRUCT *pcs)
{
	CFlexListBox *psb = new CFlexListBox;

	if (psb && psb->Create(pcs))
		return psb;
	
	delete psb;
	return NULL;
}

BOOL CFlexListBox::CreateForSingleSel(FLEXLISTBOXCREATESTRUCT *pcs)
{
	if (!Create(pcs))
		return FALSE;

	StartSel();

	return TRUE;
}

BOOL CFlexListBox::Create(FLEXLISTBOXCREATESTRUCT *pcs)
{
	if (this == NULL)
		return FALSE;

	if (m_hWnd)
		Destroy();

	if (pcs == NULL)
		return FALSE;

	if (pcs->dwSize != sizeof(FLEXLISTBOXCREATESTRUCT))
		return FALSE;

	m_hWndNotify = pcs->hWndNotify ? pcs->hWndNotify : pcs->hWndParent;

	m_dwFlags = pcs->dwFlags;

	SetFont(pcs->hFont);
	SetColors(pcs->rgbText, pcs->rgbBk, pcs->rgbSelText, pcs->rgbSelBk, pcs->rgbFill, pcs->rgbLine);
	m_VertSB.SetColors(pcs->rgbBk, pcs->rgbFill, pcs->rgbLine);
	m_nSBWidth = pcs->nSBWidth;

	if (!CFlexWnd::Create(pcs->hWndParent, pcs->rect, FALSE))
		return FALSE;

	FLEXSCROLLBARCREATESTRUCT sbcs;
	sbcs.dwSize = sizeof(FLEXSCROLLBARCREATESTRUCT);
	sbcs.dwFlags = FSBF_VERT;
	sbcs.min = 0;
	sbcs.max = 3;
	sbcs.page = 1;
	sbcs.pos = 1;
	sbcs.hWndParent = m_hWnd;
	sbcs.hWndNotify = m_hWnd;
	RECT rect = {0, 0, 1, 1};
	sbcs.rect = rect;
	sbcs.bVisible = FALSE;
	m_VertSB.Create(&sbcs);

	Calc();

	// show if we want it shown
	if (pcs->bVisible)
		ShowWindow(m_hWnd, SW_SHOW);
	if (m_bVertSB)
		SetVertSB();

	// TODO:  make sure that creation sends no notifications.
	// all initial notifications should be sent here.

	return TRUE;
}

void CFlexListBox::Calc()
{
	// handle getting text height
	if (m_nTextHeight == -1)
	{
		m_nTextHeight = GetTextHeight(m_hFont);
		Invalidate();
		assert(m_nTextHeight != -1);
	}

	// don't do the rest unless we've been created
	if (m_hWnd == NULL)
		return;

	// handle integral height
	int iUsedHeight = m_ItemArray.GetSize() * m_nTextHeight;
	// If more than max height, use the max height
	if (iUsedHeight > g_UserNamesRect.bottom - g_UserNamesRect.top)
		iUsedHeight = g_UserNamesRect.bottom - g_UserNamesRect.top;

	SIZE client = GetClientSize();
	int fit = iUsedHeight / m_nTextHeight;
	if (fit < 1)
		fit = 1;
	int setheight = (m_dwFlags & FLBF_INTEGRALHEIGHT) ? fit * m_nTextHeight : iUsedHeight;
	if (setheight != client.cy)
		SetWindowPos(m_hWnd, NULL, 0, 0, client.cx, setheight,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOZORDER);

	// handle scroll bar
	SetVertSB(m_ItemArray.GetSize() > fit);
}

void CFlexListBox::SetFont(HFONT hFont)
{
	m_hFont = hFont;
	m_nTextHeight = -1;
	Calc();
}

void CFlexListBox::OnPaint(HDC hDC)
{
	HDC hBDC = NULL, hODC = NULL;
	CBitmap *pbm = NULL;

	if (!InRenderMode())
	{
		hODC = hDC;
		pbm = CBitmap::Create(GetClientSize(), RGB(0,0,0), hDC);
		if (pbm != NULL)
		{
			hBDC = pbm->BeginPaintInto();
			if (hBDC != NULL)
			{
				hDC = hBDC;
			}
		}
	}

	InternalPaint(hDC);

	if (!InRenderMode())
	{
		if (pbm != NULL)
		{
			if (hBDC != NULL)
			{
				pbm->EndPaintInto(hBDC);
				pbm->Draw(hODC);
			}
			delete pbm;
		}
	}
}

void CFlexListBox::InternalPaint(HDC hDC)
{
	if (m_nTextHeight == -1)
		return;

	SIZE client = GetClientSize();
	RECT rc = {0,0,0,0};
	GetClientRect(&rc);

	HGDIOBJ hPen, hOldPen, hBrush, hOldBrush;
	hPen= (HGDIOBJ)CreatePen(PS_SOLID, 1, m_rgbBk);
	if (hPen != NULL)
	{
		hOldPen = SelectObject(hDC, hPen);

		hBrush = CreateSolidBrush(m_rgbBk);
		if (hBrush != NULL)
		{
			hOldBrush = SelectObject(hDC, hBrush);

			Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);  // Paint entire window black first.

			if (!m_bVertSB)
				m_nTopIndex = 0;

			int iLastY;
			for (int at = 0, i = m_nTopIndex; at < client.cy; i++, at += m_nTextHeight)
			{
				RECT rect = {0, at, client.cx, at + m_nTextHeight};

				if (i < m_ItemArray.GetSize())
				{
					BOOL bSel = m_ItemArray[i].bSelected;
					SetTextColor(hDC, bSel ? m_rgbSelText : m_rgbText);
					SetBkColor(hDC, bSel ? m_rgbSelBk : m_rgbBk);
					DrawText(hDC, m_ItemArray[i].GetText(), -1, &rect, DT_NOPREFIX);
					iLastY = at + m_nTextHeight;
				}
			}

			SelectObject(hDC, hOldBrush);
			DeleteObject(hBrush);
		}

		SelectObject(hDC, hOldPen);
		DeleteObject(hPen);
	}

	// Draw an outline around the box
	hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, m_rgbLine);
	if (hPen != NULL)
	{
		hOldPen = SelectObject(hDC, hPen);
		hOldBrush = SelectObject(hDC, GetStockObject(NULL_BRUSH));
		Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);

		SelectObject(hDC, hOldPen);
		DeleteObject(hPen);
	}
}

int CFlexListBox::AddString(LPCTSTR str)
{
	int newIndex = m_ItemArray.GetSize();
	m_ItemArray.SetSize(newIndex + 1);
	FLEXLISTBOXITEM &i = m_ItemArray[newIndex];
	i.SetText(str);
	i.bSelected = FALSE;

	SetSBValues();
	Calc();
	Invalidate();

	return newIndex;
}

void CFlexListBox::StartSel()
{
	if (m_bDragging)
		return;
	SetTimer(m_hWnd, 5, 200, NULL);
	m_bOpenClick = TRUE;  // Initial click on the combobox
	m_bDragging = TRUE;
	m_bCapture = TRUE;
	SetCapture();
}

void CFlexListBox::OnWheel(POINT point, WPARAM wParam)
{
	if (!m_bVertSB) return;

	int nPage = MulDiv(m_VertSB.GetPage(), 9, 10) >> 1;  // Half a page at a time

	if ((int)wParam >= 0)
		m_VertSB.AdjustPos(-nPage);
	else
		m_VertSB.AdjustPos(nPage);

	m_nTopIndex = m_VertSB.GetPos();
	if (m_nTopIndex < 0)
		m_nTopIndex = 0;
	Invalidate();
}

LRESULT CFlexListBox::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	// first handle scroll bar messages
	switch (msg)
	{
		case WM_FLEXVSCROLL:
			int code = (int)wParam;
			CFlexScrollBar *pSB = (CFlexScrollBar *)lParam;
			if (!pSB)
				return 0;

			int nLine = 1;
			int nPage = MulDiv(pSB->GetPage(), 9, 10);

			switch (code)
			{
				case SB_LINEUP: pSB->AdjustPos(-nLine); break;
				case SB_LINEDOWN: pSB->AdjustPos(nLine); break;
				case SB_PAGEUP: pSB->AdjustPos(-nPage); break;
				case SB_PAGEDOWN: pSB->AdjustPos(nPage); break;
				case SB_THUMBTRACK: pSB->SetPos(pSB->GetThumbPos()); break;
				case SB_ENDSCROLL:
					SetCapture();	 // Recapture after the scroll bar releases the capture.
					break;
			}

			switch (msg)
			{
				case WM_FLEXVSCROLL:
					m_nTopIndex = pSB->GetPos();
					if (m_nTopIndex < 0)
						m_nTopIndex = 0;
					break;
			}

			Invalidate();
			return 0;
	}

	// now non-scrolly input
	switch (msg)
	{
		case WM_SIZE:
			SetSBValues();
			Calc();
			Invalidate();
			return 0;

		// make sure flexwnd doesn't do ANYTHING with our mouse messages
		case WM_MOUSEMOVE:
		case WM_LBUTTONUP:
		case WM_LBUTTONDOWN:
		case WM_RBUTTONUP:
		case WM_RBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
		case WM_RBUTTONDBLCLK:
		{
			POINT point = {int(signed short(LOWORD(lParam))), int(signed short(HIWORD(lParam)))};
			m_point = point;
		}
		case WM_TIMER:
		case WM_CAPTURECHANGED:
			break;
		default:
			return CFlexWnd::WndProc(hWnd, msg, wParam, lParam);
	}

	switch (msg)
	{
		case WM_LBUTTONDOWN:
			// Check if we clicked the scroll bar area.  If so, send the click to the scroll bar.
			RECT rc;
			m_VertSB.GetClientRect(&rc);
			ClientToScreen(m_VertSB.m_hWnd, &rc);
			ScreenToClient(m_hWnd, &rc);
			if (PtInRect(&rc, m_point))
			{
				POINT point = {int(signed short(LOWORD(lParam))), int(signed short(HIWORD(lParam)))};
				ClientToScreen(m_hWnd, &point);
				ScreenToClient(m_VertSB.m_hWnd, &point);
				PostMessage(m_VertSB.m_hWnd, WM_LBUTTONDOWN, wParam, point.x + (point.y << 16));  // This will make it lose capture.
			} else
				StartSel();
			break;

		case WM_MOUSEMOVE:
		case WM_LBUTTONUP:
			if (!m_bDragging)
				break;
			if (m_nTextHeight == -1)
				break;
		case WM_TIMER:
			if (m_bDragging || msg != WM_TIMER)
			{
				int adj = m_point.y < 0 ? -1 : 0;
				SelectAndShowSingleItem(adj + m_point.y / m_nTextHeight + m_nTopIndex, msg != WM_MOUSEMOVE);
				Notify(FLBN_SEL);
			}
			// Check if the mouse cursor is within the listbox rectangle.  If not, don't show the tooltip.
			if (msg == WM_MOUSEMOVE)
			{
				RECT rect;
				GetClientRect(&rect);
				POINT pt;
				GetCursorPos(&pt);
				ScreenToClient(m_hWnd, &pt);
				if (!PtInRect(&rect, pt))
				{
					CFlexWnd::s_ToolTip.SetToolTipParent(NULL);
					CFlexWnd::s_ToolTip.SetEnable(FALSE);
				}
			}
			break;
	}

	switch (msg)
	{
		case WM_CAPTURECHANGED:
			if ((HWND)lParam == m_VertSB.m_hWnd)  // If the scroll bar is getting the capture, we do not clean up.
				break;
		case WM_LBUTTONUP:
			if (m_bOpenClick)
			{
				m_bOpenClick = FALSE;  // If this is the result of clicking the combobox window, don't release capture.
				break;
			}
			if (m_bCapture)
			{
				m_bCapture = FALSE;
				KillTimer(m_hWnd, 5);
				ReleaseCapture();
				m_bDragging = FALSE;
				BOOL bCancel = TRUE;
				if (msg == WM_LBUTTONUP)
				{
					RECT wrect;
					GetClientRect(&wrect);
					if (PtInRect(&wrect, m_point))
						bCancel = FALSE;
				}
				Notify(bCancel ? FLBN_CANCEL : FLBN_FINALSEL);
			}
			break;
	}

	return 0;
}

void CFlexListBox::SelectAndShowSingleItem(int i, BOOL bScroll)
{
	int nItems = m_ItemArray.GetSize();

	if (nItems < 1)
	{
		m_nSelItem = i;  // We have to update m_nSelItem even if there is no items because the username combobox
		                 // is not initialized when there is only 1 user.  Selection of user 0 is assumed.
		return;
	}

	if (i < 0)
		i = 0;
	if (i >= nItems)
		i = nItems - 1;

	if (m_nSelItem >= 0 && m_nSelItem < nItems)
		m_ItemArray[m_nSelItem].bSelected = FALSE;

	m_nSelItem = i;
	m_ItemArray[m_nSelItem].bSelected = TRUE;

	if (bScroll)
	{
		SIZE client = GetClientSize();
		int nBottomIndex = m_nTopIndex + client.cy / m_nTextHeight - 1;

		if (m_nSelItem < m_nTopIndex)
			m_nTopIndex = m_nSelItem;

		assert(m_nTopIndex >= 0);

		if (m_nSelItem > nBottomIndex)
		{
			m_nTopIndex += m_nSelItem - nBottomIndex + 1;
			nBottomIndex = m_nSelItem + 1;
		}

		if (nBottomIndex > nItems - 1)
			m_nTopIndex -= nBottomIndex - nItems + 1;

		if (m_nTopIndex < 0)
			m_nTopIndex = 0;

		if (m_nTopIndex >= nItems)
			m_nTopIndex = nItems - 1;

		assert(m_nTopIndex >= 0 && m_nTopIndex < nItems);
	}

	if (m_bVertSB)
		SetSBValues();

	SIZE client = GetClientSize();
	int nBottomIndex = m_nTopIndex + client.cy / m_nTextHeight - 1;
	int iToolTipIndex = m_nSelItem;
	// Make sure that we don't display tooltip for items outside the listbox window
	if (iToolTipIndex > nBottomIndex)
		iToolTipIndex = nBottomIndex;
	if (iToolTipIndex < m_nTopIndex)
		iToolTipIndex = m_nTopIndex;
	// Create and initialize a tooltip if the text is too long to fit.
	RECT rect = {0, 0, client.cx, m_nTextHeight};
	RECT ResultRect = rect;
	HDC hDC = CreateCompatibleDC(NULL);
	if (hDC)
	{
		DrawText(hDC, m_ItemArray[iToolTipIndex].GetText(), -1, &ResultRect, DT_NOPREFIX|DT_CALCRECT);
		DeleteDC(hDC);
	}
	if (ResultRect.right > rect.right)
	{
		TOOLTIPINITPARAM ttip;
		ttip.hWndParent = GetParent(m_hWnd);
		ttip.iSBWidth = m_nSBWidth;
		ttip.dwID = iToolTipIndex;
		ttip.hWndNotify = m_hWnd;
		ttip.tszCaption = GetSelText();
		CFlexToolTip::UpdateToolTipParam(ttip);
	}

	Invalidate();
}

void CFlexListBox::Notify(int code)
{
	if (!m_hWndNotify)
		return;

	SendMessage(m_hWndNotify, WM_FLEXLISTBOX,
		(WPARAM)code, (LPARAM)(LPVOID)this);
}

void CFlexListBox::SetColors(COLORREF text, COLORREF bk, COLORREF seltext, COLORREF selbk, COLORREF fill, COLORREF line)
{
	m_rgbText = text;
	m_rgbBk = bk;
	m_rgbSelText = seltext;
	m_rgbSelBk = selbk;
	m_rgbFill = fill;
	m_rgbLine = line;
	Invalidate();
}

void CFlexListBox::SetVertSB(BOOL bSet)
{
	if (bEq(bSet, m_bVertSB))
		return;

	m_bVertSB = bSet;

	if (m_hWnd == NULL)
		return;

	SetVertSB();
}

void CFlexListBox::SetVertSB()
{
	if (m_bVertSB)
	{
		SetSBValues();
		SIZE client = GetClientSize();
		SetWindowPos(m_VertSB.m_hWnd, NULL, client.cx - m_nSBWidth - 1, 0, m_nSBWidth, client.cy - 1, SWP_NOZORDER);
	}

	ShowWindow(m_VertSB.m_hWnd, m_bVertSB ? SW_SHOW : SW_HIDE);
}

void CFlexListBox::SetSBValues()
{
	if (m_hWnd == NULL)
		return;

	SIZE client = GetClientSize();
	int fit = client.cy / m_nTextHeight;
	m_VertSB.SetValues(0, m_ItemArray.GetSize(), fit, m_nTopIndex);
}

LPCTSTR CFlexListBox::GetSelText()
{
	if (m_nSelItem < 0 || m_nSelItem >= m_ItemArray.GetSize())
		return NULL;

	return m_ItemArray[m_nSelItem].GetText();
}

int CFlexListBox::GetSel()
{
	return m_nSelItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexlistbox.h ===
//-----------------------------------------------------------------------------
// File: flexlistbox.h
//
// Desc: Implements a list box control that can display a list of text strings,
//       each can be selected by mouse.  The class CFlexListBox is derived from
//       CFlexWnd.  It is used by the class CFlexComboBox when it needs to
//       expand to show the list of choices.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __FLEXLISTBOX_H__
#define __FLEXLISTBOX_H__


#include "flexscrollbar.h"


#define FLBF_INTEGRALHEIGHT		0x00000001

#define FLBF_DEFAULT (FLBF_INTEGRALHEIGHT)

enum {
	FLBN_SEL,
	FLBN_FINALSEL,
	FLBN_CANCEL
};

struct FLEXLISTBOXCREATESTRUCT {
	DWORD dwSize;
	DWORD dwFlags;
	HWND hWndParent;
	HWND hWndNotify;
	BOOL bVisible;
	RECT rect;
	HFONT hFont;
	COLORREF rgbText, rgbBk, rgbSelText, rgbSelBk, rgbFill, rgbLine;
	int nSBWidth;
};

struct FLEXLISTBOXITEM {
	FLEXLISTBOXITEM() : pszText(NULL), nID(-1), pData(NULL), bSelected(FALSE) {}
	FLEXLISTBOXITEM(const FLEXLISTBOXITEM &i) {nID = i.nID; pData = i.pData; bSelected = i.bSelected; SetText(i.GetText());}
	~FLEXLISTBOXITEM() {cleartext();}
	void SetText(LPCTSTR str) {cleartext(); pszText = _tcsdup(str);}
	LPCTSTR GetText() const {return pszText;}
	int nID;
	void *pData;
	BOOL bSelected;
private:
	void cleartext() {if (pszText) free(pszText); pszText = NULL;}
	LPTSTR pszText;	// allocated
};


class CFlexListBox : public CFlexWnd
{
public:
	CFlexListBox();
	~CFlexListBox();

	// creation
	BOOL Create(FLEXLISTBOXCREATESTRUCT *);
	BOOL CreateForSingleSel(FLEXLISTBOXCREATESTRUCT *);

	// cosmetics
	void SetFont(HFONT hFont);
	void SetColors(COLORREF text, COLORREF bk, COLORREF seltext, COLORREF selbk, COLORREF fill, COLORREF line);

	// setup
	int AddString(LPCTSTR);	// returns index

	// interaction
	void SelectAndShowSingleItem(int i, BOOL bScroll = TRUE);
	void SetSel(int i) {SelectAndShowSingleItem(i, FALSE);}
	void StartSel();

	LPCTSTR GetSelText();
	int GetSel();

protected:
	virtual void OnPaint(HDC hDC);
	virtual LRESULT WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	virtual void OnWheel(POINT point, WPARAM wParam);

private:
	HWND m_hWndNotify;

	CArray<FLEXLISTBOXITEM, FLEXLISTBOXITEM &> m_ItemArray;

	COLORREF m_rgbText, m_rgbBk, m_rgbSelText, m_rgbSelBk, m_rgbFill, m_rgbLine;
	HFONT m_hFont;
	int m_nSBWidth;

	int m_nTextHeight;

	DWORD m_dwFlags;

	int m_nSelItem;
	int m_nTopIndex;
		
	void Calc();
	void SetVertSB(BOOL);
	void SetVertSB();
	void SetSBValues();

	void InternalPaint(HDC hDC);
	
	void Notify(int code);

	POINT m_point;
	BOOL m_bOpenClick;  // True when user click the combobox to open the listbox. False after that button up msg is processed.
	BOOL m_bCapture;
	BOOL m_bDragging;

	CFlexScrollBar m_VertSB;
	BOOL m_bVertSB;
};


CFlexListBox *CreateFlexListBox(FLEXLISTBOXCREATESTRUCT *pcs);


#endif //__FLEXLISTBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexmsgbox.h ===
//-----------------------------------------------------------------------------
// File: flexMsgBox.h
//
// Desc: Implements a message box control similar to Windows message box
//       without the button.  CFlexMsgBox is derived from CFlexWnd.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __FLEXMsgBox_H__
#define __FLEXMsgBox_H__

class CFlexMsgBox : public CFlexWnd
{
	LPTSTR m_tszText;  // Text string of the message
	COLORREF m_rgbText, m_rgbBk, m_rgbSelText, m_rgbSelBk, m_rgbFill, m_rgbLine;
	HFONT m_hFont;
	BOOL m_bSent;

	HWND m_hWndNotify;

	void SetRect();
	void InternalPaint(HDC hDC);

	RECT GetRect(const RECT &);
	RECT GetRect();

	void Notify(int code);

public:
	CFlexMsgBox();
	virtual ~CFlexMsgBox();

	HWND Create(HWND hParent, const RECT &rect, BOOL bVisible);

	void SetNotify(HWND hWnd) { m_hWndNotify = hWnd; }
	void SetText(LPCTSTR tszText);

	// cosmetics
	void SetFont(HFONT hFont);
	void SetColors(COLORREF text, COLORREF bk, COLORREF seltext, COLORREF selbk, COLORREF fill, COLORREF line);

	virtual void OnPaint(HDC hDC);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexmsg.h ===
//-----------------------------------------------------------------------------
// File: flexmsg.h
//
// Desc: Contains definitions of private messages used by the UI.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __FLEXMSG_H__
#define __FLEXMSG_H__


#define WM_CFGUIRESET (WM_USER + 6)

#ifndef WM_FLEXMSGBASE
#define WM_FLEXMSGBASE    (WM_USER + 7)
#endif


#define WM_GETFLEXWND     (WM_FLEXMSGBASE + 0)
#define WM_FLEXTREENOTIFY (WM_FLEXMSGBASE + 1)
#define WM_FLEXVSCROLL    (WM_FLEXMSGBASE + 2)
#define WM_FLEXHSCROLL    (WM_FLEXMSGBASE + 3)
#define WM_FLEXLISTBOX    (WM_FLEXMSGBASE + 4)
#define WM_FLEXCOMBOBOX   (WM_FLEXMSGBASE + 5)
#define WM_FLEXCHECKBOX   (WM_FLEXMSGBASE + 6)
#define WM_DIRENDER       (WM_FLEXMSGBASE + 7)
#define WM_UNHIGHLIGHT    (WM_FLEXMSGBASE + 8)

#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL                   0x020A
#endif


#endif //__FLEXMSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexscrollbar.h ===
//-----------------------------------------------------------------------------
// File: flexscrollbar.h
//
// Desc: Implements CFlexScrollBar (derived from CFlexWnd), a scroll bar
//       control similar to a Windows scroll bar.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __FLEXSCROLLBAR_H__
#define __FLEXSCROLLBAR_H__


#include "flexwnd.h"


#define FSBF_HORZ	0
#define FSBF_VERT	1

struct FLEXSCROLLBARCREATESTRUCT {
	DWORD dwSize;
	DWORD dwFlags;
	int min, max, page, pos;
	HWND hWndParent;
	HWND hWndNotify;
	RECT rect;
	BOOL bVisible;
};

class CFlexScrollBar : public CFlexWnd
{
public:
	CFlexScrollBar();
	~CFlexScrollBar();

	BOOL Create(FLEXSCROLLBARCREATESTRUCT *);

	void SetColors(COLORREF bk, COLORREF fill, COLORREF line);

	void SetValues(int, int, int, int);
	void SetValues(int min, int max, int page) {SetRange(min, max, page);}
	void SetValues(int min, int max) {SetRange(min, max);}

	void SetRange(int min, int max, int page) {SetValues(min, max, page, GetPos());}
	void SetRange(int min, int max) {SetRange(min, max, GetPage());}

	void SetMin(int v) {SetValues(v, GetMax(), GetPage(), GetPos());}
	void SetMax(int v) {SetValues(GetMin(), v, GetPage(), GetPos());}
	void SetPage(int v) {SetValues(GetMin(), GetMax(), v, GetPos());}
	void SetPos(int v) {SetValues(GetMin(), GetMax(), GetPage(), v);}

	int GetMin() {return m_nMin;}
	int GetMax() {return m_nMax;}
	int GetPage() {return m_nPage;}
	int GetPos() {return m_nPos;}

	int GetThumbPos() {return m_bDragging ? m_nThumbPos : -1;}

	void AdjustPos(int adj, BOOL bForceCalc = FALSE);

protected:
	virtual void OnPaint(HDC hDC);
	virtual LRESULT WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
	int m_nMin, m_nMax, m_nPage, m_nPos;
	BOOL m_bVert;
	HWND m_hWndNotify;

	COLORREF m_rgbBk, m_rgbFill, m_rgbLine;

	// ui rects...  calced by Calc
	RECT m_rectLineUp;
	RECT m_rectPageUp;
	RECT m_rectTrack;
	RECT m_rectThumb;
	RECT m_rectPageDown;
	RECT m_rectLineDown;

	BOOL Calc();
	BOOL FailCalc(BOOL);
	BOOL m_bValid;  // true only when we have been created and hav valid values
	                // and calc has been called and returned successfully.

	void InternalPaint(HDC hDC);
	
	POINT m_point, m_startpoint;
	int m_nThumbPos, m_nPreDragPos;
	int m_code;
	int m_startcode;
	BOOL m_bCapture;
	BOOL m_bDragging;

	int HitTest(POINT point);
	void Notify(int code);

	int GetLineAdjust();
	int GetPageAdjust();
};


CFlexScrollBar *CreateFlexScrollBar(FLEXSCROLLBARCREATESTRUCT *pcs);


#endif //__FLEXSCROLLBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexmsgbox.cpp ===
//-----------------------------------------------------------------------------
// File: flexMsgBox.cpp
//
// Desc: Implements a message box control similar to Windows message box
//       without the button.  CFlexMsgBox is derived from CFlexWnd.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"

CFlexMsgBox::CFlexMsgBox() :
	m_hWndNotify(NULL),
	m_rgbText(RGB(255,255,255)),
	m_rgbBk(RGB(0,0,0)),
	m_rgbSelText(RGB(0,0,255)),
	m_rgbSelBk(RGB(0,0,0)),
	m_rgbFill(RGB(0,0,255)),
	m_rgbLine(RGB(0,255,255)),
	m_hFont(NULL),
	m_tszText(NULL)
{
}

CFlexMsgBox::~CFlexMsgBox()
{
	delete[] m_tszText;
}

HWND CFlexMsgBox::Create(HWND hParent, const RECT &rect, BOOL bVisible)
{
	m_bSent = FALSE;
	return CFlexWnd::Create(hParent, rect, bVisible);
}

void CFlexMsgBox::SetText(LPCTSTR tszText)
{
	LPTSTR tszTempText = NULL;

	if (tszText)
	{
		tszTempText = new TCHAR[_tcslen(tszText) + 1];
		if (!tszTempText) return;
		_tcscpy(tszTempText, tszText);
	}

	delete[] m_tszText;
	m_tszText = tszTempText;
}

void CFlexMsgBox::SetFont(HFONT hFont)
{
	m_hFont = hFont;

	if (m_hWnd == NULL)
		return;

	Invalidate();
}

void CFlexMsgBox::SetColors(COLORREF text, COLORREF bk, COLORREF seltext, COLORREF selbk, COLORREF fill, COLORREF line)
{
	m_rgbText = text;
	m_rgbBk = bk;
	m_rgbSelText = seltext;
	m_rgbSelBk = selbk;
	m_rgbFill = fill;
	m_rgbLine = line;
	Invalidate();
}

void CFlexMsgBox::SetRect()
{
	if (m_hWnd == NULL)
		return;

	RECT rect = GetRect();
	SetWindowPos(m_hWnd, NULL, rect.left, rect.top, rect.right, rect.bottom, SWP_NOZORDER | SWP_NOMOVE);
}

RECT CFlexMsgBox::GetRect(const RECT &rect)
{
	int h = GetTextHeight(m_hFont);
	RECT ret = {rect.left, rect.top, rect.right, rect.top + h + 2};
	return ret;
}

RECT CFlexMsgBox::GetRect()
{
	RECT rect;
	GetClientRect(&rect);
	return GetRect(rect);
}

void CFlexMsgBox::OnPaint(HDC hDC)
{
	HDC hBDC = NULL, hODC = NULL;
	CBitmap *pbm = NULL;

	if (!InRenderMode())
	{
		hODC = hDC;
		pbm = CBitmap::Create(GetClientSize(), RGB(0,0,0), hDC);
		if (pbm != NULL)
		{
			hBDC = pbm->BeginPaintInto();
			if (hBDC != NULL)
			{
				hDC = hBDC;
			}
		}
	}

	InternalPaint(hDC);

	if (!InRenderMode())
	{
		if (pbm != NULL)
		{
			if (hBDC != NULL)
			{
				pbm->EndPaintInto(hBDC);
				pbm->Draw(hODC);
			}
			delete pbm;
		}
	}

	// Post reset message to config window now that the msg window is shown, if
	// we haven't done so.
	if (!m_bSent)
	{
		HWND hParentWnd = GetParent(m_hWnd);
		PostMessage(hParentWnd, WM_CFGUIRESET, 0, 0);
	}
	// Flag it that we've sent the message.
	m_bSent = TRUE;
}

void CFlexMsgBox::InternalPaint(HDC hDC)
{
	HGDIOBJ hBrush = (HGDIOBJ)CreateSolidBrush(m_rgbBk);
	if (hBrush != NULL)
	{
		HGDIOBJ hOldBrush = SelectObject(hDC, hBrush);

		// Create pen for check box
		HGDIOBJ hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, m_rgbLine);
		if (hPen != NULL)
		{
			HGDIOBJ hOldPen = SelectObject(hDC, hPen);

			// Erase the background and also draw border
			RECT client;
			GetClientRect(&client);
			Rectangle(hDC, client.left, client.top, client.right, client.bottom);

			InflateRect(&client, -1, -1);

//			SetBkMode(hDC, TRANSPARENT);

			// Draw the message text
			SetTextColor(hDC, m_rgbText);
			SetBkColor(hDC, m_rgbBk);
			DrawText(hDC, m_tszText, -1, &client, DT_CENTER|DT_VCENTER|DT_NOPREFIX|DT_SINGLELINE);

			SelectObject(hDC, hOldPen);
			DeleteObject(hPen);
		}

		SelectObject(hDC, hOldBrush);
		DeleteObject(hBrush);
	}
}

void CFlexMsgBox::Notify(int code)
{
	if (!m_hWndNotify)
		return;

	PostMessage(m_hWndNotify, WM_FLEXCHECKBOX,
		(WPARAM)code, (LPARAM)(LPVOID)this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexscrollbar.cpp ===
//-----------------------------------------------------------------------------
// File: flexscrollbar.cpp
//
// Desc: Implements CFlexScrollBar (derived from CFlexWnd), a scroll bar
//       control similar to a Windows scroll bar.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


CFlexScrollBar::CFlexScrollBar() :
	m_nMin(0),
	m_nMax(0),
	m_nPage(25),
	m_nPos(25),
	m_bVert(TRUE),
	m_hWndNotify(NULL),
	m_bValid(FALSE),
	m_bCapture(FALSE),
	m_bDragging(FALSE),
	m_code(SB_ENDSCROLL),
	m_rgbBk(RGB(0,0,0)),
	m_rgbFill(RGB(0,0,255)),
	m_rgbLine(RGB(0,255,255))
{
}

CFlexScrollBar::~CFlexScrollBar()
{
}

CFlexScrollBar *CreateFlexScrollBar(FLEXSCROLLBARCREATESTRUCT *pcs)
{
	CFlexScrollBar *psb = new CFlexScrollBar;
	
	if (psb && psb->Create(pcs))
		return psb;
	
	delete psb;
	return NULL;
}

BOOL CFlexScrollBar::Create(FLEXSCROLLBARCREATESTRUCT *pcs)
{
	if (this == NULL)
		return FALSE;

	if (pcs == NULL)
		return FALSE;

	if (pcs->dwSize != sizeof(FLEXSCROLLBARCREATESTRUCT))
		return FALSE;

	if (pcs->min > pcs->max)
		return FALSE;

	int range = pcs->max - pcs->min;

	if (pcs->page > range)
		return FALSE;

	m_bVert = ( pcs->dwFlags & FSBF_VERT ) == FSBF_VERT;

	SetValues(pcs->min, pcs->max, pcs->page, pcs->pos);

	m_hWndNotify = pcs->hWndNotify ? pcs->hWndNotify : pcs->hWndParent;

	if (!CFlexWnd::Create(pcs->hWndParent, pcs->rect, pcs->bVisible))
		return FALSE;

	Calc();

	// TODO:  make sure that creation sends no notifications.
	// all initial notifications should be sent here.

	return TRUE;
}

int CFlexScrollBar::GetLineAdjust()
{
	return 1;
}

int CFlexScrollBar::GetPageAdjust()
{
	return m_nPage > 1 ? m_nPage - 1 : 1;
}

void CFlexScrollBar::AdjustPos(int adj, BOOL bForceCalc)
{
	int old = m_nPos;

	m_nPos += adj;

	if (m_nPos < m_nMin)
		m_nPos = m_nMin;
	if (m_nPos > m_nMax - m_nPage)
		m_nPos = m_nMax - m_nPage;

	if (m_nPos == old && !bForceCalc)
		return;

	if (Calc())
		Invalidate();
}

BOOL CFlexScrollBar::FailCalc(BOOL bOldValid)
{
	m_bValid = FALSE;
	if (bOldValid)
		Invalidate();
	return m_bValid;
}

BOOL CFlexScrollBar::Calc()
{
	BOOL bOldValid = m_bValid;
#define FAIL return FailCalc(bOldValid)

	if (!m_hWnd)
		FAIL;

	SRECT zero;
	m_rectLineUp = zero;
	m_rectPageUp = zero;
	m_rectTrack = zero;
	m_rectThumb = zero;
	m_rectPageDown = zero;
	m_rectLineDown = zero;

	SPOINT size = GetClientSize();

	int ord = m_bVert ? 1 : 0;
	int nord = m_bVert ? 0 : 1;
	int length = size.a[ord];
	int width = size.a[nord];
	int arrowlen = width;

	if (width < 1 || length < 2)
		FAIL;

	int tracklen = length - arrowlen * 2;
	int trackofs = arrowlen;

	BOOL bOverlappingArrows = tracklen < -1;
	int overlap = !bOverlappingArrows ? 0 : -tracklen;

	SRECT up, down, track, thumb, temp;

	if (overlap > 1)
	{
		int mid = length / 2;
		up.lr.a[nord] = width;
		up.lr.a[ord] = mid;
		down.ul.a[ord] = mid;
		down.lr.a[ord] = length;
		down.lr.a[nord] = width;
		m_rectLineUp = up;
		m_rectLineDown = down;
		return m_bValid = TRUE;
	}

	up.lr.a[nord] = width;
	up.lr.a[ord] = arrowlen;
	down.lr.a[nord] = width;
	down.ul.a[ord] = length - arrowlen;
	down.lr.a[ord] = length;
	m_rectLineUp = up;
	m_rectLineDown = down;

	int tmin = up.lr.a[ord];
	int tmax = down.ul.a[ord];
	int trange = tmax - tmin;
	int range = m_nMax - m_nMin;
	assert(trange > 0);
	if (!(range > 0) || !(trange > 0))
		return m_bValid = TRUE;

	track.ul.a[ord] = tmin;
	track.lr.a[nord] = width;
	track.lr.a[ord] = tmax;
	m_rectTrack = track;

	const int minthumblen = 3;
	int thumblen = MulDiv(m_nPage, trange, range);
	if (thumblen < minthumblen)
		thumblen = minthumblen;

	int thumbrange = trange - thumblen /*+ 1*/;
	int pagerange = range - m_nPage;
	if (!(pagerange > 1) || !(thumbrange > 1))
		return m_bValid = TRUE;
	int logpos = m_bDragging ? m_nPreDragPos : m_nPos;
	int thumbpos = MulDiv(logpos - m_nMin, thumbrange, pagerange) + tmin;
	if (m_bDragging)
	{
		SPOINT rp = m_point, rs = m_startpoint;
		int rdelta = rp.a[ord] - rs.a[ord];
		thumbpos += rdelta;
		if (thumbpos < tmin)
			thumbpos = tmin;
		if (thumbpos > tmax - thumblen)
			thumbpos = tmax - thumblen;
		m_nThumbPos = MulDiv(thumbpos - tmin, pagerange, thumbrange) + m_nMin;
		if (m_nThumbPos < m_nMin)
			m_nThumbPos = m_nMin;
		if (m_nThumbPos > m_nMax - m_nPage)
			m_nThumbPos = m_nMax - m_nPage;
	}

	thumb.ul.a[ord] = thumbpos;
	thumb.lr.a[nord] = width;
	thumb.lr.a[ord] = thumbpos + thumblen;
	m_rectThumb = thumb;

	temp = track;
	temp.lr.a[ord] = thumb.ul.a[ord];
	if (temp.lr.a[ord] > temp.ul.a[ord])
		m_rectPageUp = temp;

	temp = track;
	temp.ul.a[ord] = thumb.lr.a[ord];
	if (temp.lr.a[ord] > temp.ul.a[ord])
		m_rectPageDown = temp;

	return m_bValid = TRUE;
#undef FAIL
}

void CFlexScrollBar::SetValues(int min, int max, int page, int pos)
{
	m_nMin = min < max ? min : max;
	m_nMax = max > min ? max : min;
	m_nPage = page;
	AdjustPos(pos - m_nPos, TRUE);
}

static BOOL UseRect(const RECT &rect)
{
	if (rect.left >= rect.right || rect.bottom <= rect.top)
		return FALSE;
	return TRUE;
}

static void Rectangle(HDC hDC, RECT rect)
{
	if (!UseRect(rect))
		return;

	Rectangle(hDC, rect.left, rect.top, rect.right, rect.bottom);
}

void CFlexScrollBar::OnPaint(HDC hDC)
{
	HDC hBDC = NULL, hODC = NULL;
	CBitmap *pbm = NULL;

	if (!InRenderMode())
	{
		hODC = hDC;
		pbm = CBitmap::Create(GetClientSize(), RGB(0,0,0), hDC);
		if (pbm != NULL)
		{
			hBDC = pbm->BeginPaintInto();
			if (hBDC != NULL)
			{
				hDC = hBDC;
			}
		}
	}

	InternalPaint(hDC);

	if (!InRenderMode())
	{
		if (pbm != NULL)
		{
			if (hBDC != NULL)
			{
				pbm->EndPaintInto(hBDC);
				pbm->Draw(hODC);
			}
			delete pbm;
		}
	}
}

void CFlexScrollBar::InternalPaint(HDC hDC)
{
	HGDIOBJ hPen, hOldPen, hBrush, hOldBrush;
	hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, m_rgbBk);
	if (hPen != NULL)
	{
		hOldPen = SelectObject(hDC, hPen),
		hOldBrush = SelectObject(hDC, GetStockObject(BLACK_BRUSH));

		Rectangle(hDC, m_rectPageUp);
		Rectangle(hDC, m_rectPageDown);
		Rectangle(hDC, m_rectLineUp);
		Rectangle(hDC, m_rectLineDown);

		SelectObject(hDC, hOldPen);
		DeleteObject(hPen);

		hBrush = (HGDIOBJ)CreateSolidBrush(m_rgbFill);
		if (hBrush != NULL)
		{
			SelectObject(hDC, (HGDIOBJ)hBrush);

			hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, m_rgbFill);
			if (hPen != NULL)
			{
				SelectObject(hDC, hPen);

				Rectangle(hDC, m_rectThumb);

				SelectObject(hDC, hOldPen);
				DeleteObject(hPen);
			}

			hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, m_rgbLine);
			if (hPen != NULL)
			{
				SelectObject(hDC, hPen);

				// draw the two arrows for this scrollbar
				for (int i = 0; i < 2; i++)
					DrawArrow(hDC, i ? m_rectLineUp : m_rectLineDown, m_bVert, i);

	#if 0
				// draw the two arrows for this scrollbar
				for (int i = 0; i < 2; i++)
				{
					const RECT &rect = i == 0 ? m_rectLineUp : m_rectLineDown;
					SRECT srect = rect;
					srect.right--;
					srect.bottom--;
					int ord = m_bVert ? 1 : 0;
					int nord = m_bVert ? 0 : 1;
					SPOINT p(i ? srect.lr : srect.ul), b(i ? srect.ul : srect.lr);
					b.a[ord] += 2 * i - 1;
					SPOINT t = p;
					t.a[nord] = (p.a[nord] + b.a[nord]) / 2;
					SPOINT u;
					u.a[ord] = b.a[ord];
					u.a[nord] = p.a[nord];
					POINT poly[] = { {t.x, t.y}, {u.x, u.y}, {b.x, b.y} };
					Polygon(hDC, poly, 3);
				}
	#endif

				SelectObject(hDC, hOldPen);
				DeleteObject(hPen);
			}
		
			SelectObject(hDC, hOldBrush);
			DeleteObject(hBrush);
		}
	}
}

BOOL InRect(const RECT &rect, POINT point)
{
	return UseRect(rect) && PtInRect(&rect, point);
}

LRESULT CFlexScrollBar::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
		case WM_SIZE:
			Calc();
			Invalidate();
			return 0;

		// make sure flexwnd doesn't do ANYTHING with our mouse messages
		case WM_MOUSEMOVE:
		case WM_LBUTTONUP:
		case WM_LBUTTONDOWN:
		case WM_RBUTTONUP:
		case WM_RBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
		case WM_RBUTTONDBLCLK:
		{
			POINT point = {int(signed short(LOWORD(lParam))), int(signed short(HIWORD(lParam)))};
			m_point = point;
			m_code = HitTest(point);
		}
		case WM_TIMER:
		case WM_CAPTURECHANGED:
			break;
		default:
			return CFlexWnd::WndProc(hWnd, msg, wParam, lParam);
	}

	switch (msg)
	{
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			if (m_code == SB_ENDSCROLL)
				goto endscroll;
			if (m_code == SB_THUMBTRACK)
				m_bDragging = TRUE;
			else
				SetTimer(m_hWnd, 1, 500, NULL);
			m_startcode = m_code;
			m_startpoint = m_point;
			m_nPreDragPos = m_nPos;
			m_bCapture = TRUE;
			SetCapture();
			if (!m_bDragging)
				Notify(m_code);
			break;

		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			if (!m_bDragging)
				break;
			if (Calc())
			{
				Invalidate();
				// Force repaint the updated scrollbar position.  If we don't do this,
				// the WM_PAINT message will be pre-empted by the WM_FLEXVSCROLL messages.
				// Sometimes this happens during the entire duration of draggin the scroll
				// bar.  The result is that the scroll bar does not get updated when
				// dragging.
				SendMessage(m_hWnd, WM_PAINT, 0, 0);
			}
			Notify(m_startcode);
			break;

		case WM_TIMER:
			if (m_bCapture) switch (wParam)
			{
				case 1:
					KillTimer(m_hWnd, 1);
					SetTimer(m_hWnd, 2, 50, NULL);
				case 2:
					if (m_bDragging)
						break;
					if (m_code == m_startcode)
						Notify(m_code);
					break;
			}
			break;
	}

	switch (msg)
	{
		case WM_LBUTTONUP:
		case WM_CAPTURECHANGED:
		endscroll:
			if (m_bCapture)
			{
				m_bCapture = FALSE;
				KillTimer(m_hWnd, 1);
				KillTimer(m_hWnd, 2);
				ReleaseCapture();
				if (m_bDragging)
					Notify(SB_THUMBPOSITION);
				BOOL bWasDragging = m_bDragging;
				m_bDragging = FALSE;
				if (bWasDragging)
				{
					if (Calc())
						Invalidate();
				}
				Notify(SB_ENDSCROLL);
			}
			break;
	}

	return 0;
}

void CFlexScrollBar::Notify(int code)
{
	if (!m_hWndNotify)
		return;

	SendMessage(m_hWndNotify, m_bVert ? WM_FLEXVSCROLL : WM_FLEXHSCROLL,
		(WPARAM)code, (LPARAM)(LPVOID)this);
}

int CFlexScrollBar::HitTest(POINT point)
{
	if (InRect(m_rectLineUp, point))
		return SB_LINEUP;
	else if (InRect(m_rectLineDown, point))
		return SB_LINEDOWN;
	else if (InRect(m_rectThumb, point))
		return SB_THUMBTRACK;
	else if (InRect(m_rectPageUp, point))
		return SB_PAGEUP;
	else if (InRect(m_rectPageDown, point))
		return SB_PAGEDOWN;
	else
		return SB_ENDSCROLL;
}

void CFlexScrollBar::SetColors(COLORREF bk, COLORREF fill, COLORREF line)
{
	m_rgbBk = bk;
	m_rgbFill = fill;
	m_rgbLine = line;
	Invalidate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flextooltip.cpp ===
//-----------------------------------------------------------------------------
// File: flextooltip.cpp
//
// Desc: Implements a tooltip class that displays a text string as a tooltip.
//       CFlexTooltip (derived from CFlexWnd) is used throughout the UI when
//       a control needs to have a tooltip.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"

UINT_PTR CFlexToolTip::s_uiTimerID;
DWORD CFlexToolTip::s_dwLastTimeStamp;  // Last time stamp for mouse move
TOOLTIPINIT CFlexToolTip::s_TTParam;  // Parameters to initialize the tooltip

// TimerFunc is called periodically.  It checks if a tooltip should be displayed.
// If a window has indicated a need for tooltip, TimerFunc will initialize
// for displaying here.  CFlexWnd will do the actual displaying, since
// it has to monitor WM_MOUSEMOVE message to be sure that tooltips only
// display after a period of inactivity.
void CALLBACK CFlexToolTip::TimerFunc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
	// If it has been one sec already since last mouse move, display the tooltip
	if (dwTime > CFlexWnd::s_dwLastMouseMove + 1000)
	{
		if (s_TTParam.hWndParent && !CFlexWnd::s_ToolTip.IsEnabled())
		{
			// Check if the mouse cursor is outside the window.  If so, don't activate tooltip.
			POINT pt;
			RECT rect;
			GetCursorPos(&pt);
			ScreenToClient(s_TTParam.hWndParent, &pt);
			::GetClientRect(s_TTParam.hWndParent, &rect);
			if (!PtInRect(&rect, pt))
				return;

			SetParent(CFlexWnd::s_ToolTip.m_hWnd, s_TTParam.hWndParent);
			CFlexWnd::s_ToolTip.SetSBWidth(s_TTParam.iSBWidth);
			CFlexWnd::s_ToolTip.SetID(s_TTParam.dwID);
			CFlexWnd::s_ToolTip.SetNotifyWindow(s_TTParam.hWndNotify);
			CFlexWnd::s_ToolTip.SetText(s_TTParam.tszCaption);
			CFlexWnd::s_ToolTip.SetEnable(TRUE);
		}
	}
}

// We use the constructor and destructor to load and unload WINMM.DLL since the UI will only create this once.

CFlexToolTip::CFlexToolTip() :
	m_tszText(NULL), m_hNotifyWnd(NULL), m_dwID(0), m_bEnabled(FALSE)
{
}

CFlexToolTip::~CFlexToolTip()
{
	delete[] m_tszText;
}

HWND CFlexToolTip::Create(HWND hParent, const RECT &rect, BOOL bVisible, int iSBWidth)
{
	m_iSBWidth = iSBWidth;
	return CFlexWnd::Create(hParent, rect, bVisible);
}

// Set the tooltip position. pt is the upper-left point in screen coordinates.
// bOffsetForMouseCursor is TRUE if the tooltip is to be displayed next to mouse cursor.  SetPosition()
// will offset the position of the tooltip so that the cursor doesn't block the text of the tooltip.
void CFlexToolTip::SetPosition(POINT pt, BOOL bOffsetForMouseCursor)
{
	// Check the top, right and bottom edges.  If they are outside the main config window
	RECT rc;
	RECT cliprc;
	RECT parentrc;
	GetWindowRect(GetParent(), &parentrc);
	GetClientRect(&rc);
	GetWindowRect(GetParent(), &cliprc);
	cliprc.right -= DEFAULTVIEWSBWIDTH*2;
	if (bOffsetForMouseCursor)
	{
		pt.y -= rc.bottom;  // Align the lower left corner to the cursor
		pt.x += 1; pt.y -= 1;  // Offset x and y by 2 pixels so that when the mouse is moved up or right, we don't get over the tooltip window.
	}
	if (pt.y < cliprc.top) pt.y += cliprc.top - pt.y;  // Top
	if (pt.x + rc.right > (cliprc.right - m_iSBWidth)) pt.x += cliprc.right - m_iSBWidth - (pt.x + rc.right);  // Right
	if (pt.y + rc.bottom > cliprc.bottom) pt.y += cliprc.bottom - (pt.y + rc.bottom);  // Bottom
	ScreenToClient(GetParent(), &pt);
	SetWindowPos(m_hWnd, HWND_TOP, pt.x, pt.y, 0, 0, SWP_NOSIZE);
}

void CFlexToolTip::SetText(LPCTSTR tszText, POINT *textpos)
{
	// Figure out window size and position
	RECT rc = {0, 0, 320, 480};  // Only go to half the window width max
	HDC hDC = CreateCompatibleDC(NULL);
	if (hDC != NULL)
	{
		DrawText(hDC, CFlexToolTip::s_TTParam.tszCaption, -1, &rc, DT_CALCRECT);
	//	DrawText(hDC, m_tszText, -1, &rc, DT_CALCRECT);
		SetWindowPos(m_hWnd, HWND_TOP, 0, 0, rc.right, rc.bottom, 0);  // Set window pos as needed by text
		DeleteDC(hDC);
	}

	POINT pt;
	if (textpos)
	{
		pt = *textpos;
		SetPosition(pt, FALSE);
	}
	else
	{
		GetCursorPos(&pt);
		SetPosition(pt);
	}
	SetWindowPos(m_hWnd, HWND_TOP, 0, 0, rc.right, rc.bottom, SWP_NOMOVE);  // Set size
}

void CFlexToolTip::OnClick(POINT point, WPARAM fwKeys, BOOL bLeft)
{
	ClientToScreen(m_hWnd, &point);
	ScreenToClient(m_hNotifyWnd, &point);
	if (bLeft)
		PostMessage(m_hNotifyWnd, WM_LBUTTONDOWN, fwKeys, point.x | (point.y << 16));
	else
		PostMessage(m_hNotifyWnd, WM_RBUTTONDOWN, fwKeys, point.x | (point.y << 16));
}

void CFlexToolTip::OnDoubleClick(POINT point, WPARAM fwKeys, BOOL bLeft)
{
	ClientToScreen(m_hWnd, &point);
	ScreenToClient(m_hNotifyWnd, &point);
	if (bLeft)
		PostMessage(m_hNotifyWnd, WM_LBUTTONDBLCLK, fwKeys, point.x | (point.y << 16));
	else
		PostMessage(m_hNotifyWnd, WM_RBUTTONDBLCLK, fwKeys, point.x | (point.y << 16));
}

void CFlexToolTip::OnPaint(HDC hDC)
{
	HDC hBDC = NULL, hODC = NULL;
	CBitmap *pbm = NULL;

	if (!InRenderMode())
	{
		hODC = hDC;
		pbm = CBitmap::Create(GetClientSize(), RGB(0,0,0), hDC);
		if (pbm != NULL)
		{
			hBDC = pbm->BeginPaintInto();
			if (hBDC != NULL)
			{
				hDC = hBDC;
			}
		}
	}

	InternalPaint(hDC);

	if (!InRenderMode())
	{
		if (pbm != NULL)
		{
			if (hBDC != NULL)
			{
				pbm->EndPaintInto(hBDC);
				pbm->Draw(hODC);
			}
			delete pbm;
		}
	}
}

void CFlexToolTip::InternalPaint(HDC hDC)
{
	HGDIOBJ hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, m_rgbBk);
	if (hPen != NULL)
	{
		HGDIOBJ hOldPen = SelectObject(hDC, hPen);

		HGDIOBJ hBrush = CreateSolidBrush(m_rgbBk);
		if (hBrush != NULL)
		{
			HGDIOBJ hOldBrush = SelectObject(hDC, hBrush);
			RECT rc = {0,0,0,0};

			GetClientRect(&rc);
			DrawText(hDC, CFlexToolTip::s_TTParam.tszCaption, -1, &rc, DT_LEFT);

			SelectObject(hDC, hOldBrush);
			DeleteObject(hBrush);
		}

		SelectObject(hDC, hOldPen);
		DeleteObject(hPen);
	}
}

LRESULT CFlexToolTip::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	return CFlexWnd::WndProc(hWnd, msg, wParam, lParam);
}

LRESULT CFlexToolTip::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	// Create a timer
	CFlexToolTip::s_uiTimerID = SetTimer(m_hWnd, 6, 50, CFlexToolTip::TimerFunc);
	return 0;
}

void CFlexToolTip::OnDestroy()
{
	// Kill the timer
	if (CFlexToolTip::s_uiTimerID)
	{
		KillTimer(m_hWnd, 6);
		CFlexToolTip::s_uiTimerID = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flextooltip.h ===
//-----------------------------------------------------------------------------
// File: flextooltip.h
//
// Desc: Implements a tooltip class that displays a text string as a tooltip.
//       CFlexTooltip (derived from CFlexWnd) is used throughout the UI when
//       a control needs to have a tooltip.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __FLEXTOOLTIP_H__
#define __FLEXTOOLTIP_H__

struct TOOLTIPINIT
{
	HWND hWndParent;
	int iSBWidth;
	DWORD dwID;
	HWND hWndNotify;
	TCHAR tszCaption[MAX_PATH];
};

struct TOOLTIPINITPARAM
{
	HWND hWndParent;
	int iSBWidth;
	DWORD dwID;
	HWND hWndNotify;
	LPCTSTR tszCaption;
};

class CFlexToolTip : public CFlexWnd
{
	LPTSTR m_tszText;
	COLORREF m_rgbText, m_rgbBk, m_rgbSelText, m_rgbSelBk, m_rgbFill, m_rgbLine;
	HWND m_hNotifyWnd;
	DWORD m_dwID;  // Used to store offset when owned by a control
	int m_iSBWidth;  // Width of the owner window's scroll bar.  We cannot obscure the scroll bar.
	BOOL m_bEnabled;  // Whether this is enabled.  If not, we hide the underlying window.

	void InternalPaint(HDC hDC);

public:
	CFlexToolTip();
	virtual ~CFlexToolTip();

	// Statics for show control
	static UINT_PTR s_uiTimerID;
	static DWORD s_dwLastTimeStamp;  // Last time stamp for mouse move
	static TOOLTIPINIT s_TTParam;  // Parameters to initialize the tooltip
	static void SetToolTipParent(HWND hWnd) { s_TTParam.hWndParent = hWnd; }
	static void UpdateToolTipParam(TOOLTIPINITPARAM &TTParam)
	{
		s_TTParam.hWndParent = TTParam.hWndParent;
		s_TTParam.iSBWidth = TTParam.iSBWidth;
		s_TTParam.dwID = TTParam.dwID;
		s_TTParam.hWndNotify = TTParam.hWndNotify;
		if (TTParam.tszCaption)
			lstrcpy((LPTSTR)s_TTParam.tszCaption, TTParam.tszCaption);
		else
			s_TTParam.tszCaption[0] = _T('\0');
	}
	static TOOLTIPINIT &GetTTParam() { return s_TTParam; }
	static void CALLBACK TimerFunc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

	HWND Create(HWND hParent, const RECT &rect, BOOL bVisible, int iSBWidth = 0);

	HWND GetParent() { return ::GetParent(m_hWnd); }

	virtual LRESULT OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual void OnDestroy();

private:
	void SetNotifyWindow(HWND hWnd) { m_hNotifyWnd = hWnd; }
	void SetColors(COLORREF text, COLORREF bk, COLORREF seltext, COLORREF selbk, COLORREF fill, COLORREF line);
	void SetText(LPCTSTR tszText, POINT *textpos = NULL);
	void SetID(DWORD dwID) { m_dwID = dwID; }
	void SetPosition(POINT pt, BOOL bOffsetForMouseCursor = TRUE);
	void SetSBWidth(int iSBWidth) { m_iSBWidth = iSBWidth; }

public:
	DWORD GetID() { return m_dwID; }
	void SetEnable(BOOL bEnable)
	{
		if (m_hWnd)
		{
			if (bEnable && !m_bEnabled)
			{
				ShowWindow(m_hWnd, SW_SHOW);
				Invalidate();
			}
			else if (!bEnable && m_bEnabled)
			{
				ShowWindow(m_hWnd, SW_HIDE);
				Invalidate();
			}
		}
		m_bEnabled = bEnable;
	}
	BOOL IsEnabled() { return m_bEnabled; }

	virtual void OnClick(POINT point, WPARAM fwKeys, BOOL bLeft);
	virtual void OnDoubleClick(POINT point, WPARAM fwKeys, BOOL bLeft);

protected:
	virtual void OnPaint(HDC hDC);
	virtual LRESULT WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\guids.c ===
//-----------------------------------------------------------------------------
// File: guids.c
//
// Desc: Defines INITGUID and includes all headers with GUID definitions.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#define INITGUID

#include <dinput.h>
#include <dinputd.h>
#include <ddraw.h>
#include <d3d8.h>
#include "ourguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexwnd.h ===
//-----------------------------------------------------------------------------
// File: flexwnd.h
//
// Desc: CFlexWnd is a generic class that encapsulates the functionalities
//       of a window.  All other window classes are derived from CFlexWnd.
//
//       Child classes can have different behavior by overriding the
//       overridable message handlers (OnXXX members).
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __FLEXWND_H__
#define __FLEXWND_H__


#include "flexmsg.h"

class CFlexToolTip;

class CFlexWnd
{
public:
	CFlexWnd();
	~CFlexWnd();

	// class registration
	static void RegisterWndClass(HINSTANCE hInst);
	static void UnregisterWndClass(HINSTANCE hInst);

	// Unhighlight callouts when a click is made elsewhere besides the callouts
	static HWND s_CurrPageHwnd;

	// Tooltip
	static CFlexToolTip s_ToolTip;  // Shared tooltip window object
	static DWORD s_dwLastMouseMove;  // Last GetTickCount() that we have a WM_MOUSEMOVE
	static HWND s_hWndLastMouseMove;  // Last window handle of WM_MOUSEMOVE
	static LPARAM s_PointLastMouseMove;  // Last point of WM_MOUSEMOVE

	// public read-only access to hwnd
	const HWND &m_hWnd;

	// creation
	int DoModal(HWND hParent, int nTemplate, HINSTANCE hInst = NULL);
	int DoModal(HWND hParent, LPCTSTR lpTemplate, HINSTANCE hInst = NULL);
	HWND DoModeless(HWND hParent, int nTemplate, HINSTANCE hInst = NULL);
	HWND DoModeless(HWND hParent, LPCTSTR lpTemplate, HINSTANCE hInst = NULL);
	HWND Create(HWND hParent, LPCTSTR tszName, DWORD dwExStyle, DWORD dwStyle, const RECT &rect, HMENU hMenu = NULL);
	HWND Create(HWND hParent, const RECT &rect, BOOL bVisible);

	// destruction
	void Destroy();

	// operations
	void RenderInto(HDC hDC, int x = 0, int y = 0);
	void Invalidate();

	// information
	SIZE GetClientSize() const;
	void GetClientRect(LPRECT) const;
	static CFlexWnd *GetFlexWnd(HWND hWnd);
	BOOL HasWnd() {return m_hWnd != NULL;}
	static LPCTSTR GetDefaultClassName();
	BOOL IsDialog();
	BOOL InRenderMode();
	void SetReadOnly(BOOL bReadOnly) { m_bReadOnly = bReadOnly; }
	BOOL GetReadOnly() { return m_bReadOnly; }

	// mouse capture
	void SetCapture();
	void ReleaseCapture();

protected:

	// derived operations
	void SetRenderMode(BOOL bRender = TRUE);
	BOOL EndDialog(int);

	// overridable message handlers
	virtual void OnInit() {}
	virtual LRESULT OnCreate(LPCREATESTRUCT lpCreateStruct) {return 0;}
	virtual BOOL OnInitDialog() {return TRUE;}
	virtual void OnTimer(UINT uID) {}
	virtual BOOL OnEraseBkgnd(HDC hDC);
	virtual void OnPaint(HDC hDC) {}
	virtual void OnRender(BOOL bInternalCall = FALSE);
	virtual LRESULT OnCommand(WORD wNotifyCode, WORD wID, HWND hWnd)  {return 0;}
	virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam)  {return 0;}
	virtual void OnMouseOver(POINT point, WPARAM fwKeys) {}
	virtual void OnClick(POINT point, WPARAM fwKeys, BOOL bLeft) {}
	virtual void OnWheel(POINT point, WPARAM wParam) {}
	virtual void OnDoubleClick(POINT point, WPARAM fwKeys, BOOL bLeft) {}
	virtual LRESULT WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	virtual void OnDestroy() {}

private:

	// implementation...

	// information and initialization
	int m_nID;
	HWND m_privhWnd;
	BOOL m_bIsDialog;
	BOOL m_bReadOnly;  // Whether this window is read-only (disabled).
	void SetHWND(HWND hWnd);
	void InitFlexWnd();

	// paint helper (for inserting debug painting)
	virtual void DoOnPaint(HDC hDC);
	
	// render mode
	BOOL m_bRender;
	HDC m_hRenderInto;
	BOOL RenderIntoClipChild(HWND hChild);
	BOOL RenderIntoRenderChild(HWND hChild);

friend static BOOL CALLBACK RenderIntoClipChild(HWND hWnd, LPARAM lParam);
friend static BOOL CALLBACK RenderIntoRenderChild(HWND hWnd, LPARAM lParam);

	// class information
	static void FillWndClass(HINSTANCE hInst);
	static BOOL sm_bWndClassRegistered;
	static WNDCLASSEX sm_WndClass;
	static LPCTSTR sm_tszWndClassName;
	static HINSTANCE sm_hInstance;

friend LRESULT CALLBACK __BaseFlexWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
friend INT_PTR CALLBACK __BaseFlexWndDialogProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
};


#endif //__FLEXWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\iclassfact.cpp ===
//-----------------------------------------------------------------------------
// File: iclassfact.cpp
//
// Desc: Implements the class factory for the UI.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


//QI
STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID* ppv)
{
	//null the put parameter
	*ppv = NULL;

	if ((riid == IID_IUnknown) || (riid == IID_IClassFactory))
	{
		*ppv = this;
		AddRef();
		return S_OK;
	}

	return E_NOINTERFACE;

}



//AddRef
STDMETHODIMP_(ULONG) CFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}


//Release
STDMETHODIMP_(ULONG) CFactory::Release()
{

	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this;
		return 0;
	}

	return m_cRef;
}


//CreateInstance
STDMETHODIMP CFactory::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID *ppv)
{
	HRESULT hr = S_OK;

	//can't aggregate
	if (pUnkOuter != NULL)
	{
		return CLASS_E_NOAGGREGATION;
	}

	//create component
	CDirectInputActionFramework* pDIActionFramework = new CDirectInputActionFramework();
	if (pDIActionFramework == NULL)
	{
		return E_OUTOFMEMORY;
	}

	//get the requested interface
	hr = pDIActionFramework->QueryInterface(riid, ppv);

	//release IUnknown
	pDIActionFramework->Release();
	return hr;

}


//LockServer
STDMETHODIMP CFactory::LockServer(BOOL bLock)
{
	HRESULT hr = S_OK;
	if (bLock)
	{
		InterlockedIncrement(&g_cServerLocks);
	}
	else
	{
		InterlockedDecrement(&g_cServerLocks);
	}

	return hr;
}


//constructor
CFactory::CFactory()
{
	m_cRef = 1;
}


//destructor
CFactory::~CFactory()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flexwnd.cpp ===
//-----------------------------------------------------------------------------
// File: flexwnd.cpp
//
// Desc: CFlexWnd is a generic class that encapsulates the functionalities
//       of a window.  All other window classes are derived from CFlexWnd.
//
//       Child classes can have different behavior by overriding the
//       overridable message handlers (OnXXX members).
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"
#include "typeinfo.h"

BOOL CFlexWnd::sm_bWndClassRegistered = FALSE;
WNDCLASSEX CFlexWnd::sm_WndClass;
LPCTSTR CFlexWnd::sm_tszWndClassName = _T("Microsoft.CFlexWnd.WndClassName");
HINSTANCE CFlexWnd::sm_hInstance = NULL;
CFlexToolTip CFlexWnd::s_ToolTip;  // Shared tooltip window object
DWORD CFlexWnd::s_dwLastMouseMove;  // Last GetTickCount() that we have a WM_MOUSEMOVE
HWND CFlexWnd::s_hWndLastMouseMove;  // Last window handle of WM_MOUSEMOVE
LPARAM CFlexWnd::s_PointLastMouseMove;  // Last point of WM_MOUSEMOVE
HWND CFlexWnd::s_CurrPageHwnd;  // For unhighlighting callouts when a click is made outside of a callout


int NewID()
{
	static int i = 0;
	return ++i;
}

CFlexWnd::CFlexWnd() : m_nID(NewID()),
	m_hWnd(m_privhWnd), m_privhWnd(NULL), m_hRenderInto(NULL),
	m_bIsDialog(FALSE),	m_bRender(FALSE),
	m_bReadOnly(FALSE)
{
}

CFlexWnd::~CFlexWnd()
{
	Destroy();
}

void CFlexWnd::Destroy()
{
	if (m_hWnd != NULL)
		DestroyWindow(m_hWnd);

	assert(m_privhWnd == NULL);
}

BOOL CFlexWnd::IsDialog()
{
	return HasWnd() && m_bIsDialog;
}

void CFlexWnd::OnRender(BOOL bInternalCall)
{
	// if parent is flexwnd and both are in render mode, pass to parent
	if (!m_hWnd)
		return;
	HWND hParent = GetParent(m_hWnd);
	if (!hParent)
		return;
	CFlexWnd *pParent = GetFlexWnd(hParent);
	if (!pParent)
		return;
	if (pParent->InRenderMode() && InRenderMode())
		pParent->OnRender(TRUE);
}

BOOL CFlexWnd::OnEraseBkgnd(HDC hDC)
{
	if (InRenderMode())
		return TRUE;

/*	if (IsDialog())
		return FALSE;*/

	return TRUE;
}

struct GETFLEXWNDSTRUCT {
	int cbSize;
	BOOL bFlexWnd;
	CFlexWnd *pFlexWnd;
};

// This function takes a HWND and returns a pointer to CFlexWnd if the HWND is a window
// created by the UI.
CFlexWnd *CFlexWnd::GetFlexWnd(HWND hWnd)
{
	if (hWnd == NULL)
		return NULL;

	GETFLEXWNDSTRUCT gfws;
	gfws.cbSize = sizeof(gfws);
	gfws.bFlexWnd = FALSE;
	gfws.pFlexWnd = NULL;
	SendMessage(hWnd, WM_GETFLEXWND, 0, (LPARAM)(LPVOID)(FAR GETFLEXWNDSTRUCT *)&gfws);

	if (gfws.bFlexWnd)
		return gfws.pFlexWnd;
	else
		return NULL;
}

// Basic window proc. It simply forward interesting messages to the appropriate handlers (OnXXX).
// If child class defines this function, it should pass unhandled messages to CFlexWnd.
LRESULT CFlexWnd::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
		case WM_GETFLEXWND:
		{
			if ((LPVOID)lParam == NULL)
				break;

			GETFLEXWNDSTRUCT &gfws = *((FAR GETFLEXWNDSTRUCT *)(LPVOID)lParam);

			switch (gfws.cbSize)
			{
				case sizeof(GETFLEXWNDSTRUCT):
					gfws.bFlexWnd = TRUE;
					gfws.pFlexWnd = this;
					return 0;

				default:
					assert(0);
					break;
			}
			break;
		}

		case WM_CREATE:
		{
			LPCREATESTRUCT lpCreateStruct = (LPCREATESTRUCT)lParam;
			
			LRESULT lr = OnCreate(lpCreateStruct);
			
			if (lr != -1)
				OnInit();

			return lr;
		}

		case WM_INITDIALOG:
		{
			BOOL b = OnInitDialog();
			OnInit();
			return b;
		}

		case WM_TIMER:
			OnTimer((UINT)wParam);
			return 0;

		case WM_ERASEBKGND:
			return OnEraseBkgnd((HDC)wParam);

		case WM_PAINT:
		{
			// Check the update rectangle.  If we don't have it, exit immediately.
			if (typeid(*this) == typeid(CDeviceView) && !GetUpdateRect(m_hWnd, NULL, FALSE))
				return 0;
			PAINTSTRUCT ps;
			HDC	hDC = BeginPaint(hWnd, &ps);
			if (InRenderMode())
				OnRender(TRUE);
			else
				DoOnPaint(hDC);
			EndPaint(hWnd, &ps);
			return 0;
		}

		case WM_COMMAND:
		{
			WORD wNotifyCode = HIWORD(wParam);
			WORD wID = LOWORD(wParam);
			HWND hWnd = (HWND)lParam;
			return OnCommand(wNotifyCode, wID, hWnd);
		}

		case WM_NOTIFY:	
			return OnNotify(wParam, lParam);

		case WM_MOUSEMOVE:
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
		case WM_MOUSEWHEEL:
		{
			POINT point = {int(LOWORD(lParam)), int(HIWORD(lParam))};
			switch (msg)
			{
				case WM_MOUSEMOVE: OnMouseOver(point, wParam); break;
				case WM_LBUTTONDOWN: OnClick(point, wParam, TRUE); break;
				case WM_RBUTTONDOWN: OnClick(point, wParam, FALSE); break;
				case WM_LBUTTONDBLCLK: OnDoubleClick(point, wParam, TRUE); break;
				case WM_MOUSEWHEEL:
				{
					// Send wheel msg to the window beneath the cursor
					HWND hWnd = WindowFromPoint(point);
					CFlexWnd *pWnd = NULL;
					if (hWnd)
					{
						pWnd = GetFlexWnd(hWnd);
						if (pWnd)
							pWnd->OnWheel(point, wParam);
						else
							return DefWindowProc(hWnd, msg, wParam, lParam);
					}
					break;
				}
			}
			return 0;
		}

		case WM_DESTROY:
			OnDestroy();
			m_privhWnd = NULL;
			return 0;
	}

	if (!m_bIsDialog)
		return DefWindowProc(hWnd, msg, wParam, lParam);
	else
		return 0;
}
//@@BEGIN_MSINTERNAL
// TODO:  better control id thingy
//@@END_MSINTERNAL
static HMENU windex = 0;

BOOL CFlexWnd::EndDialog(int n)
{
	if (!m_bIsDialog || m_hWnd == NULL)
	{
		assert(0);
		return FALSE;
	}

	return ::EndDialog(m_hWnd, n);
}

int CFlexWnd::DoModal(HWND hParent, int nTemplate, HINSTANCE hInst)
{
	return DoModal(hParent, MAKEINTRESOURCE(nTemplate), hInst);
}

HWND CFlexWnd::DoModeless(HWND hParent, int nTemplate, HINSTANCE hInst)
{
	return DoModeless(hParent, MAKEINTRESOURCE(nTemplate), hInst);
}

int CFlexWnd::DoModal(HWND hParent, LPCTSTR lpTemplate, HINSTANCE hInst)
{
	if (m_hWnd != NULL)
	{
		assert(0);
		return -1;
	}

	if (hInst == NULL)
		hInst = CFlexWnd::sm_hInstance;

	return (int)DialogBoxParam(hInst, lpTemplate, hParent,
		__BaseFlexWndDialogProc, (LPARAM)(void *)this);
}

HWND CFlexWnd::DoModeless(HWND hParent, LPCTSTR lpTemplate, HINSTANCE hInst)
{
	if (m_hWnd != NULL)
	{
		assert(0);
		return NULL;
	}

	if (hInst == NULL)
		hInst = CFlexWnd::sm_hInstance;

	return CreateDialogParam(hInst, lpTemplate, hParent,
		__BaseFlexWndDialogProc, (LPARAM)(void *)this);
}

HWND CFlexWnd::Create(HWND hParent, const RECT &rect, BOOL bVisible)
{
	++(*(LPBYTE*)&windex);
	return Create(hParent, _T("(unnamed)"), 0,
		WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_EX_NOPARENTNOTIFY | (bVisible ? WS_VISIBLE : 0),
		rect, windex);
}

HWND CFlexWnd::Create(HWND hParent, LPCTSTR tszName, DWORD dwExStyle, DWORD dwStyle, const RECT &rect, HMENU hMenu)
{
	HWND hWnd = NULL;

	if (m_hWnd != NULL)
	{
		assert(0);
		return hWnd;
	}

	if (hMenu == NULL && (dwStyle & WS_CHILD))
	{
		++(*(LPBYTE*)&windex);
		hMenu = windex;
	}

	hWnd = CreateWindowEx(
		dwExStyle,
		CFlexWnd::sm_tszWndClassName,
		tszName,
		dwStyle,
		rect.left, rect.top,
		rect.right - rect.left, rect.bottom - rect.top,
		hParent,
		hMenu,
		CFlexWnd::sm_hInstance,
		(void *)this);

	assert(m_hWnd == hWnd);

	return hWnd;
}

void CFlexWnd::SetHWND(HWND hWnd)
{
	assert(m_hWnd == NULL && hWnd != NULL);
	m_privhWnd = hWnd;
	assert(m_hWnd == m_privhWnd);

	InitFlexWnd();
}

void CFlexWnd::InitFlexWnd()
{
	if (!HasWnd())
		return;

	HWND hParent = GetParent(m_hWnd);
	CFlexWnd *pParent = GetFlexWnd(hParent);
	if (pParent && pParent->InRenderMode())
		SetRenderMode();
}

TCHAR sg_tszFlexWndPointerProp[] = _T("CFlexWnd *");

LRESULT CALLBACK __BaseFlexWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	CFlexWnd *pThis = (CFlexWnd *)GetProp(hWnd, sg_tszFlexWndPointerProp);

	if ((msg == WM_MOUSEMOVE || msg == WM_MOUSEWHEEL) && hWnd != CFlexWnd::s_ToolTip.m_hWnd)
	{
		// Filter out the message with same window handle and point.
		// Windows sometimes seems to send us WM_MOUSEMOVE message even though the mouse is not moved.
		if (CFlexWnd::s_hWndLastMouseMove != hWnd || CFlexWnd::s_PointLastMouseMove != lParam)
		{
			CFlexWnd::s_hWndLastMouseMove = hWnd;
			CFlexWnd::s_PointLastMouseMove = lParam;
			CFlexWnd::s_dwLastMouseMove = GetTickCount();  // Get timestamp
			CFlexWnd::s_ToolTip.SetEnable(FALSE);
			CFlexWnd::s_ToolTip.SetToolTipParent(NULL);
		}
	}

	switch (msg)
	{
		case WM_CREATE:
		{
			LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
			if (lpcs == NULL)
				break;

			pThis = (CFlexWnd *)(void *)(lpcs->lpCreateParams);
			assert(sizeof(HANDLE) == sizeof(CFlexWnd *));
			SetProp(hWnd, sg_tszFlexWndPointerProp, (HANDLE)pThis);

			if (pThis != NULL)
			{
				pThis->m_bIsDialog = FALSE;
				pThis->SetHWND(hWnd);
			}
			break;
		}
	}

	if (pThis != NULL)
		return pThis->WndProc(hWnd, msg, wParam, lParam);
	else
		return DefWindowProc(hWnd, msg, wParam, lParam);
}

INT_PTR CALLBACK __BaseFlexWndDialogProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	CFlexWnd *pThis = (CFlexWnd *)GetProp(hWnd, sg_tszFlexWndPointerProp);

	switch (msg)
	{
		case WM_INITDIALOG:
			pThis = (CFlexWnd *)(void *)lParam;
			assert(sizeof(HANDLE) == sizeof(CFlexWnd *));
			SetProp(hWnd, sg_tszFlexWndPointerProp, (HANDLE)pThis);
			if (pThis != NULL)
			{
				pThis->m_bIsDialog = TRUE;
				pThis->SetHWND(hWnd);
			}
			break;
	}
	
	if (pThis != NULL)
		return (BOOL)pThis->WndProc(hWnd, msg, wParam, lParam);
	else
		return FALSE;
}

void CFlexWnd::Invalidate()
{
	if (m_hWnd != NULL)
		InvalidateRect(m_hWnd, NULL, TRUE);
}

SIZE CFlexWnd::GetClientSize() const
{
	RECT rect = {0, 0, 0, 0};
	if (m_hWnd != NULL)
		::GetClientRect(m_hWnd, &rect);
	SIZE size = {
		rect.right - rect.left,
		rect.bottom - rect.top};
	return size;
}

void CFlexWnd::FillWndClass(HINSTANCE hInst)
{
	sm_WndClass.cbSize = sizeof(WNDCLASSEX);
	sm_WndClass.style = CS_DBLCLKS;
	sm_WndClass.lpfnWndProc = __BaseFlexWndProc;
	sm_WndClass.cbClsExtra = 0;
	sm_WndClass.cbWndExtra = sizeof(CFlexWnd *);
	sm_WndClass.hInstance = sm_hInstance = hInst;
	sm_WndClass.hIcon = NULL;
	sm_WndClass.hCursor = NULL;
	sm_WndClass.hbrBackground = NULL;
	sm_WndClass.lpszMenuName = NULL;
	sm_WndClass.lpszClassName = sm_tszWndClassName;
	sm_WndClass.hIconSm = NULL;
}

void CFlexWnd::RegisterWndClass(HINSTANCE hInst)
{
	if (hInst == NULL)
	{
		assert(0);
		return;
	}

	FillWndClass(hInst);
	RegisterClassEx(&sm_WndClass);
	sm_bWndClassRegistered = TRUE;
}

void CFlexWnd::UnregisterWndClass(HINSTANCE hInst)
{
	if (hInst == NULL)
		return;

	UnregisterClass(sm_tszWndClassName, hInst);
	sm_bWndClassRegistered = FALSE;
}

void CFlexWnd::GetClientRect(LPRECT lprect) const
{
	if (lprect == NULL || m_hWnd == NULL)
		return;

	::GetClientRect(m_hWnd, lprect);
}

LPCTSTR CFlexWnd::GetDefaultClassName()
{
	return CFlexWnd::sm_tszWndClassName;
}

void CFlexWnd::SetRenderMode(BOOL bRender)
{
	if (bRender == m_bRender)
		return;

	m_bRender = bRender;
	Invalidate();
}

BOOL CFlexWnd::InRenderMode()
{
	return m_bRender;
}

void EnumChildWindowsZDown(HWND hParent, WNDENUMPROC proc, LPARAM lParam)
{
	if (hParent == NULL || proc == NULL)
		return;

	HWND hWnd = GetWindow(hParent, GW_CHILD);

	while (hWnd != NULL)
	{
		if (!proc(hWnd, lParam))
			break;

		hWnd = GetWindow(hWnd, GW_HWNDNEXT);
	}
}

void EnumSiblingsAbove(HWND hParent, WNDENUMPROC proc, LPARAM lParam)
{
	if (hParent == NULL || proc == NULL)
		return;

	HWND hWnd = hParent;

	while (1)
	{
		hWnd = GetWindow(hWnd, GW_HWNDPREV);

		if (hWnd == NULL)
			break;

		if (!proc(hWnd, lParam))
			break;
	}
}

static BOOL CALLBACK RenderIntoClipChild(HWND hWnd, LPARAM lParam)
{
	CFlexWnd *pThis = (CFlexWnd *)(LPVOID)lParam;
	return pThis->RenderIntoClipChild(hWnd);
}

static BOOL CALLBACK RenderIntoRenderChild(HWND hWnd, LPARAM lParam)
{
	CFlexWnd *pThis = (CFlexWnd *)(LPVOID)lParam;
	// Check if this is the immediate child. Do nothing if it's not immediate.
	HWND hParent = GetParent(hWnd);
	if (hParent != pThis->m_hWnd)
		return TRUE;
	return pThis->RenderIntoRenderChild(hWnd);
}

BOOL CFlexWnd::RenderIntoClipChild(HWND hChild)
{
	if (m_hRenderInto != NULL && HasWnd() && hChild && IsWindowVisible(hChild))
	{
		RECT rect;
		GetWindowRect(hChild, &rect);
		POINT ul = {rect.left, rect.top}, lr = {rect.right, rect.bottom};
		ScreenToClient(m_hWnd, &ul);
		ScreenToClient(m_hWnd, &lr);
		ExcludeClipRect(m_hRenderInto, ul.x, ul.y, lr.x, lr.y);
	}
	return TRUE;
}

BOOL CFlexWnd::RenderIntoRenderChild(HWND hChild)
{
	CFlexWnd *pChild = GetFlexWnd(hChild);
	if (m_hRenderInto != NULL && HasWnd() && pChild != NULL && IsWindowVisible(hChild))
	{
		RECT rect;
		GetWindowRect(hChild, &rect);
		POINT ul = {rect.left, rect.top};
		ScreenToClient(m_hWnd, &ul);
		pChild->RenderInto(m_hRenderInto, ul.x, ul.y);
	}
	return TRUE;
}

void CFlexWnd::RenderInto(HDC hDC, int x, int y)
{
	if (hDC == NULL)
		return;
		
	int sdc = SaveDC(hDC);
	{
		OffsetViewportOrgEx(hDC, x, y, NULL);
		SIZE size = GetClientSize();
		IntersectClipRect(hDC, 0, 0, size.cx, size.cy);

		m_hRenderInto = hDC;

		int sdc2 = SaveDC(hDC);
		{
			EnumChildWindows/*ZDown*/(m_hWnd, ::RenderIntoClipChild, (LPARAM)(PVOID)this);
			EnumSiblingsAbove(m_hWnd, ::RenderIntoClipChild, (LPARAM)(PVOID)this);
			DoOnPaint(hDC);
		}
		if (sdc2)
			RestoreDC(hDC, sdc2);

		EnumChildWindows/*ZDown*/(m_hWnd, ::RenderIntoRenderChild, (LPARAM)(PVOID)this);

		m_hRenderInto = NULL;
	}

	if (sdc)
		RestoreDC(hDC, sdc);
}

void CFlexWnd::SetCapture()
{
	::SetCapture(m_hWnd);
}

void CFlexWnd::ReleaseCapture()
{
	::ReleaseCapture();
}

void CFlexWnd::DoOnPaint(HDC hDC)
{
	OnPaint(hDC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flextree.h ===
//-----------------------------------------------------------------------------
// File: flextree.h
//
// Desc: Implements a tree class, similar to a Windows tree control,
//       based on CFlexWnd.  It is used by the page to display the action
//       list when the user wishes to assign an action to a control.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __FLEXTREE_H__
#define __FLEXTREE_H__


#include "flexscrollbar.h"


class CFTItem;
class CFlexTree;


typedef struct {
	CFlexTree *pTree;
	CFTItem *pItem, *pOldItem;
	POINT point;
	HDC hDC;
	WPARAM fwKeys;
	BOOL bLeft;
} FLEXTREENOTIFY;

enum {
	FTN_CLICK,
	FTN_OWNERDRAW,
	FTN_SELCHANGED,
	FTN_MOUSEOVER
};

enum {
	CLMF_NONE =			0x00000000,
	CLMF_TEXTCOLOR =	0x00000001,
	CLMF_BKCOLOR =		0x00000002,
	CLMF_BKMODE =		0x00000004,
	CLMF_BKEXTENDS =	0x00000008,
	CLMF_FONT =			0x00000010,
	CLMF_LINECOLOR = 0x00000020,
	CLMF_ALL =			0x0000003f
};

struct _CAPTIONLOOK;
typedef struct _CAPTIONLOOK {
	_CAPTIONLOOK() : dwSize(sizeof(_CAPTIONLOOK)), dwMask(CLMF_NONE),
		rgbTextColor(RGB(0,0,0)), rgbBkColor(RGB(255,255,255)), rgbLineColor(RGB(255,0,0)), nBkMode(TRANSPARENT),
		bBkExtends(FALSE), hFont(NULL) {}
	DWORD dwSize;
	DWORD dwMask;
	COLORREF rgbTextColor, rgbBkColor, rgbLineColor, nBkMode;
	BOOL bBkExtends;
	HFONT hFont;
} CAPTIONLOOK;

typedef enum {
	ATTACH_FIRSTCHILD,
	ATTACH_LASTCHILD,
	ATTACH_FIRSTSIBLING,
	ATTACH_LASTSIBLING,
	ATTACH_BEFORE,
	ATTACH_AFTER
} ATTACHREL;


class CFlexTree : public CFlexWnd
{
friend class CFTItem;
public:
	CFlexTree();
	~CFlexTree();

	// creation
	BOOL Create(HWND hParent, const RECT &, BOOL bVisible = TRUE, BOOL bOwnerDraw = FALSE);

	// look
	void SetScrollBarColors(COLORREF bk, COLORREF fill, COLORREF line);
	void SetDefCaptionLook(const CAPTIONLOOK &, BOOL bSel = FALSE);
	void GetDefCaptionLook(CAPTIONLOOK &, BOOL bSel = FALSE) const;
	void SetDefMargin(const RECT &);
	void GetDefMargin(RECT &) const;
	void SetRootChildIndent(int);
	int GetRootChildIndent() const;
	void SetDefChildIndent(int);
	int GetDefChildIndent() const;
	void SetBkColor(COLORREF);
	COLORREF GetBkColor() const;

	// adding default type items
	CFTItem *DefAddItem(LPCTSTR tszCaption, CFTItem *to, ATTACHREL rel = ATTACH_AFTER);
	CFTItem *DefAddItem(LPCTSTR tszCaption, ATTACHREL rel = ATTACH_AFTER);

	// freeing
	void FreeAll();

	// root access
	operator CFTItem *() const {return m_pRoot;}
	CFTItem *GetRoot() const {return m_pRoot;}

	// access
	CFTItem *GetFirstItem() const;
	CFTItem *GetLastItem() const;
	CFTItem *GetFirstVisibleItem() const;
	CFTItem *GetItemFromPoint(POINT point) const;

	// selection
	void SetCurSel(CFTItem *);
	CFTItem *GetCurSel() const;

	// finding
	CFTItem *FindItem(const GUID &guid, void *pUserData) const;
	CFTItem *FindItemEx(const GUID &guid, DWORD dwFindType, void *pVoid) const;

protected:
	virtual BOOL OnEraseBkgnd(HDC hDC) {return TRUE;}
	virtual void OnPaint(HDC hDC);
	virtual void OnMouseOver(POINT point, WPARAM fwKeys);
	virtual void OnClick(POINT point, WPARAM fwKeys, BOOL bLeft);
	virtual void OnWheel(POINT point, WPARAM wParam);
	virtual LRESULT WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

	// event notification firing
	void FireClick(CFTItem *pItem, POINT point, WPARAM fwKeys, BOOL bLeft);
	BOOL FireOwnerDraw(CFTItem *pItem, HDC hDC);
	void FireSelChanged(CFTItem *pItem, CFTItem *pOld);

private:
	CFTItem *m_pRoot;	// root item
	CFTItem *m_pCurSel;	// selected item
	CFTItem *m_pLastAdded;
	BOOL m_bOwnerDraw;
	POINT m_ptScrollOrigin;
	COLORREF m_rgbBkColor;
	CAPTIONLOOK m_clDefNormal, m_clDefSelected;
	RECT m_defmargin;
	int m_nDefChildIndent;

	// scrolling
	int m_nVertSBWidth;
	int m_nHorzSBHeight;
	BOOL m_bVertSB, m_bHorzSB;
	CFlexScrollBar m_VertSB, m_HorzSB;
	int m_nTotalWidth;

	// helpers
	BOOL m_bNeedPaintBkgnd;
	void SetDirty();
	void InternalPaint(HDC hDC);
	BOOL m_bDirty;
	void Calc();
	void CalcItems();
	BOOL IsMine(CFTItem *pItem);
	void LosePointer(CFTItem *pItem);
};

class CFTItem
{
friend class CFlexTree;
public:
	CFTItem();
	~CFTItem();

	// operations
	BOOL IsOut() const;
	BOOL IsExpanded() const {return m_bExpanded;}
	void Expand(BOOL bAll = FALSE);
	void ExpandAll() {Expand(TRUE);}
	void Collapse(BOOL bAll = FALSE);
	void CollapseAll() {Collapse(TRUE);}
	void EnsureVisible();
	void Invalidate();
	
	// caption
	void SetCaptionLook(const CAPTIONLOOK &, BOOL bSel = FALSE);
	void GetCaptionLook(CAPTIONLOOK &, BOOL bSel = FALSE) const;
	void SetCaption(LPCTSTR);
	LPCTSTR GetCaption() const;
	BOOL HasCaption() const {return GetCaption() != NULL;}
	void SetMargin(const RECT &);
	void GetMargin(RECT &) const;

	// attach/detachment
	void Detach();			// detaches this leaf/branch from parent.  (does not affect children, who may still be attached to this)
	void FreeChildren();	// detach and free each child (which in turn frees all their's, etc.)
	BOOL Attach(CFTItem *to, ATTACHREL rel);
	BOOL Attach(CFTItem &to, ATTACHREL rel) {return Attach(&to, rel);}
	BOOL IsOnTree() const;
	BOOL IsAttached() const;
	BOOL IsAlone() const;

	// family access
	CFlexTree *GetTree() const {return m_pTree;}
	CFTItem *GetParent() const {return m_pParent;}
	CFTItem *GetPrevSibling() const {return m_pPrev;}
	CFTItem *GetNextSibling() const {return m_pNext;}
	CFTItem *GetFirstChild() const {return m_pFirst;}
	CFTItem *GetLastChild() const {return m_pLast;}
	CFTItem *GetNextOut() const;
	CFTItem *GetNext(BOOL bOutOnly = FALSE) const;
	BOOL HasChildren() const {return m_pFirst != NULL;}

	// dimension access
	void GetItemRect(RECT &) const;
	void GetBranchRect(RECT &) const;

	// user guid/data operations
	BOOL IsUserGUID(const GUID &check) const {return IsEqualGUID(m_UserGUID, check);}
	void SetUserGUID(const GUID &set)  {m_UserGUID = set;}
	const GUID &GetUserGUID() const {return m_UserGUID;}
	void SetUserData(void *p) {m_pUserData = p;}
	void *GetUserData() const {return m_pUserData;}

	// selection
	BOOL IsSelected() const;

	// owner draw
	void PaintInto(HDC hDC);

protected:
	// internal/derived-customization operations
	void SetWidth(int);
	int GetWidth() const {return m_nWidth;}
	void SetHeight(int);
	int GetHeight() const {return m_nHeight;}
	void SetIndent(int);
	int GetIndent() const {return m_nIndent;}
	void SetChildIndent(int);
	int GetChildIndent() const {return m_nChildIndent;}

	// customization
	virtual void OnPaint(HDC hDC);
	virtual void OnMouseOver(POINT point, WPARAM fwKeys) {}
	virtual void OnClick(POINT point, WPARAM fwKeys, BOOL bLeft);

	// expansion customization
public: virtual BOOL IsExpandable() {return GetFirstChild() != NULL;}
protected:
	virtual void OnExpand() {}
	virtual void OnCollapse() {}

	// finding
	virtual BOOL FoundItem(DWORD dwUser, void *pUser) const {return FALSE;}

	// event notification firing
	void FireClick(POINT point, WPARAM fwKeys, BOOL bLeft);
	BOOL FireOwnerDraw(HDC hDC);

private:
	// caption
	LPTSTR m_ptszCaption;
	CAPTIONLOOK m_clNormal, m_clSelected;
	RECT m_margin;

	// user data
	GUID m_UserGUID;
	void *m_pUserData;

	// raw characteristics
	int m_nWidth;       // item's width (used only to provide horizontal scrolling as necessary)
	int m_nHeight;      // item's height (not including children)
	int m_nIndent;      // indent of this item relative to parent's child indent origin (full origin = this + parent origin + parent child indent)
	int m_nChildIndent; // indentation of this item's children (relative to this's origin)

	// calced characteristics
	int m_nBranchHeight;  // height of item and all currently expanded children

	// calced positioning
	POINT m_origin;  // relative to ideal tree origin

	// state
	BOOL m_bExpanded;  // is branch expanded/children shown?

	// family
	CFlexTree *m_pTree;
	CFTItem *m_pParent, *m_pPrev, *m_pNext, *m_pFirst, *m_pLast;

	// root
	BOOL IsRoot() const;
	void SetRoot(CFlexTree *);

	// helpers
	void SetTree(CFlexTree *);
	BOOL Attach(CFTItem *pParent, CFTItem *pPrev, CFTItem *pNext);
	void SetTreeDirty(CFlexTree *pTree = NULL);
	void RecalcText();
	void Init();
	void SelChangedInternal();
	void InternalExpand(BOOL bExpand, BOOL bAll);
};


#endif //__FLEXTREE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\iclassfact.h ===
//-----------------------------------------------------------------------------
// File: iclassfact.h
//
// Desc: Implements the class factory for the UI.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef _ICLASSFACT_H
#define _ICLASSFACT_H


class CFactory : public IClassFactory
{
public:

	//IUnknown
	STDMETHOD (QueryInterface) (REFIID riid, LPVOID* ppv);
	STDMETHOD_(ULONG, AddRef) ();
	STDMETHOD_(ULONG, Release) ();

	//IClassFactory
	STDMETHOD (CreateInstance) (IUnknown* pUnkOuter, REFIID riid, LPVOID* ppv);
	STDMETHOD (LockServer) (BOOL bLock);

	//constructor/destructor
	CFactory();
	~CFactory();

protected:
	LONG m_cRef;
};


#endif // _ICLASSFACT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\flextree.cpp ===
//-----------------------------------------------------------------------------
// File: flextree.cpp
//
// Desc: Implements a tree class, similar to a Windows tree control,
//       based on CFlexWnd.  It is used by the page to display the action
//       list when the user wishes to assign an action to a control.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


CFlexTree::CFlexTree() :
	m_pRoot(NULL), m_bDirty(FALSE), m_bNeedPaintBkgnd(FALSE),
	m_rgbBkColor(RGB(255,255,255)),
	m_pCurSel(NULL), m_pLastAdded(NULL), m_bOwnerDraw(FALSE),
	m_bVertSB(FALSE), m_bHorzSB(FALSE),
	m_nVertSBWidth(11), m_nHorzSBHeight(11)
{
	RECT z = {0,0,0,0};
	m_defmargin = z;
	m_clDefNormal.dwMask = CLMF_ALL;
	m_clDefSelected.dwMask = CLMF_ALL;
	m_ptScrollOrigin.x = m_ptScrollOrigin.y = 0;
	
	// allocate root
	m_pRoot = new CFTItem;
	if (m_pRoot != NULL)
	{
		m_pRoot->SetRoot(this);
		assert(m_pRoot->IsRoot());
	}
}

CFlexTree::~CFlexTree()
{
	if (m_pRoot)
		delete m_pRoot;
	m_pRoot = NULL;
}

CFTItem::CFTItem()
{
	Init();
}

void CFTItem::Init()
{
	m_pUserData = NULL;
	m_bExpanded = FALSE;
	m_pTree = NULL;
	m_pParent = NULL;
	m_pPrev = NULL;
	m_pNext = NULL;
	m_pFirst = NULL;
	m_pLast = NULL;
	m_ptszCaption = NULL;
	m_nIndent = m_nWidth = m_nHeight = m_nBranchHeight = 0;
	m_nChildIndent = 11;
	RECT z = {0,0,0,0};
	m_margin = z;
	memset(&m_UserGUID, 0, sizeof(GUID));
	SetCaption(TEXT(""));
}

CFTItem::~CFTItem()
{
	// detach from parent (unless root)
	if (!IsRoot())
		Detach();

	// remove all children
	FreeChildren();

	// free stuff
	SetCaption(NULL);
}

void CFTItem::SetRoot(CFlexTree *pTree)
{
	if (pTree == NULL)
	{
		assert(0);
		return;
	}

	SetTree(pTree);

	m_nIndent = 0;
	m_nHeight = 0;
	m_nWidth = 0;
	m_nChildIndent = 0;

	m_bExpanded = TRUE;
	POINT origin = {0, 0};
	m_origin = origin;
}

BOOL CFTItem::IsRoot() const
{
	return m_pTree != NULL && m_pParent == NULL;
}

CFTItem *CFlexTree::GetFirstItem() const
{
	if (m_pRoot == NULL)
		return NULL;

	return m_pRoot->GetFirstChild();
}

CFTItem *CFlexTree::GetLastItem() const
{
	if (m_pRoot == NULL)
		return NULL;

	return m_pRoot->GetLastChild();
}

BOOL CFTItem::IsOnTree() const
{
	return m_pTree != NULL;
}

BOOL CFTItem::IsAttached() const
{
	if (IsRoot())
	{
		assert(0);
		return TRUE;
	}

	return m_pParent != NULL;
}

BOOL CFTItem::IsAlone() const
{
	return
		m_pTree == NULL &&
		m_pParent == NULL &&
		m_pPrev == NULL &&
		m_pNext == NULL &&
		m_pFirst == NULL &&
		m_pLast == NULL;
}

void CFTItem::FreeChildren()
{
	while (m_pFirst != NULL)
	{
		CFTItem *pChild = m_pFirst;
		delete pChild;
	}
}

#define FORALLCHILDREN(pChild) \
	for (CFTItem *pChild = m_pFirst; pChild != NULL; pChild = pChild->m_pNext)

void CFTItem::SetTree(CFlexTree *pTree)
{
	// don't do anything if we've already got this tree
	if (m_pTree == pTree)
		return;

	// if we are currently on a tree, tell it to lose any potential dangling pointers to us
	if (m_pTree)
		m_pTree->LosePointer(this);

	// actually set this tree
	m_pTree = pTree;

	// set all children to this tree
	FORALLCHILDREN(pChild)
		pChild->SetTree(pTree);
}

void CFTItem::Detach()
{
	// don't allow root detachment
	if (IsRoot())
	{
		assert(0);
		return;
	}

	// if we're already detached, do nothing
	if (!IsAttached())
		return;

	// unlink from parent
	if (m_pParent->m_pFirst == this)
		m_pParent->m_pFirst = m_pNext;
	if (m_pParent->m_pLast == this)
		m_pParent->m_pLast = m_pPrev;
	m_pParent = NULL;

	// unlink from siblings
	if (m_pPrev)
		m_pPrev->m_pNext = m_pNext;
	if (m_pNext)
		m_pNext->m_pPrev = m_pPrev;
	m_pPrev = m_pNext = NULL;

	// save tree because we're about to lose it
	CFlexTree *pTree = m_pTree;

	// tell ourself and all children that we are no longer on a tree
	SetTree(NULL);

	// the tree needs to be recalced
	if (pTree)
		SetTreeDirty(pTree);
}

BOOL CFTItem::Attach(CFTItem *to, ATTACHREL rel)
{
	// can't attach root to anything, can't attach to nothing, and can't attach if already attached
	if (IsRoot() || to == NULL || IsAttached())
	{
		assert(0);
		return FALSE;
	}

	// first make sure we're not attaching to root in an impossible way
	if (to->IsRoot())
		switch (rel)
		{
			// only the following are valid for attaching to root
			case ATTACH_FIRSTCHILD:
			case ATTACH_LASTCHILD:
				break;

			// all others are invalid
			default:
				assert(0);
				return FALSE;
		}

	// now convert attaching as first/last sibling to equiv first/last child of parent
	switch (rel)
	{
		case ATTACH_FIRSTSIBLING:
			return Attach(to->m_pParent, ATTACH_FIRSTCHILD);

		case ATTACH_LASTSIBLING:
			return Attach(to->m_pParent, ATTACH_LASTCHILD);
	}

	// send to the more specific attach function
	switch (rel)
	{
		case ATTACH_FIRSTCHILD:
			return Attach(to, NULL, to->m_pFirst);
		
		case ATTACH_LASTCHILD:
			return Attach(to, to->m_pLast, NULL);

		case ATTACH_BEFORE:
			return Attach(to->m_pParent, to->m_pPrev, to);

		case ATTACH_AFTER:
			return Attach(to->m_pParent, to, to->m_pNext);

		default:
			assert(0);	// unhandled rel
			return FALSE;
	}
}

BOOL CFTItem::Attach(CFTItem *pParent, CFTItem *pPrev, CFTItem *pNext)
{
	// can't attach root to anything, can't attach to no parent, and can't attach if already attached
	if (IsRoot() || pParent == NULL || IsAttached())
	{
		assert(0);
		return FALSE;
	}

	// prev/next, if provided, must be children of parent
	if ((pPrev && pPrev->m_pParent != pParent) ||
		(pNext && pNext->m_pParent != pParent))
	{
		assert(0);
		return FALSE;
	}

	// pPrev and pNext must be consecutive
	if ((pPrev && pPrev->m_pNext != pNext) ||
		(pNext && pNext->m_pPrev != pPrev))
	{
		assert(0);
		return FALSE;
	}

	// insert
	if (pPrev)
		pPrev->m_pNext = this;
	else
		pParent->m_pFirst = this;

	if (pNext)
		pNext->m_pPrev = this;
	else
		pParent->m_pLast = this;

	// attach
	m_pParent = pParent;
	m_pPrev = pPrev;
	m_pNext = pNext;

	// set the tree
	SetTree(pParent->m_pTree);

	// tree needs to be recalced
	SetTreeDirty();

	return TRUE;
}

void CFlexTree::SetDirty()
{
	m_bDirty = TRUE;
	Invalidate();
}

void CFTItem::SetTreeDirty(CFlexTree *pTree)
{
	if (pTree == NULL)
		pTree = m_pTree;

	if (pTree)
		pTree->SetDirty();
}

void CFTItem::SetWidth(int i)
{
	if (m_nWidth == i)
		return;
	m_nWidth = i;
	SetTreeDirty();
}

void CFTItem::SetHeight(int i)
{
	if (m_nHeight == i)
		return;
	m_nHeight = i;
	SetTreeDirty();
}

void CFTItem::SetIndent(int i)
{
	if (m_nIndent == i)
		return;
	m_nIndent = i;
	SetTreeDirty();
}

void CFTItem::SetChildIndent(int i)
{
	if (m_nChildIndent == i)
		return;
	m_nChildIndent = i;
	SetTreeDirty();
}

void CFlexTree::OnPaint(HDC hDC)
{
	HDC hBDC = NULL, hODC = NULL;
	CBitmap *pbm = NULL;

	m_bNeedPaintBkgnd = TRUE;

	if (!InRenderMode())
	{
		hODC = hDC;
		pbm = CBitmap::Create(GetClientSize(), m_rgbBkColor, hDC);
		if (pbm != NULL)
		{
			hBDC = pbm->BeginPaintInto();
			if (hBDC != NULL)
			{
				hDC = hBDC;
				m_bNeedPaintBkgnd = FALSE;
			}
		}
	}

	InternalPaint(hDC);

	if (!InRenderMode())
	{
		if (pbm != NULL)
		{
			if (hBDC != NULL)
			{
				pbm->EndPaintInto(hBDC);
				pbm->Draw(hODC);
			}
			delete pbm;
		}
	}
}

void CFlexTree::InternalPaint(HDC hDC)
{
	// get client rect
	RECT rect;
	GetClientRect(&rect);

	// get view rect (ideal coordinates we're viewing)
	RECT view = rect;
	OffsetRect(&view, m_ptScrollOrigin.x, m_ptScrollOrigin.y);

	// paint background if necessary
	if (m_bNeedPaintBkgnd)
	{
		HBRUSH hBrush = CreateSolidBrush(m_rgbBkColor);
		if (hBrush != NULL)
		{
			HGDIOBJ hOldBrush = SelectObject(hDC, hBrush);
			HGDIOBJ hOldPen = SelectObject(hDC, GetStockObject(NULL_PEN));
			RECT t = rect;
			InflateRect(&t, 1, 1);
			Rectangle(hDC, t.left, t.top, t.right, t.bottom);
			SelectObject(hDC, hOldPen);
			SelectObject(hDC, hOldBrush);
			DeleteObject((HGDIOBJ)hBrush);
		}
	}

	// recalculate if necessary
	Calc();

	// start with the first visible item
	CFTItem *pItem = GetFirstVisibleItem();

	// draw until we go out of view
	for (; pItem != NULL; pItem = pItem->GetNextOut())
	{
		RECT irect;
		pItem->GetItemRect(irect);
		if (irect.top >= view.bottom)
			break;

		OffsetRect(&irect, -m_ptScrollOrigin.x, -m_ptScrollOrigin.y);
		
		POINT oldorg;
		OffsetViewportOrgEx(hDC, irect.left, irect.top, &oldorg);
		
		// TODO: clip
		
		if (!pItem->FireOwnerDraw(hDC))
			pItem->OnPaint(hDC);

		SetViewportOrgEx(hDC, oldorg.x, oldorg.y, NULL);
	}

	// Fill in the small square at bottom right corner if we have both scroll bars.
	if (m_bVertSB && m_bHorzSB)
	{
		HBRUSH hBrush = CreateSolidBrush(m_clDefNormal.rgbLineColor);
		if (hBrush != NULL)
		{
			HGDIOBJ hOldBrush = SelectObject(hDC, hBrush);

			HGDIOBJ hPen = CreatePen(PS_SOLID, 0, m_clDefNormal.rgbLineColor);
			if (hPen != NULL)
			{
				HGDIOBJ	hOldPen = SelectObject(hDC, hPen);

				RECT rc = rect;
				SIZE size;
				size = m_VertSB.GetClientSize();
				rc.left = rc.right - size.cx;
				size = m_HorzSB.GetClientSize();
				rc.top = rc.bottom - size.cy;
				Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);

				SelectObject(hDC, hOldPen);
				DeleteObject((HGDIOBJ) hPen);
			}

			SelectObject(hDC, hOldBrush);
			DeleteObject((HGDIOBJ)hBrush);
		}
	}
}

void CFlexTree::Calc()
{
	if (!m_bDirty)	
		return;
	m_bDirty = FALSE;

	CalcItems();

	BOOL bH = FALSE, bV = FALSE;
	if (m_pRoot != NULL)
	{
		SIZE view = GetClientSize();
		SIZE all = {m_nTotalWidth, m_pRoot->m_nBranchHeight};

		for (int i = 0; i < 2; i++)
		{
			// Added GetFirstVisibleItem() check since we don't want scroll bar if nothing is to be
			// displayed.
			if (!bV && all.cy > view.cy && GetFirstVisibleItem())
			{
				bV = TRUE;
				view.cx -= m_nVertSBWidth;
			}

			if (!bH && all.cx > view.cx)
			{
				bH = TRUE;
				view.cy -= m_nHorzSBHeight;
			}
		}
	
		if (bH)
		{
			m_HorzSB.SetValues(0, all.cx, view.cx, m_ptScrollOrigin.x);
			MoveWindow(m_HorzSB.m_hWnd, 0, view.cy, view.cx, m_nHorzSBHeight, TRUE);
		}

		if (bV)
		{
			m_VertSB.SetValues(0, all.cy, view.cy, m_ptScrollOrigin.y);
			MoveWindow(m_VertSB.m_hWnd, view.cx, 0, m_nVertSBWidth, view.cy, TRUE);
		}
	}

	if (bH && !m_bHorzSB || !bH && m_bHorzSB)
	{
		ShowWindow(m_HorzSB.m_hWnd, bH ? SW_SHOW : SW_HIDE);
		if (!bH)
		{
			m_ptScrollOrigin.x = 0;
			Invalidate();
		}
	}
	m_bHorzSB = bH;

	if (bV && !m_bVertSB || !bV && m_bVertSB)
	{
		ShowWindow(m_VertSB.m_hWnd, bV ? SW_SHOW : SW_HIDE);
		if (!bV)
		{
			m_ptScrollOrigin.y = 0;
			Invalidate();
		}
	}
	m_bVertSB = bV;
}

void CFlexTree::CalcItems()
{
	// can't do anything without root
	if (m_pRoot == NULL)
		return;

	// calculate the entire tree in out/down order starting with first child of root...
	POINT origin = {0, 0};
	CFTItem *pItem = m_pRoot->m_pFirst;
	m_nTotalWidth = 0;
	while (pItem != NULL)
	{
		// let this item know its out

		// get parent origin
		CFTItem *pParent = pItem->m_pParent;
		assert(pParent != NULL);

		// calc origin...

		// if we're the first child
		if (pItem->m_pPrev == NULL)
		{
			// base origin on the parent
			if (pParent)
			{
				origin.x = pParent->m_origin.x - pParent->m_nIndent + pParent->m_nChildIndent + pItem->m_nIndent;
				origin.y = pParent->m_origin.y + pParent->m_nHeight;
			}
		}
		else // otherwise
		{
			// base origin on the previous sibling
			CFTItem *pPrev = pItem->m_pPrev;
			assert(pPrev != NULL);
			if (pPrev)
			{
				origin.x = pPrev->m_origin.x - pPrev->m_nIndent + pItem->m_nIndent;
				origin.y = pPrev->m_origin.y + pPrev->m_nBranchHeight;
			}
		}

		// set origin
		pItem->m_origin = origin;

		// see which direction we'll be going next
		CFTItem *pNext = pItem->GetNextOut();
		enum {RIGHT, DOWN, BACK, NOWHERE, INVALID} dir = INVALID;
		if (pNext == NULL)
			dir = NOWHERE;
		else if (pNext == pItem->m_pNext)
			dir = DOWN;
		else if (pNext == pItem->m_pFirst)
			dir = RIGHT;
		else
			dir = BACK;

		// if we're going down, back, or nowhere, we can complete this item's branchheight
		switch (dir)
		{
			case DOWN:
			case BACK:
			case NOWHERE:
				pItem->m_nBranchHeight = pItem->m_nHeight;
				break;
		}

		// calc for skipped items when going back
		switch (dir)
		{
			case BACK:
			case NOWHERE:
			{
				CFTItem *pStop = NULL;
				if (dir == BACK)
					pStop = pNext->m_pParent;
				CFTItem *pWalk = pItem->m_pParent;
				while (1)
				{
					if (pWalk == pStop)
						break;

					pWalk->m_nBranchHeight = pItem->m_origin.y +
						pItem->m_nBranchHeight - pWalk->m_origin.y;

					pWalk = pWalk->m_pParent;
				}
				break;
			}	

			case INVALID:
				assert(0);
				break;
		}

		RECT rect;
		pItem->GetItemRect(rect);
		if (rect.right > m_nTotalWidth)
			m_nTotalWidth = rect.right;

		// now go to next item
		pItem = pNext;
	}
}

CFTItem *CFTItem::GetNextOut() const
{
	return GetNext(TRUE);
}

CFTItem *CFTItem::GetNext(BOOL bOutOnly) const
{
	// if we have a child and we're expanded (or we're not looking for out only), return the first child (going 'right')
	if ((m_bExpanded || !bOutOnly) && m_pFirst != NULL)
		return m_pFirst;

	// if we have a next sibling, return it (going 'down')
	if (m_pNext != NULL)
		return m_pNext;

	// climb up parents until we get to one with another next sibling
	for (CFTItem *pItem = m_pParent; pItem != NULL; pItem = pItem->m_pParent)
		if (pItem->m_pNext != NULL)
			return pItem->m_pNext;

	// if we didn't find one, we're done
	return NULL;
}

void CFTItem::GetItemRect(RECT &rect) const
{
	rect.left = m_origin.x;
	rect.top = m_origin.y;
	rect.right = rect.left + m_nWidth;
	rect.bottom = rect.top + m_nHeight;
}

void CFTItem::GetBranchRect(RECT &rect) const
{
	rect.left = m_origin.x;
	rect.top = m_origin.y;
	rect.right = rect.left + m_nWidth;
	rect.bottom = rect.top + m_nBranchHeight;
}

void CFTItem::SetCaption(LPCTSTR tszCaption)
{
	if (m_ptszCaption != NULL)
		free(m_ptszCaption);

	if (tszCaption == NULL)
		m_ptszCaption = NULL;
	else
		m_ptszCaption = _tcsdup(tszCaption);

	RecalcText();
}

LPCTSTR CFTItem::GetCaption() const
{
	return m_ptszCaption;
}

void CFTItem::SetMargin(const RECT &rect)
{
	m_margin = rect;
	RecalcText();
}

void CFTItem::RecalcText()
{
	// calculate size from text dimensions and margin
	SIZE size = {0, 0};
	if (HasCaption())
	{
		RECT trect = {0, 0, 1, 1};
		HDC hDC = CreateCompatibleDC(NULL);
		if (hDC != NULL)
		{
			HGDIOBJ hOld = NULL;
			HFONT hFont = IsSelected() ? m_clSelected.hFont : m_clNormal.hFont;
			if (hFont)
				hOld = SelectObject(hDC, hFont);
			DrawText(hDC, m_ptszCaption, -1, &trect, DT_CALCRECT | DT_NOPREFIX);
			if (hFont)
				SelectObject(hDC, hOld);
			DeleteDC(hDC);
			SIZE tsize = {trect.right - trect.left, trect.bottom - trect.top};
			size = tsize;
		}
	}
	SetWidth(m_margin.left + m_margin.right + size.cx);
	SetHeight(m_margin.top + m_margin.bottom + size.cy);

	// redraw
	Invalidate();
}

void CFTItem::Invalidate()
{
	if (m_pTree)
		m_pTree->Invalidate();
}

typedef CArray<LPDIACTIONW, LPDIACTIONW &> RGLPDIACW;

void CFTItem::OnPaint(HDC hDC)
{
	CAPTIONLOOK &cl = (IsSelected() && !GetTree()->GetReadOnly()) ? m_clSelected : m_clNormal;  // Always use normal color if read-only since we gray out everything.
	::SetBkMode(hDC, cl.nBkMode);
	
	LPDIACTIONW lpac = NULL;
	if (m_pUserData)
		lpac = ((RGLPDIACW *)m_pUserData)->GetAt(0);  // Get the DIACTION this item holds.
	if (GetTree()->GetReadOnly() || (lpac && (lpac->dwFlags & DIA_APPFIXED)))  // If read-only or the action has DIA_APPFIXED flag, use gray color for texts.
		::SetTextColor(hDC, RGB(GetRValue(cl.rgbTextColor) >> 1, GetGValue(cl.rgbTextColor) >> 1, GetBValue(cl.rgbTextColor) >> 1));
	else
		::SetTextColor(hDC, cl.rgbTextColor);
	::SetBkColor(hDC, cl.rgbBkColor);
	HGDIOBJ hOld = NULL;
	if (cl.hFont)
		hOld = SelectObject(hDC, cl.hFont);
	RECT trect = {m_margin.left, m_margin.top, m_margin.left + 1, m_margin.top + 1};
	DrawText(hDC, m_ptszCaption, -1, &trect, DT_NOPREFIX | DT_NOCLIP);
	if (cl.hFont)
		SelectObject(hDC, hOld);
}

BOOL CFlexTree::Create(HWND hParent, const RECT &rect, BOOL bVisible, BOOL bOwnerDraw)
{
	m_bOwnerDraw = bOwnerDraw;

	if (CFlexWnd::Create(hParent, rect, bVisible) == NULL)
		return FALSE;

	FLEXSCROLLBARCREATESTRUCT cs;
	cs.dwSize = sizeof(FLEXSCROLLBARCREATESTRUCT);
	cs.min = 0;
	cs.max = 10;
	cs.page = 3;
	cs.pos = 5;
	cs.hWndParent = m_hWnd;
	cs.hWndNotify = NULL;
	cs.rect.left = 0;
	cs.rect.top = 0;
	cs.rect.right = 5;
	cs.rect.bottom = 5;
	cs.bVisible = FALSE;
	cs.dwFlags = FSBF_VERT;
	m_VertSB.Create(&cs);
	cs.dwFlags = FSBF_HORZ;
	m_HorzSB.Create(&cs);

	return TRUE;
}

void CFlexTree::SetDefCaptionLook(const CAPTIONLOOK &cl, BOOL bSel)
{
	CAPTIONLOOK &set = bSel ? m_clDefSelected : m_clDefNormal;

	if (cl.dwMask & CLMF_TEXTCOLOR)
		set.rgbTextColor = cl.rgbTextColor;
	if (cl.dwMask & CLMF_BKCOLOR)
		set.rgbBkColor = cl.rgbBkColor;
	if (cl.dwMask & CLMF_LINECOLOR)
		set.rgbLineColor = cl.rgbLineColor;
	if (cl.dwMask & CLMF_BKMODE)
		set.nBkMode = cl.nBkMode;
	if (cl.dwMask & CLMF_BKEXTENDS)
		set.bBkExtends = cl.bBkExtends;
	if (cl.dwMask & CLMF_FONT)
		set.hFont = cl.hFont;
}

void CFlexTree::GetDefCaptionLook(CAPTIONLOOK &cl, BOOL bSel) const
{
	const CAPTIONLOOK &from = bSel ? m_clDefSelected : m_clDefNormal;

	cl = from;
	cl.dwMask = CLMF_ALL;
}

void CFlexTree::SetBkColor(COLORREF rgb)
{
	m_rgbBkColor = rgb;
	Invalidate();
}

COLORREF CFlexTree::GetBkColor() const
{
	return m_rgbBkColor;
}

void CFlexTree::SetCurSel(CFTItem *pItem)
{
	if (pItem == m_pCurSel)
		return;

	CFTItem *pOld = m_pCurSel;
	m_pCurSel = pItem;

	if (pOld)
		pOld->SelChangedInternal();
	if (m_pCurSel)
		m_pCurSel->SelChangedInternal();

	FireSelChanged(m_pCurSel, pOld);

	Invalidate();
}

CFTItem *CFlexTree::GetCurSel() const
{
	return m_pCurSel;
}

CFTItem *CFlexTree::FindItem(const GUID &guid, void *pUserData) const
{
	// go until we get to the item with specified guid and userdata
	for (CFTItem *pItem = GetFirstItem(); pItem != NULL; pItem = pItem->GetNext())
		if (pItem->IsUserGUID(guid) && pItem->GetUserData() == pUserData)
			return pItem;

	// unless there isn't one
	return NULL;
}

CFTItem *CFlexTree::FindItemEx(const GUID &guid, DWORD dwUser, void *pUser) const
{
	// go until we get to the item with specified guid and found item returns true
	for (CFTItem *pItem = GetFirstItem(); pItem != NULL; pItem = pItem->GetNext())
		if (pItem->IsUserGUID(guid) && pItem->FoundItem(dwUser, pUser))
			return pItem;

	// unless there isn't one
	return NULL;
}

void CFTItem::SetCaptionLook(const CAPTIONLOOK &cl, BOOL bSel)
{
	CAPTIONLOOK &set = bSel ? m_clSelected : m_clNormal;

	if (cl.dwMask & CLMF_TEXTCOLOR)
		set.rgbTextColor = cl.rgbTextColor;
	if (cl.dwMask & CLMF_BKCOLOR)
		set.rgbBkColor = cl.rgbBkColor;
	if (cl.dwMask & CLMF_LINECOLOR)
		set.rgbLineColor = cl.rgbLineColor;
	if (cl.dwMask & CLMF_BKMODE)
		set.nBkMode = cl.nBkMode;
	if (cl.dwMask & CLMF_BKEXTENDS)
		set.bBkExtends = cl.bBkExtends;
	if (cl.dwMask & CLMF_FONT)
		set.hFont = cl.hFont;

	if (IsSelected() == bSel)
		RecalcText();
}

void CFTItem::GetCaptionLook(CAPTIONLOOK &cl, BOOL bSel) const
{
	const CAPTIONLOOK &from = bSel ? m_clSelected : m_clNormal;

	cl = from;
	cl.dwMask = CLMF_ALL;
}

void CFTItem::GetMargin(RECT &rect) const
{
	rect = m_margin;
}

void CFTItem::SelChangedInternal()
{
	if (m_clNormal.hFont != m_clSelected.hFont)
		RecalcText();
}

CFTItem *CFlexTree::DefAddItem(LPCTSTR tszCaption, CFTItem *to, ATTACHREL rel)
{
	if (m_pRoot == NULL)
		return NULL;

	if (!to)
		return DefAddItem(tszCaption, rel);

	if (!IsMine(to))
	{
		assert(0);		// can't add relative to item that doesn't belong to this tree
		return NULL;
	}

	CFTItem *p = new CFTItem;
	if (!p)
		return NULL;

	p->SetCaptionLook(m_clDefNormal);
	p->SetCaptionLook(m_clDefSelected, TRUE);
	p->SetChildIndent(m_nDefChildIndent);
	p->SetMargin(m_defmargin);
	p->SetCaption(tszCaption);

	p->Attach(to, rel);

	return m_pLastAdded = p;
}

CFTItem *CFlexTree::DefAddItem(LPCTSTR tszCaption, ATTACHREL rel)
{
	if (m_pRoot == NULL)
		return NULL;

	assert(this != NULL);
	if (this == NULL)		// prevent infinite recursion possibility
		return NULL;

	if (!m_pLastAdded)
		return DefAddItem(tszCaption, m_pRoot, ATTACH_LASTCHILD);
	else
		return DefAddItem(tszCaption, m_pLastAdded, rel);
}

void CFlexTree::SetDefMargin(const RECT &rect)
{
	m_defmargin = rect;
}

void CFlexTree::GetDefMargin(RECT &rect) const
{
	rect = m_defmargin;
}

BOOL CFlexTree::IsMine(CFTItem *pItem)
{
	if (pItem == NULL)
		return FALSE;

	return pItem->m_pTree == this;
}

BOOL CFTItem::IsSelected() const
{
	if (!m_pTree)
		return FALSE;

	return m_pTree->m_pCurSel == this;
}

CFTItem *CFlexTree::GetFirstVisibleItem() const
{
	// get view rect (ideal coordinates we're viewing)
	RECT view;
	GetClientRect(&view);
	OffsetRect(&view, m_ptScrollOrigin.x, m_ptScrollOrigin.y);

	// start at first child of root
	CFTItem *pItem = m_pRoot->GetFirstChild();
	if (pItem == NULL)
		return NULL;

	// find first item in view
	RECT branch, irect;
	while (1)
	{
		// find first branch in view
		while (1)
		{
			pItem->GetBranchRect(branch);
			if (branch.bottom > view.top)
				break;

			pItem = pItem->GetNextSibling();
			if (pItem == NULL)
				return NULL;
		}

		// now actually go through items
		pItem->GetItemRect(irect);
		if (irect.bottom > view.top)
			break;

		pItem = pItem->GetNextOut();
		if (pItem == NULL)
			return NULL;
	}
	
	// we got it, so return it
	return pItem;	
}

CFTItem *CFlexTree::GetItemFromPoint(POINT point) const
{
	if (m_hWnd == NULL)
		return NULL;

	RECT rect;
	GetClientRect(&rect);
	if (!PtInRect(&rect, point))
		return NULL;

	for (CFTItem *pItem = GetFirstVisibleItem(); pItem != NULL; pItem = pItem->GetNextOut())
	{
		RECT irect;
		pItem->GetItemRect(irect);
		OffsetRect(&irect, -m_ptScrollOrigin.x, -m_ptScrollOrigin.y);

		if (irect.top >= rect.bottom)
			return NULL;

		if (PtInRect(&irect, point))
			return pItem;
	}

	return NULL;
}

void CFlexTree::OnMouseOver(POINT point, WPARAM fwKeys)
{
	// Send mouse over notification to page to update info box.
	HWND hParent = ::GetParent(m_hWnd);
	if (hParent)
		SendMessage(hParent, WM_FLEXTREENOTIFY, FTN_MOUSEOVER, NULL);

	CFTItem *pItem = GetItemFromPoint(point);
	if (!pItem)
		return;
	POINT rel = {point.x - pItem->m_origin.x, point.y - pItem->m_origin.y};
	pItem->OnMouseOver(point, fwKeys);
}

void CFlexTree::OnClick(POINT point, WPARAM fwKeys, BOOL bLeft)
{
	// If the tree is read-only, ignore all clicks.
	if (GetReadOnly())
		return;

	CFTItem *pItem = GetItemFromPoint(point);
	if (!pItem)
	{
		FireClick(NULL, point, fwKeys, bLeft);
		return;
	}
	POINT rel = {point.x - pItem->m_origin.x, point.y - pItem->m_origin.y};
	pItem->OnClick(point, fwKeys, bLeft);
}

void CFTItem::OnClick(POINT point, WPARAM fwKeys, BOOL bLeft)
{
	FireClick(point, fwKeys, bLeft);
}

void CFlexTree::OnWheel(POINT point, WPARAM wParam)
{
	if (!m_bVertSB) return;

	int nPage = MulDiv(m_VertSB.GetPage(), 9, 10) >> 1;  // Half a page at a time

	if ((int)wParam >= 0)
		m_VertSB.AdjustPos(-nPage);
	else
		m_VertSB.AdjustPos(nPage);

	m_ptScrollOrigin.y = m_VertSB.GetPos();
	if (m_ptScrollOrigin.y < 0)
		m_ptScrollOrigin.y = 0;
	Invalidate();
}

void CFlexTree::FireClick(CFTItem *pItem, POINT point, WPARAM fwKeys, BOOL bLeft)
{
	FLEXTREENOTIFY n;
	n.pTree = this;
	n.pItem = pItem;
	n.pOldItem = NULL;
	n.hDC = NULL;
	n.point = point;
	n.fwKeys = fwKeys;
	n.bLeft = bLeft;

	HWND hParent = ::GetParent(m_hWnd);
	if (hParent)
		SendMessage(hParent, WM_FLEXTREENOTIFY, FTN_CLICK, (LRESULT)(LPVOID)&n);
}

BOOL CFlexTree::FireOwnerDraw(CFTItem *pItem, HDC hDC)
{
	if (!m_bOwnerDraw)
		return FALSE;

	FLEXTREENOTIFY n;
	n.pTree = this;
	n.pItem = pItem;
	n.pOldItem = NULL;
	n.hDC = hDC;

	HWND hParent = ::GetParent(m_hWnd);
	if (hParent)
		return (BOOL)SendMessage(hParent, WM_FLEXTREENOTIFY, FTN_OWNERDRAW, (LRESULT)(LPVOID)&n);
	else
		return FALSE;
}

void CFlexTree::FireSelChanged(CFTItem *pItem, CFTItem *pOld)
{
	assert(pItem == m_pCurSel);

	FLEXTREENOTIFY n;
	n.pTree = this;
	n.pItem = pItem;
	n.pOldItem = pOld;
	n.hDC = NULL;

	HWND hParent = ::GetParent(m_hWnd);
	if (hParent)
		SendMessage(hParent, WM_FLEXTREENOTIFY, FTN_SELCHANGED, (LRESULT)(LPVOID)&n);
}

void CFTItem::FireClick(POINT point, WPARAM fwKeys, BOOL bLeft)
{
	if (m_pTree)
		m_pTree->FireClick(this, point, fwKeys, bLeft);
}

BOOL CFTItem::FireOwnerDraw(HDC hDC)
{
	if (m_pTree)
		return m_pTree->FireOwnerDraw(this, hDC);
	else
		return FALSE;
}

void CFTItem::Expand(BOOL bAll)
{
	InternalExpand(TRUE, bAll);
}

void CFTItem::Collapse(BOOL bAll)
{
	InternalExpand(FALSE, bAll);
}

void CFTItem::InternalExpand(BOOL bExpand, BOOL bAll)
{
	if (!HasChildren())
		return;

	BOOL bE = m_bExpanded;
	if (!IsRoot())
		m_bExpanded = bExpand;

	if (bAll)
		FORALLCHILDREN(pChild)
			pChild->InternalExpand(bExpand, TRUE);

	if (bE != m_bExpanded)
		SetTreeDirty();
}

BOOL CFTItem::IsOut() const
{
	CFTItem *pParent = GetParent();
	for (; pParent != NULL; pParent = pParent->GetParent())
		if (!pParent->IsExpanded())
			return FALSE;
	return TRUE;
}

void CFlexTree::FreeAll()
{
	if (m_pRoot)
		m_pRoot->FreeChildren();
}

void CFTItem::EnsureVisible()
{
	// TBD
}

void CFlexTree::LosePointer(CFTItem *pItem)
{
	if (m_pCurSel == pItem)
		SetCurSel(NULL);
	if (m_pLastAdded == pItem)
		m_pLastAdded = NULL;
}

void CFlexTree::SetRootChildIndent(int i)
{
	if (!m_pRoot)
		return;
	m_pRoot->m_nChildIndent = i;
	SetDirty();
}

int CFlexTree::GetRootChildIndent() const
{
	if (!m_pRoot)
		return 0;
	return m_pRoot->m_nChildIndent;
}

void CFlexTree::SetDefChildIndent(int i)
{
	m_nDefChildIndent = i;
}

int CFlexTree::GetDefChildIndent() const
{
	return m_nDefChildIndent;
}

void CFTItem::PaintInto(HDC hDC)
{
	if (hDC != NULL)
		OnPaint(hDC);
}

LRESULT CFlexTree::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
		case WM_FLEXVSCROLL:
		case WM_FLEXHSCROLL:
		{
			int code = (int)wParam;
			CFlexScrollBar *pSB = (CFlexScrollBar *)lParam;
			if (!pSB)
				return 0;

			int nLine = 5;
			int nPage = MulDiv(pSB->GetPage(), 9, 10);

			switch (code)
			{
				case SB_LINEUP: pSB->AdjustPos(-nLine); break;
				case SB_LINEDOWN: pSB->AdjustPos(nLine); break;
				case SB_PAGEUP: pSB->AdjustPos(-nPage); break;
				case SB_PAGEDOWN: pSB->AdjustPos(nPage); break;
				case SB_THUMBTRACK: pSB->SetPos(pSB->GetThumbPos()); break;
			}

			switch (msg)
			{
				case WM_FLEXHSCROLL:
					m_ptScrollOrigin.x = pSB->GetPos();
					break;

				case WM_FLEXVSCROLL:
					m_ptScrollOrigin.y = pSB->GetPos();
					break;
			}

			Invalidate();
			return 0;
		}

		default:
			return CFlexWnd::WndProc(hWnd, msg, wParam, lParam);
	}
}

void CFlexTree::SetScrollBarColors(COLORREF bk, COLORREF fill, COLORREF line)
{
	m_VertSB.SetColors(bk, fill, line);
	m_HorzSB.SetColors(bk, fill, line);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\idftest.h ===
#ifndef __IDFTEST_H__
#define __IDFTEST_H__


typedef enum _TUI_CONFIGTYPE {
	TUI_CONFIGTYPE_VIEW,
	TUI_CONFIGTYPE_EDIT,
} TUI_CONFIGTYPE;

typedef enum _TUI_VIA {
	TUI_VIA_DI,
	TUI_VIA_CCI,
} TUI_VIA;

typedef enum _TUI_DISPLAY {
	TUI_DISPLAY_GDI,
	TUI_DISPLAY_DDRAW,
	TUI_DISPLAY_D3D,
} TUI_DISPLAY;

typedef struct _TESTCONFIGUIPARAMS {
	DWORD dwSize;
	TUI_VIA eVia;
	TUI_DISPLAY eDisplay;
	TUI_CONFIGTYPE eConfigType;
	int nNumAcFors;
	LPCWSTR lpwszUserNames;
	int nColorScheme;
	BOOL bEditLayout;
	WCHAR wszErrorText[MAX_PATH];
} TESTCONFIGUIPARAMS, FAR *LPTESTCONFIGUIPARAMS;

class IDirectInputConfigUITest : public IUnknown
{
public:
   	//IUnknown fns
	STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv) PURE;
	STDMETHOD_(ULONG, AddRef) () PURE;
	STDMETHOD_(ULONG, Release) () PURE;

	//own fns
	STDMETHOD (TestConfigUI) (LPTESTCONFIGUIPARAMS params) PURE;
};


#endif //__IDFTEST_H__se
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\id3dsurf.h ===
#ifndef __ID3DSURF_H__
#define __ID3DSURF_H__

class IDirect3DSurface8Clone : public IUnknown
{
public:

	//IUnknown
	STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv) PURE;
	STDMETHOD_(ULONG, AddRef) () PURE;
	STDMETHOD_(ULONG, Release) () PURE;

	// Surface
	STDMETHOD (SetPrivateData) (REFGUID riid, 
														CONST VOID   *pvData, 
														DWORD   cbData, 
														DWORD   dwFlags) PURE;

	STDMETHOD (GetPrivateData) (REFGUID riid, 
														VOID   *pvData, 
														DWORD  *pcbData) PURE;

	STDMETHOD (FreePrivateData) (REFGUID riid) PURE;

	STDMETHOD (GetContainer) (REFIID riid, 
													void **ppContainer) PURE;

	STDMETHOD (GetDevice) (IDirect3DDevice8 **ppDevice) PURE;

	STDMETHOD_(D3DSURFACE_DESC, GetDesc)() PURE;

	STDMETHOD (LockRect)(D3DLOCKED_RECT  *pLockedRectData, 
											CONST RECT      *pRect, 
											DWORD            dwFlags) PURE;

	STDMETHOD (UnlockRect)() PURE;
};

IDirect3DSurface8 *GetCloneSurface(int iWidth, int iHeight);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\ipageclassfact.cpp ===
//-----------------------------------------------------------------------------
// File: ipageclassfact.cpp
//
// Desc: Implements the class factory for the page object.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


//QI
STDMETHODIMP CPageFactory::QueryInterface(REFIID riid, LPVOID* ppv)
{
	//null the put parameter
	*ppv = NULL;

	if ((riid == IID_IUnknown) || (riid == IID_IClassFactory))
	{
		*ppv = this;
		AddRef();
		return S_OK;
	}

	return E_NOINTERFACE;

}



//AddRef
STDMETHODIMP_(ULONG) CPageFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}


//Release
STDMETHODIMP_(ULONG) CPageFactory::Release()
{

	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this;
		return 0;
	}

	return m_cRef;
}


//CreateInstance
STDMETHODIMP CPageFactory::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID *ppv)
{
	HRESULT hr = S_OK;

	//can't aggregate
	if (pUnkOuter != NULL)
	{
		return CLASS_E_NOAGGREGATION;
	}

	//create component
	CDIDeviceActionConfigPage* pFE = new CDIDeviceActionConfigPage();
	if (pFE == NULL)
	{
		return E_OUTOFMEMORY;
	}

	//get the requested interface
	hr = pFE->QueryInterface(riid, ppv);

	//release IUnknown
	pFE->Release();
	return hr;

}


//LockServer
STDMETHODIMP CPageFactory::LockServer(BOOL bLock)
{
	HRESULT hr = S_OK;
	if (bLock)
	{
		InterlockedIncrement(&g_cServerLocks);
	}
	else
	{
		InterlockedDecrement(&g_cServerLocks);
	}

	return hr;
}


//constructor
CPageFactory::CPageFactory()
{
	m_cRef = 1;
}


//destructor
CPageFactory::~CPageFactory()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\ifrmwrk.h ===
//-----------------------------------------------------------------------------
// File: ifrmwrk.h
//
// Desc: Contains the interface definition for the UI framework.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef _IFRMWRK_H
#define _IFRMWRK_H


class IDirectInputActionFramework : public IUnknown
{
public:
	//IUnknown fns
	STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv) PURE;
	STDMETHOD_(ULONG, AddRef) () PURE;
	STDMETHOD_(ULONG, Release) () PURE;

	//own fns
	STDMETHOD (ConfigureDevices) (LPDICONFIGUREDEVICESCALLBACK lpdiCallback,
	                              LPDICONFIGUREDEVICESPARAMSW  lpdiCDParams,
	                              DWORD                        dwFlags,
	                              LPVOID                       pvRefData
	                              ) PURE;

};
#endif // _IFRMWRK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\idiacpage.h ===
//-----------------------------------------------------------------------------
// File: idiacpage.h
//
// Desc: IDIDeviceActionConfigPage is a COM interface for
//       CDIDeviceActionConfigPage.  CConfigWnd uses this interface to access
//       the pages in UI.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __IDIACPAGE_H__
#define __IDIACPAGE_H__


typedef struct _DICFGPAGECREATESTRUCT {

	DWORD dwSize;

	int nPage;

	HWND hParentWnd;
	RECT rect;
	HWND hPageWnd;	// out

	DIDEVICEINSTANCEW didi;
	LPDIRECTINPUTDEVICE8W lpDID;

	CUIGlobals *pUIGlobals;
	IDIConfigUIFrameWindow *pUIFrame;

} DICFGPAGECREATESTRUCT;


class IDIDeviceActionConfigPage : public IUnknown
{
public:

	//IUnknown fns
	STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv) PURE;
	STDMETHOD_(ULONG, AddRef) () PURE;
	STDMETHOD_(ULONG, Release) () PURE;

	//IDirectInputActionConfigPage
	STDMETHOD (Create) (DICFGPAGECREATESTRUCT *pcs) PURE;
	STDMETHOD (Show) (LPDIACTIONFORMATW lpDiActFor) PURE;
	STDMETHOD (Hide) () PURE;

	// layout edit mode
	STDMETHOD (SetEditLayout) (BOOL bEditLayout) PURE;

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	// Write layout to IHV setting file
	STDMETHOD (WriteIHVSetting) () PURE;
#endif
//@@END_MSINTERNAL

	// Set the info box text
	STDMETHOD (SetInfoText) (int iCode) PURE;

	// Unacquire and Reacquire the device for page's purposes
	// (the configwnd needs to do this around SetActionMap() calls)
	STDMETHOD (Unacquire) () PURE;
	STDMETHOD (Reacquire) () PURE;
};


#endif //__IDIACPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\ipageclassfact.h ===
//-----------------------------------------------------------------------------
// File: ipageclassfact.h
//
// Desc: Implements the class factory for the page object.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef _IPAGECLASSFACT_H
#define _IPAGECLASSFACT_H


class CPageFactory : public IClassFactory
{
public:

	//IUnknown
	STDMETHOD (QueryInterface) (REFIID riid, LPVOID* ppv);
	STDMETHOD_(ULONG, AddRef) ();
	STDMETHOD_(ULONG, Release) ();

	//IClassFactory
	STDMETHOD (CreateInstance) (IUnknown* pUnkOuter, REFIID riid, LPVOID* ppv);
	STDMETHOD (LockServer) (BOOL bLock);

	//constructor/destructor
	CPageFactory();
	~CPageFactory();

protected:
	LONG m_cRef;
};


#endif // _IPAGECLASSFACT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\itestclassfact.cpp ===
#include "common.hpp"


//QI
STDMETHODIMP CTestFactory::QueryInterface(REFIID riid, LPVOID* ppv)
{
	//null the put parameter
	*ppv = NULL;

	if ((riid == IID_IUnknown) || (riid == IID_IClassFactory))
	{
	   *ppv = this;
	   AddRef();
	   return S_OK;
	}

	return E_NOINTERFACE;

}



//AddRef
STDMETHODIMP_(ULONG) CTestFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}							


//Release
STDMETHODIMP_(ULONG) CTestFactory::Release()
{

	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this;
		return 0;
	}

	return m_cRef;
}


//CreateInstance
STDMETHODIMP CTestFactory::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID *ppv)
{
	HRESULT hr = S_OK;

	//can't aggregate
	if (pUnkOuter != NULL)
	{
		return CLASS_E_NOAGGREGATION;
	}

	//create component
	CDirectInputConfigUITest* pFE = new CDirectInputConfigUITest();
	if (pFE == NULL)
	{
		return E_OUTOFMEMORY;
	}

	//get the requested interface
	hr = pFE->QueryInterface(riid, ppv);

	//release IUnknown
	pFE->Release();
	return hr;

}


//LockServer
STDMETHODIMP CTestFactory::LockServer(BOOL bLock)
{
	HRESULT hr = S_OK;
	if (bLock)
	{
		InterlockedIncrement(&g_cServerLocks);
	}
	else
	{
		InterlockedDecrement(&g_cServerLocks);
	}

	return hr;
}


//constructor
CTestFactory::CTestFactory()
{
	m_cRef = 1;
}


//destructor
CTestFactory::~CTestFactory()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\makefile.inc ===
!if $(AXP64)
GUID_CPL_OPTIONS=/cpl_opt:" /qap64"
!else
GUID_CPL_OPTIONS=
!endif

$O\diguid.lib: ..\dinputpr.h ..\dinput.w ..\dinputd.w
    guidlib /OUT:$@ $(GUID_CPL_OPTIONS) /CPP_OPT:"-DINITGUID -DGUIDLIB -I$(SDK_INC_PATH) -I$(UMINCL)" ..\dinputpr.h

$(O)\guids.obj: ..\guids.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\itestclassfact.h ===
#ifndef __ITESTCLASSFACT_H__
#define __ITESTCLASSFACT_H__


class CTestFactory : public IClassFactory
{
public:

	//IUnknown
	STDMETHOD (QueryInterface) (REFIID riid, LPVOID* ppv);
	STDMETHOD_(ULONG, AddRef) ();
	STDMETHOD_(ULONG, Release) ();

	//IClassFactory
	STDMETHOD (CreateInstance) (IUnknown* pUnkOuter, REFIID riid, LPVOID* ppv);
	STDMETHOD (LockServer) (BOOL bLock);

	//constructor/destructor
	CTestFactory();
	~CTestFactory();

protected:
	LONG m_cRef;
};


#endif //__ITESTCLASSFACT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\ltrace.h ===
#ifndef __LTRACE_H__
#define __LTRACE_H__


#define NO_LTRACE


/*#ifndef NO_LTRACE
#ifdef NDEBUG
#error I want ltrace!
#define NO_LTRACE
#endif
#endif*/


#ifndef NO_LTRACE


#ifndef THIS_FILE
const TCHAR THIS_FILE[] = __FILE__;
#endif


class __CLTraceScope
{
public:
	__CLTraceScope(LPCTSTR, LPCTSTR, int);
	__CLTraceScope(LPCTSTR, int);
	~__CLTraceScope();

	void scope(LPCTSTR, ...);
	void ltrace(LPCTSTR, ...);

private:
	LPCTSTR spacing();
	LPCTSTR m_scope, m_file;
	int m_line;
	int m_depth;
	static int s_depth;
//	__CLTraceScope *m_pprev, *m_pnext;
//	static __CLTraceScope *s_pfirst, *s_plast;
};


#define LTSCOPE0(scope) __CLTraceScope __localscope(scope, THIS_FILE, __LINE__)
#define LTSCOPE __CLTraceScope __localscope(THIS_FILE, __LINE__); __localscope.scope
#define LTRACE __localscope.ltrace


#else


inline void __localscope_dummy(LPCTSTR, ...) {}

#define LTSCOPE0(scope) (void(0))
#define LTSCOPE ; __localscope_dummy
#define LTRACE __localscope_dummy


#endif


#endif //__LTRACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\ltrace.cpp ===
#include "common.hpp"


#ifndef NO_LTRACE


int __CLTraceScope::s_depth = 0;

static const int g_LTRACEBUFLEN = 2048;
static TCHAR g_buf[g_LTRACEBUFLEN];
static TCHAR g_buf2[g_LTRACEBUFLEN];


void __trace(LPCTSTR format, ...)
{
	va_list args;
	va_start(args, format);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,Format);						// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))			// find each %p
			*(psz+1) = 'x';							// replace each %p with %x
		_vstprintf(g_buf2, szDfs, args);    		// use the local format string
	}
#else
	{
		_vstprintf(g_buf2, format, args);
	}
#endif
	va_end(args);
	OutputDebugString((LPCTSTR)g_buf2);
}

__CLTraceScope::__CLTraceScope(LPCTSTR scope, LPCTSTR file, int line) :
	m_scope(NULL), m_file(file), m_line(line), m_depth(s_depth++)
{
	__trace(_T("{LTF}\t%s{ %s\n"), spacing(), scope);
}

__CLTraceScope::__CLTraceScope(LPCTSTR file, int line) :
	m_scope(NULL), m_file(file), m_line(line), m_depth(s_depth++)
{
}

__CLTraceScope::~__CLTraceScope()
{
	s_depth--;
	__trace(_T("{LTF}\t%s}\n"), spacing());
}

void __CLTraceScope::ltrace(LPCTSTR format, ...)
{
	va_list args;
	va_start(args, format);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,format);					// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))		// find each %p
			*(psz+1) = 'x';						// replace each %p with %x
		_vstprintf(g_buf, szDfs, args);   		// use the local format string
	}
#else
	{
		_vstprintf(g_buf, format, args);
	}
#endif
	va_end(args);
	__trace(_T("{LTF}\t%s|- %s\n"), spacing(), g_buf);
}

void __CLTraceScope::scope(LPCTSTR format, ...)
{
	va_list args;
	va_start(args, format);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,format);						// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))			// find each %p
			*(psz+1) = 'x';							// replace each %p with %x
		_vstprintf(g_buf, szDfs, args);	   		// use the local format string
	}
#else
	{
		_vstprintf(g_buf, format, args);
	}
#endif
	va_end(args);
	__trace(_T("{LTF}\t%s{ %s\n"), spacing(), g_buf);
}

LPCTSTR __CLTraceScope::spacing()
{
	const int SPACINGCHAR = _T(' ');
	const int SPACERSPERDEPTH = 3;
	const int DEPTHCHAR = _T('|');
	const int MINSPACING = 1;
	const int MAXSPACING = 128;
	static TCHAR space[MAXSPACING + 1], backup[MAXSPACING + 1];
	static bool sinit = false;
	if (!sinit)
	{
		for (int i = 0; i < MAXSPACING;)
		{
			for (int s = 0; s < SPACERSPERDEPTH && i < MAXSPACING; s++)
				space[i++] = SPACINGCHAR;
			if (i >= MAXSPACING)
				break;
			space[i++] = DEPTHCHAR;
		}
		space[MAXSPACING] = 0;
		strcpy(backup, space);
		sinit = true;
	}
	else
		strcpy(space, backup);	// todo: this can be greatly optimized :)
	int zat = (MINSPACING + m_depth) * (SPACERSPERDEPTH + 1) - 1;
	if (zat > MAXSPACING)
		zat = MAXSPACING;
	space[zat] = 0;
	return space;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\main.h ===
//-----------------------------------------------------------------------------
// File: main.h
//
// Desc: Contains global data and DllMain.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __CFGUI_MAIN_H__
#define __CFGUI_MAIN_H__


extern HMODULE g_hModule;
extern long g_cComponents;
extern long g_cServerLocks;


#endif //__CFGUI_MAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\ourguids.h ===
//-----------------------------------------------------------------------------
// File: ourguids.h
//
// Desc: Contains the definitions of the UI's GUIDs.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __CFGUI_OURGUIDS_H__
#define __CFGUI_OURGUIDS_H__


#include <objbase.h>

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
#ifdef DBG
// {0A484F30-956C-43d0-A5C9-587E2B2EA910}
DEFINE_GUID(IID_IDirectInputConfigUITest, 
0xa484f30, 0x956c, 0x43d0, 0xa5, 0xc9, 0x58, 0x7e, 0x2b, 0x2e, 0xa9, 0x10);

// {EF727FB5-EC99-4c67-B3F7-93B54CC425A2}
DEFINE_GUID(CLSID_CDirectInputConfigUITest, 
0xef727fb5, 0xec99, 0x4c67, 0xb3, 0xf7, 0x93, 0xb5, 0x4c, 0xc4, 0x25, 0xa2);
#endif
#endif
//@@END_MSINTERNAL

// {F4279160-608F-11d3-8FB2-00C04F8EC627}
DEFINE_GUID(IID_IDIActionFramework, 
0xf4279160, 0x608f, 0x11d3, 0x8f, 0xb2, 0x0, 0xc0, 0x4f, 0x8e, 0xc6, 0x27);

// {9F34AF20-6095-11d3-8FB2-00C04F8EC627}
DEFINE_GUID(CLSID_CDirectInputActionFramework, 
0x9f34af20, 0x6095, 0x11d3, 0x8f, 0xb2, 0x0, 0xc0, 0x4f, 0x8e, 0xc6, 0x27);

// {72BB1241-5CA8-11d3-8FB2-00C04F8EC627}
DEFINE_GUID(IID_IDIDeviceActionConfigPage, 
0x72bb1241, 0x5ca8, 0x11d3, 0x8f, 0xb2, 0x0, 0xc0, 0x4f, 0x8e, 0xc6, 0x27);

// {18AB439E-FCF4-40d4-90DA-F79BAA3B0655}
DEFINE_GUID(CLSID_CDIDeviceActionConfigPage, 
0x18ab439e, 0xfcf4, 0x40d4, 0x90, 0xda, 0xf7, 0x9b, 0xaa, 0x3b, 0x6, 0x55);


#endif //__CFGUI_OURGUIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\iuiframe.h ===
//-----------------------------------------------------------------------------
// File: iuiframe.h
//
// Desc: Defines the interface of IDIConfigUIFrameWindow, which is used by
//       CConfigWnd.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __IUIFRAME_H__
#define __IUIFRAME_H__


class IDIConfigUIFrameWindow
{
public:
	// Reset Entire Configuration
	STDMETHOD (Reset) () PURE;

	// Assignment Querying.  GuidInstance is the guid of the device initiating the query.
	STDMETHOD (QueryActionAssignedAnywhere) (GUID GuidInstance, int i) PURE;

	// Genre Control
	STDMETHOD_(int, GetNumGenres) () PURE;
	STDMETHOD (SetCurGenre) (int i) PURE;
	STDMETHOD_(int, GetCurGenre) () PURE;

	// User Control
	STDMETHOD_(int, GetNumUsers) () PURE;
	STDMETHOD (SetCurUser) (int nPage, int nUser) PURE;
	STDMETHOD_(int, GetCurUser) (int nPage) PURE;

	// ActionFormat Access
	STDMETHOD (GetActionFormatFromInstanceGuid) (LPDIACTIONFORMATW *lplpAcFor, REFGUID) PURE;

	// Main HWND Access
	STDMETHOD_(HWND, GetMainHWND) () PURE;
};


#endif //__IUIFRAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\pagecommon.h ===
#ifndef __PAGECOMMON_H_RECURSE__


	#ifndef __PAGECOMMON_H__
	#define __PAGECOMMON_H__


		// recurse into this header to get forward declarations first,
		// then full definitions

		#define __PAGECOMMON_H_RECURSE__

		#define FORWARD_DECLS
		#include "pagecommon.h"

		#undef FORWARD_DECLS
		#include "pagecommon.h"

		#undef __PAGECOMMON_H_RECURSE__


	#endif //__PAGECOMMON_H__


#else // __PAGECOMMON_H_RECURSE__


	// class includes in non-pointer dependency order
	#include "cdeviceui.h"
	#include "cdeviceview.h"
	#include "cdeviceviewtext.h"
	#include "cdevicecontrol.h"
	#include "populate.h"
	#include "selcontroldlg.h"
	#include "viewselwnd.h"
	#include "cdiacpage.h"


#endif // __PAGECOMMON_H_RECURSE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\main.cpp ===
//-----------------------------------------------------------------------------
// File: main.cpp
//
// Desc: Contains global data and DllMain.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


HMODULE g_hModule = NULL;
long g_cComponents = 0;
long g_cServerLocks = 0;

//exported fns

//can unload?
STDAPI DllCanUnloadNow()
{
	if ((g_cComponents == 0)	 && (g_cServerLocks == 0))
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


//get class factory
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{

	HRESULT hr = S_OK;

	//check which class it is
	if ((rclsid != CLSID_CDirectInputActionFramework)
	    && (rclsid != CLSID_CDIDeviceActionConfigPage)
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
#ifdef DBG
	    && (rclsid != CLSID_CDirectInputConfigUITest)
#endif
#endif
//@@END_MSINTERNAL
	   )
	{
		return CLASS_E_CLASSNOTAVAILABLE;
	}

	//create the appropriate class factory
	IClassFactory* pFact = NULL;

	if (rclsid == CLSID_CDirectInputActionFramework)
		pFact = new CFactory();

	if (rclsid == CLSID_CDIDeviceActionConfigPage)
		pFact = new CPageFactory();

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
#ifdef DBG
	if (rclsid == CLSID_CDirectInputConfigUITest)
		pFact = new CTestFactory();
#endif
#endif
//@@END_MSINTERNAL

	if (pFact == NULL)
		return E_OUTOFMEMORY;

	hr = pFact->QueryInterface(riid, ppv);
	pFact->Release();

	return hr;
}


//dll module information
BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)
{
	switch(dwReason)
	{
		case DLL_PROCESS_ATTACH:
			g_hModule = (HMODULE)hModule;
			CFlexWnd::RegisterWndClass((HINSTANCE)hModule);

			break;

		case DLL_PROCESS_DETACH:
			CFlexWnd::UnregisterWndClass((HINSTANCE)hModule);
			break;
	}

	return TRUE;
}


//server registration
STDAPI DllRegisterServer()
{
	HRESULT hr1 = S_OK, hr2 = S_OK, hr3 = S_OK;

	hr1 = RegisterServer(g_hModule, CLSID_CDirectInputActionFramework, _T("CLSID_CDirectInputActionFramework"), _T("DIACTFRM"), _T("DIACTFRM.1"));
	hr2 = RegisterServer(g_hModule, CLSID_CDIDeviceActionConfigPage, _T("CLSID_CDIDeviceActionConfigPage"), _T("DIACTFRM"), _T("DIACTFRM.1"));
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
#ifdef DBG
	hr3 = RegisterServer(g_hModule,	CLSID_CDirectInputConfigUITest, _T("CLSID_CDirectInputConfigUITest"), _T("DIACTFRM"), _T("DIACTFRM.1"));
#endif
#endif
//@@END_MSINTERNAL

	if (FAILED(hr1))
		return hr1;

	if (FAILED(hr2))
		return hr2;

	if (FAILED(hr3))
		return hr3;

	return S_OK;
}

//server unregistration
STDAPI DllUnregisterServer()
{
	HRESULT hr1 = S_OK, hr2 = S_OK, hr3 = S_OK;

	hr1 = UnregisterServer(CLSID_CDirectInputActionFramework, _T("DIACTFRM"), _T("DIACTFRM.1"));
	hr2 = UnregisterServer(CLSID_CDIDeviceActionConfigPage, _T("DIACTFRM"), _T("DIACTFRM.1"));
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
#ifdef DBG
	hr3 = UnregisterServer(CLSID_CDirectInputConfigUITest, _T("DIACTFRM"), _T("DIACTFRM.1"));
#endif
#endif
//@@END_MSINTERNAL

	if (FAILED(hr1))
		return hr1;

	if (FAILED(hr2))
		return hr2;

	if (FAILED(hr3))
		return hr3;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\privcom.h ===
#ifndef __PRIVCOM_H__
#define __PRIVCOM_H__


HRESULT
PrivCreateInstance(REFCLSID ptszClsid, LPUNKNOWN punkOuter, DWORD dwClsContext, 
                   REFIID riid, LPVOID *ppvOut, HINSTANCE *phinst);

HRESULT
PrivGetClassObject(REFCLSID ptszClsid, DWORD dwClsContext, LPVOID pReserved,
                   REFIID riid, LPVOID *ppvOut, HINSTANCE *phinst);


#endif //__PRIVCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\populate.cpp ===
//-----------------------------------------------------------------------------
// File: populate.cpp
//
// Desc: This file contains the population functions.  These are all
//       accessed through PopulateAppropriately().  That function creates
//       views & controls based on the type of the device that the passed
//       DeviceUI represents.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


// these functions are internal to this filed, called only by
// PopulateAppropriately().
HRESULT PopulateViaGetImageInfo(CDeviceUI &ui);
HRESULT PopulateFromImageInfoHeader(CDeviceUI &ui, const DIDEVICEIMAGEINFOHEADERW &);
HRESULT PopulateListView(CDeviceUI &ui);
HRESULT PopulateErrorView(CDeviceUI &ui);


// Clears the entire passed DeviceUI, then fills it with views and
// controls based on device type.  Tries to gaurantee that there will
// be at least one view.
HRESULT PopulateAppropriately(CDeviceUI &ui)
{
	HRESULT hr = S_OK;

	// first empty the ui
	ui.Unpopulate();

	// get device type
	DWORD dwdt = ui.m_didi.dwDevType;
	DWORD dwType = (DWORD)(LOBYTE(LOWORD(dwdt)));
	DWORD dwSubType = (DWORD)(HIBYTE(LOWORD(dwdt)));

	// based on type...
	switch (dwType)
	{
		default:
			// unless its a type we don't ever want views for,
			// populate via the GetImageInfo() API
			hr = PopulateViaGetImageInfo(ui);
			if (SUCCEEDED(hr) && ui.GetNumViews() > 0)
				return hr;

			// if it failed or resulted in nothing,
			// clear anything that might've been added
			ui.Unpopulate();

			// intentional fallthrough

		case DI8DEVTYPE_MOUSE:
		case DI8DEVTYPE_KEYBOARD:
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
			// don't do list view if we're in edit layout mode
			if (ui.m_uig.QueryAllowEditLayout())
				goto doerrorview;

#endif
//@@END_MSINTERNAL
			// for types that we don't ever want views for
			// we populate the list view without trying the above
			hr = PopulateListView(ui);
			
			// if we still failed or don't have any views,
			// populate with error message view
			if (FAILED(hr) || ui.GetNumViews() < 1)
			{
				// empty
				ui.Unpopulate();

				// show error message
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
doerrorview:
#endif
//@@END_MSINTERNAL
				hr = PopulateErrorView(ui);
			}

			// this function should guarantee success
			assert(!FAILED(hr));

			return hr;
	}
}

// Calls the GetImageInfo() API to get the view images and controls
// for the entire device, and returns a failure if there's the
// slightest problem (if GII() fails, or if an image fails to load,
// etc.)
HRESULT PopulateViaGetImageInfo(CDeviceUI &ui)
{
	if (!ui.m_lpDID)
		return E_FAIL;

	HRESULT hr = S_OK;

	DIDEVICEIMAGEINFOHEADERW m_diImgInfoHdr;
	LPDIDEVICEIMAGEINFOW &lprgdiImgData = m_diImgInfoHdr.lprgImageInfoArray;

	ZeroMemory( &m_diImgInfoHdr, sizeof(DIDEVICEIMAGEINFOHEADERW) );
	m_diImgInfoHdr.dwSize = sizeof(DIDEVICEIMAGEINFOHEADERW);
	m_diImgInfoHdr.dwSizeImageInfo = sizeof(DIDEVICEIMAGEINFOW);

	// Retrieve the required buffer size.
	hr = ui.m_lpDID->GetImageInfo( &m_diImgInfoHdr );
	if (FAILED(hr))
	{
		etrace1(_T("GetImageInfo() failed while trying to get required buffer size.  hr = 0x%08x\n"), hr);
		return E_FAIL;
	}

	// Allocate the buffer.
	lprgdiImgData = (LPDIDEVICEIMAGEINFOW) malloc( (size_t)
		(m_diImgInfoHdr.dwBufferSize = m_diImgInfoHdr.dwBufferUsed) );
	if (lprgdiImgData == NULL)
	{
		etrace1(_T("Could not allocate buffer of size %d.\n"), m_diImgInfoHdr.dwBufferSize);
		return E_FAIL;
	}

	trace(_T("Allocated buffer.\n"));
	traceDWORD(m_diImgInfoHdr.dwBufferSize);

	m_diImgInfoHdr.lprgImageInfoArray = lprgdiImgData;

	// Get the display info.
	hr = ui.m_lpDID->GetImageInfo( &m_diImgInfoHdr );
	if (FAILED(hr))
	{
		etrace1(_T("GetImageInfo() failed trying to get image info.  hr = 0x%08x\n"), hr);
		free(lprgdiImgData);
		lprgdiImgData = NULL;
		return E_FAIL;
	}

	// actually populate now
	traceDWORD(m_diImgInfoHdr.dwBufferUsed);
	hr = PopulateFromImageInfoHeader(ui, m_diImgInfoHdr);
	if (FAILED(hr))
		return hr;

	// free stuff
	free(lprgdiImgData);
	lprgdiImgData = NULL;

	return S_OK;
}

// basically does the work for the above function after the header
// is actually retrieved
HRESULT PopulateFromImageInfoHeader(CDeviceUI &ui, const DIDEVICEIMAGEINFOHEADERW &dih)
{
	tracescope(ts1, _T("CGetImageInfoPopHelper::Init()...\n"));

	traceDWORD(dih.dwSizeImageInfo);
	traceDWORD(dih.dwBufferSize);
	traceDWORD(dih.dwBufferUsed);

	if (dih.dwSizeImageInfo != sizeof(DIDEVICEIMAGEINFOW))
	{
		etrace(_T("dwSizeImageInfo Incorrect.\n"));
		assert(0);
		return E_FAIL;
	}
	DWORD dwNumElements = dih.dwBufferUsed / dih.dwSizeImageInfo;
	if (dwNumElements * dih.dwSizeImageInfo != dih.dwBufferUsed
		|| dih.dwBufferUsed < dih.dwBufferSize)
	{
		etrace(_T("Could not confidently calculate dwNumElements.\n"));
		assert(0);
		return E_FAIL;
	}

	DWORD i;

	traceDWORD(dwNumElements);

	bidirlookup<DWORD, int> offset_view;

	{
		tracescope(ts2, _T("First Pass...\n"));

		for (i = 0; i < dwNumElements; i++)
			if (dih.lprgImageInfoArray[i].dwFlags & DIDIFT_CONFIGURATION)
			{
				LPDIDEVICEIMAGEINFOW lpInfoBase = dih.lprgImageInfoArray;
				DWORD index = i;
				{
					tracescope(ts1, _T("AddViewInfo()...\n"));
					traceHEXPTR(lpInfoBase);
					traceDWORD(index);

					if (lpInfoBase == NULL)
					{
						etrace(_T("lpInfoBase NULL\n"));
						return E_FAIL;
					}

					DIDEVICEIMAGEINFOW &info = lpInfoBase[index];
					DWORD dwOffset = index;

					// add view info to array
					CDeviceView *pView = ui.NewView();
					if (!pView)
					{
						etrace(_T("Could not create new view.\n"));
						return E_FAIL;
					}
					int nView = pView->GetViewIndex();

					tracescope(ts2, _T("Adding View "));
					trace2(_T("%d (info index %u)\n"), nView, index);

					// set view's imagepath
					if (!info.tszImagePath)
					{
						etrace(_T("No image path.\n"));
						return E_FAIL;
					}
					LPTSTR tszImagePath = AllocLPTSTR(info.tszImagePath);
					if (!tszImagePath)
					{
						etrace(_T("Could not copy image path.\n"));
						return E_FAIL;
					}

					// set the view's image path
					pView->SetImagePath(tszImagePath);

					// create bitmap from path
					LPDIRECT3DSURFACE8 lpSurf3D = ui.m_uig.GetSurface3D();
					CBitmap *pbm = CBitmap::CreateViaD3DX(tszImagePath, lpSurf3D);
					traceSTR(info.tszImagePath);
					traceHEXPTR(pbm);
					traceDWORD(dwOffset);
					free(tszImagePath);
					tszImagePath = NULL;
					if (lpSurf3D)
					{
						lpSurf3D->Release();  // Need to free the surface instance after we are done as AddRef() was called earlier.
						lpSurf3D = NULL;
					}
					if (!pbm)
					{
						etrace(_T("Could not create image from path.\n"));
						return E_FAIL;
					}

					// set the view's image
					assert(pbm != NULL);
					pView->SetImage(pbm);	// setimage steals the bitmap pointer
					assert(pbm == NULL);

					// add conversion from offset to view
					offset_view.add(dwOffset, nView);
				}
			}
	}

	{
		tracescope(ts2, _T("Second Pass...\n"));

		for (i = 0; i < dwNumElements; i++)
		{
			DWORD dwFlags = dih.lprgImageInfoArray[i].dwFlags;

			if (dwFlags & DIDIFT_OVERLAY)
			{
				LPDIDEVICEIMAGEINFOW lpInfoBase = dih.lprgImageInfoArray;
				DWORD index = i;
				{
					tracescope(ts1, _T("AddControlInfo()...\n"));
					traceHEXPTR(lpInfoBase);
					traceDWORD(index);

					if (lpInfoBase == NULL)
					{
						etrace(_T("lpInfoBase NULL\n"));
						return E_FAIL;
					}

					DIDEVICEIMAGEINFOW &info = lpInfoBase[index];

					int nViewIndex = 0;
					
					if (!offset_view.getright(info.dwViewID, nViewIndex))
					{
						etrace(_T("Could not get view index\n"));
						return E_FAIL;
					}

					if (nViewIndex < 0 || nViewIndex >= ui.GetNumViews())
					{
						etrace1(_T("Invalid view index %d\n"), nViewIndex);
						return E_FAIL;
					}

					CDeviceView *pView = ui.GetView(nViewIndex);
					if (!pView)
					{
						etrace1(_T("\n"), nViewIndex);
						return E_FAIL;
					}

					CDeviceControl *pControl = pView->NewControl();
					if (!pControl)
					{
						etrace1(_T("\n"), nViewIndex);
						return E_FAIL;
					}
					int nControl = pControl->GetControlIndex();

					tracescope(ts2, _T("Adding Control "));
					trace4(_T("%d (info index %u) to view %d (info index %u)\n"), nControl, index, nViewIndex, info.dwViewID);

					traceDWORD(info.dwObjID);
					traceDWORD(info.dwcValidPts);
					traceRECT(info.rcCalloutRect);
					traceRECT(info.rcOverlay);
					traceHEX(info.dwTextAlign);
					traceSTR(info.tszImagePath);

					pControl->SetObjID(info.dwObjID);
					pControl->SetLinePoints(int(info.dwcValidPts), info.rgptCalloutLine);
					pControl->SetCalloutMaxRect(info.rcCalloutRect);
					pControl->SetAlignment(info.dwTextAlign);
					if (info.tszImagePath)
					{
						LPTSTR tszOverlayPath = AllocLPTSTR(info.tszImagePath);
						if (tszOverlayPath)
							pControl->SetOverlayPath(tszOverlayPath);
						free(tszOverlayPath);
						tszOverlayPath = NULL;
					}
					pControl->SetOverlayRect(info.rcOverlay);
					pControl->Init();
				}
			}
		}
	}

	return S_OK;
}

// Enumerates the controls on the device and creates one big list
// view for the device.  Fails if it can't enumerate for some reason.
HRESULT PopulateListView(CDeviceUI &ui)
{
	int i;
	HRESULT hr = S_OK;

	// we must have the device interface
	if (!ui.m_lpDID)
		return E_FAIL;

	// create one view
	CDeviceView *pView = ui.NewView();
	if (!pView)
		return E_FAIL;

	// enable scrolling on it
	pView->EnableScrolling();

	// get list of controls
	DIDEVOBJSTRUCT os;
	hr = FillDIDeviceObjectStruct(os, ui.m_lpDID);
	if (FAILED(hr))
		return hr;

	// if there aren't any, fail
	int n = os.nObjects;
	if (n < 1)
		return E_FAIL;

	HDC hDC = CreateCompatibleDC(NULL);
	CPaintHelper ph(ui.m_uig, hDC);
	ph.SetElement(UIE_DEVOBJ);
	// Initially, max width is the width needed for the Control label.
	TCHAR tszHeader[MAX_PATH];
	RECT LabelRect = {0, 0, 0, 0};
	LoadString(g_hModule, IDS_LISTHEADER_CTRL, tszHeader, MAX_PATH);
	DrawText(hDC, tszHeader, -1, &LabelRect, DT_LEFT|DT_NOPREFIX|DT_CALCRECT);
	// run through and create a text for every control to 
	// get the sizing
	POINT origin = {0, 0};
	SIZE max = {LabelRect.right - LabelRect.left, 0};
	for (i = 0; i < n; i++)
	{
		LPTSTR tszName = AllocLPTSTR(os.pdoi[i].tszName);
		CDeviceViewText *pText = pView->AddText(
			(HFONT)ui.m_uig.GetFont(UIE_DEVOBJ),
			ui.m_uig.GetTextColor(UIE_DEVOBJ),
			ui.m_uig.GetBkColor(UIE_DEVOBJ),
			origin,
			tszName);
		free(tszName);
		if (!pText)
		{
			DeleteDC(hDC);
			return E_FAIL;
		}
		SIZE tsize = GetRectSize(pText->GetRect());
		if (tsize.cx > max.cx)
			max.cx = tsize.cx;
		if (tsize.cy > max.cy)
			max.cy = tsize.cy;
	}

	// Find out if we should use one column or two columns if this is a kbd device.
	BOOL bUseTwoColumns = FALSE;
	if (LOBYTE(LOWORD(ui.m_didi.dwDevType)) == DI8DEVTYPE_KEYBOARD &&
	    ((g_sizeImage.cx - DEFAULTVIEWSBWIDTH) >> 1) - max.cx >= MINLISTVIEWCALLOUTWIDTH)
		bUseTwoColumns = TRUE;

	// Do two iterations here.  First one we use two columns for keyboard.  2nd one is
	// run only if the header labels are clipped.  In which case a single column is used.
	for (int iPass = 0; iPass < 2; ++iPass)
	{
		// calculate max callout height based on the two possible fonts
		int cmaxh = 0,
			ch = 2 + GetTextHeight((HFONT)ui.m_uig.GetFont(UIE_CALLOUT)),
			chh = 2 + GetTextHeight((HFONT)ui.m_uig.GetFont(UIE_CALLOUTHIGH));
		if (ch > cmaxh)
			cmaxh = ch;
		if (chh > cmaxh)
			cmaxh = chh;

		// calculate the bigger of text/callout
		int h = 0;
		if (cmaxh > h)
			h = cmaxh;
		if (max.cy > h)
			h = max.cy;

		// calculate vertical offsets of text/callout within max spacing
		int to = (h - max.cy) / 2,
			co = (h - cmaxh) / 2;

		// max width for text is half of the view window
		if (max.cx > ((g_sizeImage.cx - DEFAULTVIEWSBWIDTH) >> 1))
			max.cx = ((g_sizeImage.cx - DEFAULTVIEWSBWIDTH) >> 1);

		// go back through all the controls and place the text while
		// creating the corresponding callouts
		int at = 0;  // Start at second row since first row is used for header. Also half row spacing
		for (i = 0; i < n; i++)
		{
			// reposition the text
			CDeviceViewText *pText = pView->GetText(i);
			if (!pText)
			{
				DeleteDC(hDC);
				return E_FAIL;
			}

			SIZE s = GetRectSize(pText->GetRect());
			if (bUseTwoColumns)
			{
				int iXOffset = i & 1 ? ((g_sizeImage.cx - DEFAULTVIEWSBWIDTH) >> 1) : 0;

				RECT rect = {iXOffset,
							 at + to,
							 max.cx + iXOffset,
							 at + to + s.cy};
				// Get the rectangle that is actually used.
				RECT adjrect = rect;
				if (hDC)
				{
					DrawText(hDC, pText->GetText(), -1, &adjrect, DT_NOPREFIX|DT_CALCRECT);
					// If the rect actually used is smaller than the space available, use the smaller rect and align to right.
					if (adjrect.right < rect.right)
						rect.left += rect.right - adjrect.right;
				}
				pText->SetRect(rect);
			}
			else
			{
				RECT rect = {0, at + to, max.cx /*> ((g_sizeImage.cx - DEFAULTVIEWSBWIDTH) >> 1) ?
							 ((g_sizeImage.cx - DEFAULTVIEWSBWIDTH) >> 1) : max.cx*/, at + to + s.cy};
				pText->SetRect(rect);
			}

			// create the control
			CDeviceControl *pControl = pView->NewControl();
			if (!pControl)
			{
				DeleteDC(hDC);
				return E_FAIL;
			}

			// position it
			RECT rect = {max.cx + 10, at, (g_sizeImage.cx - DEFAULTVIEWSBWIDTH) >> 1, at + h};
			// If single column, extend callout all the way to right end of view window
			if (!bUseTwoColumns)
				rect.right = g_sizeImage.cx - DEFAULTVIEWSBWIDTH;
			// If this is a keyboard, move to right column on odd numbered controls.
			if (bUseTwoColumns && (i & 1))
			{
				rect.left += (g_sizeImage.cx - DEFAULTVIEWSBWIDTH) >> 1;
				rect.right = g_sizeImage.cx - DEFAULTVIEWSBWIDTH;
			}
			pControl->SetCalloutMaxRect(rect);

			// align it
			pControl->SetAlignment(CAF_LEFT);

			// set approp offset
			pControl->SetObjID(os.pdoi[i].dwType);

			// init it
			pControl->Init();

			// go to next y coord
			// If this is a keyboard, then only increase y when we are moving to even numbered controls.
			if (!bUseTwoColumns || (i & 1))
				at += h;
		}

		// Compute the rectangles for header labels
		if (pView->CalculateHeaderRect() && iPass == 0)
		{
			pView->RemoveAll();
			bUseTwoColumns = FALSE;  // Re-calculate the rects using single column.
		}
		else
			break;  // Break out from 2nd iteration
	}
	DeleteDC(hDC);

	// make selection/thumb images (just for kicks)
	pView->MakeMissingImages();

	// calculate view dimensions (for scrolling)
	pView->CalcDimensions();

	return S_OK;
}

// Creates a single view with an error message.  Should not fail.
HRESULT PopulateErrorView(CDeviceUI &ui)
{
	// create the new view
	CDeviceView *pView = ui.NewView();
	if (!pView)
		return E_FAIL;

	// add text objects containing error message
	pView->AddWrappedLineOfText(
		(HFONT)ui.m_uig.GetFont(UIE_ERRORHEADER),
		ui.m_uig.GetTextColor(UIE_ERRORHEADER),
		ui.m_uig.GetBkColor(UIE_ERRORHEADER),
		_T("Error!"));
	pView->AddWrappedLineOfText(
		(HFONT)ui.m_uig.GetFont(UIE_ERRORMESSAGE),
		ui.m_uig.GetTextColor(UIE_ERRORMESSAGE),
		ui.m_uig.GetBkColor(UIE_ERRORMESSAGE),
		_T("Could not create views for device."));

	pView->MakeMissingImages();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\registry.h ===
//-----------------------------------------------------------------------------
// File: registry.h
//
// Desc: Contains COM register and unregister functions for the UI.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __Registry_H__
#define __Registry_H__

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       LPCTSTR szFriendlyName,
                       LPCTSTR szVerIndProgID,
                       LPCTSTR szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         LPCTSTR szVerIndProgID,
                         LPCTSTR szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\populate.h ===
//-----------------------------------------------------------------------------
// File: populate.h
//
// Desc: Implements PopulateAppropriately.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __POPULATE_H__
#define __POPULATE_H__


HRESULT PopulateAppropriately(CDeviceUI &ui);


#endif //__POPULATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\registry.cpp ===
//-----------------------------------------------------------------------------
// File: registry.cpp
//
// Desc: Contains COM register and unregister functions for the UI.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(LPCTSTR pszPath,
                    LPCTSTR szSubkey,
                    LPCTSTR szValue);

// Set named value.
BOOL setNamedValue(LPCTSTR pszPath,
                   LPCTSTR szSubkey,
                   LPCTSTR szKeyName,
                   LPCTSTR szValue);



// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid,
                 LPTSTR szCLSID,
                 int length);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, LPCTSTR szKeyChild);

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,        // DLL module handle
                       const CLSID& clsid,     // Class ID
                       LPCTSTR szFriendlyName, // Friendly Name
                       LPCTSTR szVerIndProgID, // Programmatic
                       LPCTSTR szProgID)       // IDs
{
	// Get server location.
	TCHAR szModule[512];
	DWORD dwResult =
		::GetModuleFileName(hModule,
		                    szModule,
		                    sizeof(szModule)/sizeof(TCHAR));
	if (!dwResult) return E_FAIL;

	// Convert the CLSID into a char.
	TCHAR szCLSID[CLSID_STRING_SIZE];
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)/sizeof(TCHAR));

	// Build the key CLSID\\{...}
	TCHAR szKey[64];
	_tcscpy(szKey, _T("CLSID\\"));
	_tcscat(szKey, szCLSID);

	TCHAR szThreadKey[64];
	_tcscpy(szThreadKey, szKey);
	_tcscat(szThreadKey, _T("\\InProcServer32"));

	// Add the CLSID to the registry.
	setKeyAndValue(szKey, NULL, szFriendlyName);

	// Add the server filename subkey under the CLSID key.
	setKeyAndValue(szKey, _T("InProcServer32"), szModule);

	// Add the threading model subkey under the CLSID key
	setNamedValue(szKey, _T("InProcServer32"), _T("ThreadingModel"), _T("Both"));

	// Add the ProgID subkey under the CLSID key.
	setKeyAndValue(szKey, _T("ProgID"), szProgID);

	// Add the version-independent ProgID subkey under CLSID key.
	setKeyAndValue(szKey, _T("VersionIndependentProgID"),
	               szVerIndProgID);

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szVerIndProgID, NULL, szFriendlyName);
	setKeyAndValue(szVerIndProgID, _T("CLSID"), szCLSID);
	setKeyAndValue(szVerIndProgID, _T("CurVer"), szProgID);

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szProgID, NULL, szFriendlyName);
	setKeyAndValue(szProgID, _T("CLSID"), szCLSID);

	return S_OK;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid,     // Class ID
                      LPCTSTR szVerIndProgID, // Programmatic
                      LPCTSTR szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	TCHAR szCLSID[CLSID_STRING_SIZE];
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)/sizeof(TCHAR));

	// Build the key CLSID\\{...}
	TCHAR szKey[64];
	_tcscpy(szKey, _T("CLSID\\"));
	_tcscat(szKey, szCLSID);

	// Delete the CLSID Key - CLSID\{...}
	LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey);
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)); // Subkey may not exist.

	// Delete the version-independent ProgID Key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID);
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)); // Subkey may not exist.

	// Delete the ProgID key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID);
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)); // Subkey may not exist.

	return S_OK;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
void CLSIDtochar(const CLSID& clsid,
                 LPTSTR szCLSID,
                 int length)
{
	if (length < CLSID_STRING_SIZE)
		return;

	// Get CLSID
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	assert(SUCCEEDED(hr));

	if (!wszCLSID) return;

#ifdef _UNICODE
	_tcsncpy(szCLSID, wszCLSID, length);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szCLSID, wszCLSID, length);
#endif

	// Free memory.
	CoTaskMemFree(wszCLSID);
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,       // Parent of key to delete
                        LPCTSTR lpszKeyChild)  // Key to delete
{
	// Open the child.
	HKEY hKeyChild;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild);
	if (lRes != ERROR_SUCCESS)
	{
		return lRes;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
	       NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = recursiveDeleteKey(hKeyChild, szBuffer);
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild);
			return lRes;
		}
		dwSize = 256;
	}

	// Close the child.
	RegCloseKey(hKeyChild);

	// Delete this child.
	return RegDeleteKey(hKeyParent, lpszKeyChild);
}

//
// Create a key and set its value.
//@@BEGIN_INTERNAL
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//@@END_INTERNAL
//
BOOL setKeyAndValue(LPCTSTR szKey,
                    LPCTSTR szSubkey,
                    LPCTSTR szValue)
{
	HKEY hKey;
	LPTSTR szKeyBuf;

	if (szKey == NULL) return FALSE;

	// Allocate space
	szKeyBuf = new TCHAR[lstrlen(szKey) + lstrlen(szSubkey) + 2];
	if (!szKeyBuf) return FALSE;

	// Copy keyname into buffer.
	_tcscpy(szKeyBuf, szKey);

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
//@@BEGIN_MSINTERNAL
		/*
		/* PREFIX seems to think that there is a bug here (Whistler 171821) 
		/* and that szKeyBuf is uninitilaized -- but we assert that szKey is not NULL
		/* and then initialize szKeyBuf by _tcscpy() above.
		 */
//@@END_MSINTERNAL
		_tcscat(szKeyBuf, _T("\\"));
		_tcscat(szKeyBuf, szSubkey );
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT,
	                              szKeyBuf,
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL,
	                              &hKey, NULL);
	if (lResult != ERROR_SUCCESS)
	{
		delete[] szKeyBuf;
		return FALSE;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueEx(hKey, NULL, 0, REG_SZ,
		              (BYTE *)szValue,
		              sizeof(TCHAR) * ( _tcslen(szValue)+1) );
	}

	RegCloseKey(hKey);
	delete[] szKeyBuf;
	return TRUE;
}


//
// Create a key and set its value.
BOOL setNamedValue(LPCTSTR szKey,
                   LPCTSTR szSubkey,
                   LPCTSTR szKeyName,
                   LPCTSTR szValue)
{
	HKEY hKey;
	LPTSTR szKeyBuf;

	if (szKey == NULL) return FALSE;

	// Allocate space
	szKeyBuf = new TCHAR[lstrlen(szKey) + lstrlen(szSubkey) + 2];
	if (!szKeyBuf) return FALSE;

	// Copy keyname into buffer.
	_tcscpy(szKeyBuf, szKey);

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
//@@BEGIN_MSINTERNAL
		/*
		/* PREFIX seems to think that there is a bug here (Whistler 171820) 
		/* and that szKeyBuf is uninitilaized -- but we assert that szKey is not NULL
		/* and then initialize szKeyBuf by _tcscpy() above.
		 */
//@@END_MSINTERNAL
		_tcscat(szKeyBuf, _T("\\"));
		_tcscat(szKeyBuf, szSubkey );
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT,
	                              szKeyBuf,
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL,
	                              &hKey, NULL);
	if (lResult != ERROR_SUCCESS)
	{
		delete[] szKeyBuf;
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueEx(hKey, szKeyName, 0, REG_SZ,
		              (BYTE *)szValue,
		              sizeof(TCHAR) * ( _tcslen(szValue)+1) );
	}

	RegCloseKey(hKey);
	delete[] szKeyBuf;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\rundftest.cpp ===
#include "common.hpp"


#define TOW(a) L##a


static const GUID g_AppGuid =
{ 0x238d8220, 0x7a5d, 0x11d3, { 0x8f, 0xb2, 0x0, 0xc0, 0x4f, 0x8e, 0xc6, 0x27 } };

static const GUID GUID_DIConfigAppEditLayout = 
{ 0xfd4ace13, 0x7044, 0x4204, { 0x8b, 0x15, 0x9, 0x52, 0x86, 0xb1, 0x2e, 0xad } };


//for axes commands: AXIS_LR and AXIS_UD
#define AXIS_MASK   0x80000000l
#define AXIS_LR     (AXIS_MASK | 1)
#define AXIS_UD     (AXIS_MASK | 2)

// "Keyboard" commands
#define KEY_STOP    0x00000001l
#define KEY_DOWN    0x00000002l
#define KEY_LEFT    0x00000004l
#define KEY_RIGHT   0x00000008l
#define KEY_UP      0x00000010l
#define KEY_FIRE    0x00000020l
#define KEY_THROW   0x00000040l
#define KEY_SHIELD  0x00000080l
#define KEY_DISPLAY 0x00000100l
#define KEY_QUIT    0x00000200l
#define KEY_EDIT    0x00000400l


DIACTIONFORMATW *GetTestActionFormats()
{
static DIACTIONW g_rgGameAction1[] = {
        {AXIS_UD,    DIAXIS_FPS_MOVE, 0, TOW("Forward"),},
        {AXIS_LR,    DIAXIS_FPS_ROTATE, 0, TOW("Rotate"),},
        {KEY_FIRE,   DIBUTTON_FPS_FIRE, 0, TOW("Fire"),},
        {KEY_THROW,  DIBUTTON_FPS_WEAPONS, 0, TOW("Change Weapon"),},
        {KEY_SHIELD, DIBUTTON_FPS_APPLY, 0, TOW("Shield"),},
        {KEY_STOP,   DIBUTTON_FPS_SELECT, 0, TOW("Pause"),},
        {KEY_THROW,  DIBUTTON_FPS_CROUCH, 0, TOW("Hyper space"),},
        {KEY_THROW,  DIBUTTON_FPS_JUMP, 0, TOW("Launch Probe"),},
        {KEY_DISPLAY,DIBUTTON_FPS_DISPLAY, 0, TOW("Display"),},
        {KEY_QUIT,   DIBUTTON_FPS_MENU, 0, TOW("Quit Game"),},
		{KEY_EDIT,   DIBUTTON_FPS_DODGE, 0, TOW("Edit Configuration"),},
        {KEY_LEFT,   DIKEYBOARD_LEFT, 0, TOW("Turn +"),},
        {KEY_RIGHT,  DIKEYBOARD_RIGHT, 0, TOW("Turn -"),},
        {KEY_UP,     DIKEYBOARD_UP, 0, TOW("Move Up"),},
        {KEY_DOWN,   DIKEYBOARD_DOWN, 0, TOW("Move Down"),},
        {KEY_STOP,   DIKEYBOARD_S, 0, TOW("Stop Game"),},
        {KEY_FIRE,   DIKEYBOARD_SPACE, 0, TOW("Shoot"),},
        {KEY_THROW,  DIKEYBOARD_T, 0, TOW("Throw"),},
        {KEY_SHIELD, DIKEYBOARD_H, 0, TOW("Shield"),},
        {KEY_DISPLAY,DIKEYBOARD_D, 0, TOW("Display"),},
        {KEY_QUIT,   DIKEYBOARD_Q, 0, TOW("Quit Game"),},
        {KEY_EDIT,   DIKEYBOARD_E, 0, TOW("Edit Configuration"),},
        {AXIS_LR,    DIMOUSE_XAXIS, 0, TOW("Turn"), },
        {AXIS_UD,    DIMOUSE_YAXIS, 0, TOW("Move"), },
        {KEY_FIRE,   DIMOUSE_BUTTON0, 0, TOW("Fire"), },
        {KEY_SHIELD, DIMOUSE_BUTTON1, 0, TOW("Shield"),},
        {KEY_THROW,  DIMOUSE_BUTTON2, 0, TOW("Change Weapon"),},
        };
const int g_nGameActions1 = sizeof(g_rgGameAction1) / sizeof(DIACTIONW);

static DIACTIONW g_rgGameAction2[] = {
        {AXIS_UD,    DIAXIS_FPS_MOVE, 0, TOW("FORWARD"),},
        {AXIS_LR,    DIAXIS_FPS_ROTATE, 0, TOW("ROTATE"),},
        {KEY_FIRE,   DIBUTTON_FPS_FIRE, 0, TOW("FIRE"),},
        {KEY_SHIELD, DIBUTTON_FPS_APPLY, 0, TOW("SHIELD"),},
        {KEY_STOP,   DIBUTTON_FPS_SELECT, 0, TOW("PAUSE"),},
        {KEY_DISPLAY,DIBUTTON_FPS_DISPLAY, 0, TOW("DISPLAY"),},
        {KEY_QUIT,   DIBUTTON_FPS_MENU, 0, TOW("QUIT GAME"),},
		{KEY_EDIT,   DIBUTTON_FPS_DODGE, 0, TOW("EDIT CONFIGURATION"),},
        {KEY_LEFT,   DIKEYBOARD_LEFT, 0, TOW("TURN +"),},
        {KEY_RIGHT,  DIKEYBOARD_RIGHT, 0, TOW("TURN -"),},
        {KEY_UP,     DIKEYBOARD_UP, 0, TOW("MOVE UP"),},
        {KEY_DOWN,   DIKEYBOARD_DOWN, 0, TOW("MOVE DOWN"),},
        {KEY_STOP,   DIKEYBOARD_S, 0, TOW("STOP GAME"),},
        {KEY_FIRE,   DIKEYBOARD_SPACE, 0, TOW("SHOOT"),},
        {KEY_SHIELD, DIKEYBOARD_H, 0, TOW("SHIELD"),},
        {KEY_DISPLAY,DIKEYBOARD_D, 0, TOW("DISPLAY"),},
        {KEY_QUIT,   DIKEYBOARD_Q, 0, TOW("QUIT GAME"),},
        {KEY_EDIT,   DIKEYBOARD_E, 0, TOW("EDIT CONFIGURATION"),},
        {AXIS_LR,    DIMOUSE_XAXIS, 0, TOW("TURN"), },
        {AXIS_UD,    DIMOUSE_YAXIS, 0, TOW("MOVE"), },
        {KEY_FIRE,   DIMOUSE_BUTTON0, 0, TOW("FIRE"), },
        {KEY_SHIELD, DIMOUSE_BUTTON1, 0, TOW("SHIELD"),},
        };
const int g_nGameActions2 = sizeof(g_rgGameAction2) / sizeof(DIACTIONW);

static DIACTIONW g_rgGameAction3[] = {
        {AXIS_UD,    DIAXIS_FPS_MOVE, 0, TOW("Forward"),},
        {AXIS_LR,    DIAXIS_FPS_ROTATE, 0, TOW("Rotate"),},
        {KEY_FIRE,   DIBUTTON_FPS_FIRE, 0, TOW("Fire"),},
        {KEY_SHIELD, DIBUTTON_FPS_APPLY, 0, TOW("Shield"),},
        {KEY_STOP,   DIBUTTON_FPS_SELECT, 0, TOW("PausePausePausePausePausePausePausePausePausePausePausePausePausePausePausePause"),},
        {KEY_DISPLAY,DIBUTTON_FPS_DISPLAY, 0, TOW("Display"),},
        {KEY_QUIT,   DIBUTTON_FPS_MENU, 0, TOW("Quit Game"),},
        {KEY_LEFT,   DIKEYBOARD_LEFT, 0, TOW("Turn +"),},
        {KEY_RIGHT,  DIKEYBOARD_RIGHT, 0, TOW("Turn -"),},
        {KEY_UP,     DIKEYBOARD_UP, 0, TOW("Move Up"),},
        {KEY_DOWN,   DIKEYBOARD_DOWN, 0, TOW("Move Down"),},
        {KEY_STOP,   DIKEYBOARD_S, 0, TOW("Stop Game"),},
        {KEY_FIRE,   DIKEYBOARD_SPACE, 0, TOW("Shoot"),},
        {KEY_SHIELD, DIKEYBOARD_H, 0, TOW("Shield"),},
        {KEY_DISPLAY,DIKEYBOARD_D, 0, TOW("Display"),},
        {KEY_QUIT,   DIKEYBOARD_Q, 0, TOW("Quit Game"),},
        {AXIS_LR,    DIMOUSE_XAXIS, 0, TOW("Turn"), },
        {AXIS_UD,    DIMOUSE_YAXIS, 0, TOW("Move"), },
        {KEY_FIRE,   DIMOUSE_BUTTON0, 0, TOW("Fire"), },
        {KEY_SHIELD, DIMOUSE_BUTTON1, 0, TOW("Shield"),},
        };
const int g_nGameActions3 = sizeof(g_rgGameAction3) / sizeof(DIACTIONW);

static struct _ACTIONARRAYELEMENT {
	DIACTIONW *rgActions;
	int nActions;
	LPCWSTR name;
} g_rgActionArray[] = {
	{g_rgGameAction1, g_nGameActions1, TOW("Genre 1")},
	{g_rgGameAction2, g_nGameActions2, TOW("Genre 2")},
	{g_rgGameAction3, g_nGameActions3, TOW("Genre 3")},
};
const int g_nActionArrays = sizeof(g_rgActionArray) / sizeof(_ACTIONARRAYELEMENT);

	const int nMaxFormats = g_nActionArrays;
	static DIACTIONFORMATW af[nMaxFormats];

	for (int i = 0; i < nMaxFormats; i++)
	{
		ZeroMemory(&(af[i]), sizeof(DIACTIONFORMATW));

		af[i].dwSize = sizeof(DIACTIONFORMATW);
		af[i].dwActionSize = sizeof(DIACTIONW);
		wcscpy(af[i].tszActionMap, g_rgActionArray[i].name);
		af[i].guidActionMap = g_AppGuid;
        af[i].dwGenre = DIVIRTUAL_FIGHTING_FPS;
		af[i].dwNumActions = (DWORD)g_rgActionArray[i].nActions;
		af[i].dwDataSize = af[i].dwNumActions * sizeof(DWORD);
		af[i].rgoAction = g_rgActionArray[i].rgActions;
		af[i].lAxisMin = -100;
		af[i].lAxisMax	= 100;
		af[i].dwBufferSize = 16;
	}

	return af;
}

HRESULT RunDFTest(LPTESTCONFIGUIPARAMS params)
{
	if (params == NULL || params->dwSize != sizeof(TESTCONFIGUIPARAMS))
		return E_INVALIDARG;

	HRESULT	ret_hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(0);
	LPWSTR wszUserNames = NULL;
	DICONFIGUREDEVICESPARAMSW p;
	DWORD dwFlags = 0;

#define FAIL(e,s) \
	{ \
		CopyStr(params->wszErrorText, s, MAX_PATH); \
		ret_hr = e; \
		goto cleanup; \
	}

	if (params->eDisplay != TUI_DISPLAY_GDI)
		FAIL(E_NOTIMPL, "Only display type GDI is implemented.");
 
	if (params->nNumAcFors < 1 || params->nNumAcFors > 3)
		FAIL(E_INVALIDARG, "Only 1 to 3 Action Formats supported.");

	switch (params->eConfigType)
	{
		case TUI_CONFIGTYPE_VIEW:
			dwFlags |= DICD_DEFAULT;
			break;

		case TUI_CONFIGTYPE_EDIT:
			dwFlags |= DICD_EDIT;
			break;

		default:
			FAIL(E_INVALIDARG, "Unknown ConfigType.");
	}

	ZeroMemory(&p, sizeof(DICONFIGUREDEVICESPARAMSW));
	p.dwSize = sizeof(DICONFIGUREDEVICESPARAMSW);

	ZeroMemory(&p.dics, sizeof(DICOLORSET));
	p.dics.dwSize = sizeof(DICOLORSET);

	switch (params->nColorScheme)
	{
		case 1:
			p.dics.cTextFore = ((D3DCOLOR)RGB(255,255,255));
			p.dics.cTextHighlight = ((D3DCOLOR)RGB(255,150,255));
			p.dics.cCalloutLine = ((D3DCOLOR)RGB(191,191,0));
			p.dics.cCalloutHighlight = ((D3DCOLOR)RGB(255,255,0));
			p.dics.cBorder = ((D3DCOLOR)RGB(0,0,191));
			p.dics.cControlFill = ((D3DCOLOR)RGB(0,127,255));
			p.dics.cHighlightFill = ((D3DCOLOR)RGB(0,0,100));
			p.dics.cAreaFill = ((D3DCOLOR)RGB(0,0,0));
			break;
	}

	if (params->lpwszUserNames != NULL)
	{
		p.dwcUsers = CountSubStrings(params->lpwszUserNames);
		if (p.dwcUsers >= 1)
			wszUserNames = DupSuperString(params->lpwszUserNames);
	}
	else
		p.dwcUsers = 0;

	p.lptszUserNames = wszUserNames;
	p.dwcFormats = (DWORD)params->nNumAcFors;
	p.lprgFormats = GetTestActionFormats();
	if (params->bEditLayout)
		p.lprgFormats[0].guidActionMap = GUID_DIConfigAppEditLayout;
	p.hwnd = NULL;
	//p.dics = ;
	p.lpUnkDDSTarget = NULL;

	switch (params->eVia)
	{
		case TUI_VIA_DI:
		{
			//set up DInput and call ConfigureDevices
			IDirectInput8W* pDInput = NULL;
			DWORD dwVer = DIRECTINPUT_VERSION;
			HRESULT hres = DirectInput8Create(hInstance, dwVer, IID_IDirectInput8W, (LPVOID *)&pDInput, NULL);
			if (FAILED(hres))
				FAIL(hres, "DirectInput8Create() failed.");

			hres = pDInput->ConfigureDevices(NULL, &p, dwFlags, NULL);
			pDInput->Release();
			if (FAILED(hres))
				FAIL(hres, "ConfigureDevices() failed.");

			break;
		}

		case TUI_VIA_CCI:
		{
			IDirectInputActionFramework* pIFrame = NULL;
			HINSTANCE hInst = NULL;
			HRESULT hres = PrivCreateInstance(CLSID_CDirectInputActionFramework, NULL, CLSCTX_INPROC_SERVER, IID_IDIActionFramework, (LPVOID*)&pIFrame, &hInst);
			if (FAILED(hres))
				FAIL(hres, "PrivCreateInstance() failed.");

			hres = pIFrame->ConfigureDevices(NULL, &p, dwFlags, NULL);

			pIFrame->Release();

			if (hInst != NULL)
				FreeLibrary(hInst);
			hInst = NULL;

			if (FAILED(hres))
				FAIL(hres, "ConfigureDevices() failed.");

			break;
		}
			
		default:
			FAIL(E_INVALIDARG, "Unknown Via type.");
	}

cleanup:
	if (wszUserNames != NULL)
		free(wszUserNames);
	wszUserNames = NULL;

	return ret_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\rundftest.h ===
#ifndef __RUNDFTEST_H__
#define __RUNDFTEST_H__


HRESULT RunDFTest(LPTESTCONFIGUIPARAMS params);
DIACTIONFORMATW *GetTestActionFormats();


#endif //__RUNDFTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\privcom.cpp ===
#include "common.hpp"


/*****************************************************************************
 *
 *  privcom.c
 *
 *  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Functions that sort-of duplicate what OLE does.
 *
 *		Adapted from dinput\dx8\dll\dioledup.c
 *
 *****************************************************************************/


    typedef LPUNKNOWN PUNK;
    typedef LPVOID PV, *PPV;
    typedef CONST VOID *PCV;
    typedef REFIID RIID;
    typedef CONST GUID *PCGUID;

    /*
     * Convert an object (X) to a count of bytes (cb).
     */
#define cbX(X) sizeof(X)

    /*
     * Convert an array name (A) to a generic count (c).
     */
#define cA(a) (cbX(a)/cbX(a[0]))

    /*
     * Convert a count of X's (cx) into a count of bytes
     * and vice versa.
     */
#define  cbCxX(cx, X) ((cx) * cbX(X))
#define  cxCbX(cb, X) ((cb) / cbX(X))

    /*
     * Convert a count of chars (cch), tchars (ctch), wchars (cwch),
     * or dwords (cdw) into a count of bytes, and vice versa.
     */
#define  cbCch(cch)  cbCxX( cch,  CHAR)
#define cbCwch(cwch) cbCxX(cwch, WCHAR)
#define cbCtch(ctch) cbCxX(ctch, TCHAR)
#define  cbCdw(cdw)  cbCxX( cdw, DWORD)

#define  cchCb(cb) cxCbX(cb,  CHAR)
#define cwchCb(cb) cxCbX(cb, WCHAR)
#define ctchCb(cb) cxCbX(cb, TCHAR)
#define  cdwCb(cb) cxCbX(cb, DWORD)

// yay
#define ctchGuid    (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

/*****************************************************************************
 *
 *  _ParseHex
 *
 *      Parse a hex string encoding cb bytes (at most 4), then
 *      expect the tchDelim to appear afterwards.  If chDelim is 0,
 *      then no delimiter is expected.
 *
 *      Store the result into the indicated LPBYTE (using only the
 *      size requested), updating it, and return a pointer to the
 *      next unparsed character, or 0 on error.
 *
 *      If the incoming pointer is also 0, then return 0 immediately.
 *
 *****************************************************************************/

LPCTSTR 
    _ParseHex(LPCTSTR ptsz, LPBYTE *ppb, int cb, TCHAR tchDelim)
{
    if(ptsz)
    {
        int i = cb * 2;
        DWORD dwParse = 0;

        do
        {
            DWORD uch;
            uch = (TBYTE)*ptsz - TEXT('0');
            if(uch < 10)
            {             /* a decimal digit */
            } else
            {
                uch = (*ptsz | 0x20) - TEXT('a');
                if(uch < 6)
                {          /* a hex digit */
                    uch += 10;
                } else
                {
                    return 0;           /* Parse error */
                }
            }
            dwParse = (dwParse << 4) + uch;
            ptsz++;
        } while(--i);

        if(tchDelim && *ptsz++ != tchDelim) return 0; /* Parse error */

        for(i = 0; i < cb; i++)
        {
            (*ppb)[i] = ((LPBYTE)&dwParse)[i];
        }
        *ppb += cb;
    }
    return ptsz;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | ParseGUID |
 *
 *          Take a string and convert it into a GUID, return success/failure.
 *
 *  @parm   OUT LPGUID | lpGUID |
 *
 *          Receives the parsed GUID on success.
 *
 *  @parm   IN LPCTSTR | ptsz |
 *
 *          The string to parse.  The format is
 *
 *      { <lt>dword<gt> - <lt>word<gt> - <lt>word<gt>
 *                      - <lt>byte<gt> <lt>byte<gt>
 *                      - <lt>byte<gt> <lt>byte<gt> <lt>byte<gt>
 *                        <lt>byte<gt> <lt>byte<gt> <lt>byte<gt> }
 *
 *  @returns
 *
 *          Returns zero if <p ptszGUID> is not a valid GUID.
 *
 *
 *  @comm
 *
 *          Stolen from TweakUI.
 *
 *****************************************************************************/

BOOL 
    ParseGUID(LPGUID pguid, LPCTSTR ptsz)
{
    if(lstrlen(ptsz) == ctchGuid - 1 && *ptsz == TEXT('{'))
    {
        ptsz++;
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 4, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 2, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 2, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1, TEXT('}'));
        return (BOOL)(UINT_PTR)ptsz;
    } else
    {
        return 0;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegQueryString |
 *
 *          Wrapper for <f RegQueryValueEx> that reads a
 *          string value from the registry.  An annoying quirk
 *          is that on Windows NT, the returned string might
 *          not end in a null terminator, so we might need to add
 *          one manually.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   LPTSTR | ptsz |
 *
 *          Output buffer.
 *
 *  @parm   DWORD | ctchBuf |
 *
 *          Size of output buffer.
 *
 *  @returns
 *
 *          Registry error code.
 *
 *****************************************************************************/

LONG 
    RegQueryString(HKEY hk, LPCTSTR ptszValue, LPTSTR ptszBuf, DWORD ctchBuf)
{
    LONG lRc;
    DWORD reg;

    #ifdef UNICODE
    DWORD cb;

    /*
     *  NT quirk: Non-null terminated strings can exist.
     */
    cb = cbCtch(ctchBuf);
    lRc = RegQueryValueEx(hk, ptszValue, 0, &reg, (LPBYTE)(PV)ptszBuf, &cb);
    if(lRc == ERROR_SUCCESS)
    {
        if(reg == REG_SZ)
        {
            /*
             *  Check the last character.  If it is not NULL, then
             *  append a NULL if there is room.
             */
            DWORD ctch = ctchCb(cb);
            if(ctch == 0)
            {
                ptszBuf[ctch] = TEXT('\0');
            } else if(ptszBuf[ctch-1] != TEXT('\0'))
            {
                if(ctch < ctchBuf)
                {
                    ptszBuf[ctch] = TEXT('\0');
                } else
                {
                    lRc = ERROR_MORE_DATA;
                }
            }
        } else
        {
            lRc = ERROR_INVALID_DATA;
        }
    }


    #else

    /*
     *  This code is executed only on Win95, so we don't have to worry
     *  about the NT quirk.
     */

    lRc = RegQueryValueEx(hk, ptszValue, 0, &reg, (LPBYTE)(PV)ptszBuf, &ctchBuf);

    if(lRc == ERROR_SUCCESS && reg != REG_SZ)
    {
        lRc = ERROR_INVALID_DATA;
    }


    #endif

    return lRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | _CreateInstance |
 *
 *          Worker function for <f DICoCreateInstance>.
 *
 *  @parm   REFCLSID | rclsid |
 *
 *          The <t CLSID> to create.
 *
 *  @parm   LPCTSTR | ptszDll |
 *
 *          The name of the DLL to load.
 *
 *  @parm   LPUNKNOWN | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   RIID | riid |
 *
 *          Interface to obtain.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Receives a pointer to the created object if successful.
 *
 *  @parm   HINSTANCE * | phinst |
 *
 *          Receives the instance handle of the in-proc DLL that was
 *          loaded.  <f FreeLibrary> this DLL when you are finished
 *          with the object.
 *
 *          Note that since we don't implement a binder, this means
 *          that you cannot give the returned pointer away to anybody
 *          you don't control; otherwise, you won't know when to
 *          free the DLL.
 *
 *  @returns
 *
 *          Standard OLE status code.
 *
 *****************************************************************************/

HRESULT
_CreateInprocObject(BOOL bInstance, REFCLSID rclsid, LPCTSTR ptszDll, LPUNKNOWN punkOuter,
                REFIID riid, LPVOID *ppvOut, HINSTANCE *phinst)
{
    HRESULT hres;
    HINSTANCE hinst;

    hinst = LoadLibrary(ptszDll);
    if (hinst) {
        LPFNGETCLASSOBJECT DllGetClassObject;

        DllGetClassObject = (LPFNGETCLASSOBJECT)
                            GetProcAddress(hinst, "DllGetClassObject");

        if (DllGetClassObject) {
            IClassFactory *pcf;

			if (bInstance)
				hres = DllGetClassObject(rclsid, IID_IClassFactory, (LPVOID *)&pcf);
			else
			{
				hres = DllGetClassObject(rclsid, riid, ppvOut);
				if (FAILED(hres))
					*ppvOut = NULL;
			}
            if (SUCCEEDED(hres) && bInstance) {
                hres = pcf->CreateInstance(punkOuter, riid, ppvOut);
                pcf->Release();

                /*
                 *  People forget to adhere to
                 *  the OLE spec, which requires that *ppvOut be
                 *  set to zero on failure.
                 */
                if (FAILED(hres)) {
/*                    if (*ppvOut) {
                        RPF("ERROR! CoCreateInstance: %s forgot to zero "
                            "out *ppvOut on failure path", ptszDll);
                    }*/
                    *ppvOut = 0;
                }

            }
        } else {
            /*
             *  DLL does not export GetClassObject.
             */
            hres = REGDB_E_CLASSNOTREG;
        }

        if (SUCCEEDED(hres)) {
            *phinst = hinst;
        } else {
            FreeLibrary(hinst);
        }
    } else {
        /*
         *  DLL does not exist.
         */
        hres = REGDB_E_CLASSNOTREG;
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DICoCreateInstance |
 *
 *          Private version of CoCreateInstance that doesn't use OLE.
 *
 *  @parm   LPTSTR | ptszClsid |
 *
 *          The string version of the <t CLSID> to create.
 *
 *  @parm   LPUNKNOWN | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   RIID | riid |
 *
 *          Interface to obtain.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Receives a pointer to the created object if successful.
 *
 *  @parm   HINSTANCE * | phinst |
 *
 *          Receives the instance handle of the in-proc DLL that was
 *          loaded.  <f FreeLibrary> this DLL when you are finished
 *          with the object.
 *
 *          Note that since we don't implement a binder, this means
 *          that you cannot give the returned pointer away to anybody
 *          you don't control; otherwise, you won't know when to
 *          free the DLL.
 *
 *  @returns
 *
 *          Standard OLE status code.
 *
 *****************************************************************************/

STDMETHODIMP
CreateInprocObject(BOOL bInstance, LPCTSTR ptszClsid, LPUNKNOWN punkOuter,
                   REFIID riid, LPVOID *ppvOut, HINSTANCE *phinst)
{
    HRESULT hres;
    CLSID clsid;

    *ppvOut = 0;
    *phinst = 0;

    if (ParseGUID(&clsid, ptszClsid)) {
        HKEY hk;
        LONG lRc;
        TCHAR tszKey[ctchGuid + 40];    /* 40 is more than enough */

        /*
         *  Look up the CLSID in HKEY_CLASSES_ROOT.
         */
        wsprintf(tszKey, TEXT("CLSID\\%s\\InProcServer32"), ptszClsid);

        lRc = RegOpenKeyEx(HKEY_CLASSES_ROOT, tszKey, 0,
                           KEY_QUERY_VALUE, &hk);
        if (lRc == ERROR_SUCCESS) {
            TCHAR tszDll[MAX_PATH];
            DWORD cb;

            cb = cbX(tszDll);
            lRc = RegQueryValue(hk, 0, tszDll, (PLONG)&cb);

            if (lRc == ERROR_SUCCESS) {
                TCHAR tszModel[20];     /* more than enough */

                lRc = RegQueryString(hk, TEXT("ThreadingModel"),
                                     tszModel, cA(tszModel));
                if (lRc == ERROR_SUCCESS &&
                    ((lstrcmpi(tszModel, TEXT("Both"))==0x0) ||
                     (lstrcmpi(tszModel, TEXT("Free"))==0x0))) {

                    hres = _CreateInprocObject(bInstance, clsid, tszDll, punkOuter,
                                           riid, ppvOut, phinst);

                } else {
                    /*
                     *  No threading model or bad threading model.
                     */
                    hres = REGDB_E_CLASSNOTREG;
                }
            } else {
                /*
                 *  No InprocServer32.
                 */
                hres = REGDB_E_CLASSNOTREG;
            }

            RegCloseKey(hk);

        } else {
            /*
             *  CLSID not registered.
             */
            hres = REGDB_E_CLASSNOTREG;
        }
    } else {
        /*
         *  Invalid CLSID string.
         */
        hres = REGDB_E_CLASSNOTREG;
    }

    return hres;
}


HRESULT
PrivCreateInstance(REFCLSID ptszClsid, LPUNKNOWN punkOuter, DWORD dwClsContext, 
                   REFIID riid, LPVOID *ppvOut, HINSTANCE *phinst)
{
	if (dwClsContext != CLSCTX_INPROC_SERVER || phinst == NULL)
		return E_INVALIDARG;

	return CreateInprocObject(TRUE, GUIDSTR(ptszClsid), punkOuter, riid, ppvOut, phinst);
}

HRESULT
PrivGetClassObject(REFCLSID ptszClsid, DWORD dwClsContext, LPVOID pReserved,
                   REFIID riid, LPVOID *ppvOut, HINSTANCE *phinst)
{
	if (dwClsContext != CLSCTX_INPROC_SERVER || pReserved != NULL || phinst == NULL)
		return E_INVALIDARG;

	return CreateInprocObject(FALSE, GUIDSTR(ptszClsid), NULL, riid, ppvOut, phinst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\selcontroldlg.cpp ===
#include "common.hpp"


CSelControlDlg::CSelControlDlg(CDeviceView &view, CDeviceControl &control, BOOL bReselect, DWORD dwOfs, const DIDEVICEINSTANCEW &didi) :
	m_bReselect(bReselect), m_dwOfs(dwOfs), m_didi(didi),
	m_view(view), m_control(control), m_bAssigned(FALSE), m_bNoItems(TRUE)
{
}

CSelControlDlg::~CSelControlDlg()
{
}

int CSelControlDlg::DoModal(HWND hParent)
{
	return CFlexWnd::DoModal(hParent, IDD_SELCONTROLDLG, g_hModule);
}

BOOL CALLBACK AddItem(LPCDIDEVICEOBJECTINSTANCE lpddoi, LPVOID pvRef)
{
	if (pvRef == NULL || lpddoi == NULL)
		return DIENUM_CONTINUE;
	return ((CSelControlDlg *)pvRef)->AddItem(*lpddoi);
}

BOOL CSelControlDlg::AddItem(const DIDEVICEOBJECTINSTANCE &doi)
{
	if (m_hList == NULL || m_view.DoesCalloutOtherThanSpecifiedExistForOffset(&m_control, doi.dwType))
		return DIENUM_CONTINUE;

	LRESULT i = SendMessage(m_hList, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)doi.tszName);
	if (i == LB_ERR || i == LB_ERRSPACE)
		return DIENUM_CONTINUE;

	m_bNoItems = FALSE;

	i = SendMessage(m_hList, LB_SETITEMDATA, (WPARAM)i, (LPARAM)doi.dwType);

	return DIENUM_CONTINUE;
}

void CSelControlDlg::OnInit()
{
	m_hList = GetDlgItem(m_hWnd, IDC_LIST);
	if (m_hList == NULL)
		return;

	LPDIRECTINPUTDEVICE8 pDID = NULL;
	LPDIRECTINPUT8 pDI = NULL;
	DWORD dwVer = DIRECTINPUT_VERSION;
	HRESULT hr;
	if (FAILED(hr = DirectInput8Create(g_hModule, dwVer, IID_IDirectInput8, (LPVOID*)&pDI, NULL)))
		return;

	if (FAILED(hr = pDI->CreateDevice(m_didi.guidInstance, &pDID, NULL)))
	{
		pDID = NULL;
		return;
	}

	pDI->Release();
	pDI = NULL;

	if (FAILED(hr = pDID->EnumObjects(::AddItem, this, DIDFT_AXIS | DIDFT_BUTTON | DIDFT_POV)))
		return;

	pDID->Release();
	pDID = NULL;

	if (m_bNoItems)
	{
		EndDialog(SCDR_NOFREE);
		return;
	}

	// indicate callout offset assignment...
	int i = -1;

	if (m_control.IsOffsetAssigned())
	{
		BOOL m_bAssigned = TRUE;
		m_dwOfs = m_control.GetOffset();
		i = GetItemWithOffset(m_dwOfs);
	}

	SendMessage(m_hList, LB_SETCURSEL, (WPARAM)i, 0);
}

LRESULT CSelControlDlg::OnCommand(WORD wNotifyCode, WORD wID, HWND hWnd)
{
	switch (wNotifyCode)
	{
		case LBN_SELCHANGE:
		{
			if (m_hList == NULL || m_hList != hWnd)
				break;

			LRESULT lr = SendMessage(m_hList, LB_GETCURSEL, 0, 0);
			if (lr == LB_ERR)
				break;

			lr = SendMessage(m_hList, LB_GETITEMDATA, (WPARAM)lr, 0);
			if (lr == LB_ERR)
				break;

			m_dwOfs = (DWORD)lr;
			m_bAssigned = TRUE;
			break;
		}

		case BN_CLICKED:
			switch (wID)
			{
				case IDOK:
					if (m_bAssigned)
						EndDialog(SCDR_OK);
					else
						MessageBox(m_hWnd, TEXT("You must either select a control for this callout or click cancel."), TEXT("Select a Control"), MB_OK);
					break;

				case IDCANCEL:
					EndDialog(SCDR_CANCEL);
					break;
			}
			break;
	}

	return 0;
}

int CSelControlDlg::GetItemWithOffset(DWORD dwOfs)
{	
	if (m_hList == NULL)
		return -1;

	LRESULT lr = SendMessage(m_hList, LB_GETCOUNT, 0, 0);
	if (lr == LB_ERR)
		return -1;

	int n = int(lr);

	if (n < 1)
		return -1;

	for (int i = 0; i < n; i++)
	{
		lr = SendMessage(m_hList, LB_GETITEMDATA, (WPARAM)i, 0);
		if (lr == LB_ERR)
			continue;

		if ((DWORD)lr == dwOfs)
			return i;
	}
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\sources.inc ===
!ifndef DXROOT
DXROOT=$(BASEDIR)\MultiMedia\DirectX
!endif

!INCLUDE $(DXROOT)\Project.mk


MAJORCOMP=windows
MINORCOMP=media
UMTYPE=windows

TARGETNAME=diactfrm
TARGETTYPE=DYNLINK
TARGETPATH=obj
USE_LIBCMT=1
USE_RTTI=1
DLLENTRY=_DllMainCRTStartup

INCLUDES=$(INCLUDES); \
	..\; \
	$(DXROOT)\inc;\
	$(SDK_INC_PATH)\MFC42;

USE_RTTI=1

!IFDEF TARGET_WIN95
CHICAGO_PRODUCT = 1
ALT_PROJECT_TARGET = WIN9x
C_DEFINES=$(C_DEFINES) -DWIN95 -D_X86_ 
!ELSE
C_DEFINES=$(C_DEFINES) -DWINNT -DUNICODE 
!ENDIF


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
	$(SDK_LIB_PATH)\kernel32.lib    \
	$(SDK_LIB_PATH)\advapi32.lib    \
	$(SDK_LIB_PATH)\ole32.lib    \
	$(SDK_LIB_PATH)\user32.lib      \
	$(SDK_LIB_PATH)\uuid.lib        \
	$(SDK_LIB_PATH)\gdi32.lib       \
	$(SDK_LIB_PATH)\comdlg32.lib    \
	$(SDK_LIB_PATH)\dinput8.lib     \
	$(SDK_LIB_PATH)\ddraw.lib       \
        $(SDK_LIB_PATH)\d3d8.lib     \
#	$(SDK_LIB_PATH)\mydebug.lib     \

!if $(FREEBUILD)
TARGETLIBS=$(TARGETLIBS) \
        $(SDK_LIB_PATH)\d3dx8.lib
!else
TARGETLIBS=$(TARGETLIBS) \
        $(SDK_LIB_PATH)\d3dx8dt.lib
!endif      


LINKER_FLAGS=-SECTION:share,RWS


!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif

SOURCES= \
	..\guids.c	\
	..\dconfig.rc	\
	..\privcom.cpp \
	..\itestclassfact.cpp \
	..\cdftest.cpp \
	..\rundftest.cpp \
	..\flexcombobox.cpp \
	..\flexlistbox.cpp \
	..\uiglobals.cpp \
	..\cfguitrace.cpp \
	..\flextree.cpp \
	..\flexscrollbar.cpp \
	..\selcontroldlg.cpp \
	..\viewselwnd.cpp \
	..\constants.cpp        \
	..\cdiacpage.cpp        \
	..\cdeviceui.cpp        \
	..\cdeviceview.cpp      \
	..\cdevicecontrol.cpp   \
	..\iclassfact.cpp \
	..\ipageclassfact.cpp \
	..\configwnd.cpp \
	..\cbitmap.cpp  \
	..\usefuldi.cpp \
	..\flexwnd.cpp 	\
	..\cyclestr.cpp   \
	..\cfrmwrk.cpp	\
	..\registry.cpp	\
	..\main.cpp 	\
	..\flextooltip.cpp \
	..\cd3dsurf.cpp \
	..\cdeviceviewtext.cpp \
	..\populate.cpp \
	..\flexinfobox.cpp \
	..\flexcheckbox.cpp \
	..\flexmsgbox.cpp \

PRECOMPILED_INCLUDE=..\common.hpp

DLLDEF=..\diactfrm.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\selcontroldlg.h ===
#ifdef FORWARD_DECLS


	class CSelControlDlg;


#else // FORWARD_DECLS

#ifndef __SELCONTROLDLG_H__
#define __SELCONTROLDLG_H__


enum {
	SCDR_OK = 1,
	SCDR_CANCEL,
	SCDR_NOFREE,
};


class CSelControlDlg : public CFlexWnd
{
public:
	CSelControlDlg(CDeviceView &view, CDeviceControl &control, BOOL bReselect, DWORD dwOfs, const DIDEVICEINSTANCEW &didi);
	~CSelControlDlg();

	int DoModal(HWND hParent);
	DWORD GetOffset() {return m_dwOfs;}

protected:
	virtual void OnInit();
	virtual LRESULT OnCommand(WORD wNotifyCode, WORD wID, HWND hWnd);
	virtual BOOL OnEraseBkgnd(HDC) {return FALSE;}

private:
	BOOL m_bReselect;
	DWORD m_dwOfs;
	BOOL m_bAssigned;
	const DIDEVICEINSTANCEW &m_didi;
friend BOOL CALLBACK AddItem(LPCDIDEVICEOBJECTINSTANCE lpddoi, LPVOID pvRef);
	BOOL AddItem(const DIDEVICEOBJECTINSTANCE &doi);
	CDeviceControl &m_control;
	CDeviceView &m_view;

	HWND m_hList;
	BOOL m_bNoItems;

	int GetItemWithOffset(DWORD dwOfs);
};


#endif //__SELCONTROLDLG_H__

#endif // FORWARD_DECLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\uiglobals.cpp ===
//-----------------------------------------------------------------------------
// File: uiglobals.cpp
//
// Desc: CUIGlobals is a class that packs and holds most information
//       relevent to a UI session.  Many classes make reference to
//       CUIGlobals all the time.
//
//       CPaintHelper encapsulates GDI calls, simplifying GDI operations.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"
#define __DEFINE_ELEMENT_STRUCTURES__
#include "uielements.h"


static const GUID GUID_DIConfigAppEditLayout = 
{ 0xfd4ace13, 0x7044, 0x4204, { 0x8b, 0x15, 0x9, 0x52, 0x86, 0xb1, 0x2e, 0xad } };


CUIGlobals::CUIGlobals(UIG_PARAMS_DEFINE) :

	// globals...
	m_hrInit(S_OK),

	m_hrFinalResult(S_OK),

	m_hInst(NULL),
	m_lpDI(NULL),

	m_dwFlags(0),
	m_wszUserNames(NULL),
	m_pSurface(NULL),
	m_pSurface3D(NULL),
	m_lpCallback(NULL),
	m_pvRefData(NULL),

	m_bAllowEditLayout(FALSE),

	m_bUseColorSet(FALSE),

	// ui...
	m_pElement(NULL),
	m_nElements(0),
	m_pFont(NULL),
	m_nFonts(0),
	m_pBrush(NULL),
	m_nBrushes(0),
	m_pPen(NULL),
	m_nPens(0),
	m_pColor(NULL),
	m_nColors(0)
{
	tracescope(__ts,_T("CUIGlobals::CUIGlobals()\n"));

	m_hrInit = Init(UIG_PARAMS_DEFINE_PASS);
}

void CUIGlobals::SetTableColor(UICOLOR uic, COLORREF c)
{
	UICOLORINFO *info = GetColorInfo(uic);
	assert(info != NULL);
	if (info == NULL)
		return;

	info->rgb = c;
}

HRESULT CUIGlobals::Init(UIG_PARAMS_DEFINE)
{tracescope(__ts,_T("CUIGlobals::Init(...)\n"));

	HRESULT hr = S_OK;

	// get instance handle
	m_hInst = (HINSTANCE)g_hModule;
	if (m_hInst == NULL)
	{
		etrace(_T("hInst NULL\n"));
		return E_FAIL;
	}

	// create direct input
	DWORD dwVer = DIRECTINPUT_VERSION;
	hr = DirectInput8Create(m_hInst, dwVer, IID_IDirectInput8W, (LPVOID *)&m_lpDI, NULL);
	if (FAILED(hr) || m_lpDI == NULL)
	{
		m_lpDI = NULL;
		etrace2(_T("Could not create DirectInput ver 0x%08x\n  -> DirectInputCreateEx() returned 0x%08x\n"), dwVer, hr);
		return hr;
	}

	// save flags
	m_dwFlags = dwFlags;
#ifdef CFGUI__FORCE_NON_NULL_WSZUSERNAMES
	if (wszUserNames == NULL)
		wszUserNames = _T("Forced Non-NULL Username");
#endif
	if (wszUserNames == NULL)
	{
		etrace(_T("wszUserNames was passed NULL\n"));
		return E_FAIL;
	}

	// save user names
	m_wszUserNames = DupSuperString(wszUserNames);
	if (m_wszUserNames == NULL)
	{
		etrace(_T("Could not duplicate user names\n"));
		return E_FAIL;
	}

	// make sure we were passed an action format
	if (lpAcFor == NULL)
	{
		etrace(_T("lpAcFor param NULL\n"));
		return E_INVALIDARG;
	}

	// copy the acfor to the master
	hr = InitMasterAcForArray(lpAcFor, int(dwNumAcFor));
	if (FAILED(hr))
	{
		etrace1(_T("InitMasterAcForArray() failed, returning 0x%08x\n"), hr);
		return hr;
	}

	// get surface
	if (lpSurface != NULL)
	{
		hr = lpSurface->QueryInterface(IID_IDirect3DSurface8, (void **)&m_pSurface3D);
		if (FAILED(hr) || m_pSurface3D == NULL)
		{
			m_pSurface3D = NULL;
		}

		hr = lpSurface->QueryInterface(IID_IDirectDrawSurface, (void **)&m_pSurface);
		if (FAILED(hr) || m_pSurface == NULL)
		{
			m_pSurface = NULL;
		}

		if (m_pSurface == NULL && m_pSurface3D == NULL)
			etrace(_T("lpSurface was non-NULL but could not get IDirect3DSurface8 or IID_IDirectDrawSurface from it"));
	}

	// save callback and ref data
	m_lpCallback = lpCallback;
	m_pvRefData = pvRefData;

	// see whether or not we're allowing edit layout mode
	m_bAllowEditLayout = IsEqualGUID(RefMasterAcFor(0).guidActionMap,
		GUID_DIConfigAppEditLayout);

	// init a bunch of stuff necessary for painting
	if (!InitColorsAndTablesAndObjects(lpDIColorSet))
		return E_FAIL;

	// dump info if debug
#ifdef DBG
	Dump();
#endif

	// return success if we got here
	return S_OK;
}

BOOL CUIGlobals::InitColorsAndTablesAndObjects(LPDICOLORSET lpDIColorSet)
{tracescope(__ts,_T("CUIGlobals::InitColorsAndTablesAndObjects()\n"));

	// init ui tables
	if (!InitTables())
	{
		etrace(_T("Could not initialize tables\n"));
		return FALSE;
	}

	// decide whether or not to use the passed colorset
	if (lpDIColorSet != NULL)
	{
		m_ColorSet = *lpDIColorSet;

		m_bUseColorSet = !IsZeroOrInvalidColorSet(m_ColorSet);
	}
	else
		m_bUseColorSet = FALSE;

	// use it, or use defaults
	if (m_bUseColorSet)
	{
		// transfer colors from passed colorset
		SetTableColor(UIC_TEXTFORE, D3DCOLOR2COLORREF(m_ColorSet.cTextFore));
		SetTableColor(UIC_TEXTHIGHLIGHT, D3DCOLOR2COLORREF(m_ColorSet.cTextHighlight));
		SetTableColor(UIC_CALLOUTLINE, D3DCOLOR2COLORREF(m_ColorSet.cCalloutLine));
		SetTableColor(UIC_CALLOUTHIGHLIGHT, D3DCOLOR2COLORREF(m_ColorSet.cCalloutHighlight));
		SetTableColor(UIC_BORDER, D3DCOLOR2COLORREF(m_ColorSet.cBorder));
		SetTableColor(UIC_CONTROLFILL, D3DCOLOR2COLORREF(m_ColorSet.cControlFill));
		SetTableColor(UIC_HIGHLIGHTFILL, D3DCOLOR2COLORREF(m_ColorSet.cHighlightFill));
		SetTableColor(UIC_AREAFILL, D3DCOLOR2COLORREF(m_ColorSet.cAreaFill));
	}
	else
	{
		// use default colors
		SetTableColor(UIC_TEXTFORE,				RGB(255, 255, 255));
		SetTableColor(UIC_TEXTHIGHLIGHT,		RGB(  0, 255,   0));
		SetTableColor(UIC_CALLOUTLINE,			RGB(255, 255, 255));
		SetTableColor(UIC_CALLOUTHIGHLIGHT,		RGB(  0, 255,   0));
		SetTableColor(UIC_BORDER,				RGB(255, 255,   0));
		SetTableColor(UIC_CONTROLFILL,			RGB(  0, 191,   0));
		SetTableColor(UIC_HIGHLIGHTFILL,		RGB(  0,   0,   0));
		SetTableColor(UIC_AREAFILL,				RGB(  0,   0,   0));
	}

	// create the table objects
	CreateObjects();

	return TRUE;
}

CUIGlobals::~CUIGlobals()
{
	tracescope(__ts,_T("CUIGlobals::~CUIGlobals()\n"));

	if (m_wszUserNames != NULL)
		free((LPVOID)m_wszUserNames);
	m_wszUserNames = NULL;

	if (m_lpDI != NULL)
		m_lpDI->Release();
	m_lpDI = NULL;

	if (m_pSurface != NULL)
		m_pSurface->Release();
	m_pSurface = NULL;

	if (m_pSurface3D != NULL)
		m_pSurface3D->Release();
	m_pSurface3D = NULL;

	ClearMasterAcForArray();

	ClearTables();
}

void CUIGlobals::Dump()
{
	tracescope(ts, _T("UIGlobals...\n\n"));

	traceHEXPTR(m_hInst);
	traceHEXPTR(m_lpDI);
	LPTSTR str = AllocConfigureFlagStr(m_dwFlags);
	trace1(_T("m_dwFlags = %s\n"), str);
	free(str);
	traceSUPERSTR(m_wszUserNames);
	traceHEXPTR(m_pSurface);
	traceHEXPTR(m_pSurface3D);
	traceHEXPTR(m_lpCallback);
	traceBOOL(m_bAllowEditLayout);
	{
		tracescope(__csts, _T("m_ColorSet...\n"));
		traceHEX(m_ColorSet.cTextFore);
		traceHEX(m_ColorSet.cTextHighlight);
		traceHEX(m_ColorSet.cCalloutLine);
		traceHEX(m_ColorSet.cCalloutHighlight);
		traceHEX(m_ColorSet.cBorder);
		traceHEX(m_ColorSet.cControlFill);
		traceHEX(m_ColorSet.cHighlightFill);
		traceHEX(m_ColorSet.cAreaFill);
	}
	traceBOOL(m_bUseColorSet);
	trace(_T("\n"));
	TraceActionFormat(_T("Master ActionFormat 0:"), RefMasterAcFor(0));
	trace(_T("\n\n"));
}

LPDIRECTINPUT8W CUIGlobals::GetDI()
{
	if (m_lpDI == NULL)
		return NULL;

	m_lpDI->AddRef();
	return m_lpDI;
}

IDirectDrawSurface *CUIGlobals::GetSurface()
{
	if (m_pSurface == NULL)
		return NULL;

	m_pSurface->AddRef();
	return m_pSurface;
}

IDirect3DSurface8 *CUIGlobals::GetSurface3D()
{
	if (m_pSurface3D == NULL)
		return NULL;

	m_pSurface3D->AddRef();
	return m_pSurface3D;
}

void CUIGlobals::DeleteObjects()
{
	// make sure all our gdi objects are deleted
	int i;
	if (m_pFont != NULL)
		for (i = 0; i <	m_nFonts; i++)
		{
			UIFONTINFO &info = m_pFont[i];
			if (info.hFont != NULL)
				DeleteObject(info.hFont);
			info.hFont = NULL;
		}
	if (m_pBrush != NULL)
		for (i = 0; i <	m_nBrushes; i++)
		{
			UIBRUSHINFO &info = m_pBrush[i];
			if (info.hBrush != NULL)
				DeleteObject(info.hBrush);
			info.hBrush = NULL;
			if (info.hPen != NULL)
				DeleteObject(info.hPen);
			info.hPen = NULL;
		}
	if (m_pPen != NULL)
		for (i = 0; i <	m_nPens; i++)
		{
			UIPENINFO &info = m_pPen[i];
			if (info.hPen != NULL)
				DeleteObject(info.hPen);
			info.hPen = NULL;
		}
}

void CUIGlobals::ClearTables()
{
	// make sure all our gdi objects are deleted
	DeleteObjects();

	// delete the tables, null the pointers, and zero the counters
#define FREETABLE(member, memnum) \
{ \
	if (member != NULL) \
		delete [] member; \
	member = NULL; \
	memnum = 0; \
}
	FREETABLE(m_pElement, m_nElements);
	FREETABLE(m_pFont, m_nFonts);
	FREETABLE(m_pBrush, m_nBrushes);
	FREETABLE(m_pPen, m_nPens);
	FREETABLE(m_pColor, m_nColors);
}

BOOL CUIGlobals::InitTables()
{
	BOOL bSuccess = TRUE;

	// make sure the tables have been cleared
	ClearTables();

	// allocate our own copies of all the tables
#define ALLOCTABLE(member, memnum, type, init, num) \
{ \
	member = new type [memnum = num]; \
	if (member == NULL) \
	{ \
		memnum = 0; \
		bSuccess = FALSE; \
	} \
	else \
		memcpy(member, init, sizeof(type) * memnum); \
}
	ALLOCTABLE(m_pElement, m_nElements, UIELEMENTINFO, uielement, NUMUIELEMENTS);
	ALLOCTABLE(m_pFont, m_nFonts, UIFONTINFO, uifont, NUMUIFONTS);
	ALLOCTABLE(m_pBrush, m_nBrushes, UIBRUSHINFO, uibrush, NUMUIBRUSHES);
	ALLOCTABLE(m_pPen, m_nPens, UIPENINFO, uipen, NUMUIPENS);
	ALLOCTABLE(m_pColor, m_nColors, UICOLORINFO, uicolor, NUMUICOLORS);

	return bSuccess;
}

void CUIGlobals::RecreateObjects()
{
	DeleteObjects();
	CreateObjects();
}

void CUIGlobals::CreateObjects()
{
	// make sure all our gdi objects are created
	int i;
	if (m_pFont != NULL)
	{
		HDC hDC = GetDC(NULL);
		for (i = 0; i <	m_nFonts; i++)
		{
			UIFONTINFO &info = m_pFont[i];
			if (info.hFont == NULL)
			{
				LOGFONT lf;
				lf.lfHeight = -MulDiv(info.nPointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
				lf.lfWidth = 0;
				lf.lfEscapement = 0;
				lf.lfOrientation = 0;
				lf.lfWeight = info.bBold ? FW_BOLD : FW_NORMAL;
				lf.lfItalic = FALSE;
				lf.lfUnderline = FALSE;
				lf.lfStrikeOut = FALSE;
				lf.lfCharSet = DEFAULT_CHARSET;
				lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
				lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
				lf.lfQuality = PROOF_QUALITY;
				lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
				_tcscpy(lf.lfFaceName, info.lfFaceName);

				info.hFont = (HGDIOBJ)CreateFontIndirect(&lf);
			}
		}
		ReleaseDC(NULL, hDC);
	}
	if (m_pBrush != NULL)
		for (i = 0; i <	m_nBrushes; i++)
		{
			UIBRUSHINFO &info = m_pBrush[i];
			if (info.hBrush == NULL)
				info.hBrush = (HGDIOBJ)CreateSolidBrush(GetColor(info.eColor));
			if (info.hPen == NULL)
				info.hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, GetColor(info.eColor));
		}
	if (m_pPen != NULL)
		for (i = 0; i <	m_nPens; i++)
		{
			UIPENINFO &info = m_pPen[i];
			if (info.hPen == NULL)
				info.hPen = (HGDIOBJ)CreatePen(info.fnPenStyle, info.nWidth, GetColor(info.eColor));
		}
}


#define IMPLGETINFO(Type, TYPE, Types, t) \
UI##TYPE##INFO *CUIGlobals::Get##Type##Info(UI##TYPE t) \
{ \
	if (m_p##Type != NULL) \
		for (int i = 0; i < m_n##Types; i++) \
			if (m_p##Type[i].e##Type == t) \
				return &(m_p##Type[i]); \
	return NULL; \
}

IMPLGETINFO(Element, ELEMENT, Elements, e)
IMPLGETINFO(Font, FONT, Fonts, f)
IMPLGETINFO(Brush, BRUSH, Brushes, b)
IMPLGETINFO(Pen, PEN, Pens, p)
IMPLGETINFO(Color, COLOR, Colors, c)

#undef IMPLGETINFO


#define IMPLGET(T, Name, Type, TYPE, v, def, ret) \
T CUIGlobals::Get##Name(UI##TYPE ui##v) \
{ \
	UI##TYPE##INFO *v = Get##Type##Info(ui##v); \
	if (!v) \
		return def; \
	return ret; \
}

IMPLGET(HGDIOBJ, Font, Element, ELEMENT, e, NULL, GetFont(e->eFont))
IMPLGET(HGDIOBJ, Font, Font, FONT, f, NULL, f->hFont)
IMPLGET(HGDIOBJ, Brush, Element, ELEMENT, e, NULL, GetBrush(e->eBrush))
IMPLGET(HGDIOBJ, Brush, Brush, BRUSH, b, NULL, b->hBrush)
IMPLGET(HGDIOBJ, Pen, Element, ELEMENT, e, NULL, GetPen(e->ePen))
IMPLGET(HGDIOBJ, Pen, Brush, BRUSH, b, NULL, b->hPen)
IMPLGET(HGDIOBJ, Pen, Pen, PEN, p, NULL, p->hPen)
IMPLGET(COLORREF, BrushColor, Element, ELEMENT, e, RGB(255, 127, 127), GetColor(e->eBrush))
IMPLGET(COLORREF, PenColor, Element, ELEMENT, e, RGB(255, 127, 127), GetColor(e->ePen))
IMPLGET(COLORREF, TextColor, Element, ELEMENT, e, RGB(255, 127, 127), GetColor(e->eText))
IMPLGET(COLORREF, BkColor, Element, ELEMENT, e, RGB(255, 127, 127), GetColor(e->eBk))
IMPLGET(COLORREF, Color, Brush, BRUSH, b, RGB(255, 127, 127), GetColor(b->eColor))
IMPLGET(COLORREF, Color, Pen, PEN, p, RGB(255, 127, 127), GetColor(p->eColor))
IMPLGET(COLORREF, Color, Color, COLOR, c, RGB(255, 127, 127), c->rgb)

#undef IMPLGET


CPaintHelper::CPaintHelper(CUIGlobals &uig, HDC hDC) :
	m_uig(uig), m_priv_hDC(hDC), m_hDC(m_priv_hDC),
	m_eFont(UIF_VOID),
	m_eBrush(UIB_VOID),
	m_ePen(UIP_VOID),
	m_eText(UIC_VOID),
	m_eBk(UIC_VOID),
	m_hOldFont(NULL), m_hOldBrush(NULL), m_hOldPen(NULL),
	m_bOldFont(FALSE), m_bOldBrush(FALSE), m_bOldPen(FALSE)
{
	if (m_hDC != NULL)
	{
		m_oldtextcolor = GetTextColor(m_hDC);
		m_oldbkcolor = GetBkColor(m_hDC);
		m_oldbkmode = GetBkMode(m_hDC);
	}
}

CPaintHelper::~CPaintHelper()
{
	if (m_hDC != NULL)
	{
		if (m_bOldFont)
			SelectObject(m_hDC, m_hOldFont);
		if (m_bOldBrush)
			SelectObject(m_hDC, m_hOldBrush);
		if (m_bOldPen)
			SelectObject(m_hDC, m_hOldPen);

		SetTextColor(m_hDC, m_oldtextcolor);
		SetBkColor(m_hDC, m_oldbkcolor);
		SetBkMode(m_hDC, m_oldbkmode);
	}
}

void CPaintHelper::SetElement(UIELEMENT eElement)
{
	UIELEMENTINFO *info = m_uig.GetElementInfo(eElement);
	if (!info)
		return;

	if (info->eFont != UIF_LAST)
		SetFont(info->eFont);
	if (info->eBrush != UIB_LAST)
		SetBrush(info->eBrush);
	if (info->ePen != UIP_LAST)
		SetPen(info->ePen);
	SetText(info->eText, info->eBk);
}

void CPaintHelper::SetFont(UIFONT eFont)
{
	if (m_eFont == eFont || eFont == UIF_LAST)
		return;

	HGDIOBJ hObj = m_uig.GetFont(eFont);
	if (hObj == NULL)
		return;

	if (m_hDC != NULL)
	{
		HGDIOBJ hOld = NULL;
		hOld = SelectObject(m_hDC, hObj);
		if (!m_bOldFont)
			m_hOldFont = hOld;
		m_bOldFont = TRUE;
	}

	m_eFont = eFont;
}

void CPaintHelper::SetBrush(UIBRUSH eBrush)
{
	if (m_eBrush == eBrush || eBrush == UIB_LAST)
		return;

	HGDIOBJ hObj = eBrush == UIB_NULL ?
		GetStockObject(NULL_BRUSH) :
		m_uig.GetBrush(eBrush);
	if (hObj == NULL)
		return;

	if (m_hDC != NULL)
	{
		HGDIOBJ hOld = NULL;
		hOld = SelectObject(m_hDC, hObj);
		if (!m_bOldBrush)
			m_hOldBrush = hOld;
		m_bOldBrush = TRUE;
	}

	m_eBrush = eBrush;
}

void CPaintHelper::SetPen(UIPEN ePen)
{
	if (m_ePen == ePen || ePen == UIP_LAST)
		return;

	HGDIOBJ hObj = ePen == UIB_NULL ?
		GetStockObject(NULL_PEN) :
		m_uig.GetPen(ePen);
	if (hObj == NULL)
		return;

	if (m_hDC != NULL)
	{
		HGDIOBJ hOld = NULL;
		hOld = SelectObject(m_hDC, hObj);
		if (!m_bOldPen)
			m_hOldPen = hOld;
		m_bOldPen = TRUE;
	}

	m_ePen = ePen;
}

void CPaintHelper::SetText(UICOLOR eText, UICOLOR eBk)
{
	if (m_eText != eText && eText != UIC_LAST)
	{
		if (m_hDC != NULL)
			SetTextColor(m_hDC, m_uig.GetColor(eText));
		m_eText = eText;
	}
	if (m_eBk != eBk && eBk != UIC_LAST)
	{
		if (m_hDC != NULL)
		{
			if (eBk == UIC_NULL)
				SetBkMode(m_hDC, TRANSPARENT);
			else 
			{
				SetBkColor(m_hDC, m_uig.GetColor(eBk));
				SetBkMode(m_hDC, OPAQUE);
			}
		}
		m_eBk = eBk;
	}
}

BOOL CPaintHelper::LineTo(int x, int y)
{
	if (m_hDC == NULL)
		return FALSE;

	return ::LineTo(m_hDC, x, y);
}

BOOL CPaintHelper::MoveTo(int x, int y, SPOINT *last)
{
	if (m_hDC == NULL)
		return FALSE;

	POINT p;
	BOOL bRet = MoveToEx(m_hDC, x, y, &p);
	if (last)
		*last = p;
	return bRet;
}

BOOL CPaintHelper::Rectangle(SRECT r, UIRECTTYPE eType)
{
	// fail on no dc
	if (m_hDC == NULL)
		return FALSE;

	// see if we lack a pen or brush (might add more checks later)
	BOOL bNoPen = m_ePen == UIP_NULL;
	BOOL bNoBrush = m_eBrush == UIB_NULL;

	// fail if trying to do an outline without a pen
	if (eType == UIR_OUTLINE && bNoPen)
		return FALSE;

	// fail if trying to do a solid without a brush
	if (eType == UIR_SOLID && bNoBrush)
		return FALSE;

	// save old objects if we change anything...
	HGDIOBJ hOldBrush = NULL, hOldPen = NULL;

	// select a null brush if we're doing an outline and we're not already null brushed
	if (eType == UIR_OUTLINE && m_eBrush != UIB_NULL)
		hOldBrush = SelectObject(m_hDC, GetStockObject(NULL_BRUSH));

	// select a pen the same color as the current brush if doing solid
	if (eType == UIR_SOLID || m_ePen == UIP_NULL)
	{
		HGDIOBJ hPen = m_uig.GetPen(m_eBrush);
		if (hPen == NULL)
			return FALSE;
		hOldPen = SelectObject(m_hDC, hPen);
	}

	// draw the rect
	BOOL bRet = ::Rectangle(m_hDC, r.left, r.top, r.right, r.bottom);

	// restore whatever changed
	if (eType == UIR_OUTLINE && m_eBrush != UIB_NULL)
		SelectObject(m_hDC, hOldBrush);
	if (eType == UIR_SOLID || m_ePen == UIP_NULL)
		SelectObject(m_hDC, hOldPen);

	return bRet;
}

const DIACTIONFORMATW &CUIGlobals::RefMasterAcFor(int i)
{
	assert(IsValidMasterAcForIndex(i));
	return m_MasterAcForArray[i];
}

BOOL CUIGlobals::IsValidMasterAcForIndex(int i)
{
	if (i < 0 || i >= m_MasterAcForArray.GetSize())
		return FALSE;

	return TRUE;
}

HRESULT CUIGlobals::InitMasterAcForArray(const DIACTIONFORMATW *af, int n)
{
	if (n < 1)
		return E_FAIL;

	ClearMasterAcForArray();

	m_MasterAcForArray.SetSize(n);

	for (int i = 0; i < n; i++)
	{
		HRESULT hr = CopyActionFormat(m_MasterAcForArray[i], af[i]);
		if (FAILED(hr))
		{
			m_MasterAcForArray.SetSize(i);
			ClearMasterAcForArray();

			return hr;
		}
	}

	return S_OK;
}

void CUIGlobals::ClearMasterAcForArray()
{
	int s = m_MasterAcForArray.GetSize();

	for (int i = 0; i < s; i++)
		CleanupActionFormatCopy(m_MasterAcForArray[i]);

	m_MasterAcForArray.RemoveAll();
	assert(m_MasterAcForArray.GetSize() == 0);
}

LPCWSTR CUIGlobals::GetUserName(int i)
{
	return GetSubString(m_wszUserNames, i);
}

int CUIGlobals::GetNumUserNames()
{
	return CountSubStrings(m_wszUserNames);
}

void CUIGlobals::SetFinalResult(HRESULT hr)
{
	m_hrFinalResult = hr;
}

HRESULT CUIGlobals::GetFinalResult()
{
	return m_hrFinalResult;
}

int CUIGlobals::GetUserNameIndex(LPCWSTR wsz)
{
	for (int i = 0; i < GetNumUserNames(); i++)
		if (_wcsicmp(wsz, GetUserName(i)) == 0)
			return i;

	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\uiglobals.h ===
//-----------------------------------------------------------------------------
// File: uiglobals.h
//
// Desc: CUIGlobals is a class that packs and holds most information
//       relevent to a UI session.  Many classes make reference to
//       CUIGlobals all the time.
//
//       CPaintHelper encapsulates GDI calls, simplifying GDI operations.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __UIGLOBALS_H__
#define __UIGLOBALS_H__


#include "uielements.h"


struct UIELEMENTINFO {
	UIELEMENT eElement;
	UIFONT eFont;
	UIBRUSH eBrush;
	UIPEN ePen;
	UICOLOR eText, eBk;
};

struct UIFONTINFO {
	UIFONT eFont;
	LPCTSTR lfFaceName;
	int nPointSize;
	BOOL bBold;
	HGDIOBJ hFont;
};

struct UIBRUSHINFO {
	UIBRUSH eBrush;
	UICOLOR eColor;
	HGDIOBJ hBrush;
	HGDIOBJ hPen;
};

struct UIPENINFO {
	UIPEN ePen;
	int fnPenStyle;
	int nWidth;
	UICOLOR eColor;
	HGDIOBJ hPen;
};

struct UICOLORINFO {
	UICOLOR eColor;
	COLORREF rgb;
};

enum UIRECTTYPE {
	UIR_OUTLINE,
	UIR_NORMAL,
	UIR_SOLID,
};

#define UIG_PARAMS_DEFINE \
	DWORD dwFlags, \
	LPCWSTR wszUserNames, \
	DWORD dwNumAcFor, \
	LPDIACTIONFORMATW lpAcFor, \
	LPDICOLORSET lpDIColorSet, \
	IUnknown FAR *lpSurface, \
	LPDICONFIGUREDEVICESCALLBACK lpCallback, \
	LPVOID pvRefData

#define UIG_PARAMS_DEFINE_PASS \
	dwFlags, \
	wszUserNames, \
	dwNumAcFor, \
	lpAcFor, \
	lpDIColorSet, \
	lpSurface, \
	lpCallback, \
	pvRefData

class CUIGlobals
{
public:
	CUIGlobals(UIG_PARAMS_DEFINE);
	~CUIGlobals();

	// UI Variables/States/Etc...
public:
	HRESULT GetInitResult() {return m_hrInit;}

	HINSTANCE GetInstance() {return m_hInst;}
	LPDIRECTINPUT8W GetDI();

	int GetUserNameIndex(LPCWSTR);
	int GetNumUserNames();
	LPCWSTR GetUserName(int i);

	// GetSurface should not be used as only IDirect3DSurface8 should be used. Instead, use GetSurface3D.
	IDirectDrawSurface *GetSurface();	// must release when done with returned surface (it's addref'd before returned)
	IDirect3DSurface8 *GetSurface3D();	// must release when done with returned surface (it's addref'd before returned)
	LPDICONFIGUREDEVICESCALLBACK GetCallback() {return m_lpCallback;}
	LPVOID GetRefData() {return m_pvRefData;}
//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
	BOOL QueryAllowEditLayout() { return m_bAllowEditLayout; }
#endif
//@@END_MSINTERNAL
	DWORD GetFlags() {return m_dwFlags;}
	BOOL IsFlagSet(DWORD dwFlag) {return AreFlagsSet(dwFlag);}
	BOOL AreFlagsSet(DWORD dwFlags) {return (m_dwFlags & dwFlags) == dwFlags;}
	BOOL InEditMode() {return IsFlagSet(DICD_EDIT);}
	const DIACTIONFORMATW &RefMasterAcFor(int i);
	int GetNumMasterAcFors() {return m_MasterAcForArray.GetSize();}
	const DICOLORSET &GetColorSet() const { return m_ColorSet; }

	void SetFinalResult(HRESULT);
	HRESULT GetFinalResult();

private:
	HRESULT Init(UIG_PARAMS_DEFINE);
	void Dump();
	HRESULT m_hrInit;
	HRESULT m_hrFinalResult;

	BOOL InitColorsAndTablesAndObjects(LPDICOLORSET lpDIColorSet);

	BOOL IsValidUserIndex(int i);
	BOOL IsValidMasterAcForIndex(int i);
	HRESULT InitMasterAcForArray(const DIACTIONFORMATW *af, int n);
	void ClearMasterAcForArray();

	HINSTANCE m_hInst;
	LPDIRECTINPUT8W m_lpDI;

	DWORD m_dwFlags;
	LPCWSTR m_wszUserNames;
	CArray<DIACTIONFORMATW, DIACTIONFORMATW &> m_MasterAcForArray;
	BOOL m_bUseColorSet;
	DICOLORSET m_ColorSet;
	void SetTableColor(UICOLOR, COLORREF);
	IDirectDrawSurface *m_pSurface;
	IDirect3DSurface8 *m_pSurface3D;
	LPDICONFIGUREDEVICESCALLBACK m_lpCallback;
	LPVOID m_pvRefData;

	BOOL m_bAllowEditLayout;

	// UI Elements...
public:
	UIELEMENTINFO *GetElementInfo(UIELEMENT);
	UIFONTINFO *GetFontInfo(UIFONT);
	UIBRUSHINFO *GetBrushInfo(UIBRUSH);
	UIPENINFO *GetPenInfo(UIPEN);
	UICOLORINFO *GetColorInfo(UICOLOR);
	HGDIOBJ GetFont(UIELEMENT);
	HGDIOBJ GetFont(UIFONT);
	HGDIOBJ GetBrush(UIELEMENT);
	HGDIOBJ GetBrush(UIBRUSH);
	HGDIOBJ GetPen(UIELEMENT);
	HGDIOBJ GetPen(UIBRUSH);
	HGDIOBJ GetPen(UIPEN);
	COLORREF GetBrushColor(UIELEMENT);
	COLORREF GetPenColor(UIELEMENT);
	COLORREF GetTextColor(UIELEMENT);
	COLORREF GetBkColor(UIELEMENT);
	COLORREF GetColor(UIBRUSH);
	COLORREF GetColor(UIPEN);
	COLORREF GetColor(UICOLOR);
	
	void DeleteObjects();
	void CreateObjects();
	void RecreateObjects();

private:
	BOOL InitTables();
	void ClearTables();

	UIELEMENTINFO *m_pElement;
	int m_nElements;
	UIFONTINFO *m_pFont;
	int m_nFonts;
	UIBRUSHINFO *m_pBrush;
	int m_nBrushes;
	UIPENINFO *m_pPen;
	int m_nPens;
	UICOLORINFO *m_pColor;
	int m_nColors;
};

class CPaintHelper
{
public:
	CPaintHelper(CUIGlobals &uig, HDC hDC);
	~CPaintHelper();
	CUIGlobals &m_uig;
	HDC &m_hDC;

	void SetElement(UIELEMENT eElement);
	void SetFont(UIFONT eFont);
	void SetBrush(UIBRUSH eBrush);
	void SetPen(UIPEN ePen);
	void SetText(UICOLOR eText, UICOLOR eBk = UIC_LAST);

	BOOL LineTo(SPOINT p) {return LineTo(p.x, p.y);}
	BOOL LineTo(int x, int y);
	BOOL MoveTo(SPOINT p, SPOINT *last = NULL) {return MoveTo(p.x, p.y, last);}
	BOOL MoveTo(int x, int y, SPOINT *last = NULL);

	BOOL Rectangle(SRECT r, UIRECTTYPE eType = UIR_NORMAL);
	BOOL Rectangle(int l, int t, int r, int b, UIRECTTYPE eType = UIR_NORMAL)
		{SRECT s(l,t,r,b); return Rectangle(s, eType);}

private:
	HDC m_priv_hDC;
	HGDIOBJ m_hOldFont, m_hOldBrush, m_hOldPen;
	BOOL m_bOldFont, m_bOldBrush, m_bOldPen;
	COLORREF m_oldtextcolor, m_oldbkcolor;
	int m_oldbkmode;
	UIFONT m_eFont;
	UIBRUSH m_eBrush;
	UIPEN m_ePen;
	UICOLOR m_eText, m_eBk;
};

#endif //__UIGLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\useful.cpp ===
//-----------------------------------------------------------------------------
// File: useful.cpp
//
// Desc: Contains various utility classes and functions to help the
//       UI carry its operations more easily.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <wchar.h>
#include <stdio.h>
#include <stdarg.h>

// assert include (make sure assert actually works with build)
#ifdef DBG
#undef NDEBUG
#endif
#include <assert.h>

#include "useful.h"
#include "collections.h"


/*--------- \/ stuff for collections.h \/ ---------*/
BOOL AfxIsValidAddress( const void* lp, UINT nBytes, BOOL bReadWrite)
{
//	return lp != NULL;

	// simple version using Win-32 APIs for pointer validation.
	return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
		(!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

CPlex* PASCAL CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
	assert(nMax > 0 && cbElement > 0);
	CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
			// may throw exception
	if (p)
	{
		p->pNext = pHead;
		pHead = p;  // change head (adds in reverse order for simplicity)
	}
	return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
	CPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}
/*--------- /\ stuff for collections.h /\ ---------*/


int ConvertVal(int x, int a1, int a2, int b1, int b2)
{
	assert(a1 != a2 && a2 - a1);
	return MulDiv(x - a1, b2 - b1, a2 - a1) + b1;
}

double dConvertVal(double x, double a1, double a2, double b1, double b2)
{
	assert(a1 != a2 && a2 - a1);
	return (x - a1) * (b2 - b1) / (a2 - a1) + b1;
}

SIZE GetRectSize(const RECT &rect)
{
	SIZE size = {
		rect.right - rect.left,
		rect.bottom - rect.top};
	return size;
}

SIZE GetTextSize(LPCTSTR tszText, HFONT hFont)
{
	if (!tszText)
	{
		SIZE z = {0, 0};
		return z;
	}
	RECT trect = {0, 0, 1, 1};
	HDC hDC = CreateCompatibleDC(NULL);
	if (hDC != NULL)
	{
		HGDIOBJ hOld = NULL;
		if (hFont)
			hOld = SelectObject(hDC, hFont);
		DrawText(hDC, tszText, -1, &trect, DT_CALCRECT | DT_NOPREFIX);
		if (hFont)
			SelectObject(hDC, hOld);
		DeleteDC(hDC);
	}
	SIZE size = {trect.right - trect.left, trect.bottom - trect.top};
	return size;
}

int GetTextHeight(HFONT hFont)
{
	static const TCHAR str[] = _T("Happy Test!  :D");
	SIZE size = GetTextSize(str, hFont);
	return size.cy;
}

int vFormattedMsgBox(HINSTANCE hInstance, HWND hParent, UINT uType, UINT uTitle, UINT uMsg, va_list args)
{
	int i;
	const int len = 1024;
	static TCHAR title[len], format[len], msg[len];

	if (!LoadString(hInstance, uTitle, title, len))
		_tcscpy(title, _T("(could not load title string)"));
	
	if (!LoadString(hInstance, uMsg, format, len))
		return MessageBox(hParent, _T("(could not load message/format string)"), title, uType);

#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,format);							// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))				// find each %p
			*(psz+1) = 'x';								// replace each %p with %x
		i = _vsntprintf(msg, len, szDfs, args);			// use the local format string
	}
#else
	{
		i = _vsntprintf(msg, len, format, args);
	}
#endif

	if (i < 0)
		return MessageBox(hParent, _T("(could not format message)"), title, uType);

	if (i < 1)
		msg[0] = 0;

	return MessageBox(hParent, msg, title, uType);
}

int FormattedMsgBox(HINSTANCE hInstance, HWND hParent, UINT uType, UINT uTitle, UINT uMsg, ...)
{
	va_list args;
	va_start(args, uMsg);
	int i = vFormattedMsgBox(hInstance, hParent, uType, uTitle, uMsg, args);
	va_end(args);
	return i;
}

BOOL UserConfirm(HINSTANCE hInstance, HWND hParent, UINT uTitle, UINT uMsg, ...)
{
	va_list args;
	va_start(args, uMsg);
	int i = vFormattedMsgBox(hInstance, hParent, MB_ICONQUESTION | MB_YESNO, uTitle, uMsg, args);
	va_end(args);
	return i == IDYES;
}

int FormattedErrorBox(HINSTANCE hInstance, HWND hParent, UINT uTitle, UINT uMsg, ...)
{
	va_list args;
	va_start(args, uMsg);
	int i = vFormattedMsgBox(hInstance, hParent, MB_OK | MB_ICONSTOP, uTitle, uMsg, args);
	va_end(args);
	return i;
}

int FormattedLastErrorBox(HINSTANCE hInstance, HWND hParent, UINT uTitle, UINT uMsg, DWORD dwError)
{
	// format an error message from GetLastError().
	LPVOID lpMsgBuf = NULL;
	DWORD result = FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dwError,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR) &lpMsgBuf,
		0,
		NULL);

	if (!result || lpMsgBuf == NULL)
		return FormattedErrorBox(hInstance, hParent, uTitle, uMsg, 
			_T("An unknown error occured (could not format the error code)."));

	int i = FormattedErrorBox(hInstance, hParent, uTitle, uMsg, (LPCTSTR)lpMsgBuf);

	LocalFree(lpMsgBuf);

	return i;
}

LPTSTR AllocLPTSTR(LPCWSTR wstr)
{
	if (wstr == NULL)
		return NULL;

#ifdef UNICODE
	return _tcsdup(wstr);
#else
	int len = wcslen(wstr) * 2 + 1;
	char *ret = (char *)malloc(len);
	if (!ret)
		return NULL;
	WideCharToMultiByte(CP_ACP, 0, wstr, -1, ret, len, NULL, NULL);
	ret[len-1] = '\0';
	return ret;
#endif
}

LPTSTR AllocLPTSTR(LPCSTR str)
{
	if (str == NULL)
		return NULL;

#ifndef UNICODE
	return _tcsdup(str);
#else
	int len = strlen(str);
	WCHAR *ret = (WCHAR *)malloc((len + 1) * sizeof(WCHAR));
	if (!ret)
		return NULL;
	mbstowcs(ret, str, len);
	ret[len] = L'\0';
	return ret;
#endif
}

void CopyStr(LPWSTR dest, LPCWSTR src, size_t max)
{
	if (dest == NULL || src == NULL)
		return;

	wcsncpy(dest, src, max);
}

void CopyStr(LPSTR dest, LPCSTR src, size_t max)
{
	if (dest == NULL || src == NULL)
		return;

	strncpy(dest, src, max);
}

void CopyStr(LPWSTR dest, LPCSTR src, size_t max)
{
	if (dest == NULL || src == NULL)
		return;

	mbstowcs(dest, src, max);
}

void CopyStr(LPSTR dest, LPCWSTR src, size_t max)
{
	if (dest == NULL || src == NULL)
		return;

	WideCharToMultiByte(CP_ACP, 0, src, -1, dest, max, NULL, NULL);
}

LPWSTR AllocLPWSTR(LPCWSTR wstr)
{
	if (wstr == NULL)
		return NULL;

	return _wcsdup(wstr);
}

LPWSTR AllocLPWSTR(LPCSTR str)
{
	if (str == NULL)
		return NULL;

	size_t len = strlen(str);
	size_t retsize = mbstowcs(NULL, str, len);
	WCHAR *ret = (WCHAR *)malloc((retsize + 1) * sizeof(WCHAR));
	if (!ret)
		return NULL;
	mbstowcs(ret, str, len);
	ret[retsize] = L'\0';
	return ret;
}

LPSTR AllocLPSTR(LPCWSTR wstr)
{
	if (wstr == NULL)
		return NULL;

	size_t len = wcslen(wstr);
	size_t retsize = WideCharToMultiByte(CP_ACP, 0, wstr, -1, NULL, 0, NULL, NULL);
	CHAR *ret = (CHAR *)malloc((retsize + 1) * sizeof(CHAR));
	if (!ret)
		return NULL;
	WideCharToMultiByte(CP_ACP, 0, wstr, -1, ret, retsize, NULL, NULL);
	ret[retsize] = '\0';
	return ret;
}

LPSTR AllocLPSTR(LPCSTR str)
{
	if (str == NULL)
		return NULL;

	return _strdup(str);
}

LPTSTR AllocFileNameNoPath(LPTSTR path)
{
	TCHAR fname[_MAX_FNAME];
	TCHAR ext[_MAX_EXT];

	if (path == NULL) return NULL;

	_tsplitpath(path, NULL, NULL, fname, ext);

	LPTSTR ret = (LPTSTR)malloc(sizeof(TCHAR) * (_tcslen(fname) + _tcslen(ext) + 1));
	if (ret != NULL)
	{
		_tcscpy(ret, fname);
		_tcscat(ret, ext);
	}

	return ret;
}

LPTSTR utilstr::Eject()
{
	LPTSTR str = m_str;
	m_str = NULL;
	m_len = 0;
	return str;
}

void utilstr::Empty()
{
	if (m_str != NULL)
		free(m_str);
	m_len = 0;
}

bool utilstr::IsEmpty() const
{
	return !GetLength();
}

int utilstr::GetLength() const
{
	if (m_str == NULL)
		return 0;
	if (!m_len)
		return 0;

	return _tcslen(m_str);
}

void utilstr::Format(LPCTSTR format, ...)
{
	static TCHAR buf[2048];
	va_list args;
	va_start(args, format);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,format);  // make a local copy of format string
		while (psz = strstr(szDfs,"%p"))  // find each %p
			*(psz+1) = 'x';  // replace each %p with %x
		_vsntprintf(buf, sizeof(buf)/sizeof(TCHAR), szDfs, args);  // use the local format string
	}
#else
	{
		_vsntprintf(buf, sizeof(buf)/sizeof(TCHAR), format, args);
	}
#endif
	va_end(args);
	equal(buf);
}

void utilstr::equal(LPCTSTR str)
{
	Empty();
	if (str == NULL)
		return;
	m_len = _tcslen(str);
	m_str = (LPTSTR)malloc(sizeof(TCHAR) * (m_len + 1));
	if (m_str != NULL)
		_tcscpy(m_str, str);
	else
		m_len = 0;
}

void utilstr::add(LPCTSTR str)
{
	if (str == NULL)
		return;
	if (IsEmpty())
	{
		equal(str);
		return;
	}
	int len = _tcslen(str);
	int newlen = m_len + len;
	LPTSTR newstr = (LPTSTR)malloc(sizeof(TCHAR) * (newlen + 1));
	if (newstr == NULL)
		return;
	_tcscpy(newstr, m_str);
	_tcscat(newstr, str);
	Empty();
	m_str = newstr;
	m_len = newlen;
}

LPTSTR AllocFlagStr(DWORD value, const AFS_FLAG flag[], int flags)
{
	utilstr ret;	// return string
	DWORD allknownbits = 0;  // check value to see if there are any bits
	                         // set for which we don't have a define

	// handle each flag
	bool bflagfound = false;
	for (int i = 0; i < flags; i++)
	{
		// set bit for this flag in allknownbits
		allknownbits |= flag[i].value;

		// if this bit is set in the passed value, or the value
		// is zero and we're on the zero flag,
		// add the define for this bit/flag to the return string
		if (value ? value & flag[i].value : !flag[i].value)
		{
			// adding binary or operators between flags
			if (bflagfound)
				ret += _T(" | ");
			ret += flag[i].name;
			bflagfound = true;
		}
	}

	// now see if there are any unknown bits in passed flag
	DWORD unknownbits = value & ~allknownbits;
	if (unknownbits)
	{
		// add hex number for unknown bits
		utilstr unk;
		unk.Format(_T("0x%08X"), unknownbits);
		if (bflagfound)
			ret += _T(" | ");
		ret += unk;
	}

	// if value is zero (and no flags for zero) we should just set the string to "0"
	if (!value && !bflagfound)
		ret = _T("0");

	// now the string should definitely not be empty, in any case
	assert(!ret.IsEmpty());

	// finally, add a comment that has hex number for entire value
	// (for debugging)
	utilstr temp;
	temp.Format(_T(" /* 0x%08X */"), value);
	ret += temp;

	// done
	return ret.Eject();
}

void PutLinePoint(HDC hDC, POINT p)
{
	MoveToEx(hDC, p.x, p.y, NULL);
	LineTo(hDC, p.x + 1, p.y);
}

void PolyLineArrowShadow(HDC hDC, POINT *p, int i)
{
	PolyLineArrow(hDC, p, i, TRUE);
}

void PolyLineArrow(HDC hDC, POINT *rgpt, int nPoints, BOOL bDoShadow)
{
	int i;

	if (rgpt == NULL || nPoints < 1)
		return;

	if (nPoints > 1)
		for (i = 0; i < nPoints - 1; i++)
		{
			SPOINT a = rgpt[i], b = rgpt[i + 1];

			if (bDoShadow)
			{
				int rise = abs(b.y - a.y), run = abs(b.x - a.x);
				bool vert = rise > run;
				int ord = vert ? 1 : 0;
				int nord = vert ? 0 : 1;
				
				for (int o = -1; o <= 1; o += 2)
				{
					SPOINT c(a), d(b);
					c.a[nord] += o;
					d.a[nord] += o;
					MoveToEx(hDC, c.x, c.y, NULL);
					LineTo(hDC, d.x, d.y);
				}

				bool reverse = a.a[ord] > b.a[ord];
				SPOINT e(reverse ? b : a), f(reverse ? a : b);
				e.a[ord] -= 1;
				f.a[ord] += 1;
				PutLinePoint(hDC, e);
				PutLinePoint(hDC, f);
			}
			else
			{
				MoveToEx(hDC, a.x, a.y, NULL);
				LineTo(hDC, b.x, b.y);
			}
		}

	POINT z = rgpt[nPoints - 1];

	if (bDoShadow)
	{
		POINT pt[5] = {
			{z.x, z.y + 2},
			{z.x + 2, z.y},
			{z.x, z.y - 2},
			{z.x - 2, z.y}, };
		pt[4] = pt[0];
		Polyline(hDC, pt, 5);
	}
	else
	{
		MoveToEx(hDC, z.x - 1, z.y, NULL);
		LineTo(hDC, z.x + 2, z.y);
		MoveToEx(hDC, z.x, z.y - 1, NULL);
		LineTo(hDC, z.x, z.y + 2);
	}
}

BOOL bEq(BOOL a, BOOL b)
{
	bool c = !a, d = !b;
	return (c == d) ? TRUE : FALSE;
}

void DrawArrow(HDC hDC, const RECT &rect, BOOL bVert, BOOL bUpLeft)
{
	SRECT srect = rect;
	srect.right--;
	srect.bottom--;
	int ord = bVert ? 1 : 0;
	int nord = bVert ? 0 : 1;
	SPOINT p(!bUpLeft ? srect.lr : srect.ul), b(!bUpLeft ? srect.ul : srect.lr);
	b.a[ord] += bUpLeft ? -1 : 1;
	SPOINT t = p;
	t.a[nord] = (p.a[nord] + b.a[nord]) / 2;
	SPOINT u;
	u.a[ord] = b.a[ord];
	u.a[nord] = p.a[nord];
	POINT poly[] = { {t.x, t.y}, {u.x, u.y}, {b.x, b.y} };
	Polygon(hDC, poly, 3);
}

BOOL ScreenToClient(HWND hWnd, LPRECT rect)
{
	if (rect == NULL)
		return FALSE;

	SRECT sr = *rect;

	if (ScreenToClient(hWnd, &sr.ul.p) &&
	    ScreenToClient(hWnd, &sr.lr.p))
	{
		*rect = sr;
		return TRUE;
	}

	return FALSE;
}

BOOL ClientToScreen(HWND hWnd, LPRECT rect)
{
	if (rect == NULL)
		return FALSE;

	SRECT sr = *rect;

	if (ClientToScreen(hWnd, &sr.ul.p) &&
	    ClientToScreen(hWnd, &sr.lr.p))
	{
		*rect = sr;
		return TRUE;
	}

	return FALSE;
}

#define z ((L"\0")[0])

int StrLen(LPCWSTR s)
{
	if (s == NULL)
		return 0;

	return wcslen(s);
}

int StrLen(LPCSTR s)
{
	if (s == NULL)
		return 0;

	return strlen(s);
}

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
LPCTSTR GetOpenFileName(HINSTANCE hInst, HWND hWnd, LPCTSTR title, LPCTSTR filter, LPCTSTR defext, LPCTSTR inidir)
{
	OPENFILENAME ofn;
	static TCHAR tszFile[MAX_PATH + 1] = _T("");
	tszFile[MAX_PATH] = 0;

	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = hWnd;
	ofn.hInstance = hInst;
	ofn.lpstrFilter = filter;
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 0;
	ofn.lpstrFile = tszFile;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = inidir;
	ofn.lpstrTitle = title;
	ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST;
	ofn.lpstrDefExt = defext;
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	if (!GetOpenFileName(&ofn))
		return NULL;

	return tszFile;
}
#endif
//@@END_MSINTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\bc9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\bcnt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\win9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\uielements.h ===
//-----------------------------------------------------------------------------
// File: uielements.h
//
// Desc: Defines various UI element definitions used throughout the UI.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __DEFINE_ELEMENT_STRUCTURES__


#ifndef __UIELEMENTS_H_ENUMS__
#define __UIELEMENTS_H_ENUMS__


enum UIELEMENT {
	UIE_VOID,
	//
	UIE_TAB,
	UIE_TABARROW,
	UIE_SELTAB,
	UIE_BUTTON,
	UIE_DEFBUTTON,
	UIE_BORDER,
	UIE_VIEWSEL,
	UIE_DEVOBJ,
	UIE_GLYPH,
	UIE_CALLOUT,
	UIE_CALLOUTHIGH,
	UIE_CALLOUTSHADOW,
	UIE_CALLOUTMAX,
	UIE_CALLOUTALIGN,
	UIE_VIEWBORDER,
	UIE_SBTRACK,
	UIE_SBTHUMB,
	UIE_SBBUTTON,
	UIE_USERNAMES,
	UIE_USERNAMESEL,
	UIE_ACTION,
	UIE_ACTIONLABEL,
	UIE_PICERRORTEXT,
	UIE_PICCUSTOMTEXT,
	UIE_PICCUSTOM2TEXT,
	UIE_ERRORHEADER,
	UIE_ERRORMESSAGE,
};

enum UIFONT {
	UIF_VOID,
	UIF_LAST,
	//
	UIF_FRAME,
	UIF_DEVOBJ,
	UIF_CALLOUT,
	UIF_ACTION,
	UIF_ACTIONLABEL,
	UIF_INFO,
	UIF_VIEWSEL,
	UIF_PICERROR,
	UIF_PICCUSTOM,
	UIF_PICCUSTOM2,
	UIF_ERRORHEADER,
	UIF_ERRORMESSAGE,
};

enum UIBRUSH {
	UIB_VOID,
	UIB_LAST,
	UIB_NULL,
	//
	UIB_BLACK,
	UIB_AREAFILL,
	UIB_HIGHLIGHTFILL,
	UIB_SB,
};

enum UIPEN {
	UIP_VOID,
	UIP_LAST,
	UIP_NULL,
	//
	UIP_BORDER,
	UIP_BLACK,
	UIP_AREAFILL,
	UIP_TEXTFORE,
	UIP_VIEWSELGRID,
	UIP_CALLOUTLINE,
	UIP_CALLOUTHIGHLIGHT,
	UIP_CALLOUTMAX,
	UIP_CALLOUTALIGN,
	UIP_VIEWBORDER,
	UIP_SELTHUMB,
};

enum UICOLOR {
	UIC_VOID,
	UIC_LAST,
	UIC_NULL,
	//
	UIC_BLACK,
	UIC_WHITE,
	UIC_RED,
	//
	UIC_TEXTFORE,
	UIC_TEXTHIGHLIGHT,
	UIC_CALLOUTLINE,
	UIC_CALLOUTHIGHLIGHT,
	UIC_BORDER,
	UIC_CONTROLFILL,
	UIC_HIGHLIGHTFILL,
	UIC_AREAFILL,
	//
	UIC_PICERRORTEXT,
};


#endif //__UIELEMENTS_H_ENUMS__


#else // __DEFINE_ELEMENT_STRUCTURES__


#ifndef __UIELEMENTS_H_TABLES__
#define __UIELEMENTS_H_TABLES__


static const UIELEMENTINFO uielement[] = {
	{UIE_TAB,			UIF_FRAME,			UIB_NULL,			UIP_BORDER,				UIC_BORDER,				UIC_NULL},
	{UIE_TABARROW,		UIF_LAST,			UIB_BLACK,			UIP_BORDER,				UIC_LAST,				UIC_LAST},
	{UIE_SELTAB,		UIF_FRAME,			UIB_HIGHLIGHTFILL,	UIP_BORDER,				UIC_BORDER,				UIC_NULL},
	{UIE_BUTTON,		UIF_FRAME,			UIB_NULL,			UIP_AREAFILL,			UIC_AREAFILL,			UIC_NULL},
	{UIE_DEFBUTTON,		UIF_FRAME,			UIB_HIGHLIGHTFILL,	UIP_BORDER,				UIC_BORDER,				UIC_NULL},
	{UIE_BORDER,		UIF_LAST,			UIB_NULL,			UIP_BORDER,				UIC_LAST,				UIC_LAST},
	{UIE_VIEWSEL,		UIF_VIEWSEL,		UIB_NULL,			UIP_NULL,				UIC_TEXTFORE,			UIC_NULL},
	{UIE_DEVOBJ,		UIF_DEVOBJ,			UIB_LAST,			UIP_LAST,				UIC_TEXTFORE,			UIC_BLACK},
	{UIE_GLYPH,			UIF_LAST,			UIB_LAST,			UIP_LAST,				UIC_TEXTFORE,			UIC_NULL},
	{UIE_CALLOUT,		UIF_CALLOUT,		UIB_AREAFILL,		UIP_CALLOUTLINE,		UIC_TEXTFORE,			UIC_AREAFILL},
	{UIE_CALLOUTHIGH,	UIF_CALLOUT,		UIB_AREAFILL,		UIP_CALLOUTHIGHLIGHT,	UIC_TEXTHIGHLIGHT,		UIC_AREAFILL},
	{UIE_CALLOUTSHADOW,	UIF_LAST,			UIB_LAST,			UIP_AREAFILL,			UIC_LAST,				UIC_LAST},
	{UIE_CALLOUTMAX,	UIF_LAST,			UIB_NULL,			UIP_CALLOUTMAX,			UIC_LAST,				UIC_NULL},
	{UIE_CALLOUTALIGN,	UIF_LAST,			UIB_LAST,			UIP_CALLOUTALIGN,		UIC_LAST,				UIC_LAST},
	{UIE_VIEWBORDER,	UIF_LAST,			UIB_NULL,			UIP_VIEWBORDER,			UIC_LAST,				UIC_NULL},
	{UIE_SBTRACK,		UIF_LAST,			UIB_AREAFILL,		UIP_NULL,				UIC_LAST,				UIC_LAST},
	{UIE_SBTHUMB,		UIF_LAST,			UIB_SB,				UIP_NULL,				UIC_LAST,				UIC_LAST},
	{UIE_SBBUTTON,		UIF_LAST,			UIB_SB,				UIP_BORDER,				UIC_LAST,				UIC_LAST},
	{UIE_USERNAMES,		UIF_LAST,			UIB_SB,				UIP_BORDER,				UIC_TEXTFORE,			UIC_AREAFILL},
	{UIE_USERNAMESEL,	UIF_LAST,			UIB_LAST,			UIP_LAST,				UIC_AREAFILL,			UIC_TEXTFORE},
	{UIE_ACTION,		UIF_ACTION,			UIB_LAST,			UIP_LAST,				UIC_TEXTFORE,			UIC_NULL},
	{UIE_ACTIONLABEL,	UIF_ACTIONLABEL,	UIB_LAST,			UIP_LAST,				UIC_TEXTFORE,			UIC_NULL},
	{UIE_PICERRORTEXT,	UIF_PICERROR,		UIB_LAST,			UIP_LAST,				UIC_PICERRORTEXT,		UIC_BLACK},
	{UIE_PICCUSTOMTEXT,	UIF_PICCUSTOM,		UIB_LAST,			UIP_LAST,				UIC_PICERRORTEXT,		UIC_BLACK},
	{UIE_PICCUSTOM2TEXT,UIF_PICCUSTOM2,		UIB_LAST,			UIP_LAST,				UIC_PICERRORTEXT,		UIC_BLACK},
	{UIE_ERRORHEADER,	UIF_ERRORHEADER,	UIB_LAST,			UIP_LAST,				UIC_PICERRORTEXT,		UIC_BLACK},
	{UIE_ERRORMESSAGE,	UIF_ERRORMESSAGE,	UIB_LAST,			UIP_LAST,				UIC_PICERRORTEXT,		UIC_BLACK},
};

static const UIFONTINFO uifont[] = {
	{UIF_FRAME,				_T("System"),			9,		TRUE,		NULL},
	{UIF_DEVOBJ,			_T("System"),	10,		TRUE,		NULL},
	{UIF_CALLOUT,			_T("System"),			10,		FALSE,		NULL},
	{UIF_ACTION,			_T("System"),			8,		FALSE,		NULL},
	{UIF_ACTIONLABEL,		_T("System"),			12,		TRUE,		NULL},
	{UIF_INFO,				_T("System"),			9,		TRUE,		NULL},
	{UIF_VIEWSEL,			_T("System"),			8,		TRUE,		NULL},
	{UIF_PICERROR,			_T("Arial"),			30,		TRUE,		NULL},
	{UIF_PICCUSTOM,			_T("Arial"),			30,		TRUE,		NULL},
	{UIF_PICCUSTOM2,		_T("Arial"),			15,		TRUE,		NULL},
	{UIF_ERRORHEADER,		_T("Arial"),			60,		TRUE,		NULL},
	{UIF_ERRORMESSAGE,		_T("Arial"),			30,		TRUE,		NULL},
};

static const UIBRUSHINFO uibrush[] = {
	{UIB_BLACK,			UIC_BLACK,			NULL,	NULL},
	{UIB_AREAFILL,		UIC_AREAFILL,		NULL,	NULL},
	{UIB_HIGHLIGHTFILL,	UIC_HIGHLIGHTFILL,	NULL,	NULL},
	{UIB_SB,			UIC_CONTROLFILL,	NULL,	NULL},
};

static const UIPENINFO uipen[] = {
	{UIP_BORDER,			PS_SOLID,	1,	UIC_BORDER,				NULL},
	{UIP_BLACK,				PS_SOLID,	1,	UIC_BLACK,				NULL},
	{UIP_AREAFILL,			PS_SOLID,	1,	UIC_AREAFILL,			NULL},
	{UIP_TEXTFORE,			PS_SOLID,	1,	UIC_TEXTFORE,			NULL},
	{UIP_VIEWSELGRID,		PS_SOLID,	1,	UIC_WHITE,				NULL},
	{UIP_CALLOUTLINE,		PS_SOLID,	1,	UIC_CALLOUTLINE,		NULL},
	{UIP_CALLOUTHIGHLIGHT,	PS_SOLID,	1,	UIC_CALLOUTHIGHLIGHT,	NULL},
	{UIP_CALLOUTMAX,		PS_DOT,		1,	UIC_WHITE,				NULL},
	{UIP_CALLOUTALIGN,		PS_SOLID,	1,	UIC_RED,				NULL},
	{UIP_VIEWBORDER,		PS_DOT,		1,	UIC_RED,				NULL},
	{UIP_SELTHUMB,			PS_SOLID,	3,	UIC_WHITE,				NULL},
};

static const UICOLORINFO uicolor[] = {
	{UIC_WHITE,				RGB(255, 255, 255)},
	{UIC_BLACK,				RGB(  0,   0,   0)},
	{UIC_RED,				RGB(255,   0,   0)},
	//
	{UIC_TEXTFORE,			RGB(191,   0,   0)},
	{UIC_TEXTHIGHLIGHT,		RGB(255,   0,   0)},
	{UIC_CALLOUTLINE,		RGB(191,   0,   0)},
	{UIC_CALLOUTHIGHLIGHT,	RGB(255,   0,   0)},
	{UIC_BORDER,			RGB(255,   0,   0)},
	{UIC_CONTROLFILL,		RGB(127,   0,   0)},
	{UIC_HIGHLIGHTFILL,		RGB(  0,   0,   0)},
	{UIC_AREAFILL,			RGB(  0,   0,   0)},
	//
	{UIC_PICERRORTEXT,		RGB(128, 128, 128)},
};


const int NUMUIELEMENTS = sizeof(uielement) / sizeof(UIELEMENTINFO);
const int NUMUIFONTS = sizeof(uifont) / sizeof(UIFONTINFO);
const int NUMUIBRUSHES = sizeof(uibrush) / sizeof(UIBRUSHINFO);
const int NUMUIPENS = sizeof(uipen) / sizeof(UIPENINFO);
const int NUMUICOLORS = sizeof(uicolor) / sizeof(UICOLORINFO);


#endif // __UIELEMENTS_H_TABLES__


#endif //__DEFINE_ELEMENT_STRUCTURES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\useful.h ===
//-----------------------------------------------------------------------------
// File: useful.h
//
// Desc: Contains various utility classes and functions to help the
//       UI carry its operations more easily.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __USEFUL_H__
#define __USEFUL_H__


class utilstr
{
public:
	utilstr() : m_str(NULL), m_len(0) {}
	~utilstr() {Empty();}

	operator LPCTSTR () const {return m_str;}
	LPCTSTR Get() const {return m_str;}

	const utilstr & operator = (const utilstr &s) {equal(s); return *this;}
	const utilstr & operator = (LPCTSTR s) {equal(s); return *this;}
	const utilstr & operator += (const utilstr &s) {add(s); return *this;}
	const utilstr & operator += (LPCTSTR s) {add(s); return *this;}

	LPTSTR Eject();
	void Empty();
	bool IsEmpty() const;
	int GetLength() const;
	void Format(LPCTSTR format, ...);

private:
	LPTSTR m_str;
	int m_len;

	void equal(LPCTSTR str);
	void add(LPCTSTR str);
};

template <class T>
struct rgref {
	rgref(T *p) : pt(p) {}

	T &operator [] (int i) {return pt[i];}
	const T &operator [] (int i) const {return pt[i];}

private:
	T *pt;
};

struct SPOINT {
	SPOINT() :
#define SPOINT_INITIALIZERS \
		p(u.p), \
		s(u.s), \
		a(((int *)(void *)u.a)), \
		x(u.p.x), \
		y(u.p.y), \
		cx(u.s.cx), \
		cy(u.s.cy)
		SPOINT_INITIALIZERS
	{x = y = 0;}

	SPOINT(int, POINT *r) :
		p(*r),
		s(*((SIZE *)(void *)r)),
		a(((int *)(void *)r)),
		x(r->x),
		y(r->y),
		cx(r->x),
		cy(r->y)
	{}

	SPOINT(const SPOINT &sp) :
		SPOINT_INITIALIZERS
	{p = sp.p;}

	SPOINT(int b, int c) :
		SPOINT_INITIALIZERS
	{x = b; y = c;}

	SPOINT(const POINT &point) :
		SPOINT_INITIALIZERS
	{p = point;}

	SPOINT(const SIZE &size) :
		SPOINT_INITIALIZERS
	{s = size;}

#undef SPOINT_INITIALIZERS

	SPOINT operator = (const SPOINT &sp) {p = sp.p; return *this;}
	SPOINT operator = (const POINT &_p) {p = _p; return *this;}
	SPOINT operator = (const SIZE &_s) {s = _s; return *this;}

	operator POINT () const {return p;}
	operator SIZE () const {return s;}

	long &x, &y, &cx, &cy;
	POINT &p;
	SIZE &s;
	rgref<int> a;

private:
	union {
		POINT p;
		SIZE s;
		int a[2];
	} u;
};

struct SRECT {
	SRECT() :
#define SRECT_INITIALIZERS \
		a(((int *)(void *)u.a)), \
		r(u.r), \
		left(u.r.left), \
		top(u.r.top), \
		right(u.r.right), \
		bottom(u.r.bottom), \
		ul(0, &u.p.ul), \
		lr(0, &u.p.lr)
		SRECT_INITIALIZERS
	{RECT z = {0,0,0,0}; u.r = z;}
	
	SRECT(const SRECT &sr) :
		SRECT_INITIALIZERS
	{u.r = sr.r;}

	SRECT(int c, int d, int e, int f) :
		SRECT_INITIALIZERS
	{RECT z = {c,d,e,f}; u.r = z;}

	SRECT(const RECT &_r) :
		SRECT_INITIALIZERS
	{u.r = _r;}

#undef SRECT_INITIALIZERS

	SRECT operator = (const SRECT &sr) {u.r = sr.r; return *this;}
	SRECT operator = (const RECT &_r) {u.r = _r; return *this;}

	operator RECT () const {return r;}

	long &left, &top, &right, &bottom;
	rgref<int> a;
	RECT &r;
	SPOINT ul, lr;

private:
	union {
		int a[4];
		RECT r;
		struct {
			POINT ul, lr;
		} p;
	} u;
};

int ConvertVal(int x, int a1, int a2, int b1, int b2);
double dConvertVal(double x, double a1, double a2, double b1, double b2);

SIZE GetTextSize(LPCTSTR tszText, HFONT hFont = NULL);
int GetTextHeight(HFONT hFont);
SIZE GetRectSize(const RECT &rect);

int FormattedMsgBox(HINSTANCE, HWND, UINT, UINT, UINT, ...);
int FormattedErrorBox(HINSTANCE, HWND, UINT, UINT, ...);
int FormattedLastErrorBox(HINSTANCE, HWND, UINT, UINT, DWORD);
BOOL UserConfirm(HINSTANCE, HWND, UINT, UINT, ...);

struct AFS_FLAG {DWORD value; LPCTSTR name;};
LPTSTR AllocFlagStr(DWORD value, const AFS_FLAG flag[], DWORD flags);

LPTSTR AllocFileNameNoPath(LPTSTR path);

LPTSTR AllocLPTSTR(LPCWSTR wstr);
LPTSTR AllocLPTSTR(LPCSTR cstr);
LPWSTR AllocLPWSTR(LPCWSTR wstr);
LPWSTR AllocLPWSTR(LPCSTR str);
LPSTR AllocLPSTR(LPCWSTR wstr);
LPSTR AllocLPSTR(LPCSTR str);
void CopyStr(LPWSTR dest, LPCWSTR src, size_t max);
void CopyStr(LPSTR dest, LPCSTR src, size_t max);
void CopyStr(LPWSTR dest, LPCSTR src, size_t max);
void CopyStr(LPSTR dest, LPCWSTR src, size_t max);


void PolyLineArrowShadow(HDC hDC, POINT *p, int i);
void PolyLineArrow(HDC hDC, POINT *, int, BOOL bDoShadow = FALSE);

BOOL bEq(BOOL a, BOOL b);

void DrawArrow(HDC hDC, const RECT &rect, BOOL bVert, BOOL bUpLeft);

BOOL ScreenToClient(HWND hWnd, LPRECT rect);
BOOL ClientToScreen(HWND hWnd, LPRECT rect);

int StrLen(LPCWSTR s);
int StrLen(LPCSTR s);

//@@BEGIN_MSINTERNAL
#ifdef DDKBUILD
LPCTSTR GetOpenFileName(HINSTANCE hInst, HWND hWnd, LPCTSTR title, LPCTSTR filter, LPCTSTR defext, LPCTSTR inidir = NULL);
#endif
//@@END_MSINTERNAL

template<class T>
int GetSuperStringByteSize(const T *str)
{
	for (int i = 0;; i++)
		if (!str[i] && !str[i + 1])
			return (i + 2) * sizeof(T);
}

template<class T>
T *DupSuperString(const T *str)
{
	int s = GetSuperStringByteSize(str);
	T *ret = (T *)malloc(s);
	if (ret != NULL)
	{
		CopyMemory((void *)ret, (const void *)str, (DWORD)s);
	}
	return ret;
}

template<class T>
int CountSubStrings(const T *str)
{
	int n = 0;

	while (1)
	{
		str += StrLen(str) + 1;

		n++;

		if (!*str)
			return n;
	}
}

template<class T>
const T *GetSubString(const T *str, int i)
{
	int n = 0;

	while (1)
	{
		if (n == i)
			return str;

		str += StrLen(str) + 1;

		n++;

		if (!*str)
			return NULL;
	}
}

template<class T>
class SetOnFunctionExit
{
public:
	SetOnFunctionExit(T &var, T value) : m_var(var), m_value(value) {}
	~SetOnFunctionExit() {m_var = m_value;}

private:
	T &m_var;
	T m_value;
};


#endif //__USEFUL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\viewselwnd.cpp ===
//-----------------------------------------------------------------------------
// File: viewselwnd.cpp
//
// Desc: Implements CViewSelWnd class (derived from  CFlexWnd).  CViewSelWnd
//       is used by the page object when a device has more than one view.
//       CViewSelWnd displays one thumbnail for each view.  The user can then
//       select which view he/she wants to see with the mouse.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"


CViewSelWnd::CViewSelWnd() :
	m_pUI(NULL), m_nOver(-1)
{
}

CViewSelWnd::~CViewSelWnd()
{
}

BOOL CViewSelWnd::Go(HWND hParent, int left, int bottom, CDeviceUI *pUI)
{
	if (pUI == NULL)
	{
		assert(0);
		return FALSE;
	}
	m_pUI = pUI;

	int w = 2 + g_sizeThumb.cx * pUI->GetNumViews();
	int h = 2 + g_sizeThumb.cy;

	RECT rect = {left, bottom - h, left + w, bottom};

	if (!Create(hParent, rect, FALSE))
		return FALSE;

	assert(m_hWnd);
	if (!m_hWnd)
		return FALSE;

	SetWindowPos(m_hWnd, HWND_TOP, 0, 0, 0, 0,
		SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
	SetCapture();

	return TRUE;
}

void CViewSelWnd::OnPaint(HDC hDC)
{
	for (int i = 0; i < m_pUI->GetNumViews(); i++)
	{
		CBitmap *pbm = m_pUI->GetViewThumbnail(i, i == m_nOver);
		if (pbm != NULL)
			pbm->Draw(hDC, i * g_sizeThumb.cx + 1, 1);
	}

	CPaintHelper ph(m_pUI->m_uig, hDC);
	ph.SetPen(UIP_VIEWSELGRID);
	RECT rect;
	GetClientRect(&rect);
	ph.Rectangle(rect, UIR_OUTLINE);
}

void CViewSelWnd::OnMouseOver(POINT point, WPARAM fwKeys)
{
	RECT rect;
	GetClientRect(&rect);
	InflateRect(&rect, -1, -1);
	if (PtInRect(&rect, point))
		m_nOver = point.x / g_sizeThumb.cx;
	else
		m_nOver = -1;
	Invalidate();
}

void CViewSelWnd::OnClick(POINT point, WPARAM fwKeys, BOOL bLeft)
{
	if (!bLeft)
		return;

	OnMouseOver(point, fwKeys);

	if (m_nOver != -1)
	{
		DEVICEUINOTIFY uin;
		uin.msg = DEVUINM_SELVIEW;
		uin.from = DEVUINFROM_SELWND;
		uin.selview.nView = m_nOver;
		m_pUI->Notify(uin);
	}

	ReleaseCapture();

	Destroy();
}

LRESULT CViewSelWnd::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	LRESULT lr = CFlexWnd::WndProc(hWnd, msg, wParam, lParam);

	switch (msg)
	{
		case WM_CAPTURECHANGED:
			Destroy();
			break;
	}

	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\viewselwnd.h ===
//-----------------------------------------------------------------------------
// File: viewselwnd.h
//
// Desc: Implements CViewSelWnd class (derived from  CFlexWnd).  CViewSelWnd
//       is used by the page object when a device has more than one view.
//       CViewSelWnd displays one thumbnail for each view.  The user can then
//       select which view he/she wants to see with the mouse.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifdef FORWARD_DECLS


	class CViewSelWnd;


#else // FORWARD_DECLS

#ifndef __VIEWSELWND_H__
#define __VIEWSELWND_H__


class CViewSelWnd : public CFlexWnd
{
public:
	CViewSelWnd();
	~CViewSelWnd();

	BOOL Go(HWND hParent, int left, int bottom, CDeviceUI *pUI);

protected:
	virtual void OnPaint(HDC hDC);
	virtual void OnMouseOver(POINT point, WPARAM fwKeys);
	virtual void OnClick(POINT point, WPARAM fwKeys, BOOL bLeft);
	virtual LRESULT WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
	CDeviceUI *m_pUI;
	int m_nOver;
};


#endif //__VIEWSELWND_H__

#endif // FORWARD_DECLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\usefuldi.cpp ===
//-----------------------------------------------------------------------------
// File: usefuldi.cpp
//
// Desc: Contains various DInput-specific utility classes and functions
//       to help the UI carry its operations more easily.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "common.hpp"

// don't want useful.cpp to use precompiled header
#include "useful.cpp"


BOOL IsObjectOnExcludeList(DWORD dwOfs)
{
	if (dwOfs == DIK_PREVTRACK ||
	    dwOfs == DIK_NEXTTRACK ||
	    dwOfs == DIK_MUTE ||
	    dwOfs == DIK_CALCULATOR ||
	    dwOfs == DIK_PLAYPAUSE ||
	    dwOfs == DIK_MEDIASTOP ||
	    dwOfs == DIK_VOLUMEDOWN ||
	    dwOfs == DIK_VOLUMEUP ||
	    dwOfs == DIK_WEBHOME ||
	    dwOfs == DIK_SLEEP ||
	    dwOfs == DIK_WEBSEARCH ||
	    dwOfs == DIK_WEBFAVORITES ||
	    dwOfs == DIK_WEBREFRESH ||
	    dwOfs == DIK_WEBSTOP ||
	    dwOfs == DIK_WEBFORWARD ||
	    dwOfs == DIK_WEBBACK ||
	    dwOfs == DIK_MYCOMPUTER ||
	    dwOfs == DIK_MAIL ||
	    dwOfs == DIK_MEDIASELECT ||
	    dwOfs == DIK_LWIN ||
	    dwOfs == DIK_RWIN ||
	    dwOfs == DIK_POWER ||
	    dwOfs == DIK_WAKE)
		return TRUE;

	return FALSE;
}

BOOL CALLBACK IncrementValPerObject(LPCDIDEVICEOBJECTINSTANCEW lpddoi, LPVOID pvRef)
{
	if (pvRef != NULL)
		++(*((int *)pvRef));
	return DIENUM_CONTINUE;
}

BOOL CALLBACK KeyboardIncrementValPerObject(LPCDIDEVICEOBJECTINSTANCEW lpddoi, LPVOID pvRef)
{
	if (pvRef != NULL && !IsObjectOnExcludeList(lpddoi->dwOfs))
		++(*((int *)pvRef));
	return DIENUM_CONTINUE;
}

BOOL CALLBACK FillDIDeviceObject(LPCDIDEVICEOBJECTINSTANCEW lpddoi, LPVOID pvRef)
{
	if (pvRef == NULL || lpddoi == NULL)
		return DIENUM_CONTINUE;

	DIDEVOBJSTRUCT &os = *((DIDEVOBJSTRUCT *)pvRef);
	assert(os.pdoi != NULL);
	assert(os.n < os.nObjects);
	if (os.pdoi != NULL && os.n < os.nObjects)
		os.pdoi[os.n++] = *lpddoi;

	return DIENUM_CONTINUE;
}

// This is a special EnumObjects() callback for keyboard type devices.  When we enumerate, dwOfs
// member of lpddoi is meaningless.  We need to take the middle 16 bits of dwType as dwOfs
// (also same as DIK_xxx).
BOOL CALLBACK FillDIKeyboardDeviceObject(LPCDIDEVICEOBJECTINSTANCEW lpddoi, LPVOID pvRef)
{
	if (pvRef == NULL || lpddoi == NULL || IsObjectOnExcludeList(lpddoi->dwOfs))
		return DIENUM_CONTINUE;

	DIDEVOBJSTRUCT &os = *((DIDEVOBJSTRUCT *)pvRef);
	assert(os.pdoi != NULL);
	assert(os.n < os.nObjects);
	if (os.pdoi != NULL && os.n < os.nObjects)
	{
		os.pdoi[os.n] = *lpddoi;
		os.pdoi[os.n].dwOfs = os.pdoi[os.n].dwType >> 8;
		wcscpy(os.pdoi[os.n].tszName, lpddoi->tszName);
		++os.n;
	}

	return DIENUM_CONTINUE;
}

HRESULT FillDIDeviceObjectStruct(DIDEVOBJSTRUCT &os, LPDIRECTINPUTDEVICE8W pDID)
{
	if (pDID == NULL)
		return E_FAIL;

	DIDEVICEINSTANCEW didi;
	didi.dwSize = sizeof(didi);
	pDID->GetDeviceInfo(&didi);

	HRESULT hr;
	if (LOBYTE(didi.dwDevType) == DI8DEVTYPE_KEYBOARD)
		hr = pDID->EnumObjects(KeyboardIncrementValPerObject, &os.nObjects,
				DIDFT_AXIS | DIDFT_BUTTON | DIDFT_POV);
	else
		hr = pDID->EnumObjects(IncrementValPerObject, &os.nObjects,
				DIDFT_AXIS | DIDFT_BUTTON | DIDFT_POV);
	if (FAILED(hr))
	{
		os.nObjects = 0;
		return hr;
	}

	if (os.nObjects == 0)
		return S_OK;

	if (os.pdoi != NULL)
		free(os.pdoi);
	os.pdoi = (DIDEVICEOBJECTINSTANCEW *)malloc(sizeof(DIDEVICEOBJECTINSTANCEW) * os.nObjects);
	if (os.pdoi == NULL)
	{
		os.nObjects = 0;
		return E_FAIL;
	}

	// Check if this device is a keyboard. If so, it needs special treatment.
	os.n = 0;
	if ((didi.dwDevType & 0xFF) == DI8DEVTYPE_KEYBOARD)
	{
		hr = pDID->EnumObjects(FillDIKeyboardDeviceObject, &os,
				DIDFT_AXIS | DIDFT_BUTTON | DIDFT_POV);
	} else {
		hr = pDID->EnumObjects(FillDIDeviceObject, &os,
				DIDFT_AXIS | DIDFT_BUTTON | DIDFT_POV);
	}

	if (FAILED(hr))
	{
		os.nObjects = 0;
		return hr;
	}

	assert(os.nObjects == os.n);
	os.nObjects = os.n;

	return S_OK;
}

LPTSTR AllocConfigureFlagStr(DWORD dwFlags)
{
	static const AFS_FLAG flag[] = {
#define f(F) { F, _T(#F) }
		f(DICD_EDIT), f(DICD_DEFAULT)
#undef f
	};
	static const int flags = sizeof(flag) / sizeof(AFS_FLAG);
	return AllocFlagStr(dwFlags, flag, flags);
}

LPTSTR AllocActionFlagStr(DWORD dwFlags)
{
	static const AFS_FLAG flag[] = {
#define f(F) { F, _T(#F) }
		f(DIA_FORCEFEEDBACK),
		f(DIA_APPMAPPED),
		f(DIA_APPNOMAP),
		f(DIA_NORANGE),
#undef f
	}; static const int flags = sizeof(flag) / sizeof(AFS_FLAG);
	return AllocFlagStr(dwFlags, flag, flags);
}

LPTSTR AllocActionHowFlagStr(DWORD dwFlags)
{
	static const AFS_FLAG flag[] = {
#define f(F) { F, _T(#F) }
		f(DIAH_UNMAPPED),
		f(DIAH_USERCONFIG),
		f(DIAH_APPREQUESTED),
		f(DIAH_HWAPP),
		f(DIAH_HWDEFAULT),
		f(DIAH_DEFAULT),
		f(DIAH_ERROR)
#undef f
	}; static const int flags = sizeof(flag) / sizeof(AFS_FLAG);
	return AllocFlagStr(dwFlags, flag, flags);
}

void CleanupActionFormatCopy(DIACTIONFORMATW &c)
{
	if (c.rgoAction != NULL)
	{
		for (DWORD i = 0; i < c.dwNumActions; i++)
			if (c.rgoAction[i].lptszActionName != NULL)
				free((LPTSTR)c.rgoAction[i].lptszActionName);
		free(c.rgoAction);
	}
	c.rgoAction = NULL;
}

HRESULT CopyActionFormat(DIACTIONFORMATW &to, const DIACTIONFORMATW &from)
{
	DWORD i;

	// copy all simple members
	to = from;

	// null copied pointers since we're going to duplicate them (makes sure cleanup works)
	to.rgoAction = NULL;

	// handle pointers/arrays/strings
	to.rgoAction = new DIACTIONW [to.dwNumActions];
	if (to.rgoAction == NULL)
		goto fail;

	// first null it all 
	memset(to.rgoAction, 0, sizeof(DIACTIONW) * to.dwNumActions);

	// now copy...
	for (i = 0; i < to.dwNumActions; i++)
	{
		// copy simple members
		to.rgoAction[i] = from.rgoAction[i];

		// handle pointers/arrays/strings
		to.rgoAction[i].lptszActionName = _wcsdup(from.rgoAction[i].lptszActionName);
		if (to.rgoAction[i].lptszActionName == NULL)
			goto fail;
	}

	return S_OK;
fail:
	CleanupActionFormatCopy(to);
	return E_OUTOFMEMORY;
}

LPDIACTIONFORMATW DupActionFormat(LPCDIACTIONFORMATW lpAcFor)
{
	if (!lpAcFor)
		return NULL;

	LPDIACTIONFORMATW pdup = new DIACTIONFORMATW;
	if (!pdup)
		return NULL;

	if (FAILED(CopyActionFormat(*pdup, *lpAcFor)))
	{
		delete pdup;
		return NULL;
	}

	return pdup;
}

void FreeActionFormatDup(LPDIACTIONFORMATW &lpAcFor)
{
	if (!lpAcFor)
		return;

	CleanupActionFormatCopy(*lpAcFor);
	delete lpAcFor;
	lpAcFor = NULL;
}

void TraceActionFormat(LPTSTR header, const DIACTIONFORMATW &acf)
{
#ifdef CFGUI__TRACE_ACTION_FORMATS
	tracescope(a, header);
	trace(_T("\n"));

	traceDWORD(acf.dwSize);
	traceDWORD(acf.dwActionSize);
	traceDWORD(acf.dwDataSize);
	traceDWORD(acf.dwNumActions);
	{tracescope(b, _T("acf.rgoAction Array\n"));
		for (DWORD i = 0; i < acf.dwNumActions; i++)
		{
			const DIACTIONW &a = acf.rgoAction[i];
			static TCHAR buf[MAX_PATH];
			_stprintf(buf, _T("Action %d\n"), i);
			{tracescope(c, buf);
				traceHEX(a.uAppData);
				traceDWORD(a.dwSemantic);
				LPTSTR str = AllocActionFlagStr(a.dwFlags);
				trace1(_T("a.dwFlags = %s\n"), str);
				free(str);
				traceWSTR(a.lptszActionName);
				traceUINT(a.uResIdString);
				traceDWORD(a.dwObjID);
				traceGUID(a.guidInstance);
				str = AllocActionHowFlagStr(a.dwHow);
				trace1(_T("a.dwHow = %s\n"), str);
				free(str);
			}
		}
	}
	traceGUID(acf.guidActionMap);
	traceDWORD(acf.dwGenre);
	traceDWORD(acf.dwBufferSize);
	traceLONG(acf.lAxisMin);
	traceLONG(acf.lAxisMax);
	traceHEX(acf.hInstString);
	traceHEX(acf.dwCRC);
	traceWSTR(acf.tszActionMap);
#endif
}

BOOL IsZeroOrInvalidColorSet(const DICOLORSET &cs)
{
	if (cs.dwSize < sizeof(DICOLORSET))
		return TRUE;

	const int colors = 8;
	D3DCOLOR color[colors] = {
		cs.cTextFore,
		cs.cTextHighlight,
		cs.cCalloutLine,
		cs.cCalloutHighlight,
		cs.cBorder,
		cs.cControlFill,
		cs.cHighlightFill,
		cs.cAreaFill
	};

	for (int i = 0; i < colors; i++)
		if (color[i])
			return FALSE;

	return TRUE;
}

// D3DCOLOR2COLORREF swaps the blue and red components since GDI and D3D store RGB in the opposite order.
// It also removes the alpha component as the GDI doesn't use that, and including it causes incorrect color.
COLORREF D3DCOLOR2COLORREF(D3DCOLOR c)
{
	LPBYTE pC = (LPBYTE)&c;

	return (COLORREF)((DWORD(*pC) << 16) + (DWORD(*(pC+1)) << 8) + DWORD(*(pC+2)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\diconfig\usefuldi.h ===
//-----------------------------------------------------------------------------
// File: usefuldi.h
//
// Desc: Contains various DInput-specific utility classes and functions
//       to help the UI carry its operations more easily.
//
// Copyright (C) 1999-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#ifndef __USEFULDI_H__
#define __USEFULDI_H__


struct DIDEVOBJSTRUCT {
	DIDEVOBJSTRUCT() : nObjects(0), pdoi(NULL) {}
	~DIDEVOBJSTRUCT() {if (pdoi != NULL) free(pdoi);}
	DWORD GetTypeFromObjID(DWORD);
	int nObjects;
	DIDEVICEOBJECTINSTANCEW *pdoi;
	int n;
};
HRESULT FillDIDeviceObjectStruct(DIDEVOBJSTRUCT &os, LPDIRECTINPUTDEVICE8W pDID);

LPTSTR AllocConfigureFlagStr(DWORD dwFlags);
LPTSTR AllocActionFlagStr(DWORD dwFlags);
LPTSTR AllocActionHowFlagStr(DWORD dwFlags);

void CleanupActionFormatCopy(DIACTIONFORMATW &c);
HRESULT CopyActionFormat(DIACTIONFORMATW &to, const DIACTIONFORMATW &from);
LPDIACTIONFORMATW DupActionFormat(LPCDIACTIONFORMATW lpAcFor);
void FreeActionFormatDup(LPDIACTIONFORMATW &lpAcFor);

void TraceActionFormat(LPTSTR header, const DIACTIONFORMATW &acf);

BOOL IsZeroOrInvalidColorSet(const DICOLORSET &);
COLORREF D3DCOLOR2COLORREF(D3DCOLOR c);


#endif //__USEFULDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dimapcfg\dimaptst.h ===
//===========================================================================
// dimaptst.h
//
// History:
//  08/19/1999 - davidkl - created
//===========================================================================

#ifndef _DIMAPTST_H
#define _DIMAPTST_H

//---------------------------------------------------------------------------

#include <windows.h>
#include <commctrl.h>
#include <dinput.h>
#include "dmterror.h"
#include "debug.h"
#include "resource.h"

//---------------------------------------------------------------------------

// app global variables
extern HINSTANCE        ghinst;
extern HANDLE           ghEvent;
extern CRITICAL_SECTION gcritsect;

//JJ FIX
extern UINT_PTR			g_NumSubGenres;
//---------------------------------------------------------------------------

// custom window messages
#define WM_DMT_UPDATE_LISTS         WM_USER+1
#define WM_DMT_FILE_SAVE            WM_USER+3

//---------------------------------------------------------------------------

#define GENRES_INI              ".\\genre.ini"

//---------------------------------------------------------------------------

#define DMT_DI_STRING_VER       "0x800"

//---------------------------------------------------------------------------

#define ID_POLL_TIMER           97
#define DMT_POLL_TIMEOUT        100

//---------------------------------------------------------------------------

#define NUM_DISPBTNS            32

//---------------------------------------------------------------------------

#ifndef COUNT_ARRAY_ELEMENTS
#define COUNT_ARRAY_ELEMENTS(a) (sizeof(a) / sizeof(a[0]))
#endif

//---------------------------------------------------------------------------

#define MAX_ACTION_ID_STRING    MAX_PATH

//---------------------------------------------------------------------------

#define DMT_GENRE_MASK          0xFF000000
#define DMT_ACTION_MASK         0x000000FF

//---------------------------------------------------------------------------

// control type IDs
#define DMTA_TYPE_AXIS          0
#define DMTA_TYPE_BUTTON        1
#define DMTA_TYPE_POV           2
#define DMTA_TYPE_UNKNOWN       0xFFFFFFFF

//---------------------------------------------------------------------------

typedef struct _actionname
{
    DWORD   dw;
    char    sz[MAX_PATH];

} ACTIONNAME, *PACTIONNAME;

//---------------------------------------------------------------------------

//===========================================================================
// GUID_DIMapTst
//
// GUID uniquely identifying our application
//
// DDK App:
// {87480CC9-C186-4270-914B-CF9EC33839CA}
// SDK App:
// {87480CCA-C186-4270-914B-CF9EC33839CA}
// Internal App:
// {87480CCB-C186-4270-914B-CF9EC33839CA}
//===========================================================================
#ifdef DDKAPP
    DEFINE_GUID(GUID_DIMapTst, 
    0x87480cc9, 0xc186, 0x4270, 0x91, 0x4b, 0xcf, 0x9e, 0xc3, 0x38, 0x39, 0xca);
#else
    DEFINE_GUID(GUID_DIMapTst, 
    0x87480ccb, 0xc186, 0x4270, 0x91, 0x4b, 0xcf, 0x9e, 0xc3, 0x38, 0x39, 0xca);
#endif

//===========================================================================
// GUID_DIConfigAppEditLayout
//
// Make IDirectInput8::ConfigureDevices() launch in "edit mode"
//
// {FD4ACE13-7044-4204-8B15-095286B12EAD}
//===========================================================================
DEFINE_GUID(GUID_DIConfigAppEditLayout, 
0xfd4ace13, 0x7044, 0x4204, 0x8b, 0x15, 0x09, 0x52, 0x86, 0xb1, 0x2e, 0xad);

//---------------------------------------------------------------------------

#ifdef DDKAPP
    #define DMT_APP_CAPTION "DirectInput Mapper Device Configuration Tool"
#else
    #define DMT_APP_CAPTION "DirectInput Mapper Test Tool - MICROSOFT INTERNAL BUILD"
#endif

//---------------------------------------------------------------------------

//===========================================================================
// DMTDEVICEOBJECT_NODE
// PDMTDEVICEOBJECT_NODE
//
// Linked list node for DirectInput device objects (buttons, axes, povs)
//
// Struct contents:
//  DMTDEVICEOBJECT_NODE    *pNext              - next device object in the 
//                                              list
//  char                    szName              - display name of the device 
//                                              object (ANSI string)
//  DWORD                   dwObjectType        - type (axis, button, pov)
//  DWORD                   dwObjectOffset      - offset into the device data 
//                                              format
//  WORD                    wUsagePage          - HID usage page
//  WORD                    wUsage              - HID usage
//  GUID                    guidDeviceInstance  - parent device's instance
//                                              GUID
//  WORD                    wCtrlId             - "identifier" for integrated 
//                                              test UI control
//
//===========================================================================
typedef struct _dmtdeviceobject_node
{
    struct _dmtdeviceobject_node    *pNext;
    
    char                            szName[MAX_PATH];
    DWORD                           dwObjectType;
    DWORD                           dwObjectOffset;
    
    WORD                            wUsagePage;
    WORD                            wUsage;

    GUID                            guidDeviceInstance;
    WORD                            wCtrlId;

} DMTDEVICEOBJECT_NODE, *PDMTDEVICEOBJECT_NODE;

//===========================================================================
// DMTDEVICE_NODE
// PDMTDEVICE_NODE
//
// Linked list node for DirectInput devices
//
// Struct contents:
//  DMTDEVICE_NODE          *pNext          - next device in the list
//  char                    szName          - display name of the device 
//                                          (ANSI string)
//  char                    szShorthandName - 
//  WORD                    wVendorId       - vendor id
//  WORD                    wProductId      - product id
//  DMTDEVICEOBJECT_NODE    *pObjectList    - list of device controls
//  char                    szFileTitle     - 
//
//===========================================================================
typedef struct _dmtdevice_node
{
    struct _dmtdevice_node  *pNext;
    
    IDirectInputDevice8A    *pdid;
    char                    szName[MAX_PATH];
    char                    szShorthandName[MAX_PATH];
    WORD                    wVendorId;
    WORD                    wProductId;
    GUID                    guidInstance;
    DWORD                   dwDeviceType;
    BOOL                    fPolled;
    char                    szProductName[MAX_PATH];

    DWORD                   dwAxes;
    DWORD                   dwButtons;
    DWORD                   dwPovs;

    DMTDEVICEOBJECT_NODE    *pObjectList;

    char                    szFilename[MAX_PATH];

} DMTDEVICE_NODE, *PDMTDEVICE_NODE;

//===========================================================================
// DMTMAPPING_NODE
// PDMTMAPPING_NODE
//
// Linked list node for action maps
//
// Struct contents:
//  DMTMAPPING_NODE *pNext          - next mapping in the list
//  GUID            guidInstance    - device's instance guid
//  BOOL            fChanged        - has this data changed?
//                                  (this gets set to FALSE on load & save)
//  DIACTIONA       *pdia           - array of DIACTIONA structures
//  UINT            uActions        - number of actions referenced by pdia
//
//===========================================================================
typedef struct _dmtmapping_node
{
    struct _dmtmapping_node *pNext;

    GUID                    guidInstance;

    BOOL                    fChanged;

    DIACTIONA               *pdia;
    UINT                    uActions;

} DMTMAPPING_NODE, *PDMTMAPPING_NODE;

//===========================================================================
// DMTACTION_NODE
// PDMTACTION_NODE
//
// Linked list node for DirectInput Mapper actions
//
// Struct contents:
//  DMTACTION_NODE  *pNext      - next action in the list
//  char            szName      - name of the action (ANSI string)
//  DWORD           dwType      - action type (button, axis, pov)
//  DWORD           dwPriority  - priority level of control mapping
//  DWORD           dwActionId  - ID as defined by DirectInput
//  char            szActionId  - text representation of action ID (ANSI 
//                              string)
//
//===========================================================================
typedef struct _dmtaction_node
{
    struct _dmtaction_node  *pNext;

    char                    szName[MAX_PATH];
    DWORD                   dwType;
    DWORD                   dwPriority;
    DWORD                   dwActionId;
    char                    szActionId[MAX_ACTION_ID_STRING];

} DMTACTION_NODE, *PDMTACTION_NODE;


//=====